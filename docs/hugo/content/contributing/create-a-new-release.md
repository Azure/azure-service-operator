---
title: Creating a new release
---

1. Ensure that the [controller CVE scan action](https://github.com/Azure/azure-service-operator/actions/workflows/scan-controller-image.yaml) is green.
2. Ensure that the [pre-release upgrade tests](https://github.com/Azure/azure-service-operator/actions/workflows/pre-release-tests.yaml) are passing.
3. Ensure that [experimental release](https://github.com/Azure/azure-service-operator/releases/tag/experimental) passed on the most recent commit.
4. Go to the [releases](https://github.com/Azure/azure-service-operator/releases) page and draft a new release.
5. In the tag dropdown, type the name of the new tag you'd like to create (it should match the pattern of previous releases tags, for example: `v2.10.0`). The release target should be `main` (the default).
6. Use the GitHub "auto-generate release notes" button to generate a set of release notes to work with. You will need to clean this up quite a bit before actually publishing it.
7. Write a "Release Notes" section. You can edit the autogenerated section as a start. You can also look through the commits between the last release and now: 

   ``` bash
   git log v2.4.0..main
   ```

8. Publish the release. This will automatically trigger a GitHub action to build and publish an updated Docker image with the latest manager changes.
9. Ensure that the action associated with your release finishes successfully.
10. [Update our documentation](#update-resource-documentation) to move resources listed under "Next Release" to the heading "Released".
11. [Update the ROADMAP](#update-roadmap) to reflect the new release.
12. [Update Breaking Changes](#update-breaking-changes) if there are any.

## Catalog breaking changes

There may be breaking changes in a new release of ASO, either due to changes we made or changes made in the upstream
service Swagger specifications. We must validate each breaking change so that we can notify customers about it.

1. Download the CRD definitions for the prior release (in this example, v2.5.0):

   ``` bash
   wget https://github.com/Azure/azure-service-operator/releases/download/v2.6.0/azureserviceoperator_customresourcedefinitions_v2.6.0.yaml
   ```

2. Download the CRD definitions for the new release (in this example, v2.6.0):

   ``` bash
   wget https://github.com/Azure/azure-service-operator/releases/download/v2.7.0/azureserviceoperator_customresourcedefinitions_v2.7.0.yaml
   ```

   This will only be available when the GitHub action triggered by publishing the release has finished.

3. Produce a diff between these files and examine it.

   ``` bash
   diff -u <old> <new> > comparison.diff
   ```

## Testing

Perform a simple smoke test to make sure the new release is capable of starting up and creating some Azure resources.

1. Ensure you have the following environment variables exported:
   * AZURE_SUBSCRIPTION_ID
   * AZURE_TENANT_ID

2. Create a kind cluster
   ``` bash
   task controller:kind-create-wi
   ```

3. Enable workload identity on that cluster:
   ```
   task controller:create-mi-for-workload-identity
   ```

4. Install cert-manager
   ``` bash
   task controller:install-cert-manager
   ```

5. Create the namespace for the operator
   ``` bash
   kubectl create namespace azureserviceoperator-system
   ```

6. Create a secret in your cluster with the Workload Identity credentials for ASO to use:
   ``` bash
   task controller:make-workload-identity-secret
   ```

7. Download asoctl

   ``` bash 
   curl -L https://github.com/Azure/azure-service-operator/releases/latest/download/asoctl-linux-amd64.gz -o asoctl.gz
   gunzip asoctl.gz
   chmod +x asoctl
   ```

8. Use asoctl to install the new release

   ``` bash
   ./asoctl export template --version v2.7.0 --crd-pattern "resources.azure.com/*;network.azure.com/*" | kubectl apply -f -
   ```

9. Watch while ASO starts
   ``` bash
   kubectl get all -n azureserviceoperator-system
   ```

10. Create a resource group and a vnet in it (the vnet is to check that conversion webhooks are working, since there aren't any for RGs):

    ``` bash
    kubectl apply -f v2/samples/resources/v1api/v1api20200601_resourcegroup.yaml
    kubectl apply -f v2/samples/network/v1api20240301/v1api20240301_virtualnetwork.yaml
    ```
11. Make sure they deploy successfully - check in the portal as well.

## Create and test the Helm chart

{{% alert title="Note" %}}
A PR that does this should be automatically generated when a new release is published.
These steps are documented here in case that process fails.
{{% /alert %}}

### Update the chart

1. Create a new branch from `<NEW_RELEASE_TAG>` HEAD
2. Generate helm manifest for new release: `task controller:package-helm-manifest`
3. Check the version in `/v2/charts/azure-service-operator/Chart.yaml` if matches with the latest release tag.

### Test the updated chart

1. Create a kind cluster with the chart installed
   ``` bash
   task controller:kind-create-workloadidentity-local-helm
   ```
2. Wait for it all to start: `k get all -n azureserviceoperator-system`
3. Create a resource group and a vnet in it (the vnet is to check that conversion webhooks are working, since there aren't any for RGs):
    ```
    k apply -f v2/samples/resources/v1api/v1api20200601_resourcegroup.yaml
    k apply -f v2/samples/network/v1api20201101/v1api20201101_virtualnetwork.yaml
    ```
4. Make sure they deploy successfully - check in the portal as well.
5. If installed successfully, commit the files under `v2/charts/azure-service-operator`.
6. Send a PR.

## Update Resource Documentation

Any resources included in the new release will currently be listed under "Next Release" in the documentation, so we need to update the documentation to move them to the "Released" section.

1. Create a new branch from `main` and check it out.
2. Update the setting `supportedResourcesReport.currentRelease` to the new release in `v2/azure-arm.yaml` 
3. Run `task controller:generate-types` to update the documentation.
4. Repeat the above steps by modifying `hack/crossplane/azure-crossplane.yml` and running `task crossplane:generate-types`.
5. Commit the changes and send a PR.

## Update ROADMAP

Modify the `ROADMAP.md` file in the repo root.

* Add the new release to the _Prior Releases_ section, linking to the release in GitHub.
* Remove the new release from the _Release Cadence & Planning_ section and add a new future release to the end.
* Check that future versions are linked to the relevant GitHub milestone where possible.

Then commit the changes and send a PR.

## Update Breaking Changes

If you earlier [catalogued breaking changes](#catalog-breaking-changes), or if there are any PRs for this release with the tag [**breaking**](https://github.com/Azure/azure-service-operator/pulls?q=is%3Apr+label%3Abreaking+is%3Aclosed), create a new page under our [breaking changes]( {{< relref "breaking-changes" >}} ) page with details of the breaking changes and how to mitigate them.
  
## Fixing an incorrect release

If there was an issue publishing a new release, we may want to delete the existing release and try again. 
Only do this if you've just published the release and there is something wrong with it. We shouldn't be deleting releases people are actually using. 

1. Delete the release in the [releases](https://github.com/Azure/azure-service-operator/releases) page.
2. Delete the tag: `git push <origin> --delete <tag>`, for example `git push origin --delete v2.0.0-alpha.1`.

At this point, you can safely publish a "new" release with the same name.
