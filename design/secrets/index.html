<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Azure Service Operator support for managing data plane secrets #  What secrets are we talking about? #  The secrets discussed in this document are associated with accessing the data plane of various services.
Think: Accessing a StorageAccount via Shared Key, accessing a MySQLServer by admin Username and Password, or accessing a VM by SSHKey.
Sometimes these secrets may be used by other CRDs managed by ASO, as would be the case for a MySQLUser CRD, but often the consumers of these secrets are the users applications.">
<meta name="theme-color" content="#FFFFFF">
<meta name="color-scheme" content="light dark"><meta property="og:title" content="" />
<meta property="og:description" content="Azure Service Operator support for managing data plane secrets #  What secrets are we talking about? #  The secrets discussed in this document are associated with accessing the data plane of various services.
Think: Accessing a StorageAccount via Shared Key, accessing a MySQLServer by admin Username and Password, or accessing a VM by SSHKey.
Sometimes these secrets may be used by other CRDs managed by ASO, as would be the case for a MySQLUser CRD, but often the consumers of these secrets are the users applications." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://azure.github.io/azure-service-operator/design/secrets/" /><meta property="article:section" content="design" />



<title>Secrets | Azure Service Operator</title>
<link rel="manifest" href="/azure-service-operator/manifest.json">
<link rel="icon" href="/azure-service-operator/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/azure-service-operator/book.min.46181bc93375ba932026e753b37c40e6ff8bb16a9ef770c78bcc663e4577b1ba.css" integrity="sha256-RhgbyTN1upMgJudTs3xA5v&#43;LsWqe93DHi8xmPkV3sbo=" crossorigin="anonymous">
  <script defer src="/azure-service-operator/flexsearch.min.js"></script>
  <script defer src="/azure-service-operator/en.search.min.a8a1c225b0d05654c3a5b2d9d878c95764abfa5ce625b42ded58e75b5ba4b455.js" integrity="sha256-qKHCJbDQVlTDpbLZ2HjJV2Sr&#43;lzmJbQt7VjnW1uktFU=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/azure-service-operator/"><span>Azure Service Operator</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>












  

  



  
  <ul>
    
      
        <li>
          
  
  

  
    <span>User’s Guide</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://azure.github.io/azure-service-operator/introduction/annotations/" class="">Annotations</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://azure.github.io/azure-service-operator/introduction/authentication/" class="">Authentication</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://azure.github.io/azure-service-operator/introduction/conditions/" class="">Conditions</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://azure.github.io/azure-service-operator/introduction/diagnosing-problems/" class="">Diagnosing Problems</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://azure.github.io/azure-service-operator/introduction/multitenant-deployment/" class="">Multitenant Deployment</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://azure.github.io/azure-service-operator/introduction/resources/" class="">Resources</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://azure.github.io/azure-service-operator/introduction/tutorial-cosmosdb/" class="">Tutorial: CosmosDB to-do List</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://azure.github.io/azure-service-operator/introduction/tutorial-postgresql/" class="">Tutorial: PostgreSQL Votes</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>For Contributors</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://azure.github.io/azure-service-operator/contributing/contributing/" class="">Contributing</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://azure.github.io/azure-service-operator/contributing/add-a-new-code-generated-resource/" class="">Add a New Code Generated Resource</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://azure.github.io/azure-service-operator/contributing/create-a-new-release/" class="">Create a New Release</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://azure.github.io/azure-service-operator/contributing/generator-overview/" class="">Generator Overview</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>Design &amp; Specifications</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://azure.github.io/azure-service-operator/design/clarifying-object-structure/" class="">Clarifying Object Structure</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://azure.github.io/azure-service-operator/design/crossplane/" class="">Crossplane</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://azure.github.io/azure-service-operator/design/defaulter-validator/" class="">Defaulter Validator</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://azure.github.io/azure-service-operator/design/resource-states/" class="">Resource States</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://azure.github.io/azure-service-operator/design/secrets/" class=" active">Secrets</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://azure.github.io/azure-service-operator/design/type-references-and-ownership/" class="">Type References and Ownership</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://azure.github.io/azure-service-operator/design/versioning/" class="">Versioning</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <span>Case Studies</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://azure.github.io/azure-service-operator/design/versioning/case-studies/chained-storage-versions/" class="">Chained Storage Versions</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://azure.github.io/azure-service-operator/design/versioning/case-studies/fixed-storage-version/" class="">Fixed Storage Version</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://azure.github.io/azure-service-operator/design/versioning/case-studies/rolling-storage-versions/" class="">Rolling Storage Versions</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://azure.github.io/azure-service-operator/architecture-decision-records/" class="">Architecture Decision Records</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://azure.github.io/azure-service-operator/architecture-decision-records/adr-2021-02-property-conversions/" class="">2021-02: Property Conversions</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://azure.github.io/azure-service-operator/architecture-decision-records/adr-2020-11-abstract-syntax-trees/" class="">2020-11: AST Library Choice</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://azure.github.io/azure-service-operator/architecture-decision-records/adr-2020-07-pipeline-architecture/" class="">2020-07: Pipeline Architecture</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://azure.github.io/azure-service-operator/architecture-decision-records/adr-2020-04-code-generation/" class="">2020-04: Why Code Generation?</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://azure.github.io/azure-service-operator/architecture-decision-records/adr-2021-06-api-version-recovery/" class="">Adr 2021 06 API Version Recovery</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://azure.github.io/azure-service-operator/architecture-decision-records/adr-2022-01-reconciler-extensions/" class="">Adr 2022 01 Reconciler Extensions</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>















</nav>




  <script>(function(){var a=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/azure-service-operator/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>Secrets</strong>

  <label for="toc-control">
    
    <img src="/azure-service-operator/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#what-secrets-are-we-talking-about">What secrets are we talking about?</a></li>
    <li><a href="#goals">Goals</a>
      <ul>
        <li><a href="#aso-should-not-be-generating-secrets-on-the-users-behalf">ASO should not be generating secrets on the users behalf</a></li>
        <li><a href="#prefer-managed-identity">Prefer Managed Identity</a></li>
        <li><a href="#work-well-with-gitops">Work well with GitOps</a></li>
      </ul>
    </li>
    <li><a href="#kinds-of-secrets">Kinds of secrets</a>
      <ul>
        <li><a href="#sample-resources-that-have-secrets">Sample resources that have secrets</a></li>
        <li><a href="#other-kinds-of-secrets-in-azure">Other kinds of secrets in Azure:</a></li>
      </ul>
    </li>
    <li><a href="#other-operators">Other Operators</a>
      <ul>
        <li><a href="#crossplane">Crossplane</a></li>
        <li><a href="#aws-controller-for-kubernetes-ack">AWS Controller for Kubernetes (ACK)</a></li>
      </ul>
    </li>
    <li><a href="#proposal">Proposal</a>
      <ul>
        <li><a href="#user-specified-secrets">User specified secrets</a></li>
        <li><a href="#azure-generated-secrets">Azure generated secrets</a></li>
        <li><a href="#other-kinds-of-secrets">Other kinds of secrets</a></li>
        <li><a href="#a-special-note-on-keyvault">A special note on KeyVault</a></li>
      </ul>
    </li>
    <li><a href="#integrations">Integrations</a></li>
    <li><a href="#supported-secret-stores">Supported secret stores</a></li>
    <li><a href="#implementation-plan">Implementation plan</a>
      <ul>
        <li><a href="#input-secrets">Input secrets</a></li>
        <li><a href="#output-secrets">Output secrets</a></li>
      </ul>
    </li>
    <li><a href="#testing">Testing</a>
      <ul>
        <li><a href="#unit-testing">Unit testing</a></li>
        <li><a href="#end-to-end-testing">End to end testing</a></li>
      </ul>
    </li>
    <li><a href="#related-issues">Related issues</a></li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="azure-service-operator-support-for-managing-data-plane-secrets">
  Azure Service Operator support for managing data plane secrets
  <a class="anchor" href="#azure-service-operator-support-for-managing-data-plane-secrets">#</a>
</h1>
<h2 id="what-secrets-are-we-talking-about">
  What secrets are we talking about?
  <a class="anchor" href="#what-secrets-are-we-talking-about">#</a>
</h2>
<p>The secrets discussed in this document are associated with accessing the data plane of various services.</p>
<p>Think: Accessing a <code>StorageAccount</code> via Shared Key, accessing a <code>MySQLServer</code> by admin <code>Username</code> and <code>Password</code>, or accessing a VM
by <code>SSHKey</code>.</p>
<p><em>Sometimes</em> these secrets may be used by other CRDs managed by ASO, as would be the case for a <code>MySQLUser</code> CRD, but often the consumers of these
secrets are the users applications.</p>
<h2 id="goals">
  Goals
  <a class="anchor" href="#goals">#</a>
</h2>
<h3 id="aso-should-not-be-generating-secrets-on-the-users-behalf">
  ASO should not be generating secrets on the users behalf
  <a class="anchor" href="#aso-should-not-be-generating-secrets-on-the-users-behalf">#</a>
</h3>
<p>ASO v1 generated secrets on the users behalf in some cases. The users had access to the generated secret as ASO wrote it into a Kubernetes (or KeyVault)
secret.</p>
<p>There are problems with this approach:</p>
<ol>
<li>It makes performing secret rollover more difficult. If the user had specified the secret, rollover is as easy as modifying the specified secret, which
triggers a reconcile, which triggers a PUT to the Azure Resource updating the secret. If the operator generated the secret then the user must somehow
issue an instruction to us to perform an action to roll the secret, which doesn&rsquo;t fit as well into the goal-seeking paradigm Kubernetes prefers.</li>
<li>It takes control away from the user. What if the secret the operator generates doesn&rsquo;t comply with a particular organizations complexity requirements?</li>
<li>It requires that we do a <em>very</em> good job generating cryptographically secure passwords/secrets. This could easily become a can of worms.</li>
<li>It hinders adoption of existing resources. If the operator expects to always generate the secret for a SQL DB, but the user wants to import a SQL DB
they&rsquo;ve already created through some other mechanism, then they are at an impasse as there is no (easy) way for them to provide ASO with the secret.</li>
<li>It doesn&rsquo;t work well with GitOps. A number of customers have expressed the desire to move resources between namespaces. In theory this is easy -
just create the exact same resources in a different namespace (pointing at the same Azure resources), mark the old resources as <code>skip-deletion</code> (so that
the backing Azure resources are not deleted), and delete the original namespace. If the definition of the secret isn&rsquo;t part of the users GitOps flow this
becomes more difficult as the first namespace has  the secret (which was created by ASO) and that secret must be cloned manually to the second namespace,
otherwise the creation of the resource in the second namespace will attempt to generate a new secret.</li>
</ol>
<p>We could investigate allowing both automatically generated secrets (the default) and user specified secrets (opt-in). That avenue results in the operator
shouldering all of the complexity burden of both though.</p>
<p>Given ASO&rsquo;s approach as a low level toolkit providing the ability to create Azure resources, at least
at this time we should avoid the added complexity of generating user secrets.</p>
<h3 id="prefer-managed-identity">
  Prefer Managed Identity
  <a class="anchor" href="#prefer-managed-identity">#</a>
</h3>
<p>Managing secrets is hard. We should prefer AAD Authentication and Managed Identity where possible.</p>
<p>What this means in practice is that secrets should not be retrieved <strong>unless the user has specifically asked for them to be</strong>.</p>
<p>This has a number of advantages:</p>
<ol>
<li>If the user <em>is</em> using Managed Identity, they don&rsquo;t have a secret leak waiting to happen created in their namespace which they didn&rsquo;t ask about
(and might not even know about).</li>
<li>We can make a failing <code>ListKeys</code> (or equivalent) call fatal. Many services support ways lock down or forbid access to the <code>ListKeys</code> (or equivalent) API.
This allows users to block access if they would like to require AAD authentication with their resource. As long as the operator is not calling those APIs
unless asked (in the <code>Spec</code> of the resource) we can make their failure fatal. This gives users an easy way to drive towards full AAD usage in ASO and elsewhere.</li>
</ol>
<p>We&rsquo;ll dig more into how we might accomplish this a bit later.</p>
<h3 id="work-well-with-gitops">
  Work well with GitOps
  <a class="anchor" href="#work-well-with-gitops">#</a>
</h3>
<p>Resources should strive to play well with GitOps. This means that when a new resource is deployed it is capable of adopting an already existing ARM resource
if one exists. This also must apply to secrets. As mentioned above one of the reasons that
<a href="#aso-should-not-be-generating-secrets-on-the-users-behalf">we do not want to be generating secrets on the users behalf</a> is that it makes redeploy
and resource adoption hard because the user has no configuration representing the generated secret.</p>
<h2 id="kinds-of-secrets">
  Kinds of secrets
  <a class="anchor" href="#kinds-of-secrets">#</a>
</h2>
<p>There are two main types of secrets we need to consider, differing primarily by the origin of the secret.</p>
<p><strong>User provided secrets</strong>: Secrets provided by the user at resource creation time.</p>
<p><strong>Azure generated secrets</strong>: Secrets created by Azure, and returned by a special <code>GetMeTheSecrets</code> API call.</p>
<h3 id="sample-resources-that-have-secrets">
  Sample resources that have secrets
  <a class="anchor" href="#sample-resources-that-have-secrets">#</a>
</h3>
<p>Below is a table containing a sampling of resources with secrets that ASO already supports or has a plan to support in the near future.</p>
<table>
<thead>
<tr>
<th>CRD</th>
<th>User provided secrets</th>
<th>Azure generated secrets</th>
<th>AAD/Managed Identity Support</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>VirtualMachineScaleSet</td>
<td>✔️</td>
<td>❌</td>
<td>❌</td>
<td><code>Username</code> and <code>Password</code>. Can be modified by subsequent PUT.</td>
</tr>
<tr>
<td>VirtualMachine</td>
<td>✔️</td>
<td>❌</td>
<td>❌</td>
<td><code>Username</code> and <code>Password</code>. Can be modified by subsequent PUT.</td>
</tr>
<tr>
<td>PostgreSQL FlexibleServer</td>
<td>✔️</td>
<td>❌</td>
<td>✔️</td>
<td><code>AdministratorLogin</code> and <code>AdministratorLoginPassword</code>. Must have even if using AAD. Can be modified by subsequent PUT.</td>
</tr>
<tr>
<td>MySQL FlexibleServer</td>
<td>✔️</td>
<td>❌</td>
<td>✔️</td>
<td><code>AdministratorLogin</code> and <code>AdministratorLoginPassword</code>. Must have even if using AAD. Can be modified by subsequent PUT.</td>
</tr>
<tr>
<td>StorageAccount</td>
<td>❌</td>
<td>✔️</td>
<td>✔️</td>
<td><a href="https://docs.microsoft.com/rest/api/storagerp/storage-accounts/list-keys">List Keys API</a> and <a href="https://docs.microsoft.com/en-us/rest/api/storagerp/storage-accounts/regenerate-key">Regenerate Keys API</a>. AAD+RBAC (blob/table only?) <a href="https://docs.microsoft.com/en-us/azure/storage/blobs/authorize-access-azure-active-directory">Authorizing Access with Active Directory</a>.</td>
</tr>
<tr>
<td>CosmosDB DatabaseAccount</td>
<td>❌</td>
<td>✔️</td>
<td>✔️</td>
<td><a href="https://docs.microsoft.com/en-us/rest/api/cosmos-db-resource-provider/2021-04-15/database-accounts/list-keys">List Keys API</a>, <a href="https://docs.microsoft.com/en-us/rest/api/cosmos-db-resource-provider/2021-04-15/database-accounts/list-read-only-keys">List Read Only Keys</a> and <a href="https://docs.microsoft.com/en-us/rest/api/cosmos-db-resource-provider/2021-04-15/database-accounts/regenerate-key">Regenerate Key API</a>. For AAD+RBAC (supported by SQL only?), see <a href="https://docs.microsoft.com/en-us/azure/cosmos-db/how-to-setup-rbac#disable-local-auth">Disabling Local Auth</a>, <a href="https://docs.microsoft.com/en-us/rest/api/cosmos-db-resource-provider/2021-04-15/sql-resources/create-update-sql-role-assignment">Create Role Assignment API</a>, <a href="https://docs.microsoft.com/en-us/rest/api/cosmos-db-resource-provider/2021-04-15/sql-resources/create-update-sql-role-definition">Create Role Definition API</a>. <a href="https://docs.microsoft.com/en-us/azure/cosmos-db/how-to-setup-rbac#built-in-role-definitions">Built-in Role Definitions</a>.</td>
</tr>
<tr>
<td>EventHubAuthorizationRules</td>
<td>❌</td>
<td>✔️</td>
<td>❌</td>
<td><a href="https://docs.microsoft.com/en-us/rest/api/eventhub/stable/authorization-rules-event-hubs/list-keys">List Keys API</a>. There are default authorization rules created, such as <code>RootManageSharedAccessKey</code>. Supports <a href="https://docs.microsoft.com/en-us/rest/api/eventhub/preview/event-hubs-authorization-rules/regenerate-keys">regeneration</a>.</td>
</tr>
<tr>
<td>Redis</td>
<td>❌</td>
<td>✔️</td>
<td>❌</td>
<td><a href="https://docs.microsoft.com/en-us/rest/api/redis/redis/list-keys">List Keys API</a>. <a href="https://docs.microsoft.com/en-us/rest/api/redis/redis/regenerate-key">Regenerate Key API</a>. <!-- raw HTML omitted --></td>
</tr>
</tbody>
</table>
<h3 id="other-kinds-of-secrets-in-azure">
  Other kinds of secrets in Azure:
  <a class="anchor" href="#other-kinds-of-secrets-in-azure">#</a>
</h3>
<p>There are a few other types of secrets in Azure in addition to the two main ones discussed above.</p>
<ol>
<li><strong>Get once Azure generated secrets:</strong> These are secrets created by Azure and <em>only returned once</em>, usually as the response to a POST.
These don&rsquo;t fit cleanly into the table above because they are a POST action on a parent resource these are not in fact resources themselves.
<ol>
<li>Application Insights Component APIKey: This is a POST to the Component/ApiKey URL.</li>
<li>KeyVault Key: <a href="https://docs.microsoft.com/en-us/rest/api/keyvault/create-key/create-key">Create Key API</a>.</li>
</ol>
</li>
<li><strong>&ldquo;Secrets&rdquo; created by Azure, and returned in the GET:</strong> In almost all cases (all that I have seen), a secret in Azure is not returned by a GET.
&ldquo;Secrets&rdquo; returned in a GET are not really secrets per-se, but ASOv1 classifies them as secrets.
<ol>
<li><code>ApplicationInsights</code> <code>InstrumentationKey</code> or <code>ConnectionString</code>?
See <a href="https://docs.microsoft.com/en-us/rest/api/application-insights/components/create-or-update#applicationinsightscomponent">here</a>.</li>
</ol>
</li>
<li><strong>Short-lived &ldquo;tokens&rdquo;</strong>
<ol>
<li><code>StorageAccount</code> SAS</li>
<li><code>CosmosDB</code> ResourceToken.</li>
</ol>
</li>
</ol>
<h2 id="other-operators">
  Other Operators
  <a class="anchor" href="#other-operators">#</a>
</h2>
<p>A quick look at what other operators are doing with regard to secrets.</p>
<h3 id="crossplane">
  Crossplane
  <a class="anchor" href="#crossplane">#</a>
</h3>
<p><strong>Azure generated secrets</strong>: A
<a href="https://doc.crds.dev/github.com/crossplane/provider-azure/database.azure.crossplane.io/CosmosDBAccount/v1alpha3@v0.17.0#spec-writeConnectionSecretToRef">Connection secret</a>
stores information needed to connect to the resource, including keys generated by Azure
(see for example <a href="https://github.com/crossplane/provider-azure/blob/faab5b58ea2cef6a2d1afbebb3c1a8943e72248e/pkg/controller/storage/account/account.go#L347">Storage Account</a>).
This is a <a href="https://github.com/crossplane/crossplane-runtime/blob/6a7a44ac50aa1caca20a3cb5c215e6c03dc2b58e/pkg/resource/resource.go#L131">standard pattern</a>
used across all of the providers.</p>
<p>The destination of the <code>writeConnectionSecretToRef</code> is currently always a Kubernetes secret, but there is an <a href="https://github.com/crossplane/crossplane/issues/2366">open issue</a>
requesting pluggable secret stores.</p>
<p><strong>User provided secrets</strong> seem to be
<a href="https://github.com/crossplane/provider-azure/blob/f37af6dd4f9d7d10a14caf8270d38078aee06bbe/pkg/controller/database/mysqlserver/managed.go#L157">automatically generated</a>
by Crossplane.</p>
<h3 id="aws-controller-for-kubernetes-ack">
  AWS Controller for Kubernetes (ACK)
  <a class="anchor" href="#aws-controller-for-kubernetes-ack">#</a>
</h3>
<p><strong>User provided secrets</strong> are provided via a <a href="https://github.com/aws-controllers-k8s/runtime/blob/main/apis/core/v1alpha1/secret.go">SecretKeyRef</a>.
This allows cross-namespace references to a secret. The specific <code>Key</code> of the secret is selected with a <code>Key string</code> parameter.</p>
<p>It looks like there may <a href="https://github.com/aws-controllers-k8s/community/issues/700">not currently be support</a> for key updates/rollover.</p>
<p><strong>AWS generated secrets</strong> I can&rsquo;t find any examples of. They do not seem to classify &ldquo;endpoints&rdquo; as a secret, as shown by
<a href="https://aws-controllers-k8s.github.io/community/reference/opensearchservice/v1alpha1/domain/">opensearchservice endpoint</a> and
<a href="https://aws-controllers-k8s.github.io/community/reference/eks/v1alpha1/cluster/">cluster endpoint</a>.</p>
<h2 id="proposal">
  Proposal
  <a class="anchor" href="#proposal">#</a>
</h2>
<h3 id="user-specified-secrets">
  User specified secrets
  <a class="anchor" href="#user-specified-secrets">#</a>
</h3>
<p>User specified secrets will be detected and transformed from <code>string</code> to a <code>SecretReference</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">SecretReference</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#75715e">// Name is the name of the secret. The secret must be in the same namespace as the resource.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">Name</span> <span style="color:#66d9ef">string</span>

    <span style="color:#75715e">// Key is the key in the secret to use.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">Key</span> <span style="color:#66d9ef">string</span>
}
</code></pre></div><p>Detection will be done with a combination of:</p>
<ol>
<li>Additions to ASO&rsquo;s configuration file to flag particular fields as secret (probably in the <code>ObjectModelConfiguration</code> section).</li>
<li>Using the <code>&quot;format&quot;: &quot;password&quot;</code> data from Swagger, such as that used by
<a href="https://github.com/Azure/azure-rest-api-specs/blob/main/specification/mysql/resource-manager/Microsoft.DBforMySQL/stable/2021-05-01/mysql.json#L1662">MySQL Flexible Server</a>.
Note that not all specs have this, for example
<a href="https://github.com/Azure/azure-rest-api-specs/blob/main/specification/compute/resource-manager/Microsoft.Compute/stable/2020-12-01/compute.json#L9397">VMSS does not</a>.</li>
<li>Using the <code>x-ms-secret</code> annotation, which I assume has the same meaning as <code>&quot;format&quot;: &quot;password&quot;</code> although it&rsquo;s not actually exactly documented anywhere.</li>
</ol>
<p>This is a place where we can push changes upstream to flag things as passwords if they&rsquo;re not being flagged.</p>
<h4 id="lifecycle">
  Lifecycle
  <a class="anchor" href="#lifecycle">#</a>
</h4>
<p>Since these secrets are created <em>by the user</em>, the user owns the lifecycle of these secrets. They could be using the same secret across many resources, or
intending to use this secret on a resource they have not created yet. As such, the lifecycle of these secrets must be controlled by the user.</p>
<p>Rollover will be supported by triggering events on the associated resource when the secret is modified. Since multiple custom resources might be using
the same secret, this could trigger reconciles on multiple resources. An existing pattern has been established for this in
<a href="https://github.com/Azure/azure-service-operator/blob/main/controllers/mysqlserver_controller.go#L51">mysqlserver_controller.go</a> of ASO v1.</p>
<p>When secrets are rolled over, there is a risk that applications using the secret will fail because the secret they are using is no longer valid.
We don&rsquo;t need to worry about coordination or timing though. If the user asks us to update the password (by changing it in the Kubernetes secret),
we should just do it. We aren&rsquo;t going to be able to guarantee 100% uptime unless the service in question supports multiple keys/passwords/secrets.
If the service does support that, we should be able to do what we&rsquo;ve designed here and we will automatically get those same 100% uptime guarantees
for the services that support it.</p>
<h4 id="open-questions">
  Open questions
  <a class="anchor" href="#open-questions">#</a>
</h4>
<p><strong>Should we support KeyVault inputs?</strong></p>
<p>Kubernetes has a proposal out for <a href="https://github.com/kubernetes/enhancements/tree/master/keps/sig-api-machinery/1027-api-unions">unions</a>. In this proposal they
suggest using a <code>discriminator</code> field, but allow for either of the shapes proposed above.</p>
<p>On the discriminator, they say:</p>
<blockquote>
<p>The value of the discriminator is going to be set automatically by the apiserver when a new field is changed in the union. It will be set to the value of the
fields-to-discriminateBy for that specific field.
When the value of the discriminator is explicitly changed by the client, it will be interpreted as an intention to clear all the other fields. See section below.</p>
</blockquote>
<p>See more details about what they see the <code>discriminator</code> doing in
<a href="https://github.com/kubernetes/enhancements/tree/master/keps/sig-api-machinery/1027-api-unions#normalizing-on-updates">normalizing on updates</a>.</p>
<p>Since their proposal suggests that <code>discriminator</code> is optional, <em>and</em> as far as I know it is not supported by <code>kubebuilder</code> yet, I suggest we don&rsquo;t add one
for now. In any case it&rsquo;s not totally clear to me that we really need the value that it is adding, and it seems to add a significant amount of update complexity.</p>
<p>We need to decide which of the above shapes we like more, and also if we do or do not want a <code>secretType</code> discriminator.</p>
<p><strong>Conclusion:</strong> Not needed for v1 of the feature, but we need to have a shape ready that makes sense for when we do.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">  <span style="color:#ae81ff">...</span>
  <span style="color:#f92672">secret</span>:
    <span style="color:#f92672">type</span>: <span style="color:#ae81ff">Secret</span> <span style="color:#75715e"># Or KeyVault</span>
    <span style="color:#f92672">name</span>: <span style="color:#ae81ff">foo</span>
    <span style="color:#f92672">key</span>: <span style="color:#ae81ff">bar</span>
    <span style="color:#f92672">keyVaultReference</span>:  <span style="color:#75715e"># This is the standard Reference type we use elsewhere</span>
      <span style="color:#f92672">armId</span>: <span style="color:#ae81ff">...</span>
</code></pre></div><p><strong>Is an <code>AccountName</code> a secret?</strong></p>
<p>If the service is returning it in the resource <code>GET</code>, then strictly speaking it is not a secret. Since the field isn&rsquo;t secret, we will not transform it
to be a <code>SecretReference</code>. This is for two reasons:</p>
<ol>
<li>We won&rsquo;t be able to automate it, since as far as the OpenAPI specification is concerned it isn&rsquo;t a secret.</li>
<li>The primary reason to classify this as a secret would be so that users could then inject the value from their secret into a pod. There is a workaround
for this though since the user could (using Kustomize or similar) do this already.</li>
</ol>
<p><strong>Conclusion:</strong> We will not classify these as a secret for inputs unless there&rsquo;s some requirement forcing us to do so.</p>
<p><strong>Do we allow reading a secret from a namespace where the resource isn&rsquo;t?</strong></p>
<p>There were some requests for this in ASOv1, see <a href="https://github.com/Azure/azure-service-operator/issues/1396">this</a> for example.</p>
<p>This has security implications, so initially at least the answer should be no. See: <a href="https://github.com/kubernetes/community/pull/5455">https://github.com/kubernetes/community/pull/5455</a>.</p>
<p><strong>Conclusion:</strong> No</p>
<p><strong>What&rsquo;s the difference between <code>x-ms-secret</code> and <code>format: password</code>?</strong></p>
<p>Unclear currently. I have a question out to the Swagger team. Current plan is to just treat them the same.</p>
<p><strong>Conclusion:</strong> They are not the same, <code>x-ms-secret</code> implies that the secret is not returned in the <code>GET</code>, whereas <code>format: password</code> is just an annotation that
as far as we can tell is not actually consumed by anything. For our case, we can treat them the same.</p>
<h3 id="azure-generated-secrets">
  Azure generated secrets
  <a class="anchor" href="#azure-generated-secrets">#</a>
</h3>
<p>Azure generated secrets will be <em>optionally</em> downloaded to a Kubernetes or KeyVault secret. Users instruct the operator to download
the secrets associated with a resource by supplying a <code>SecretDestination</code> in the <code>Spec</code>.</p>
<p>The optionality of this step is key for <a href="#prefer-managed-identity">preferring managed identity</a>, as it allows those in AAD/Managed identity cases to avoid
secrets they don&rsquo;t want/won&rsquo;t use being retrieved into their namespace.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// Note: This is the same type that is used for specifying references to user created secrets/
</span><span style="color:#75715e">// reproduced here for clarity
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">SecretReference</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">Name</span> <span style="color:#66d9ef">string</span>
	<span style="color:#a6e22e">Key</span> <span style="color:#66d9ef">string</span>
}

<span style="color:#75715e">// Using a different type for the destination as there are some things that are destination specific (such as adding annotations or labels, 
</span><span style="color:#75715e">// which don&#39;t make sense on )
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">SecretDestination</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">SecretReference</span>
}
</code></pre></div><h4 id="example-explicit-secrets-w-azure-storage-simple">
  Example: Explicit secrets w/ Azure Storage (Simple)
  <a class="anchor" href="#example-explicit-secrets-w-azure-storage-simple">#</a>
</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">spec</span>:
  <span style="color:#75715e"># Other spec fields elided...</span>
  <span style="color:#f92672">operatorSpec</span>:
    <span style="color:#f92672">secrets</span>:
      <span style="color:#f92672">primaryKey</span>:
        <span style="color:#f92672">name</span>: <span style="color:#ae81ff">my-secret</span>
        <span style="color:#f92672">key</span>: <span style="color:#ae81ff">PRIMARY_KEY</span>
      <span style="color:#f92672">secondaryKey</span>:
        <span style="color:#f92672">name</span>: <span style="color:#ae81ff">my-secret</span>
        <span style="color:#f92672">key</span>: <span style="color:#ae81ff">SECONDARY_KEY</span>
      <span style="color:#f92672">endpoint</span>:
        <span style="color:#f92672">name</span>: <span style="color:#ae81ff">my-secret</span>
        <span style="color:#f92672">key</span>: <span style="color:#ae81ff">ENDPOINT</span>
</code></pre></div><h4 id="example-explicit-secrets-w-cosmosdb-and-multiple-secret-destinations-complex">
  Example: Explicit secrets w/ CosmosDB and multiple secret destinations (Complex)
  <a class="anchor" href="#example-explicit-secrets-w-cosmosdb-and-multiple-secret-destinations-complex">#</a>
</h4>
<p>Here is what a more complex resource might look like if we also supported <code>KeyVault</code> as a secret type.</p>
<p><strong>Note</strong>: We are not planning to support <code>KeyVault</code> initially.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">spec</span>:
  <span style="color:#75715e"># Other spec fields elided...</span>
  <span style="color:#f92672">operatorSpec</span>:
    <span style="color:#f92672">secrets</span>:
      <span style="color:#f92672">primaryKey</span>:
        <span style="color:#f92672">type</span>: <span style="color:#ae81ff">KeyVault</span>
        <span style="color:#f92672">reference</span>:
          <span style="color:#f92672">armId</span>: <span style="color:#ae81ff">/subscriptions/.../resourceGroups/.../providers/Microsoft.KeyVault/vaults/asokeyvault</span>
        <span style="color:#f92672">name</span>: <span style="color:#ae81ff">my-primary-key</span>
      <span style="color:#f92672">secondaryKey</span>:
        <span style="color:#f92672">type</span>: <span style="color:#ae81ff">KeyVault</span>
        <span style="color:#f92672">reference</span>:
          <span style="color:#f92672">armId</span>: <span style="color:#ae81ff">/subscriptions/.../resourceGroups/.../providers/Microsoft.KeyVault/vaults/asokeyvault</span>
        <span style="color:#f92672">name</span>: <span style="color:#ae81ff">my-secondary-key</span>
      <span style="color:#f92672">readOnlyPrimaryKey</span>:
        <span style="color:#f92672">type</span>: <span style="color:#ae81ff">Secret</span>
        <span style="color:#f92672">name</span>: <span style="color:#ae81ff">my-readonly-secret</span>
        <span style="color:#f92672">key</span>: <span style="color:#ae81ff">PRIMARY_KEY</span>
      <span style="color:#f92672">readOnlySecondaryKey</span>:
        <span style="color:#f92672">type</span>: <span style="color:#ae81ff">Secret</span>
        <span style="color:#f92672">name</span>: <span style="color:#ae81ff">my-readonly-secret</span>
        <span style="color:#f92672">key</span>: <span style="color:#ae81ff">SECONDARY_KEY</span>
      <span style="color:#f92672">endpoint</span>:
        <span style="color:#f92672">type</span>: <span style="color:#ae81ff">Secret</span>
        <span style="color:#f92672">name</span>: <span style="color:#ae81ff">my-secret</span>
        <span style="color:#f92672">key</span>: <span style="color:#ae81ff">ENDPOINT</span>
</code></pre></div><p>Note that some resources (like CosmosDB <code>DatabaseAccount</code>) have multiple kinds of secrets. There might be a <code>PrimaryKey</code>, <code>SecondaryKey</code>, <code>ReadOnlyPrimaryKey</code>,
and <code>ReadOnlySecondaryKey</code>. At the very least we need to support putting the main keys and the readonly keys into two different secrets. To accomplish this,
we can define multiple logical secret groupings in the ASO config and a corresponding <code>destination</code> property will be created for each of them. You can see this
done above in the sample.</p>
<p>Some fields such as <code>Endpoint</code> (or <code>AccountName</code> for other databases) are not <em>really</em> secret, but should be included in these logical secret groups anyway so
that they&rsquo;re easier for users to inject into pods.</p>
<p>Azure generated secrets are more difficult to automatically detect. Often there is a <code>ListKeys</code> or <code>GetKey</code> API for the resource in question, but nothing on
the resource itself indicates that it has secrets automatically generated by Azure. For resources like these we will add a flag in the ASO configuration to
generate the appropriate structures in the resource. In the future we can investigate detecting this from the Swagger (probably after we move to Swagger
as the single source of truth) by introspecting &ldquo;other API calls&rdquo; on the resource in question.</p>
<h4 id="hooks-required">
  Hooks required
  <a class="anchor" href="#hooks-required">#</a>
</h4>
<p>In addition to the configuration required to generate types with the right shape, we will also need a way to hook into the reconcile process and actually make
the right <code>ListKeys</code> or <code>GetKeys</code> call. To support rollover we would need a different hook as well.</p>
<p>This is a relatively involved topic so not designing it all here. As a starting point, resources manually implementing the following interface would
get us what we need. Issue <a href="https://github.com/Azure/azure-service-operator/issues/1978">#1978</a> is tracking this request in more detail.</p>
<p>See also the design of <a href="../architecture-decision-records/ADR-2022-01-Reconciler-Extensions.md">reconciler extensions</a>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ARMDetails</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#a6e22e">Endpoint</span>       <span style="color:#66d9ef">string</span>
    <span style="color:#a6e22e">SubscriptionID</span> <span style="color:#66d9ef">string</span>
    <span style="color:#a6e22e">Creds</span>          <span style="color:#a6e22e">azcore</span>.<span style="color:#a6e22e">TokenCredential</span>
    <span style="color:#a6e22e">HttpClient</span>     <span style="color:#f92672">*</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Client</span>
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ReconcileDetails</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#a6e22e">log</span>                <span style="color:#a6e22e">logr</span>.<span style="color:#a6e22e">Logger</span>
    <span style="color:#a6e22e">recorder</span>           <span style="color:#a6e22e">record</span>.<span style="color:#a6e22e">EventRecorder</span>
    <span style="color:#a6e22e">ARMDetails</span>         <span style="color:#f92672">*</span><span style="color:#a6e22e">ARMDetails</span>
    <span style="color:#a6e22e">KubeClient</span>         <span style="color:#f92672">*</span><span style="color:#a6e22e">kubeclient</span>.<span style="color:#a6e22e">Client</span>
    <span style="color:#a6e22e">ResourceResolver</span>   <span style="color:#f92672">*</span><span style="color:#a6e22e">genruntime</span>.<span style="color:#a6e22e">Resolver</span>
    <span style="color:#a6e22e">PositiveConditions</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">conditions</span>.<span style="color:#a6e22e">PositiveConditionBuilder</span>
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">BeforeReconcileOverride</span> <span style="color:#66d9ef">interface</span> {
    <span style="color:#75715e">// BeforeCreateOrUpdate runs before sending the resource to Azure
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">BeforeCreateOrUpdate</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">details</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ReconcileDetails</span>) (<span style="color:#a6e22e">ctrl</span>.<span style="color:#a6e22e">Result</span>, <span style="color:#66d9ef">error</span>)
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">AfterReconcileOverride</span> <span style="color:#66d9ef">interface</span> {
    <span style="color:#75715e">// AfterCreateOrUpdate runs after the resource has been sent to Azure and finished creating, either successfully or with a fatal error.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// You can determine the current state by examining the Ready condition on obj.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">AfterCreateOrUpdate</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">details</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ReconcileDetails</span>) (<span style="color:#a6e22e">ctrl</span>.<span style="color:#a6e22e">Result</span>, <span style="color:#66d9ef">error</span>)
}
</code></pre></div><p>Resources with Azure generated secrets would manually implement <code>AfterCreateOrUpdate</code>, which would then:</p>
<ul>
<li>Check that the resource is in a <code>Ready</code> state.</li>
<li>Cast the provided <code>obj</code> to the expected type. This should be guaranteed safe because the method won&rsquo;t have been called unless its implemented.</li>
<li>Check the <code>forOperator</code> section of the spec to determine if any keys should be written. This includes determining the destination secret name and any
annotations or other properties that should be written or updated on that secret. Also includes ensuring that the secret in question (if it exists)
is owned by the resource in question.</li>
<li>Make the required <code>GetKeys</code> or <code>ListKeys</code> call to Azure.</li>
<li>Create or update the secret.</li>
</ul>
<h4 id="lifecycle-1">
  Lifecycle
  <a class="anchor" href="#lifecycle-1">#</a>
</h4>
<p>These are secrets created by the operator (usually after calling some <code>ListKeys</code> type API). Since the these secrets are by definition specific to the resource
that created them, their ownership in Kubernetes will be set to the resource that created them. When the owning resource is deleted, the created secret will
also be deleted.</p>
<h4 id="open-questions-1">
  Open questions
  <a class="anchor" href="#open-questions-1">#</a>
</h4>
<p><strong>Should <code>Endpoint</code>/<code>AccountName</code> type &ldquo;secrets&rdquo; really be put into the secret, or no?</strong></p>
<p>Putting them into the secret makes injecting them into pods easier, which is what people are going to want to do with these values. ASOv1 classifies all
of these sorts of things as secrets.</p>
<p>I think we should put these into the generated secrets&hellip; although this does somewhat conflict with my stance on user specified <code>accountName</code>, etc where
I had said to not classify them as secrets.</p>
<p><strong>Conclusion:</strong> Yes, we will put them into the secret.</p>
<p><strong>How does key rollover work for these types of secrets?</strong></p>
<p>We don&rsquo;t support this at all initially. This is a somewhat advanced scenario that doesn&rsquo;t fit well into the Kubernetes resource model anyway
because rollover is more of an action and less of an actual resource. The user can roll their secrets using the <code>az cli</code> (or other tooling) and
then either wait for a reconcile to occur naturally or force one to refresh the secrets locally in the cluster.</p>
<p>When we do decide to support this, we should be able to do so as a <code>Job</code>-esque resource that runs to completion (and somehow triggers a re-reconcile
on the parent resource type).</p>
<p><strong>Conclusion:</strong> This will not be supported in the initial implementation.</p>
<p><strong>How do deal with soft-delete and purge protection?</strong></p>
<p>If we support KeyVault, we have to deal with the soft-delete + purge awkwardness that deleting and recreating brings. Some of this we dodge by giving control
to the user and expecting them to provide us with the name of a secret that&rsquo;s going to work. We may also need a flag per-secret (or global at the operator
level?) for if we should purge the secret when we delete. Something like <code>purgeOnDelete</code>.</p>
<p>The main downside of a global flag controlling the behavior of purge or delete is that it doesn&rsquo;t give fine-grain control, yet we are proposing to give
fine-grained control over what vault to put secrets in. This seems like a discrepancy. This seems to suggest we just put this option on every KeyVault reference:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">spec</span>:
  <span style="color:#75715e"># Other spec fields elided...</span>
  <span style="color:#f92672">operatorSpec</span>:
    <span style="color:#f92672">secrets</span>:
      <span style="color:#75715e"># Save the read-write keys (and endpoints) into a kubernetes secret called &#34;my-secret&#34; and a KeyVault secret called &#34;my-secret&#34;.</span>
      <span style="color:#f92672">keyDestination</span>:
        <span style="color:#f92672">keyVault</span>:
          <span style="color:#f92672">reference</span>:
            <span style="color:#f92672">armId</span>: <span style="color:#ae81ff">/subscriptions/.../resourceGroups/.../providers/Microsoft.KeyVault/vaults/asokeyvault</span>
          <span style="color:#f92672">name</span>: <span style="color:#ae81ff">my-secret</span>
          <span style="color:#f92672">purge: false  # Optional</span>: <span style="color:#ae81ff">defaults to false</span>
          <span style="color:#f92672">delete: false # Optional</span>: <span style="color:#ae81ff">defaults to true</span>
</code></pre></div><p><strong>Conclusion:</strong> When we add KeyVault support, we will add the option to avoid deletion/purging of secrets.</p>
<p><strong>How do we ensure that we aren&rsquo;t overwriting secrets that we don&rsquo;t own?</strong></p>
<p>The operator must support updating the secret as keys can change or be rolled over. On the other hand we should present a clear error if the user has
accidentally pointed two resources at the same secret. The first resource should be unaffected and work normally while the second resource should encounter
a reconcile error stating that the secret in question already exists.</p>
<p>This applies to either Kubernetes or KeyVault secrets.</p>
<p>Proposed solution for Kubernetes secrets is to issue a <code>GET</code> and check the <code>Owner</code> field for Kubernetes secrets before issuing an update. <code>resourceVersion</code>
should ensure that we&rsquo;re protected from any races where some external entity deletes the secret and another resource creates it between our <code>GET</code> and <code>PUT</code>.</p>
<p>Proposed solution for KeyVault secrets is to label the secret with a key uniquely identifying the operator and resource (GVK + namespace + name) which it
corresponds to. The operator will then issue a <code>GET</code> prior to attempting to update the secret to ensure that it owns the secret. Unfortunately, as far as I can
tell KeyVault secrets don&rsquo;t support <code>Etag</code> so there&rsquo;s a possible data race here that we can&rsquo;t avoid&hellip;</p>
<p><strong>Conclusion:</strong> We will use the above design to ensure we&rsquo;re not overwriting secrets.</p>
<p><strong>What happens when a resource is updated to remove the <code>secrets</code> entry?</strong></p>
<p>If a resource is created and given a <code>forOperator.secrets</code> field that instructs it to create a secret, and then is updated to remove this secrets entry,
should we delete the secret we previously created? It feels like we <em>should</em>, but when the operator is presented with the updated object during that second
reconcile it doesn&rsquo;t know that it ever had a secret.</p>
<p>Some possible solutions:</p>
<ol>
<li>We just don&rsquo;t delete the secrets when you do this and expect users to do it themselves if they want things cleaned up.</li>
<li>For k8s secrets, we could probably look through all of the secrets in the resources namespace and see if any of them are owned by us. If there are some
and we don&rsquo;t have any <code>forOperator.secrets</code> we delete them. The downside here is that&rsquo;s a lot of overhead to do for all reconciles. This also assumes that
the operator has Secret <code>Read</code> permissions in the namespaces in question - which it&rsquo;s possible that it doesn&rsquo;t (it may never have created any secrets and
the users may know that it won&rsquo;t and so have denied it permission). This also obviously doesn&rsquo;t work for KeyVault secrets as we have no idea which KeyVault
the secrets might even be in.</li>
<li>When we create a secret we store information about it in <code>Status</code> or <code>Annotations</code> and then use that information to clean up after ourselves. It&rsquo;s a bit
cleaner to store it in <code>Status</code> but technically that can be lost, whereas <code>Annotations</code> won&rsquo;t be. This should work for both KeyVault and k8s secrets and
while it&rsquo;s a bit icky I think gives the best experience.</li>
</ol>
<p><strong>Conclusion:</strong> We will do nothing, the secret will remain. If this becomes a problem for users we can add support in the future for an annotation on the resource
that says azureGeneratedSecretBehavior: DeleteIfNotSpecified. We feel it&rsquo;s unlikely people are going to complain though, and it errs on the side of caution for deleting
secrets that may be critical to the users application operation. Note that secrets <strong>WILL</strong> be deleted when you delete the actual resource (ex: <code>CosmosDB</code>).</p>
<p><strong>Should we drop the <code>Destination</code> suffix in the field names?</strong></p>
<p>For example, the proposal for CosmosDB <code>DatabaseAccount</code> was:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">spec</span>:
  <span style="color:#75715e"># Other spec fields elided...</span>
  <span style="color:#f92672">forOperator</span>:
    <span style="color:#f92672">operatorSpec</span>:
      <span style="color:#f92672">keyDestination</span>:
        <span style="color:#75715e"># stuff elided...</span>
      <span style="color:#f92672">readOnlyKeyDestination</span>:
        <span style="color:#75715e"># stuff elided...</span>
</code></pre></div><p>Without the <code>Destination</code> suffix that would be:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">spec</span>:
  <span style="color:#75715e"># Other spec fields elided...</span>
  <span style="color:#f92672">operatorSpec</span>:
    <span style="color:#f92672">secrets</span>:
      <span style="color:#f92672">key</span>:
        <span style="color:#75715e"># stuff elided...</span>
      <span style="color:#f92672">readOnlyKey</span>:
        <span style="color:#75715e"># stuff elided...</span>
</code></pre></div><p><strong>Conclusion:</strong> Yes, drop it</p>
<p><strong>Do we allow writing a secret to a namespace where the resource isn&rsquo;t?</strong></p>
<p><strong>Conclusion:</strong> No, see: <a href="https://github.com/kubernetes/community/pull/5455">https://github.com/kubernetes/community/pull/5455</a></p>
<p><strong>Do we support writing the same secret to multiple destinations?</strong></p>
<p>Initially we had decided to not support this, and instead just write each secret to a maximum of 1 destination.
This has one unfortunate side effect. It&rsquo;s tricky for customers to break apart different &ldquo;parts&rdquo; of the secret, such as
the primary and secondary keys, into different secrets as the endpoint can only be written to one of them.</p>
<p>There is a workaround for this though: when users want to split their primary/secondary keys into different secrets,
they can write the endpoint to its own secret as well:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">spec</span>:
  <span style="color:#75715e"># Other spec fields elided...</span>
  <span style="color:#f92672">operatorSpec</span>:
     <span style="color:#f92672">primaryKey</span>:
        <span style="color:#f92672">type</span>: <span style="color:#ae81ff">Secret</span>
        <span style="color:#f92672">name</span>: <span style="color:#ae81ff">my-secret</span>
        <span style="color:#f92672">key</span>: <span style="color:#ae81ff">PRIMARY_KEY</span>
     <span style="color:#f92672">secondaryKey</span>:
        <span style="color:#f92672">type</span>: <span style="color:#ae81ff">Secret</span>
        <span style="color:#f92672">name</span>: <span style="color:#ae81ff">my-secret</span>
        <span style="color:#f92672">key</span>: <span style="color:#ae81ff">SECONDARY_KEY</span>
     <span style="color:#f92672">readOnlyPrimaryKey</span>:
        <span style="color:#f92672">type</span>: <span style="color:#ae81ff">Secret</span>
        <span style="color:#f92672">name</span>: <span style="color:#ae81ff">my-readonly-secret</span>
        <span style="color:#f92672">key</span>: <span style="color:#ae81ff">PRIMARY_KEY</span>
     <span style="color:#f92672">readOnlySecondaryKey</span>:
        <span style="color:#f92672">type</span>: <span style="color:#ae81ff">Secret</span>
        <span style="color:#f92672">name</span>: <span style="color:#ae81ff">my-readonly-secret</span>
        <span style="color:#f92672">key</span>: <span style="color:#ae81ff">SECONDARY_KEY</span>
     <span style="color:#f92672">endpoint</span>:
        <span style="color:#f92672">type</span>: <span style="color:#ae81ff">Secret</span>
        <span style="color:#f92672">name</span>: <span style="color:#ae81ff">my-endpoint</span>
        <span style="color:#f92672">key</span>: <span style="color:#ae81ff">ENDPOINT</span>
</code></pre></div><p>Then if they want to use the secondary key for a pod they would mount the endpoint and the primary/secondary keys from
<code>my-readonly-secret</code>.</p>
<p>While this isn&rsquo;t quite as clean as it could otherwise be by supporting multiple secret destinations for each
secret kind (<code>endpoint</code>, <code>readOnlyPrimaryKey</code>, etc) it&rsquo;s simpler to implement and has fewer failure modes as we don&rsquo;t
have to deal with the possibility of the user specifying 10 destinations where we wrote some but failed to write others.</p>
<p><strong>Conclusion:</strong> No, we will not support this.</p>
<p><strong>What client should we use for issuing the ListKeys/GetKeys request?</strong></p>
<p>We don&rsquo;t automatically generate methods for performing these calls. It seems easiest to just use the corresponding Azure SDK for this.
This does mean that we&rsquo;re taking a dependency on the SDK where we didn&rsquo;t have one before, but the overall footprint of usage is pretty small
and it&rsquo;s going to be easier to do that than it is to write the methods ourselves.</p>
<p><strong>Conclusion:</strong> We will use the Azure SDK for this.</p>
<p><strong>What API version should we use for issuing the ListKeys/GetKeys request?</strong></p>
<p>There are a few options here. The custom hooks could be applied to either the customer facing resource version <em>or</em> to the internal storage version.
Applying the hooks to the storage version is easier, but means that the same hook will be run regardless of which customer</p>
<h3 id="other-kinds-of-secrets">
  Other kinds of secrets
  <a class="anchor" href="#other-kinds-of-secrets">#</a>
</h3>
<p>See <a href="#other-kinds-of-secrets-in-azure">other kinds of secrets in Azure</a> for examples of each of these types of secrets.</p>
<p><strong>Get once Azure generated secrets</strong>: These are secrets created by Azure and <em>only returned once</em>, usually as the response to a POST.</p>
<p>This pattern doesn&rsquo;t seem to be very common. The current plan is to not support resources with this pattern. If we did need to support
resources with this pattern there would be no way to avoid violating the <a href="#work-well-with-gitops">work well with GitOps</a> goal, as when
deploying this resource there would be no way to adopt secrets associated with it (they&rsquo;re GET-once). That might be ok for particular
kinds of resources provided we document it though.</p>
<p>If there are large user requests for this sort of secret management we can support it similar to the <code>ListKeys</code> cases except that
the resources won&rsquo;t be movable without also cloning the secret.</p>
<p><strong>&ldquo;Secrets&rdquo; created by Azure, and returned in the <code>GET</code></strong>: This is things like <code>InstrumentationKey</code>, or server endpoint URLs.</p>
<p>Since these are returned in a <code>GET</code> they are not secret and are already being shown on Status. We will also manually classify some of them to be
included in secrets we write. That will include things like <code>endpoint</code>. This means that <code>endpoint</code> for a SQL Server would show up in two places,
in the status <em>and</em> possibly in the secret written by the operator (assuming that the user has instructed us to write the endpoint someplace).</p>
<p>The main reason for writing this into two places is:</p>
<ol>
<li>We already have it in the <code>Status</code> and it doesn&rsquo;t make sense to remove it as it&rsquo;s part of the resource payload from Azure.</li>
<li>We want the ability to put it into a Secret so that if users want to inject it into their pods as an environment variable it&rsquo;s easy to do so.
There is no good way to inject environment variables from CRD Status&rsquo;s.</li>
</ol>
<p><strong>Short-lived &ldquo;tokens&rdquo;</strong>: Like Storage SAS.</p>
<p>We will not support these sorts of secrets.</p>
<h3 id="a-special-note-on-keyvault">
  A special note on KeyVault
  <a class="anchor" href="#a-special-note-on-keyvault">#</a>
</h3>
<p>We have an <a href="https://github.com/Azure/azure-service-operator/issues/1894">open issue</a> asking for support to manage KeyVault secrets via ASO.</p>
<p>We have to be <em>very</em> careful about support for KeyVault secrets (or certs, keys, etc), as the whole point of KeyVault is as a secure place to store your
secrets.
If you&rsquo;re instead creating those secrets via the operator then you have by definition also located the secret in Kubernetes, which somewhat defeats the purpose
from a security perspective.</p>
<p>There might be cases where this makes sense if there are APIs that require a KeyVault secret to be provided to them via ARM ID and so KeyVault isn&rsquo;t the
medium of secure storage so much as it is a medium of secret transfer.</p>
<p>Until we run into such scenarios <strong>we should avoid implementing any of the KeyVault key/secret/certificate/etc APIs</strong>.</p>
<h2 id="integrations">
  Integrations
  <a class="anchor" href="#integrations">#</a>
</h2>
<p>If/when we support storing secrets in KeyVault, we can create some demos showing integration with the
<a href="https://github.com/Azure/secrets-store-csi-driver-provider-azure">KeyVault secret store csi driver</a>.</p>
<h2 id="supported-secret-stores">
  Supported secret stores
  <a class="anchor" href="#supported-secret-stores">#</a>
</h2>
<p>P0: Kubernetes Secrets</p>
<p>P1: KeyVault - this seems more interesting for the &ldquo;secrets from Azure&rdquo; case, since at least right now you cannot create KeyVault secrets through
ASO. That limitation means if you wanted to use KeyVault for input secrets you must have already pre-created the secrets before deploying via the operator.</p>
<h2 id="implementation-plan">
  Implementation plan
  <a class="anchor" href="#implementation-plan">#</a>
</h2>
<p>There are effectively two parallel features here:</p>
<ol>
<li>Input secrets (reading secrets from a store and supplying those secrets to Azure)</li>
<li>Output secrets (reading secrets from Azure and storing them in a secret store)</li>
</ol>
<h3 id="input-secrets">
  Input secrets
  <a class="anchor" href="#input-secrets">#</a>
</h3>
<ol>
<li><code>SecretReference</code> implementation.</li>
<li>Code generator changes to detect <code>format: password</code> or <code>x-ms-secret</code> and transform properties appropriately.</li>
<li>Reflector library to generically crawl resources and find secret refs.</li>
<li><code>SecretReader</code> library to get secrets from a collection of <code>SecretReference</code>&rsquo;s. This should be expandable to support KeyVault secret refs in
the future if we decide to add them. Should probably look something like this. Note that this  related to the <code>SecretWriter</code> below in
the <a href="#output-secrets">output secrets</a> section:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// TODO: these strings may need to be []byte
</span><span style="color:#75715e">// Note: these interfaces are acting on collections only so that they can be more efficient, as multiple SecretReference&#39;s or secret values may be read from or written to 
</span><span style="color:#75715e">// a single secret.
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">SecretReader</span> <span style="color:#66d9ef">interface</span> {
    <span style="color:#a6e22e">GetSecrets</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">refs</span> []<span style="color:#a6e22e">SecretReference</span>) (<span style="color:#66d9ef">map</span>[<span style="color:#a6e22e">SecretReference</span>]<span style="color:#66d9ef">string</span>, <span style="color:#66d9ef">error</span>)
}
</code></pre></div></li>
<li>ARM conversion changes to take a <code>ResolvedSecrets</code> parameter in addition to the <code>ResolvedReferences</code> it takes now.
This will probably require a bit of fussing with the types passed to the ARM conversion methods and the conversion methods themselves.</li>
<li>Reconciler changes to perform secret reading in addition to reference resolving.</li>
<li>Testing: Modify existing tests passing secrets in plain text as part of the spec to use the new mechanism instead.</li>
<li>[Stretch goal] Support for secret rollover:
<ol>
<li>Hook to add field indexers for specific resources (see what we&rsquo;re doing for MySQL in ASOv1 today).</li>
<li>Hook to control custom additional watches used for monitoring changes to secrets (see what we&rsquo;re doing for MySQL in ASOv1 today).</li>
</ol>
</li>
</ol>
<h3 id="output-secrets">
  Output secrets
  <a class="anchor" href="#output-secrets">#</a>
</h3>
<ol>
<li><code>operatorSpec</code>/<code>operatorStatus</code> preparatory work. See <a href="https://github.com/Azure/azure-service-operator/issues/1612">#1612</a>.</li>
<li>Add hooks to controller allowing handcrafted per-resource customization, see <a href="https://github.com/Azure/azure-service-operator/issues/1978">#1978</a>.</li>
<li>Update azure-arm configuration to allow for additional AzureGeneratedSecret properties to be defined. These properties will be rendered into the
<code>operatorSpec</code> as <code>SecretDestination</code>&rsquo;s and subsequently read by the resource specific hooks in order to determine what (if any) <code>ListKeys</code> APIs to call
and where to store the results.</li>
<li>Implement the <code>SecretWriter</code> interface described below (or something like it). Note that this is related to the <code>SecretReader</code> above in
the <a href="#input-secrets">input secrets</a> section.
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// TODO: these strings may need to be []byte
</span><span style="color:#75715e">// Note: these interfaces are acting on collections only so that they can be more efficient, as multiple SecretReference&#39;s or secret values may be read from or written to 
</span><span style="color:#75715e">// a single secret.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">DestinationValuePair</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#a6e22e">Value</span> <span style="color:#66d9ef">string</span>
    <span style="color:#a6e22e">Destination</span> <span style="color:#a6e22e">SecretDestination</span>
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">SecretWriter</span> <span style="color:#66d9ef">interface</span> {
    <span style="color:#75715e">// This will perform ownership checks and return an error if an attempt is made to update a secret that is not owned by the operator
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">SetSecrets</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">owner</span> <span style="color:#a6e22e">MetaObject</span>, <span style="color:#a6e22e">secrets</span> []<span style="color:#a6e22e">DestinationValuePair</span>) <span style="color:#66d9ef">error</span>
}
</code></pre></div></li>
<li>Use customization hooks to implement <code>GetKeys</code> or <code>ListKeys</code> for each applicable resource, utilizing the <code>SecretWriter</code> to write the secrets to their
destination.</li>
</ol>
<h2 id="testing">
  Testing
  <a class="anchor" href="#testing">#</a>
</h2>
<h3 id="unit-testing">
  Unit testing
  <a class="anchor" href="#unit-testing">#</a>
</h3>
<p>All of the library code should have unit tests written:</p>
<ol>
<li>Reflector to discover <code>SecretReference</code>.</li>
<li><code>SecretReader</code>/<code>SecretWriter</code></li>
</ol>
<h3 id="end-to-end-testing">
  End to end testing
  <a class="anchor" href="#end-to-end-testing">#</a>
</h3>
<p>The existing EnvTest tests can be expanded to test secret management. We will need to make sure that we redact the keys returned by <code>ListKeys</code>. Tests for resources which
take secrets will need the secrets created beforehand and passed to the resource (just as the customer would have to do).</p>
<h2 id="related-issues">
  Related issues
  <a class="anchor" href="#related-issues">#</a>
</h2>
<ol>
<li><a href="https://github.com/Azure/azure-service-operator/issues/1398">Secrets created by ASO should have configurable annotations</a></li>
<li><a href="https://github.com/Azure/azure-service-operator/issues/1318">Path to secrets created by ASO should be in the status</a> - maybe not needed if we&rsquo;re making the user tell us where to put it?</li>
<li><a href="https://github.com/Azure/azure-service-operator/issues/1280">Secrets deletion should be required as part of resource deletion</a></li>
<li><a href="https://github.com/Azure/azure-service-operator/issues/1894">Add option to create and manage keyvault secrets through ASO</a></li>
</ol>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#what-secrets-are-we-talking-about">What secrets are we talking about?</a></li>
    <li><a href="#goals">Goals</a>
      <ul>
        <li><a href="#aso-should-not-be-generating-secrets-on-the-users-behalf">ASO should not be generating secrets on the users behalf</a></li>
        <li><a href="#prefer-managed-identity">Prefer Managed Identity</a></li>
        <li><a href="#work-well-with-gitops">Work well with GitOps</a></li>
      </ul>
    </li>
    <li><a href="#kinds-of-secrets">Kinds of secrets</a>
      <ul>
        <li><a href="#sample-resources-that-have-secrets">Sample resources that have secrets</a></li>
        <li><a href="#other-kinds-of-secrets-in-azure">Other kinds of secrets in Azure:</a></li>
      </ul>
    </li>
    <li><a href="#other-operators">Other Operators</a>
      <ul>
        <li><a href="#crossplane">Crossplane</a></li>
        <li><a href="#aws-controller-for-kubernetes-ack">AWS Controller for Kubernetes (ACK)</a></li>
      </ul>
    </li>
    <li><a href="#proposal">Proposal</a>
      <ul>
        <li><a href="#user-specified-secrets">User specified secrets</a></li>
        <li><a href="#azure-generated-secrets">Azure generated secrets</a></li>
        <li><a href="#other-kinds-of-secrets">Other kinds of secrets</a></li>
        <li><a href="#a-special-note-on-keyvault">A special note on KeyVault</a></li>
      </ul>
    </li>
    <li><a href="#integrations">Integrations</a></li>
    <li><a href="#supported-secret-stores">Supported secret stores</a></li>
    <li><a href="#implementation-plan">Implementation plan</a>
      <ul>
        <li><a href="#input-secrets">Input secrets</a></li>
        <li><a href="#output-secrets">Output secrets</a></li>
      </ul>
    </li>
    <li><a href="#testing">Testing</a>
      <ul>
        <li><a href="#unit-testing">Unit testing</a></li>
        <li><a href="#end-to-end-testing">End to end testing</a></li>
      </ul>
    </li>
    <li><a href="#related-issues">Related issues</a></li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












