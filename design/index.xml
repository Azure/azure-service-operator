<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Design &amp; Specifications on Azure Service Operator</title>
    <link>https://azure.github.io/azure-service-operator/design/</link>
    <description>Recent content in Design &amp; Specifications on Azure Service Operator</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <atom:link href="https://azure.github.io/azure-service-operator/design/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>2020-04: Why Code Generation?</title>
      <link>https://azure.github.io/azure-service-operator/design/adr-2020-04-code-generation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://azure.github.io/azure-service-operator/design/adr-2020-04-code-generation/</guid>
      <description>&lt;h2 id=&#34;context&#34;&gt;Context&lt;/h2&gt;&#xA;&lt;p&gt;The Azure Service Operator CSE team had successfully developed support for a handful of ARM (Azure Resource Manager) based custom resources over the course of eighteen months or so.&lt;/p&gt;&#xA;&lt;p&gt;Their experience yielded several useful lessons.&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Working closely with their customers, they only built out resource support for those features required by the current customer base. While this successfully reduced the amount of work, each additional customer brought new requirements and a need to revisit/enhance existing resources.&lt;/p&gt;</description>
    </item>
    <item>
      <title>2020-07: Pipeline Architecture</title>
      <link>https://azure.github.io/azure-service-operator/design/adr-2020-07-pipeline-architecture/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://azure.github.io/azure-service-operator/design/adr-2020-07-pipeline-architecture/</guid>
      <description>&lt;h2 id=&#34;context&#34;&gt;Context&lt;/h2&gt;&#xA;&lt;p&gt;As the complexity of code generation grew, and with a partial view of the complexity yet to come, it became clear that we were facing a challenge. Each additional required function was making integration and testing progressively more difficult.&lt;/p&gt;&#xA;&lt;p&gt;We also have the requirement to support a parallel pipeline that generates code appropriate for CrossPlane integration, and have a strong desire for an approach that minimizes the amount of ongoing maintenance.&lt;/p&gt;</description>
    </item>
    <item>
      <title>2020-11: AST Library Choice</title>
      <link>https://azure.github.io/azure-service-operator/design/adr-2020-11-abstract-syntax-trees/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://azure.github.io/azure-service-operator/design/adr-2020-11-abstract-syntax-trees/</guid>
      <description>&lt;h2 id=&#34;context&#34;&gt;Context&lt;/h2&gt;&#xA;&lt;p&gt;When we first started working on the Azure Service Operator Code Generator, we used the standard go &lt;a href=&#34;https://pkg.go.dev/go/ast&#34;&gt;&lt;code&gt;ast&lt;/code&gt;&lt;/a&gt; library to create the final Go code.&lt;/p&gt;&#xA;&lt;p&gt;Unfortunately, we have run into a number of significant limitations with this library.&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;Comments are often emitted in unexpected places.&lt;/strong&gt;&lt;br&gt;&#xA;They would often appear at the end of the previous line, which conveys an incorrect meaning to a casual reader of the code. As a workaround, we found that prefacing some comments with newline characters would force them onto the next line. While hacking the library in this function worked, we are concerned that it&amp;rsquo;s a fragile technique that would break in a future version of Go. We also found situations where this technique did not work.&lt;/p&gt;</description>
    </item>
    <item>
      <title>2021-02: Property Conversions</title>
      <link>https://azure.github.io/azure-service-operator/design/adr-2021-02-property-conversions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://azure.github.io/azure-service-operator/design/adr-2021-02-property-conversions/</guid>
      <description>&lt;h2 id=&#34;context&#34;&gt;Context&lt;/h2&gt;&#xA;&lt;p&gt;To facilitate the use of dedicated storage variants for persistence of our custom resources, we need to codegen conversion routines that will copy all properties defined on one version of a resource to another version.&lt;/p&gt;&#xA;&lt;p&gt;Given the way resources evolve from version to version, these we need to support a wide range of conversions between types that are similar, but not identical.&lt;/p&gt;&#xA;&lt;p&gt;For example, looking primitive types (such as &lt;strong&gt;string&lt;/strong&gt;, &lt;strong&gt;int&lt;/strong&gt;, and &lt;strong&gt;bool&lt;/strong&gt;):&lt;/p&gt;</description>
    </item>
    <item>
      <title>2021-06: API Version Recovery</title>
      <link>https://azure.github.io/azure-service-operator/design/adr-2021-06-api-version-recovery/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://azure.github.io/azure-service-operator/design/adr-2021-06-api-version-recovery/</guid>
      <description>&lt;h2 id=&#34;context&#34;&gt;Context&lt;/h2&gt;&#xA;&lt;p&gt;In addition to structural changes, there may be behaviour changes between ARM API versions. It is therefore important that we use the correct API version - the version requested by the user - when interacting with ARM, to ensure that we get the expected behaviour.&lt;/p&gt;&#xA;&lt;p&gt;Revisting the CRM example from the &lt;a href=&#34;https://azure.github.io/azure-service-operator/design/versioning/&#34;&gt;Versioning&lt;/a&gt; specification, consider what happens if we have two available versions of the resource &lt;code&gt;Person&lt;/code&gt;, lets call them &lt;strong&gt;v1&lt;/strong&gt; and &lt;strong&gt;v2&lt;/strong&gt;. In &lt;strong&gt;v2&lt;/strong&gt; the new properties &lt;code&gt;PostalAddress&lt;/code&gt; and &lt;code&gt;ResidentialAddress&lt;/code&gt; are mandatory, requiring that everyone have a both a mailing address and a home.&lt;/p&gt;</description>
    </item>
    <item>
      <title>2021-08: Committing Generated Code</title>
      <link>https://azure.github.io/azure-service-operator/design/adr-2021-08-committing-generated-code/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://azure.github.io/azure-service-operator/design/adr-2021-08-committing-generated-code/</guid>
      <description>&lt;h2 id=&#34;context&#34;&gt;Context&lt;/h2&gt;&#xA;&lt;p&gt;Weâ€™re aware that common practice avoids committing generated code into source control, treating it as an ephemeral resource that can be regenerated on demand.&lt;/p&gt;&#xA;&lt;p&gt;Even so, we are concluding that we want to check in our generated code.&lt;/p&gt;&#xA;&lt;h3 id=&#34;upstream-changes&#34;&gt;Upstream changes&lt;/h3&gt;&#xA;&lt;p&gt;We do not fully control the source definitions from which we are generating our object model and we are concerned about upstream changes that change our generated output in unexpected ways.&lt;/p&gt;</description>
    </item>
    <item>
      <title>2022-01: Reconciler Extensions</title>
      <link>https://azure.github.io/azure-service-operator/design/adr-2022-01-reconciler-extensions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://azure.github.io/azure-service-operator/design/adr-2022-01-reconciler-extensions/</guid>
      <description>&lt;h2 id=&#34;context&#34;&gt;Context&lt;/h2&gt;&#xA;&lt;p&gt;We are discovering inconsistencies in the way different Azure Resource Providers behave.&lt;/p&gt;&#xA;&lt;p&gt;These inconsistencies are anticipated. Given the number of disparate teams independently implementing their providers and given the way the ARM guidance has changed over time, differences in behaviour are to be expected.&lt;/p&gt;&#xA;&lt;p&gt;For example, the Azure Redis Resource Provider can return a HTTP conflict (409) with a retry message indicating that it&amp;rsquo;s not a fatal error but a transient one.&lt;/p&gt;</description>
    </item>
    <item>
      <title>2022-02: Backward Resource Compatibility</title>
      <link>https://azure.github.io/azure-service-operator/design/adr-2022-02-backward-compatibility/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://azure.github.io/azure-service-operator/design/adr-2022-02-backward-compatibility/</guid>
      <description>&lt;h2 id=&#34;context&#34;&gt;Context&lt;/h2&gt;&#xA;&lt;p&gt;As we close in on a beta release, we are considering modification of the version prefix used for code-generated resources.&lt;/p&gt;&#xA;&lt;h3 id=&#34;option-1-do-nothing&#34;&gt;Option 1: Do nothing&lt;/h3&gt;&#xA;&lt;p&gt;Leave all generated resources using the alpha prefix that is currently in use.&lt;/p&gt;&#xA;&lt;p&gt;Pros&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Easy to implement (nothing to do) and quick to deliver&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Cons&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Introduces an inconsistency between the status of ASO (beta) and the labelling of the resources (alpha).&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Might be perceived by some users as indicating these particular resources are still in alpha, and therefore pose significant a barrier to adoption of ASO.&lt;/p&gt;</description>
    </item>
    <item>
      <title>2022-08 Evil Discriminator</title>
      <link>https://azure.github.io/azure-service-operator/design/adr-2022-08-evil-discriminator/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://azure.github.io/azure-service-operator/design/adr-2022-08-evil-discriminator/</guid>
      <description>&lt;p&gt;Coined in frustration by the ASO project team, the phrase &lt;em&gt;evil discriminator&lt;/em&gt; identifies the fundamental differences in the way polymorphic API payloads are defined in Swagger, as compared to the JSON Schema on which ASO was originally based.&lt;/p&gt;&#xA;&lt;h2 id=&#34;context&#34;&gt;Context&lt;/h2&gt;&#xA;&lt;p&gt;When parsing a JSON Schema and populating our abstract-syntax-model (astmodel), all of the available options for a OneOf are available as children of a single node. This makes processing relatively simple, and greatly influenced our object model during the original development of ASO.&lt;/p&gt;</description>
    </item>
    <item>
      <title>2022-09: Reading Status properties from other ASO resources</title>
      <link>https://azure.github.io/azure-service-operator/design/adr-2022-09-reading-status-properties-of-resources/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://azure.github.io/azure-service-operator/design/adr-2022-09-reading-status-properties-of-resources/</guid>
      <description>&lt;h2 id=&#34;context&#34;&gt;Context&lt;/h2&gt;&#xA;&lt;p&gt;It isn&amp;rsquo;t currently possible to create a &lt;code&gt;UserManagedIdentity&lt;/code&gt; and use it in the same YAML, because&#xA;usage of it requires knowing its &lt;code&gt;PrincipalId&lt;/code&gt; which is generated by Azure only when the identity is created.&#xA;This is discussed in a variety of issues. See &lt;a href=&#34;https://github.com/Azure/azure-service-operator/issues/2435&#34;&gt;2435&lt;/a&gt;&#xA;and &lt;a href=&#34;https://github.com/Azure/azure-service-operator/issues/2350&#34;&gt;2350&lt;/a&gt; for two examples.&#xA;This is also somewhat related to &lt;a href=&#34;https://github.com/Azure/azure-service-operator/issues/2474&#34;&gt;2474&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;The following example highlights the problem:&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;apiVersion&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;managedidentity.azure.com/v1beta20181130&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;kind&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;UserAssignedIdentity&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;metadata&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;sample-uai&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;spec&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;location&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;Germany West Central&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;owner&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;dev-sample-rg&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;---&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;apiVersion&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;authorization.azure.com/v1beta20200801preview&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;kind&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;RoleAssignment&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;metadata&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;6a2d44f5-57d8-4916-9f46-ff7c9c1b338f&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;spec&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;location&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;Germany West Central&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;owner&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;samplevnet&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;group&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;network.azure.com&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;kind&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;VirtualNetwork&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;principalId&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;lt;NOT YET KNOWN&amp;gt; &lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;# Problem!!&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;roleDefinitionReference&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;armId&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;/subscriptions/00000000-0000-0000-0000-000000000000/providers/Microsoft.Authorization/roleDefinitions/b24988ac-6180-42a0-ab88-20f7382dd24c&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This results in an awkward to use API and prevents ASO from fulfilling its main duty as a way to manage&#xA;infrastructure as code and deploy things simply with no manual steps.&lt;/p&gt;</description>
    </item>
    <item>
      <title>2022-09: Support For Multiple Credentials Under Global Operator</title>
      <link>https://azure.github.io/azure-service-operator/design/adr-2022-09-multiple-credential-operator/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://azure.github.io/azure-service-operator/design/adr-2022-09-multiple-credential-operator/</guid>
      <description>&lt;h2 id=&#34;context&#34;&gt;Context&lt;/h2&gt;&#xA;&lt;p&gt;Some users of Azure Service Operator want to have a single instance that manages Azure resources across multiple subscriptions. This is useful, for example, if the organisation has a large cluster used by multiple teams, each team having their own Azure subscription.&#xA;To support this, ASO will introduce support for multiple credentials, each associated with a specific scope:&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Global Secret(aso-controller-settings)&lt;/strong&gt; is a currently existing one and is used as default for all Azure Resources&lt;/p&gt;</description>
    </item>
    <item>
      <title>2022-11: ASO v1 Migration and Resource Import</title>
      <link>https://azure.github.io/azure-service-operator/design/adr-2022-11-resource-import/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://azure.github.io/azure-service-operator/design/adr-2022-11-resource-import/</guid>
      <description>&lt;h2 id=&#34;context&#34;&gt;Context&lt;/h2&gt;&#xA;&lt;p&gt;We have a significant number of customers successfully using ASO v1 whom we want to migrate to ASO v2. This requires both feature parity (so that users don&amp;rsquo;t lose functionality when they switch) and a straightforward migration path (if it&amp;rsquo;s too hard to migrate, they won&amp;rsquo;t).&lt;/p&gt;&#xA;&lt;p&gt;Discussions so far have identified three possible solutions - &lt;em&gt;version integration&lt;/em&gt;, &lt;em&gt;resource import job&lt;/em&gt; and &lt;em&gt;resource import tool&lt;/em&gt;.&lt;/p&gt;&#xA;&lt;h3 id=&#34;version-integration&#34;&gt;Version Integration&lt;/h3&gt;&#xA;&lt;p&gt;We would add new hand-written resources into ASO v2 with the same names and shapes as the resources supported by ASO v1. Users would be able to migrate to ASO v2 simply by removing ASO v1 from their cluster and installing ASO v2 in its place.&lt;/p&gt;</description>
    </item>
    <item>
      <title>2022-11: Change Detection</title>
      <link>https://azure.github.io/azure-service-operator/design/adr-2022-11-change-detection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://azure.github.io/azure-service-operator/design/adr-2022-11-change-detection/</guid>
      <description>&lt;h2 id=&#34;context&#34;&gt;Context&lt;/h2&gt;&#xA;&lt;p&gt;In ASO v2 up to at least the &lt;code&gt;beta.4&lt;/code&gt; release, we reconcile each resource by doing a PUT, relying on the Azure Resource Manager (ARM) to do the goal state comparison and only update the resource if it has changed.&lt;/p&gt;&#xA;&lt;p&gt;While this works, customers are already running up against severe ARM throttling with moderate numbers of resources. Typically, ARM throttles PUT requests handled by a given ARM endpoint to just 1200 per hour per subscription. With our current use of a single active HTTP connection and a reconcile period of 15m, ASO users are hitting this limit with just 300 active resources.&lt;/p&gt;</description>
    </item>
    <item>
      <title>2022-12: Conversion Augmentation</title>
      <link>https://azure.github.io/azure-service-operator/design/adr-2023-01-conversion-augmentation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://azure.github.io/azure-service-operator/design/adr-2023-01-conversion-augmentation/</guid>
      <description>&lt;h2 id=&#34;context&#34;&gt;Context&lt;/h2&gt;&#xA;&lt;p&gt;The Kubernetes ecosystem has &lt;a href=&#34;https://book.kubebuilder.io/multiversion-tutorial/api-changes.html&#34;&gt;strong requirements&lt;/a&gt; around backward and forward compatibility of resource versions:&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;In Kubernetes, all versions must be safely round-tripable through each other. This means that if we convert from version 1 to version 2, and then back to version 1, we must not lose information. Thus, any change we make to our API must be compatible with whatever we supported in v1, and also need to make sure anything we add in v2 is supported in v1.&lt;/p&gt;</description>
    </item>
    <item>
      <title>2022-12: Reconciliation Extensions</title>
      <link>https://azure.github.io/azure-service-operator/design/adr-2022-12-reconciliation-extensions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://azure.github.io/azure-service-operator/design/adr-2022-12-reconciliation-extensions/</guid>
      <description>&lt;h2 id=&#34;context&#34;&gt;Context&lt;/h2&gt;&#xA;&lt;p&gt;The current behaviour of Azure Service Operator (ASO) is to unilaterally issue a PUT to Azure each time reconciliation of a resource is triggered.&lt;/p&gt;&#xA;&lt;p&gt;For some resources this doesn&amp;rsquo;t work particularly well because the resources can be in a transient state that precludes the PUT from succeeding. The resulting error message pushes ASO into retrying the operation over and over again when it can&amp;rsquo;t possibly succeed. Not only does this cause needless load on both the cluster and Azure, it can trigger rate limiting and other throttling mechanisms.&lt;/p&gt;</description>
    </item>
    <item>
      <title>2023-01: Helm Chart Size Limitations and Workarounds</title>
      <link>https://azure.github.io/azure-service-operator/design/adr-2023-02-helm-chart-size-limitations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://azure.github.io/azure-service-operator/design/adr-2023-02-helm-chart-size-limitations/</guid>
      <description>&lt;h2 id=&#34;context&#34;&gt;Context&lt;/h2&gt;&#xA;&lt;p&gt;Helm v3 stores chart state in a Kubernetes secret by default. Kubernetes secrets are limited to a max size based on&#xA;etcd&amp;rsquo;s configuration. The default etcd configuration limits secrets to a maximum size of 1MB.&lt;/p&gt;&#xA;&lt;p&gt;Our chart secret is fast approaching 1MB. In fact,&#xA;&lt;a href=&#34;https://github.com/Azure/azure-service-operator/pull/2727&#34;&gt;outstanding PRs&lt;/a&gt; already cause us to surpass the 1MB limit.&lt;/p&gt;&#xA;&lt;p&gt;Once this limit is reached, users will be unable to install our chart. When this happens, the error looks like:&lt;/p&gt;</description>
    </item>
    <item>
      <title>2023-02: Adoption Policy</title>
      <link>https://azure.github.io/azure-service-operator/design/adr-2023-02-adoption-policy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://azure.github.io/azure-service-operator/design/adr-2023-02-adoption-policy/</guid>
      <description>&lt;h2 id=&#34;context&#34;&gt;Context&lt;/h2&gt;&#xA;&lt;p&gt;Resources which exist in Azure prior to being created in Kubernetes are &amp;ldquo;adopted&amp;rdquo; by the operator when the resource&#xA;is created in Kubernetes. Today this adoption process is automatic and implicit. As a user there isn&amp;rsquo;t an easy way&#xA;to tell if a resource you&amp;rsquo;re about to &lt;code&gt;kubectl apply&lt;/code&gt; already exists in Azure (will be adopted) or does not exist in&#xA;Azure (will be created).&lt;/p&gt;&#xA;&lt;p&gt;We already have support for &lt;a href=&#34;https://github.com/Azure/azure-service-operator/pull/2060&#34;&gt;reconcile-policy&lt;/a&gt; which&#xA;is related to adoption. Some of &lt;code&gt;reconcile-policy&lt;/code&gt;&amp;rsquo;s primary use cases are for when the user does not want ASO to&#xA;fully manage an adopted resource.&lt;/p&gt;</description>
    </item>
    <item>
      <title>2023-03: Post Reconciliation Extensions</title>
      <link>https://azure.github.io/azure-service-operator/design/adr-2023-03-post-reconciliation-extension/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://azure.github.io/azure-service-operator/design/adr-2023-03-post-reconciliation-extension/</guid>
      <description>&lt;h2 id=&#34;context&#34;&gt;Context&lt;/h2&gt;&#xA;&lt;p&gt;The current behaviour of Azure Service Operator (ASO) is to set the &lt;code&gt;Ready&lt;/code&gt; status on a resource by default after a successful creation of a resource.&lt;/p&gt;&#xA;&lt;p&gt;For some resources, this is not sufficient as there may be additional steps required after initial creation of the resource. We need the ability to check the status of a created resource post reconciliation and set a condition accordingly.&lt;/p&gt;&#xA;&lt;p&gt;An example of this is &lt;code&gt;PrivateEndpoints&lt;/code&gt; with &lt;code&gt;ConnectionState&lt;/code&gt; of &lt;code&gt;Approved&lt;/code&gt;, &lt;code&gt;Rejected&lt;/code&gt; or &lt;code&gt;Pending&lt;/code&gt;. We don&amp;rsquo;t want a &lt;code&gt;PrivateEndpoint&lt;/code&gt; to go to condition &lt;code&gt;Ready&lt;/code&gt; until the connection is approved.&lt;/p&gt;</description>
    </item>
    <item>
      <title>2023-04: Azure Resource Deprecation</title>
      <link>https://azure.github.io/azure-service-operator/design/adr-2023-04-deprecation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://azure.github.io/azure-service-operator/design/adr-2023-04-deprecation/</guid>
      <description>&lt;h2 id=&#34;context&#34;&gt;Context&lt;/h2&gt;&#xA;&lt;p&gt;As succinctly raised by &lt;code&gt;@sakthi-vetrivel&lt;/code&gt; in (#2070)[https://github.com/Azure/azure-service-operator/issues/2070]:&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Today, there&amp;rsquo;s no change to the support for an Azure Service Operator CRD when the underlying Azure service/offering is being deprecated. How should we communicate these deprecations and what timelines should we follow? How will we keep our catalog up to date?&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;Starting in Kubernetes v1.19, it&amp;rsquo;s possible to flag individual versions of a custom resource as (deprecated)[https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definition-versioning/#version-deprecation]. This results in the follow behaviour:&lt;/p&gt;</description>
    </item>
    <item>
      <title>2023-04: Preventing Resource Drift</title>
      <link>https://azure.github.io/azure-service-operator/design/adr-2023-04-patch-collections/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://azure.github.io/azure-service-operator/design/adr-2023-04-patch-collections/</guid>
      <description>&lt;h2 id=&#34;context&#34;&gt;Context&lt;/h2&gt;&#xA;&lt;p&gt;Some Azure Resource Providers do not quite have full replace semantics for a PUT.&lt;/p&gt;&#xA;&lt;p&gt;Instead, they have PATCH-like behavior on PUT which effectively boils down to: They will replace sub-objects/sub-collections if the object/collection is in the JSON payload, but they will leave untouched omitted properties or collections.&lt;/p&gt;&#xA;&lt;p&gt;To illustrate, assume you have a Person object with a Name and a list of Addresses.&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;If you PUT a Person object with a new Name and &lt;em&gt;no addresses&lt;/em&gt;, the new name will be persisted, but the addresses will remain &lt;em&gt;unchanged&lt;/em&gt;.&lt;/li&gt;&#xA;&lt;li&gt;If you PUT a Person object with a new Name and an &lt;em&gt;empty list&lt;/em&gt; of addresses, the new name will be persisted, and the addresses collection will be cleared.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: Some services will treat PUT with an omitted collection and PUT with an explicit JSON &amp;ldquo;null&amp;rdquo; the same, while other services treat &amp;ldquo;null&amp;rdquo; to mean clear, while omission means &amp;ldquo;ignore&amp;rdquo;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>2023-05: Installing only selected CRDs</title>
      <link>https://azure.github.io/azure-service-operator/design/adr-2023-05-installing-only-selected-crds/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://azure.github.io/azure-service-operator/design/adr-2023-05-installing-only-selected-crds/</guid>
      <description>&lt;h2 id=&#34;context&#34;&gt;Context&lt;/h2&gt;&#xA;&lt;p&gt;Outstanding issues:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/Azure/azure-service-operator/issues/2920&#34;&gt;#2920: kube-apiserver persistently high memory usage with large number of CRDs&lt;/a&gt;.&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/Azure/azure-service-operator/issues/1433&#34;&gt;#1433: Allow users to control which CRDs are installed&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;CRDs consume kube-apiserver resources even if no instances of the CRDs are ever created. For more details, see&#xA;&lt;a href=&#34;https://github.com/Azure/azure-service-operator/issues/2920&#34;&gt;#2920&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;We have had a longstanding item (&lt;a href=&#34;https://github.com/Azure/azure-service-operator/issues/1433&#34;&gt;#1433&lt;/a&gt;) to allow users&#xA;to be more selective about what CRDs to install. As the number of CRDs installed by ASO increases,&#xA;this becomes more critical in order to mitigate the kube-apiserver memory usage problem.&lt;/p&gt;</description>
    </item>
    <item>
      <title>2024-04: RoleAssignments UUID Generation</title>
      <link>https://azure.github.io/azure-service-operator/design/adr-2024-04-roleassignment-uuid-generation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://azure.github.io/azure-service-operator/design/adr-2024-04-roleassignment-uuid-generation/</guid>
      <description>&lt;h2 id=&#34;context&#34;&gt;Context&lt;/h2&gt;&#xA;&lt;p&gt;In ASO, we made several improvements to make RoleAssignment user-friendly by auto-generating their AzureName (which must be a UUID) using UUIDv5 with a seed string based on group, kind, namespace, and name.&#xA;The aim for above approach was to:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;include the namespace and name to ensure no two RoleAssignments in the same cluster can end up with the same UUID.&lt;/li&gt;&#xA;&lt;li&gt;include the group and kind to ensure that different kinds of resources get different UUIDs. This isn&amp;rsquo;t entirely required by Azure, but it makes sense to avoid collisions between two resources of different types even if they have the same namespace and name.&lt;/li&gt;&#xA;&lt;li&gt;include the owner group, kind, and name to avoid collisions between resources with the same name in different clusters that actually point to different Azure resources.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;In scenarios where users have multiple ASO instances across different clusters, resources within the identical namespaces, and each cluster has resources with identical names pointing to distinct Azure resources, there is no native support for this configuration. To work around this limitation, users must manually assign a unique UUID to each RoleAssignment. Alternatively, setting the AzureName property to a random UUID by default can prevent the issue, but it may lead to complications if a RoleAssignment is ever deleted and then recreated (or migrated between clusters), as the old UUID would become orphaned.&lt;/p&gt;</description>
    </item>
    <item>
      <title>2024-07: Dynamic Export to Secret or ConfigMap</title>
      <link>https://azure.github.io/azure-service-operator/design/adr-2024-07-dynamic-export-to-secret-or-configmap/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://azure.github.io/azure-service-operator/design/adr-2024-07-dynamic-export-to-secret-or-configmap/</guid>
      <description>&lt;h2 id=&#34;context&#34;&gt;Context&lt;/h2&gt;&#xA;&lt;p&gt;It is a common ask for users to request a new value be exportable to &lt;code&gt;ConfigMap&lt;/code&gt;, or for the values&#xA;that are currently exported to a &lt;code&gt;ConfigMap&lt;/code&gt; or &lt;code&gt;Secret&lt;/code&gt; to be customizable in some way.&lt;/p&gt;&#xA;&lt;p&gt;Outstanding issues related to this topic:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/Azure/azure-service-operator/issues/3929&#34;&gt;#2920: Feature: Support export of storage account connection strings&lt;/a&gt;.&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/Azure/azure-service-operator/issues/2555&#34;&gt;#2555: Feature: Support dynamic secret/configmap exports&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/Azure/azure-service-operator/issues/3711&#34;&gt;#3711: PublicIPPrefix: Allow exporting IP range as ConfigMap&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/Azure/azure-service-operator/issues/3671&#34;&gt;#3671: DatabaseAccount CRD: Add support to store the account Id in a config map&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;(there may be more)&lt;/p&gt;</description>
    </item>
    <item>
      <title>Clarifying object structure</title>
      <link>https://azure.github.io/azure-service-operator/design/clarifying-object-structure/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://azure.github.io/azure-service-operator/design/clarifying-object-structure/</guid>
      <description>&lt;p&gt;Today we have resources that look like:&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;apiVersion&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;microsoft.storage.infra.azure.com/v1alpha1api20190401&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;kind&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;StorageAccount&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;metadata&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;samplekubestorage&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;namespace&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;default&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;spec&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;azureName&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;mykubestorage&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;location&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;westcentralus&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;kind&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;BlobStorage&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;sku&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;Standard_LRS&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;owner&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;k8sinfra-sample-rg&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;accessTier&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;Hot&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;tags&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;tag1&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;tag1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;tag2&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;tag2&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;the-problem&#34;&gt;The problem&lt;/h2&gt;&#xA;&lt;p&gt;There&amp;rsquo;s no good way with this object structure to differentiate stuff that is for Azure directly, versus stuff that is&#xA;for the operator. &lt;code&gt;owner&lt;/code&gt; &lt;em&gt;almost&lt;/em&gt; falls into this category already, but there are other likely upcoming properties that&#xA;definitely fall into this category:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;SecretConfiguration&lt;/code&gt;: details about where/how we should store secrets created by this entity.&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Credentials&lt;/code&gt;: per object credentials used to support CAPZ-like scenarios.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;The problem also manifests in &lt;code&gt;Status&lt;/code&gt; where ideally we would distinguish between properties from Azure directly (the&#xA;result of a GET on the resource) and properties that we are presenting. For example, we may want to have a status field&#xA;for &lt;code&gt;deploymentId&lt;/code&gt; documenting the deployment ID used to create the resource, or the &lt;code&gt;error&lt;/code&gt; if there was an error.&#xA;If we do that there&amp;rsquo;s no easy way for the customer to understand that field is provided by ASO and not by Storage.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Code generation for Crossplane</title>
      <link>https://azure.github.io/azure-service-operator/design/crossplane/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://azure.github.io/azure-service-operator/design/crossplane/</guid>
      <description>&lt;p&gt;The patterns identified below were extrapolated from &lt;a href=&#34;https://github.com/crossplane-contrib/provider-azure/blob/master/package/crds/network.azure.crossplane.io_virtualnetworks.yaml&#34;&gt;the Crossplane VNET spec&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;h2 id=&#34;general-notes&#34;&gt;General notes&lt;/h2&gt;&#xA;&lt;h3 id=&#34;crossplane-has-the-following-static-special-properties&#34;&gt;Crossplane has the following static &amp;ldquo;special&amp;rdquo; properties&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;ForProvider - this contains the actual &amp;ldquo;spec&amp;rdquo; as Azure would see it.&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;DeletionPolicy&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;ProviderConfigRef&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;WriteConnectionSecretToRef&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;Since these are statically shaped they should be relatively easy to add with Crossplane specific generator pipeline stages.&lt;/p&gt;&#xA;&lt;p&gt;Items #2-4 are included automatically by embedding the  &lt;code&gt;runtimev1alpha1.ResourceSpec&lt;/code&gt; from &lt;code&gt;runtimev1alpha1 &amp;quot;github.com/crossplane/crossplane-runtime/apis/core/v1alpha1&amp;quot;&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;h3 id=&#34;cross-resource-references-in-crossplane&#34;&gt;Cross resource references in Crossplane&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;X&lt;/code&gt; (e.g. &lt;code&gt;ResourceGroupName&lt;/code&gt;) - An actual field that exists in the Azure API. Can be set to any string you&amp;rsquo;d post to the Azure API.&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;XRef&lt;/code&gt; (e.g. &lt;code&gt;ResourceGroupNameRef&lt;/code&gt;) - A reference to a named Kubernetes object of a preordained kind. Used to resolve a value for &lt;code&gt;X&lt;/code&gt;.&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;XNameSelector&lt;/code&gt; (e.g. &lt;code&gt;ResourceGroupNameSelector&lt;/code&gt;) - A selector used to set &lt;code&gt;XRef&lt;/code&gt;.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;Note that these values cascade down from the selector, to the ref, to the underlying field. If the ref is already set the selector is ignored,&#xA;and if the field is already set the ref is ignored.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Custom validation and defaulting for code generated resources</title>
      <link>https://azure.github.io/azure-service-operator/design/defaulter-validator/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://azure.github.io/azure-service-operator/design/defaulter-validator/</guid>
      <description>&lt;h2 id=&#34;reasoning&#34;&gt;Reasoning&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;controller-runtime&lt;/code&gt; defines &lt;code&gt;admission.Defaulter&lt;/code&gt; and &lt;code&gt;admission.Validator&lt;/code&gt;. These interfaces only give you a single &lt;code&gt;Default&lt;/code&gt; or &lt;code&gt;ValidateX&lt;/code&gt; method, which means that all validation/defaulting needs to be done in that method. I think we&amp;rsquo;re going to quickly run into situations where we want custom (handcrafted) validations or defaults for a particular resource and we&amp;rsquo;re not going to want to teach the code generator about these.&lt;/p&gt;&#xA;&lt;h2 id=&#34;suggestion&#34;&gt;Suggestion&lt;/h2&gt;&#xA;&lt;p&gt;Structure our autogenerated webhooks such that there an ability to override the default behavior by implementing an interface.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Managing dataplane secrets</title>
      <link>https://azure.github.io/azure-service-operator/design/secrets/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://azure.github.io/azure-service-operator/design/secrets/</guid>
      <description>&lt;h2 id=&#34;what-secrets-are-we-talking-about&#34;&gt;What secrets are we talking about?&lt;/h2&gt;&#xA;&lt;p&gt;The secrets discussed in this document are associated with accessing the data plane of various services.&lt;/p&gt;&#xA;&lt;p&gt;Think: Accessing a &lt;code&gt;StorageAccount&lt;/code&gt; via Shared Key, accessing a &lt;code&gt;MySQLServer&lt;/code&gt; by admin &lt;code&gt;Username&lt;/code&gt; and &lt;code&gt;Password&lt;/code&gt;, or accessing a VM&#xA;by &lt;code&gt;SSHKey&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;Sometimes&lt;/em&gt; these secrets may be used by other CRDs managed by ASO, as would be the case for a &lt;code&gt;MySQLUser&lt;/code&gt; CRD, but often the consumers of these&#xA;secrets are the users applications.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Improving the Reconciler interface</title>
      <link>https://azure.github.io/azure-service-operator/design/reconcile-interface/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://azure.github.io/azure-service-operator/design/reconcile-interface/</guid>
      <description>&lt;h1 id=&#34;reconciler-interface&#34;&gt;Reconciler Interface&lt;/h1&gt;&#xA;&lt;p&gt;Today the interface is:&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Reconciler&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;Reconcile&lt;/span&gt;(&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;ctx&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;context&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Context&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;logr&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Logger&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;eventRecorder&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;record&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;EventRecorder&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;obj&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MetaObject&lt;/span&gt;) (&lt;span style=&#34;color:#a6e22e&#34;&gt;ctrl&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Result&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;error&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This is pretty similar to the interface that controller-runtime gives us:&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Reconciler&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Reconcile performs a full reconciliation for the object referred to by the Request.&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// The Controller will requeue the Request to be processed again if an error is non-nil or&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Result.Requeue is true, otherwise upon completion it will remove the work from the queue.&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;Reconcile&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;context&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Context&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;Request&lt;/span&gt;) (&lt;span style=&#34;color:#a6e22e&#34;&gt;Result&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;error&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The problem with the interface at this level is that each controller must duplicate certain checks. This not only involves needless code duplication, but also opens the door for subtle bugs when differences occur.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Proposal for reporting resource Status</title>
      <link>https://azure.github.io/azure-service-operator/design/resource-states/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://azure.github.io/azure-service-operator/design/resource-states/</guid>
      <description>&lt;h2 id=&#34;what-status-are-we-talking-about&#34;&gt;What Status are we talking about?&lt;/h2&gt;&#xA;&lt;p&gt;There are two types of Status that we&amp;rsquo;re interested in understanding and reporting to the user when running an operator that creates resources in Azure:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;The Status of the operator and its actions on the resource. Has the resource successfully been reconciled? Is the operator in the progress of driving the resource to its goal state (defined in the &lt;code&gt;spec&lt;/code&gt;), or has it already done so and is now&#xA;waiting for more changes before taking further action?&lt;/li&gt;&#xA;&lt;li&gt;The State of the resource in Azure. What fields are set in Azure? There are often defaults and other values which, while you may not have specified them in the &lt;code&gt;spec&lt;/code&gt; have been applied on the server side and we want to show to you.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;This document is focused on the first type of Status defined above.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Type References &amp; ownership</title>
      <link>https://azure.github.io/azure-service-operator/design/type-references-and-ownership/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://azure.github.io/azure-service-operator/design/type-references-and-ownership/</guid>
      <description>&lt;h2 id=&#34;related-reading&#34;&gt;Related reading&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/workloads/controllers/garbage-collection/&#34;&gt;Kubernetes garbage collection&lt;/a&gt;.&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://kubernetes.io/docs/reference/access-authn-authz/rbac/&#34;&gt;Kubernetes RBAC&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;related-projects&#34;&gt;Related Projects&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ASO: &lt;a href=&#34;https://github.com/Azure/azure-service-operator&#34;&gt;Azure Service Operator&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;k8s-infra: The handcrafted precurser to the code generation tool being designed.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;goals&#34;&gt;Goals&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Provide a way for customers to express relationships between Azure resources in an idiomatic Kubernetes way.&lt;/li&gt;&#xA;&lt;li&gt;Provide automatic ownership and garbage collection (using &lt;a href=&#34;https://kubernetes.io/docs/concepts/workloads/controllers/garbage-collection/&#34;&gt;Kubernetes garbage collection&lt;/a&gt;)&#xA;where appropriate (e.g. ResourceGroup as an owner of all the resources inside of it)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Ideally ResourceGroup is handled the same as other owners and isn&amp;rsquo;t special cased.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Define how Kubernetes interacts with Azure resources &lt;em&gt;not&lt;/em&gt; created/managed by Kubernetes, for example resources which were created prior to the&#xA;customer onboarding to the Azure Service Operator.&lt;/li&gt;&#xA;&lt;li&gt;References should be extensible to work across multiple Azure subscriptions, although&#xA;initially we may not support that.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;non-goals&#34;&gt;Non-goals&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Managing ownership for resources/resource hierarchies that were not created&#xA;by the service operator.&#xA;While this proposal allows references to point to external resources not managed by the service operator,&#xA;the operator is not watching/monitoring the resource in question&#xA;and as such cannot propagate deletes. Put another way: for the operator to manage ownership/object lifecycles, the entire resource hierarchy must exist &lt;em&gt;within Kubernetes&lt;/em&gt;. If only part of the resource hierarchy&#xA;is managed by the service operator, only those parts can have their lifecycles managed.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;different-kinds-of-resource-relationships-in-azure&#34;&gt;Different kinds of resource relationships in Azure&lt;/h2&gt;&#xA;&lt;h4 id=&#34;relatedlinked-resources&#34;&gt;Related/linked resources&lt;/h4&gt;&#xA;&lt;p&gt;Two resources are related to one another (&amp;ldquo;has-a&amp;rdquo; relationship), but there is no ownership.&#xA;Example: &lt;a href=&#34;https://github.com/Azure/k8s-infra/blob/master/apis/microsoft.compute/v1/virtualmachinescaleset_types.go#L169&#34;&gt;VMSS â†’ Subnet&lt;/a&gt; (&lt;a href=&#34;https://schema.management.azure.com/schemas/2019-07-01/Microsoft.Compute.json&#34;&gt;json schema&lt;/a&gt;).&lt;/p&gt;</description>
    </item>
    <item>
      <title>YEAR-MONTH: ADR TEMPLATE</title>
      <link>https://azure.github.io/azure-service-operator/design/adr-year-month-title/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://azure.github.io/azure-service-operator/design/adr-year-month-title/</guid>
      <description>&lt;h2 id=&#34;context&#34;&gt;Context&lt;/h2&gt;&#xA;&lt;h2 id=&#34;requirements&#34;&gt;Requirements&lt;/h2&gt;&#xA;&lt;!-- &#xA;## Options (optional) &#xA;&#xA;### Option 1: Foo&#xA;&#xA;**Pros:**&#xA;&#xA;- Pro 1&#xA;&#xA;**Cons:**&#xA;&#xA;- Con 1&#xA;&#xA;### Option 2: Bar&#xA;&#xA;**Pros:**&#xA;&#xA;- Pro 1&#xA;&#xA;**Cons:**&#xA;&#xA;- Con 1&#xA;&#xA;--&gt;&#xA;&lt;h2 id=&#34;decision&#34;&gt;Decision&lt;/h2&gt;&#xA;&lt;!--&#xA;### FAQ &#xA;&#xA;Q: Q1&#xA;&#xA;A: A1&#xA;--&gt;&#xA;&lt;h2 id=&#34;status&#34;&gt;Status&lt;/h2&gt;&#xA;&lt;p&gt;Proposed.&lt;/p&gt;&#xA;&lt;h2 id=&#34;consequences&#34;&gt;Consequences&lt;/h2&gt;&#xA;&lt;p&gt;TBC&lt;/p&gt;&#xA;&lt;h2 id=&#34;experience-report&#34;&gt;Experience Report&lt;/h2&gt;&#xA;&lt;p&gt;TBC&lt;/p&gt;&#xA;&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;&#xA;&lt;p&gt;None&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
