trigger:
  branches:
    include:
    - master

pool:
  vmImage: 'Ubuntu 16.04'

variables:
  major_version: 0
  minor_version: 0
  patch_version: $(Build.BuildId)
  goroot: '/usr/local/go1.12' # Go installation path
  gopath: '$(System.DefaultWorkingDirectory)/gopath' # Go workspace path
  gobin:  '$(gopath)/bin' # Go binaries path
  module_path: '$(gopath)/src/$(Build.Repository.Name)' # Path to the module's code
  image_name: 'github.com/Azure/azure-service-operator'
  # CONTAINER_REGISTRY:     - set this value in Azure Devops variables
  # AZURE_SUBSCRIPTION:     - set this value in Azure Devops variables
  # AZURE_SUBSCRIPTION_ID   - set this value in Azure Devops variables
  # AZURE_TENANT_ID:        - set this value in Azure Devops variables
  # AZURE_CLIENT_ID:        - set this value in Azure Devops variables
  # AZURE_CLIENT_SECRET:    - set this value in Azure Devops variables
  # REQUEUE_AFTER:          - set this value in Azure Devops variables
 
steps:

- checkout: self  # self represents the repo where the initial Pipelines YAML file was found
  lfs: "true"

- script: |
    set -x

    ls -l /usr/local/go*

    mkdir -p '$(gobin)'
    mkdir -p '$(gopath)/pkg'
    mkdir -p '$(module_path)'
    shopt -s extglob
    mv !(gopath) '$(module_path)'
    echo '##vso[task.prependpath]$(gobin)'
    echo '##vso[task.prependpath]$(goroot)/bin'

    go version
    go env
  displayName: 'Set up the Go workspace'
  env:
    GO111MODULE: on

- script: |
    set -x
    mkdir -p '$(module_path)/bin'
    os=$(go env GOOS)
    arch=$(go env GOARCH)
    # download kubebuilder
    curl -sL https://go.kubebuilder.io/dl/2.0.0-alpha.4/${os}/${arch} | tar -xz -C $(module_path)/bin
    mv $(module_path)/bin/kubebuilder_2.0.0-alpha.4_${os}_${arch}/bin/* $(module_path)/bin/
    # download kustomize
    curl -o $(module_path)/bin/kustomize -sL https://go.kubebuilder.io/kustomize/${os}/${arch}
    # set permission
    chmod a+x $(module_path)/bin/*
    # export path
    export PATH=$PATH:$(module_path)/bin
    go mod download
    go get -u github.com/jstemmer/go-junit-report
    go get github.com/axw/gocov/gocov
    go get github.com/AlekSi/gocov-xml
    go get -u gopkg.in/matm/v1/gocov-html
    go get golang.org/x/tools/cmd/cover
   

  continueOnError: 'true'
  displayName: 'Install kubebuilder, kustomize and set environment'
  env:
    GO111MODULE: on
    KUBEBUILDER_ASSETS: $(module_path)/bin
    AZURE_SUBSCRIPTION: $(AZURE_SUBSCRIPTION)
    AZURE_SUBSCRIPTION_ID: $(AZURE_SUBSCRIPTION_ID)
    AZURE_TENANT_ID: $(AZURE_TENANT_ID)
    AZURE_CLIENT_ID: $(AZURE_CLIENT_ID)
    AZURE_CLIENT_SECRET: $(AZURE_CLIENT_SECRET)
    REQUEUE_AFTER: $(REQUEUE_AFTER)
  workingDirectory: '$(module_path)'

- script: |
    make test
    gocov convert coverage.txt > coverage.json
    gocov-xml < coverage.json > coverage.xml
    mkdir coverage
    gocov-html < coverage.json > coverage/index.html

  continueOnError: 'false'
  displayName: 'Run unit tests'
  env:
    GO111MODULE: on
    KUBEBUILDER_ASSETS: $(module_path)/bin
    AZURE_SUBSCRIPTION: $(AZURE_SUBSCRIPTION)
    AZURE_SUBSCRIPTION_ID: $(AZURE_SUBSCRIPTION_ID)
    AZURE_TENANT_ID: $(AZURE_TENANT_ID)
    AZURE_CLIENT_ID: $(AZURE_CLIENT_ID)
    AZURE_CLIENT_SECRET: $(AZURE_CLIENT_SECRET)
    REQUEUE_AFTER: $(REQUEUE_AFTER)
  workingDirectory: '$(module_path)'

- script: |
    GO111MODULE="on" go get sigs.k8s.io/kind@v0.4.0
    kind create cluster
    export KUBECONFIG=$(kind get kubeconfig-path --name="kind")
    kubectl cluster-info
    kubectl create namespace cert-manager
    kubectl label namespace cert-manager certmanager.k8s.io/disable-validation=true
    kubectl apply -f https://github.com/jetstack/cert-manager/releases/download/v0.9.0/cert-manager.yaml
    kubectl create namespace azureoperator-system 
    kubectl --namespace azureoperator-system \
      create secret generic azureoperatorsettings \
      --from-literal=AZURE_CLIENT_ID=${AZURE_CLIENT_ID} \
      --from-literal=AZURE_CLIENT_SECRET=${AZURE_CLIENT_SECRET} \
      --from-literal=AZURE_SUBSCRIPTION_ID=${AZURE_SUBSCRIPTION_ID} \
      --from-literal=AZURE_TENANT_ID=${AZURE_TENANT_ID}
    #create image and load it into cluster
    IMG="docker.io/controllertest:1" make docker-build
    kind load docker-image docker.io/controllertest:1 --loglevel "trace"
    make install
    kubectl get namespaces
    echo "sleep 80 seconds to get the cert pods running"
    sleep 80
    echo "end of sleep"
    kubectl get pods --namespace cert-manager
    echo "all the pods should be running"
    make deploy
  continueOnError: 'false'
  displayName: 'set kind cluster and Run unit tests'
  env:
    GO111MODULE: on
    KUBEBUILDER_ASSETS: $(module_path)/bin
    AZURE_SUBSCRIPTION: $(AZURE_SUBSCRIPTION)
    AZURE_SUBSCRIPTION_ID: $(AZURE_SUBSCRIPTION_ID)
    AZURE_TENANT_ID: $(AZURE_TENANT_ID)
    AZURE_CLIENT_ID: $(AZURE_CLIENT_ID)
    AZURE_CLIENT_SECRET: $(AZURE_CLIENT_SECRET)
    REQUEUE_AFTER: $(REQUEUE_AFTER)
  workingDirectory: '$(module_path)'

- task: PublishTestResults@2
  inputs:
    failedTaskOnFailedTest: true
    testRunner: JUnit
    testResultsFiles: $(System.DefaultWorkingDirectory)/**/report.xml


- task: PublishCodeCoverageResults@1
  inputs:
    codeCoverageTool: Cobertura 
    summaryFileLocation: $(System.DefaultWorkingDirectory)/**/coverage.xml
    reportDirectory: $(System.DefaultWorkingDirectory)/**/coverage

- script: docker build -t $(image_name) .  # add options to this command to meet your needs
  condition: and(succeeded(), ne(variables['Build.SourceBranch'], 'refs/heads/master'))
  displayName: 'Docker build'
  workingDirectory: '$(module_path)'

- task: Docker@2
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/master'))
  displayName: Build Docker Image $(image_name)
  inputs:
    command: build
    containerRegistry: $(CONTAINER_REGISTRY)
    repository: $(image_name)
    Dockerfile: "$(module_path)/Dockerfile"    
    buildContext: $(module_path)
    tags: |
      latest
      $(Build.SourceVersion)
      $(major_version)
      $(major_version).$(minor_version)
      $(major_version).$(minor_version).$(patch_version)

  
- task: Docker@2
  displayName: Push Docker Image $(image_name)
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/master'))
  inputs:
    command: push
    containerRegistry: $(CONTAINER_REGISTRY)
    repository: $(image_name)
    tags: |
      latest
      $(Build.SourceVersion)
      $(major_version)
      $(major_version).$(minor_version)
      $(major_version).$(minor_version).$(patch_version)


- script: |
    echo "updating kustomize image patch file for manager resource"
    echo $(image_name)
    echo $(major_version)
    echo $(minor_version)
    echo $(patch_version)
    echo $(image_name):$(major_version).$(minor_version).$(patch_version)
    IMG="$(image_name):$(major_version).$(minor_version).$(patch_version)"
    echo $IMG
    sed -i -e 's@IMAGE_URL@'${IMG}'@g' ./config/default/manager_image_patch.yaml
    ./bin/kustomize build config/default > $(Build.ArtifactStagingDirectory)/setup.yaml
    set -x
    echo $IMG > $(Build.ArtifactStagingDirectory)/github.com/Azure/azure-service-operator.txt
    ls $(Build.ArtifactStagingDirectory)
  continueOnError: 'false'
  displayName: 'Prepare manifests for publish'
  workingDirectory: '$(module_path)'
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/master')) 

- task: PublishBuildArtifacts@1
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/master'))
  inputs:
    pathtoPublish: $(Build.ArtifactStagingDirectory)
    artifactName: drop
