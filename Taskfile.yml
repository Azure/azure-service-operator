version: '3.7'

run: when_changed
output: prefixed

vars:
  PACKAGE: github.com/Azure/azure-service-operator/v2

  GENERATOR_APP: aso-gen
  GENERATOR_ROOT: v2/tools/generator/

  ASOCTL_APP: asoctl
  ASOCTL_ROOT: v2/cmd/asoctl/

  CONTROLLER_APP: aso-controller
  CONTROLLER_ROOT: v2/
  CONTROLLER_OUTPUT:
    sh: 'realpath v2/config'

  MANGLE_ROOT: v2/tools/mangle-test-json

  TEST_RESOURCE_PREFIX: asotest
  TEST_LIVE_RESOURCE_PREFIX: asolivetest
  SCRIPTS_ROOT:
    sh: 'realpath scripts/v2'

  HEADER_FILE:
    sh: 'realpath v2/boilerplate.go.txt'

  TEST_OUT:
    sh: 'realpath reports'

  VERSION:
    # Version tags for the v2 controller must start with "v2", e.g. "v2.0.0-alpha.0".
    sh: "{{.SCRIPTS_ROOT}}/build_version.py v2"

  LATEST_VERSION_TAG:
    sh: git describe --tags $(git rev-list --tags='v2*' --max-count=1) --match 'v2*'

  VERSION_FLAGS: '"-X {{.PACKAGE}}/internal/version.BuildVersion={{.VERSION}}"'
  LDFLAGS: -ldflags {{.VERSION_FLAGS}}

  CONTROLLER_DOCKER_IMAGE: azureserviceoperator:{{.VERSION}}
  PUBLIC_REGISTRY: mcr.microsoft.com/k8s/
  LOCAL_REGISTRY_CONTROLLER_DOCKER_IMAGE: localhost:5000/azureserviceoperator:latest

  CROSSPLANE_APP: crossplane-gen
  CROSSPLANE_ROOT: ./hack/crossplane/
  CROSSPLANE_OUTPUT:
    sh: 'realpath hack/crossplane/config'

  # how long to let tests against live resources run for
  LIVE_TEST_TIMEOUT: 3h

  ASO_NAMESPACE: azureserviceoperator-system

  ACR_NAME:
    sh: "echo $(hostname)asoacr | sed 's/[^[:alpha:]]//g'" # Only alphanumeric allowed for acr names

  KIND_WORKLOAD_IDENTITY_PATH: "v2/out/kind-identity"
  AKS_WORKLOAD_IDENTITY_PATH: "v2/out/aks-identity"

tasks:
  default:
    cmds:
      - task: format-code # Run before quick-checks to avoid racing with generated file creation
      - task: quick-checks

  quick-checks:
    desc: Perform all fast local pre-commit tasks.
    deps:
      - generator:quick-checks
      - controller:quick-checks
      - asoctl:quick-checks
      - crossplane:quick-checks
      - mangle-test:quick-checks

  setup:
    desc: Perform setup tasks
    cmds:
      - "mkdir -p {{.TEST_OUT}}"

  ci:
    desc: Run all CI checks.
    cmds:
      # Run tasks in sequence to avoid racing with generated file creation,
      # and to avoid running the generator in parallel
      - task: generator:ci
      - task: controller:ci
      - task: crossplane:ci
      - task: asoctl:ci
      - task: format-code
      - task: verify-no-changes

  ci-live:
    desc: Run all CI checks with live Azure resources. Requires that auth environment variables are set.
    deps:
      - generator:ci
      - controller:ci-live

  format-code:
    desc: Ensure all code is formatted
    dir: v2
    cmds:
      - task: asoctl:format-code
      - task: generator:format-code
      - task: controller:format-code

  go-mod-tidy:
    desc: Tidy the go.mod files
    dir : v2
    cmds:
      - task: controller:go-mod-tidy
      - task: asoctl:go-mod-tidy
      - task: generator:go-mod-tidy

  build-docs-site:
    cmds:
      - task: doc:build-site

  basic-checks:
    deps: 
      - header-check
      - specifier-check

  make-release-artifacts:
    desc: Produce files required for an ASOv2 release
    dir: "{{.CONTROLLER_ROOT}}"
    deps:
      - controller:run-kustomize
      - controller:make-multitenant-files
      - asoctl:make-release-artifacts
    cmds:
      - rm -rf out/release
      - mkdir -p out/release
      - cp ./bin/{azureserviceoperator,multitenant-cluster,multitenant-tenant}_*.yaml out/release
      - cp ./bin/asoctl* out/release

  ############### Asoctl targets ###############

  asoctl:quick-checks:
    cmds:
      - task: asoctl:unit-tests
      - task: basic-checks
      - task: asoctl:lint

  asoctl:ci:
    cmds:
      - task: asoctl:unit-tests-cover
      - task: basic-checks
      - task: asoctl:lint

  asoctl:unit-tests:
    desc: Run {{.ASOCTL_APP}} unit tests.
    dir: '{{.ASOCTL_ROOT}}'
    deps:
      - controller:generate-crds
    cmds:
      - go test ./... -tags=noexit -run '{{default ".*" .TEST_FILTER}}'

  asoctl:unit-tests-cover:
    desc: Run {{.ASOCTL_APP}} unit tests and output coverage.
    dir: '{{.ASOCTL_ROOT}}'
    deps:
      - setup
      - controller:generate-crds
    cmds:
      - defer: # want to run even on failure
          task: produce-markdown-summary
          vars:
            INPUT_FILE: '{{.TEST_OUT}}/asoctl-unit-tests.json'
            OUTPUT_FILE: '{{.TEST_OUT}}/asoctl-unit-tests.md'
      - go test ./... -tags=noexit -race -covermode atomic -coverprofile='{{.TEST_OUT}}/asoctl-coverage.out' -json -coverpkg=./... -run '{{default ".*" .TEST_FILTER}}' > '{{.TEST_OUT}}/asoctl-unit-tests.json'

  asoctl:format-code:
    desc: Ensure all code for asoctl is formatted
    dir: v2/cmd/asoctl/
    cmds:
      - cmd: gofumpt -l -w .
        ignore_error: true # Just in case the code doesn't build

  asoctl:go-mod-tidy:
    desc: Tidy the go.mod file
    dir : v2/cmd/asoctl/
    cmds:
      - go mod tidy
      
  asoctl:lint:
    desc: Run {{.ASOCTL_APP}} fast lint checks.
    dir: '{{.ASOCTL_ROOT}}'
    cmds:
      - golangci-lint run --verbose --fix --timeout 5m ./...

  asoctl:build:
    desc: Generate the {{.ASOCTL_APP}} binary.
    dir: '{{.ASOCTL_ROOT}}'
    label: asoctl:build-{{.GOOS}}-{{.GOARCH}}
    generates:
      - "{{.ARCHIVE}}"
    cmds:
      - mkdir -p ./bin/{{.GOOS}}-{{.GOARCH}}
      - GOOS={{.GOOS}} GOARCH={{.GOARCH}} go build {{.LDFLAGS}} -o {{.EXECUTABLE}}
      - if [ "{{.ARCHIVETYPE}}" = ".zip" ]; then zip -j -r {{.ARCHIVE}} {{.EXECUTABLE}}; fi
      - if [ "{{.ARCHIVETYPE}}" = ".gz" ]; then gzip -v -c {{.EXECUTABLE}} > {{.ARCHIVE}} ; fi
    vars:
      GOOS: '{{default OS .GOOS}}'
      EXT: '{{if eq .GOOS "windows"}}.exe{{else}}{{end}}'
      ARCHIVETYPE: '{{if eq .GOOS "windows"}}.zip{{else}}.gz{{end}}'
      GOARCH: '{{default ARCH .GOARCH}}'
      EXECUTABLE: ./bin/{{.GOOS}}-{{.GOARCH}}/{{.ASOCTL_APP}}{{.EXT}}
      ARCHIVE: ../../bin/{{.ASOCTL_APP}}-{{.GOOS}}-{{.GOARCH}}{{.ARCHIVETYPE}}

  asoctl:make-release-artifacts:
    desc: Produce asoctl files required for an ASOv2 release
    dir: "{{.CONTROLLER_ROOT}}"
    deps:
        # Regenerating the deepcopy files deletes and regenerates them, 
        # so we have to ensure this runs before we do any asoctl builds
      - controller:run-kustomize
    cmds:
      - task: asoctl:build
        vars: {GOOS: "linux", GOARCH: "amd64"}
      - task: asoctl:build
        vars: {GOOS: "linux", GOARCH: "arm64"}
      - task: asoctl:build
        vars: {GOOS: "darwin", GOARCH: "amd64"}
      - task: asoctl:build
        vars: {GOOS: "darwin", GOARCH: "arm64"}
      - task: asoctl:build
        vars: {GOOS: "windows", GOARCH: "amd64"}
  
  ############### Generator targets ###############

  generator:quick-checks:
    cmds:
      - task: generator:unit-tests
      - task: basic-checks
      - task: generator:lint

  generator:ci:
    cmds:
      - task: generator:unit-tests-cover
      - task: basic-checks
      - task: generator:lint

  generator:unit-tests:
    desc: Run {{.GENERATOR_APP}} unit tests.
    dir: '{{.GENERATOR_ROOT}}'
    cmds:
      - go test ./... -tags=noexit -run '{{default ".*" .TEST_FILTER}}'

  generator:unit-tests-cover:
    desc: Run {{.GENERATOR_APP}} unit tests and output coverage.
    dir: '{{.GENERATOR_ROOT}}'
    deps:
      - setup
    cmds:
      - defer: # want to run even on failure
          task: produce-markdown-summary
          vars:
            INPUT_FILE: '{{.TEST_OUT}}/generator-unit-tests.json'
            OUTPUT_FILE: '{{.TEST_OUT}}/generator-unit-tests.md'
      - go test ./... -tags=noexit -race -covermode atomic -coverprofile='{{.TEST_OUT}}/generator-coverage.out' -json -coverpkg=./... -run '{{default ".*" .TEST_FILTER}}' > '{{.TEST_OUT}}/generator-unit-tests.json'

  generator:update-golden-tests:
    desc: Update {{.GENERATOR_APP}} golden test outputs.
    dir: '{{.GENERATOR_ROOT}}'
    cmds:
      - go test ./... -run ^TestGolden -update

  generator:format-code:
    desc: Ensure all code for the code generator is formatted
    dir: v2/tools/generator
    cmds:
      - cmd: gofumpt -l -w .
        ignore_error: true # Just in case the code doesn't build

  generator:go-mod-tidy:
    desc: Tidy the go.mod file
    dir : v2/tools/generator
    cmds:
      - go mod tidy

  generator:lint:
    desc: Run {{.GENERATOR_APP}} lint checks.
    dir: '{{.GENERATOR_ROOT}}'
    cmds:
      - golangci-lint run --verbose --fix

  generator:build:
    desc: Generate the {{.GENERATOR_APP}} binary.
    dir: '{{.GENERATOR_ROOT}}'
    cmds:
      - go build {{.LDFLAGS}} -o ../../bin/{{.GENERATOR_APP}} .

  # Stub retained until migration of workflows complete
  generator:diagrams:
    cmds:
      - task: doc:render-diagrams

  ############### Controller targets ###############

  controller:quick-checks:
    cmds:
      - task: controller:test
      # checks must be after test as that will generate code
      - task: basic-checks
      - task: controller:verify-samples
      # Lint is forced to the end because it expects the code is formatted
      - task: controller:lint

  controller:ci:
    cmds:
      - task: controller:verify-samples
      - task: controller:test-cover
      - task: controller:test-integration-ci
      # checks must be after test as that will generate code
      - task: basic-checks
      # lint must be at end after code is formatted
      - task: controller:lint

  controller:ci-integration-tests:
    cmds:
      - task: cleanup-old-live-azure-resources
      - task: controller:test-integration-kind-ci
      - task: controller:test-multitenant-integration-kind-ci
      - task: cleanup-old-live-azure-resources  # Run this on both sides of the test pass to do our best to avoid leaking something

  controller:ci-live:
    cmds:
      - task: controller:test-integration-ci-live
      - task: basic-checks
      - task: controller:lint

  controller:format-code:
    desc: Ensure all code for the controller is formatted
    dir: v2
    cmds:
      - cmd: gofumpt -l -w .
        ignore_error: true # Just in case the code doesn't build

  controller:go-mod-tidy:
    desc: Tidy the go.mod file
    dir : v2
    cmds:
      - go mod tidy

  controller:lint:
    desc: Run lint checks.
    deps: 
      - controller:generate-crds
    dir: "{{.CONTROLLER_ROOT}}"
    cmds:
      # Setting GOGC to increase how much debris is tolerated before running GC
      - GOGC=200 golangci-lint run --verbose --fix --timeout 20m ./...

  controller:verify-samples:
    desc: Verify that a sample exists for each supported resource
    deps: 
      - controller:generate-crds
    cmds:
      - "{{.SCRIPTS_ROOT}}/check_samples.py v2/"

  controller:test:
    desc: Run {{.CONTROLLER_APP}} unit tests.
    dir: "{{.CONTROLLER_ROOT}}"
    # controller:run-kustomize-for-envtest isn't strictly required here, but running it here so that
    # integration tests can be run manually (via IDE) after running "task"
    deps:
      - controller:generate-crds
      - controller:run-kustomize-for-envtest
      - controller:bundle-crds # bundle-crds is here because some tests assert on generated CRD shape
    cmds:
      - go test -short -tags=noexit -timeout 10m -run '{{default ".*" .TEST_FILTER}}' ./...

  controller:test-cover:
    desc: Run {{.CONTROLLER_APP}} unit tests and output coverage.
    dir: "{{.CONTROLLER_ROOT}}"
    deps:
    - setup
    - controller:generate-crds
    - controller:bundle-crds # bundle-crds is here because some tests assert on generated CRD shape
    cmds:
      - defer: # want to run even on failure
          task: produce-markdown-summary
          vars:
            INPUT_FILE: '{{.TEST_OUT}}/controller-unit-tests.json'
            OUTPUT_FILE: '{{.TEST_OUT}}/controller-unit-tests.md'
      # -race fails at the moment in gopter - possibly due to our shared generator variable?
      - go test -short -tags=noexit -timeout 10m -covermode atomic -coverprofile='{{.TEST_OUT}}/controller-coverage.out' -json -coverpkg="./..." -run '{{default ".*" .TEST_FILTER}}' ./... > '{{.TEST_OUT}}/controller-unit-tests.json'

  controller:test-upgrade-setup:
    desc: Setup for upgrade test
    dir: "{{.CONTROLLER_ROOT}}"
    cmds:
      - task: controller:kind-create-wi
      - task: controller:create-mi-for-workload-identity
      - task: controller:install-cert-manager
      - task: controller:package-helm-manifest
      # We need the below to wait until cert-manager is up, otherwise the subsequent installation of webhooks fails. See https://cert-manager.io/next-docs/installation/verify/
      - "cmctl check api --wait=2m"

  controller:test-upgrade-pre-setup:
    desc: Setup for the test-upgrade-pre step
    dir: "{{.CONTROLLER_ROOT}}"
    cmds:
      - "helm repo add asov2 https://raw.githubusercontent.com/Azure/azure-service-operator/main/v2/charts"
      - "helm repo update"
      - "helm upgrade --install aso2 asov2/azure-service-operator \
        --create-namespace \
        --namespace={{.ASO_NAMESPACE}} \
        --set azureSubscriptionID=$AZURE_SUBSCRIPTION_ID \
        --set azureTenantID=$AZURE_TENANT_ID \
        --set azureClientID={{.AZURE_MI_CLIENT_ID}} \
        --set useWorkloadIdentityAuth=true \
        --set crdPattern=*"
      - task: controller:wait-for-operator-ready
    vars:
      DIR: "{{.DIR | default .KIND_WORKLOAD_IDENTITY_PATH}}"
      AZURE_MI_CLIENT_ID:
        sh: "cat {{.DIR}}/azure/miclientid.txt"

  controller:test-upgrade-pre:
    desc: Test upgrading {{.CONTROLLER_APP}} and helm chart for new release
    dir: "{{.CONTROLLER_ROOT}}"
    deps:
      - controller:test-upgrade-pre-setup
    cmds:
      - "kubectl create namespace pre-release"
      - "go test -timeout 15m -count=1 -v -run Test_Pre_Release_ResourceCanBeCreated_BeforeUpgrade ./test/pre-release"
    vars:
      DIR: "{{.DIR | default .KIND_WORKLOAD_IDENTITY_PATH}}"
      AZURE_MI_CLIENT_ID:
        sh: "cat {{.DIR}}/azure/miclientid.txt"

  controller:test-upgrade-apply-prerelease-chart:
    desc: Apply the {{.CONTROLLER_APP}} prerelease chart for new release
    dir: "{{.CONTROLLER_ROOT}}"
    cmds:
      - task: controller:docker-push-local
      - task: controller:package-helm-manifest
      - task: controller:install-helm-wi
        vars:
          AZURE_MI_CLIENT_ID:
            sh: "cat {{.DIR}}/azure/miclientid.txt"
    vars:
      DIR: "{{.DIR  | default .KIND_WORKLOAD_IDENTITY_PATH}}"

  controller:test-upgrade-post:
    desc: Test upgrading {{.CONTROLLER_APP}} and helm chart for new release
    dir: "{{.CONTROLLER_ROOT}}"
    cmds:
      - task: controller:test-upgrade-apply-prerelease-chart
      - "go test -timeout 15m -count=1 -v -run Test_Pre_Release_ResourceCanBeCreated_AfterUpgrade ./test/pre-release"
      - task: controller:kind-delete

  controller:test-upgrade:
    desc: Test upgrading {{.CONTROLLER_APP}} and helm chart for new release
    dir: "{{.CONTROLLER_ROOT}}"
    cmds:
      - task: controller:test-upgrade-setup
      - task: controller:test-upgrade-pre
      - task: controller:test-upgrade-post

  controller:build:
    desc: Generate the {{.CONTROLLER_APP}} binary.
    dir: "{{.CONTROLLER_ROOT}}"
    deps: 
      - controller:generate-crds
    sources:
      - "go.mod"
      - "go.sum"
      - "**/*.go"
    cmds:
      - CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build {{.LDFLAGS}} -o ./bin/{{.CONTROLLER_APP}} ./cmd/controller/

  controller:docker-build:
    desc: Builds the {{.CONTROLLER_APP}} Docker image.
    dir: "{{.CONTROLLER_ROOT}}"
    deps:
      - controller:bundle-crds
    run: always
    sources:
      - "go.mod"
      - "go.sum"
      - "**/*.go"
      - "out/crds/**/*"
      - Dockerfile
    cmds:
      - docker build . --build-arg VERSION_FLAGS={{.VERSION_FLAGS}} --build-arg CONTROLLER_APP={{.CONTROLLER_APP}} -t {{.CONTROLLER_DOCKER_IMAGE}}

  controller:docker-build-and-save:
    desc: Builds the {{.CONTROLLER_APP}} Docker image and saves it using docker save.
    dir: "{{.CONTROLLER_ROOT}}"
    deps:
      - controller:docker-build
    cmds:
      - docker save {{.CONTROLLER_DOCKER_IMAGE}} > bin/$(echo '{{.CONTROLLER_DOCKER_IMAGE}}' | sed -e 's/:/_/g').tar

  controller:docker-push-local:
    desc: Pushes the controller container image to a local registry
    deps: 
      - controller:bundle-crds
    dir: "{{.CONTROLLER_ROOT}}"
    run: always
    sources:
      - "go.mod"
      - "go.sum"
      - "**/*.go"
      - "out/crds/**/*"
      - Dockerfile
    cmds:
      # We don't use multi-arch images here for local registry as building cross-platform image takes about 10-15 minutes to build.
      # Which would increase our CI time and in the local environment, only the same architecture image is going to be pulled always.
      - docker buildx create --driver-opt network=host --use
      - docker buildx build --push
        --build-arg VERSION_FLAGS={{.VERSION_FLAGS}}
        --build-arg CONTROLLER_APP={{.CONTROLLER_APP}}
        --tag "{{.LOCAL_REGISTRY_CONTROLLER_DOCKER_IMAGE}}" .

  controller:docker-push-multiarch:
    desc: Builds, tags and pushes the multi architecture controller container image to repository
    deps:
      - controller:bundle-crds
      - task: docker-login
        vars:
          DOCKER_REGISTRY: "{{.DOCKER_REGISTRY}}"
    dir: "{{.CONTROLLER_ROOT}}"
    run: always
    cmds:
      - 'if [ -z "{{.DOCKER_PUSH_TARGET}}" ]; then echo "Error: DOCKER_PUSH_TARGET must be set"; exit 1; fi'
      - docker buildx create --use
      - docker buildx build --push 
        --build-arg VERSION_FLAGS={{.VERSION_FLAGS}}
        --build-arg CONTROLLER_APP={{.CONTROLLER_APP}}
        --platform {{.PLATFORMS}} 
        --tag "{{.DOCKER_PUSH_TARGET}}/{{.CONTROLLER_DOCKER_IMAGE}}" .
    vars:
      PLATFORMS: '{{default "linux/amd64,linux/arm64" .PLATFORMS}}'
      DOCKER_PUSH_TARGET:
        sh: |
          if [ ! -z "${DOCKER_PUSH_TARGET}" ]; then
            echo "${DOCKER_PUSH_TARGET}"
          else
            echo "{{.DOCKER_PUSH_TARGET}}"
          fi

  controller:acr-protect-image:
    desc: Protects an existing image in ACR from being updated or deleted
    dir: "{{.CONTROLLER_ROOT}}"
    deps:
      - az-login
    run: always
    cmds:
      - 'if [ -z "{{.DOCKER_PUSH_TARGET}}" ]; then echo "Error: DOCKER_PUSH_TARGET must be set"; exit 1; fi'
      - 'if [ -z "${DOCKER_REGISTRY}" ]; then echo "Error: DOCKER_REGISTRY must be set"; exit 1; fi'
      - az acr repository update --name ${DOCKER_REGISTRY} --image "{{.DOCKER_PUSH_TARGET}}/{{.CONTROLLER_DOCKER_IMAGE}}" --write-enabled false --delete-enabled false
    vars:
      # This strips the leftmost .*.azurecr.io/ from the PUSH_TARGET as the acr repository update command doesn't want that bit in the image parameter
      DOCKER_PUSH_TARGET:
        sh: |
          if [ ! -z "${DOCKER_PUSH_TARGET}" ]; then
            echo "${DOCKER_PUSH_TARGET}" | sed -e "s|^.*.azurecr.io/||"
          else
            echo "{{.DOCKER_PUSH_TARGET}}" | sed -e "s|^.*.azurecr.io/||"
          fi

  controller:test-integration-envtest:
    desc: Run integration tests with envtest using record/replay.
    dir: "{{.CONTROLLER_ROOT}}"
    deps: 
      - controller:run-kustomize-for-envtest
    cmds:
      # -race fails at the moment in controller-runtime
      # We run these in sequence right now because it doesn't gain us much speed to go in parallel
      - go test -count=1 -timeout {{.TIMEOUT}} -run '{{default ".*" .TEST_FILTER}}' {{.VERBOSE}} ./internal/controllers
      - go test -count=1 -timeout {{.TIMEOUT}} -run '{{default ".*" .TEST_FILTER}}' {{.VERBOSE}} ./pkg/genruntime/test
      - go test -count=1 -timeout {{.TIMEOUT}} -run '{{default ".*" .TEST_FILTER}}' {{.VERBOSE}} ./internal/genericarmclient
    vars:
      VERBOSE:
        sh: if [ $TEST_FILTER ];  then echo "-v"; fi
      TIMEOUT: '{{default "20m" .TIMEOUT}}'  # Should be kept in sync with the -cover variant below

  # This target is intended for local use only
  controller:test-integration-envtest-record:
    desc: Run integration tests with envtest with a longer timeout suitable for recording the tests.
    dir: "{{.CONTROLLER_ROOT}}"
    deps: 
      - controller:run-kustomize-for-envtest
    cmds:
       - go test -timeout {{.TIMEOUT}} -run '{{default ".*" .TEST_FILTER}}' {{.VERBOSE}} ./internal/controllers -args -live
    vars:
      VERBOSE:
        sh: if [ $TEST_FILTER ];  then echo "-v"; fi
      TIMEOUT: '{{.LIVE_TEST_TIMEOUT}}'

  controller:test-integration-envtest-cover:
    desc: Run integration tests with envtest using record/replay and output coverage.
    dir: "{{.CONTROLLER_ROOT}}"
    deps:
      - setup
      - controller:run-kustomize-for-envtest
    cmds:
      - defer: # want to run even on failure
          task: produce-markdown-summary
          vars:
            INPUT_FILE: '{{.TEST_OUT}}/controller-integration-tests.json'
            OUTPUT_FILE: '{{.TEST_OUT}}/controller-integration-tests.md'
      - defer: # want to run even on failure
          task: produce-markdown-summary
          vars:
            INPUT_FILE: '{{.TEST_OUT}}/controller-integration-genruntime-tests.json'
            OUTPUT_FILE: '{{.TEST_OUT}}/controller-integration-genruntime-tests.md'
      - defer: # want to run even on failure
          task: produce-markdown-summary
          vars:
            INPUT_FILE: '{{.TEST_OUT}}/controller-integration-genericarmclient-tests.json'
            OUTPUT_FILE: '{{.TEST_OUT}}/controller-integration-genericarmclient-tests.md'
      # -race fails at the moment in controller-runtime
      - go test -covermode atomic -coverprofile='{{.TEST_OUT}}/coverage-integration-envtest.out' -coverpkg="./..." -json -timeout {{.TIMEOUT}} -run '{{default ".*" .TEST_FILTER}}' ./internal/controllers > '{{.TEST_OUT}}/controller-integration-tests.json'
      - go test -covermode atomic -coverprofile='{{.TEST_OUT}}/coverage-integration-genruntime-envtest.out' -coverpkg="./..." -json -timeout {{.TIMEOUT}} -run '{{default ".*" .TEST_FILTER}}' ./pkg/genruntime/test > '{{.TEST_OUT}}/controller-integration-genruntime-tests.json'
      - go test -covermode atomic -coverprofile='{{.TEST_OUT}}/coverage-integration-genericarmclient-envtest.out' -coverpkg="./..." -json -timeout {{.TIMEOUT}} -run '{{default ".*" .TEST_FILTER}}' ./internal/genericarmclient > '{{.TEST_OUT}}/controller-integration-genericarmclient-tests.json'
    vars:
      TIMEOUT: '20m'  # Should be kept in sync with the non-cover variant above

  controller:test-integration-envtest-live:
    desc: Run integration tests with envtest against live data and output coverage.
    dir: "{{.CONTROLLER_ROOT}}"
    deps:  
      - controller:run-kustomize-for-envtest
      - cleanup-azure-resources
    cmds:
      # -race fails at the moment in controller-runtime
      - go test -timeout {{.LIVE_TEST_TIMEOUT}} -covermode atomic -coverprofile='{{.TEST_OUT}}/coverage-integration-envtest-live.out' -coverpkg="./..." -run '{{default ".*" .TEST_FILTER}}' ./internal/controllers -args -live
    env:
      RECORD_REPLAY: 0

  controller:test-integration-kind-ci:
    desc: Run live integration tests in kind and deletes the kind cluster afterwards.
    dir: "{{.CONTROLLER_ROOT}}"
    deps:  
      - controller:kind-create-helm-workload-identity
    cmds:
      # This timeout is purposefully low - if we find that this job is taking a long time we may need to think of other ways
      # to keep CI fast
      - defer: { task: controller:kind-delete }
      - go test -timeout 40m -run '{{default ".*" .TEST_FILTER}}' ./test

  # Note that this target isn't used in CI and is intended for use when running locally on a kind cluster
  # that you don't want to delete (in contrast to test-integration-kind-ci which will delete the kind cluster
  # when it is done.
  controller:test-integration-kind:
    desc: Run live integration tests in kind.
    dir: "{{.CONTROLLER_ROOT}}"
    deps: 
      - controller:kind-create-helm-workload-identity
    cmds:
      # This timeout is purposefully low - if we find that this job is taking a long time we may need to think of other ways
      # to keep CI fast
      - go test -timeout 40m -v -run '{{default ".*" .TEST_FILTER}}' ./test

  controller:test-multitenant-integration-kind-ci:
    desc: Run live multitenant integration tests in kind.
    dir: "{{.CONTROLLER_ROOT}}"
    deps: 
       - controller:kind-create-multitenant-cluster-helm
    cmds:
      # This timeout is purposefully low - if we find that this job is
      # taking a long time we may need to think of other ways to keep
      # CI fast
      - defer: { task: controller:kind-delete }
      - go test -timeout 15m -v -run '{{default ".*" .TEST_FILTER}}' ./test/multitenant

  # Note that this target isn't used in CI and is intended for use
  # when running locally on a kind cluster that you don't want to
  # delete (in contrast to test-multitenant-integration-kind which
  # will delete the kind cluster when it is done.
  controller:test-multitenant-integration-kind:
    desc: Run live multitenant integration tests in kind.
    dir: "{{.CONTROLLER_ROOT}}"
    deps: 
      - controller:kind-create-multitenant-cluster-helm
    cmds:
      # This timeout is purposefully low - if we find that this job is
      # taking a long time we may need to think of other ways to keep
      # CI fast
      - go test -timeout 15m -v -run '{{default ".*" .TEST_FILTER}}' ./test/multitenant

  controller:test-integration-ci:
    desc: Run integration tests for CI
    dir: "{{.CONTROLLER_ROOT}}"
    deps: 
      - controller:test-integration-envtest-cover

  controller:test-integration-ci-live:
    desc: Run integration tests for CI in live mode
    dir: "{{.CONTROLLER_ROOT}}"
    deps:
      - controller:test-integration-envtest-live

  controller:generate-types:
    desc: Run {{.GENERATOR_APP}} to generate input files for controller-gen for {{.CONTROLLER_APP}}.
    dir: v2
    deps: 
      - generator:build
    sources:
      - ./bin/{{.GENERATOR_APP}}
      - v2/azure-arm.yaml
      - ../docs/hugo/content/reference
    cmds:
      - ./bin/{{.GENERATOR_APP}} gen-types azure-arm.yaml

  controller:generate-crds:
    desc: Run controller-gen to generate {{.CONTROLLER_APP}} CRD files.
    deps: 
      - controller:generate-types
      - controller:generate-genruntime-deepcopy
    sources:
      - "v2/api/**/*.go" # depends on all API types
      - "v2/pkg/genruntime/**/*.go" # Also depends on the genruntime types as they're embedded into the CRDs
    cmds:
      - mkdir -p v2/api
      - find v2/api -type f -name "zz_generated.*" -delete
      - if [ -d "{{.CONTROLLER_OUTPUT}}/crd/generated/bases" ]; then find "{{.CONTROLLER_OUTPUT}}/crd/generated/bases" -type f -delete; fi
      - if [ -d "{{.CONTROLLER_OUTPUT}}/crd/generated/patches" ]; then find "{{.CONTROLLER_OUTPUT}}/crd/generated/patches" -type f -delete; fi
      - cd v2/api && controller-gen {{.OBJECT_OPTIONS}} paths=./...
      - cd v2/api && controller-gen {{.CRD_OPTIONS}} {{.WEBHOOK_OPTIONS}} {{.RBAC_OPTIONS}} paths=./...
      - cmd: cd v2/api && gofumpt -l -w . # format all generated code
        ignore_error: true # Just in case the code doesn't build
    vars:
      OBJECT_OPTIONS: object:headerFile={{.HEADER_FILE}}
      CRD_OPTIONS: crd:crdVersions=v1,allowDangerousTypes=true output:crd:artifacts:config={{.CONTROLLER_OUTPUT}}/crd/generated/bases
      WEBHOOK_OPTIONS: webhook output:webhook:artifacts:config={{.CONTROLLER_OUTPUT}}/webhook
      RBAC_OPTIONS: rbac:roleName=manager-role output:rbac:artifacts:config={{.CONTROLLER_OUTPUT}}/rbac

  controller:generate-genruntime-deepcopy:
    desc: Run controller-gen to generate {{.CONTROLLER_APP}} CRD files.
    dir: "{{.CONTROLLER_ROOT}}"
    sources:
      - "pkg/genruntime/**/*.go"
    cmds:
      - find ./pkg/genruntime -type f -name "zz_generated.*" -delete
      - cd pkg/genruntime && controller-gen {{.OBJECT_OPTIONS}} paths=./...
      - cd pkg/genruntime && gofmt -l -s -w .  # We do this because controller-gen can generate these files in a way that isn't gofmt'ed which can break things down the line
    vars:
      OBJECT_OPTIONS: object:headerFile={{.HEADER_FILE}}

  controller:generate-kustomize:
    desc: Run {{.GENERATOR_APP}} to generate the Kustomize file for registering CRDs.
    deps: 
      - controller:generate-crds
    dir: v2
    sources:
      - bin/{{.GENERATOR_APP}}
      - config/crd/generated/bases/**/*.yaml
    generates:
      - config/crd/generated/kustomization.yaml
      - config/crd/generated/patches/**/*.yaml
    cmds:
      - bin/{{.GENERATOR_APP}} gen-kustomize config/crd/generated

  controller:run-kustomize:
    desc: Generates the CRD & configuration bundle.
    deps: 
      - controller:generate-kustomize
    dir: "v2/"
    cmds:
      - mkdir -p bin # in case it doesn't exist
      - "{{.SCRIPTS_ROOT}}/kustomize-build.sh -k operator -v {{.VERSION}} | sed -e 's@{{.LOCAL_REGISTRY_CONTROLLER_DOCKER_IMAGE}}@{{.PUBLIC_REGISTRY}}{{.CONTROLLER_DOCKER_IMAGE}}@g' > bin/azureserviceoperator_{{.VERSION}}.yaml"
      - "{{.SCRIPTS_ROOT}}/kustomize-build.sh -k crd -v {{.VERSION}} > bin/azureserviceoperator_customresourcedefinitions_{{.VERSION}}.yaml"
    vars:
      VERSION: "{{default .VERSION .VERSION_TAG}}"
      CONTROLLER_DOCKER_IMAGE: "{{default .CONTROLLER_DOCKER_IMAGE .CONTROLLER_IMAGE}}"

  controller:make-multitenant-files:
    desc: Splits the deployment yaml into cluster and tenant files for multitenant deployment
    deps: 
      - controller:run-kustomize
    dir: "v2/bin"
    cmds:
      - '{{.SCRIPTS_ROOT}}/make-multitenant-cluster.sh "{{.VERSION}}" "azureserviceoperator_{{.VERSION}}.yaml"'
      - '{{.SCRIPTS_ROOT}}/make-multitenant-tenant.sh "{{.VERSION}}" "azureserviceoperator_{{.VERSION}}.yaml"'

  controller:run-kustomize-for-envtest:
    desc: Generates the CRDs for use in envtest
    deps: 
      - controller:generate-kustomize
    dir: "v2/"
    sources:
      - config/crd/**/*.yaml
    generates:
      - out/envtest/crds/azureserviceoperator.yaml
    cmds:
      - mkdir -p out/envtest/crds
      - find "out/envtest/crds" -type f -delete
      - kustomize build config/crd/generated > out/envtest/crds/azureserviceoperator.yaml

  scripts:build-python-venv:
    desc: Creates a Python virtual env
    dir: "{{.SCRIPTS_ROOT}}"
    cmds:
      - python3 -m virtualenv venv
      - venv/bin/pip3 install -r requirements.txt

  controller:validate-helm:
    desc: Validates and compares helm against the ASO yaml generated by kustomize and ensures that they match
    dir: "{{.CONTROLLER_ROOT}}"
    deps:
      - task: controller:run-kustomize
        vars:
          VERSION_TAG: "{{.LATEST_VERSION_TAG}}"
          CONTROLLER_IMAGE: "azureserviceoperator:{{.LATEST_VERSION_TAG}}"
      - task: scripts:build-python-venv
    defer:
    cmds:
      - "{{.SCRIPTS_ROOT}}/venv/bin/python3 {{.SCRIPTS_ROOT}}/validate_helm.py --helm-dir=$PWD/charts/azure-service-operator --yaml-path=$PWD/bin/azureserviceoperator_{{.LATEST_VERSION_TAG}}.yaml"

  controller:package-helm-manifest:
    desc: Package helm manifest for the release
    dir: "{{.CONTROLLER_ROOT}}"
    deps:
      - controller:generate-kustomize
    cmds:
      - "{{.SCRIPTS_ROOT}}/package-helm-manifest.sh -i {{.LOCAL_REGISTRY_CONTROLLER_DOCKER_IMAGE}} -r {{.PUBLIC_REGISTRY}} -v {{.LATEST_VERSION_TAG}} -d `pwd`/"
      - task: controller:validate-helm

  controller:install-helm-wi:
    desc: Generate and install helm chart on cluster using workload identity
    dir: "{{.CONTROLLER_ROOT}}"
    cmds:
      - "helm upgrade --install --set azureSubscriptionID=$AZURE_SUBSCRIPTION_ID \
      --set azureTenantID=$AZURE_TENANT_ID \
      --set azureClientID={{.AZURE_MI_CLIENT_ID}} \
      --set useWorkloadIdentityAuth=true \
      {{.IMAGE_REPOSITORY_CMD}} \
      --set crdPattern=* \
      aso2 -n {{.ASO_NAMESPACE}} --create-namespace ./charts/azure-service-operator/"
      - task: controller:wait-for-operator-ready
    vars:
      IMAGE_REPOSITORY: "{{default .LOCAL_REGISTRY_CONTROLLER_DOCKER_IMAGE .IMAGE_REPOSITORY}}"
      OVERRIDE_IMAGE_REPOSITORY: "{{default true .OVERRIDE_IMAGE_REPOSITORY}}"
      IMAGE_REPOSITORY_CMD_DEFAULT: "--set image.repository={{.IMAGE_REPOSITORY}}"
      IMAGE_REPOSITORY_CMD:
        sh: |
          if [ "{{.OVERRIDE_IMAGE_REPOSITORY}}" = true ]; then
            echo "--set image.repository={{.IMAGE_REPOSITORY}}"
          else
            echo ""
          fi 

  controller:install-helm-single-tenant:
    desc: Generate and install helm chart on cluster using workload identity
    dir: "{{.CONTROLLER_ROOT}}"
    cmds:
      - "helm upgrade --install --set azureSubscriptionID=$AZURE_SUBSCRIPTION_ID \ 
           --set azureTenantID=$AZURE_TENANT_ID \
           --set azureClientID={{.AZURE_MI_CLIENT_ID}} \
           --set image.repository={{.LOCAL_REGISTRY_CONTROLLER_DOCKER_IMAGE}} \
           --set useWorkloadIdentityAuth=true \
           --set multitenant.enable=true \
           --set azureOperatorMode=watchers \
           --set-string azureTargetNamespaces='{t1-items,t1-more}' \
           aso2 -n tenant1-system --create-namespace ./charts/azure-service-operator/"
    vars:
      IMAGE_REPOSITORY: "{{default .LOCAL_REGISTRY_CONTROLLER_DOCKER_IMAGE .IMAGE_REPOSITORY}}"
      AZURE_MI_CLIENT_ID:
        sh: "cat {{.KIND_WORKLOAD_IDENTITY_PATH}}/azure/miclientid.txt #controller:install-helm-single-tenant" # Comment required to disambiguate sh usage, see: https://github.com/go-task/task/issues/524

  controller:delete-helm:
    desc: Delete helm release
    cmds:
      - "helm delete aso2 -n {{.ASO_NAMESPACE}}"

  controller:kind-delete:
    desc: Deletes a kind cluster
    run: always
    cmds:
      - "kind delete cluster --name=asov2"
      - "{{.SCRIPTS_ROOT}}/delete-kind-wi-storage.sh -d {{.KIND_WORKLOAD_IDENTITY_PATH}}"
      - "kind delete cluster --name=asov2-wi"

  # This is somewhat useless now because we're not using service principal to install ASO anymore
  # but keeping it around in case there's some other use for a bare kind cluster.
  controller:kind-create:
    desc: Creates a kind cluster and local Docker registry. Images in the local registry can be pulled in the kind cluster
    run: always
    cmds:
      - "export KIND_CLUSTER_NAME=asov2 && {{.SCRIPTS_ROOT}}/kind-with-registry.sh"
    status:
      - "kind get clusters | grep \"^asov2$\""

  controller:kind-create-wi:
    desc: Creates a kind cluster and local Docker registry with OIDC + workload identity enabled. Images in the local registry can be pulled in the kind cluster.
    run: always
    deps: 
      - az-login
    cmds:
      - echo "Cleaning {{.KIND_WORKLOAD_IDENTITY_PATH}}"
      - "rm -rf {{.KIND_WORKLOAD_IDENTITY_PATH}}"
      - "mkdir -p {{.KIND_WORKLOAD_IDENTITY_PATH}}"
      - echo "Calling create-kind-wi-storage.sh"
      - "{{.SCRIPTS_ROOT}}/create-kind-wi-storage.sh -d {{.KIND_WORKLOAD_IDENTITY_PATH}} -p {{.TEST_LIVE_RESOURCE_PREFIX}}"
      - echo "Calling kind-with-registry.sh"
      - "export KIND_CLUSTER_NAME=asov2-wi && \
            export SERVICE_ACCOUNT_ISSUER=$(cat {{.KIND_WORKLOAD_IDENTITY_PATH}}/azure/saissuer.txt) && \
            {{.SCRIPTS_ROOT}}/kind-with-registry.sh"
    status:
      - "kind get clusters | grep \"^asov2-wi$\""
    env:
      SERVICE_ACCOUNT_KEY_FILE:
        sh: "echo ${HOSTROOT:-$PWD}/{{.KIND_WORKLOAD_IDENTITY_PATH}}/sa.pub" # Have to use HOSTROOT here for mounting files when in docker-in-docker as paths are relative to host
      SERVICE_ACCOUNT_SIGNING_KEY_FILE:
        sh: "echo ${HOSTROOT:-$PWD}/{{.KIND_WORKLOAD_IDENTITY_PATH}}/sa.key"

  controller:create-mi-for-workload-identity:
    desc: Creates a managed identity and federated identity credential and stores their details in the specified path
    deps: 
      - az-login
    cmds:
      - "{{.SCRIPTS_ROOT}}/make-mi-fic.py -g {{.RESOURCE_GROUP}} -i {{.ISSUER}} -s {{.SUBJECT}} -d ./{{.DIR}}"
    vars:
      DIR: "{{default .KIND_WORKLOAD_IDENTITY_PATH .DIR}}"
      RESOURCE_GROUP_FILE:
        sh: "cat ./{{.DIR}}/azure/rg.txt || echo ''"
      RESOURCE_GROUP: "{{default .RESOURCE_GROUP_FILE .RESOURCE_GROUP}}"
      ISSUER_FILE:
        sh: "cat ./{{.DIR}}/azure/saissuer.txt"
      ISSUER: "{{default .ISSUER_FILE .ISSUER}}"
      SUBJECT: '{{default "system:serviceaccount:azureserviceoperator-system:azureserviceoperator-default" .SUBJECT}}'

  controller:aks-create:
    desc: Creates an AKS cluster
    run: always
    deps:
      - az-login
    cmds:
      - "{{.SCRIPTS_ROOT}}/make-aks.sh -l {{.LOCATION}} -g {{.RESOURCE_GROUP_NAME}} -a {{.ACR_NAME}} -c {{.CLUSTER_NAME}} -d {{.AKS_WORKLOAD_IDENTITY_PATH}}"
    status:
      - az aks show --resource-group {{.RESOURCE_GROUP_NAME}} --name {{.CLUSTER_NAME}} > /dev/null 2>&1
    vars:
      RESOURCE_GROUP_NAME: "{{.HOSTNAME}}-aso-rg"
      CLUSTER_NAME: "{{.HOSTNAME}}-aso-aks"
      LOCATION: "westus3"

  controller:aks-delete:
    desc: Deletes an AKS cluster
    run: always
    deps:
      - az-login
    cmds:
      - "az group delete --name {{.RESOURCE_GROUP_NAME}} -y"
      - "{{.SCRIPTS_ROOT}}/delete-role-assignment.sh -d {{.AKS_WORKLOAD_IDENTITY_PATH}}"
      - "rm -rf {{.AKS_WORKLOAD_IDENTITY_PATH}}"
    vars:
      RESOURCE_GROUP_NAME: "{{.HOSTNAME}}-aso-rg"

  controller:aks-create-helm-install:
    desc: Deploys ASO onto an AKS cluster
    run: always
    deps:
      - az-login
    cmds:
      - task: controller:aks-create
      - task: controller:create-mi-for-workload-identity
        vars:
          DIR: "{{.AKS_WORKLOAD_IDENTITY_PATH}}"
          RESOURCE_GROUP: "{{.HOSTNAME}}-aso-rg"
      - task: controller:install-cert-manager
      - task: controller:docker-push-multiarch
        vars:
          PLATFORMS: "{{OS}}/{{ARCH}}" # Just push to one platform for now
          DOCKER_PUSH_TARGET: "{{.ACR_NAME}}.azurecr.io"
          DOCKER_REGISTRY: "{{.ACR_NAME}}"
      - task: controller:package-helm-manifest
      # We need the below to wait until cert-manager is up, otherwise the subsequent installation of webhooks fails. See https://cert-manager.io/next-docs/installation/verify/
      - "cmctl check api --wait=2m"
      - task: controller:install-helm-wi
        vars:
          IMAGE_REPOSITORY: "{{.ACR_NAME}}.azurecr.io/{{.CONTROLLER_DOCKER_IMAGE}}"
          AZURE_MI_CLIENT_ID:
            sh: "cat {{.AKS_WORKLOAD_IDENTITY_PATH}}/azure/miclientid.txt"

  controller:scan-image:
    desc: Builds a local image and scans the image using trivy
    deps: 
      - controller:docker-build
    cmds:
      - "trivy image {{.CONTROLLER_DOCKER_IMAGE}}"
      - "trivy image --exit-code 1 --ignore-unfixed --severity MEDIUM,HIGH,CRITICAL {{.CONTROLLER_DOCKER_IMAGE}} || exit 1"

  controller:install:
    desc: Installs the controller, webhooks, and CRDs into the default kubectl cluster
    deps: 
      - controller:generate-kustomize
    dir: "{{.CONTROLLER_ROOT}}"
    cmds:
      - "{{.SCRIPTS_ROOT}}/kustomize-build.sh -k operator -v {{.VERSION}} > out/operator.yaml"
      - "sed -i 's/--crd-pattern=.*/--crd-pattern=*/g' out/operator.yaml"
      - "kubectl apply --server-side=true -f out/operator.yaml" # TODO: may need | sed "s_${CONFIG_REGISTRY}_${REGISTRY}/${IMG}_" at some point

  controller:bundle-crds:
    desc: Bundles CRDs...
    deps: 
      - controller:generate-kustomize
    dir: "{{.CONTROLLER_ROOT}}"
    sources:
      - config/**/*.yaml
    generates:
      - out/crds/**/*.yaml
    cmds:
      - "rm -rf out/crds"
      - "mkdir -p out/crds"
      - "{{.SCRIPTS_ROOT}}/kustomize-build.sh -k crd -v {{.VERSION}} -o out/crds"

  controller:install-cert-manager:
    desc: Installs cert manager
    run: always
    cmds:
      - "kubectl create namespace cert-manager"
      - "kubectl label namespace cert-manager cert-manager.io/disable-validation=true"
      - "kubectl apply -f https://github.com/jetstack/cert-manager/releases/download/v1.14.4/cert-manager.yaml"
    status:
      - "kubectl get namespace cert-manager"

  controller:make-sp-secret:
    desc: Creates a service principal aso-controller-settings secret for testing purposes
    cmds:
      - "{{.SCRIPTS_ROOT}}/deploy-testing-secret.sh sp"

  controller:make-workload-identity-secret:
    desc: Creates a workload identity secret for testing purposes
    cmds:
      - "{{.SCRIPTS_ROOT}}/deploy-testing-secret.sh workloadidentity"
    vars:
      DIR: "{{.DIR | default .KIND_WORKLOAD_IDENTITY_PATH}}"
    env:
      # Override the AZURE_CLIENT_ID env variable here
      AZURE_MI_CLIENT_ID:  # TODO: Ideally would override AZURE_CLIENT_ID here but we can't because of https://github.com/go-task/task/issues/1038
        sh: "cat {{.DIR}}/azure/miclientid.txt"

  controller:deploy-multitenant-testing-secret:
    desc: Deploy a multitenant testing secret
    cmds:
      - "{{.SCRIPTS_ROOT}}/deploy-multitenant-testing-secret.sh"
    env:
      # Override the AZURE_CLIENT_ID env variable here
      AZURE_MI_CLIENT_ID:  # TODO: Ideally would override AZURE_CLIENT_ID here but we can't because of https://github.com/go-task/task/issues/1038
        sh: "cat {{.KIND_WORKLOAD_IDENTITY_PATH}}/azure/miclientid.txt"

  controller:wait-for-operator-ready:
    desc: Waits for the operator and associated CRDs to be ready
    run: always
    cmds:
      - "{{.SCRIPTS_ROOT}}/wait-for-operator-ready.sh -n '{{default .ASO_NAMESPACE .NAMESPACE}}' {{.ARGS}}"

  controller:kind-create-with-workload-identity:
    desc: Creates a local kind cluster in workload identity mode with ASO using a managed identity.
    cmds:
      - task: controller:kind-create-wi
      - task: controller:create-mi-for-workload-identity
      - task: controller:install-cert-manager
      - task: controller:docker-push-local
      # We need the below to wait until cert-manager is up, otherwise the subsequent installation of webhooks fails. See https://cert-manager.io/next-docs/installation/verify/
      - "cmctl check api --wait=2m"
      - task: controller:install
      - task: controller:make-workload-identity-secret
      - task: controller:wait-for-operator-ready

  # TODO: This currently doesn't work because the installation via raw YAML doesn't pass crdpattern.
  controller:kind-create-multitenant-cluster:
    desc: Creates a local kind cluster with ASO installed in multitenant configuration.
    deps: 
      - controller:make-multitenant-files
    cmds:
      - task: controller:kind-create-wi
      - task: controller:create-mi-for-workload-identity
      - task: controller:install-cert-manager
      - task: controller:docker-push-local
      # We need the below to wait until cert-manager is up, otherwise the subsequent installation of webhooks fails. See https://cert-manager.io/next-docs/installation/verify/
      - "cmctl check api --wait=2m"
      # Install cluster yaml - we need to switch the image to the local one.
      - "cat v2/bin/multitenant-cluster_{{.VERSION}}.yaml | sed -e 's|image: mcr.microsoft.com/k8s/azureserviceoperator:.*|image: localhost:5000/azureserviceoperator:latest|' | kubectl apply --server-side=true -f -"
      # Wait for all the operator pods to be ready.
      - task: controller:wait-for-operator-ready
      # Install tenant yaml - with same image switch
      - "cat v2/bin/multitenant-tenant_{{.VERSION}}.yaml | sed -e 's|image: mcr.microsoft.com/k8s/azureserviceoperator:.*|image: localhost:5000/azureserviceoperator:latest|' | kubectl apply --server-side=true -f -"
      # Make sp secret for tenant watching some target namespaces.
      - task: controller:deploy-multitenant-testing-secret
      # Create the namespaces that the tenant is watching.
      - "kubectl create namespace t1-items"
      - "kubectl create namespace t1-more"
      # Wait for the other operator to be ready - not using controller:wait-for-operator-ready because that also waits for CRDs, etc which this doesn't install
      - "kubectl wait --for=condition=ready --timeout=2m pod -n tenant1-system -l control-plane=controller-manager"

  controller:kind-create-multitenant-cluster-helm:
    desc: Creates a local kind cluster Helm and ASO in multitenant configuration.
    dir: "{{.CONTROLLER_ROOT}}"
    vars:
      # This below is added to test if ASO works fine in namespaces other than 'azureserviceoperator-system"
      NAMESPACE: "custom-namespace"
    cmds:
      - task: controller:kind-create-wi
      - task: controller:create-mi-for-workload-identity
        vars:
          # Use the tenant1-system namespace as that's where the single tenant operator will be installed
          SUBJECT: "system:serviceaccount:tenant1-system:azureserviceoperator-default"
          # We have to set RESOURCE_GROUP and ISSUER here because if we don't, the cached variables
          # will be used from the create-mi-for-workload-identity task in ci. See: https://github.com/go-task/task/issues/524
          RESOURCE_GROUP:
            sh: "cat ./{{.KIND_WORKLOAD_IDENTITY_PATH}}/azure/rg.txt #controller:kind-create-multitenant-cluster-helm"
          ISSUER:
            sh: "cat ./{{.KIND_WORKLOAD_IDENTITY_PATH}}/azure/saissuer.txt #controller:kind-create-multitenant-cluster-helm"
      - task: controller:install-cert-manager
      - task: controller:docker-push-local
      - task: controller:package-helm-manifest
      # We need the below to wait until cert-manager is up, otherwise the subsequent installation of webhooks fails. See https://cert-manager.io/next-docs/installation/verify/
      - "cmctl check api --wait=2m"
      # Install cluster scope chart (mode == webhooks)
      - "helm upgrade --install --set multitenant.enable=true --set azureOperatorMode=webhooks \
           --set image.repository={{.LOCAL_REGISTRY_CONTROLLER_DOCKER_IMAGE}} \
           --set crdPattern=* \
           aso2 -n {{.NAMESPACE}} --create-namespace ./charts/azure-service-operator/"
      - task: controller:wait-for-operator-ready
        vars:
          NAMESPACE: "{{.NAMESPACE}}"
      - task: controller:install-helm-single-tenant
      # Create the namespaces that the tenant is watching.
      - "kubectl create namespace t1-items"
      - "kubectl create namespace t1-more"
      # Wait for the other operator to be ready - not using controller:wait-for-operator-ready because that also waits for CRDs, etc which this doesn't install
      - "kubectl wait --for=condition=ready --timeout=2m pod -n tenant1-system -l control-plane=controller-manager"

  controller:kind-create-helm-workload-identity:
    desc: Creates a local kind cluster with Workload identity installed alongside ASO helm chart using UMI auth.
    cmds:
      - task: controller:kind-create-wi
      - task: controller:create-mi-for-workload-identity
      - task: controller:install-cert-manager
      - task: controller:docker-push-local
      - task: controller:package-helm-manifest
      # We need the below to wait until cert-manager is up, otherwise the subsequent installation of webhooks fails. See https://cert-manager.io/next-docs/installation/verify/
      - "cmctl check api --wait=2m"
      - task: controller:install-helm-wi
        vars:
          AZURE_MI_CLIENT_ID:
            sh: "cat {{.KIND_WORKLOAD_IDENTITY_PATH}}/azure/miclientid.txt"

  controller:kind-create-workloadidentity-local-helm:
    desc: Creates a local kind cluster with Workload identity installed alongside the local ASO helm chart. Does NOT build the Helm chart, it expects that it has already been built. Does NOT swap the image for a local copy.
    cmds:
      - task: controller:kind-create-wi
      - task: controller:create-mi-for-workload-identity
      - task: controller:install-cert-manager
      - "cmctl check api --wait=2m"
      - task: controller:install-helm-wi
        vars:
          OVERRIDE_IMAGE_REPOSITORY: "false"
          AZURE_MI_CLIENT_ID:
            sh: "cat {{.KIND_WORKLOAD_IDENTITY_PATH}}/azure/miclientid.txt"

  # Stub retained until migration of workflows complete
  controller:gen-crd-docs:
    cmds:
      - task: doc:crd-api

  ############### Utility targets ###############

  mangle-test:quick-checks:
    cmds:
      - task: mangle-test:lint

  mangle-test:lint:
    desc: Run mangle-test fast lint checks.
    dir: '{{.MANGLE_ROOT}}'
    cmds:
      - golangci-lint run --verbose --fix --timeout 5m ./...  

  ############### Crossplane targets ###############

  crossplane:quick-checks:
    cmds:
      - task: basic-checks

# TODO: We currently have no tests
#  crossplane:test:
#    desc: Run {{.CROSSPLANE_APP}} unit tests.
#    dir: "{{.CROSSPLANE_ROOT}}"
#    cmds:
#      - go test ./... -tags=noexit -timeout 10m

#  crossplane:update-golden-tests:
#    desc: Update {{.CROSSPLANE_APP}} golden test outputs.
#    dir: "{{.CROSSPLANE_ROOT}}"
#    cmds:
#      - go test ./pkg/codegen -run ^TestGolden$ -update -timeout 10m

  # TODO: No non-generated code in this directory at the moment
  # crossplane:lint:
  #   desc: Run {{.CROSSPLANE_APP}} fast lint checks.
  #   dir: "{{.CROSSPLANE_ROOT}}"
  #   cmds:
  #     - golangci-lint run --verbose

  crossplane:generate-crds:
    desc: Run controller-gen to generate {{.CROSSPLANE_APP}} CRD files.
    deps: 
      - crossplane:generate-types
    dir: "{{.CROSSPLANE_ROOT}}"
    sources:
      - "apis/**/*_gen.go" # depends on all generated types
    cmds:
      - mkdir -p ./apis
      - find ./apis -type f -name "zz_generated.*" -delete
      - if [ -d "{{.CROSSPLANE_OUTPUT}}/crd/bases" ]; then find "{{.CROSSPLANE_OUTPUT}}/crd/bases" -type f -delete; fi
      - if [ -d "{{.CROSSPLANE_OUTPUT}}/crd/patches" ]; then find "{{.CROSSPLANE_OUTPUT}}/crd/patches" -type f -delete; fi
      - cd apis && controller-gen {{.OBJECT_OPTIONS}} paths=./...
      - cd apis && controller-gen {{.CRD_OPTIONS}} {{.WEBHOOK_OPTIONS}} {{.RBAC_OPTIONS}} paths=./...
      - cmd: cd apis && gofumpt -l -w . # format all generated code
        ignore_error: true # Just in case the code doesn't build
    vars:
      OBJECT_OPTIONS: object:headerFile={{.HEADER_FILE}}
      CRD_OPTIONS: crd:crdVersions=v1,allowDangerousTypes=true output:crd:artifacts:config={{.CROSSPLANE_OUTPUT}}/crd/bases
      WEBHOOK_OPTIONS: webhook output:webhook:artifacts:config={{.CROSSPLANE_OUTPUT}}/webhook
      RBAC_OPTIONS: rbac:roleName=manager-role output:rbac:artifacts:config={{.CROSSPLANE_OUTPUT}}/rbac

  crossplane:generate-types:
    desc: Run {{.GENERATOR_APP}} to generate input files for controller-gen for {{.CROSSPLANE_APP}}.
    dir: "{{.CROSSPLANE_ROOT}}"
    deps: 
       - generator:build
    sources:
      - ../../v2/bin/{{.GENERATOR_APP}}
      - azure-crossplane.yaml
    cmds:
      - ../../v2/bin/{{.GENERATOR_APP}} gen-types azure-crossplane.yaml

  crossplane:ci:
    deps: 
      - basic-checks
      - crossplane:generate-crds

  ############### Documentation targets ###############

  doc:build-site:
    dir: docs/hugo
    dep:
      - doc:frontmatter-check
    cmds:
      - hugo
      - htmltest
    env:
      NODE_PATH:
        sh: npm root -g

  doc:render-diagrams:
    desc: Render all GraphViz diagrams
    dir: "./docs/hugo/content"
    sources: ["**/*.dot"]
    cmds:
      - "for f in $(find . -name '*.dot'); do dot -Tpng -o${f%.dot}.png $f; done"

  doc:crd-api:
    desc: Generates API docs for CRDs
    deps: 
      - controller:generate-crds
    dir: "{{.CONTROLLER_ROOT}}"
    cmds:
      - "{{.SCRIPTS_ROOT}}/gen-api-docs.sh ./api ../docs/hugo/content/reference ../docs/v2/api/template"

  doc:frontmatter-check:
    desc: Ensure all Markdown documentation has frontmatter.
    dir: docs/hugo/content
    cmds:
      - "{{.SCRIPTS_ROOT}}/check_frontmatter.py"

  doc:dependencies:
    desc: Generate documentation for depencencies
    cmds:
      - cp ./docs/v2/dependencies-header.md ./docs/hugo/content/contributing/dependencies.md
      - grep '^[[:space:]]*#doc#' .devcontainer/install-dependencies.sh | sed -e 's/[[:space:]]*#doc# //' | sort -f >> ./docs/hugo/content/contributing/dependencies.md
      - cat ./docs/v2/dependencies-footer.md >> ./docs/hugo/content/contributing/dependencies.md

  ############### Shared targets ###############

  cleanup-azure-resources:
    desc: Removes any resources created by the integration tests.
    deps: 
       - az-login
    cmds:
      - '{{.SCRIPTS_ROOT}}/delete-old-resourcegroups.sh -p "{{.TEST_RESOURCE_PREFIX}}"'

  cleanup-old-live-azure-resources:
    desc: Removes any old resources created by the integration tests (old means older than 3 hours).
    deps: 
      - az-login
    # This finds all resource groups which match the specified pattern (asolivetest*)
    # and are older than 3 hours (10800 seconds).
    cmds:
      - '{{.SCRIPTS_ROOT}}/delete-old-resourcegroups.sh -p "{{.TEST_LIVE_RESOURCE_PREFIX}}" -a 10800'

  az-login:
    desc: Runs AZ login. In the context of GitHub actions, uses an MSI token, in a local (non-actions) context, uses an interactive login
    cmds:
      # For interactive login: az cli has 2 tokens, an access token (valid for ~60m) and a refresh token (valid for ~12h)
      # If the access token is expired, but the refresh token is still valid, the below command will get a new access token
      # via the refresh token without asking for re-authentication.
      # If the refresh token is expired, re-authentication is required.
      # In practice this means that you should be asked for authentication once a (working) day, unless you're working for more
      # than 12 hours in which case you'll be prompted twice.
      - if [ "${GITHUB_ACTIONS}" = true ]; then az login --identity; elif ! az account get-access-token --tenant {{.AZURE_TENANT_ID}} --query "expiresOn" --output tsv > /dev/null; then az login; fi
      - az account set --subscription {{.AZURE_SUBSCRIPTION_ID}}

  docker-login:
    desc: Docker login
    deps:
      - az-login
    cmds:
      - 'if [ -z "{{.DOCKER_REGISTRY}}" ]; then echo "Error: DOCKER_REGISTRY must be set"; exit 1; fi'
      - az acr login --name {{.DOCKER_REGISTRY}}

  header-check:
    desc: Ensure all files have an appropriate license header.
    cmds:
      - "{{.SCRIPTS_ROOT}}/check_headers.py"

  # Stub retained until migration of workflows complete
  frontmatter-check:
    cmds:
      - doc:frontmatter-check

  specifier-check:
    desc: Check that format specifiers %v and %+v are not used
    # Both %v and %+v result in all the values from structs being dumped into the string. If that
    # struct happens to contain a secret or sensitive information, it ends up dumped out in an
    # uncontrolled way, potentially leading to a security issue or a problem with PII disclosure.
    # The buried risk here is that while %v might be safe now, a future change to the struct might
    # introduce a disclosure later on.
    cmds:
      - cmd: echo "==> Checking format specifiers <=="
        silent: true
      - cmd: '! git grep -e "%+v" -e "%v" --break --heading --line-number -I "*.go"'

  verify-no-changes:
    desc: Checks that there are no uncommitted modifications to files
    cmds:
      - cmd: 'if [ -n "{{.CHANGED}}" ]; then echo "Error: files were modified during the build (ensure you have commited generated files, and run ''task format-code'' to tidy):"; echo "{{.CHANGED}}"; git diff; exit 1; fi'
        silent: true
    vars:
      CHANGED:
        sh: git status --porcelain

  produce-markdown-summary:
    desc: Builds a test output summary for Github
    deps: 
       - build-mangle-test
    cmds:
      - cmd: ./v2/tools/mangle-test-json/mangle-test-json "{{.INPUT_FILE}}" > "{{.OUTPUT_FILE}}"

  build-mangle-test:
    desc: Builds the tool we use for mangling test results
    dir: v2/tools/mangle-test-json
    cmds:
      - go build

  provision-oidc-storage-acct:
    desc: Creates a storage account for use in OIDC federation with a random name in resource group "aso-wi-storage"
    dir: "v2/"
    cmds:
      - '{{.SCRIPTS_ROOT}}/workloadidentitystorage/deploy.sh'
    env:
      KIND_OIDC_STORAGE_ACCOUNT_RG: aso-wi-storage
      KIND_OIDC_STORAGE_ACCOUNT:
          sh: echo "asowi$(openssl rand -hex 6)"
