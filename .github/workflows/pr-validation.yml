name: pr-validation
on:
  push:
    branches:
    - master

  pull_request: 
    branches:
      - master

jobs:
  test-generator:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
        with:
          submodules: 'true'

      - name: Docker cache
        id: docker-cache
        uses: actions/cache@v2
        with:
          path: docker-cache
          key: ${{ runner.os }}-${{ hashFiles('.devcontainer/**') }}

      - name: Build devcontainer image (uncached)
        if: steps.docker-cache.outputs.cache-hit != 'true'
        # If no cache-hit we will rebuild the image from scratch with buildx, which
        # allows us to output a cache for reuse later.
        #
        # We output the cache to a new folder and then remove the old cache and copy the new one there
        # so that the cache size does not keep growing.
        run: |
          mkdir -p docker-cache docker-cache-new
          docker buildx create --use
          docker buildx build --tag devcontainer:1.0 --cache-from=type=local,src=docker-cache --cache-to=type=local,dest=docker-cache-new --load .devcontainer
          rm -rf docker-cache && mv docker-cache-new docker-cache

      - name: Build devcontainer image (cached)
        if: steps.docker-cache.outputs.cache-hit == 'true'
        # If we have a cache hit we can instruct docker to load from the cache.
        # We do not write to the cache as we had a hit, and it is very slow.
        run: |
          docker buildx build --tag devcontainer:1.0 --cache-from=type=local,src=docker-cache --load .devcontainer

      - name: Run devcontainer image
        id: devcontainer
        run: |
          container_id=$(docker create -w /workspace -v $GITHUB_WORKSPACE:/workspace -v /var/run/docker.sock:/var/run/docker.sock devcontainer:1.0)
          docker start "$container_id"
          echo "::set-output name=id::$container_id"
        
      - name: Run CI tasks
        run: |
          docker exec "${{steps.devcontainer.outputs.id}}" task ci

      - name: Build docker image
        run: |
          container_id=${{steps.devcontainer.outputs.id}}
          docker exec "$container_id" task controller:docker-build
          docker cp "$container_id:/workspace/hack/generated/bin" .
          mv bin/*.tar azure-service-operator.tar

      - name: Archive Docker image
        uses: actions/upload-artifact@v2
        with:
          name: controller-image
          path: azure-service-operator.tar
          if-no-files-found: error

      - name: Upload code coverage to Codecov
        run: bash <(curl -s https://codecov.io/bash)
