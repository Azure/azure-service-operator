// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20201101

import (
	"fmt"
	"github.com/Azure/azure-service-operator/hack/generated/apis/microsoft.network/v1alpha1api20201101storage"
	"github.com/Azure/azure-service-operator/hack/generated/pkg/genruntime"
	"github.com/Azure/azure-service-operator/hack/generated/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/hack/generated/pkg/reflecthelpers"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	kerrors "k8s.io/apimachinery/pkg/util/errors"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:rbac:groups=microsoft.network.azure.com,resources=loadbalancers,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=microsoft.network.azure.com,resources={loadbalancers/status,loadbalancers/finalizers},verbs=get;update;patch

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
//Generated from: https://schema.management.azure.com/schemas/2020-11-01/Microsoft.Network.json#/resourceDefinitions/loadBalancers
type LoadBalancer struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              LoadBalancers_Spec  `json:"spec,omitempty"`
	Status            LoadBalancer_Status `json:"status,omitempty"`
}

var _ conditions.Conditioner = &LoadBalancer{}

// GetConditions returns the conditions of the resource
func (loadBalancer *LoadBalancer) GetConditions() conditions.Conditions {
	return loadBalancer.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (loadBalancer *LoadBalancer) SetConditions(conditions conditions.Conditions) {
	loadBalancer.Status.Conditions = conditions
}

// +kubebuilder:webhook:path=/mutate-microsoft-network-azure-com-v1alpha1api20201101-loadbalancer,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=microsoft.network.azure.com,resources=loadbalancers,verbs=create;update,versions=v1alpha1api20201101,name=default.v1alpha1api20201101.loadbalancers.microsoft.network.azure.com,admissionReviewVersions=v1beta1

var _ admission.Defaulter = &LoadBalancer{}

// Default applies defaults to the LoadBalancer resource
func (loadBalancer *LoadBalancer) Default() {
	loadBalancer.defaultImpl()
	var temp interface{} = loadBalancer
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (loadBalancer *LoadBalancer) defaultAzureName() {
	if loadBalancer.Spec.AzureName == "" {
		loadBalancer.Spec.AzureName = loadBalancer.Name
	}
}

// defaultImpl applies the code generated defaults to the LoadBalancer resource
func (loadBalancer *LoadBalancer) defaultImpl() { loadBalancer.defaultAzureName() }

var _ genruntime.KubernetesResource = &LoadBalancer{}

// AzureName returns the Azure name of the resource
func (loadBalancer *LoadBalancer) AzureName() string {
	return loadBalancer.Spec.AzureName
}

// GetResourceKind returns the kind of the resource
func (loadBalancer *LoadBalancer) GetResourceKind() genruntime.ResourceKind {
	return genruntime.ResourceKindNormal
}

// GetSpec returns the specification of this resource
func (loadBalancer *LoadBalancer) GetSpec() genruntime.ConvertibleSpec {
	return &loadBalancer.Spec
}

// GetStatus returns the status of this resource
func (loadBalancer *LoadBalancer) GetStatus() genruntime.ConvertibleStatus {
	return &loadBalancer.Status
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Network/loadBalancers"
func (loadBalancer *LoadBalancer) GetType() string {
	return "Microsoft.Network/loadBalancers"
}

// Owner returns the ResourceReference of the owner, or nil if there is no owner
func (loadBalancer *LoadBalancer) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(loadBalancer.Spec)
	return &genruntime.ResourceReference{Group: group, Kind: kind, Namespace: loadBalancer.Namespace, Name: loadBalancer.Spec.Owner.Name}
}

// SetStatus sets the status of this resource
func (loadBalancer *LoadBalancer) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*LoadBalancer_Status); ok {
		loadBalancer.Status = *st
		return nil
	}

	// Convert status to required version
	var st LoadBalancer_Status
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	loadBalancer.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-microsoft-network-azure-com-v1alpha1api20201101-loadbalancer,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=microsoft.network.azure.com,resources=loadbalancers,verbs=create;update,versions=v1alpha1api20201101,name=validate.v1alpha1api20201101.loadbalancers.microsoft.network.azure.com,admissionReviewVersions=v1beta1

var _ admission.Validator = &LoadBalancer{}

// ValidateCreate validates the creation of the resource
func (loadBalancer *LoadBalancer) ValidateCreate() error {
	validations := loadBalancer.createValidations()
	var temp interface{} = loadBalancer
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateDelete validates the deletion of the resource
func (loadBalancer *LoadBalancer) ValidateDelete() error {
	validations := loadBalancer.deleteValidations()
	var temp interface{} = loadBalancer
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateUpdate validates an update of the resource
func (loadBalancer *LoadBalancer) ValidateUpdate(old runtime.Object) error {
	validations := loadBalancer.updateValidations()
	var temp interface{} = loadBalancer
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation(old)
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// createValidations validates the creation of the resource
func (loadBalancer *LoadBalancer) createValidations() []func() error {
	return []func() error{loadBalancer.validateResourceReferences}
}

// deleteValidations validates the deletion of the resource
func (loadBalancer *LoadBalancer) deleteValidations() []func() error {
	return nil
}

// updateValidations validates the update of the resource
func (loadBalancer *LoadBalancer) updateValidations() []func(old runtime.Object) error {
	return []func(old runtime.Object) error{
		func(old runtime.Object) error {
			return loadBalancer.validateResourceReferences()
		},
	}
}

// validateResourceReferences validates all resource references
func (loadBalancer *LoadBalancer) validateResourceReferences() error {
	refs, err := reflecthelpers.FindResourceReferences(&loadBalancer.Spec)
	if err != nil {
		return err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// AssignPropertiesFromLoadBalancer populates our LoadBalancer from the provided source LoadBalancer
func (loadBalancer *LoadBalancer) AssignPropertiesFromLoadBalancer(source *v1alpha1api20201101storage.LoadBalancer) error {

	// Spec
	var spec LoadBalancers_Spec
	err := spec.AssignPropertiesFromLoadBalancersSpec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "populating Spec from Spec, calling AssignPropertiesFromLoadBalancersSpec()")
	}
	loadBalancer.Spec = spec

	// Status
	var status LoadBalancer_Status
	err = status.AssignPropertiesFromLoadBalancerStatus(&source.Status)
	if err != nil {
		return errors.Wrap(err, "populating Status from Status, calling AssignPropertiesFromLoadBalancerStatus()")
	}
	loadBalancer.Status = status

	// No error
	return nil
}

// AssignPropertiesToLoadBalancer populates the provided destination LoadBalancer from our LoadBalancer
func (loadBalancer *LoadBalancer) AssignPropertiesToLoadBalancer(destination *v1alpha1api20201101storage.LoadBalancer) error {

	// Spec
	var spec v1alpha1api20201101storage.LoadBalancers_Spec
	err := loadBalancer.Spec.AssignPropertiesToLoadBalancersSpec(&spec)
	if err != nil {
		return errors.Wrap(err, "populating Spec from Spec, calling AssignPropertiesToLoadBalancersSpec()")
	}
	destination.Spec = spec

	// Status
	var status v1alpha1api20201101storage.LoadBalancer_Status
	err = loadBalancer.Status.AssignPropertiesToLoadBalancerStatus(&status)
	if err != nil {
		return errors.Wrap(err, "populating Status from Status, calling AssignPropertiesToLoadBalancerStatus()")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (loadBalancer *LoadBalancer) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: loadBalancer.Spec.OriginalVersion(),
		Kind:    "LoadBalancer",
	}
}

// +kubebuilder:object:root=true
//Generated from: https://schema.management.azure.com/schemas/2020-11-01/Microsoft.Network.json#/resourceDefinitions/loadBalancers
type LoadBalancerList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []LoadBalancer `json:"items"`
}

//Generated from:
type LoadBalancer_Status struct {
	//BackendAddressPools: Collection of backend address pools used by a load balancer.
	BackendAddressPools []BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded `json:"backendAddressPools,omitempty"`

	//Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	//Etag: A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	//ExtendedLocation: The extended location of the load balancer.
	ExtendedLocation *ExtendedLocation_Status `json:"extendedLocation,omitempty"`

	//FrontendIPConfigurations: Object representing the frontend IPs to be used for
	//the load balancer.
	FrontendIPConfigurations []FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded `json:"frontendIPConfigurations,omitempty"`

	//Id: Resource ID.
	Id *string `json:"id,omitempty"`

	//InboundNatPools: Defines an external port range for inbound NAT to a single
	//backend port on NICs associated with a load balancer. Inbound NAT rules are
	//created automatically for each NIC associated with the Load Balancer using an
	//external port from this range. Defining an Inbound NAT pool on your Load
	//Balancer is mutually exclusive with defining inbound Nat rules. Inbound NAT
	//pools are referenced from virtual machine scale sets. NICs that are associated
	//with individual virtual machines cannot reference an inbound NAT pool. They have
	//to reference individual inbound NAT rules.
	InboundNatPools []InboundNatPool_Status `json:"inboundNatPools,omitempty"`

	//InboundNatRules: Collection of inbound NAT Rules used by a load balancer.
	//Defining inbound NAT rules on your load balancer is mutually exclusive with
	//defining an inbound NAT pool. Inbound NAT pools are referenced from virtual
	//machine scale sets. NICs that are associated with individual virtual machines
	//cannot reference an Inbound NAT pool. They have to reference individual inbound
	//NAT rules.
	InboundNatRules []InboundNatRule_Status_LoadBalancer_SubResourceEmbedded `json:"inboundNatRules,omitempty"`

	//LoadBalancingRules: Object collection representing the load balancing rules Gets
	//the provisioning.
	LoadBalancingRules []LoadBalancingRule_Status `json:"loadBalancingRules,omitempty"`

	//Location: Resource location.
	Location *string `json:"location,omitempty"`

	//Name: Resource name.
	Name *string `json:"name,omitempty"`

	//OutboundRules: The outbound rules.
	OutboundRules []OutboundRule_Status `json:"outboundRules,omitempty"`

	//Probes: Collection of probe objects used in the load balancer.
	Probes []Probe_Status `json:"probes,omitempty"`

	//ProvisioningState: The provisioning state of the load balancer resource.
	ProvisioningState *ProvisioningState_Status `json:"provisioningState,omitempty"`

	//ResourceGuid: The resource GUID property of the load balancer resource.
	ResourceGuid *string `json:"resourceGuid,omitempty"`

	//Sku: The load balancer SKU.
	Sku *LoadBalancerSku_Status `json:"sku,omitempty"`

	//Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	//Type: Resource type.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &LoadBalancer_Status{}

// ConvertStatusFrom populates our LoadBalancer_Status from the provided source
func (loadBalancerStatus *LoadBalancer_Status) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v1alpha1api20201101storage.LoadBalancer_Status)
	if ok {
		// Populate our instance from source
		return loadBalancerStatus.AssignPropertiesFromLoadBalancerStatus(src)
	}

	// Convert to an intermediate form
	src = &v1alpha1api20201101storage.LoadBalancer_Status{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = loadBalancerStatus.AssignPropertiesFromLoadBalancerStatus(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our LoadBalancer_Status
func (loadBalancerStatus *LoadBalancer_Status) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v1alpha1api20201101storage.LoadBalancer_Status)
	if ok {
		// Populate destination from our instance
		return loadBalancerStatus.AssignPropertiesToLoadBalancerStatus(dst)
	}

	// Convert to an intermediate form
	dst = &v1alpha1api20201101storage.LoadBalancer_Status{}
	err := loadBalancerStatus.AssignPropertiesToLoadBalancerStatus(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &LoadBalancer_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (loadBalancerStatus *LoadBalancer_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &LoadBalancer_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (loadBalancerStatus *LoadBalancer_Status) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(LoadBalancer_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LoadBalancer_StatusARM, got %T", armInput)
	}

	// Set property ‘BackendAddressPools’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.BackendAddressPools {
			var item1 BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			loadBalancerStatus.BackendAddressPools = append(loadBalancerStatus.BackendAddressPools, item1)
		}
	}

	// no assignment for property ‘Conditions’

	// Set property ‘Etag’:
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		loadBalancerStatus.Etag = &etag
	}

	// Set property ‘ExtendedLocation’:
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation_Status
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		loadBalancerStatus.ExtendedLocation = &extendedLocation
	}

	// Set property ‘FrontendIPConfigurations’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.FrontendIPConfigurations {
			var item1 FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			loadBalancerStatus.FrontendIPConfigurations = append(loadBalancerStatus.FrontendIPConfigurations, item1)
		}
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		loadBalancerStatus.Id = &id
	}

	// Set property ‘InboundNatPools’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.InboundNatPools {
			var item1 InboundNatPool_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			loadBalancerStatus.InboundNatPools = append(loadBalancerStatus.InboundNatPools, item1)
		}
	}

	// Set property ‘InboundNatRules’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.InboundNatRules {
			var item1 InboundNatRule_Status_LoadBalancer_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			loadBalancerStatus.InboundNatRules = append(loadBalancerStatus.InboundNatRules, item1)
		}
	}

	// Set property ‘LoadBalancingRules’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancingRules {
			var item1 LoadBalancingRule_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			loadBalancerStatus.LoadBalancingRules = append(loadBalancerStatus.LoadBalancingRules, item1)
		}
	}

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		loadBalancerStatus.Location = &location
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		loadBalancerStatus.Name = &name
	}

	// Set property ‘OutboundRules’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.OutboundRules {
			var item1 OutboundRule_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			loadBalancerStatus.OutboundRules = append(loadBalancerStatus.OutboundRules, item1)
		}
	}

	// Set property ‘Probes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Probes {
			var item1 Probe_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			loadBalancerStatus.Probes = append(loadBalancerStatus.Probes, item1)
		}
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			loadBalancerStatus.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘ResourceGuid’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ResourceGuid != nil {
			resourceGuid := *typedInput.Properties.ResourceGuid
			loadBalancerStatus.ResourceGuid = &resourceGuid
		}
	}

	// Set property ‘Sku’:
	if typedInput.Sku != nil {
		var sku1 LoadBalancerSku_Status
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		loadBalancerStatus.Sku = &sku
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		loadBalancerStatus.Tags = make(map[string]string)
		for key, value := range typedInput.Tags {
			loadBalancerStatus.Tags[key] = value
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		loadBalancerStatus.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromLoadBalancerStatus populates our LoadBalancer_Status from the provided source LoadBalancer_Status
func (loadBalancerStatus *LoadBalancer_Status) AssignPropertiesFromLoadBalancerStatus(source *v1alpha1api20201101storage.LoadBalancer_Status) error {

	// BackendAddressPools
	backendAddressPoolList := make([]BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded, len(source.BackendAddressPools))
	for backendAddressPoolIndex, backendAddressPoolItem := range source.BackendAddressPools {
		// Shadow the loop variable to avoid aliasing
		backendAddressPoolItem := backendAddressPoolItem
		var backendAddressPool BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded
		err := backendAddressPool.AssignPropertiesFromBackendAddressPoolStatusLoadBalancerSubResourceEmbedded(&backendAddressPoolItem)
		if err != nil {
			return errors.Wrap(err, "populating BackendAddressPools from BackendAddressPools, calling AssignPropertiesFromBackendAddressPoolStatusLoadBalancerSubResourceEmbedded()")
		}
		backendAddressPoolList[backendAddressPoolIndex] = backendAddressPool
	}
	loadBalancerStatus.BackendAddressPools = backendAddressPoolList

	// Conditions
	conditionList := make([]conditions.Condition, len(source.Conditions))
	for conditionIndex, conditionItem := range source.Conditions {
		// Shadow the loop variable to avoid aliasing
		conditionItem := conditionItem
		conditionList[conditionIndex] = conditionItem.Copy()
	}
	loadBalancerStatus.Conditions = conditionList

	// Etag
	if source.Etag != nil {
		etag := *source.Etag
		loadBalancerStatus.Etag = &etag
	} else {
		loadBalancerStatus.Etag = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation_Status
		err := extendedLocation.AssignPropertiesFromExtendedLocationStatus(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "populating ExtendedLocation from ExtendedLocation, calling AssignPropertiesFromExtendedLocationStatus()")
		}
		loadBalancerStatus.ExtendedLocation = &extendedLocation
	} else {
		loadBalancerStatus.ExtendedLocation = nil
	}

	// FrontendIPConfigurations
	frontendIPConfigurationList := make([]FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded, len(source.FrontendIPConfigurations))
	for frontendIPConfigurationIndex, frontendIPConfigurationItem := range source.FrontendIPConfigurations {
		// Shadow the loop variable to avoid aliasing
		frontendIPConfigurationItem := frontendIPConfigurationItem
		var frontendIPConfiguration FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded
		err := frontendIPConfiguration.AssignPropertiesFromFrontendIPConfigurationStatusLoadBalancerSubResourceEmbedded(&frontendIPConfigurationItem)
		if err != nil {
			return errors.Wrap(err, "populating FrontendIPConfigurations from FrontendIPConfigurations, calling AssignPropertiesFromFrontendIPConfigurationStatusLoadBalancerSubResourceEmbedded()")
		}
		frontendIPConfigurationList[frontendIPConfigurationIndex] = frontendIPConfiguration
	}
	loadBalancerStatus.FrontendIPConfigurations = frontendIPConfigurationList

	// Id
	if source.Id != nil {
		id := *source.Id
		loadBalancerStatus.Id = &id
	} else {
		loadBalancerStatus.Id = nil
	}

	// InboundNatPools
	inboundNatPoolList := make([]InboundNatPool_Status, len(source.InboundNatPools))
	for inboundNatPoolIndex, inboundNatPoolItem := range source.InboundNatPools {
		// Shadow the loop variable to avoid aliasing
		inboundNatPoolItem := inboundNatPoolItem
		var inboundNatPool InboundNatPool_Status
		err := inboundNatPool.AssignPropertiesFromInboundNatPoolStatus(&inboundNatPoolItem)
		if err != nil {
			return errors.Wrap(err, "populating InboundNatPools from InboundNatPools, calling AssignPropertiesFromInboundNatPoolStatus()")
		}
		inboundNatPoolList[inboundNatPoolIndex] = inboundNatPool
	}
	loadBalancerStatus.InboundNatPools = inboundNatPoolList

	// InboundNatRules
	inboundNatRuleList := make([]InboundNatRule_Status_LoadBalancer_SubResourceEmbedded, len(source.InboundNatRules))
	for inboundNatRuleIndex, inboundNatRuleItem := range source.InboundNatRules {
		// Shadow the loop variable to avoid aliasing
		inboundNatRuleItem := inboundNatRuleItem
		var inboundNatRule InboundNatRule_Status_LoadBalancer_SubResourceEmbedded
		err := inboundNatRule.AssignPropertiesFromInboundNatRuleStatusLoadBalancerSubResourceEmbedded(&inboundNatRuleItem)
		if err != nil {
			return errors.Wrap(err, "populating InboundNatRules from InboundNatRules, calling AssignPropertiesFromInboundNatRuleStatusLoadBalancerSubResourceEmbedded()")
		}
		inboundNatRuleList[inboundNatRuleIndex] = inboundNatRule
	}
	loadBalancerStatus.InboundNatRules = inboundNatRuleList

	// LoadBalancingRules
	loadBalancingRuleList := make([]LoadBalancingRule_Status, len(source.LoadBalancingRules))
	for loadBalancingRuleIndex, loadBalancingRuleItem := range source.LoadBalancingRules {
		// Shadow the loop variable to avoid aliasing
		loadBalancingRuleItem := loadBalancingRuleItem
		var loadBalancingRule LoadBalancingRule_Status
		err := loadBalancingRule.AssignPropertiesFromLoadBalancingRuleStatus(&loadBalancingRuleItem)
		if err != nil {
			return errors.Wrap(err, "populating LoadBalancingRules from LoadBalancingRules, calling AssignPropertiesFromLoadBalancingRuleStatus()")
		}
		loadBalancingRuleList[loadBalancingRuleIndex] = loadBalancingRule
	}
	loadBalancerStatus.LoadBalancingRules = loadBalancingRuleList

	// Location
	if source.Location != nil {
		location := *source.Location
		loadBalancerStatus.Location = &location
	} else {
		loadBalancerStatus.Location = nil
	}

	// Name
	if source.Name != nil {
		name := *source.Name
		loadBalancerStatus.Name = &name
	} else {
		loadBalancerStatus.Name = nil
	}

	// OutboundRules
	outboundRuleList := make([]OutboundRule_Status, len(source.OutboundRules))
	for outboundRuleIndex, outboundRuleItem := range source.OutboundRules {
		// Shadow the loop variable to avoid aliasing
		outboundRuleItem := outboundRuleItem
		var outboundRule OutboundRule_Status
		err := outboundRule.AssignPropertiesFromOutboundRuleStatus(&outboundRuleItem)
		if err != nil {
			return errors.Wrap(err, "populating OutboundRules from OutboundRules, calling AssignPropertiesFromOutboundRuleStatus()")
		}
		outboundRuleList[outboundRuleIndex] = outboundRule
	}
	loadBalancerStatus.OutboundRules = outboundRuleList

	// Probes
	probeList := make([]Probe_Status, len(source.Probes))
	for probeIndex, probeItem := range source.Probes {
		// Shadow the loop variable to avoid aliasing
		probeItem := probeItem
		var probe Probe_Status
		err := probe.AssignPropertiesFromProbeStatus(&probeItem)
		if err != nil {
			return errors.Wrap(err, "populating Probes from Probes, calling AssignPropertiesFromProbeStatus()")
		}
		probeList[probeIndex] = probe
	}
	loadBalancerStatus.Probes = probeList

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ProvisioningState_Status(*source.ProvisioningState)
		loadBalancerStatus.ProvisioningState = &provisioningState
	} else {
		loadBalancerStatus.ProvisioningState = nil
	}

	// ResourceGuid
	if source.ResourceGuid != nil {
		resourceGuid := *source.ResourceGuid
		loadBalancerStatus.ResourceGuid = &resourceGuid
	} else {
		loadBalancerStatus.ResourceGuid = nil
	}

	// Sku
	if source.Sku != nil {
		var sku LoadBalancerSku_Status
		err := sku.AssignPropertiesFromLoadBalancerSkuStatus(source.Sku)
		if err != nil {
			return errors.Wrap(err, "populating Sku from Sku, calling AssignPropertiesFromLoadBalancerSkuStatus()")
		}
		loadBalancerStatus.Sku = &sku
	} else {
		loadBalancerStatus.Sku = nil
	}

	// Tags
	tagMap := make(map[string]string)
	for tagKey, tagValue := range source.Tags {
		// Shadow the loop variable to avoid aliasing
		tagValue := tagValue
		tagMap[tagKey] = tagValue
	}
	loadBalancerStatus.Tags = tagMap

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		loadBalancerStatus.Type = &typeVar
	} else {
		loadBalancerStatus.Type = nil
	}

	// No error
	return nil
}

// AssignPropertiesToLoadBalancerStatus populates the provided destination LoadBalancer_Status from our LoadBalancer_Status
func (loadBalancerStatus *LoadBalancer_Status) AssignPropertiesToLoadBalancerStatus(destination *v1alpha1api20201101storage.LoadBalancer_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackendAddressPools
	backendAddressPoolList := make([]v1alpha1api20201101storage.BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded, len(loadBalancerStatus.BackendAddressPools))
	for backendAddressPoolIndex, backendAddressPoolItem := range loadBalancerStatus.BackendAddressPools {
		// Shadow the loop variable to avoid aliasing
		backendAddressPoolItem := backendAddressPoolItem
		var backendAddressPool v1alpha1api20201101storage.BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded
		err := backendAddressPoolItem.AssignPropertiesToBackendAddressPoolStatusLoadBalancerSubResourceEmbedded(&backendAddressPool)
		if err != nil {
			return errors.Wrap(err, "populating BackendAddressPools from BackendAddressPools, calling AssignPropertiesToBackendAddressPoolStatusLoadBalancerSubResourceEmbedded()")
		}
		backendAddressPoolList[backendAddressPoolIndex] = backendAddressPool
	}
	destination.BackendAddressPools = backendAddressPoolList

	// Conditions
	conditionList := make([]conditions.Condition, len(loadBalancerStatus.Conditions))
	for conditionIndex, conditionItem := range loadBalancerStatus.Conditions {
		// Shadow the loop variable to avoid aliasing
		conditionItem := conditionItem
		conditionList[conditionIndex] = conditionItem.Copy()
	}
	destination.Conditions = conditionList

	// Etag
	if loadBalancerStatus.Etag != nil {
		etag := *loadBalancerStatus.Etag
		destination.Etag = &etag
	} else {
		destination.Etag = nil
	}

	// ExtendedLocation
	if loadBalancerStatus.ExtendedLocation != nil {
		var extendedLocation v1alpha1api20201101storage.ExtendedLocation_Status
		err := (*loadBalancerStatus.ExtendedLocation).AssignPropertiesToExtendedLocationStatus(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "populating ExtendedLocation from ExtendedLocation, calling AssignPropertiesToExtendedLocationStatus()")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// FrontendIPConfigurations
	frontendIPConfigurationList := make([]v1alpha1api20201101storage.FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded, len(loadBalancerStatus.FrontendIPConfigurations))
	for frontendIPConfigurationIndex, frontendIPConfigurationItem := range loadBalancerStatus.FrontendIPConfigurations {
		// Shadow the loop variable to avoid aliasing
		frontendIPConfigurationItem := frontendIPConfigurationItem
		var frontendIPConfiguration v1alpha1api20201101storage.FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded
		err := frontendIPConfigurationItem.AssignPropertiesToFrontendIPConfigurationStatusLoadBalancerSubResourceEmbedded(&frontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "populating FrontendIPConfigurations from FrontendIPConfigurations, calling AssignPropertiesToFrontendIPConfigurationStatusLoadBalancerSubResourceEmbedded()")
		}
		frontendIPConfigurationList[frontendIPConfigurationIndex] = frontendIPConfiguration
	}
	destination.FrontendIPConfigurations = frontendIPConfigurationList

	// Id
	if loadBalancerStatus.Id != nil {
		id := *loadBalancerStatus.Id
		destination.Id = &id
	} else {
		destination.Id = nil
	}

	// InboundNatPools
	inboundNatPoolList := make([]v1alpha1api20201101storage.InboundNatPool_Status, len(loadBalancerStatus.InboundNatPools))
	for inboundNatPoolIndex, inboundNatPoolItem := range loadBalancerStatus.InboundNatPools {
		// Shadow the loop variable to avoid aliasing
		inboundNatPoolItem := inboundNatPoolItem
		var inboundNatPool v1alpha1api20201101storage.InboundNatPool_Status
		err := inboundNatPoolItem.AssignPropertiesToInboundNatPoolStatus(&inboundNatPool)
		if err != nil {
			return errors.Wrap(err, "populating InboundNatPools from InboundNatPools, calling AssignPropertiesToInboundNatPoolStatus()")
		}
		inboundNatPoolList[inboundNatPoolIndex] = inboundNatPool
	}
	destination.InboundNatPools = inboundNatPoolList

	// InboundNatRules
	inboundNatRuleList := make([]v1alpha1api20201101storage.InboundNatRule_Status_LoadBalancer_SubResourceEmbedded, len(loadBalancerStatus.InboundNatRules))
	for inboundNatRuleIndex, inboundNatRuleItem := range loadBalancerStatus.InboundNatRules {
		// Shadow the loop variable to avoid aliasing
		inboundNatRuleItem := inboundNatRuleItem
		var inboundNatRule v1alpha1api20201101storage.InboundNatRule_Status_LoadBalancer_SubResourceEmbedded
		err := inboundNatRuleItem.AssignPropertiesToInboundNatRuleStatusLoadBalancerSubResourceEmbedded(&inboundNatRule)
		if err != nil {
			return errors.Wrap(err, "populating InboundNatRules from InboundNatRules, calling AssignPropertiesToInboundNatRuleStatusLoadBalancerSubResourceEmbedded()")
		}
		inboundNatRuleList[inboundNatRuleIndex] = inboundNatRule
	}
	destination.InboundNatRules = inboundNatRuleList

	// LoadBalancingRules
	loadBalancingRuleList := make([]v1alpha1api20201101storage.LoadBalancingRule_Status, len(loadBalancerStatus.LoadBalancingRules))
	for loadBalancingRuleIndex, loadBalancingRuleItem := range loadBalancerStatus.LoadBalancingRules {
		// Shadow the loop variable to avoid aliasing
		loadBalancingRuleItem := loadBalancingRuleItem
		var loadBalancingRule v1alpha1api20201101storage.LoadBalancingRule_Status
		err := loadBalancingRuleItem.AssignPropertiesToLoadBalancingRuleStatus(&loadBalancingRule)
		if err != nil {
			return errors.Wrap(err, "populating LoadBalancingRules from LoadBalancingRules, calling AssignPropertiesToLoadBalancingRuleStatus()")
		}
		loadBalancingRuleList[loadBalancingRuleIndex] = loadBalancingRule
	}
	destination.LoadBalancingRules = loadBalancingRuleList

	// Location
	if loadBalancerStatus.Location != nil {
		location := *loadBalancerStatus.Location
		destination.Location = &location
	} else {
		destination.Location = nil
	}

	// Name
	if loadBalancerStatus.Name != nil {
		name := *loadBalancerStatus.Name
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// OutboundRules
	outboundRuleList := make([]v1alpha1api20201101storage.OutboundRule_Status, len(loadBalancerStatus.OutboundRules))
	for outboundRuleIndex, outboundRuleItem := range loadBalancerStatus.OutboundRules {
		// Shadow the loop variable to avoid aliasing
		outboundRuleItem := outboundRuleItem
		var outboundRule v1alpha1api20201101storage.OutboundRule_Status
		err := outboundRuleItem.AssignPropertiesToOutboundRuleStatus(&outboundRule)
		if err != nil {
			return errors.Wrap(err, "populating OutboundRules from OutboundRules, calling AssignPropertiesToOutboundRuleStatus()")
		}
		outboundRuleList[outboundRuleIndex] = outboundRule
	}
	destination.OutboundRules = outboundRuleList

	// Probes
	probeList := make([]v1alpha1api20201101storage.Probe_Status, len(loadBalancerStatus.Probes))
	for probeIndex, probeItem := range loadBalancerStatus.Probes {
		// Shadow the loop variable to avoid aliasing
		probeItem := probeItem
		var probe v1alpha1api20201101storage.Probe_Status
		err := probeItem.AssignPropertiesToProbeStatus(&probe)
		if err != nil {
			return errors.Wrap(err, "populating Probes from Probes, calling AssignPropertiesToProbeStatus()")
		}
		probeList[probeIndex] = probe
	}
	destination.Probes = probeList

	// ProvisioningState
	if loadBalancerStatus.ProvisioningState != nil {
		provisioningState := string(*loadBalancerStatus.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// ResourceGuid
	if loadBalancerStatus.ResourceGuid != nil {
		resourceGuid := *loadBalancerStatus.ResourceGuid
		destination.ResourceGuid = &resourceGuid
	} else {
		destination.ResourceGuid = nil
	}

	// Sku
	if loadBalancerStatus.Sku != nil {
		var sku v1alpha1api20201101storage.LoadBalancerSku_Status
		err := (*loadBalancerStatus.Sku).AssignPropertiesToLoadBalancerSkuStatus(&sku)
		if err != nil {
			return errors.Wrap(err, "populating Sku from Sku, calling AssignPropertiesToLoadBalancerSkuStatus()")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	tagMap := make(map[string]string)
	for tagKey, tagValue := range loadBalancerStatus.Tags {
		// Shadow the loop variable to avoid aliasing
		tagValue := tagValue
		tagMap[tagKey] = tagValue
	}
	destination.Tags = tagMap

	// Type
	if loadBalancerStatus.Type != nil {
		typeVar := *loadBalancerStatus.Type
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

type LoadBalancers_Spec struct {
	//AzureName: The name of the resource in Azure. This is often the same as the name
	//of the resource in Kubernetes but it doesn't have to be.
	AzureName string `json:"azureName"`

	//BackendAddressPools: Collection of backend address pools used by a load balancer.
	BackendAddressPools []LoadBalancers_Spec_Properties_BackendAddressPools `json:"backendAddressPools,omitempty"`

	//ExtendedLocation: The extended location of the load balancer.
	ExtendedLocation *ExtendedLocation `json:"extendedLocation,omitempty"`

	//FrontendIPConfigurations: Object representing the frontend IPs to be used for
	//the load balancer.
	FrontendIPConfigurations []LoadBalancers_Spec_Properties_FrontendIPConfigurations `json:"frontendIPConfigurations,omitempty"`

	//InboundNatPools: Defines an external port range for inbound NAT to a single
	//backend port on NICs associated with a load balancer. Inbound NAT rules are
	//created automatically for each NIC associated with the Load Balancer using an
	//external port from this range. Defining an Inbound NAT pool on your Load
	//Balancer is mutually exclusive with defining inbound Nat rules. Inbound NAT
	//pools are referenced from virtual machine scale sets. NICs that are associated
	//with individual virtual machines cannot reference an inbound NAT pool. They have
	//to reference individual inbound NAT rules.
	InboundNatPools []LoadBalancers_Spec_Properties_InboundNatPools `json:"inboundNatPools,omitempty"`

	//LoadBalancingRules: Object collection representing the load balancing rules Gets
	//the provisioning.
	LoadBalancingRules []LoadBalancers_Spec_Properties_LoadBalancingRules `json:"loadBalancingRules,omitempty"`

	//Location: Location to deploy resource to
	Location string `json:"location,omitempty"`

	//OutboundRules: The outbound rules.
	OutboundRules []LoadBalancers_Spec_Properties_OutboundRules `json:"outboundRules,omitempty"`

	// +kubebuilder:validation:Required
	Owner genruntime.KnownResourceReference `group:"microsoft.resources.azure.com" json:"owner" kind:"ResourceGroup"`

	//Probes: Collection of probe objects used in the load balancer.
	Probes []LoadBalancers_Spec_Properties_Probes `json:"probes,omitempty"`

	//Sku: The load balancer SKU.
	Sku *LoadBalancerSku `json:"sku,omitempty"`

	//Tags: Name-value pairs to add to the resource
	Tags map[string]string `json:"tags,omitempty"`
}

var _ genruntime.ARMTransformer = &LoadBalancers_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (loadBalancersSpec *LoadBalancers_Spec) ConvertToARM(name string, resolvedReferences genruntime.ResolvedReferences) (interface{}, error) {
	if loadBalancersSpec == nil {
		return nil, nil
	}
	var result LoadBalancers_SpecARM

	// Set property ‘APIVersion’:
	result.APIVersion = LoadBalancersSpecAPIVersion20201101

	// Set property ‘ExtendedLocation’:
	if loadBalancersSpec.ExtendedLocation != nil {
		extendedLocationARM, err := (*loadBalancersSpec.ExtendedLocation).ConvertToARM(name, resolvedReferences)
		if err != nil {
			return nil, err
		}
		extendedLocation := extendedLocationARM.(ExtendedLocationARM)
		result.ExtendedLocation = &extendedLocation
	}

	// Set property ‘Location’:
	result.Location = loadBalancersSpec.Location

	// Set property ‘Name’:
	result.Name = name

	// Set property ‘Properties’:
	for _, item := range loadBalancersSpec.BackendAddressPools {
		itemARM, err := item.ConvertToARM(name, resolvedReferences)
		if err != nil {
			return nil, err
		}
		result.Properties.BackendAddressPools = append(result.Properties.BackendAddressPools, itemARM.(LoadBalancers_Spec_Properties_BackendAddressPoolsARM))
	}
	for _, item := range loadBalancersSpec.FrontendIPConfigurations {
		itemARM, err := item.ConvertToARM(name, resolvedReferences)
		if err != nil {
			return nil, err
		}
		result.Properties.FrontendIPConfigurations = append(result.Properties.FrontendIPConfigurations, itemARM.(LoadBalancers_Spec_Properties_FrontendIPConfigurationsARM))
	}
	for _, item := range loadBalancersSpec.InboundNatPools {
		itemARM, err := item.ConvertToARM(name, resolvedReferences)
		if err != nil {
			return nil, err
		}
		result.Properties.InboundNatPools = append(result.Properties.InboundNatPools, itemARM.(LoadBalancers_Spec_Properties_InboundNatPoolsARM))
	}
	for _, item := range loadBalancersSpec.LoadBalancingRules {
		itemARM, err := item.ConvertToARM(name, resolvedReferences)
		if err != nil {
			return nil, err
		}
		result.Properties.LoadBalancingRules = append(result.Properties.LoadBalancingRules, itemARM.(LoadBalancers_Spec_Properties_LoadBalancingRulesARM))
	}
	for _, item := range loadBalancersSpec.OutboundRules {
		itemARM, err := item.ConvertToARM(name, resolvedReferences)
		if err != nil {
			return nil, err
		}
		result.Properties.OutboundRules = append(result.Properties.OutboundRules, itemARM.(LoadBalancers_Spec_Properties_OutboundRulesARM))
	}
	for _, item := range loadBalancersSpec.Probes {
		itemARM, err := item.ConvertToARM(name, resolvedReferences)
		if err != nil {
			return nil, err
		}
		result.Properties.Probes = append(result.Properties.Probes, itemARM.(LoadBalancers_Spec_Properties_ProbesARM))
	}

	// Set property ‘Sku’:
	if loadBalancersSpec.Sku != nil {
		skuARM, err := (*loadBalancersSpec.Sku).ConvertToARM(name, resolvedReferences)
		if err != nil {
			return nil, err
		}
		sku := skuARM.(LoadBalancerSkuARM)
		result.Sku = &sku
	}

	// Set property ‘Tags’:
	if loadBalancersSpec.Tags != nil {
		result.Tags = make(map[string]string)
		for key, value := range loadBalancersSpec.Tags {
			result.Tags[key] = value
		}
	}

	// Set property ‘Type’:
	result.Type = LoadBalancersSpecTypeMicrosoftNetworkLoadBalancers
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (loadBalancersSpec *LoadBalancers_Spec) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &LoadBalancers_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (loadBalancersSpec *LoadBalancers_Spec) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(LoadBalancers_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LoadBalancers_SpecARM, got %T", armInput)
	}

	// Set property ‘AzureName’:
	loadBalancersSpec.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property ‘BackendAddressPools’:
	// copying flattened property:
	for _, item := range typedInput.Properties.BackendAddressPools {
		var item1 LoadBalancers_Spec_Properties_BackendAddressPools
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		loadBalancersSpec.BackendAddressPools = append(loadBalancersSpec.BackendAddressPools, item1)
	}

	// Set property ‘ExtendedLocation’:
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		loadBalancersSpec.ExtendedLocation = &extendedLocation
	}

	// Set property ‘FrontendIPConfigurations’:
	// copying flattened property:
	for _, item := range typedInput.Properties.FrontendIPConfigurations {
		var item1 LoadBalancers_Spec_Properties_FrontendIPConfigurations
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		loadBalancersSpec.FrontendIPConfigurations = append(loadBalancersSpec.FrontendIPConfigurations, item1)
	}

	// Set property ‘InboundNatPools’:
	// copying flattened property:
	for _, item := range typedInput.Properties.InboundNatPools {
		var item1 LoadBalancers_Spec_Properties_InboundNatPools
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		loadBalancersSpec.InboundNatPools = append(loadBalancersSpec.InboundNatPools, item1)
	}

	// Set property ‘LoadBalancingRules’:
	// copying flattened property:
	for _, item := range typedInput.Properties.LoadBalancingRules {
		var item1 LoadBalancers_Spec_Properties_LoadBalancingRules
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		loadBalancersSpec.LoadBalancingRules = append(loadBalancersSpec.LoadBalancingRules, item1)
	}

	// Set property ‘Location’:
	loadBalancersSpec.Location = typedInput.Location

	// Set property ‘OutboundRules’:
	// copying flattened property:
	for _, item := range typedInput.Properties.OutboundRules {
		var item1 LoadBalancers_Spec_Properties_OutboundRules
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		loadBalancersSpec.OutboundRules = append(loadBalancersSpec.OutboundRules, item1)
	}

	// Set property ‘Owner’:
	loadBalancersSpec.Owner = owner

	// Set property ‘Probes’:
	// copying flattened property:
	for _, item := range typedInput.Properties.Probes {
		var item1 LoadBalancers_Spec_Properties_Probes
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		loadBalancersSpec.Probes = append(loadBalancersSpec.Probes, item1)
	}

	// Set property ‘Sku’:
	if typedInput.Sku != nil {
		var sku1 LoadBalancerSku
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		loadBalancersSpec.Sku = &sku
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		loadBalancersSpec.Tags = make(map[string]string)
		for key, value := range typedInput.Tags {
			loadBalancersSpec.Tags[key] = value
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &LoadBalancers_Spec{}

// ConvertSpecFrom populates our LoadBalancers_Spec from the provided source
func (loadBalancersSpec *LoadBalancers_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v1alpha1api20201101storage.LoadBalancers_Spec)
	if ok {
		// Populate our instance from source
		return loadBalancersSpec.AssignPropertiesFromLoadBalancersSpec(src)
	}

	// Convert to an intermediate form
	src = &v1alpha1api20201101storage.LoadBalancers_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = loadBalancersSpec.AssignPropertiesFromLoadBalancersSpec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our LoadBalancers_Spec
func (loadBalancersSpec *LoadBalancers_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v1alpha1api20201101storage.LoadBalancers_Spec)
	if ok {
		// Populate destination from our instance
		return loadBalancersSpec.AssignPropertiesToLoadBalancersSpec(dst)
	}

	// Convert to an intermediate form
	dst = &v1alpha1api20201101storage.LoadBalancers_Spec{}
	err := loadBalancersSpec.AssignPropertiesToLoadBalancersSpec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignPropertiesFromLoadBalancersSpec populates our LoadBalancers_Spec from the provided source LoadBalancers_Spec
func (loadBalancersSpec *LoadBalancers_Spec) AssignPropertiesFromLoadBalancersSpec(source *v1alpha1api20201101storage.LoadBalancers_Spec) error {

	// AzureName
	loadBalancersSpec.AzureName = source.AzureName

	// BackendAddressPools
	backendAddressPoolList := make([]LoadBalancers_Spec_Properties_BackendAddressPools, len(source.BackendAddressPools))
	for backendAddressPoolIndex, backendAddressPoolItem := range source.BackendAddressPools {
		// Shadow the loop variable to avoid aliasing
		backendAddressPoolItem := backendAddressPoolItem
		var backendAddressPool LoadBalancers_Spec_Properties_BackendAddressPools
		err := backendAddressPool.AssignPropertiesFromLoadBalancersSpecPropertiesBackendAddressPools(&backendAddressPoolItem)
		if err != nil {
			return errors.Wrap(err, "populating BackendAddressPools from BackendAddressPools, calling AssignPropertiesFromLoadBalancersSpecPropertiesBackendAddressPools()")
		}
		backendAddressPoolList[backendAddressPoolIndex] = backendAddressPool
	}
	loadBalancersSpec.BackendAddressPools = backendAddressPoolList

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation
		err := extendedLocation.AssignPropertiesFromExtendedLocation(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "populating ExtendedLocation from ExtendedLocation, calling AssignPropertiesFromExtendedLocation()")
		}
		loadBalancersSpec.ExtendedLocation = &extendedLocation
	} else {
		loadBalancersSpec.ExtendedLocation = nil
	}

	// FrontendIPConfigurations
	frontendIPConfigurationList := make([]LoadBalancers_Spec_Properties_FrontendIPConfigurations, len(source.FrontendIPConfigurations))
	for frontendIPConfigurationIndex, frontendIPConfigurationItem := range source.FrontendIPConfigurations {
		// Shadow the loop variable to avoid aliasing
		frontendIPConfigurationItem := frontendIPConfigurationItem
		var frontendIPConfiguration LoadBalancers_Spec_Properties_FrontendIPConfigurations
		err := frontendIPConfiguration.AssignPropertiesFromLoadBalancersSpecPropertiesFrontendIPConfigurations(&frontendIPConfigurationItem)
		if err != nil {
			return errors.Wrap(err, "populating FrontendIPConfigurations from FrontendIPConfigurations, calling AssignPropertiesFromLoadBalancersSpecPropertiesFrontendIPConfigurations()")
		}
		frontendIPConfigurationList[frontendIPConfigurationIndex] = frontendIPConfiguration
	}
	loadBalancersSpec.FrontendIPConfigurations = frontendIPConfigurationList

	// InboundNatPools
	inboundNatPoolList := make([]LoadBalancers_Spec_Properties_InboundNatPools, len(source.InboundNatPools))
	for inboundNatPoolIndex, inboundNatPoolItem := range source.InboundNatPools {
		// Shadow the loop variable to avoid aliasing
		inboundNatPoolItem := inboundNatPoolItem
		var inboundNatPool LoadBalancers_Spec_Properties_InboundNatPools
		err := inboundNatPool.AssignPropertiesFromLoadBalancersSpecPropertiesInboundNatPools(&inboundNatPoolItem)
		if err != nil {
			return errors.Wrap(err, "populating InboundNatPools from InboundNatPools, calling AssignPropertiesFromLoadBalancersSpecPropertiesInboundNatPools()")
		}
		inboundNatPoolList[inboundNatPoolIndex] = inboundNatPool
	}
	loadBalancersSpec.InboundNatPools = inboundNatPoolList

	// LoadBalancingRules
	loadBalancingRuleList := make([]LoadBalancers_Spec_Properties_LoadBalancingRules, len(source.LoadBalancingRules))
	for loadBalancingRuleIndex, loadBalancingRuleItem := range source.LoadBalancingRules {
		// Shadow the loop variable to avoid aliasing
		loadBalancingRuleItem := loadBalancingRuleItem
		var loadBalancingRule LoadBalancers_Spec_Properties_LoadBalancingRules
		err := loadBalancingRule.AssignPropertiesFromLoadBalancersSpecPropertiesLoadBalancingRules(&loadBalancingRuleItem)
		if err != nil {
			return errors.Wrap(err, "populating LoadBalancingRules from LoadBalancingRules, calling AssignPropertiesFromLoadBalancersSpecPropertiesLoadBalancingRules()")
		}
		loadBalancingRuleList[loadBalancingRuleIndex] = loadBalancingRule
	}
	loadBalancersSpec.LoadBalancingRules = loadBalancingRuleList

	// Location
	if source.Location != nil {
		loadBalancersSpec.Location = *source.Location
	} else {
		loadBalancersSpec.Location = ""
	}

	// OutboundRules
	outboundRuleList := make([]LoadBalancers_Spec_Properties_OutboundRules, len(source.OutboundRules))
	for outboundRuleIndex, outboundRuleItem := range source.OutboundRules {
		// Shadow the loop variable to avoid aliasing
		outboundRuleItem := outboundRuleItem
		var outboundRule LoadBalancers_Spec_Properties_OutboundRules
		err := outboundRule.AssignPropertiesFromLoadBalancersSpecPropertiesOutboundRules(&outboundRuleItem)
		if err != nil {
			return errors.Wrap(err, "populating OutboundRules from OutboundRules, calling AssignPropertiesFromLoadBalancersSpecPropertiesOutboundRules()")
		}
		outboundRuleList[outboundRuleIndex] = outboundRule
	}
	loadBalancersSpec.OutboundRules = outboundRuleList

	// Owner
	loadBalancersSpec.Owner = source.Owner.Copy()

	// Probes
	probeList := make([]LoadBalancers_Spec_Properties_Probes, len(source.Probes))
	for probeIndex, probeItem := range source.Probes {
		// Shadow the loop variable to avoid aliasing
		probeItem := probeItem
		var probe LoadBalancers_Spec_Properties_Probes
		err := probe.AssignPropertiesFromLoadBalancersSpecPropertiesProbes(&probeItem)
		if err != nil {
			return errors.Wrap(err, "populating Probes from Probes, calling AssignPropertiesFromLoadBalancersSpecPropertiesProbes()")
		}
		probeList[probeIndex] = probe
	}
	loadBalancersSpec.Probes = probeList

	// Sku
	if source.Sku != nil {
		var sku LoadBalancerSku
		err := sku.AssignPropertiesFromLoadBalancerSku(source.Sku)
		if err != nil {
			return errors.Wrap(err, "populating Sku from Sku, calling AssignPropertiesFromLoadBalancerSku()")
		}
		loadBalancersSpec.Sku = &sku
	} else {
		loadBalancersSpec.Sku = nil
	}

	// Tags
	tagMap := make(map[string]string)
	for tagKey, tagValue := range source.Tags {
		// Shadow the loop variable to avoid aliasing
		tagValue := tagValue
		tagMap[tagKey] = tagValue
	}
	loadBalancersSpec.Tags = tagMap

	// No error
	return nil
}

// AssignPropertiesToLoadBalancersSpec populates the provided destination LoadBalancers_Spec from our LoadBalancers_Spec
func (loadBalancersSpec *LoadBalancers_Spec) AssignPropertiesToLoadBalancersSpec(destination *v1alpha1api20201101storage.LoadBalancers_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = loadBalancersSpec.AzureName

	// BackendAddressPools
	backendAddressPoolList := make([]v1alpha1api20201101storage.LoadBalancers_Spec_Properties_BackendAddressPools, len(loadBalancersSpec.BackendAddressPools))
	for backendAddressPoolIndex, backendAddressPoolItem := range loadBalancersSpec.BackendAddressPools {
		// Shadow the loop variable to avoid aliasing
		backendAddressPoolItem := backendAddressPoolItem
		var backendAddressPool v1alpha1api20201101storage.LoadBalancers_Spec_Properties_BackendAddressPools
		err := backendAddressPoolItem.AssignPropertiesToLoadBalancersSpecPropertiesBackendAddressPools(&backendAddressPool)
		if err != nil {
			return errors.Wrap(err, "populating BackendAddressPools from BackendAddressPools, calling AssignPropertiesToLoadBalancersSpecPropertiesBackendAddressPools()")
		}
		backendAddressPoolList[backendAddressPoolIndex] = backendAddressPool
	}
	destination.BackendAddressPools = backendAddressPoolList

	// ExtendedLocation
	if loadBalancersSpec.ExtendedLocation != nil {
		var extendedLocation v1alpha1api20201101storage.ExtendedLocation
		err := (*loadBalancersSpec.ExtendedLocation).AssignPropertiesToExtendedLocation(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "populating ExtendedLocation from ExtendedLocation, calling AssignPropertiesToExtendedLocation()")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// FrontendIPConfigurations
	frontendIPConfigurationList := make([]v1alpha1api20201101storage.LoadBalancers_Spec_Properties_FrontendIPConfigurations, len(loadBalancersSpec.FrontendIPConfigurations))
	for frontendIPConfigurationIndex, frontendIPConfigurationItem := range loadBalancersSpec.FrontendIPConfigurations {
		// Shadow the loop variable to avoid aliasing
		frontendIPConfigurationItem := frontendIPConfigurationItem
		var frontendIPConfiguration v1alpha1api20201101storage.LoadBalancers_Spec_Properties_FrontendIPConfigurations
		err := frontendIPConfigurationItem.AssignPropertiesToLoadBalancersSpecPropertiesFrontendIPConfigurations(&frontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "populating FrontendIPConfigurations from FrontendIPConfigurations, calling AssignPropertiesToLoadBalancersSpecPropertiesFrontendIPConfigurations()")
		}
		frontendIPConfigurationList[frontendIPConfigurationIndex] = frontendIPConfiguration
	}
	destination.FrontendIPConfigurations = frontendIPConfigurationList

	// InboundNatPools
	inboundNatPoolList := make([]v1alpha1api20201101storage.LoadBalancers_Spec_Properties_InboundNatPools, len(loadBalancersSpec.InboundNatPools))
	for inboundNatPoolIndex, inboundNatPoolItem := range loadBalancersSpec.InboundNatPools {
		// Shadow the loop variable to avoid aliasing
		inboundNatPoolItem := inboundNatPoolItem
		var inboundNatPool v1alpha1api20201101storage.LoadBalancers_Spec_Properties_InboundNatPools
		err := inboundNatPoolItem.AssignPropertiesToLoadBalancersSpecPropertiesInboundNatPools(&inboundNatPool)
		if err != nil {
			return errors.Wrap(err, "populating InboundNatPools from InboundNatPools, calling AssignPropertiesToLoadBalancersSpecPropertiesInboundNatPools()")
		}
		inboundNatPoolList[inboundNatPoolIndex] = inboundNatPool
	}
	destination.InboundNatPools = inboundNatPoolList

	// LoadBalancingRules
	loadBalancingRuleList := make([]v1alpha1api20201101storage.LoadBalancers_Spec_Properties_LoadBalancingRules, len(loadBalancersSpec.LoadBalancingRules))
	for loadBalancingRuleIndex, loadBalancingRuleItem := range loadBalancersSpec.LoadBalancingRules {
		// Shadow the loop variable to avoid aliasing
		loadBalancingRuleItem := loadBalancingRuleItem
		var loadBalancingRule v1alpha1api20201101storage.LoadBalancers_Spec_Properties_LoadBalancingRules
		err := loadBalancingRuleItem.AssignPropertiesToLoadBalancersSpecPropertiesLoadBalancingRules(&loadBalancingRule)
		if err != nil {
			return errors.Wrap(err, "populating LoadBalancingRules from LoadBalancingRules, calling AssignPropertiesToLoadBalancersSpecPropertiesLoadBalancingRules()")
		}
		loadBalancingRuleList[loadBalancingRuleIndex] = loadBalancingRule
	}
	destination.LoadBalancingRules = loadBalancingRuleList

	// Location
	location := loadBalancersSpec.Location
	destination.Location = &location

	// OriginalVersion
	destination.OriginalVersion = loadBalancersSpec.OriginalVersion()

	// OutboundRules
	outboundRuleList := make([]v1alpha1api20201101storage.LoadBalancers_Spec_Properties_OutboundRules, len(loadBalancersSpec.OutboundRules))
	for outboundRuleIndex, outboundRuleItem := range loadBalancersSpec.OutboundRules {
		// Shadow the loop variable to avoid aliasing
		outboundRuleItem := outboundRuleItem
		var outboundRule v1alpha1api20201101storage.LoadBalancers_Spec_Properties_OutboundRules
		err := outboundRuleItem.AssignPropertiesToLoadBalancersSpecPropertiesOutboundRules(&outboundRule)
		if err != nil {
			return errors.Wrap(err, "populating OutboundRules from OutboundRules, calling AssignPropertiesToLoadBalancersSpecPropertiesOutboundRules()")
		}
		outboundRuleList[outboundRuleIndex] = outboundRule
	}
	destination.OutboundRules = outboundRuleList

	// Owner
	destination.Owner = loadBalancersSpec.Owner.Copy()

	// Probes
	probeList := make([]v1alpha1api20201101storage.LoadBalancers_Spec_Properties_Probes, len(loadBalancersSpec.Probes))
	for probeIndex, probeItem := range loadBalancersSpec.Probes {
		// Shadow the loop variable to avoid aliasing
		probeItem := probeItem
		var probe v1alpha1api20201101storage.LoadBalancers_Spec_Properties_Probes
		err := probeItem.AssignPropertiesToLoadBalancersSpecPropertiesProbes(&probe)
		if err != nil {
			return errors.Wrap(err, "populating Probes from Probes, calling AssignPropertiesToLoadBalancersSpecPropertiesProbes()")
		}
		probeList[probeIndex] = probe
	}
	destination.Probes = probeList

	// Sku
	if loadBalancersSpec.Sku != nil {
		var sku v1alpha1api20201101storage.LoadBalancerSku
		err := (*loadBalancersSpec.Sku).AssignPropertiesToLoadBalancerSku(&sku)
		if err != nil {
			return errors.Wrap(err, "populating Sku from Sku, calling AssignPropertiesToLoadBalancerSku()")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	tagMap := make(map[string]string)
	for tagKey, tagValue := range loadBalancersSpec.Tags {
		// Shadow the loop variable to avoid aliasing
		tagValue := tagValue
		tagMap[tagKey] = tagValue
	}
	destination.Tags = tagMap

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

func (loadBalancersSpec *LoadBalancers_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (loadBalancersSpec *LoadBalancers_Spec) SetAzureName(azureName string) {
	loadBalancersSpec.AzureName = azureName
}

//Generated from:
type BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded struct {
	//Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (backendAddressPoolStatusLoadBalancerSubResourceEmbedded *BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &BackendAddressPool_Status_LoadBalancer_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (backendAddressPoolStatusLoadBalancerSubResourceEmbedded *BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(BackendAddressPool_Status_LoadBalancer_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BackendAddressPool_Status_LoadBalancer_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		backendAddressPoolStatusLoadBalancerSubResourceEmbedded.Id = &id
	}

	// No error
	return nil
}

// AssignPropertiesFromBackendAddressPoolStatusLoadBalancerSubResourceEmbedded populates our BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded from the provided source BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded
func (backendAddressPoolStatusLoadBalancerSubResourceEmbedded *BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded) AssignPropertiesFromBackendAddressPoolStatusLoadBalancerSubResourceEmbedded(source *v1alpha1api20201101storage.BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded) error {

	// Id
	if source.Id != nil {
		id := *source.Id
		backendAddressPoolStatusLoadBalancerSubResourceEmbedded.Id = &id
	} else {
		backendAddressPoolStatusLoadBalancerSubResourceEmbedded.Id = nil
	}

	// No error
	return nil
}

// AssignPropertiesToBackendAddressPoolStatusLoadBalancerSubResourceEmbedded populates the provided destination BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded from our BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded
func (backendAddressPoolStatusLoadBalancerSubResourceEmbedded *BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded) AssignPropertiesToBackendAddressPoolStatusLoadBalancerSubResourceEmbedded(destination *v1alpha1api20201101storage.BackendAddressPool_Status_LoadBalancer_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	if backendAddressPoolStatusLoadBalancerSubResourceEmbedded.Id != nil {
		id := *backendAddressPoolStatusLoadBalancerSubResourceEmbedded.Id
		destination.Id = &id
	} else {
		destination.Id = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-11-01/Microsoft.Network.json#/definitions/ExtendedLocation
type ExtendedLocation struct {
	// +kubebuilder:validation:Required
	//Name: The name of the extended location.
	Name string `json:"name"`

	// +kubebuilder:validation:Required
	//Type: The type of the extended location.
	Type ExtendedLocationType `json:"type"`
}

var _ genruntime.ARMTransformer = &ExtendedLocation{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (extendedLocation *ExtendedLocation) ConvertToARM(name string, resolvedReferences genruntime.ResolvedReferences) (interface{}, error) {
	if extendedLocation == nil {
		return nil, nil
	}
	var result ExtendedLocationARM

	// Set property ‘Name’:
	result.Name = extendedLocation.Name

	// Set property ‘Type’:
	result.Type = extendedLocation.Type
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (extendedLocation *ExtendedLocation) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ExtendedLocationARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (extendedLocation *ExtendedLocation) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(ExtendedLocationARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ExtendedLocationARM, got %T", armInput)
	}

	// Set property ‘Name’:
	extendedLocation.Name = typedInput.Name

	// Set property ‘Type’:
	extendedLocation.Type = typedInput.Type

	// No error
	return nil
}

// AssignPropertiesFromExtendedLocation populates our ExtendedLocation from the provided source ExtendedLocation
func (extendedLocation *ExtendedLocation) AssignPropertiesFromExtendedLocation(source *v1alpha1api20201101storage.ExtendedLocation) error {

	// Name
	if source.Name != nil {
		extendedLocation.Name = *source.Name
	} else {
		extendedLocation.Name = ""
	}

	// Type
	if source.Type != nil {
		extendedLocation.Type = ExtendedLocationType(*source.Type)
	} else {
		extendedLocation.Type = ""
	}

	// No error
	return nil
}

// AssignPropertiesToExtendedLocation populates the provided destination ExtendedLocation from our ExtendedLocation
func (extendedLocation *ExtendedLocation) AssignPropertiesToExtendedLocation(destination *v1alpha1api20201101storage.ExtendedLocation) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	name := extendedLocation.Name
	destination.Name = &name

	// Type
	typeVar := string(extendedLocation.Type)
	destination.Type = &typeVar

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type ExtendedLocation_Status struct {
	// +kubebuilder:validation:Required
	//Name: The name of the extended location.
	Name string `json:"name"`

	// +kubebuilder:validation:Required
	//Type: The type of the extended location.
	Type ExtendedLocationType_Status `json:"type"`
}

var _ genruntime.FromARMConverter = &ExtendedLocation_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (extendedLocationStatus *ExtendedLocation_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ExtendedLocation_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (extendedLocationStatus *ExtendedLocation_Status) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(ExtendedLocation_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ExtendedLocation_StatusARM, got %T", armInput)
	}

	// Set property ‘Name’:
	extendedLocationStatus.Name = typedInput.Name

	// Set property ‘Type’:
	extendedLocationStatus.Type = typedInput.Type

	// No error
	return nil
}

// AssignPropertiesFromExtendedLocationStatus populates our ExtendedLocation_Status from the provided source ExtendedLocation_Status
func (extendedLocationStatus *ExtendedLocation_Status) AssignPropertiesFromExtendedLocationStatus(source *v1alpha1api20201101storage.ExtendedLocation_Status) error {

	// Name
	if source.Name != nil {
		extendedLocationStatus.Name = *source.Name
	} else {
		extendedLocationStatus.Name = ""
	}

	// Type
	if source.Type != nil {
		extendedLocationStatus.Type = ExtendedLocationType_Status(*source.Type)
	} else {
		extendedLocationStatus.Type = ""
	}

	// No error
	return nil
}

// AssignPropertiesToExtendedLocationStatus populates the provided destination ExtendedLocation_Status from our ExtendedLocation_Status
func (extendedLocationStatus *ExtendedLocation_Status) AssignPropertiesToExtendedLocationStatus(destination *v1alpha1api20201101storage.ExtendedLocation_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	name := extendedLocationStatus.Name
	destination.Name = &name

	// Type
	typeVar := string(extendedLocationStatus.Type)
	destination.Type = &typeVar

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded struct {
	//Etag: A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	//Id: Resource ID.
	Id *string `json:"id,omitempty"`

	//InboundNatPools: An array of references to inbound pools that use this frontend
	//IP.
	InboundNatPools []SubResource_Status `json:"inboundNatPools,omitempty"`

	//InboundNatRules: An array of references to inbound rules that use this frontend
	//IP.
	InboundNatRules []SubResource_Status `json:"inboundNatRules,omitempty"`

	//LoadBalancingRules: An array of references to load balancing rules that use this
	//frontend IP.
	LoadBalancingRules []SubResource_Status `json:"loadBalancingRules,omitempty"`

	//Name: The name of the resource that is unique within the set of frontend IP
	//configurations used by the load balancer. This name can be used to access the
	//resource.
	Name *string `json:"name,omitempty"`

	//OutboundRules: An array of references to outbound rules that use this frontend
	//IP.
	OutboundRules []SubResource_Status `json:"outboundRules,omitempty"`

	//PrivateIPAddress: The private IP address of the IP configuration.
	PrivateIPAddress *string `json:"privateIPAddress,omitempty"`

	//PrivateIPAddressVersion: Whether the specific ipconfiguration is IPv4 or IPv6.
	//Default is taken as IPv4.
	PrivateIPAddressVersion *IPVersion_Status `json:"privateIPAddressVersion,omitempty"`

	//PrivateIPAllocationMethod: The Private IP allocation method.
	PrivateIPAllocationMethod *IPAllocationMethod_Status `json:"privateIPAllocationMethod,omitempty"`

	//ProvisioningState: The provisioning state of the frontend IP configuration
	//resource.
	ProvisioningState *ProvisioningState_Status `json:"provisioningState,omitempty"`

	//PublicIPAddress: The reference to the Public IP resource.
	PublicIPAddress *PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded `json:"publicIPAddress,omitempty"`

	//PublicIPPrefix: The reference to the Public IP Prefix resource.
	PublicIPPrefix *SubResource_Status `json:"publicIPPrefix,omitempty"`

	//Subnet: The reference to the subnet resource.
	Subnet *Subnet_Status_LoadBalancer_SubResourceEmbedded `json:"subnet,omitempty"`

	//Type: Type of the resource.
	Type *string `json:"type,omitempty"`

	//Zones: A list of availability zones denoting the IP allocated for the resource
	//needs to come from.
	Zones []string `json:"zones,omitempty"`
}

var _ genruntime.FromARMConverter = &FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded *FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded *FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘Etag’:
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.Etag = &etag
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.Id = &id
	}

	// Set property ‘InboundNatPools’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.InboundNatPools {
			var item1 SubResource_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.InboundNatPools = append(frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.InboundNatPools, item1)
		}
	}

	// Set property ‘InboundNatRules’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.InboundNatRules {
			var item1 SubResource_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.InboundNatRules = append(frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.InboundNatRules, item1)
		}
	}

	// Set property ‘LoadBalancingRules’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancingRules {
			var item1 SubResource_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.LoadBalancingRules = append(frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.LoadBalancingRules, item1)
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.Name = &name
	}

	// Set property ‘OutboundRules’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.OutboundRules {
			var item1 SubResource_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.OutboundRules = append(frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.OutboundRules, item1)
		}
	}

	// Set property ‘PrivateIPAddress’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAddress != nil {
			privateIPAddress := *typedInput.Properties.PrivateIPAddress
			frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.PrivateIPAddress = &privateIPAddress
		}
	}

	// Set property ‘PrivateIPAddressVersion’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAddressVersion != nil {
			privateIPAddressVersion := *typedInput.Properties.PrivateIPAddressVersion
			frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.PrivateIPAddressVersion = &privateIPAddressVersion
		}
	}

	// Set property ‘PrivateIPAllocationMethod’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAllocationMethod != nil {
			privateIPAllocationMethod := *typedInput.Properties.PrivateIPAllocationMethod
			frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.PrivateIPAllocationMethod = &privateIPAllocationMethod
		}
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘PublicIPAddress’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPAddress != nil {
			var publicIPAddress1 PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded
			err := publicIPAddress1.PopulateFromARM(owner, *typedInput.Properties.PublicIPAddress)
			if err != nil {
				return err
			}
			publicIPAddress := publicIPAddress1
			frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.PublicIPAddress = &publicIPAddress
		}
	}

	// Set property ‘PublicIPPrefix’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPPrefix != nil {
			var publicIPPrefix1 SubResource_Status
			err := publicIPPrefix1.PopulateFromARM(owner, *typedInput.Properties.PublicIPPrefix)
			if err != nil {
				return err
			}
			publicIPPrefix := publicIPPrefix1
			frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.PublicIPPrefix = &publicIPPrefix
		}
	}

	// Set property ‘Subnet’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Subnet != nil {
			var subnet1 Subnet_Status_LoadBalancer_SubResourceEmbedded
			err := subnet1.PopulateFromARM(owner, *typedInput.Properties.Subnet)
			if err != nil {
				return err
			}
			subnet := subnet1
			frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.Subnet = &subnet
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.Type = &typeVar
	}

	// Set property ‘Zones’:
	for _, item := range typedInput.Zones {
		frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.Zones = append(frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.Zones, item)
	}

	// No error
	return nil
}

// AssignPropertiesFromFrontendIPConfigurationStatusLoadBalancerSubResourceEmbedded populates our FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded from the provided source FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded
func (frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded *FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded) AssignPropertiesFromFrontendIPConfigurationStatusLoadBalancerSubResourceEmbedded(source *v1alpha1api20201101storage.FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded) error {

	// Etag
	if source.Etag != nil {
		etag := *source.Etag
		frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.Etag = &etag
	} else {
		frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.Etag = nil
	}

	// Id
	if source.Id != nil {
		id := *source.Id
		frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.Id = &id
	} else {
		frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.Id = nil
	}

	// InboundNatPools
	inboundNatPoolList := make([]SubResource_Status, len(source.InboundNatPools))
	for inboundNatPoolIndex, inboundNatPoolItem := range source.InboundNatPools {
		// Shadow the loop variable to avoid aliasing
		inboundNatPoolItem := inboundNatPoolItem
		var inboundNatPool SubResource_Status
		err := inboundNatPool.AssignPropertiesFromSubResourceStatus(&inboundNatPoolItem)
		if err != nil {
			return errors.Wrap(err, "populating InboundNatPools from InboundNatPools, calling AssignPropertiesFromSubResourceStatus()")
		}
		inboundNatPoolList[inboundNatPoolIndex] = inboundNatPool
	}
	frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.InboundNatPools = inboundNatPoolList

	// InboundNatRules
	inboundNatRuleList := make([]SubResource_Status, len(source.InboundNatRules))
	for inboundNatRuleIndex, inboundNatRuleItem := range source.InboundNatRules {
		// Shadow the loop variable to avoid aliasing
		inboundNatRuleItem := inboundNatRuleItem
		var inboundNatRule SubResource_Status
		err := inboundNatRule.AssignPropertiesFromSubResourceStatus(&inboundNatRuleItem)
		if err != nil {
			return errors.Wrap(err, "populating InboundNatRules from InboundNatRules, calling AssignPropertiesFromSubResourceStatus()")
		}
		inboundNatRuleList[inboundNatRuleIndex] = inboundNatRule
	}
	frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.InboundNatRules = inboundNatRuleList

	// LoadBalancingRules
	loadBalancingRuleList := make([]SubResource_Status, len(source.LoadBalancingRules))
	for loadBalancingRuleIndex, loadBalancingRuleItem := range source.LoadBalancingRules {
		// Shadow the loop variable to avoid aliasing
		loadBalancingRuleItem := loadBalancingRuleItem
		var loadBalancingRule SubResource_Status
		err := loadBalancingRule.AssignPropertiesFromSubResourceStatus(&loadBalancingRuleItem)
		if err != nil {
			return errors.Wrap(err, "populating LoadBalancingRules from LoadBalancingRules, calling AssignPropertiesFromSubResourceStatus()")
		}
		loadBalancingRuleList[loadBalancingRuleIndex] = loadBalancingRule
	}
	frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.LoadBalancingRules = loadBalancingRuleList

	// Name
	if source.Name != nil {
		name := *source.Name
		frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.Name = &name
	} else {
		frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.Name = nil
	}

	// OutboundRules
	outboundRuleList := make([]SubResource_Status, len(source.OutboundRules))
	for outboundRuleIndex, outboundRuleItem := range source.OutboundRules {
		// Shadow the loop variable to avoid aliasing
		outboundRuleItem := outboundRuleItem
		var outboundRule SubResource_Status
		err := outboundRule.AssignPropertiesFromSubResourceStatus(&outboundRuleItem)
		if err != nil {
			return errors.Wrap(err, "populating OutboundRules from OutboundRules, calling AssignPropertiesFromSubResourceStatus()")
		}
		outboundRuleList[outboundRuleIndex] = outboundRule
	}
	frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.OutboundRules = outboundRuleList

	// PrivateIPAddress
	if source.PrivateIPAddress != nil {
		privateIPAddress := *source.PrivateIPAddress
		frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.PrivateIPAddress = &privateIPAddress
	} else {
		frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.PrivateIPAddress = nil
	}

	// PrivateIPAddressVersion
	if source.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := IPVersion_Status(*source.PrivateIPAddressVersion)
		frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.PrivateIPAddressVersion = nil
	}

	// PrivateIPAllocationMethod
	if source.PrivateIPAllocationMethod != nil {
		privateIPAllocationMethod := IPAllocationMethod_Status(*source.PrivateIPAllocationMethod)
		frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.PrivateIPAllocationMethod = &privateIPAllocationMethod
	} else {
		frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.PrivateIPAllocationMethod = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ProvisioningState_Status(*source.ProvisioningState)
		frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.ProvisioningState = &provisioningState
	} else {
		frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.ProvisioningState = nil
	}

	// PublicIPAddress
	if source.PublicIPAddress != nil {
		var publicIPAddress PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded
		err := publicIPAddress.AssignPropertiesFromPublicIPAddressStatusLoadBalancerSubResourceEmbedded(source.PublicIPAddress)
		if err != nil {
			return errors.Wrap(err, "populating PublicIPAddress from PublicIPAddress, calling AssignPropertiesFromPublicIPAddressStatusLoadBalancerSubResourceEmbedded()")
		}
		frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.PublicIPAddress = &publicIPAddress
	} else {
		frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.PublicIPAddress = nil
	}

	// PublicIPPrefix
	if source.PublicIPPrefix != nil {
		var publicIPPrefix SubResource_Status
		err := publicIPPrefix.AssignPropertiesFromSubResourceStatus(source.PublicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "populating PublicIPPrefix from PublicIPPrefix, calling AssignPropertiesFromSubResourceStatus()")
		}
		frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.PublicIPPrefix = &publicIPPrefix
	} else {
		frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.PublicIPPrefix = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet Subnet_Status_LoadBalancer_SubResourceEmbedded
		err := subnet.AssignPropertiesFromSubnetStatusLoadBalancerSubResourceEmbedded(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "populating Subnet from Subnet, calling AssignPropertiesFromSubnetStatusLoadBalancerSubResourceEmbedded()")
		}
		frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.Subnet = &subnet
	} else {
		frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.Subnet = nil
	}

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.Type = &typeVar
	} else {
		frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.Type = nil
	}

	// Zones
	zoneList := make([]string, len(source.Zones))
	for zoneIndex, zoneItem := range source.Zones {
		// Shadow the loop variable to avoid aliasing
		zoneItem := zoneItem
		zoneList[zoneIndex] = zoneItem
	}
	frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.Zones = zoneList

	// No error
	return nil
}

// AssignPropertiesToFrontendIPConfigurationStatusLoadBalancerSubResourceEmbedded populates the provided destination FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded from our FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded
func (frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded *FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded) AssignPropertiesToFrontendIPConfigurationStatusLoadBalancerSubResourceEmbedded(destination *v1alpha1api20201101storage.FrontendIPConfiguration_Status_LoadBalancer_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Etag
	if frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.Etag != nil {
		etag := *frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.Etag
		destination.Etag = &etag
	} else {
		destination.Etag = nil
	}

	// Id
	if frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.Id != nil {
		id := *frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.Id
		destination.Id = &id
	} else {
		destination.Id = nil
	}

	// InboundNatPools
	inboundNatPoolList := make([]v1alpha1api20201101storage.SubResource_Status, len(frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.InboundNatPools))
	for inboundNatPoolIndex, inboundNatPoolItem := range frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.InboundNatPools {
		// Shadow the loop variable to avoid aliasing
		inboundNatPoolItem := inboundNatPoolItem
		var inboundNatPool v1alpha1api20201101storage.SubResource_Status
		err := inboundNatPoolItem.AssignPropertiesToSubResourceStatus(&inboundNatPool)
		if err != nil {
			return errors.Wrap(err, "populating InboundNatPools from InboundNatPools, calling AssignPropertiesToSubResourceStatus()")
		}
		inboundNatPoolList[inboundNatPoolIndex] = inboundNatPool
	}
	destination.InboundNatPools = inboundNatPoolList

	// InboundNatRules
	inboundNatRuleList := make([]v1alpha1api20201101storage.SubResource_Status, len(frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.InboundNatRules))
	for inboundNatRuleIndex, inboundNatRuleItem := range frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.InboundNatRules {
		// Shadow the loop variable to avoid aliasing
		inboundNatRuleItem := inboundNatRuleItem
		var inboundNatRule v1alpha1api20201101storage.SubResource_Status
		err := inboundNatRuleItem.AssignPropertiesToSubResourceStatus(&inboundNatRule)
		if err != nil {
			return errors.Wrap(err, "populating InboundNatRules from InboundNatRules, calling AssignPropertiesToSubResourceStatus()")
		}
		inboundNatRuleList[inboundNatRuleIndex] = inboundNatRule
	}
	destination.InboundNatRules = inboundNatRuleList

	// LoadBalancingRules
	loadBalancingRuleList := make([]v1alpha1api20201101storage.SubResource_Status, len(frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.LoadBalancingRules))
	for loadBalancingRuleIndex, loadBalancingRuleItem := range frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.LoadBalancingRules {
		// Shadow the loop variable to avoid aliasing
		loadBalancingRuleItem := loadBalancingRuleItem
		var loadBalancingRule v1alpha1api20201101storage.SubResource_Status
		err := loadBalancingRuleItem.AssignPropertiesToSubResourceStatus(&loadBalancingRule)
		if err != nil {
			return errors.Wrap(err, "populating LoadBalancingRules from LoadBalancingRules, calling AssignPropertiesToSubResourceStatus()")
		}
		loadBalancingRuleList[loadBalancingRuleIndex] = loadBalancingRule
	}
	destination.LoadBalancingRules = loadBalancingRuleList

	// Name
	if frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.Name != nil {
		name := *frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.Name
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// OutboundRules
	outboundRuleList := make([]v1alpha1api20201101storage.SubResource_Status, len(frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.OutboundRules))
	for outboundRuleIndex, outboundRuleItem := range frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.OutboundRules {
		// Shadow the loop variable to avoid aliasing
		outboundRuleItem := outboundRuleItem
		var outboundRule v1alpha1api20201101storage.SubResource_Status
		err := outboundRuleItem.AssignPropertiesToSubResourceStatus(&outboundRule)
		if err != nil {
			return errors.Wrap(err, "populating OutboundRules from OutboundRules, calling AssignPropertiesToSubResourceStatus()")
		}
		outboundRuleList[outboundRuleIndex] = outboundRule
	}
	destination.OutboundRules = outboundRuleList

	// PrivateIPAddress
	if frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.PrivateIPAddress != nil {
		privateIPAddress := *frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.PrivateIPAddress
		destination.PrivateIPAddress = &privateIPAddress
	} else {
		destination.PrivateIPAddress = nil
	}

	// PrivateIPAddressVersion
	if frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := string(*frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.PrivateIPAddressVersion)
		destination.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		destination.PrivateIPAddressVersion = nil
	}

	// PrivateIPAllocationMethod
	if frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.PrivateIPAllocationMethod != nil {
		privateIPAllocationMethod := string(*frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.PrivateIPAllocationMethod)
		destination.PrivateIPAllocationMethod = &privateIPAllocationMethod
	} else {
		destination.PrivateIPAllocationMethod = nil
	}

	// ProvisioningState
	if frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.ProvisioningState != nil {
		provisioningState := string(*frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// PublicIPAddress
	if frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.PublicIPAddress != nil {
		var publicIPAddress v1alpha1api20201101storage.PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded
		err := (*frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.PublicIPAddress).AssignPropertiesToPublicIPAddressStatusLoadBalancerSubResourceEmbedded(&publicIPAddress)
		if err != nil {
			return errors.Wrap(err, "populating PublicIPAddress from PublicIPAddress, calling AssignPropertiesToPublicIPAddressStatusLoadBalancerSubResourceEmbedded()")
		}
		destination.PublicIPAddress = &publicIPAddress
	} else {
		destination.PublicIPAddress = nil
	}

	// PublicIPPrefix
	if frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.PublicIPPrefix != nil {
		var publicIPPrefix v1alpha1api20201101storage.SubResource_Status
		err := (*frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.PublicIPPrefix).AssignPropertiesToSubResourceStatus(&publicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "populating PublicIPPrefix from PublicIPPrefix, calling AssignPropertiesToSubResourceStatus()")
		}
		destination.PublicIPPrefix = &publicIPPrefix
	} else {
		destination.PublicIPPrefix = nil
	}

	// Subnet
	if frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.Subnet != nil {
		var subnet v1alpha1api20201101storage.Subnet_Status_LoadBalancer_SubResourceEmbedded
		err := (*frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.Subnet).AssignPropertiesToSubnetStatusLoadBalancerSubResourceEmbedded(&subnet)
		if err != nil {
			return errors.Wrap(err, "populating Subnet from Subnet, calling AssignPropertiesToSubnetStatusLoadBalancerSubResourceEmbedded()")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// Type
	if frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.Type != nil {
		typeVar := *frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.Type
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Zones
	zoneList := make([]string, len(frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.Zones))
	for zoneIndex, zoneItem := range frontendIPConfigurationStatusLoadBalancerSubResourceEmbedded.Zones {
		// Shadow the loop variable to avoid aliasing
		zoneItem := zoneItem
		zoneList[zoneIndex] = zoneItem
	}
	destination.Zones = zoneList

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type InboundNatPool_Status struct {
	//BackendPort: The port used for internal connections on the endpoint. Acceptable
	//values are between 1 and 65535.
	BackendPort *int `json:"backendPort,omitempty"`

	//EnableFloatingIP: Configures a virtual machine's endpoint for the floating IP
	//capability required to configure a SQL AlwaysOn Availability Group. This setting
	//is required when using the SQL AlwaysOn Availability Groups in SQL server. This
	//setting can't be changed after you create the endpoint.
	EnableFloatingIP *bool `json:"enableFloatingIP,omitempty"`

	//EnableTcpReset: Receive bidirectional TCP Reset on TCP flow idle timeout or
	//unexpected connection termination. This element is only used when the protocol
	//is set to TCP.
	EnableTcpReset *bool `json:"enableTcpReset,omitempty"`

	//Etag: A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	//FrontendIPConfiguration: A reference to frontend IP addresses.
	FrontendIPConfiguration *SubResource_Status `json:"frontendIPConfiguration,omitempty"`

	//FrontendPortRangeEnd: The last port number in the range of external ports that
	//will be used to provide Inbound Nat to NICs associated with a load balancer.
	//Acceptable values range between 1 and 65535.
	FrontendPortRangeEnd *int `json:"frontendPortRangeEnd,omitempty"`

	//FrontendPortRangeStart: The first port number in the range of external ports
	//that will be used to provide Inbound Nat to NICs associated with a load
	//balancer. Acceptable values range between 1 and 65534.
	FrontendPortRangeStart *int `json:"frontendPortRangeStart,omitempty"`

	//Id: Resource ID.
	Id *string `json:"id,omitempty"`

	//IdleTimeoutInMinutes: The timeout for the TCP idle connection. The value can be
	//set between 4 and 30 minutes. The default value is 4 minutes. This element is
	//only used when the protocol is set to TCP.
	IdleTimeoutInMinutes *int `json:"idleTimeoutInMinutes,omitempty"`

	//Name: The name of the resource that is unique within the set of inbound NAT
	//pools used by the load balancer. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`

	//Protocol: The reference to the transport protocol used by the inbound NAT pool.
	Protocol *TransportProtocol_Status `json:"protocol,omitempty"`

	//ProvisioningState: The provisioning state of the inbound NAT pool resource.
	ProvisioningState *ProvisioningState_Status `json:"provisioningState,omitempty"`

	//Type: Type of the resource.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &InboundNatPool_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (inboundNatPoolStatus *InboundNatPool_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &InboundNatPool_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (inboundNatPoolStatus *InboundNatPool_Status) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(InboundNatPool_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected InboundNatPool_StatusARM, got %T", armInput)
	}

	// Set property ‘BackendPort’:
	// copying flattened property:
	if typedInput.Properties != nil {
		inboundNatPoolStatus.BackendPort = &typedInput.Properties.BackendPort
	}

	// Set property ‘EnableFloatingIP’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableFloatingIP != nil {
			enableFloatingIP := *typedInput.Properties.EnableFloatingIP
			inboundNatPoolStatus.EnableFloatingIP = &enableFloatingIP
		}
	}

	// Set property ‘EnableTcpReset’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableTcpReset != nil {
			enableTcpReset := *typedInput.Properties.EnableTcpReset
			inboundNatPoolStatus.EnableTcpReset = &enableTcpReset
		}
	}

	// Set property ‘Etag’:
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		inboundNatPoolStatus.Etag = &etag
	}

	// Set property ‘FrontendIPConfiguration’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FrontendIPConfiguration != nil {
			var frontendIPConfiguration1 SubResource_Status
			err := frontendIPConfiguration1.PopulateFromARM(owner, *typedInput.Properties.FrontendIPConfiguration)
			if err != nil {
				return err
			}
			frontendIPConfiguration := frontendIPConfiguration1
			inboundNatPoolStatus.FrontendIPConfiguration = &frontendIPConfiguration
		}
	}

	// Set property ‘FrontendPortRangeEnd’:
	// copying flattened property:
	if typedInput.Properties != nil {
		inboundNatPoolStatus.FrontendPortRangeEnd = &typedInput.Properties.FrontendPortRangeEnd
	}

	// Set property ‘FrontendPortRangeStart’:
	// copying flattened property:
	if typedInput.Properties != nil {
		inboundNatPoolStatus.FrontendPortRangeStart = &typedInput.Properties.FrontendPortRangeStart
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		inboundNatPoolStatus.Id = &id
	}

	// Set property ‘IdleTimeoutInMinutes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdleTimeoutInMinutes != nil {
			idleTimeoutInMinutes := *typedInput.Properties.IdleTimeoutInMinutes
			inboundNatPoolStatus.IdleTimeoutInMinutes = &idleTimeoutInMinutes
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		inboundNatPoolStatus.Name = &name
	}

	// Set property ‘Protocol’:
	// copying flattened property:
	if typedInput.Properties != nil {
		inboundNatPoolStatus.Protocol = &typedInput.Properties.Protocol
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			inboundNatPoolStatus.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		inboundNatPoolStatus.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromInboundNatPoolStatus populates our InboundNatPool_Status from the provided source InboundNatPool_Status
func (inboundNatPoolStatus *InboundNatPool_Status) AssignPropertiesFromInboundNatPoolStatus(source *v1alpha1api20201101storage.InboundNatPool_Status) error {

	// BackendPort
	if source.BackendPort != nil {
		backendPort := *source.BackendPort
		inboundNatPoolStatus.BackendPort = &backendPort
	} else {
		inboundNatPoolStatus.BackendPort = nil
	}

	// EnableFloatingIP
	if source.EnableFloatingIP != nil {
		enableFloatingIP := *source.EnableFloatingIP
		inboundNatPoolStatus.EnableFloatingIP = &enableFloatingIP
	} else {
		inboundNatPoolStatus.EnableFloatingIP = nil
	}

	// EnableTcpReset
	if source.EnableTcpReset != nil {
		enableTcpReset := *source.EnableTcpReset
		inboundNatPoolStatus.EnableTcpReset = &enableTcpReset
	} else {
		inboundNatPoolStatus.EnableTcpReset = nil
	}

	// Etag
	if source.Etag != nil {
		etag := *source.Etag
		inboundNatPoolStatus.Etag = &etag
	} else {
		inboundNatPoolStatus.Etag = nil
	}

	// FrontendIPConfiguration
	if source.FrontendIPConfiguration != nil {
		var frontendIPConfiguration SubResource_Status
		err := frontendIPConfiguration.AssignPropertiesFromSubResourceStatus(source.FrontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "populating FrontendIPConfiguration from FrontendIPConfiguration, calling AssignPropertiesFromSubResourceStatus()")
		}
		inboundNatPoolStatus.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		inboundNatPoolStatus.FrontendIPConfiguration = nil
	}

	// FrontendPortRangeEnd
	if source.FrontendPortRangeEnd != nil {
		frontendPortRangeEnd := *source.FrontendPortRangeEnd
		inboundNatPoolStatus.FrontendPortRangeEnd = &frontendPortRangeEnd
	} else {
		inboundNatPoolStatus.FrontendPortRangeEnd = nil
	}

	// FrontendPortRangeStart
	if source.FrontendPortRangeStart != nil {
		frontendPortRangeStart := *source.FrontendPortRangeStart
		inboundNatPoolStatus.FrontendPortRangeStart = &frontendPortRangeStart
	} else {
		inboundNatPoolStatus.FrontendPortRangeStart = nil
	}

	// Id
	if source.Id != nil {
		id := *source.Id
		inboundNatPoolStatus.Id = &id
	} else {
		inboundNatPoolStatus.Id = nil
	}

	// IdleTimeoutInMinutes
	if source.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinute := *source.IdleTimeoutInMinutes
		inboundNatPoolStatus.IdleTimeoutInMinutes = &idleTimeoutInMinute
	} else {
		inboundNatPoolStatus.IdleTimeoutInMinutes = nil
	}

	// Name
	if source.Name != nil {
		name := *source.Name
		inboundNatPoolStatus.Name = &name
	} else {
		inboundNatPoolStatus.Name = nil
	}

	// Protocol
	if source.Protocol != nil {
		protocol := TransportProtocol_Status(*source.Protocol)
		inboundNatPoolStatus.Protocol = &protocol
	} else {
		inboundNatPoolStatus.Protocol = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ProvisioningState_Status(*source.ProvisioningState)
		inboundNatPoolStatus.ProvisioningState = &provisioningState
	} else {
		inboundNatPoolStatus.ProvisioningState = nil
	}

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		inboundNatPoolStatus.Type = &typeVar
	} else {
		inboundNatPoolStatus.Type = nil
	}

	// No error
	return nil
}

// AssignPropertiesToInboundNatPoolStatus populates the provided destination InboundNatPool_Status from our InboundNatPool_Status
func (inboundNatPoolStatus *InboundNatPool_Status) AssignPropertiesToInboundNatPoolStatus(destination *v1alpha1api20201101storage.InboundNatPool_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackendPort
	if inboundNatPoolStatus.BackendPort != nil {
		backendPort := *inboundNatPoolStatus.BackendPort
		destination.BackendPort = &backendPort
	} else {
		destination.BackendPort = nil
	}

	// EnableFloatingIP
	if inboundNatPoolStatus.EnableFloatingIP != nil {
		enableFloatingIP := *inboundNatPoolStatus.EnableFloatingIP
		destination.EnableFloatingIP = &enableFloatingIP
	} else {
		destination.EnableFloatingIP = nil
	}

	// EnableTcpReset
	if inboundNatPoolStatus.EnableTcpReset != nil {
		enableTcpReset := *inboundNatPoolStatus.EnableTcpReset
		destination.EnableTcpReset = &enableTcpReset
	} else {
		destination.EnableTcpReset = nil
	}

	// Etag
	if inboundNatPoolStatus.Etag != nil {
		etag := *inboundNatPoolStatus.Etag
		destination.Etag = &etag
	} else {
		destination.Etag = nil
	}

	// FrontendIPConfiguration
	if inboundNatPoolStatus.FrontendIPConfiguration != nil {
		var frontendIPConfiguration v1alpha1api20201101storage.SubResource_Status
		err := (*inboundNatPoolStatus.FrontendIPConfiguration).AssignPropertiesToSubResourceStatus(&frontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "populating FrontendIPConfiguration from FrontendIPConfiguration, calling AssignPropertiesToSubResourceStatus()")
		}
		destination.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		destination.FrontendIPConfiguration = nil
	}

	// FrontendPortRangeEnd
	if inboundNatPoolStatus.FrontendPortRangeEnd != nil {
		frontendPortRangeEnd := *inboundNatPoolStatus.FrontendPortRangeEnd
		destination.FrontendPortRangeEnd = &frontendPortRangeEnd
	} else {
		destination.FrontendPortRangeEnd = nil
	}

	// FrontendPortRangeStart
	if inboundNatPoolStatus.FrontendPortRangeStart != nil {
		frontendPortRangeStart := *inboundNatPoolStatus.FrontendPortRangeStart
		destination.FrontendPortRangeStart = &frontendPortRangeStart
	} else {
		destination.FrontendPortRangeStart = nil
	}

	// Id
	if inboundNatPoolStatus.Id != nil {
		id := *inboundNatPoolStatus.Id
		destination.Id = &id
	} else {
		destination.Id = nil
	}

	// IdleTimeoutInMinutes
	if inboundNatPoolStatus.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinute := *inboundNatPoolStatus.IdleTimeoutInMinutes
		destination.IdleTimeoutInMinutes = &idleTimeoutInMinute
	} else {
		destination.IdleTimeoutInMinutes = nil
	}

	// Name
	if inboundNatPoolStatus.Name != nil {
		name := *inboundNatPoolStatus.Name
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Protocol
	if inboundNatPoolStatus.Protocol != nil {
		protocol := string(*inboundNatPoolStatus.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// ProvisioningState
	if inboundNatPoolStatus.ProvisioningState != nil {
		provisioningState := string(*inboundNatPoolStatus.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// Type
	if inboundNatPoolStatus.Type != nil {
		typeVar := *inboundNatPoolStatus.Type
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type InboundNatRule_Status_LoadBalancer_SubResourceEmbedded struct {
	//Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &InboundNatRule_Status_LoadBalancer_SubResourceEmbedded{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (inboundNatRuleStatusLoadBalancerSubResourceEmbedded *InboundNatRule_Status_LoadBalancer_SubResourceEmbedded) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &InboundNatRule_Status_LoadBalancer_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (inboundNatRuleStatusLoadBalancerSubResourceEmbedded *InboundNatRule_Status_LoadBalancer_SubResourceEmbedded) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(InboundNatRule_Status_LoadBalancer_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected InboundNatRule_Status_LoadBalancer_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		inboundNatRuleStatusLoadBalancerSubResourceEmbedded.Id = &id
	}

	// No error
	return nil
}

// AssignPropertiesFromInboundNatRuleStatusLoadBalancerSubResourceEmbedded populates our InboundNatRule_Status_LoadBalancer_SubResourceEmbedded from the provided source InboundNatRule_Status_LoadBalancer_SubResourceEmbedded
func (inboundNatRuleStatusLoadBalancerSubResourceEmbedded *InboundNatRule_Status_LoadBalancer_SubResourceEmbedded) AssignPropertiesFromInboundNatRuleStatusLoadBalancerSubResourceEmbedded(source *v1alpha1api20201101storage.InboundNatRule_Status_LoadBalancer_SubResourceEmbedded) error {

	// Id
	if source.Id != nil {
		id := *source.Id
		inboundNatRuleStatusLoadBalancerSubResourceEmbedded.Id = &id
	} else {
		inboundNatRuleStatusLoadBalancerSubResourceEmbedded.Id = nil
	}

	// No error
	return nil
}

// AssignPropertiesToInboundNatRuleStatusLoadBalancerSubResourceEmbedded populates the provided destination InboundNatRule_Status_LoadBalancer_SubResourceEmbedded from our InboundNatRule_Status_LoadBalancer_SubResourceEmbedded
func (inboundNatRuleStatusLoadBalancerSubResourceEmbedded *InboundNatRule_Status_LoadBalancer_SubResourceEmbedded) AssignPropertiesToInboundNatRuleStatusLoadBalancerSubResourceEmbedded(destination *v1alpha1api20201101storage.InboundNatRule_Status_LoadBalancer_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	if inboundNatRuleStatusLoadBalancerSubResourceEmbedded.Id != nil {
		id := *inboundNatRuleStatusLoadBalancerSubResourceEmbedded.Id
		destination.Id = &id
	} else {
		destination.Id = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-11-01/Microsoft.Network.json#/definitions/LoadBalancerSku
type LoadBalancerSku struct {
	//Name: Name of a load balancer SKU.
	Name *LoadBalancerSkuName `json:"name,omitempty"`

	//Tier: Tier of a load balancer SKU.
	Tier *LoadBalancerSkuTier `json:"tier,omitempty"`
}

var _ genruntime.ARMTransformer = &LoadBalancerSku{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (loadBalancerSku *LoadBalancerSku) ConvertToARM(name string, resolvedReferences genruntime.ResolvedReferences) (interface{}, error) {
	if loadBalancerSku == nil {
		return nil, nil
	}
	var result LoadBalancerSkuARM

	// Set property ‘Name’:
	if loadBalancerSku.Name != nil {
		name := *loadBalancerSku.Name
		result.Name = &name
	}

	// Set property ‘Tier’:
	if loadBalancerSku.Tier != nil {
		tier := *loadBalancerSku.Tier
		result.Tier = &tier
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (loadBalancerSku *LoadBalancerSku) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &LoadBalancerSkuARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (loadBalancerSku *LoadBalancerSku) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(LoadBalancerSkuARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LoadBalancerSkuARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		loadBalancerSku.Name = &name
	}

	// Set property ‘Tier’:
	if typedInput.Tier != nil {
		tier := *typedInput.Tier
		loadBalancerSku.Tier = &tier
	}

	// No error
	return nil
}

// AssignPropertiesFromLoadBalancerSku populates our LoadBalancerSku from the provided source LoadBalancerSku
func (loadBalancerSku *LoadBalancerSku) AssignPropertiesFromLoadBalancerSku(source *v1alpha1api20201101storage.LoadBalancerSku) error {

	// Name
	if source.Name != nil {
		name := LoadBalancerSkuName(*source.Name)
		loadBalancerSku.Name = &name
	} else {
		loadBalancerSku.Name = nil
	}

	// Tier
	if source.Tier != nil {
		tier := LoadBalancerSkuTier(*source.Tier)
		loadBalancerSku.Tier = &tier
	} else {
		loadBalancerSku.Tier = nil
	}

	// No error
	return nil
}

// AssignPropertiesToLoadBalancerSku populates the provided destination LoadBalancerSku from our LoadBalancerSku
func (loadBalancerSku *LoadBalancerSku) AssignPropertiesToLoadBalancerSku(destination *v1alpha1api20201101storage.LoadBalancerSku) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if loadBalancerSku.Name != nil {
		name := string(*loadBalancerSku.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Tier
	if loadBalancerSku.Tier != nil {
		tier := string(*loadBalancerSku.Tier)
		destination.Tier = &tier
	} else {
		destination.Tier = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type LoadBalancerSku_Status struct {
	//Name: Name of a load balancer SKU.
	Name *LoadBalancerSkuStatusName `json:"name,omitempty"`

	//Tier: Tier of a load balancer SKU.
	Tier *LoadBalancerSkuStatusTier `json:"tier,omitempty"`
}

var _ genruntime.FromARMConverter = &LoadBalancerSku_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (loadBalancerSkuStatus *LoadBalancerSku_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &LoadBalancerSku_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (loadBalancerSkuStatus *LoadBalancerSku_Status) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(LoadBalancerSku_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LoadBalancerSku_StatusARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		loadBalancerSkuStatus.Name = &name
	}

	// Set property ‘Tier’:
	if typedInput.Tier != nil {
		tier := *typedInput.Tier
		loadBalancerSkuStatus.Tier = &tier
	}

	// No error
	return nil
}

// AssignPropertiesFromLoadBalancerSkuStatus populates our LoadBalancerSku_Status from the provided source LoadBalancerSku_Status
func (loadBalancerSkuStatus *LoadBalancerSku_Status) AssignPropertiesFromLoadBalancerSkuStatus(source *v1alpha1api20201101storage.LoadBalancerSku_Status) error {

	// Name
	if source.Name != nil {
		name := LoadBalancerSkuStatusName(*source.Name)
		loadBalancerSkuStatus.Name = &name
	} else {
		loadBalancerSkuStatus.Name = nil
	}

	// Tier
	if source.Tier != nil {
		tier := LoadBalancerSkuStatusTier(*source.Tier)
		loadBalancerSkuStatus.Tier = &tier
	} else {
		loadBalancerSkuStatus.Tier = nil
	}

	// No error
	return nil
}

// AssignPropertiesToLoadBalancerSkuStatus populates the provided destination LoadBalancerSku_Status from our LoadBalancerSku_Status
func (loadBalancerSkuStatus *LoadBalancerSku_Status) AssignPropertiesToLoadBalancerSkuStatus(destination *v1alpha1api20201101storage.LoadBalancerSku_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if loadBalancerSkuStatus.Name != nil {
		name := string(*loadBalancerSkuStatus.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Tier
	if loadBalancerSkuStatus.Tier != nil {
		tier := string(*loadBalancerSkuStatus.Tier)
		destination.Tier = &tier
	} else {
		destination.Tier = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

type LoadBalancers_Spec_Properties_BackendAddressPools struct {
	//LoadBalancerBackendAddresses: An array of backend addresses.
	LoadBalancerBackendAddresses []LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses `json:"loadBalancerBackendAddresses,omitempty"`

	//Location: The location of the backend address pool.
	Location *string `json:"location,omitempty"`

	// +kubebuilder:validation:Required
	//Name: The name of the resource that is unique within the set of backend address
	//pools used by the load balancer. This name can be used to access the resource.
	Name string `json:"name"`
}

var _ genruntime.ARMTransformer = &LoadBalancers_Spec_Properties_BackendAddressPools{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (loadBalancersSpecPropertiesBackendAddressPools *LoadBalancers_Spec_Properties_BackendAddressPools) ConvertToARM(name string, resolvedReferences genruntime.ResolvedReferences) (interface{}, error) {
	if loadBalancersSpecPropertiesBackendAddressPools == nil {
		return nil, nil
	}
	var result LoadBalancers_Spec_Properties_BackendAddressPoolsARM

	// Set property ‘Name’:
	result.Name = loadBalancersSpecPropertiesBackendAddressPools.Name

	// Set property ‘Properties’:
	if loadBalancersSpecPropertiesBackendAddressPools.LoadBalancerBackendAddresses != nil || loadBalancersSpecPropertiesBackendAddressPools.Location != nil {
		result.Properties = &LoadBalancers_Spec_Properties_BackendAddressPools_PropertiesARM{}
	}
	for _, item := range loadBalancersSpecPropertiesBackendAddressPools.LoadBalancerBackendAddresses {
		itemARM, err := item.ConvertToARM(name, resolvedReferences)
		if err != nil {
			return nil, err
		}
		result.Properties.LoadBalancerBackendAddresses = append(result.Properties.LoadBalancerBackendAddresses, itemARM.(LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARM))
	}
	if loadBalancersSpecPropertiesBackendAddressPools.Location != nil {
		location := *loadBalancersSpecPropertiesBackendAddressPools.Location
		result.Properties.Location = &location
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (loadBalancersSpecPropertiesBackendAddressPools *LoadBalancers_Spec_Properties_BackendAddressPools) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &LoadBalancers_Spec_Properties_BackendAddressPoolsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (loadBalancersSpecPropertiesBackendAddressPools *LoadBalancers_Spec_Properties_BackendAddressPools) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(LoadBalancers_Spec_Properties_BackendAddressPoolsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LoadBalancers_Spec_Properties_BackendAddressPoolsARM, got %T", armInput)
	}

	// Set property ‘LoadBalancerBackendAddresses’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancerBackendAddresses {
			var item1 LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			loadBalancersSpecPropertiesBackendAddressPools.LoadBalancerBackendAddresses = append(loadBalancersSpecPropertiesBackendAddressPools.LoadBalancerBackendAddresses, item1)
		}
	}

	// Set property ‘Location’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Location != nil {
			location := *typedInput.Properties.Location
			loadBalancersSpecPropertiesBackendAddressPools.Location = &location
		}
	}

	// Set property ‘Name’:
	loadBalancersSpecPropertiesBackendAddressPools.Name = typedInput.Name

	// No error
	return nil
}

// AssignPropertiesFromLoadBalancersSpecPropertiesBackendAddressPools populates our LoadBalancers_Spec_Properties_BackendAddressPools from the provided source LoadBalancers_Spec_Properties_BackendAddressPools
func (loadBalancersSpecPropertiesBackendAddressPools *LoadBalancers_Spec_Properties_BackendAddressPools) AssignPropertiesFromLoadBalancersSpecPropertiesBackendAddressPools(source *v1alpha1api20201101storage.LoadBalancers_Spec_Properties_BackendAddressPools) error {

	// LoadBalancerBackendAddresses
	loadBalancerBackendAddressList := make([]LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses, len(source.LoadBalancerBackendAddresses))
	for loadBalancerBackendAddressIndex, loadBalancerBackendAddressItem := range source.LoadBalancerBackendAddresses {
		// Shadow the loop variable to avoid aliasing
		loadBalancerBackendAddressItem := loadBalancerBackendAddressItem
		var loadBalancerBackendAddress LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses
		err := loadBalancerBackendAddress.AssignPropertiesFromLoadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses(&loadBalancerBackendAddressItem)
		if err != nil {
			return errors.Wrap(err, "populating LoadBalancerBackendAddresses from LoadBalancerBackendAddresses, calling AssignPropertiesFromLoadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses()")
		}
		loadBalancerBackendAddressList[loadBalancerBackendAddressIndex] = loadBalancerBackendAddress
	}
	loadBalancersSpecPropertiesBackendAddressPools.LoadBalancerBackendAddresses = loadBalancerBackendAddressList

	// Location
	if source.Location != nil {
		location := *source.Location
		loadBalancersSpecPropertiesBackendAddressPools.Location = &location
	} else {
		loadBalancersSpecPropertiesBackendAddressPools.Location = nil
	}

	// Name
	if source.Name != nil {
		loadBalancersSpecPropertiesBackendAddressPools.Name = *source.Name
	} else {
		loadBalancersSpecPropertiesBackendAddressPools.Name = ""
	}

	// No error
	return nil
}

// AssignPropertiesToLoadBalancersSpecPropertiesBackendAddressPools populates the provided destination LoadBalancers_Spec_Properties_BackendAddressPools from our LoadBalancers_Spec_Properties_BackendAddressPools
func (loadBalancersSpecPropertiesBackendAddressPools *LoadBalancers_Spec_Properties_BackendAddressPools) AssignPropertiesToLoadBalancersSpecPropertiesBackendAddressPools(destination *v1alpha1api20201101storage.LoadBalancers_Spec_Properties_BackendAddressPools) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// LoadBalancerBackendAddresses
	loadBalancerBackendAddressList := make([]v1alpha1api20201101storage.LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses, len(loadBalancersSpecPropertiesBackendAddressPools.LoadBalancerBackendAddresses))
	for loadBalancerBackendAddressIndex, loadBalancerBackendAddressItem := range loadBalancersSpecPropertiesBackendAddressPools.LoadBalancerBackendAddresses {
		// Shadow the loop variable to avoid aliasing
		loadBalancerBackendAddressItem := loadBalancerBackendAddressItem
		var loadBalancerBackendAddress v1alpha1api20201101storage.LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses
		err := loadBalancerBackendAddressItem.AssignPropertiesToLoadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses(&loadBalancerBackendAddress)
		if err != nil {
			return errors.Wrap(err, "populating LoadBalancerBackendAddresses from LoadBalancerBackendAddresses, calling AssignPropertiesToLoadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses()")
		}
		loadBalancerBackendAddressList[loadBalancerBackendAddressIndex] = loadBalancerBackendAddress
	}
	destination.LoadBalancerBackendAddresses = loadBalancerBackendAddressList

	// Location
	if loadBalancersSpecPropertiesBackendAddressPools.Location != nil {
		location := *loadBalancersSpecPropertiesBackendAddressPools.Location
		destination.Location = &location
	} else {
		destination.Location = nil
	}

	// Name
	name := loadBalancersSpecPropertiesBackendAddressPools.Name
	destination.Name = &name

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

type LoadBalancers_Spec_Properties_FrontendIPConfigurations struct {
	// +kubebuilder:validation:Required
	//Name: The name of the resource that is unique within the set of frontend IP
	//configurations used by the load balancer. This name can be used to access the
	//resource.
	Name string `json:"name"`

	//PrivateIPAddress: The private IP address of the IP configuration.
	PrivateIPAddress *string `json:"privateIPAddress,omitempty"`

	//PrivateIPAddressVersion: Whether the specific ipconfiguration is IPv4 or IPv6.
	//Default is taken as IPv4.
	PrivateIPAddressVersion *FrontendIPConfigurationPropertiesFormatPrivateIPAddressVersion `json:"privateIPAddressVersion,omitempty"`

	//PrivateIPAllocationMethod: The Private IP allocation method.
	PrivateIPAllocationMethod *FrontendIPConfigurationPropertiesFormatPrivateIPAllocationMethod `json:"privateIPAllocationMethod,omitempty"`

	//PublicIPAddress: The reference to the Public IP resource.
	PublicIPAddress *SubResource `json:"publicIPAddress,omitempty"`

	//PublicIPPrefix: The reference to the Public IP Prefix resource.
	PublicIPPrefix *SubResource `json:"publicIPPrefix,omitempty"`

	//Subnet: The reference to the subnet resource.
	Subnet *SubResource `json:"subnet,omitempty"`

	//Zones: A list of availability zones denoting the IP allocated for the resource
	//needs to come from.
	Zones []string `json:"zones,omitempty"`
}

var _ genruntime.ARMTransformer = &LoadBalancers_Spec_Properties_FrontendIPConfigurations{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (loadBalancersSpecPropertiesFrontendIPConfigurations *LoadBalancers_Spec_Properties_FrontendIPConfigurations) ConvertToARM(name string, resolvedReferences genruntime.ResolvedReferences) (interface{}, error) {
	if loadBalancersSpecPropertiesFrontendIPConfigurations == nil {
		return nil, nil
	}
	var result LoadBalancers_Spec_Properties_FrontendIPConfigurationsARM

	// Set property ‘Name’:
	result.Name = loadBalancersSpecPropertiesFrontendIPConfigurations.Name

	// Set property ‘Properties’:
	if loadBalancersSpecPropertiesFrontendIPConfigurations.PrivateIPAddress != nil || loadBalancersSpecPropertiesFrontendIPConfigurations.PrivateIPAddressVersion != nil || loadBalancersSpecPropertiesFrontendIPConfigurations.PrivateIPAllocationMethod != nil || loadBalancersSpecPropertiesFrontendIPConfigurations.PublicIPAddress != nil || loadBalancersSpecPropertiesFrontendIPConfigurations.PublicIPPrefix != nil || loadBalancersSpecPropertiesFrontendIPConfigurations.Subnet != nil {
		result.Properties = &FrontendIPConfigurationPropertiesFormatARM{}
	}
	if loadBalancersSpecPropertiesFrontendIPConfigurations.PrivateIPAddress != nil {
		privateIPAddress := *loadBalancersSpecPropertiesFrontendIPConfigurations.PrivateIPAddress
		result.Properties.PrivateIPAddress = &privateIPAddress
	}
	if loadBalancersSpecPropertiesFrontendIPConfigurations.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := *loadBalancersSpecPropertiesFrontendIPConfigurations.PrivateIPAddressVersion
		result.Properties.PrivateIPAddressVersion = &privateIPAddressVersion
	}
	if loadBalancersSpecPropertiesFrontendIPConfigurations.PrivateIPAllocationMethod != nil {
		privateIPAllocationMethod := *loadBalancersSpecPropertiesFrontendIPConfigurations.PrivateIPAllocationMethod
		result.Properties.PrivateIPAllocationMethod = &privateIPAllocationMethod
	}
	if loadBalancersSpecPropertiesFrontendIPConfigurations.PublicIPAddress != nil {
		publicIPAddressARM, err := (*loadBalancersSpecPropertiesFrontendIPConfigurations.PublicIPAddress).ConvertToARM(name, resolvedReferences)
		if err != nil {
			return nil, err
		}
		publicIPAddress := publicIPAddressARM.(SubResourceARM)
		result.Properties.PublicIPAddress = &publicIPAddress
	}
	if loadBalancersSpecPropertiesFrontendIPConfigurations.PublicIPPrefix != nil {
		publicIPPrefixARM, err := (*loadBalancersSpecPropertiesFrontendIPConfigurations.PublicIPPrefix).ConvertToARM(name, resolvedReferences)
		if err != nil {
			return nil, err
		}
		publicIPPrefix := publicIPPrefixARM.(SubResourceARM)
		result.Properties.PublicIPPrefix = &publicIPPrefix
	}
	if loadBalancersSpecPropertiesFrontendIPConfigurations.Subnet != nil {
		subnetARM, err := (*loadBalancersSpecPropertiesFrontendIPConfigurations.Subnet).ConvertToARM(name, resolvedReferences)
		if err != nil {
			return nil, err
		}
		subnet := subnetARM.(SubResourceARM)
		result.Properties.Subnet = &subnet
	}

	// Set property ‘Zones’:
	for _, item := range loadBalancersSpecPropertiesFrontendIPConfigurations.Zones {
		result.Zones = append(result.Zones, item)
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (loadBalancersSpecPropertiesFrontendIPConfigurations *LoadBalancers_Spec_Properties_FrontendIPConfigurations) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &LoadBalancers_Spec_Properties_FrontendIPConfigurationsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (loadBalancersSpecPropertiesFrontendIPConfigurations *LoadBalancers_Spec_Properties_FrontendIPConfigurations) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(LoadBalancers_Spec_Properties_FrontendIPConfigurationsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LoadBalancers_Spec_Properties_FrontendIPConfigurationsARM, got %T", armInput)
	}

	// Set property ‘Name’:
	loadBalancersSpecPropertiesFrontendIPConfigurations.Name = typedInput.Name

	// Set property ‘PrivateIPAddress’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAddress != nil {
			privateIPAddress := *typedInput.Properties.PrivateIPAddress
			loadBalancersSpecPropertiesFrontendIPConfigurations.PrivateIPAddress = &privateIPAddress
		}
	}

	// Set property ‘PrivateIPAddressVersion’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAddressVersion != nil {
			privateIPAddressVersion := *typedInput.Properties.PrivateIPAddressVersion
			loadBalancersSpecPropertiesFrontendIPConfigurations.PrivateIPAddressVersion = &privateIPAddressVersion
		}
	}

	// Set property ‘PrivateIPAllocationMethod’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAllocationMethod != nil {
			privateIPAllocationMethod := *typedInput.Properties.PrivateIPAllocationMethod
			loadBalancersSpecPropertiesFrontendIPConfigurations.PrivateIPAllocationMethod = &privateIPAllocationMethod
		}
	}

	// Set property ‘PublicIPAddress’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPAddress != nil {
			var publicIPAddress1 SubResource
			err := publicIPAddress1.PopulateFromARM(owner, *typedInput.Properties.PublicIPAddress)
			if err != nil {
				return err
			}
			publicIPAddress := publicIPAddress1
			loadBalancersSpecPropertiesFrontendIPConfigurations.PublicIPAddress = &publicIPAddress
		}
	}

	// Set property ‘PublicIPPrefix’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPPrefix != nil {
			var publicIPPrefix1 SubResource
			err := publicIPPrefix1.PopulateFromARM(owner, *typedInput.Properties.PublicIPPrefix)
			if err != nil {
				return err
			}
			publicIPPrefix := publicIPPrefix1
			loadBalancersSpecPropertiesFrontendIPConfigurations.PublicIPPrefix = &publicIPPrefix
		}
	}

	// Set property ‘Subnet’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Subnet != nil {
			var subnet1 SubResource
			err := subnet1.PopulateFromARM(owner, *typedInput.Properties.Subnet)
			if err != nil {
				return err
			}
			subnet := subnet1
			loadBalancersSpecPropertiesFrontendIPConfigurations.Subnet = &subnet
		}
	}

	// Set property ‘Zones’:
	for _, item := range typedInput.Zones {
		loadBalancersSpecPropertiesFrontendIPConfigurations.Zones = append(loadBalancersSpecPropertiesFrontendIPConfigurations.Zones, item)
	}

	// No error
	return nil
}

// AssignPropertiesFromLoadBalancersSpecPropertiesFrontendIPConfigurations populates our LoadBalancers_Spec_Properties_FrontendIPConfigurations from the provided source LoadBalancers_Spec_Properties_FrontendIPConfigurations
func (loadBalancersSpecPropertiesFrontendIPConfigurations *LoadBalancers_Spec_Properties_FrontendIPConfigurations) AssignPropertiesFromLoadBalancersSpecPropertiesFrontendIPConfigurations(source *v1alpha1api20201101storage.LoadBalancers_Spec_Properties_FrontendIPConfigurations) error {

	// Name
	if source.Name != nil {
		loadBalancersSpecPropertiesFrontendIPConfigurations.Name = *source.Name
	} else {
		loadBalancersSpecPropertiesFrontendIPConfigurations.Name = ""
	}

	// PrivateIPAddress
	if source.PrivateIPAddress != nil {
		privateIPAddress := *source.PrivateIPAddress
		loadBalancersSpecPropertiesFrontendIPConfigurations.PrivateIPAddress = &privateIPAddress
	} else {
		loadBalancersSpecPropertiesFrontendIPConfigurations.PrivateIPAddress = nil
	}

	// PrivateIPAddressVersion
	if source.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := FrontendIPConfigurationPropertiesFormatPrivateIPAddressVersion(*source.PrivateIPAddressVersion)
		loadBalancersSpecPropertiesFrontendIPConfigurations.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		loadBalancersSpecPropertiesFrontendIPConfigurations.PrivateIPAddressVersion = nil
	}

	// PrivateIPAllocationMethod
	if source.PrivateIPAllocationMethod != nil {
		privateIPAllocationMethod := FrontendIPConfigurationPropertiesFormatPrivateIPAllocationMethod(*source.PrivateIPAllocationMethod)
		loadBalancersSpecPropertiesFrontendIPConfigurations.PrivateIPAllocationMethod = &privateIPAllocationMethod
	} else {
		loadBalancersSpecPropertiesFrontendIPConfigurations.PrivateIPAllocationMethod = nil
	}

	// PublicIPAddress
	if source.PublicIPAddress != nil {
		var publicIPAddress SubResource
		err := publicIPAddress.AssignPropertiesFromSubResource(source.PublicIPAddress)
		if err != nil {
			return errors.Wrap(err, "populating PublicIPAddress from PublicIPAddress, calling AssignPropertiesFromSubResource()")
		}
		loadBalancersSpecPropertiesFrontendIPConfigurations.PublicIPAddress = &publicIPAddress
	} else {
		loadBalancersSpecPropertiesFrontendIPConfigurations.PublicIPAddress = nil
	}

	// PublicIPPrefix
	if source.PublicIPPrefix != nil {
		var publicIPPrefix SubResource
		err := publicIPPrefix.AssignPropertiesFromSubResource(source.PublicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "populating PublicIPPrefix from PublicIPPrefix, calling AssignPropertiesFromSubResource()")
		}
		loadBalancersSpecPropertiesFrontendIPConfigurations.PublicIPPrefix = &publicIPPrefix
	} else {
		loadBalancersSpecPropertiesFrontendIPConfigurations.PublicIPPrefix = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet SubResource
		err := subnet.AssignPropertiesFromSubResource(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "populating Subnet from Subnet, calling AssignPropertiesFromSubResource()")
		}
		loadBalancersSpecPropertiesFrontendIPConfigurations.Subnet = &subnet
	} else {
		loadBalancersSpecPropertiesFrontendIPConfigurations.Subnet = nil
	}

	// Zones
	zoneList := make([]string, len(source.Zones))
	for zoneIndex, zoneItem := range source.Zones {
		// Shadow the loop variable to avoid aliasing
		zoneItem := zoneItem
		zoneList[zoneIndex] = zoneItem
	}
	loadBalancersSpecPropertiesFrontendIPConfigurations.Zones = zoneList

	// No error
	return nil
}

// AssignPropertiesToLoadBalancersSpecPropertiesFrontendIPConfigurations populates the provided destination LoadBalancers_Spec_Properties_FrontendIPConfigurations from our LoadBalancers_Spec_Properties_FrontendIPConfigurations
func (loadBalancersSpecPropertiesFrontendIPConfigurations *LoadBalancers_Spec_Properties_FrontendIPConfigurations) AssignPropertiesToLoadBalancersSpecPropertiesFrontendIPConfigurations(destination *v1alpha1api20201101storage.LoadBalancers_Spec_Properties_FrontendIPConfigurations) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	name := loadBalancersSpecPropertiesFrontendIPConfigurations.Name
	destination.Name = &name

	// PrivateIPAddress
	if loadBalancersSpecPropertiesFrontendIPConfigurations.PrivateIPAddress != nil {
		privateIPAddress := *loadBalancersSpecPropertiesFrontendIPConfigurations.PrivateIPAddress
		destination.PrivateIPAddress = &privateIPAddress
	} else {
		destination.PrivateIPAddress = nil
	}

	// PrivateIPAddressVersion
	if loadBalancersSpecPropertiesFrontendIPConfigurations.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := string(*loadBalancersSpecPropertiesFrontendIPConfigurations.PrivateIPAddressVersion)
		destination.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		destination.PrivateIPAddressVersion = nil
	}

	// PrivateIPAllocationMethod
	if loadBalancersSpecPropertiesFrontendIPConfigurations.PrivateIPAllocationMethod != nil {
		privateIPAllocationMethod := string(*loadBalancersSpecPropertiesFrontendIPConfigurations.PrivateIPAllocationMethod)
		destination.PrivateIPAllocationMethod = &privateIPAllocationMethod
	} else {
		destination.PrivateIPAllocationMethod = nil
	}

	// PublicIPAddress
	if loadBalancersSpecPropertiesFrontendIPConfigurations.PublicIPAddress != nil {
		var publicIPAddress v1alpha1api20201101storage.SubResource
		err := (*loadBalancersSpecPropertiesFrontendIPConfigurations.PublicIPAddress).AssignPropertiesToSubResource(&publicIPAddress)
		if err != nil {
			return errors.Wrap(err, "populating PublicIPAddress from PublicIPAddress, calling AssignPropertiesToSubResource()")
		}
		destination.PublicIPAddress = &publicIPAddress
	} else {
		destination.PublicIPAddress = nil
	}

	// PublicIPPrefix
	if loadBalancersSpecPropertiesFrontendIPConfigurations.PublicIPPrefix != nil {
		var publicIPPrefix v1alpha1api20201101storage.SubResource
		err := (*loadBalancersSpecPropertiesFrontendIPConfigurations.PublicIPPrefix).AssignPropertiesToSubResource(&publicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "populating PublicIPPrefix from PublicIPPrefix, calling AssignPropertiesToSubResource()")
		}
		destination.PublicIPPrefix = &publicIPPrefix
	} else {
		destination.PublicIPPrefix = nil
	}

	// Subnet
	if loadBalancersSpecPropertiesFrontendIPConfigurations.Subnet != nil {
		var subnet v1alpha1api20201101storage.SubResource
		err := (*loadBalancersSpecPropertiesFrontendIPConfigurations.Subnet).AssignPropertiesToSubResource(&subnet)
		if err != nil {
			return errors.Wrap(err, "populating Subnet from Subnet, calling AssignPropertiesToSubResource()")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// Zones
	zoneList := make([]string, len(loadBalancersSpecPropertiesFrontendIPConfigurations.Zones))
	for zoneIndex, zoneItem := range loadBalancersSpecPropertiesFrontendIPConfigurations.Zones {
		// Shadow the loop variable to avoid aliasing
		zoneItem := zoneItem
		zoneList[zoneIndex] = zoneItem
	}
	destination.Zones = zoneList

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

type LoadBalancers_Spec_Properties_InboundNatPools struct {
	//BackendPort: The port used for internal connections on the endpoint. Acceptable
	//values are between 1 and 65535.
	BackendPort *int `json:"backendPort,omitempty"`

	//EnableFloatingIP: Configures a virtual machine's endpoint for the floating IP
	//capability required to configure a SQL AlwaysOn Availability Group. This setting
	//is required when using the SQL AlwaysOn Availability Groups in SQL server. This
	//setting can't be changed after you create the endpoint.
	EnableFloatingIP *bool `json:"enableFloatingIP,omitempty"`

	//EnableTcpReset: Receive bidirectional TCP Reset on TCP flow idle timeout or
	//unexpected connection termination. This element is only used when the protocol
	//is set to TCP.
	EnableTcpReset *bool `json:"enableTcpReset,omitempty"`

	//FrontendIPConfiguration: A reference to frontend IP addresses.
	FrontendIPConfiguration *SubResource `json:"frontendIPConfiguration,omitempty"`

	//FrontendPortRangeEnd: The last port number in the range of external ports that
	//will be used to provide Inbound Nat to NICs associated with a load balancer.
	//Acceptable values range between 1 and 65535.
	FrontendPortRangeEnd *int `json:"frontendPortRangeEnd,omitempty"`

	//FrontendPortRangeStart: The first port number in the range of external ports
	//that will be used to provide Inbound Nat to NICs associated with a load
	//balancer. Acceptable values range between 1 and 65534.
	FrontendPortRangeStart *int `json:"frontendPortRangeStart,omitempty"`

	//IdleTimeoutInMinutes: The timeout for the TCP idle connection. The value can be
	//set between 4 and 30 minutes. The default value is 4 minutes. This element is
	//only used when the protocol is set to TCP.
	IdleTimeoutInMinutes *int `json:"idleTimeoutInMinutes,omitempty"`

	// +kubebuilder:validation:Required
	//Name: The name of the resource that is unique within the set of inbound NAT
	//pools used by the load balancer. This name can be used to access the resource.
	Name string `json:"name"`

	//Protocol: The reference to the transport protocol used by the inbound NAT pool.
	Protocol *InboundNatPoolPropertiesFormatProtocol `json:"protocol,omitempty"`
}

var _ genruntime.ARMTransformer = &LoadBalancers_Spec_Properties_InboundNatPools{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (loadBalancersSpecPropertiesInboundNatPools *LoadBalancers_Spec_Properties_InboundNatPools) ConvertToARM(name string, resolvedReferences genruntime.ResolvedReferences) (interface{}, error) {
	if loadBalancersSpecPropertiesInboundNatPools == nil {
		return nil, nil
	}
	var result LoadBalancers_Spec_Properties_InboundNatPoolsARM

	// Set property ‘Name’:
	result.Name = loadBalancersSpecPropertiesInboundNatPools.Name

	// Set property ‘Properties’:
	if loadBalancersSpecPropertiesInboundNatPools.BackendPort != nil || loadBalancersSpecPropertiesInboundNatPools.EnableFloatingIP != nil || loadBalancersSpecPropertiesInboundNatPools.EnableTcpReset != nil || loadBalancersSpecPropertiesInboundNatPools.FrontendIPConfiguration != nil || loadBalancersSpecPropertiesInboundNatPools.FrontendPortRangeEnd != nil || loadBalancersSpecPropertiesInboundNatPools.FrontendPortRangeStart != nil || loadBalancersSpecPropertiesInboundNatPools.IdleTimeoutInMinutes != nil || loadBalancersSpecPropertiesInboundNatPools.Protocol != nil {
		result.Properties = &InboundNatPoolPropertiesFormatARM{}
	}
	if loadBalancersSpecPropertiesInboundNatPools.BackendPort != nil {
		result.Properties.BackendPort = *loadBalancersSpecPropertiesInboundNatPools.BackendPort
	}
	if loadBalancersSpecPropertiesInboundNatPools.EnableFloatingIP != nil {
		enableFloatingIP := *loadBalancersSpecPropertiesInboundNatPools.EnableFloatingIP
		result.Properties.EnableFloatingIP = &enableFloatingIP
	}
	if loadBalancersSpecPropertiesInboundNatPools.EnableTcpReset != nil {
		enableTcpReset := *loadBalancersSpecPropertiesInboundNatPools.EnableTcpReset
		result.Properties.EnableTcpReset = &enableTcpReset
	}
	var temp SubResourceARM
	tempARM, err := (*loadBalancersSpecPropertiesInboundNatPools.FrontendIPConfiguration).ConvertToARM(name, resolvedReferences)
	if err != nil {
		return nil, err
	}
	temp = tempARM.(SubResourceARM)
	result.Properties.FrontendIPConfiguration = temp
	if loadBalancersSpecPropertiesInboundNatPools.FrontendPortRangeEnd != nil {
		result.Properties.FrontendPortRangeEnd = *loadBalancersSpecPropertiesInboundNatPools.FrontendPortRangeEnd
	}
	if loadBalancersSpecPropertiesInboundNatPools.FrontendPortRangeStart != nil {
		result.Properties.FrontendPortRangeStart = *loadBalancersSpecPropertiesInboundNatPools.FrontendPortRangeStart
	}
	if loadBalancersSpecPropertiesInboundNatPools.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinutes := *loadBalancersSpecPropertiesInboundNatPools.IdleTimeoutInMinutes
		result.Properties.IdleTimeoutInMinutes = &idleTimeoutInMinutes
	}
	if loadBalancersSpecPropertiesInboundNatPools.Protocol != nil {
		result.Properties.Protocol = *loadBalancersSpecPropertiesInboundNatPools.Protocol
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (loadBalancersSpecPropertiesInboundNatPools *LoadBalancers_Spec_Properties_InboundNatPools) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &LoadBalancers_Spec_Properties_InboundNatPoolsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (loadBalancersSpecPropertiesInboundNatPools *LoadBalancers_Spec_Properties_InboundNatPools) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(LoadBalancers_Spec_Properties_InboundNatPoolsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LoadBalancers_Spec_Properties_InboundNatPoolsARM, got %T", armInput)
	}

	// Set property ‘BackendPort’:
	// copying flattened property:
	if typedInput.Properties != nil {
		loadBalancersSpecPropertiesInboundNatPools.BackendPort = &typedInput.Properties.BackendPort
	}

	// Set property ‘EnableFloatingIP’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableFloatingIP != nil {
			enableFloatingIP := *typedInput.Properties.EnableFloatingIP
			loadBalancersSpecPropertiesInboundNatPools.EnableFloatingIP = &enableFloatingIP
		}
	}

	// Set property ‘EnableTcpReset’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableTcpReset != nil {
			enableTcpReset := *typedInput.Properties.EnableTcpReset
			loadBalancersSpecPropertiesInboundNatPools.EnableTcpReset = &enableTcpReset
		}
	}

	// Set property ‘FrontendIPConfiguration’:
	// copying flattened property:
	if typedInput.Properties != nil {
		var temp SubResource
		var temp1 SubResource
		err := temp1.PopulateFromARM(owner, typedInput.Properties.FrontendIPConfiguration)
		if err != nil {
			return err
		}
		temp = temp1
		loadBalancersSpecPropertiesInboundNatPools.FrontendIPConfiguration = &temp
	}

	// Set property ‘FrontendPortRangeEnd’:
	// copying flattened property:
	if typedInput.Properties != nil {
		loadBalancersSpecPropertiesInboundNatPools.FrontendPortRangeEnd = &typedInput.Properties.FrontendPortRangeEnd
	}

	// Set property ‘FrontendPortRangeStart’:
	// copying flattened property:
	if typedInput.Properties != nil {
		loadBalancersSpecPropertiesInboundNatPools.FrontendPortRangeStart = &typedInput.Properties.FrontendPortRangeStart
	}

	// Set property ‘IdleTimeoutInMinutes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdleTimeoutInMinutes != nil {
			idleTimeoutInMinutes := *typedInput.Properties.IdleTimeoutInMinutes
			loadBalancersSpecPropertiesInboundNatPools.IdleTimeoutInMinutes = &idleTimeoutInMinutes
		}
	}

	// Set property ‘Name’:
	loadBalancersSpecPropertiesInboundNatPools.Name = typedInput.Name

	// Set property ‘Protocol’:
	// copying flattened property:
	if typedInput.Properties != nil {
		loadBalancersSpecPropertiesInboundNatPools.Protocol = &typedInput.Properties.Protocol
	}

	// No error
	return nil
}

// AssignPropertiesFromLoadBalancersSpecPropertiesInboundNatPools populates our LoadBalancers_Spec_Properties_InboundNatPools from the provided source LoadBalancers_Spec_Properties_InboundNatPools
func (loadBalancersSpecPropertiesInboundNatPools *LoadBalancers_Spec_Properties_InboundNatPools) AssignPropertiesFromLoadBalancersSpecPropertiesInboundNatPools(source *v1alpha1api20201101storage.LoadBalancers_Spec_Properties_InboundNatPools) error {

	// BackendPort
	if source.BackendPort != nil {
		backendPort := *source.BackendPort
		loadBalancersSpecPropertiesInboundNatPools.BackendPort = &backendPort
	} else {
		loadBalancersSpecPropertiesInboundNatPools.BackendPort = nil
	}

	// EnableFloatingIP
	if source.EnableFloatingIP != nil {
		enableFloatingIP := *source.EnableFloatingIP
		loadBalancersSpecPropertiesInboundNatPools.EnableFloatingIP = &enableFloatingIP
	} else {
		loadBalancersSpecPropertiesInboundNatPools.EnableFloatingIP = nil
	}

	// EnableTcpReset
	if source.EnableTcpReset != nil {
		enableTcpReset := *source.EnableTcpReset
		loadBalancersSpecPropertiesInboundNatPools.EnableTcpReset = &enableTcpReset
	} else {
		loadBalancersSpecPropertiesInboundNatPools.EnableTcpReset = nil
	}

	// FrontendIPConfiguration
	if source.FrontendIPConfiguration != nil {
		var frontendIPConfiguration SubResource
		err := frontendIPConfiguration.AssignPropertiesFromSubResource(source.FrontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "populating FrontendIPConfiguration from FrontendIPConfiguration, calling AssignPropertiesFromSubResource()")
		}
		loadBalancersSpecPropertiesInboundNatPools.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		loadBalancersSpecPropertiesInboundNatPools.FrontendIPConfiguration = nil
	}

	// FrontendPortRangeEnd
	if source.FrontendPortRangeEnd != nil {
		frontendPortRangeEnd := *source.FrontendPortRangeEnd
		loadBalancersSpecPropertiesInboundNatPools.FrontendPortRangeEnd = &frontendPortRangeEnd
	} else {
		loadBalancersSpecPropertiesInboundNatPools.FrontendPortRangeEnd = nil
	}

	// FrontendPortRangeStart
	if source.FrontendPortRangeStart != nil {
		frontendPortRangeStart := *source.FrontendPortRangeStart
		loadBalancersSpecPropertiesInboundNatPools.FrontendPortRangeStart = &frontendPortRangeStart
	} else {
		loadBalancersSpecPropertiesInboundNatPools.FrontendPortRangeStart = nil
	}

	// IdleTimeoutInMinutes
	if source.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinute := *source.IdleTimeoutInMinutes
		loadBalancersSpecPropertiesInboundNatPools.IdleTimeoutInMinutes = &idleTimeoutInMinute
	} else {
		loadBalancersSpecPropertiesInboundNatPools.IdleTimeoutInMinutes = nil
	}

	// Name
	if source.Name != nil {
		loadBalancersSpecPropertiesInboundNatPools.Name = *source.Name
	} else {
		loadBalancersSpecPropertiesInboundNatPools.Name = ""
	}

	// Protocol
	if source.Protocol != nil {
		protocol := InboundNatPoolPropertiesFormatProtocol(*source.Protocol)
		loadBalancersSpecPropertiesInboundNatPools.Protocol = &protocol
	} else {
		loadBalancersSpecPropertiesInboundNatPools.Protocol = nil
	}

	// No error
	return nil
}

// AssignPropertiesToLoadBalancersSpecPropertiesInboundNatPools populates the provided destination LoadBalancers_Spec_Properties_InboundNatPools from our LoadBalancers_Spec_Properties_InboundNatPools
func (loadBalancersSpecPropertiesInboundNatPools *LoadBalancers_Spec_Properties_InboundNatPools) AssignPropertiesToLoadBalancersSpecPropertiesInboundNatPools(destination *v1alpha1api20201101storage.LoadBalancers_Spec_Properties_InboundNatPools) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackendPort
	if loadBalancersSpecPropertiesInboundNatPools.BackendPort != nil {
		backendPort := *loadBalancersSpecPropertiesInboundNatPools.BackendPort
		destination.BackendPort = &backendPort
	} else {
		destination.BackendPort = nil
	}

	// EnableFloatingIP
	if loadBalancersSpecPropertiesInboundNatPools.EnableFloatingIP != nil {
		enableFloatingIP := *loadBalancersSpecPropertiesInboundNatPools.EnableFloatingIP
		destination.EnableFloatingIP = &enableFloatingIP
	} else {
		destination.EnableFloatingIP = nil
	}

	// EnableTcpReset
	if loadBalancersSpecPropertiesInboundNatPools.EnableTcpReset != nil {
		enableTcpReset := *loadBalancersSpecPropertiesInboundNatPools.EnableTcpReset
		destination.EnableTcpReset = &enableTcpReset
	} else {
		destination.EnableTcpReset = nil
	}

	// FrontendIPConfiguration
	if loadBalancersSpecPropertiesInboundNatPools.FrontendIPConfiguration != nil {
		var frontendIPConfiguration v1alpha1api20201101storage.SubResource
		err := (*loadBalancersSpecPropertiesInboundNatPools.FrontendIPConfiguration).AssignPropertiesToSubResource(&frontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "populating FrontendIPConfiguration from FrontendIPConfiguration, calling AssignPropertiesToSubResource()")
		}
		destination.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		destination.FrontendIPConfiguration = nil
	}

	// FrontendPortRangeEnd
	if loadBalancersSpecPropertiesInboundNatPools.FrontendPortRangeEnd != nil {
		frontendPortRangeEnd := *loadBalancersSpecPropertiesInboundNatPools.FrontendPortRangeEnd
		destination.FrontendPortRangeEnd = &frontendPortRangeEnd
	} else {
		destination.FrontendPortRangeEnd = nil
	}

	// FrontendPortRangeStart
	if loadBalancersSpecPropertiesInboundNatPools.FrontendPortRangeStart != nil {
		frontendPortRangeStart := *loadBalancersSpecPropertiesInboundNatPools.FrontendPortRangeStart
		destination.FrontendPortRangeStart = &frontendPortRangeStart
	} else {
		destination.FrontendPortRangeStart = nil
	}

	// IdleTimeoutInMinutes
	if loadBalancersSpecPropertiesInboundNatPools.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinute := *loadBalancersSpecPropertiesInboundNatPools.IdleTimeoutInMinutes
		destination.IdleTimeoutInMinutes = &idleTimeoutInMinute
	} else {
		destination.IdleTimeoutInMinutes = nil
	}

	// Name
	name := loadBalancersSpecPropertiesInboundNatPools.Name
	destination.Name = &name

	// Protocol
	if loadBalancersSpecPropertiesInboundNatPools.Protocol != nil {
		protocol := string(*loadBalancersSpecPropertiesInboundNatPools.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

type LoadBalancers_Spec_Properties_LoadBalancingRules struct {
	//BackendAddressPool: A reference to a pool of DIPs. Inbound traffic is randomly
	//load balanced across IPs in the backend IPs.
	BackendAddressPool *SubResource `json:"backendAddressPool,omitempty"`

	//BackendPort: The port used for internal connections on the endpoint. Acceptable
	//values are between 0 and 65535. Note that value 0 enables "Any Port".
	BackendPort *int `json:"backendPort,omitempty"`

	//DisableOutboundSnat: Configures SNAT for the VMs in the backend pool to use the
	//publicIP address specified in the frontend of the load balancing rule.
	DisableOutboundSnat *bool `json:"disableOutboundSnat,omitempty"`

	//EnableFloatingIP: Configures a virtual machine's endpoint for the floating IP
	//capability required to configure a SQL AlwaysOn Availability Group. This setting
	//is required when using the SQL AlwaysOn Availability Groups in SQL server. This
	//setting can't be changed after you create the endpoint.
	EnableFloatingIP *bool `json:"enableFloatingIP,omitempty"`

	//EnableTcpReset: Receive bidirectional TCP Reset on TCP flow idle timeout or
	//unexpected connection termination. This element is only used when the protocol
	//is set to TCP.
	EnableTcpReset *bool `json:"enableTcpReset,omitempty"`

	//FrontendIPConfiguration: A reference to frontend IP addresses.
	FrontendIPConfiguration *SubResource `json:"frontendIPConfiguration,omitempty"`

	//FrontendPort: The port for the external endpoint. Port numbers for each rule
	//must be unique within the Load Balancer. Acceptable values are between 0 and
	//65534. Note that value 0 enables "Any Port".
	FrontendPort *int `json:"frontendPort,omitempty"`

	//IdleTimeoutInMinutes: The timeout for the TCP idle connection. The value can be
	//set between 4 and 30 minutes. The default value is 4 minutes. This element is
	//only used when the protocol is set to TCP.
	IdleTimeoutInMinutes *int `json:"idleTimeoutInMinutes,omitempty"`

	//LoadDistribution: The load distribution policy for this rule.
	LoadDistribution *LoadBalancingRulePropertiesFormatLoadDistribution `json:"loadDistribution,omitempty"`

	// +kubebuilder:validation:Required
	//Name: The name of the resource that is unique within the set of load balancing
	//rules used by the load balancer. This name can be used to access the resource.
	Name string `json:"name"`

	//Probe: The reference to the load balancer probe used by the load balancing rule.
	Probe *SubResource `json:"probe,omitempty"`

	//Protocol: The reference to the transport protocol used by the load balancing
	//rule.
	Protocol *LoadBalancingRulePropertiesFormatProtocol `json:"protocol,omitempty"`
}

var _ genruntime.ARMTransformer = &LoadBalancers_Spec_Properties_LoadBalancingRules{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (loadBalancersSpecPropertiesLoadBalancingRules *LoadBalancers_Spec_Properties_LoadBalancingRules) ConvertToARM(name string, resolvedReferences genruntime.ResolvedReferences) (interface{}, error) {
	if loadBalancersSpecPropertiesLoadBalancingRules == nil {
		return nil, nil
	}
	var result LoadBalancers_Spec_Properties_LoadBalancingRulesARM

	// Set property ‘Name’:
	result.Name = loadBalancersSpecPropertiesLoadBalancingRules.Name

	// Set property ‘Properties’:
	if loadBalancersSpecPropertiesLoadBalancingRules.BackendAddressPool != nil || loadBalancersSpecPropertiesLoadBalancingRules.BackendPort != nil || loadBalancersSpecPropertiesLoadBalancingRules.DisableOutboundSnat != nil || loadBalancersSpecPropertiesLoadBalancingRules.EnableFloatingIP != nil || loadBalancersSpecPropertiesLoadBalancingRules.EnableTcpReset != nil || loadBalancersSpecPropertiesLoadBalancingRules.FrontendIPConfiguration != nil || loadBalancersSpecPropertiesLoadBalancingRules.FrontendPort != nil || loadBalancersSpecPropertiesLoadBalancingRules.IdleTimeoutInMinutes != nil || loadBalancersSpecPropertiesLoadBalancingRules.LoadDistribution != nil || loadBalancersSpecPropertiesLoadBalancingRules.Probe != nil || loadBalancersSpecPropertiesLoadBalancingRules.Protocol != nil {
		result.Properties = &LoadBalancingRulePropertiesFormatARM{}
	}
	if loadBalancersSpecPropertiesLoadBalancingRules.BackendAddressPool != nil {
		backendAddressPoolARM, err := (*loadBalancersSpecPropertiesLoadBalancingRules.BackendAddressPool).ConvertToARM(name, resolvedReferences)
		if err != nil {
			return nil, err
		}
		backendAddressPool := backendAddressPoolARM.(SubResourceARM)
		result.Properties.BackendAddressPool = &backendAddressPool
	}
	if loadBalancersSpecPropertiesLoadBalancingRules.BackendPort != nil {
		result.Properties.BackendPort = *loadBalancersSpecPropertiesLoadBalancingRules.BackendPort
	}
	if loadBalancersSpecPropertiesLoadBalancingRules.DisableOutboundSnat != nil {
		disableOutboundSnat := *loadBalancersSpecPropertiesLoadBalancingRules.DisableOutboundSnat
		result.Properties.DisableOutboundSnat = &disableOutboundSnat
	}
	if loadBalancersSpecPropertiesLoadBalancingRules.EnableFloatingIP != nil {
		enableFloatingIP := *loadBalancersSpecPropertiesLoadBalancingRules.EnableFloatingIP
		result.Properties.EnableFloatingIP = &enableFloatingIP
	}
	if loadBalancersSpecPropertiesLoadBalancingRules.EnableTcpReset != nil {
		enableTcpReset := *loadBalancersSpecPropertiesLoadBalancingRules.EnableTcpReset
		result.Properties.EnableTcpReset = &enableTcpReset
	}
	var temp SubResourceARM
	tempARM, err := (*loadBalancersSpecPropertiesLoadBalancingRules.FrontendIPConfiguration).ConvertToARM(name, resolvedReferences)
	if err != nil {
		return nil, err
	}
	temp = tempARM.(SubResourceARM)
	result.Properties.FrontendIPConfiguration = temp
	if loadBalancersSpecPropertiesLoadBalancingRules.FrontendPort != nil {
		result.Properties.FrontendPort = *loadBalancersSpecPropertiesLoadBalancingRules.FrontendPort
	}
	if loadBalancersSpecPropertiesLoadBalancingRules.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinutes := *loadBalancersSpecPropertiesLoadBalancingRules.IdleTimeoutInMinutes
		result.Properties.IdleTimeoutInMinutes = &idleTimeoutInMinutes
	}
	if loadBalancersSpecPropertiesLoadBalancingRules.LoadDistribution != nil {
		loadDistribution := *loadBalancersSpecPropertiesLoadBalancingRules.LoadDistribution
		result.Properties.LoadDistribution = &loadDistribution
	}
	if loadBalancersSpecPropertiesLoadBalancingRules.Probe != nil {
		probeARM, err := (*loadBalancersSpecPropertiesLoadBalancingRules.Probe).ConvertToARM(name, resolvedReferences)
		if err != nil {
			return nil, err
		}
		probe := probeARM.(SubResourceARM)
		result.Properties.Probe = &probe
	}
	if loadBalancersSpecPropertiesLoadBalancingRules.Protocol != nil {
		result.Properties.Protocol = *loadBalancersSpecPropertiesLoadBalancingRules.Protocol
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (loadBalancersSpecPropertiesLoadBalancingRules *LoadBalancers_Spec_Properties_LoadBalancingRules) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &LoadBalancers_Spec_Properties_LoadBalancingRulesARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (loadBalancersSpecPropertiesLoadBalancingRules *LoadBalancers_Spec_Properties_LoadBalancingRules) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(LoadBalancers_Spec_Properties_LoadBalancingRulesARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LoadBalancers_Spec_Properties_LoadBalancingRulesARM, got %T", armInput)
	}

	// Set property ‘BackendAddressPool’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.BackendAddressPool != nil {
			var backendAddressPool1 SubResource
			err := backendAddressPool1.PopulateFromARM(owner, *typedInput.Properties.BackendAddressPool)
			if err != nil {
				return err
			}
			backendAddressPool := backendAddressPool1
			loadBalancersSpecPropertiesLoadBalancingRules.BackendAddressPool = &backendAddressPool
		}
	}

	// Set property ‘BackendPort’:
	// copying flattened property:
	if typedInput.Properties != nil {
		loadBalancersSpecPropertiesLoadBalancingRules.BackendPort = &typedInput.Properties.BackendPort
	}

	// Set property ‘DisableOutboundSnat’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DisableOutboundSnat != nil {
			disableOutboundSnat := *typedInput.Properties.DisableOutboundSnat
			loadBalancersSpecPropertiesLoadBalancingRules.DisableOutboundSnat = &disableOutboundSnat
		}
	}

	// Set property ‘EnableFloatingIP’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableFloatingIP != nil {
			enableFloatingIP := *typedInput.Properties.EnableFloatingIP
			loadBalancersSpecPropertiesLoadBalancingRules.EnableFloatingIP = &enableFloatingIP
		}
	}

	// Set property ‘EnableTcpReset’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableTcpReset != nil {
			enableTcpReset := *typedInput.Properties.EnableTcpReset
			loadBalancersSpecPropertiesLoadBalancingRules.EnableTcpReset = &enableTcpReset
		}
	}

	// Set property ‘FrontendIPConfiguration’:
	// copying flattened property:
	if typedInput.Properties != nil {
		var temp SubResource
		var temp1 SubResource
		err := temp1.PopulateFromARM(owner, typedInput.Properties.FrontendIPConfiguration)
		if err != nil {
			return err
		}
		temp = temp1
		loadBalancersSpecPropertiesLoadBalancingRules.FrontendIPConfiguration = &temp
	}

	// Set property ‘FrontendPort’:
	// copying flattened property:
	if typedInput.Properties != nil {
		loadBalancersSpecPropertiesLoadBalancingRules.FrontendPort = &typedInput.Properties.FrontendPort
	}

	// Set property ‘IdleTimeoutInMinutes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdleTimeoutInMinutes != nil {
			idleTimeoutInMinutes := *typedInput.Properties.IdleTimeoutInMinutes
			loadBalancersSpecPropertiesLoadBalancingRules.IdleTimeoutInMinutes = &idleTimeoutInMinutes
		}
	}

	// Set property ‘LoadDistribution’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LoadDistribution != nil {
			loadDistribution := *typedInput.Properties.LoadDistribution
			loadBalancersSpecPropertiesLoadBalancingRules.LoadDistribution = &loadDistribution
		}
	}

	// Set property ‘Name’:
	loadBalancersSpecPropertiesLoadBalancingRules.Name = typedInput.Name

	// Set property ‘Probe’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Probe != nil {
			var probe1 SubResource
			err := probe1.PopulateFromARM(owner, *typedInput.Properties.Probe)
			if err != nil {
				return err
			}
			probe := probe1
			loadBalancersSpecPropertiesLoadBalancingRules.Probe = &probe
		}
	}

	// Set property ‘Protocol’:
	// copying flattened property:
	if typedInput.Properties != nil {
		loadBalancersSpecPropertiesLoadBalancingRules.Protocol = &typedInput.Properties.Protocol
	}

	// No error
	return nil
}

// AssignPropertiesFromLoadBalancersSpecPropertiesLoadBalancingRules populates our LoadBalancers_Spec_Properties_LoadBalancingRules from the provided source LoadBalancers_Spec_Properties_LoadBalancingRules
func (loadBalancersSpecPropertiesLoadBalancingRules *LoadBalancers_Spec_Properties_LoadBalancingRules) AssignPropertiesFromLoadBalancersSpecPropertiesLoadBalancingRules(source *v1alpha1api20201101storage.LoadBalancers_Spec_Properties_LoadBalancingRules) error {

	// BackendAddressPool
	if source.BackendAddressPool != nil {
		var backendAddressPool SubResource
		err := backendAddressPool.AssignPropertiesFromSubResource(source.BackendAddressPool)
		if err != nil {
			return errors.Wrap(err, "populating BackendAddressPool from BackendAddressPool, calling AssignPropertiesFromSubResource()")
		}
		loadBalancersSpecPropertiesLoadBalancingRules.BackendAddressPool = &backendAddressPool
	} else {
		loadBalancersSpecPropertiesLoadBalancingRules.BackendAddressPool = nil
	}

	// BackendPort
	if source.BackendPort != nil {
		backendPort := *source.BackendPort
		loadBalancersSpecPropertiesLoadBalancingRules.BackendPort = &backendPort
	} else {
		loadBalancersSpecPropertiesLoadBalancingRules.BackendPort = nil
	}

	// DisableOutboundSnat
	if source.DisableOutboundSnat != nil {
		disableOutboundSnat := *source.DisableOutboundSnat
		loadBalancersSpecPropertiesLoadBalancingRules.DisableOutboundSnat = &disableOutboundSnat
	} else {
		loadBalancersSpecPropertiesLoadBalancingRules.DisableOutboundSnat = nil
	}

	// EnableFloatingIP
	if source.EnableFloatingIP != nil {
		enableFloatingIP := *source.EnableFloatingIP
		loadBalancersSpecPropertiesLoadBalancingRules.EnableFloatingIP = &enableFloatingIP
	} else {
		loadBalancersSpecPropertiesLoadBalancingRules.EnableFloatingIP = nil
	}

	// EnableTcpReset
	if source.EnableTcpReset != nil {
		enableTcpReset := *source.EnableTcpReset
		loadBalancersSpecPropertiesLoadBalancingRules.EnableTcpReset = &enableTcpReset
	} else {
		loadBalancersSpecPropertiesLoadBalancingRules.EnableTcpReset = nil
	}

	// FrontendIPConfiguration
	if source.FrontendIPConfiguration != nil {
		var frontendIPConfiguration SubResource
		err := frontendIPConfiguration.AssignPropertiesFromSubResource(source.FrontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "populating FrontendIPConfiguration from FrontendIPConfiguration, calling AssignPropertiesFromSubResource()")
		}
		loadBalancersSpecPropertiesLoadBalancingRules.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		loadBalancersSpecPropertiesLoadBalancingRules.FrontendIPConfiguration = nil
	}

	// FrontendPort
	if source.FrontendPort != nil {
		frontendPort := *source.FrontendPort
		loadBalancersSpecPropertiesLoadBalancingRules.FrontendPort = &frontendPort
	} else {
		loadBalancersSpecPropertiesLoadBalancingRules.FrontendPort = nil
	}

	// IdleTimeoutInMinutes
	if source.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinute := *source.IdleTimeoutInMinutes
		loadBalancersSpecPropertiesLoadBalancingRules.IdleTimeoutInMinutes = &idleTimeoutInMinute
	} else {
		loadBalancersSpecPropertiesLoadBalancingRules.IdleTimeoutInMinutes = nil
	}

	// LoadDistribution
	if source.LoadDistribution != nil {
		loadDistribution := LoadBalancingRulePropertiesFormatLoadDistribution(*source.LoadDistribution)
		loadBalancersSpecPropertiesLoadBalancingRules.LoadDistribution = &loadDistribution
	} else {
		loadBalancersSpecPropertiesLoadBalancingRules.LoadDistribution = nil
	}

	// Name
	if source.Name != nil {
		loadBalancersSpecPropertiesLoadBalancingRules.Name = *source.Name
	} else {
		loadBalancersSpecPropertiesLoadBalancingRules.Name = ""
	}

	// Probe
	if source.Probe != nil {
		var probe SubResource
		err := probe.AssignPropertiesFromSubResource(source.Probe)
		if err != nil {
			return errors.Wrap(err, "populating Probe from Probe, calling AssignPropertiesFromSubResource()")
		}
		loadBalancersSpecPropertiesLoadBalancingRules.Probe = &probe
	} else {
		loadBalancersSpecPropertiesLoadBalancingRules.Probe = nil
	}

	// Protocol
	if source.Protocol != nil {
		protocol := LoadBalancingRulePropertiesFormatProtocol(*source.Protocol)
		loadBalancersSpecPropertiesLoadBalancingRules.Protocol = &protocol
	} else {
		loadBalancersSpecPropertiesLoadBalancingRules.Protocol = nil
	}

	// No error
	return nil
}

// AssignPropertiesToLoadBalancersSpecPropertiesLoadBalancingRules populates the provided destination LoadBalancers_Spec_Properties_LoadBalancingRules from our LoadBalancers_Spec_Properties_LoadBalancingRules
func (loadBalancersSpecPropertiesLoadBalancingRules *LoadBalancers_Spec_Properties_LoadBalancingRules) AssignPropertiesToLoadBalancersSpecPropertiesLoadBalancingRules(destination *v1alpha1api20201101storage.LoadBalancers_Spec_Properties_LoadBalancingRules) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackendAddressPool
	if loadBalancersSpecPropertiesLoadBalancingRules.BackendAddressPool != nil {
		var backendAddressPool v1alpha1api20201101storage.SubResource
		err := (*loadBalancersSpecPropertiesLoadBalancingRules.BackendAddressPool).AssignPropertiesToSubResource(&backendAddressPool)
		if err != nil {
			return errors.Wrap(err, "populating BackendAddressPool from BackendAddressPool, calling AssignPropertiesToSubResource()")
		}
		destination.BackendAddressPool = &backendAddressPool
	} else {
		destination.BackendAddressPool = nil
	}

	// BackendPort
	if loadBalancersSpecPropertiesLoadBalancingRules.BackendPort != nil {
		backendPort := *loadBalancersSpecPropertiesLoadBalancingRules.BackendPort
		destination.BackendPort = &backendPort
	} else {
		destination.BackendPort = nil
	}

	// DisableOutboundSnat
	if loadBalancersSpecPropertiesLoadBalancingRules.DisableOutboundSnat != nil {
		disableOutboundSnat := *loadBalancersSpecPropertiesLoadBalancingRules.DisableOutboundSnat
		destination.DisableOutboundSnat = &disableOutboundSnat
	} else {
		destination.DisableOutboundSnat = nil
	}

	// EnableFloatingIP
	if loadBalancersSpecPropertiesLoadBalancingRules.EnableFloatingIP != nil {
		enableFloatingIP := *loadBalancersSpecPropertiesLoadBalancingRules.EnableFloatingIP
		destination.EnableFloatingIP = &enableFloatingIP
	} else {
		destination.EnableFloatingIP = nil
	}

	// EnableTcpReset
	if loadBalancersSpecPropertiesLoadBalancingRules.EnableTcpReset != nil {
		enableTcpReset := *loadBalancersSpecPropertiesLoadBalancingRules.EnableTcpReset
		destination.EnableTcpReset = &enableTcpReset
	} else {
		destination.EnableTcpReset = nil
	}

	// FrontendIPConfiguration
	if loadBalancersSpecPropertiesLoadBalancingRules.FrontendIPConfiguration != nil {
		var frontendIPConfiguration v1alpha1api20201101storage.SubResource
		err := (*loadBalancersSpecPropertiesLoadBalancingRules.FrontendIPConfiguration).AssignPropertiesToSubResource(&frontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "populating FrontendIPConfiguration from FrontendIPConfiguration, calling AssignPropertiesToSubResource()")
		}
		destination.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		destination.FrontendIPConfiguration = nil
	}

	// FrontendPort
	if loadBalancersSpecPropertiesLoadBalancingRules.FrontendPort != nil {
		frontendPort := *loadBalancersSpecPropertiesLoadBalancingRules.FrontendPort
		destination.FrontendPort = &frontendPort
	} else {
		destination.FrontendPort = nil
	}

	// IdleTimeoutInMinutes
	if loadBalancersSpecPropertiesLoadBalancingRules.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinute := *loadBalancersSpecPropertiesLoadBalancingRules.IdleTimeoutInMinutes
		destination.IdleTimeoutInMinutes = &idleTimeoutInMinute
	} else {
		destination.IdleTimeoutInMinutes = nil
	}

	// LoadDistribution
	if loadBalancersSpecPropertiesLoadBalancingRules.LoadDistribution != nil {
		loadDistribution := string(*loadBalancersSpecPropertiesLoadBalancingRules.LoadDistribution)
		destination.LoadDistribution = &loadDistribution
	} else {
		destination.LoadDistribution = nil
	}

	// Name
	name := loadBalancersSpecPropertiesLoadBalancingRules.Name
	destination.Name = &name

	// Probe
	if loadBalancersSpecPropertiesLoadBalancingRules.Probe != nil {
		var probe v1alpha1api20201101storage.SubResource
		err := (*loadBalancersSpecPropertiesLoadBalancingRules.Probe).AssignPropertiesToSubResource(&probe)
		if err != nil {
			return errors.Wrap(err, "populating Probe from Probe, calling AssignPropertiesToSubResource()")
		}
		destination.Probe = &probe
	} else {
		destination.Probe = nil
	}

	// Protocol
	if loadBalancersSpecPropertiesLoadBalancingRules.Protocol != nil {
		protocol := string(*loadBalancersSpecPropertiesLoadBalancingRules.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

type LoadBalancers_Spec_Properties_OutboundRules struct {
	//AllocatedOutboundPorts: The number of outbound ports to be used for NAT.
	AllocatedOutboundPorts *int `json:"allocatedOutboundPorts,omitempty"`

	//BackendAddressPool: A reference to a pool of DIPs. Outbound traffic is randomly
	//load balanced across IPs in the backend IPs.
	BackendAddressPool *SubResource `json:"backendAddressPool,omitempty"`

	//EnableTcpReset: Receive bidirectional TCP Reset on TCP flow idle timeout or
	//unexpected connection termination. This element is only used when the protocol
	//is set to TCP.
	EnableTcpReset *bool `json:"enableTcpReset,omitempty"`

	//FrontendIPConfigurations: The Frontend IP addresses of the load balancer.
	FrontendIPConfigurations []SubResource `json:"frontendIPConfigurations,omitempty"`

	//IdleTimeoutInMinutes: The timeout for the TCP idle connection.
	IdleTimeoutInMinutes *int `json:"idleTimeoutInMinutes,omitempty"`

	//Name: The name of the resource that is unique within the set of outbound rules
	//used by the load balancer. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`

	//Protocol: The protocol for the outbound rule in load balancer.
	Protocol *OutboundRulePropertiesFormatProtocol `json:"protocol,omitempty"`
}

var _ genruntime.ARMTransformer = &LoadBalancers_Spec_Properties_OutboundRules{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (loadBalancersSpecPropertiesOutboundRules *LoadBalancers_Spec_Properties_OutboundRules) ConvertToARM(name string, resolvedReferences genruntime.ResolvedReferences) (interface{}, error) {
	if loadBalancersSpecPropertiesOutboundRules == nil {
		return nil, nil
	}
	var result LoadBalancers_Spec_Properties_OutboundRulesARM

	// Set property ‘Name’:
	if loadBalancersSpecPropertiesOutboundRules.Name != nil {
		name := *loadBalancersSpecPropertiesOutboundRules.Name
		result.Name = &name
	}

	// Set property ‘Properties’:
	if loadBalancersSpecPropertiesOutboundRules.AllocatedOutboundPorts != nil || loadBalancersSpecPropertiesOutboundRules.BackendAddressPool != nil || loadBalancersSpecPropertiesOutboundRules.EnableTcpReset != nil || loadBalancersSpecPropertiesOutboundRules.FrontendIPConfigurations != nil || loadBalancersSpecPropertiesOutboundRules.IdleTimeoutInMinutes != nil || loadBalancersSpecPropertiesOutboundRules.Protocol != nil {
		result.Properties = &OutboundRulePropertiesFormatARM{}
	}
	if loadBalancersSpecPropertiesOutboundRules.AllocatedOutboundPorts != nil {
		allocatedOutboundPorts := *loadBalancersSpecPropertiesOutboundRules.AllocatedOutboundPorts
		result.Properties.AllocatedOutboundPorts = &allocatedOutboundPorts
	}
	var temp SubResourceARM
	tempARM, err := (*loadBalancersSpecPropertiesOutboundRules.BackendAddressPool).ConvertToARM(name, resolvedReferences)
	if err != nil {
		return nil, err
	}
	temp = tempARM.(SubResourceARM)
	result.Properties.BackendAddressPool = temp
	if loadBalancersSpecPropertiesOutboundRules.EnableTcpReset != nil {
		enableTcpReset := *loadBalancersSpecPropertiesOutboundRules.EnableTcpReset
		result.Properties.EnableTcpReset = &enableTcpReset
	}
	for _, item := range loadBalancersSpecPropertiesOutboundRules.FrontendIPConfigurations {
		itemARM, err := item.ConvertToARM(name, resolvedReferences)
		if err != nil {
			return nil, err
		}
		result.Properties.FrontendIPConfigurations = append(result.Properties.FrontendIPConfigurations, itemARM.(SubResourceARM))
	}
	if loadBalancersSpecPropertiesOutboundRules.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinutes := *loadBalancersSpecPropertiesOutboundRules.IdleTimeoutInMinutes
		result.Properties.IdleTimeoutInMinutes = &idleTimeoutInMinutes
	}
	if loadBalancersSpecPropertiesOutboundRules.Protocol != nil {
		result.Properties.Protocol = *loadBalancersSpecPropertiesOutboundRules.Protocol
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (loadBalancersSpecPropertiesOutboundRules *LoadBalancers_Spec_Properties_OutboundRules) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &LoadBalancers_Spec_Properties_OutboundRulesARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (loadBalancersSpecPropertiesOutboundRules *LoadBalancers_Spec_Properties_OutboundRules) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(LoadBalancers_Spec_Properties_OutboundRulesARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LoadBalancers_Spec_Properties_OutboundRulesARM, got %T", armInput)
	}

	// Set property ‘AllocatedOutboundPorts’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AllocatedOutboundPorts != nil {
			allocatedOutboundPorts := *typedInput.Properties.AllocatedOutboundPorts
			loadBalancersSpecPropertiesOutboundRules.AllocatedOutboundPorts = &allocatedOutboundPorts
		}
	}

	// Set property ‘BackendAddressPool’:
	// copying flattened property:
	if typedInput.Properties != nil {
		var temp SubResource
		var temp1 SubResource
		err := temp1.PopulateFromARM(owner, typedInput.Properties.BackendAddressPool)
		if err != nil {
			return err
		}
		temp = temp1
		loadBalancersSpecPropertiesOutboundRules.BackendAddressPool = &temp
	}

	// Set property ‘EnableTcpReset’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableTcpReset != nil {
			enableTcpReset := *typedInput.Properties.EnableTcpReset
			loadBalancersSpecPropertiesOutboundRules.EnableTcpReset = &enableTcpReset
		}
	}

	// Set property ‘FrontendIPConfigurations’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.FrontendIPConfigurations {
			var item1 SubResource
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			loadBalancersSpecPropertiesOutboundRules.FrontendIPConfigurations = append(loadBalancersSpecPropertiesOutboundRules.FrontendIPConfigurations, item1)
		}
	}

	// Set property ‘IdleTimeoutInMinutes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdleTimeoutInMinutes != nil {
			idleTimeoutInMinutes := *typedInput.Properties.IdleTimeoutInMinutes
			loadBalancersSpecPropertiesOutboundRules.IdleTimeoutInMinutes = &idleTimeoutInMinutes
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		loadBalancersSpecPropertiesOutboundRules.Name = &name
	}

	// Set property ‘Protocol’:
	// copying flattened property:
	if typedInput.Properties != nil {
		loadBalancersSpecPropertiesOutboundRules.Protocol = &typedInput.Properties.Protocol
	}

	// No error
	return nil
}

// AssignPropertiesFromLoadBalancersSpecPropertiesOutboundRules populates our LoadBalancers_Spec_Properties_OutboundRules from the provided source LoadBalancers_Spec_Properties_OutboundRules
func (loadBalancersSpecPropertiesOutboundRules *LoadBalancers_Spec_Properties_OutboundRules) AssignPropertiesFromLoadBalancersSpecPropertiesOutboundRules(source *v1alpha1api20201101storage.LoadBalancers_Spec_Properties_OutboundRules) error {

	// AllocatedOutboundPorts
	if source.AllocatedOutboundPorts != nil {
		allocatedOutboundPort := *source.AllocatedOutboundPorts
		loadBalancersSpecPropertiesOutboundRules.AllocatedOutboundPorts = &allocatedOutboundPort
	} else {
		loadBalancersSpecPropertiesOutboundRules.AllocatedOutboundPorts = nil
	}

	// BackendAddressPool
	if source.BackendAddressPool != nil {
		var backendAddressPool SubResource
		err := backendAddressPool.AssignPropertiesFromSubResource(source.BackendAddressPool)
		if err != nil {
			return errors.Wrap(err, "populating BackendAddressPool from BackendAddressPool, calling AssignPropertiesFromSubResource()")
		}
		loadBalancersSpecPropertiesOutboundRules.BackendAddressPool = &backendAddressPool
	} else {
		loadBalancersSpecPropertiesOutboundRules.BackendAddressPool = nil
	}

	// EnableTcpReset
	if source.EnableTcpReset != nil {
		enableTcpReset := *source.EnableTcpReset
		loadBalancersSpecPropertiesOutboundRules.EnableTcpReset = &enableTcpReset
	} else {
		loadBalancersSpecPropertiesOutboundRules.EnableTcpReset = nil
	}

	// FrontendIPConfigurations
	frontendIPConfigurationList := make([]SubResource, len(source.FrontendIPConfigurations))
	for frontendIPConfigurationIndex, frontendIPConfigurationItem := range source.FrontendIPConfigurations {
		// Shadow the loop variable to avoid aliasing
		frontendIPConfigurationItem := frontendIPConfigurationItem
		var frontendIPConfiguration SubResource
		err := frontendIPConfiguration.AssignPropertiesFromSubResource(&frontendIPConfigurationItem)
		if err != nil {
			return errors.Wrap(err, "populating FrontendIPConfigurations from FrontendIPConfigurations, calling AssignPropertiesFromSubResource()")
		}
		frontendIPConfigurationList[frontendIPConfigurationIndex] = frontendIPConfiguration
	}
	loadBalancersSpecPropertiesOutboundRules.FrontendIPConfigurations = frontendIPConfigurationList

	// IdleTimeoutInMinutes
	if source.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinute := *source.IdleTimeoutInMinutes
		loadBalancersSpecPropertiesOutboundRules.IdleTimeoutInMinutes = &idleTimeoutInMinute
	} else {
		loadBalancersSpecPropertiesOutboundRules.IdleTimeoutInMinutes = nil
	}

	// Name
	if source.Name != nil {
		name := *source.Name
		loadBalancersSpecPropertiesOutboundRules.Name = &name
	} else {
		loadBalancersSpecPropertiesOutboundRules.Name = nil
	}

	// Protocol
	if source.Protocol != nil {
		protocol := OutboundRulePropertiesFormatProtocol(*source.Protocol)
		loadBalancersSpecPropertiesOutboundRules.Protocol = &protocol
	} else {
		loadBalancersSpecPropertiesOutboundRules.Protocol = nil
	}

	// No error
	return nil
}

// AssignPropertiesToLoadBalancersSpecPropertiesOutboundRules populates the provided destination LoadBalancers_Spec_Properties_OutboundRules from our LoadBalancers_Spec_Properties_OutboundRules
func (loadBalancersSpecPropertiesOutboundRules *LoadBalancers_Spec_Properties_OutboundRules) AssignPropertiesToLoadBalancersSpecPropertiesOutboundRules(destination *v1alpha1api20201101storage.LoadBalancers_Spec_Properties_OutboundRules) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllocatedOutboundPorts
	if loadBalancersSpecPropertiesOutboundRules.AllocatedOutboundPorts != nil {
		allocatedOutboundPort := *loadBalancersSpecPropertiesOutboundRules.AllocatedOutboundPorts
		destination.AllocatedOutboundPorts = &allocatedOutboundPort
	} else {
		destination.AllocatedOutboundPorts = nil
	}

	// BackendAddressPool
	if loadBalancersSpecPropertiesOutboundRules.BackendAddressPool != nil {
		var backendAddressPool v1alpha1api20201101storage.SubResource
		err := (*loadBalancersSpecPropertiesOutboundRules.BackendAddressPool).AssignPropertiesToSubResource(&backendAddressPool)
		if err != nil {
			return errors.Wrap(err, "populating BackendAddressPool from BackendAddressPool, calling AssignPropertiesToSubResource()")
		}
		destination.BackendAddressPool = &backendAddressPool
	} else {
		destination.BackendAddressPool = nil
	}

	// EnableTcpReset
	if loadBalancersSpecPropertiesOutboundRules.EnableTcpReset != nil {
		enableTcpReset := *loadBalancersSpecPropertiesOutboundRules.EnableTcpReset
		destination.EnableTcpReset = &enableTcpReset
	} else {
		destination.EnableTcpReset = nil
	}

	// FrontendIPConfigurations
	frontendIPConfigurationList := make([]v1alpha1api20201101storage.SubResource, len(loadBalancersSpecPropertiesOutboundRules.FrontendIPConfigurations))
	for frontendIPConfigurationIndex, frontendIPConfigurationItem := range loadBalancersSpecPropertiesOutboundRules.FrontendIPConfigurations {
		// Shadow the loop variable to avoid aliasing
		frontendIPConfigurationItem := frontendIPConfigurationItem
		var frontendIPConfiguration v1alpha1api20201101storage.SubResource
		err := frontendIPConfigurationItem.AssignPropertiesToSubResource(&frontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "populating FrontendIPConfigurations from FrontendIPConfigurations, calling AssignPropertiesToSubResource()")
		}
		frontendIPConfigurationList[frontendIPConfigurationIndex] = frontendIPConfiguration
	}
	destination.FrontendIPConfigurations = frontendIPConfigurationList

	// IdleTimeoutInMinutes
	if loadBalancersSpecPropertiesOutboundRules.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinute := *loadBalancersSpecPropertiesOutboundRules.IdleTimeoutInMinutes
		destination.IdleTimeoutInMinutes = &idleTimeoutInMinute
	} else {
		destination.IdleTimeoutInMinutes = nil
	}

	// Name
	if loadBalancersSpecPropertiesOutboundRules.Name != nil {
		name := *loadBalancersSpecPropertiesOutboundRules.Name
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Protocol
	if loadBalancersSpecPropertiesOutboundRules.Protocol != nil {
		protocol := string(*loadBalancersSpecPropertiesOutboundRules.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

type LoadBalancers_Spec_Properties_Probes struct {
	//IntervalInSeconds: The interval, in seconds, for how frequently to probe the
	//endpoint for health status. Typically, the interval is slightly less than half
	//the allocated timeout period (in seconds) which allows two full probes before
	//taking the instance out of rotation. The default value is 15, the minimum value
	//is 5.
	IntervalInSeconds *int `json:"intervalInSeconds,omitempty"`

	// +kubebuilder:validation:Required
	//Name: The name of the resource that is unique within the set of probes used by
	//the load balancer. This name can be used to access the resource.
	Name string `json:"name"`

	//NumberOfProbes: The number of probes where if no response, will result in
	//stopping further traffic from being delivered to the endpoint. This values
	//allows endpoints to be taken out of rotation faster or slower than the typical
	//times used in Azure.
	NumberOfProbes *int `json:"numberOfProbes,omitempty"`

	//Port: The port for communicating the probe. Possible values range from 1 to
	//65535, inclusive.
	Port *int `json:"port,omitempty"`

	//Protocol: The protocol of the end point. If 'Tcp' is specified, a received ACK
	//is required for the probe to be successful. If 'Http' or 'Https' is specified, a
	//200 OK response from the specifies URI is required for the probe to be
	//successful.
	Protocol *ProbePropertiesFormatProtocol `json:"protocol,omitempty"`

	//RequestPath: The URI used for requesting health status from the VM. Path is
	//required if a protocol is set to http. Otherwise, it is not allowed. There is no
	//default value.
	RequestPath *string `json:"requestPath,omitempty"`
}

var _ genruntime.ARMTransformer = &LoadBalancers_Spec_Properties_Probes{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (loadBalancersSpecPropertiesProbes *LoadBalancers_Spec_Properties_Probes) ConvertToARM(name string, resolvedReferences genruntime.ResolvedReferences) (interface{}, error) {
	if loadBalancersSpecPropertiesProbes == nil {
		return nil, nil
	}
	var result LoadBalancers_Spec_Properties_ProbesARM

	// Set property ‘Name’:
	result.Name = loadBalancersSpecPropertiesProbes.Name

	// Set property ‘Properties’:
	if loadBalancersSpecPropertiesProbes.IntervalInSeconds != nil || loadBalancersSpecPropertiesProbes.NumberOfProbes != nil || loadBalancersSpecPropertiesProbes.Port != nil || loadBalancersSpecPropertiesProbes.Protocol != nil || loadBalancersSpecPropertiesProbes.RequestPath != nil {
		result.Properties = &ProbePropertiesFormatARM{}
	}
	if loadBalancersSpecPropertiesProbes.IntervalInSeconds != nil {
		intervalInSeconds := *loadBalancersSpecPropertiesProbes.IntervalInSeconds
		result.Properties.IntervalInSeconds = &intervalInSeconds
	}
	if loadBalancersSpecPropertiesProbes.NumberOfProbes != nil {
		result.Properties.NumberOfProbes = *loadBalancersSpecPropertiesProbes.NumberOfProbes
	}
	if loadBalancersSpecPropertiesProbes.Port != nil {
		result.Properties.Port = *loadBalancersSpecPropertiesProbes.Port
	}
	if loadBalancersSpecPropertiesProbes.Protocol != nil {
		result.Properties.Protocol = *loadBalancersSpecPropertiesProbes.Protocol
	}
	if loadBalancersSpecPropertiesProbes.RequestPath != nil {
		requestPath := *loadBalancersSpecPropertiesProbes.RequestPath
		result.Properties.RequestPath = &requestPath
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (loadBalancersSpecPropertiesProbes *LoadBalancers_Spec_Properties_Probes) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &LoadBalancers_Spec_Properties_ProbesARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (loadBalancersSpecPropertiesProbes *LoadBalancers_Spec_Properties_Probes) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(LoadBalancers_Spec_Properties_ProbesARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LoadBalancers_Spec_Properties_ProbesARM, got %T", armInput)
	}

	// Set property ‘IntervalInSeconds’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IntervalInSeconds != nil {
			intervalInSeconds := *typedInput.Properties.IntervalInSeconds
			loadBalancersSpecPropertiesProbes.IntervalInSeconds = &intervalInSeconds
		}
	}

	// Set property ‘Name’:
	loadBalancersSpecPropertiesProbes.Name = typedInput.Name

	// Set property ‘NumberOfProbes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		loadBalancersSpecPropertiesProbes.NumberOfProbes = &typedInput.Properties.NumberOfProbes
	}

	// Set property ‘Port’:
	// copying flattened property:
	if typedInput.Properties != nil {
		loadBalancersSpecPropertiesProbes.Port = &typedInput.Properties.Port
	}

	// Set property ‘Protocol’:
	// copying flattened property:
	if typedInput.Properties != nil {
		loadBalancersSpecPropertiesProbes.Protocol = &typedInput.Properties.Protocol
	}

	// Set property ‘RequestPath’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RequestPath != nil {
			requestPath := *typedInput.Properties.RequestPath
			loadBalancersSpecPropertiesProbes.RequestPath = &requestPath
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromLoadBalancersSpecPropertiesProbes populates our LoadBalancers_Spec_Properties_Probes from the provided source LoadBalancers_Spec_Properties_Probes
func (loadBalancersSpecPropertiesProbes *LoadBalancers_Spec_Properties_Probes) AssignPropertiesFromLoadBalancersSpecPropertiesProbes(source *v1alpha1api20201101storage.LoadBalancers_Spec_Properties_Probes) error {

	// IntervalInSeconds
	if source.IntervalInSeconds != nil {
		intervalInSecond := *source.IntervalInSeconds
		loadBalancersSpecPropertiesProbes.IntervalInSeconds = &intervalInSecond
	} else {
		loadBalancersSpecPropertiesProbes.IntervalInSeconds = nil
	}

	// Name
	if source.Name != nil {
		loadBalancersSpecPropertiesProbes.Name = *source.Name
	} else {
		loadBalancersSpecPropertiesProbes.Name = ""
	}

	// NumberOfProbes
	if source.NumberOfProbes != nil {
		numberOfProbe := *source.NumberOfProbes
		loadBalancersSpecPropertiesProbes.NumberOfProbes = &numberOfProbe
	} else {
		loadBalancersSpecPropertiesProbes.NumberOfProbes = nil
	}

	// Port
	if source.Port != nil {
		port := *source.Port
		loadBalancersSpecPropertiesProbes.Port = &port
	} else {
		loadBalancersSpecPropertiesProbes.Port = nil
	}

	// Protocol
	if source.Protocol != nil {
		protocol := ProbePropertiesFormatProtocol(*source.Protocol)
		loadBalancersSpecPropertiesProbes.Protocol = &protocol
	} else {
		loadBalancersSpecPropertiesProbes.Protocol = nil
	}

	// RequestPath
	if source.RequestPath != nil {
		requestPath := *source.RequestPath
		loadBalancersSpecPropertiesProbes.RequestPath = &requestPath
	} else {
		loadBalancersSpecPropertiesProbes.RequestPath = nil
	}

	// No error
	return nil
}

// AssignPropertiesToLoadBalancersSpecPropertiesProbes populates the provided destination LoadBalancers_Spec_Properties_Probes from our LoadBalancers_Spec_Properties_Probes
func (loadBalancersSpecPropertiesProbes *LoadBalancers_Spec_Properties_Probes) AssignPropertiesToLoadBalancersSpecPropertiesProbes(destination *v1alpha1api20201101storage.LoadBalancers_Spec_Properties_Probes) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IntervalInSeconds
	if loadBalancersSpecPropertiesProbes.IntervalInSeconds != nil {
		intervalInSecond := *loadBalancersSpecPropertiesProbes.IntervalInSeconds
		destination.IntervalInSeconds = &intervalInSecond
	} else {
		destination.IntervalInSeconds = nil
	}

	// Name
	name := loadBalancersSpecPropertiesProbes.Name
	destination.Name = &name

	// NumberOfProbes
	if loadBalancersSpecPropertiesProbes.NumberOfProbes != nil {
		numberOfProbe := *loadBalancersSpecPropertiesProbes.NumberOfProbes
		destination.NumberOfProbes = &numberOfProbe
	} else {
		destination.NumberOfProbes = nil
	}

	// Port
	if loadBalancersSpecPropertiesProbes.Port != nil {
		port := *loadBalancersSpecPropertiesProbes.Port
		destination.Port = &port
	} else {
		destination.Port = nil
	}

	// Protocol
	if loadBalancersSpecPropertiesProbes.Protocol != nil {
		protocol := string(*loadBalancersSpecPropertiesProbes.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// RequestPath
	if loadBalancersSpecPropertiesProbes.RequestPath != nil {
		requestPath := *loadBalancersSpecPropertiesProbes.RequestPath
		destination.RequestPath = &requestPath
	} else {
		destination.RequestPath = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type LoadBalancingRule_Status struct {
	//BackendAddressPool: A reference to a pool of DIPs. Inbound traffic is randomly
	//load balanced across IPs in the backend IPs.
	BackendAddressPool *SubResource_Status `json:"backendAddressPool,omitempty"`

	//BackendPort: The port used for internal connections on the endpoint. Acceptable
	//values are between 0 and 65535. Note that value 0 enables "Any Port".
	BackendPort *int `json:"backendPort,omitempty"`

	//DisableOutboundSnat: Configures SNAT for the VMs in the backend pool to use the
	//publicIP address specified in the frontend of the load balancing rule.
	DisableOutboundSnat *bool `json:"disableOutboundSnat,omitempty"`

	//EnableFloatingIP: Configures a virtual machine's endpoint for the floating IP
	//capability required to configure a SQL AlwaysOn Availability Group. This setting
	//is required when using the SQL AlwaysOn Availability Groups in SQL server. This
	//setting can't be changed after you create the endpoint.
	EnableFloatingIP *bool `json:"enableFloatingIP,omitempty"`

	//EnableTcpReset: Receive bidirectional TCP Reset on TCP flow idle timeout or
	//unexpected connection termination. This element is only used when the protocol
	//is set to TCP.
	EnableTcpReset *bool `json:"enableTcpReset,omitempty"`

	//Etag: A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	//FrontendIPConfiguration: A reference to frontend IP addresses.
	FrontendIPConfiguration *SubResource_Status `json:"frontendIPConfiguration,omitempty"`

	//FrontendPort: The port for the external endpoint. Port numbers for each rule
	//must be unique within the Load Balancer. Acceptable values are between 0 and
	//65534. Note that value 0 enables "Any Port".
	FrontendPort *int `json:"frontendPort,omitempty"`

	//Id: Resource ID.
	Id *string `json:"id,omitempty"`

	//IdleTimeoutInMinutes: The timeout for the TCP idle connection. The value can be
	//set between 4 and 30 minutes. The default value is 4 minutes. This element is
	//only used when the protocol is set to TCP.
	IdleTimeoutInMinutes *int `json:"idleTimeoutInMinutes,omitempty"`

	//LoadDistribution: The load distribution policy for this rule.
	LoadDistribution *LoadBalancingRulePropertiesFormatStatusLoadDistribution `json:"loadDistribution,omitempty"`

	//Name: The name of the resource that is unique within the set of load balancing
	//rules used by the load balancer. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`

	//Probe: The reference to the load balancer probe used by the load balancing rule.
	Probe *SubResource_Status `json:"probe,omitempty"`

	//Protocol: The reference to the transport protocol used by the load balancing
	//rule.
	Protocol *TransportProtocol_Status `json:"protocol,omitempty"`

	//ProvisioningState: The provisioning state of the load balancing rule resource.
	ProvisioningState *ProvisioningState_Status `json:"provisioningState,omitempty"`

	//Type: Type of the resource.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &LoadBalancingRule_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (loadBalancingRuleStatus *LoadBalancingRule_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &LoadBalancingRule_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (loadBalancingRuleStatus *LoadBalancingRule_Status) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(LoadBalancingRule_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LoadBalancingRule_StatusARM, got %T", armInput)
	}

	// Set property ‘BackendAddressPool’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.BackendAddressPool != nil {
			var backendAddressPool1 SubResource_Status
			err := backendAddressPool1.PopulateFromARM(owner, *typedInput.Properties.BackendAddressPool)
			if err != nil {
				return err
			}
			backendAddressPool := backendAddressPool1
			loadBalancingRuleStatus.BackendAddressPool = &backendAddressPool
		}
	}

	// Set property ‘BackendPort’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.BackendPort != nil {
			backendPort := *typedInput.Properties.BackendPort
			loadBalancingRuleStatus.BackendPort = &backendPort
		}
	}

	// Set property ‘DisableOutboundSnat’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DisableOutboundSnat != nil {
			disableOutboundSnat := *typedInput.Properties.DisableOutboundSnat
			loadBalancingRuleStatus.DisableOutboundSnat = &disableOutboundSnat
		}
	}

	// Set property ‘EnableFloatingIP’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableFloatingIP != nil {
			enableFloatingIP := *typedInput.Properties.EnableFloatingIP
			loadBalancingRuleStatus.EnableFloatingIP = &enableFloatingIP
		}
	}

	// Set property ‘EnableTcpReset’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableTcpReset != nil {
			enableTcpReset := *typedInput.Properties.EnableTcpReset
			loadBalancingRuleStatus.EnableTcpReset = &enableTcpReset
		}
	}

	// Set property ‘Etag’:
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		loadBalancingRuleStatus.Etag = &etag
	}

	// Set property ‘FrontendIPConfiguration’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FrontendIPConfiguration != nil {
			var frontendIPConfiguration1 SubResource_Status
			err := frontendIPConfiguration1.PopulateFromARM(owner, *typedInput.Properties.FrontendIPConfiguration)
			if err != nil {
				return err
			}
			frontendIPConfiguration := frontendIPConfiguration1
			loadBalancingRuleStatus.FrontendIPConfiguration = &frontendIPConfiguration
		}
	}

	// Set property ‘FrontendPort’:
	// copying flattened property:
	if typedInput.Properties != nil {
		loadBalancingRuleStatus.FrontendPort = &typedInput.Properties.FrontendPort
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		loadBalancingRuleStatus.Id = &id
	}

	// Set property ‘IdleTimeoutInMinutes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdleTimeoutInMinutes != nil {
			idleTimeoutInMinutes := *typedInput.Properties.IdleTimeoutInMinutes
			loadBalancingRuleStatus.IdleTimeoutInMinutes = &idleTimeoutInMinutes
		}
	}

	// Set property ‘LoadDistribution’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LoadDistribution != nil {
			loadDistribution := *typedInput.Properties.LoadDistribution
			loadBalancingRuleStatus.LoadDistribution = &loadDistribution
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		loadBalancingRuleStatus.Name = &name
	}

	// Set property ‘Probe’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Probe != nil {
			var probe1 SubResource_Status
			err := probe1.PopulateFromARM(owner, *typedInput.Properties.Probe)
			if err != nil {
				return err
			}
			probe := probe1
			loadBalancingRuleStatus.Probe = &probe
		}
	}

	// Set property ‘Protocol’:
	// copying flattened property:
	if typedInput.Properties != nil {
		loadBalancingRuleStatus.Protocol = &typedInput.Properties.Protocol
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			loadBalancingRuleStatus.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		loadBalancingRuleStatus.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromLoadBalancingRuleStatus populates our LoadBalancingRule_Status from the provided source LoadBalancingRule_Status
func (loadBalancingRuleStatus *LoadBalancingRule_Status) AssignPropertiesFromLoadBalancingRuleStatus(source *v1alpha1api20201101storage.LoadBalancingRule_Status) error {

	// BackendAddressPool
	if source.BackendAddressPool != nil {
		var backendAddressPool SubResource_Status
		err := backendAddressPool.AssignPropertiesFromSubResourceStatus(source.BackendAddressPool)
		if err != nil {
			return errors.Wrap(err, "populating BackendAddressPool from BackendAddressPool, calling AssignPropertiesFromSubResourceStatus()")
		}
		loadBalancingRuleStatus.BackendAddressPool = &backendAddressPool
	} else {
		loadBalancingRuleStatus.BackendAddressPool = nil
	}

	// BackendPort
	if source.BackendPort != nil {
		backendPort := *source.BackendPort
		loadBalancingRuleStatus.BackendPort = &backendPort
	} else {
		loadBalancingRuleStatus.BackendPort = nil
	}

	// DisableOutboundSnat
	if source.DisableOutboundSnat != nil {
		disableOutboundSnat := *source.DisableOutboundSnat
		loadBalancingRuleStatus.DisableOutboundSnat = &disableOutboundSnat
	} else {
		loadBalancingRuleStatus.DisableOutboundSnat = nil
	}

	// EnableFloatingIP
	if source.EnableFloatingIP != nil {
		enableFloatingIP := *source.EnableFloatingIP
		loadBalancingRuleStatus.EnableFloatingIP = &enableFloatingIP
	} else {
		loadBalancingRuleStatus.EnableFloatingIP = nil
	}

	// EnableTcpReset
	if source.EnableTcpReset != nil {
		enableTcpReset := *source.EnableTcpReset
		loadBalancingRuleStatus.EnableTcpReset = &enableTcpReset
	} else {
		loadBalancingRuleStatus.EnableTcpReset = nil
	}

	// Etag
	if source.Etag != nil {
		etag := *source.Etag
		loadBalancingRuleStatus.Etag = &etag
	} else {
		loadBalancingRuleStatus.Etag = nil
	}

	// FrontendIPConfiguration
	if source.FrontendIPConfiguration != nil {
		var frontendIPConfiguration SubResource_Status
		err := frontendIPConfiguration.AssignPropertiesFromSubResourceStatus(source.FrontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "populating FrontendIPConfiguration from FrontendIPConfiguration, calling AssignPropertiesFromSubResourceStatus()")
		}
		loadBalancingRuleStatus.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		loadBalancingRuleStatus.FrontendIPConfiguration = nil
	}

	// FrontendPort
	if source.FrontendPort != nil {
		frontendPort := *source.FrontendPort
		loadBalancingRuleStatus.FrontendPort = &frontendPort
	} else {
		loadBalancingRuleStatus.FrontendPort = nil
	}

	// Id
	if source.Id != nil {
		id := *source.Id
		loadBalancingRuleStatus.Id = &id
	} else {
		loadBalancingRuleStatus.Id = nil
	}

	// IdleTimeoutInMinutes
	if source.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinute := *source.IdleTimeoutInMinutes
		loadBalancingRuleStatus.IdleTimeoutInMinutes = &idleTimeoutInMinute
	} else {
		loadBalancingRuleStatus.IdleTimeoutInMinutes = nil
	}

	// LoadDistribution
	if source.LoadDistribution != nil {
		loadDistribution := LoadBalancingRulePropertiesFormatStatusLoadDistribution(*source.LoadDistribution)
		loadBalancingRuleStatus.LoadDistribution = &loadDistribution
	} else {
		loadBalancingRuleStatus.LoadDistribution = nil
	}

	// Name
	if source.Name != nil {
		name := *source.Name
		loadBalancingRuleStatus.Name = &name
	} else {
		loadBalancingRuleStatus.Name = nil
	}

	// Probe
	if source.Probe != nil {
		var probe SubResource_Status
		err := probe.AssignPropertiesFromSubResourceStatus(source.Probe)
		if err != nil {
			return errors.Wrap(err, "populating Probe from Probe, calling AssignPropertiesFromSubResourceStatus()")
		}
		loadBalancingRuleStatus.Probe = &probe
	} else {
		loadBalancingRuleStatus.Probe = nil
	}

	// Protocol
	if source.Protocol != nil {
		protocol := TransportProtocol_Status(*source.Protocol)
		loadBalancingRuleStatus.Protocol = &protocol
	} else {
		loadBalancingRuleStatus.Protocol = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ProvisioningState_Status(*source.ProvisioningState)
		loadBalancingRuleStatus.ProvisioningState = &provisioningState
	} else {
		loadBalancingRuleStatus.ProvisioningState = nil
	}

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		loadBalancingRuleStatus.Type = &typeVar
	} else {
		loadBalancingRuleStatus.Type = nil
	}

	// No error
	return nil
}

// AssignPropertiesToLoadBalancingRuleStatus populates the provided destination LoadBalancingRule_Status from our LoadBalancingRule_Status
func (loadBalancingRuleStatus *LoadBalancingRule_Status) AssignPropertiesToLoadBalancingRuleStatus(destination *v1alpha1api20201101storage.LoadBalancingRule_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackendAddressPool
	if loadBalancingRuleStatus.BackendAddressPool != nil {
		var backendAddressPool v1alpha1api20201101storage.SubResource_Status
		err := (*loadBalancingRuleStatus.BackendAddressPool).AssignPropertiesToSubResourceStatus(&backendAddressPool)
		if err != nil {
			return errors.Wrap(err, "populating BackendAddressPool from BackendAddressPool, calling AssignPropertiesToSubResourceStatus()")
		}
		destination.BackendAddressPool = &backendAddressPool
	} else {
		destination.BackendAddressPool = nil
	}

	// BackendPort
	if loadBalancingRuleStatus.BackendPort != nil {
		backendPort := *loadBalancingRuleStatus.BackendPort
		destination.BackendPort = &backendPort
	} else {
		destination.BackendPort = nil
	}

	// DisableOutboundSnat
	if loadBalancingRuleStatus.DisableOutboundSnat != nil {
		disableOutboundSnat := *loadBalancingRuleStatus.DisableOutboundSnat
		destination.DisableOutboundSnat = &disableOutboundSnat
	} else {
		destination.DisableOutboundSnat = nil
	}

	// EnableFloatingIP
	if loadBalancingRuleStatus.EnableFloatingIP != nil {
		enableFloatingIP := *loadBalancingRuleStatus.EnableFloatingIP
		destination.EnableFloatingIP = &enableFloatingIP
	} else {
		destination.EnableFloatingIP = nil
	}

	// EnableTcpReset
	if loadBalancingRuleStatus.EnableTcpReset != nil {
		enableTcpReset := *loadBalancingRuleStatus.EnableTcpReset
		destination.EnableTcpReset = &enableTcpReset
	} else {
		destination.EnableTcpReset = nil
	}

	// Etag
	if loadBalancingRuleStatus.Etag != nil {
		etag := *loadBalancingRuleStatus.Etag
		destination.Etag = &etag
	} else {
		destination.Etag = nil
	}

	// FrontendIPConfiguration
	if loadBalancingRuleStatus.FrontendIPConfiguration != nil {
		var frontendIPConfiguration v1alpha1api20201101storage.SubResource_Status
		err := (*loadBalancingRuleStatus.FrontendIPConfiguration).AssignPropertiesToSubResourceStatus(&frontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "populating FrontendIPConfiguration from FrontendIPConfiguration, calling AssignPropertiesToSubResourceStatus()")
		}
		destination.FrontendIPConfiguration = &frontendIPConfiguration
	} else {
		destination.FrontendIPConfiguration = nil
	}

	// FrontendPort
	if loadBalancingRuleStatus.FrontendPort != nil {
		frontendPort := *loadBalancingRuleStatus.FrontendPort
		destination.FrontendPort = &frontendPort
	} else {
		destination.FrontendPort = nil
	}

	// Id
	if loadBalancingRuleStatus.Id != nil {
		id := *loadBalancingRuleStatus.Id
		destination.Id = &id
	} else {
		destination.Id = nil
	}

	// IdleTimeoutInMinutes
	if loadBalancingRuleStatus.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinute := *loadBalancingRuleStatus.IdleTimeoutInMinutes
		destination.IdleTimeoutInMinutes = &idleTimeoutInMinute
	} else {
		destination.IdleTimeoutInMinutes = nil
	}

	// LoadDistribution
	if loadBalancingRuleStatus.LoadDistribution != nil {
		loadDistribution := string(*loadBalancingRuleStatus.LoadDistribution)
		destination.LoadDistribution = &loadDistribution
	} else {
		destination.LoadDistribution = nil
	}

	// Name
	if loadBalancingRuleStatus.Name != nil {
		name := *loadBalancingRuleStatus.Name
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Probe
	if loadBalancingRuleStatus.Probe != nil {
		var probe v1alpha1api20201101storage.SubResource_Status
		err := (*loadBalancingRuleStatus.Probe).AssignPropertiesToSubResourceStatus(&probe)
		if err != nil {
			return errors.Wrap(err, "populating Probe from Probe, calling AssignPropertiesToSubResourceStatus()")
		}
		destination.Probe = &probe
	} else {
		destination.Probe = nil
	}

	// Protocol
	if loadBalancingRuleStatus.Protocol != nil {
		protocol := string(*loadBalancingRuleStatus.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// ProvisioningState
	if loadBalancingRuleStatus.ProvisioningState != nil {
		provisioningState := string(*loadBalancingRuleStatus.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// Type
	if loadBalancingRuleStatus.Type != nil {
		typeVar := *loadBalancingRuleStatus.Type
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type OutboundRule_Status struct {
	//AllocatedOutboundPorts: The number of outbound ports to be used for NAT.
	AllocatedOutboundPorts *int `json:"allocatedOutboundPorts,omitempty"`

	//BackendAddressPool: A reference to a pool of DIPs. Outbound traffic is randomly
	//load balanced across IPs in the backend IPs.
	BackendAddressPool *SubResource_Status `json:"backendAddressPool,omitempty"`

	//EnableTcpReset: Receive bidirectional TCP Reset on TCP flow idle timeout or
	//unexpected connection termination. This element is only used when the protocol
	//is set to TCP.
	EnableTcpReset *bool `json:"enableTcpReset,omitempty"`

	//Etag: A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	//FrontendIPConfigurations: The Frontend IP addresses of the load balancer.
	FrontendIPConfigurations []SubResource_Status `json:"frontendIPConfigurations,omitempty"`

	//Id: Resource ID.
	Id *string `json:"id,omitempty"`

	//IdleTimeoutInMinutes: The timeout for the TCP idle connection.
	IdleTimeoutInMinutes *int `json:"idleTimeoutInMinutes,omitempty"`

	//Name: The name of the resource that is unique within the set of outbound rules
	//used by the load balancer. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`

	//Protocol: The protocol for the outbound rule in load balancer.
	Protocol *OutboundRulePropertiesFormatStatusProtocol `json:"protocol,omitempty"`

	//ProvisioningState: The provisioning state of the outbound rule resource.
	ProvisioningState *ProvisioningState_Status `json:"provisioningState,omitempty"`

	//Type: Type of the resource.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &OutboundRule_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (outboundRuleStatus *OutboundRule_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &OutboundRule_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (outboundRuleStatus *OutboundRule_Status) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(OutboundRule_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected OutboundRule_StatusARM, got %T", armInput)
	}

	// Set property ‘AllocatedOutboundPorts’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AllocatedOutboundPorts != nil {
			allocatedOutboundPorts := *typedInput.Properties.AllocatedOutboundPorts
			outboundRuleStatus.AllocatedOutboundPorts = &allocatedOutboundPorts
		}
	}

	// Set property ‘BackendAddressPool’:
	// copying flattened property:
	if typedInput.Properties != nil {
		var temp SubResource_Status
		var temp1 SubResource_Status
		err := temp1.PopulateFromARM(owner, typedInput.Properties.BackendAddressPool)
		if err != nil {
			return err
		}
		temp = temp1
		outboundRuleStatus.BackendAddressPool = &temp
	}

	// Set property ‘EnableTcpReset’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableTcpReset != nil {
			enableTcpReset := *typedInput.Properties.EnableTcpReset
			outboundRuleStatus.EnableTcpReset = &enableTcpReset
		}
	}

	// Set property ‘Etag’:
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		outboundRuleStatus.Etag = &etag
	}

	// Set property ‘FrontendIPConfigurations’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.FrontendIPConfigurations {
			var item1 SubResource_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			outboundRuleStatus.FrontendIPConfigurations = append(outboundRuleStatus.FrontendIPConfigurations, item1)
		}
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		outboundRuleStatus.Id = &id
	}

	// Set property ‘IdleTimeoutInMinutes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdleTimeoutInMinutes != nil {
			idleTimeoutInMinutes := *typedInput.Properties.IdleTimeoutInMinutes
			outboundRuleStatus.IdleTimeoutInMinutes = &idleTimeoutInMinutes
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		outboundRuleStatus.Name = &name
	}

	// Set property ‘Protocol’:
	// copying flattened property:
	if typedInput.Properties != nil {
		outboundRuleStatus.Protocol = &typedInput.Properties.Protocol
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			outboundRuleStatus.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		outboundRuleStatus.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromOutboundRuleStatus populates our OutboundRule_Status from the provided source OutboundRule_Status
func (outboundRuleStatus *OutboundRule_Status) AssignPropertiesFromOutboundRuleStatus(source *v1alpha1api20201101storage.OutboundRule_Status) error {

	// AllocatedOutboundPorts
	if source.AllocatedOutboundPorts != nil {
		allocatedOutboundPort := *source.AllocatedOutboundPorts
		outboundRuleStatus.AllocatedOutboundPorts = &allocatedOutboundPort
	} else {
		outboundRuleStatus.AllocatedOutboundPorts = nil
	}

	// BackendAddressPool
	if source.BackendAddressPool != nil {
		var backendAddressPool SubResource_Status
		err := backendAddressPool.AssignPropertiesFromSubResourceStatus(source.BackendAddressPool)
		if err != nil {
			return errors.Wrap(err, "populating BackendAddressPool from BackendAddressPool, calling AssignPropertiesFromSubResourceStatus()")
		}
		outboundRuleStatus.BackendAddressPool = &backendAddressPool
	} else {
		outboundRuleStatus.BackendAddressPool = nil
	}

	// EnableTcpReset
	if source.EnableTcpReset != nil {
		enableTcpReset := *source.EnableTcpReset
		outboundRuleStatus.EnableTcpReset = &enableTcpReset
	} else {
		outboundRuleStatus.EnableTcpReset = nil
	}

	// Etag
	if source.Etag != nil {
		etag := *source.Etag
		outboundRuleStatus.Etag = &etag
	} else {
		outboundRuleStatus.Etag = nil
	}

	// FrontendIPConfigurations
	frontendIPConfigurationList := make([]SubResource_Status, len(source.FrontendIPConfigurations))
	for frontendIPConfigurationIndex, frontendIPConfigurationItem := range source.FrontendIPConfigurations {
		// Shadow the loop variable to avoid aliasing
		frontendIPConfigurationItem := frontendIPConfigurationItem
		var frontendIPConfiguration SubResource_Status
		err := frontendIPConfiguration.AssignPropertiesFromSubResourceStatus(&frontendIPConfigurationItem)
		if err != nil {
			return errors.Wrap(err, "populating FrontendIPConfigurations from FrontendIPConfigurations, calling AssignPropertiesFromSubResourceStatus()")
		}
		frontendIPConfigurationList[frontendIPConfigurationIndex] = frontendIPConfiguration
	}
	outboundRuleStatus.FrontendIPConfigurations = frontendIPConfigurationList

	// Id
	if source.Id != nil {
		id := *source.Id
		outboundRuleStatus.Id = &id
	} else {
		outboundRuleStatus.Id = nil
	}

	// IdleTimeoutInMinutes
	if source.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinute := *source.IdleTimeoutInMinutes
		outboundRuleStatus.IdleTimeoutInMinutes = &idleTimeoutInMinute
	} else {
		outboundRuleStatus.IdleTimeoutInMinutes = nil
	}

	// Name
	if source.Name != nil {
		name := *source.Name
		outboundRuleStatus.Name = &name
	} else {
		outboundRuleStatus.Name = nil
	}

	// Protocol
	if source.Protocol != nil {
		protocol := OutboundRulePropertiesFormatStatusProtocol(*source.Protocol)
		outboundRuleStatus.Protocol = &protocol
	} else {
		outboundRuleStatus.Protocol = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ProvisioningState_Status(*source.ProvisioningState)
		outboundRuleStatus.ProvisioningState = &provisioningState
	} else {
		outboundRuleStatus.ProvisioningState = nil
	}

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		outboundRuleStatus.Type = &typeVar
	} else {
		outboundRuleStatus.Type = nil
	}

	// No error
	return nil
}

// AssignPropertiesToOutboundRuleStatus populates the provided destination OutboundRule_Status from our OutboundRule_Status
func (outboundRuleStatus *OutboundRule_Status) AssignPropertiesToOutboundRuleStatus(destination *v1alpha1api20201101storage.OutboundRule_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllocatedOutboundPorts
	if outboundRuleStatus.AllocatedOutboundPorts != nil {
		allocatedOutboundPort := *outboundRuleStatus.AllocatedOutboundPorts
		destination.AllocatedOutboundPorts = &allocatedOutboundPort
	} else {
		destination.AllocatedOutboundPorts = nil
	}

	// BackendAddressPool
	if outboundRuleStatus.BackendAddressPool != nil {
		var backendAddressPool v1alpha1api20201101storage.SubResource_Status
		err := (*outboundRuleStatus.BackendAddressPool).AssignPropertiesToSubResourceStatus(&backendAddressPool)
		if err != nil {
			return errors.Wrap(err, "populating BackendAddressPool from BackendAddressPool, calling AssignPropertiesToSubResourceStatus()")
		}
		destination.BackendAddressPool = &backendAddressPool
	} else {
		destination.BackendAddressPool = nil
	}

	// EnableTcpReset
	if outboundRuleStatus.EnableTcpReset != nil {
		enableTcpReset := *outboundRuleStatus.EnableTcpReset
		destination.EnableTcpReset = &enableTcpReset
	} else {
		destination.EnableTcpReset = nil
	}

	// Etag
	if outboundRuleStatus.Etag != nil {
		etag := *outboundRuleStatus.Etag
		destination.Etag = &etag
	} else {
		destination.Etag = nil
	}

	// FrontendIPConfigurations
	frontendIPConfigurationList := make([]v1alpha1api20201101storage.SubResource_Status, len(outboundRuleStatus.FrontendIPConfigurations))
	for frontendIPConfigurationIndex, frontendIPConfigurationItem := range outboundRuleStatus.FrontendIPConfigurations {
		// Shadow the loop variable to avoid aliasing
		frontendIPConfigurationItem := frontendIPConfigurationItem
		var frontendIPConfiguration v1alpha1api20201101storage.SubResource_Status
		err := frontendIPConfigurationItem.AssignPropertiesToSubResourceStatus(&frontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "populating FrontendIPConfigurations from FrontendIPConfigurations, calling AssignPropertiesToSubResourceStatus()")
		}
		frontendIPConfigurationList[frontendIPConfigurationIndex] = frontendIPConfiguration
	}
	destination.FrontendIPConfigurations = frontendIPConfigurationList

	// Id
	if outboundRuleStatus.Id != nil {
		id := *outboundRuleStatus.Id
		destination.Id = &id
	} else {
		destination.Id = nil
	}

	// IdleTimeoutInMinutes
	if outboundRuleStatus.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinute := *outboundRuleStatus.IdleTimeoutInMinutes
		destination.IdleTimeoutInMinutes = &idleTimeoutInMinute
	} else {
		destination.IdleTimeoutInMinutes = nil
	}

	// Name
	if outboundRuleStatus.Name != nil {
		name := *outboundRuleStatus.Name
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Protocol
	if outboundRuleStatus.Protocol != nil {
		protocol := string(*outboundRuleStatus.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// ProvisioningState
	if outboundRuleStatus.ProvisioningState != nil {
		provisioningState := string(*outboundRuleStatus.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// Type
	if outboundRuleStatus.Type != nil {
		typeVar := *outboundRuleStatus.Type
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type Probe_Status struct {
	//Etag: A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	//Id: Resource ID.
	Id *string `json:"id,omitempty"`

	//IntervalInSeconds: The interval, in seconds, for how frequently to probe the
	//endpoint for health status. Typically, the interval is slightly less than half
	//the allocated timeout period (in seconds) which allows two full probes before
	//taking the instance out of rotation. The default value is 15, the minimum value
	//is 5.
	IntervalInSeconds *int `json:"intervalInSeconds,omitempty"`

	//LoadBalancingRules: The load balancer rules that use this probe.
	LoadBalancingRules []SubResource_Status `json:"loadBalancingRules,omitempty"`

	//Name: The name of the resource that is unique within the set of probes used by
	//the load balancer. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`

	//NumberOfProbes: The number of probes where if no response, will result in
	//stopping further traffic from being delivered to the endpoint. This values
	//allows endpoints to be taken out of rotation faster or slower than the typical
	//times used in Azure.
	NumberOfProbes *int `json:"numberOfProbes,omitempty"`

	//Port: The port for communicating the probe. Possible values range from 1 to
	//65535, inclusive.
	Port *int `json:"port,omitempty"`

	//Protocol: The protocol of the end point. If 'Tcp' is specified, a received ACK
	//is required for the probe to be successful. If 'Http' or 'Https' is specified, a
	//200 OK response from the specifies URI is required for the probe to be
	//successful.
	Protocol *ProbePropertiesFormatStatusProtocol `json:"protocol,omitempty"`

	//ProvisioningState: The provisioning state of the probe resource.
	ProvisioningState *ProvisioningState_Status `json:"provisioningState,omitempty"`

	//RequestPath: The URI used for requesting health status from the VM. Path is
	//required if a protocol is set to http. Otherwise, it is not allowed. There is no
	//default value.
	RequestPath *string `json:"requestPath,omitempty"`

	//Type: Type of the resource.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &Probe_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (probeStatus *Probe_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &Probe_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (probeStatus *Probe_Status) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(Probe_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Probe_StatusARM, got %T", armInput)
	}

	// Set property ‘Etag’:
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		probeStatus.Etag = &etag
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		probeStatus.Id = &id
	}

	// Set property ‘IntervalInSeconds’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IntervalInSeconds != nil {
			intervalInSeconds := *typedInput.Properties.IntervalInSeconds
			probeStatus.IntervalInSeconds = &intervalInSeconds
		}
	}

	// Set property ‘LoadBalancingRules’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancingRules {
			var item1 SubResource_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			probeStatus.LoadBalancingRules = append(probeStatus.LoadBalancingRules, item1)
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		probeStatus.Name = &name
	}

	// Set property ‘NumberOfProbes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NumberOfProbes != nil {
			numberOfProbes := *typedInput.Properties.NumberOfProbes
			probeStatus.NumberOfProbes = &numberOfProbes
		}
	}

	// Set property ‘Port’:
	// copying flattened property:
	if typedInput.Properties != nil {
		probeStatus.Port = &typedInput.Properties.Port
	}

	// Set property ‘Protocol’:
	// copying flattened property:
	if typedInput.Properties != nil {
		probeStatus.Protocol = &typedInput.Properties.Protocol
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			probeStatus.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘RequestPath’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RequestPath != nil {
			requestPath := *typedInput.Properties.RequestPath
			probeStatus.RequestPath = &requestPath
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		probeStatus.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromProbeStatus populates our Probe_Status from the provided source Probe_Status
func (probeStatus *Probe_Status) AssignPropertiesFromProbeStatus(source *v1alpha1api20201101storage.Probe_Status) error {

	// Etag
	if source.Etag != nil {
		etag := *source.Etag
		probeStatus.Etag = &etag
	} else {
		probeStatus.Etag = nil
	}

	// Id
	if source.Id != nil {
		id := *source.Id
		probeStatus.Id = &id
	} else {
		probeStatus.Id = nil
	}

	// IntervalInSeconds
	if source.IntervalInSeconds != nil {
		intervalInSecond := *source.IntervalInSeconds
		probeStatus.IntervalInSeconds = &intervalInSecond
	} else {
		probeStatus.IntervalInSeconds = nil
	}

	// LoadBalancingRules
	loadBalancingRuleList := make([]SubResource_Status, len(source.LoadBalancingRules))
	for loadBalancingRuleIndex, loadBalancingRuleItem := range source.LoadBalancingRules {
		// Shadow the loop variable to avoid aliasing
		loadBalancingRuleItem := loadBalancingRuleItem
		var loadBalancingRule SubResource_Status
		err := loadBalancingRule.AssignPropertiesFromSubResourceStatus(&loadBalancingRuleItem)
		if err != nil {
			return errors.Wrap(err, "populating LoadBalancingRules from LoadBalancingRules, calling AssignPropertiesFromSubResourceStatus()")
		}
		loadBalancingRuleList[loadBalancingRuleIndex] = loadBalancingRule
	}
	probeStatus.LoadBalancingRules = loadBalancingRuleList

	// Name
	if source.Name != nil {
		name := *source.Name
		probeStatus.Name = &name
	} else {
		probeStatus.Name = nil
	}

	// NumberOfProbes
	if source.NumberOfProbes != nil {
		numberOfProbe := *source.NumberOfProbes
		probeStatus.NumberOfProbes = &numberOfProbe
	} else {
		probeStatus.NumberOfProbes = nil
	}

	// Port
	if source.Port != nil {
		port := *source.Port
		probeStatus.Port = &port
	} else {
		probeStatus.Port = nil
	}

	// Protocol
	if source.Protocol != nil {
		protocol := ProbePropertiesFormatStatusProtocol(*source.Protocol)
		probeStatus.Protocol = &protocol
	} else {
		probeStatus.Protocol = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ProvisioningState_Status(*source.ProvisioningState)
		probeStatus.ProvisioningState = &provisioningState
	} else {
		probeStatus.ProvisioningState = nil
	}

	// RequestPath
	if source.RequestPath != nil {
		requestPath := *source.RequestPath
		probeStatus.RequestPath = &requestPath
	} else {
		probeStatus.RequestPath = nil
	}

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		probeStatus.Type = &typeVar
	} else {
		probeStatus.Type = nil
	}

	// No error
	return nil
}

// AssignPropertiesToProbeStatus populates the provided destination Probe_Status from our Probe_Status
func (probeStatus *Probe_Status) AssignPropertiesToProbeStatus(destination *v1alpha1api20201101storage.Probe_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Etag
	if probeStatus.Etag != nil {
		etag := *probeStatus.Etag
		destination.Etag = &etag
	} else {
		destination.Etag = nil
	}

	// Id
	if probeStatus.Id != nil {
		id := *probeStatus.Id
		destination.Id = &id
	} else {
		destination.Id = nil
	}

	// IntervalInSeconds
	if probeStatus.IntervalInSeconds != nil {
		intervalInSecond := *probeStatus.IntervalInSeconds
		destination.IntervalInSeconds = &intervalInSecond
	} else {
		destination.IntervalInSeconds = nil
	}

	// LoadBalancingRules
	loadBalancingRuleList := make([]v1alpha1api20201101storage.SubResource_Status, len(probeStatus.LoadBalancingRules))
	for loadBalancingRuleIndex, loadBalancingRuleItem := range probeStatus.LoadBalancingRules {
		// Shadow the loop variable to avoid aliasing
		loadBalancingRuleItem := loadBalancingRuleItem
		var loadBalancingRule v1alpha1api20201101storage.SubResource_Status
		err := loadBalancingRuleItem.AssignPropertiesToSubResourceStatus(&loadBalancingRule)
		if err != nil {
			return errors.Wrap(err, "populating LoadBalancingRules from LoadBalancingRules, calling AssignPropertiesToSubResourceStatus()")
		}
		loadBalancingRuleList[loadBalancingRuleIndex] = loadBalancingRule
	}
	destination.LoadBalancingRules = loadBalancingRuleList

	// Name
	if probeStatus.Name != nil {
		name := *probeStatus.Name
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// NumberOfProbes
	if probeStatus.NumberOfProbes != nil {
		numberOfProbe := *probeStatus.NumberOfProbes
		destination.NumberOfProbes = &numberOfProbe
	} else {
		destination.NumberOfProbes = nil
	}

	// Port
	if probeStatus.Port != nil {
		port := *probeStatus.Port
		destination.Port = &port
	} else {
		destination.Port = nil
	}

	// Protocol
	if probeStatus.Protocol != nil {
		protocol := string(*probeStatus.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// ProvisioningState
	if probeStatus.ProvisioningState != nil {
		provisioningState := string(*probeStatus.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// RequestPath
	if probeStatus.RequestPath != nil {
		requestPath := *probeStatus.RequestPath
		destination.RequestPath = &requestPath
	} else {
		destination.RequestPath = nil
	}

	// Type
	if probeStatus.Type != nil {
		typeVar := *probeStatus.Type
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type ProvisioningState_Status string

const (
	ProvisioningState_StatusDeleting  = ProvisioningState_Status("Deleting")
	ProvisioningState_StatusFailed    = ProvisioningState_Status("Failed")
	ProvisioningState_StatusSucceeded = ProvisioningState_Status("Succeeded")
	ProvisioningState_StatusUpdating  = ProvisioningState_Status("Updating")
)

// +kubebuilder:validation:Enum={"IPv4","IPv6"}
type FrontendIPConfigurationPropertiesFormatPrivateIPAddressVersion string

const (
	FrontendIPConfigurationPropertiesFormatPrivateIPAddressVersionIPv4 = FrontendIPConfigurationPropertiesFormatPrivateIPAddressVersion("IPv4")
	FrontendIPConfigurationPropertiesFormatPrivateIPAddressVersionIPv6 = FrontendIPConfigurationPropertiesFormatPrivateIPAddressVersion("IPv6")
)

// +kubebuilder:validation:Enum={"Dynamic","Static"}
type FrontendIPConfigurationPropertiesFormatPrivateIPAllocationMethod string

const (
	FrontendIPConfigurationPropertiesFormatPrivateIPAllocationMethodDynamic = FrontendIPConfigurationPropertiesFormatPrivateIPAllocationMethod("Dynamic")
	FrontendIPConfigurationPropertiesFormatPrivateIPAllocationMethodStatic  = FrontendIPConfigurationPropertiesFormatPrivateIPAllocationMethod("Static")
)

// +kubebuilder:validation:Enum={"All","Tcp","Udp"}
type InboundNatPoolPropertiesFormatProtocol string

const (
	InboundNatPoolPropertiesFormatProtocolAll = InboundNatPoolPropertiesFormatProtocol("All")
	InboundNatPoolPropertiesFormatProtocolTcp = InboundNatPoolPropertiesFormatProtocol("Tcp")
	InboundNatPoolPropertiesFormatProtocolUdp = InboundNatPoolPropertiesFormatProtocol("Udp")
)

type LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses struct {
	//IpAddress: IP Address belonging to the referenced virtual network.
	IpAddress *string `json:"ipAddress,omitempty"`

	//LoadBalancerFrontendIPConfiguration: Reference to the frontend ip address
	//configuration defined in regional loadbalancer.
	LoadBalancerFrontendIPConfiguration *SubResource `json:"loadBalancerFrontendIPConfiguration,omitempty"`

	//Name: Name of the backend address.
	Name *string `json:"name,omitempty"`

	//Subnet: Reference to an existing subnet.
	Subnet *SubResource `json:"subnet,omitempty"`

	//VirtualNetwork: Reference to an existing virtual network.
	VirtualNetwork *SubResource `json:"virtualNetwork,omitempty"`
}

var _ genruntime.ARMTransformer = &LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses *LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses) ConvertToARM(name string, resolvedReferences genruntime.ResolvedReferences) (interface{}, error) {
	if loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses == nil {
		return nil, nil
	}
	var result LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARM

	// Set property ‘Name’:
	if loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses.Name != nil {
		name := *loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses.Name
		result.Name = &name
	}

	// Set property ‘Properties’:
	if loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses.IpAddress != nil || loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses.LoadBalancerFrontendIPConfiguration != nil || loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses.Subnet != nil || loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses.VirtualNetwork != nil {
		result.Properties = &LoadBalancerBackendAddressPropertiesFormatARM{}
	}
	if loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses.IpAddress != nil {
		ipAddress := *loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses.IpAddress
		result.Properties.IpAddress = &ipAddress
	}
	if loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses.LoadBalancerFrontendIPConfiguration != nil {
		loadBalancerFrontendIPConfigurationARM, err := (*loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses.LoadBalancerFrontendIPConfiguration).ConvertToARM(name, resolvedReferences)
		if err != nil {
			return nil, err
		}
		loadBalancerFrontendIPConfiguration := loadBalancerFrontendIPConfigurationARM.(SubResourceARM)
		result.Properties.LoadBalancerFrontendIPConfiguration = &loadBalancerFrontendIPConfiguration
	}
	if loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses.Subnet != nil {
		subnetARM, err := (*loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses.Subnet).ConvertToARM(name, resolvedReferences)
		if err != nil {
			return nil, err
		}
		subnet := subnetARM.(SubResourceARM)
		result.Properties.Subnet = &subnet
	}
	if loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses.VirtualNetwork != nil {
		virtualNetworkARM, err := (*loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses.VirtualNetwork).ConvertToARM(name, resolvedReferences)
		if err != nil {
			return nil, err
		}
		virtualNetwork := virtualNetworkARM.(SubResourceARM)
		result.Properties.VirtualNetwork = &virtualNetwork
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses *LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses *LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddressesARM, got %T", armInput)
	}

	// Set property ‘IpAddress’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IpAddress != nil {
			ipAddress := *typedInput.Properties.IpAddress
			loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses.IpAddress = &ipAddress
		}
	}

	// Set property ‘LoadBalancerFrontendIPConfiguration’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LoadBalancerFrontendIPConfiguration != nil {
			var loadBalancerFrontendIPConfiguration1 SubResource
			err := loadBalancerFrontendIPConfiguration1.PopulateFromARM(owner, *typedInput.Properties.LoadBalancerFrontendIPConfiguration)
			if err != nil {
				return err
			}
			loadBalancerFrontendIPConfiguration := loadBalancerFrontendIPConfiguration1
			loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses.LoadBalancerFrontendIPConfiguration = &loadBalancerFrontendIPConfiguration
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses.Name = &name
	}

	// Set property ‘Subnet’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Subnet != nil {
			var subnet1 SubResource
			err := subnet1.PopulateFromARM(owner, *typedInput.Properties.Subnet)
			if err != nil {
				return err
			}
			subnet := subnet1
			loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses.Subnet = &subnet
		}
	}

	// Set property ‘VirtualNetwork’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VirtualNetwork != nil {
			var virtualNetwork1 SubResource
			err := virtualNetwork1.PopulateFromARM(owner, *typedInput.Properties.VirtualNetwork)
			if err != nil {
				return err
			}
			virtualNetwork := virtualNetwork1
			loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses.VirtualNetwork = &virtualNetwork
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromLoadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses populates our LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses from the provided source LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses
func (loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses *LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses) AssignPropertiesFromLoadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses(source *v1alpha1api20201101storage.LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses) error {

	// IpAddress
	if source.IpAddress != nil {
		ipAddress := *source.IpAddress
		loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses.IpAddress = &ipAddress
	} else {
		loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses.IpAddress = nil
	}

	// LoadBalancerFrontendIPConfiguration
	if source.LoadBalancerFrontendIPConfiguration != nil {
		var loadBalancerFrontendIPConfiguration SubResource
		err := loadBalancerFrontendIPConfiguration.AssignPropertiesFromSubResource(source.LoadBalancerFrontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "populating LoadBalancerFrontendIPConfiguration from LoadBalancerFrontendIPConfiguration, calling AssignPropertiesFromSubResource()")
		}
		loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses.LoadBalancerFrontendIPConfiguration = &loadBalancerFrontendIPConfiguration
	} else {
		loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses.LoadBalancerFrontendIPConfiguration = nil
	}

	// Name
	if source.Name != nil {
		name := *source.Name
		loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses.Name = &name
	} else {
		loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses.Name = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet SubResource
		err := subnet.AssignPropertiesFromSubResource(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "populating Subnet from Subnet, calling AssignPropertiesFromSubResource()")
		}
		loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses.Subnet = &subnet
	} else {
		loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses.Subnet = nil
	}

	// VirtualNetwork
	if source.VirtualNetwork != nil {
		var virtualNetwork SubResource
		err := virtualNetwork.AssignPropertiesFromSubResource(source.VirtualNetwork)
		if err != nil {
			return errors.Wrap(err, "populating VirtualNetwork from VirtualNetwork, calling AssignPropertiesFromSubResource()")
		}
		loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses.VirtualNetwork = &virtualNetwork
	} else {
		loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses.VirtualNetwork = nil
	}

	// No error
	return nil
}

// AssignPropertiesToLoadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses populates the provided destination LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses from our LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses
func (loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses *LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses) AssignPropertiesToLoadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses(destination *v1alpha1api20201101storage.LoadBalancers_Spec_Properties_BackendAddressPools_Properties_LoadBalancerBackendAddresses) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IpAddress
	if loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses.IpAddress != nil {
		ipAddress := *loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses.IpAddress
		destination.IpAddress = &ipAddress
	} else {
		destination.IpAddress = nil
	}

	// LoadBalancerFrontendIPConfiguration
	if loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses.LoadBalancerFrontendIPConfiguration != nil {
		var loadBalancerFrontendIPConfiguration v1alpha1api20201101storage.SubResource
		err := (*loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses.LoadBalancerFrontendIPConfiguration).AssignPropertiesToSubResource(&loadBalancerFrontendIPConfiguration)
		if err != nil {
			return errors.Wrap(err, "populating LoadBalancerFrontendIPConfiguration from LoadBalancerFrontendIPConfiguration, calling AssignPropertiesToSubResource()")
		}
		destination.LoadBalancerFrontendIPConfiguration = &loadBalancerFrontendIPConfiguration
	} else {
		destination.LoadBalancerFrontendIPConfiguration = nil
	}

	// Name
	if loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses.Name != nil {
		name := *loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses.Name
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Subnet
	if loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses.Subnet != nil {
		var subnet v1alpha1api20201101storage.SubResource
		err := (*loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses.Subnet).AssignPropertiesToSubResource(&subnet)
		if err != nil {
			return errors.Wrap(err, "populating Subnet from Subnet, calling AssignPropertiesToSubResource()")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// VirtualNetwork
	if loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses.VirtualNetwork != nil {
		var virtualNetwork v1alpha1api20201101storage.SubResource
		err := (*loadBalancersSpecPropertiesBackendAddressPoolsPropertiesLoadBalancerBackendAddresses.VirtualNetwork).AssignPropertiesToSubResource(&virtualNetwork)
		if err != nil {
			return errors.Wrap(err, "populating VirtualNetwork from VirtualNetwork, calling AssignPropertiesToSubResource()")
		}
		destination.VirtualNetwork = &virtualNetwork
	} else {
		destination.VirtualNetwork = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Default","SourceIP","SourceIPProtocol"}
type LoadBalancingRulePropertiesFormatLoadDistribution string

const (
	LoadBalancingRulePropertiesFormatLoadDistributionDefault          = LoadBalancingRulePropertiesFormatLoadDistribution("Default")
	LoadBalancingRulePropertiesFormatLoadDistributionSourceIP         = LoadBalancingRulePropertiesFormatLoadDistribution("SourceIP")
	LoadBalancingRulePropertiesFormatLoadDistributionSourceIPProtocol = LoadBalancingRulePropertiesFormatLoadDistribution("SourceIPProtocol")
)

// +kubebuilder:validation:Enum={"All","Tcp","Udp"}
type LoadBalancingRulePropertiesFormatProtocol string

const (
	LoadBalancingRulePropertiesFormatProtocolAll = LoadBalancingRulePropertiesFormatProtocol("All")
	LoadBalancingRulePropertiesFormatProtocolTcp = LoadBalancingRulePropertiesFormatProtocol("Tcp")
	LoadBalancingRulePropertiesFormatProtocolUdp = LoadBalancingRulePropertiesFormatProtocol("Udp")
)

type LoadBalancingRulePropertiesFormatStatusLoadDistribution string

const (
	LoadBalancingRulePropertiesFormatStatusLoadDistributionDefault          = LoadBalancingRulePropertiesFormatStatusLoadDistribution("Default")
	LoadBalancingRulePropertiesFormatStatusLoadDistributionSourceIP         = LoadBalancingRulePropertiesFormatStatusLoadDistribution("SourceIP")
	LoadBalancingRulePropertiesFormatStatusLoadDistributionSourceIPProtocol = LoadBalancingRulePropertiesFormatStatusLoadDistribution("SourceIPProtocol")
)

// +kubebuilder:validation:Enum={"All","Tcp","Udp"}
type OutboundRulePropertiesFormatProtocol string

const (
	OutboundRulePropertiesFormatProtocolAll = OutboundRulePropertiesFormatProtocol("All")
	OutboundRulePropertiesFormatProtocolTcp = OutboundRulePropertiesFormatProtocol("Tcp")
	OutboundRulePropertiesFormatProtocolUdp = OutboundRulePropertiesFormatProtocol("Udp")
)

type OutboundRulePropertiesFormatStatusProtocol string

const (
	OutboundRulePropertiesFormatStatusProtocolAll = OutboundRulePropertiesFormatStatusProtocol("All")
	OutboundRulePropertiesFormatStatusProtocolTcp = OutboundRulePropertiesFormatStatusProtocol("Tcp")
	OutboundRulePropertiesFormatStatusProtocolUdp = OutboundRulePropertiesFormatStatusProtocol("Udp")
)

// +kubebuilder:validation:Enum={"Http","Https","Tcp"}
type ProbePropertiesFormatProtocol string

const (
	ProbePropertiesFormatProtocolHttp  = ProbePropertiesFormatProtocol("Http")
	ProbePropertiesFormatProtocolHttps = ProbePropertiesFormatProtocol("Https")
	ProbePropertiesFormatProtocolTcp   = ProbePropertiesFormatProtocol("Tcp")
)

type ProbePropertiesFormatStatusProtocol string

const (
	ProbePropertiesFormatStatusProtocolHttp  = ProbePropertiesFormatStatusProtocol("Http")
	ProbePropertiesFormatStatusProtocolHttps = ProbePropertiesFormatStatusProtocol("Https")
	ProbePropertiesFormatStatusProtocolTcp   = ProbePropertiesFormatStatusProtocol("Tcp")
)

//Generated from:
type PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded struct {
	//ExtendedLocation: The extended location of the public ip address.
	ExtendedLocation *ExtendedLocation_Status `json:"extendedLocation,omitempty"`

	//Id: Resource ID.
	Id *string `json:"id,omitempty"`

	//Sku: The public IP address SKU.
	Sku *PublicIPAddressSku_Status `json:"sku,omitempty"`

	//Zones: A list of availability zones denoting the IP allocated for the resource
	//needs to come from.
	Zones []string `json:"zones,omitempty"`
}

var _ genruntime.FromARMConverter = &PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (publicIPAddressStatusLoadBalancerSubResourceEmbedded *PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &PublicIPAddress_Status_LoadBalancer_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (publicIPAddressStatusLoadBalancerSubResourceEmbedded *PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(PublicIPAddress_Status_LoadBalancer_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PublicIPAddress_Status_LoadBalancer_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘ExtendedLocation’:
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation_Status
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		publicIPAddressStatusLoadBalancerSubResourceEmbedded.ExtendedLocation = &extendedLocation
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		publicIPAddressStatusLoadBalancerSubResourceEmbedded.Id = &id
	}

	// Set property ‘Sku’:
	if typedInput.Sku != nil {
		var sku1 PublicIPAddressSku_Status
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		publicIPAddressStatusLoadBalancerSubResourceEmbedded.Sku = &sku
	}

	// Set property ‘Zones’:
	for _, item := range typedInput.Zones {
		publicIPAddressStatusLoadBalancerSubResourceEmbedded.Zones = append(publicIPAddressStatusLoadBalancerSubResourceEmbedded.Zones, item)
	}

	// No error
	return nil
}

// AssignPropertiesFromPublicIPAddressStatusLoadBalancerSubResourceEmbedded populates our PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded from the provided source PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded
func (publicIPAddressStatusLoadBalancerSubResourceEmbedded *PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded) AssignPropertiesFromPublicIPAddressStatusLoadBalancerSubResourceEmbedded(source *v1alpha1api20201101storage.PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded) error {

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation_Status
		err := extendedLocation.AssignPropertiesFromExtendedLocationStatus(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "populating ExtendedLocation from ExtendedLocation, calling AssignPropertiesFromExtendedLocationStatus()")
		}
		publicIPAddressStatusLoadBalancerSubResourceEmbedded.ExtendedLocation = &extendedLocation
	} else {
		publicIPAddressStatusLoadBalancerSubResourceEmbedded.ExtendedLocation = nil
	}

	// Id
	if source.Id != nil {
		id := *source.Id
		publicIPAddressStatusLoadBalancerSubResourceEmbedded.Id = &id
	} else {
		publicIPAddressStatusLoadBalancerSubResourceEmbedded.Id = nil
	}

	// Sku
	if source.Sku != nil {
		var sku PublicIPAddressSku_Status
		err := sku.AssignPropertiesFromPublicIPAddressSkuStatus(source.Sku)
		if err != nil {
			return errors.Wrap(err, "populating Sku from Sku, calling AssignPropertiesFromPublicIPAddressSkuStatus()")
		}
		publicIPAddressStatusLoadBalancerSubResourceEmbedded.Sku = &sku
	} else {
		publicIPAddressStatusLoadBalancerSubResourceEmbedded.Sku = nil
	}

	// Zones
	zoneList := make([]string, len(source.Zones))
	for zoneIndex, zoneItem := range source.Zones {
		// Shadow the loop variable to avoid aliasing
		zoneItem := zoneItem
		zoneList[zoneIndex] = zoneItem
	}
	publicIPAddressStatusLoadBalancerSubResourceEmbedded.Zones = zoneList

	// No error
	return nil
}

// AssignPropertiesToPublicIPAddressStatusLoadBalancerSubResourceEmbedded populates the provided destination PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded from our PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded
func (publicIPAddressStatusLoadBalancerSubResourceEmbedded *PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded) AssignPropertiesToPublicIPAddressStatusLoadBalancerSubResourceEmbedded(destination *v1alpha1api20201101storage.PublicIPAddress_Status_LoadBalancer_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ExtendedLocation
	if publicIPAddressStatusLoadBalancerSubResourceEmbedded.ExtendedLocation != nil {
		var extendedLocation v1alpha1api20201101storage.ExtendedLocation_Status
		err := (*publicIPAddressStatusLoadBalancerSubResourceEmbedded.ExtendedLocation).AssignPropertiesToExtendedLocationStatus(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "populating ExtendedLocation from ExtendedLocation, calling AssignPropertiesToExtendedLocationStatus()")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// Id
	if publicIPAddressStatusLoadBalancerSubResourceEmbedded.Id != nil {
		id := *publicIPAddressStatusLoadBalancerSubResourceEmbedded.Id
		destination.Id = &id
	} else {
		destination.Id = nil
	}

	// Sku
	if publicIPAddressStatusLoadBalancerSubResourceEmbedded.Sku != nil {
		var sku v1alpha1api20201101storage.PublicIPAddressSku_Status
		err := (*publicIPAddressStatusLoadBalancerSubResourceEmbedded.Sku).AssignPropertiesToPublicIPAddressSkuStatus(&sku)
		if err != nil {
			return errors.Wrap(err, "populating Sku from Sku, calling AssignPropertiesToPublicIPAddressSkuStatus()")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Zones
	zoneList := make([]string, len(publicIPAddressStatusLoadBalancerSubResourceEmbedded.Zones))
	for zoneIndex, zoneItem := range publicIPAddressStatusLoadBalancerSubResourceEmbedded.Zones {
		// Shadow the loop variable to avoid aliasing
		zoneItem := zoneItem
		zoneList[zoneIndex] = zoneItem
	}
	destination.Zones = zoneList

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type Subnet_Status_LoadBalancer_SubResourceEmbedded struct {
	//Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &Subnet_Status_LoadBalancer_SubResourceEmbedded{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (subnetStatusLoadBalancerSubResourceEmbedded *Subnet_Status_LoadBalancer_SubResourceEmbedded) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &Subnet_Status_LoadBalancer_SubResourceEmbeddedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (subnetStatusLoadBalancerSubResourceEmbedded *Subnet_Status_LoadBalancer_SubResourceEmbedded) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(Subnet_Status_LoadBalancer_SubResourceEmbeddedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Subnet_Status_LoadBalancer_SubResourceEmbeddedARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		subnetStatusLoadBalancerSubResourceEmbedded.Id = &id
	}

	// No error
	return nil
}

// AssignPropertiesFromSubnetStatusLoadBalancerSubResourceEmbedded populates our Subnet_Status_LoadBalancer_SubResourceEmbedded from the provided source Subnet_Status_LoadBalancer_SubResourceEmbedded
func (subnetStatusLoadBalancerSubResourceEmbedded *Subnet_Status_LoadBalancer_SubResourceEmbedded) AssignPropertiesFromSubnetStatusLoadBalancerSubResourceEmbedded(source *v1alpha1api20201101storage.Subnet_Status_LoadBalancer_SubResourceEmbedded) error {

	// Id
	if source.Id != nil {
		id := *source.Id
		subnetStatusLoadBalancerSubResourceEmbedded.Id = &id
	} else {
		subnetStatusLoadBalancerSubResourceEmbedded.Id = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSubnetStatusLoadBalancerSubResourceEmbedded populates the provided destination Subnet_Status_LoadBalancer_SubResourceEmbedded from our Subnet_Status_LoadBalancer_SubResourceEmbedded
func (subnetStatusLoadBalancerSubResourceEmbedded *Subnet_Status_LoadBalancer_SubResourceEmbedded) AssignPropertiesToSubnetStatusLoadBalancerSubResourceEmbedded(destination *v1alpha1api20201101storage.Subnet_Status_LoadBalancer_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	if subnetStatusLoadBalancerSubResourceEmbedded.Id != nil {
		id := *subnetStatusLoadBalancerSubResourceEmbedded.Id
		destination.Id = &id
	} else {
		destination.Id = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type TransportProtocol_Status string

const (
	TransportProtocol_StatusAll = TransportProtocol_Status("All")
	TransportProtocol_StatusTcp = TransportProtocol_Status("Tcp")
	TransportProtocol_StatusUdp = TransportProtocol_Status("Udp")
)

func init() {
	SchemeBuilder.Register(&LoadBalancer{}, &LoadBalancerList{})
}
