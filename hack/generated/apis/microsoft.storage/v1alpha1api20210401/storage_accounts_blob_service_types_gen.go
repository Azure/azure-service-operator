// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20210401

import (
	"fmt"
	"github.com/Azure/azure-service-operator/hack/generated/apis/microsoft.storage/v1alpha1api20210401storage"
	"github.com/Azure/azure-service-operator/hack/generated/pkg/genruntime"
	"github.com/Azure/azure-service-operator/hack/generated/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/hack/generated/pkg/reflecthelpers"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	kerrors "k8s.io/apimachinery/pkg/util/errors"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:rbac:groups=microsoft.storage.azure.com,resources=storageaccountsblobservices,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=microsoft.storage.azure.com,resources={storageaccountsblobservices/status,storageaccountsblobservices/finalizers},verbs=get;update;patch

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
//Generated from: https://schema.management.azure.com/schemas/2021-04-01/Microsoft.Storage.json#/resourceDefinitions/storageAccounts_blobServices
type StorageAccountsBlobService struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              StorageAccountsBlobServices_Spec `json:"spec,omitempty"`
	Status            BlobServiceProperties_Status     `json:"status,omitempty"`
}

var _ conditions.Conditioner = &StorageAccountsBlobService{}

// GetConditions returns the conditions of the resource
func (storageAccountsBlobService *StorageAccountsBlobService) GetConditions() conditions.Conditions {
	return storageAccountsBlobService.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (storageAccountsBlobService *StorageAccountsBlobService) SetConditions(conditions conditions.Conditions) {
	storageAccountsBlobService.Status.Conditions = conditions
}

// +kubebuilder:webhook:path=/mutate-microsoft-storage-azure-com-v1alpha1api20210401-storageaccountsblobservice,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=microsoft.storage.azure.com,resources=storageaccountsblobservices,verbs=create;update,versions=v1alpha1api20210401,name=default.v1alpha1api20210401.storageaccountsblobservices.microsoft.storage.azure.com,admissionReviewVersions=v1beta1

var _ admission.Defaulter = &StorageAccountsBlobService{}

// Default applies defaults to the StorageAccountsBlobService resource
func (storageAccountsBlobService *StorageAccountsBlobService) Default() {
	storageAccountsBlobService.defaultImpl()
	var temp interface{} = storageAccountsBlobService
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultImpl applies the code generated defaults to the StorageAccountsBlobService resource
func (storageAccountsBlobService *StorageAccountsBlobService) defaultImpl() {}

var _ genruntime.KubernetesResource = &StorageAccountsBlobService{}

// AzureName returns the Azure name of the resource (always "default")
func (storageAccountsBlobService *StorageAccountsBlobService) AzureName() string {
	return "default"
}

// GetSpec returns the specification of this resource
func (storageAccountsBlobService *StorageAccountsBlobService) GetSpec() genruntime.ConvertibleSpec {
	return &storageAccountsBlobService.Spec
}

// GetStatus returns the status of this resource
func (storageAccountsBlobService *StorageAccountsBlobService) GetStatus() genruntime.ConvertibleStatus {
	return &storageAccountsBlobService.Status
}

// Owner returns the ResourceReference of the owner, or nil if there is no owner
func (storageAccountsBlobService *StorageAccountsBlobService) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(storageAccountsBlobService.Spec)
	return &genruntime.ResourceReference{Group: group, Kind: kind, Namespace: storageAccountsBlobService.Namespace, Name: storageAccountsBlobService.Spec.Owner.Name}
}

// +kubebuilder:webhook:path=/validate-microsoft-storage-azure-com-v1alpha1api20210401-storageaccountsblobservice,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=microsoft.storage.azure.com,resources=storageaccountsblobservices,verbs=create;update,versions=v1alpha1api20210401,name=validate.v1alpha1api20210401.storageaccountsblobservices.microsoft.storage.azure.com,admissionReviewVersions=v1beta1

var _ admission.Validator = &StorageAccountsBlobService{}

// ValidateCreate validates the creation of the resource
func (storageAccountsBlobService *StorageAccountsBlobService) ValidateCreate() error {
	validations := storageAccountsBlobService.createValidations()
	var temp interface{} = storageAccountsBlobService
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateDelete validates the deletion of the resource
func (storageAccountsBlobService *StorageAccountsBlobService) ValidateDelete() error {
	validations := storageAccountsBlobService.deleteValidations()
	var temp interface{} = storageAccountsBlobService
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateUpdate validates an update of the resource
func (storageAccountsBlobService *StorageAccountsBlobService) ValidateUpdate(old runtime.Object) error {
	validations := storageAccountsBlobService.updateValidations()
	var temp interface{} = storageAccountsBlobService
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation(old)
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// createValidations validates the creation of the resource
func (storageAccountsBlobService *StorageAccountsBlobService) createValidations() []func() error {
	return []func() error{storageAccountsBlobService.validateResourceReferences}
}

// deleteValidations validates the deletion of the resource
func (storageAccountsBlobService *StorageAccountsBlobService) deleteValidations() []func() error {
	return nil
}

// updateValidations validates the update of the resource
func (storageAccountsBlobService *StorageAccountsBlobService) updateValidations() []func(old runtime.Object) error {
	return []func(old runtime.Object) error{
		func(old runtime.Object) error {
			return storageAccountsBlobService.validateResourceReferences()
		},
	}
}

// validateResourceReferences validates all resource references
func (storageAccountsBlobService *StorageAccountsBlobService) validateResourceReferences() error {
	refs, err := reflecthelpers.FindResourceReferences(&storageAccountsBlobService.Spec)
	if err != nil {
		return err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// AssignPropertiesFromStorageAccountsBlobService populates our StorageAccountsBlobService from the provided source StorageAccountsBlobService
func (storageAccountsBlobService *StorageAccountsBlobService) AssignPropertiesFromStorageAccountsBlobService(source *v1alpha1api20210401storage.StorageAccountsBlobService) error {

	// Spec
	var spec StorageAccountsBlobServices_Spec
	err := spec.AssignPropertiesFromStorageAccountsBlobServicesSpec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "populating Spec from Spec, calling AssignPropertiesFromStorageAccountsBlobServicesSpec()")
	}
	storageAccountsBlobService.Spec = spec

	// Status
	var status BlobServiceProperties_Status
	err = status.AssignPropertiesFromBlobServicePropertiesStatus(&source.Status)
	if err != nil {
		return errors.Wrap(err, "populating Status from Status, calling AssignPropertiesFromBlobServicePropertiesStatus()")
	}
	storageAccountsBlobService.Status = status

	// No error
	return nil
}

// AssignPropertiesToStorageAccountsBlobService populates the provided destination StorageAccountsBlobService from our StorageAccountsBlobService
func (storageAccountsBlobService *StorageAccountsBlobService) AssignPropertiesToStorageAccountsBlobService(destination *v1alpha1api20210401storage.StorageAccountsBlobService) error {

	// Spec
	var spec v1alpha1api20210401storage.StorageAccountsBlobServices_Spec
	err := storageAccountsBlobService.Spec.AssignPropertiesToStorageAccountsBlobServicesSpec(&spec)
	if err != nil {
		return errors.Wrap(err, "populating Spec from Spec, calling AssignPropertiesToStorageAccountsBlobServicesSpec()")
	}
	destination.Spec = spec

	// Status
	var status v1alpha1api20210401storage.BlobServiceProperties_Status
	err = storageAccountsBlobService.Status.AssignPropertiesToBlobServicePropertiesStatus(&status)
	if err != nil {
		return errors.Wrap(err, "populating Status from Status, calling AssignPropertiesToBlobServicePropertiesStatus()")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (storageAccountsBlobService *StorageAccountsBlobService) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: storageAccountsBlobService.Spec.OriginalVersion(),
		Kind:    "StorageAccountsBlobService",
	}
}

// +kubebuilder:object:root=true
//Generated from: https://schema.management.azure.com/schemas/2021-04-01/Microsoft.Storage.json#/resourceDefinitions/storageAccounts_blobServices
type StorageAccountsBlobServiceList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []StorageAccountsBlobService `json:"items"`
}

//Generated from:
type BlobServiceProperties_Status struct {
	//AutomaticSnapshotPolicyEnabled: Deprecated in favor of isVersioningEnabled
	//property.
	AutomaticSnapshotPolicyEnabled *bool `json:"automaticSnapshotPolicyEnabled,omitempty"`

	//ChangeFeed: The blob service properties for change feed events.
	ChangeFeed *ChangeFeed_Status `json:"changeFeed,omitempty"`

	//Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	//ContainerDeleteRetentionPolicy: The blob service properties for container soft
	//delete.
	ContainerDeleteRetentionPolicy *DeleteRetentionPolicy_Status `json:"containerDeleteRetentionPolicy,omitempty"`

	//Cors: Specifies CORS rules for the Blob service. You can include up to five
	//CorsRule elements in the request. If no CorsRule elements are included in the
	//request body, all CORS rules will be deleted, and CORS will be disabled for the
	//Blob service.
	Cors *CorsRules_Status `json:"cors,omitempty"`

	//DefaultServiceVersion: DefaultServiceVersion indicates the default version to
	//use for requests to the Blob service if an incoming request’s version is not
	//specified. Possible values include version 2008-10-27 and all more recent
	//versions.
	DefaultServiceVersion *string `json:"defaultServiceVersion,omitempty"`

	//DeleteRetentionPolicy: The blob service properties for blob soft delete.
	DeleteRetentionPolicy *DeleteRetentionPolicy_Status `json:"deleteRetentionPolicy,omitempty"`

	//Id: Fully qualified resource ID for the resource. Ex -
	///subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	Id *string `json:"id,omitempty"`

	//IsVersioningEnabled: Versioning is enabled if set to true.
	IsVersioningEnabled *bool `json:"isVersioningEnabled,omitempty"`

	//LastAccessTimeTrackingPolicy: The blob service property to configure last access
	//time based tracking policy.
	LastAccessTimeTrackingPolicy *LastAccessTimeTrackingPolicy_Status `json:"lastAccessTimeTrackingPolicy,omitempty"`

	//Name: The name of the resource
	Name *string `json:"name,omitempty"`

	//RestorePolicy: The blob service properties for blob restore policy.
	RestorePolicy *RestorePolicyProperties_Status `json:"restorePolicy,omitempty"`

	//Sku: Sku name and tier.
	Sku *Sku_Status `json:"sku,omitempty"`

	//Type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
	//"Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &BlobServiceProperties_Status{}

// ConvertStatusFrom populates our BlobServiceProperties_Status from the provided source
func (blobServicePropertiesStatus *BlobServiceProperties_Status) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v1alpha1api20210401storage.BlobServiceProperties_Status)
	if ok {
		// Populate our instance from source
		return blobServicePropertiesStatus.AssignPropertiesFromBlobServicePropertiesStatus(src)
	}

	// Convert to an intermediate form
	src = &v1alpha1api20210401storage.BlobServiceProperties_Status{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = blobServicePropertiesStatus.AssignPropertiesFromBlobServicePropertiesStatus(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our BlobServiceProperties_Status
func (blobServicePropertiesStatus *BlobServiceProperties_Status) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v1alpha1api20210401storage.BlobServiceProperties_Status)
	if ok {
		// Populate destination from our instance
		return blobServicePropertiesStatus.AssignPropertiesToBlobServicePropertiesStatus(dst)
	}

	// Convert to an intermediate form
	dst = &v1alpha1api20210401storage.BlobServiceProperties_Status{}
	err := blobServicePropertiesStatus.AssignPropertiesToBlobServicePropertiesStatus(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &BlobServiceProperties_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (blobServicePropertiesStatus *BlobServiceProperties_Status) CreateEmptyARMValue() interface{} {
	return BlobServiceProperties_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (blobServicePropertiesStatus *BlobServiceProperties_Status) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(BlobServiceProperties_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BlobServiceProperties_StatusARM, got %T", armInput)
	}

	// Set property ‘AutomaticSnapshotPolicyEnabled’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AutomaticSnapshotPolicyEnabled != nil {
			automaticSnapshotPolicyEnabled := *typedInput.Properties.AutomaticSnapshotPolicyEnabled
			blobServicePropertiesStatus.AutomaticSnapshotPolicyEnabled = &automaticSnapshotPolicyEnabled
		}
	}

	// Set property ‘ChangeFeed’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ChangeFeed != nil {
			var changeFeed1 ChangeFeed_Status
			err := changeFeed1.PopulateFromARM(owner, *typedInput.Properties.ChangeFeed)
			if err != nil {
				return err
			}
			changeFeed := changeFeed1
			blobServicePropertiesStatus.ChangeFeed = &changeFeed
		}
	}

	// no assignment for property ‘Conditions’

	// Set property ‘ContainerDeleteRetentionPolicy’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ContainerDeleteRetentionPolicy != nil {
			var containerDeleteRetentionPolicy1 DeleteRetentionPolicy_Status
			err := containerDeleteRetentionPolicy1.PopulateFromARM(owner, *typedInput.Properties.ContainerDeleteRetentionPolicy)
			if err != nil {
				return err
			}
			containerDeleteRetentionPolicy := containerDeleteRetentionPolicy1
			blobServicePropertiesStatus.ContainerDeleteRetentionPolicy = &containerDeleteRetentionPolicy
		}
	}

	// Set property ‘Cors’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Cors != nil {
			var cors1 CorsRules_Status
			err := cors1.PopulateFromARM(owner, *typedInput.Properties.Cors)
			if err != nil {
				return err
			}
			cors := cors1
			blobServicePropertiesStatus.Cors = &cors
		}
	}

	// Set property ‘DefaultServiceVersion’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DefaultServiceVersion != nil {
			defaultServiceVersion := *typedInput.Properties.DefaultServiceVersion
			blobServicePropertiesStatus.DefaultServiceVersion = &defaultServiceVersion
		}
	}

	// Set property ‘DeleteRetentionPolicy’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DeleteRetentionPolicy != nil {
			var deleteRetentionPolicy1 DeleteRetentionPolicy_Status
			err := deleteRetentionPolicy1.PopulateFromARM(owner, *typedInput.Properties.DeleteRetentionPolicy)
			if err != nil {
				return err
			}
			deleteRetentionPolicy := deleteRetentionPolicy1
			blobServicePropertiesStatus.DeleteRetentionPolicy = &deleteRetentionPolicy
		}
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		blobServicePropertiesStatus.Id = &id
	}

	// Set property ‘IsVersioningEnabled’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IsVersioningEnabled != nil {
			isVersioningEnabled := *typedInput.Properties.IsVersioningEnabled
			blobServicePropertiesStatus.IsVersioningEnabled = &isVersioningEnabled
		}
	}

	// Set property ‘LastAccessTimeTrackingPolicy’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LastAccessTimeTrackingPolicy != nil {
			var lastAccessTimeTrackingPolicy1 LastAccessTimeTrackingPolicy_Status
			err := lastAccessTimeTrackingPolicy1.PopulateFromARM(owner, *typedInput.Properties.LastAccessTimeTrackingPolicy)
			if err != nil {
				return err
			}
			lastAccessTimeTrackingPolicy := lastAccessTimeTrackingPolicy1
			blobServicePropertiesStatus.LastAccessTimeTrackingPolicy = &lastAccessTimeTrackingPolicy
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		blobServicePropertiesStatus.Name = &name
	}

	// Set property ‘RestorePolicy’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RestorePolicy != nil {
			var restorePolicy1 RestorePolicyProperties_Status
			err := restorePolicy1.PopulateFromARM(owner, *typedInput.Properties.RestorePolicy)
			if err != nil {
				return err
			}
			restorePolicy := restorePolicy1
			blobServicePropertiesStatus.RestorePolicy = &restorePolicy
		}
	}

	// Set property ‘Sku’:
	if typedInput.Sku != nil {
		var sku1 Sku_Status
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		blobServicePropertiesStatus.Sku = &sku
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		blobServicePropertiesStatus.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromBlobServicePropertiesStatus populates our BlobServiceProperties_Status from the provided source BlobServiceProperties_Status
func (blobServicePropertiesStatus *BlobServiceProperties_Status) AssignPropertiesFromBlobServicePropertiesStatus(source *v1alpha1api20210401storage.BlobServiceProperties_Status) error {

	// AutomaticSnapshotPolicyEnabled
	if source.AutomaticSnapshotPolicyEnabled != nil {
		automaticSnapshotPolicyEnabled := *source.AutomaticSnapshotPolicyEnabled
		blobServicePropertiesStatus.AutomaticSnapshotPolicyEnabled = &automaticSnapshotPolicyEnabled
	} else {
		blobServicePropertiesStatus.AutomaticSnapshotPolicyEnabled = nil
	}

	// ChangeFeed
	if source.ChangeFeed != nil {
		var changeFeed ChangeFeed_Status
		err := changeFeed.AssignPropertiesFromChangeFeedStatus(source.ChangeFeed)
		if err != nil {
			return errors.Wrap(err, "populating ChangeFeed from ChangeFeed, calling AssignPropertiesFromChangeFeedStatus()")
		}
		blobServicePropertiesStatus.ChangeFeed = &changeFeed
	} else {
		blobServicePropertiesStatus.ChangeFeed = nil
	}

	// Conditions
	conditionList := make([]conditions.Condition, len(source.Conditions))
	for conditionIndex, conditionItem := range source.Conditions {
		// Shadow the loop variable to avoid aliasing
		conditionItem := conditionItem
		conditionList[conditionIndex] = conditionItem.Copy()
	}
	blobServicePropertiesStatus.Conditions = conditionList

	// ContainerDeleteRetentionPolicy
	if source.ContainerDeleteRetentionPolicy != nil {
		var containerDeleteRetentionPolicy DeleteRetentionPolicy_Status
		err := containerDeleteRetentionPolicy.AssignPropertiesFromDeleteRetentionPolicyStatus(source.ContainerDeleteRetentionPolicy)
		if err != nil {
			return errors.Wrap(err, "populating ContainerDeleteRetentionPolicy from ContainerDeleteRetentionPolicy, calling AssignPropertiesFromDeleteRetentionPolicyStatus()")
		}
		blobServicePropertiesStatus.ContainerDeleteRetentionPolicy = &containerDeleteRetentionPolicy
	} else {
		blobServicePropertiesStatus.ContainerDeleteRetentionPolicy = nil
	}

	// Cors
	if source.Cors != nil {
		var cor CorsRules_Status
		err := cor.AssignPropertiesFromCorsRulesStatus(source.Cors)
		if err != nil {
			return errors.Wrap(err, "populating Cors from Cors, calling AssignPropertiesFromCorsRulesStatus()")
		}
		blobServicePropertiesStatus.Cors = &cor
	} else {
		blobServicePropertiesStatus.Cors = nil
	}

	// DefaultServiceVersion
	if source.DefaultServiceVersion != nil {
		defaultServiceVersion := *source.DefaultServiceVersion
		blobServicePropertiesStatus.DefaultServiceVersion = &defaultServiceVersion
	} else {
		blobServicePropertiesStatus.DefaultServiceVersion = nil
	}

	// DeleteRetentionPolicy
	if source.DeleteRetentionPolicy != nil {
		var deleteRetentionPolicy DeleteRetentionPolicy_Status
		err := deleteRetentionPolicy.AssignPropertiesFromDeleteRetentionPolicyStatus(source.DeleteRetentionPolicy)
		if err != nil {
			return errors.Wrap(err, "populating DeleteRetentionPolicy from DeleteRetentionPolicy, calling AssignPropertiesFromDeleteRetentionPolicyStatus()")
		}
		blobServicePropertiesStatus.DeleteRetentionPolicy = &deleteRetentionPolicy
	} else {
		blobServicePropertiesStatus.DeleteRetentionPolicy = nil
	}

	// Id
	if source.Id != nil {
		id := *source.Id
		blobServicePropertiesStatus.Id = &id
	} else {
		blobServicePropertiesStatus.Id = nil
	}

	// IsVersioningEnabled
	if source.IsVersioningEnabled != nil {
		isVersioningEnabled := *source.IsVersioningEnabled
		blobServicePropertiesStatus.IsVersioningEnabled = &isVersioningEnabled
	} else {
		blobServicePropertiesStatus.IsVersioningEnabled = nil
	}

	// LastAccessTimeTrackingPolicy
	if source.LastAccessTimeTrackingPolicy != nil {
		var lastAccessTimeTrackingPolicy LastAccessTimeTrackingPolicy_Status
		err := lastAccessTimeTrackingPolicy.AssignPropertiesFromLastAccessTimeTrackingPolicyStatus(source.LastAccessTimeTrackingPolicy)
		if err != nil {
			return errors.Wrap(err, "populating LastAccessTimeTrackingPolicy from LastAccessTimeTrackingPolicy, calling AssignPropertiesFromLastAccessTimeTrackingPolicyStatus()")
		}
		blobServicePropertiesStatus.LastAccessTimeTrackingPolicy = &lastAccessTimeTrackingPolicy
	} else {
		blobServicePropertiesStatus.LastAccessTimeTrackingPolicy = nil
	}

	// Name
	if source.Name != nil {
		name := *source.Name
		blobServicePropertiesStatus.Name = &name
	} else {
		blobServicePropertiesStatus.Name = nil
	}

	// RestorePolicy
	if source.RestorePolicy != nil {
		var restorePolicy RestorePolicyProperties_Status
		err := restorePolicy.AssignPropertiesFromRestorePolicyPropertiesStatus(source.RestorePolicy)
		if err != nil {
			return errors.Wrap(err, "populating RestorePolicy from RestorePolicy, calling AssignPropertiesFromRestorePolicyPropertiesStatus()")
		}
		blobServicePropertiesStatus.RestorePolicy = &restorePolicy
	} else {
		blobServicePropertiesStatus.RestorePolicy = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku_Status
		err := sku.AssignPropertiesFromSkuStatus(source.Sku)
		if err != nil {
			return errors.Wrap(err, "populating Sku from Sku, calling AssignPropertiesFromSkuStatus()")
		}
		blobServicePropertiesStatus.Sku = &sku
	} else {
		blobServicePropertiesStatus.Sku = nil
	}

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		blobServicePropertiesStatus.Type = &typeVar
	} else {
		blobServicePropertiesStatus.Type = nil
	}

	// No error
	return nil
}

// AssignPropertiesToBlobServicePropertiesStatus populates the provided destination BlobServiceProperties_Status from our BlobServiceProperties_Status
func (blobServicePropertiesStatus *BlobServiceProperties_Status) AssignPropertiesToBlobServicePropertiesStatus(destination *v1alpha1api20210401storage.BlobServiceProperties_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AutomaticSnapshotPolicyEnabled
	if blobServicePropertiesStatus.AutomaticSnapshotPolicyEnabled != nil {
		automaticSnapshotPolicyEnabled := *blobServicePropertiesStatus.AutomaticSnapshotPolicyEnabled
		destination.AutomaticSnapshotPolicyEnabled = &automaticSnapshotPolicyEnabled
	} else {
		destination.AutomaticSnapshotPolicyEnabled = nil
	}

	// ChangeFeed
	if blobServicePropertiesStatus.ChangeFeed != nil {
		var changeFeed v1alpha1api20210401storage.ChangeFeed_Status
		err := (*blobServicePropertiesStatus.ChangeFeed).AssignPropertiesToChangeFeedStatus(&changeFeed)
		if err != nil {
			return errors.Wrap(err, "populating ChangeFeed from ChangeFeed, calling AssignPropertiesToChangeFeedStatus()")
		}
		destination.ChangeFeed = &changeFeed
	} else {
		destination.ChangeFeed = nil
	}

	// Conditions
	conditionList := make([]conditions.Condition, len(blobServicePropertiesStatus.Conditions))
	for conditionIndex, conditionItem := range blobServicePropertiesStatus.Conditions {
		// Shadow the loop variable to avoid aliasing
		conditionItem := conditionItem
		conditionList[conditionIndex] = conditionItem.Copy()
	}
	destination.Conditions = conditionList

	// ContainerDeleteRetentionPolicy
	if blobServicePropertiesStatus.ContainerDeleteRetentionPolicy != nil {
		var containerDeleteRetentionPolicy v1alpha1api20210401storage.DeleteRetentionPolicy_Status
		err := (*blobServicePropertiesStatus.ContainerDeleteRetentionPolicy).AssignPropertiesToDeleteRetentionPolicyStatus(&containerDeleteRetentionPolicy)
		if err != nil {
			return errors.Wrap(err, "populating ContainerDeleteRetentionPolicy from ContainerDeleteRetentionPolicy, calling AssignPropertiesToDeleteRetentionPolicyStatus()")
		}
		destination.ContainerDeleteRetentionPolicy = &containerDeleteRetentionPolicy
	} else {
		destination.ContainerDeleteRetentionPolicy = nil
	}

	// Cors
	if blobServicePropertiesStatus.Cors != nil {
		var cor v1alpha1api20210401storage.CorsRules_Status
		err := (*blobServicePropertiesStatus.Cors).AssignPropertiesToCorsRulesStatus(&cor)
		if err != nil {
			return errors.Wrap(err, "populating Cors from Cors, calling AssignPropertiesToCorsRulesStatus()")
		}
		destination.Cors = &cor
	} else {
		destination.Cors = nil
	}

	// DefaultServiceVersion
	if blobServicePropertiesStatus.DefaultServiceVersion != nil {
		defaultServiceVersion := *blobServicePropertiesStatus.DefaultServiceVersion
		destination.DefaultServiceVersion = &defaultServiceVersion
	} else {
		destination.DefaultServiceVersion = nil
	}

	// DeleteRetentionPolicy
	if blobServicePropertiesStatus.DeleteRetentionPolicy != nil {
		var deleteRetentionPolicy v1alpha1api20210401storage.DeleteRetentionPolicy_Status
		err := (*blobServicePropertiesStatus.DeleteRetentionPolicy).AssignPropertiesToDeleteRetentionPolicyStatus(&deleteRetentionPolicy)
		if err != nil {
			return errors.Wrap(err, "populating DeleteRetentionPolicy from DeleteRetentionPolicy, calling AssignPropertiesToDeleteRetentionPolicyStatus()")
		}
		destination.DeleteRetentionPolicy = &deleteRetentionPolicy
	} else {
		destination.DeleteRetentionPolicy = nil
	}

	// Id
	if blobServicePropertiesStatus.Id != nil {
		id := *blobServicePropertiesStatus.Id
		destination.Id = &id
	} else {
		destination.Id = nil
	}

	// IsVersioningEnabled
	if blobServicePropertiesStatus.IsVersioningEnabled != nil {
		isVersioningEnabled := *blobServicePropertiesStatus.IsVersioningEnabled
		destination.IsVersioningEnabled = &isVersioningEnabled
	} else {
		destination.IsVersioningEnabled = nil
	}

	// LastAccessTimeTrackingPolicy
	if blobServicePropertiesStatus.LastAccessTimeTrackingPolicy != nil {
		var lastAccessTimeTrackingPolicy v1alpha1api20210401storage.LastAccessTimeTrackingPolicy_Status
		err := (*blobServicePropertiesStatus.LastAccessTimeTrackingPolicy).AssignPropertiesToLastAccessTimeTrackingPolicyStatus(&lastAccessTimeTrackingPolicy)
		if err != nil {
			return errors.Wrap(err, "populating LastAccessTimeTrackingPolicy from LastAccessTimeTrackingPolicy, calling AssignPropertiesToLastAccessTimeTrackingPolicyStatus()")
		}
		destination.LastAccessTimeTrackingPolicy = &lastAccessTimeTrackingPolicy
	} else {
		destination.LastAccessTimeTrackingPolicy = nil
	}

	// Name
	if blobServicePropertiesStatus.Name != nil {
		name := *blobServicePropertiesStatus.Name
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// RestorePolicy
	if blobServicePropertiesStatus.RestorePolicy != nil {
		var restorePolicy v1alpha1api20210401storage.RestorePolicyProperties_Status
		err := (*blobServicePropertiesStatus.RestorePolicy).AssignPropertiesToRestorePolicyPropertiesStatus(&restorePolicy)
		if err != nil {
			return errors.Wrap(err, "populating RestorePolicy from RestorePolicy, calling AssignPropertiesToRestorePolicyPropertiesStatus()")
		}
		destination.RestorePolicy = &restorePolicy
	} else {
		destination.RestorePolicy = nil
	}

	// Sku
	if blobServicePropertiesStatus.Sku != nil {
		var sku v1alpha1api20210401storage.Sku_Status
		err := (*blobServicePropertiesStatus.Sku).AssignPropertiesToSkuStatus(&sku)
		if err != nil {
			return errors.Wrap(err, "populating Sku from Sku, calling AssignPropertiesToSkuStatus()")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Type
	if blobServicePropertiesStatus.Type != nil {
		typeVar := *blobServicePropertiesStatus.Type
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

type StorageAccountsBlobServices_Spec struct {
	//AutomaticSnapshotPolicyEnabled: Deprecated in favor of isVersioningEnabled
	//property.
	AutomaticSnapshotPolicyEnabled *bool `json:"automaticSnapshotPolicyEnabled,omitempty"`

	//ChangeFeed: The blob service properties for change feed events.
	ChangeFeed *ChangeFeed `json:"changeFeed,omitempty"`

	//ContainerDeleteRetentionPolicy: The service properties for soft delete.
	ContainerDeleteRetentionPolicy *DeleteRetentionPolicy `json:"containerDeleteRetentionPolicy,omitempty"`

	//Cors: Sets the CORS rules. You can include up to five CorsRule elements in the
	//request.
	Cors *CorsRules `json:"cors,omitempty"`

	//DefaultServiceVersion: DefaultServiceVersion indicates the default version to
	//use for requests to the Blob service if an incoming request’s version is not
	//specified. Possible values include version 2008-10-27 and all more recent
	//versions.
	DefaultServiceVersion *string `json:"defaultServiceVersion,omitempty"`

	//DeleteRetentionPolicy: The service properties for soft delete.
	DeleteRetentionPolicy *DeleteRetentionPolicy `json:"deleteRetentionPolicy,omitempty"`

	//IsVersioningEnabled: Versioning is enabled if set to true.
	IsVersioningEnabled *bool `json:"isVersioningEnabled,omitempty"`

	//LastAccessTimeTrackingPolicy: The blob service properties for Last access time
	//based tracking policy.
	LastAccessTimeTrackingPolicy *LastAccessTimeTrackingPolicy `json:"lastAccessTimeTrackingPolicy,omitempty"`

	//Location: Location to deploy resource to
	Location *string `json:"location,omitempty"`

	// +kubebuilder:validation:Required
	Owner genruntime.KnownResourceReference `group:"microsoft.storage.azure.com" json:"owner" kind:"StorageAccount"`

	//RestorePolicy: The blob service properties for blob restore policy
	RestorePolicy *RestorePolicyProperties `json:"restorePolicy,omitempty"`

	//Tags: Name-value pairs to add to the resource
	Tags map[string]string `json:"tags,omitempty"`
}

var _ genruntime.ARMTransformer = &StorageAccountsBlobServices_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (storageAccountsBlobServicesSpec *StorageAccountsBlobServices_Spec) ConvertToARM(name string, resolvedReferences genruntime.ResolvedReferences) (interface{}, error) {
	if storageAccountsBlobServicesSpec == nil {
		return nil, nil
	}
	var result StorageAccountsBlobServices_SpecARM

	// Set property ‘APIVersion’:
	result.APIVersion = StorageAccountsBlobServicesSpecAPIVersion20210401

	// Set property ‘Location’:
	if storageAccountsBlobServicesSpec.Location != nil {
		location := *storageAccountsBlobServicesSpec.Location
		result.Location = &location
	}

	// Set property ‘Name’:
	result.Name = name

	// Set property ‘Properties’:
	if storageAccountsBlobServicesSpec.AutomaticSnapshotPolicyEnabled != nil || storageAccountsBlobServicesSpec.ChangeFeed != nil || storageAccountsBlobServicesSpec.ContainerDeleteRetentionPolicy != nil || storageAccountsBlobServicesSpec.Cors != nil || storageAccountsBlobServicesSpec.DefaultServiceVersion != nil || storageAccountsBlobServicesSpec.DeleteRetentionPolicy != nil || storageAccountsBlobServicesSpec.IsVersioningEnabled != nil || storageAccountsBlobServicesSpec.LastAccessTimeTrackingPolicy != nil || storageAccountsBlobServicesSpec.RestorePolicy != nil {
		result.Properties = &BlobServicePropertiesPropertiesARM{}
	}
	if storageAccountsBlobServicesSpec.AutomaticSnapshotPolicyEnabled != nil {
		automaticSnapshotPolicyEnabled := *storageAccountsBlobServicesSpec.AutomaticSnapshotPolicyEnabled
		result.Properties.AutomaticSnapshotPolicyEnabled = &automaticSnapshotPolicyEnabled
	}
	if storageAccountsBlobServicesSpec.ChangeFeed != nil {
		changeFeedARM, err := (*storageAccountsBlobServicesSpec.ChangeFeed).ConvertToARM(name, resolvedReferences)
		if err != nil {
			return nil, err
		}
		changeFeed := changeFeedARM.(ChangeFeedARM)
		result.Properties.ChangeFeed = &changeFeed
	}
	if storageAccountsBlobServicesSpec.ContainerDeleteRetentionPolicy != nil {
		containerDeleteRetentionPolicyARM, err := (*storageAccountsBlobServicesSpec.ContainerDeleteRetentionPolicy).ConvertToARM(name, resolvedReferences)
		if err != nil {
			return nil, err
		}
		containerDeleteRetentionPolicy := containerDeleteRetentionPolicyARM.(DeleteRetentionPolicyARM)
		result.Properties.ContainerDeleteRetentionPolicy = &containerDeleteRetentionPolicy
	}
	if storageAccountsBlobServicesSpec.Cors != nil {
		corsARM, err := (*storageAccountsBlobServicesSpec.Cors).ConvertToARM(name, resolvedReferences)
		if err != nil {
			return nil, err
		}
		cors := corsARM.(CorsRulesARM)
		result.Properties.Cors = &cors
	}
	if storageAccountsBlobServicesSpec.DefaultServiceVersion != nil {
		defaultServiceVersion := *storageAccountsBlobServicesSpec.DefaultServiceVersion
		result.Properties.DefaultServiceVersion = &defaultServiceVersion
	}
	if storageAccountsBlobServicesSpec.DeleteRetentionPolicy != nil {
		deleteRetentionPolicyARM, err := (*storageAccountsBlobServicesSpec.DeleteRetentionPolicy).ConvertToARM(name, resolvedReferences)
		if err != nil {
			return nil, err
		}
		deleteRetentionPolicy := deleteRetentionPolicyARM.(DeleteRetentionPolicyARM)
		result.Properties.DeleteRetentionPolicy = &deleteRetentionPolicy
	}
	if storageAccountsBlobServicesSpec.IsVersioningEnabled != nil {
		isVersioningEnabled := *storageAccountsBlobServicesSpec.IsVersioningEnabled
		result.Properties.IsVersioningEnabled = &isVersioningEnabled
	}
	if storageAccountsBlobServicesSpec.LastAccessTimeTrackingPolicy != nil {
		lastAccessTimeTrackingPolicyARM, err := (*storageAccountsBlobServicesSpec.LastAccessTimeTrackingPolicy).ConvertToARM(name, resolvedReferences)
		if err != nil {
			return nil, err
		}
		lastAccessTimeTrackingPolicy := lastAccessTimeTrackingPolicyARM.(LastAccessTimeTrackingPolicyARM)
		result.Properties.LastAccessTimeTrackingPolicy = &lastAccessTimeTrackingPolicy
	}
	if storageAccountsBlobServicesSpec.RestorePolicy != nil {
		restorePolicyARM, err := (*storageAccountsBlobServicesSpec.RestorePolicy).ConvertToARM(name, resolvedReferences)
		if err != nil {
			return nil, err
		}
		restorePolicy := restorePolicyARM.(RestorePolicyPropertiesARM)
		result.Properties.RestorePolicy = &restorePolicy
	}

	// Set property ‘Tags’:
	if storageAccountsBlobServicesSpec.Tags != nil {
		result.Tags = make(map[string]string)
		for key, value := range storageAccountsBlobServicesSpec.Tags {
			result.Tags[key] = value
		}
	}

	// Set property ‘Type’:
	result.Type = StorageAccountsBlobServicesSpecTypeMicrosoftStorageStorageAccountsBlobServices
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (storageAccountsBlobServicesSpec *StorageAccountsBlobServices_Spec) CreateEmptyARMValue() interface{} {
	return StorageAccountsBlobServices_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (storageAccountsBlobServicesSpec *StorageAccountsBlobServices_Spec) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(StorageAccountsBlobServices_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected StorageAccountsBlobServices_SpecARM, got %T", armInput)
	}

	// Set property ‘AutomaticSnapshotPolicyEnabled’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AutomaticSnapshotPolicyEnabled != nil {
			automaticSnapshotPolicyEnabled := *typedInput.Properties.AutomaticSnapshotPolicyEnabled
			storageAccountsBlobServicesSpec.AutomaticSnapshotPolicyEnabled = &automaticSnapshotPolicyEnabled
		}
	}

	// Set property ‘ChangeFeed’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ChangeFeed != nil {
			var changeFeed1 ChangeFeed
			err := changeFeed1.PopulateFromARM(owner, *typedInput.Properties.ChangeFeed)
			if err != nil {
				return err
			}
			changeFeed := changeFeed1
			storageAccountsBlobServicesSpec.ChangeFeed = &changeFeed
		}
	}

	// Set property ‘ContainerDeleteRetentionPolicy’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ContainerDeleteRetentionPolicy != nil {
			var containerDeleteRetentionPolicy1 DeleteRetentionPolicy
			err := containerDeleteRetentionPolicy1.PopulateFromARM(owner, *typedInput.Properties.ContainerDeleteRetentionPolicy)
			if err != nil {
				return err
			}
			containerDeleteRetentionPolicy := containerDeleteRetentionPolicy1
			storageAccountsBlobServicesSpec.ContainerDeleteRetentionPolicy = &containerDeleteRetentionPolicy
		}
	}

	// Set property ‘Cors’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Cors != nil {
			var cors1 CorsRules
			err := cors1.PopulateFromARM(owner, *typedInput.Properties.Cors)
			if err != nil {
				return err
			}
			cors := cors1
			storageAccountsBlobServicesSpec.Cors = &cors
		}
	}

	// Set property ‘DefaultServiceVersion’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DefaultServiceVersion != nil {
			defaultServiceVersion := *typedInput.Properties.DefaultServiceVersion
			storageAccountsBlobServicesSpec.DefaultServiceVersion = &defaultServiceVersion
		}
	}

	// Set property ‘DeleteRetentionPolicy’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DeleteRetentionPolicy != nil {
			var deleteRetentionPolicy1 DeleteRetentionPolicy
			err := deleteRetentionPolicy1.PopulateFromARM(owner, *typedInput.Properties.DeleteRetentionPolicy)
			if err != nil {
				return err
			}
			deleteRetentionPolicy := deleteRetentionPolicy1
			storageAccountsBlobServicesSpec.DeleteRetentionPolicy = &deleteRetentionPolicy
		}
	}

	// Set property ‘IsVersioningEnabled’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IsVersioningEnabled != nil {
			isVersioningEnabled := *typedInput.Properties.IsVersioningEnabled
			storageAccountsBlobServicesSpec.IsVersioningEnabled = &isVersioningEnabled
		}
	}

	// Set property ‘LastAccessTimeTrackingPolicy’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LastAccessTimeTrackingPolicy != nil {
			var lastAccessTimeTrackingPolicy1 LastAccessTimeTrackingPolicy
			err := lastAccessTimeTrackingPolicy1.PopulateFromARM(owner, *typedInput.Properties.LastAccessTimeTrackingPolicy)
			if err != nil {
				return err
			}
			lastAccessTimeTrackingPolicy := lastAccessTimeTrackingPolicy1
			storageAccountsBlobServicesSpec.LastAccessTimeTrackingPolicy = &lastAccessTimeTrackingPolicy
		}
	}

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		storageAccountsBlobServicesSpec.Location = &location
	}

	// Set property ‘Owner’:
	storageAccountsBlobServicesSpec.Owner = owner

	// Set property ‘RestorePolicy’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RestorePolicy != nil {
			var restorePolicy1 RestorePolicyProperties
			err := restorePolicy1.PopulateFromARM(owner, *typedInput.Properties.RestorePolicy)
			if err != nil {
				return err
			}
			restorePolicy := restorePolicy1
			storageAccountsBlobServicesSpec.RestorePolicy = &restorePolicy
		}
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		storageAccountsBlobServicesSpec.Tags = make(map[string]string)
		for key, value := range typedInput.Tags {
			storageAccountsBlobServicesSpec.Tags[key] = value
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &StorageAccountsBlobServices_Spec{}

// ConvertSpecFrom populates our StorageAccountsBlobServices_Spec from the provided source
func (storageAccountsBlobServicesSpec *StorageAccountsBlobServices_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v1alpha1api20210401storage.StorageAccountsBlobServices_Spec)
	if ok {
		// Populate our instance from source
		return storageAccountsBlobServicesSpec.AssignPropertiesFromStorageAccountsBlobServicesSpec(src)
	}

	// Convert to an intermediate form
	src = &v1alpha1api20210401storage.StorageAccountsBlobServices_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = storageAccountsBlobServicesSpec.AssignPropertiesFromStorageAccountsBlobServicesSpec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our StorageAccountsBlobServices_Spec
func (storageAccountsBlobServicesSpec *StorageAccountsBlobServices_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v1alpha1api20210401storage.StorageAccountsBlobServices_Spec)
	if ok {
		// Populate destination from our instance
		return storageAccountsBlobServicesSpec.AssignPropertiesToStorageAccountsBlobServicesSpec(dst)
	}

	// Convert to an intermediate form
	dst = &v1alpha1api20210401storage.StorageAccountsBlobServices_Spec{}
	err := storageAccountsBlobServicesSpec.AssignPropertiesToStorageAccountsBlobServicesSpec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignPropertiesFromStorageAccountsBlobServicesSpec populates our StorageAccountsBlobServices_Spec from the provided source StorageAccountsBlobServices_Spec
func (storageAccountsBlobServicesSpec *StorageAccountsBlobServices_Spec) AssignPropertiesFromStorageAccountsBlobServicesSpec(source *v1alpha1api20210401storage.StorageAccountsBlobServices_Spec) error {

	// AutomaticSnapshotPolicyEnabled
	if source.AutomaticSnapshotPolicyEnabled != nil {
		automaticSnapshotPolicyEnabled := *source.AutomaticSnapshotPolicyEnabled
		storageAccountsBlobServicesSpec.AutomaticSnapshotPolicyEnabled = &automaticSnapshotPolicyEnabled
	} else {
		storageAccountsBlobServicesSpec.AutomaticSnapshotPolicyEnabled = nil
	}

	// ChangeFeed
	if source.ChangeFeed != nil {
		var changeFeed ChangeFeed
		err := changeFeed.AssignPropertiesFromChangeFeed(source.ChangeFeed)
		if err != nil {
			return errors.Wrap(err, "populating ChangeFeed from ChangeFeed, calling AssignPropertiesFromChangeFeed()")
		}
		storageAccountsBlobServicesSpec.ChangeFeed = &changeFeed
	} else {
		storageAccountsBlobServicesSpec.ChangeFeed = nil
	}

	// ContainerDeleteRetentionPolicy
	if source.ContainerDeleteRetentionPolicy != nil {
		var containerDeleteRetentionPolicy DeleteRetentionPolicy
		err := containerDeleteRetentionPolicy.AssignPropertiesFromDeleteRetentionPolicy(source.ContainerDeleteRetentionPolicy)
		if err != nil {
			return errors.Wrap(err, "populating ContainerDeleteRetentionPolicy from ContainerDeleteRetentionPolicy, calling AssignPropertiesFromDeleteRetentionPolicy()")
		}
		storageAccountsBlobServicesSpec.ContainerDeleteRetentionPolicy = &containerDeleteRetentionPolicy
	} else {
		storageAccountsBlobServicesSpec.ContainerDeleteRetentionPolicy = nil
	}

	// Cors
	if source.Cors != nil {
		var cor CorsRules
		err := cor.AssignPropertiesFromCorsRules(source.Cors)
		if err != nil {
			return errors.Wrap(err, "populating Cors from Cors, calling AssignPropertiesFromCorsRules()")
		}
		storageAccountsBlobServicesSpec.Cors = &cor
	} else {
		storageAccountsBlobServicesSpec.Cors = nil
	}

	// DefaultServiceVersion
	if source.DefaultServiceVersion != nil {
		defaultServiceVersion := *source.DefaultServiceVersion
		storageAccountsBlobServicesSpec.DefaultServiceVersion = &defaultServiceVersion
	} else {
		storageAccountsBlobServicesSpec.DefaultServiceVersion = nil
	}

	// DeleteRetentionPolicy
	if source.DeleteRetentionPolicy != nil {
		var deleteRetentionPolicy DeleteRetentionPolicy
		err := deleteRetentionPolicy.AssignPropertiesFromDeleteRetentionPolicy(source.DeleteRetentionPolicy)
		if err != nil {
			return errors.Wrap(err, "populating DeleteRetentionPolicy from DeleteRetentionPolicy, calling AssignPropertiesFromDeleteRetentionPolicy()")
		}
		storageAccountsBlobServicesSpec.DeleteRetentionPolicy = &deleteRetentionPolicy
	} else {
		storageAccountsBlobServicesSpec.DeleteRetentionPolicy = nil
	}

	// IsVersioningEnabled
	if source.IsVersioningEnabled != nil {
		isVersioningEnabled := *source.IsVersioningEnabled
		storageAccountsBlobServicesSpec.IsVersioningEnabled = &isVersioningEnabled
	} else {
		storageAccountsBlobServicesSpec.IsVersioningEnabled = nil
	}

	// LastAccessTimeTrackingPolicy
	if source.LastAccessTimeTrackingPolicy != nil {
		var lastAccessTimeTrackingPolicy LastAccessTimeTrackingPolicy
		err := lastAccessTimeTrackingPolicy.AssignPropertiesFromLastAccessTimeTrackingPolicy(source.LastAccessTimeTrackingPolicy)
		if err != nil {
			return errors.Wrap(err, "populating LastAccessTimeTrackingPolicy from LastAccessTimeTrackingPolicy, calling AssignPropertiesFromLastAccessTimeTrackingPolicy()")
		}
		storageAccountsBlobServicesSpec.LastAccessTimeTrackingPolicy = &lastAccessTimeTrackingPolicy
	} else {
		storageAccountsBlobServicesSpec.LastAccessTimeTrackingPolicy = nil
	}

	// Location
	if source.Location != nil {
		location := *source.Location
		storageAccountsBlobServicesSpec.Location = &location
	} else {
		storageAccountsBlobServicesSpec.Location = nil
	}

	// Owner
	storageAccountsBlobServicesSpec.Owner = source.Owner.Copy()

	// RestorePolicy
	if source.RestorePolicy != nil {
		var restorePolicy RestorePolicyProperties
		err := restorePolicy.AssignPropertiesFromRestorePolicyProperties(source.RestorePolicy)
		if err != nil {
			return errors.Wrap(err, "populating RestorePolicy from RestorePolicy, calling AssignPropertiesFromRestorePolicyProperties()")
		}
		storageAccountsBlobServicesSpec.RestorePolicy = &restorePolicy
	} else {
		storageAccountsBlobServicesSpec.RestorePolicy = nil
	}

	// Tags
	tagMap := make(map[string]string)
	for tagKey, tagValue := range source.Tags {
		// Shadow the loop variable to avoid aliasing
		tagValue := tagValue
		tagMap[tagKey] = tagValue
	}
	storageAccountsBlobServicesSpec.Tags = tagMap

	// No error
	return nil
}

// AssignPropertiesToStorageAccountsBlobServicesSpec populates the provided destination StorageAccountsBlobServices_Spec from our StorageAccountsBlobServices_Spec
func (storageAccountsBlobServicesSpec *StorageAccountsBlobServices_Spec) AssignPropertiesToStorageAccountsBlobServicesSpec(destination *v1alpha1api20210401storage.StorageAccountsBlobServices_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AutomaticSnapshotPolicyEnabled
	if storageAccountsBlobServicesSpec.AutomaticSnapshotPolicyEnabled != nil {
		automaticSnapshotPolicyEnabled := *storageAccountsBlobServicesSpec.AutomaticSnapshotPolicyEnabled
		destination.AutomaticSnapshotPolicyEnabled = &automaticSnapshotPolicyEnabled
	} else {
		destination.AutomaticSnapshotPolicyEnabled = nil
	}

	// ChangeFeed
	if storageAccountsBlobServicesSpec.ChangeFeed != nil {
		var changeFeed v1alpha1api20210401storage.ChangeFeed
		err := (*storageAccountsBlobServicesSpec.ChangeFeed).AssignPropertiesToChangeFeed(&changeFeed)
		if err != nil {
			return errors.Wrap(err, "populating ChangeFeed from ChangeFeed, calling AssignPropertiesToChangeFeed()")
		}
		destination.ChangeFeed = &changeFeed
	} else {
		destination.ChangeFeed = nil
	}

	// ContainerDeleteRetentionPolicy
	if storageAccountsBlobServicesSpec.ContainerDeleteRetentionPolicy != nil {
		var containerDeleteRetentionPolicy v1alpha1api20210401storage.DeleteRetentionPolicy
		err := (*storageAccountsBlobServicesSpec.ContainerDeleteRetentionPolicy).AssignPropertiesToDeleteRetentionPolicy(&containerDeleteRetentionPolicy)
		if err != nil {
			return errors.Wrap(err, "populating ContainerDeleteRetentionPolicy from ContainerDeleteRetentionPolicy, calling AssignPropertiesToDeleteRetentionPolicy()")
		}
		destination.ContainerDeleteRetentionPolicy = &containerDeleteRetentionPolicy
	} else {
		destination.ContainerDeleteRetentionPolicy = nil
	}

	// Cors
	if storageAccountsBlobServicesSpec.Cors != nil {
		var cor v1alpha1api20210401storage.CorsRules
		err := (*storageAccountsBlobServicesSpec.Cors).AssignPropertiesToCorsRules(&cor)
		if err != nil {
			return errors.Wrap(err, "populating Cors from Cors, calling AssignPropertiesToCorsRules()")
		}
		destination.Cors = &cor
	} else {
		destination.Cors = nil
	}

	// DefaultServiceVersion
	if storageAccountsBlobServicesSpec.DefaultServiceVersion != nil {
		defaultServiceVersion := *storageAccountsBlobServicesSpec.DefaultServiceVersion
		destination.DefaultServiceVersion = &defaultServiceVersion
	} else {
		destination.DefaultServiceVersion = nil
	}

	// DeleteRetentionPolicy
	if storageAccountsBlobServicesSpec.DeleteRetentionPolicy != nil {
		var deleteRetentionPolicy v1alpha1api20210401storage.DeleteRetentionPolicy
		err := (*storageAccountsBlobServicesSpec.DeleteRetentionPolicy).AssignPropertiesToDeleteRetentionPolicy(&deleteRetentionPolicy)
		if err != nil {
			return errors.Wrap(err, "populating DeleteRetentionPolicy from DeleteRetentionPolicy, calling AssignPropertiesToDeleteRetentionPolicy()")
		}
		destination.DeleteRetentionPolicy = &deleteRetentionPolicy
	} else {
		destination.DeleteRetentionPolicy = nil
	}

	// IsVersioningEnabled
	if storageAccountsBlobServicesSpec.IsVersioningEnabled != nil {
		isVersioningEnabled := *storageAccountsBlobServicesSpec.IsVersioningEnabled
		destination.IsVersioningEnabled = &isVersioningEnabled
	} else {
		destination.IsVersioningEnabled = nil
	}

	// LastAccessTimeTrackingPolicy
	if storageAccountsBlobServicesSpec.LastAccessTimeTrackingPolicy != nil {
		var lastAccessTimeTrackingPolicy v1alpha1api20210401storage.LastAccessTimeTrackingPolicy
		err := (*storageAccountsBlobServicesSpec.LastAccessTimeTrackingPolicy).AssignPropertiesToLastAccessTimeTrackingPolicy(&lastAccessTimeTrackingPolicy)
		if err != nil {
			return errors.Wrap(err, "populating LastAccessTimeTrackingPolicy from LastAccessTimeTrackingPolicy, calling AssignPropertiesToLastAccessTimeTrackingPolicy()")
		}
		destination.LastAccessTimeTrackingPolicy = &lastAccessTimeTrackingPolicy
	} else {
		destination.LastAccessTimeTrackingPolicy = nil
	}

	// Location
	if storageAccountsBlobServicesSpec.Location != nil {
		location := *storageAccountsBlobServicesSpec.Location
		destination.Location = &location
	} else {
		destination.Location = nil
	}

	// OriginalVersion
	destination.OriginalVersion = storageAccountsBlobServicesSpec.OriginalVersion()

	// Owner
	destination.Owner = storageAccountsBlobServicesSpec.Owner.Copy()

	// RestorePolicy
	if storageAccountsBlobServicesSpec.RestorePolicy != nil {
		var restorePolicy v1alpha1api20210401storage.RestorePolicyProperties
		err := (*storageAccountsBlobServicesSpec.RestorePolicy).AssignPropertiesToRestorePolicyProperties(&restorePolicy)
		if err != nil {
			return errors.Wrap(err, "populating RestorePolicy from RestorePolicy, calling AssignPropertiesToRestorePolicyProperties()")
		}
		destination.RestorePolicy = &restorePolicy
	} else {
		destination.RestorePolicy = nil
	}

	// Tags
	tagMap := make(map[string]string)
	for tagKey, tagValue := range storageAccountsBlobServicesSpec.Tags {
		// Shadow the loop variable to avoid aliasing
		tagValue := tagValue
		tagMap[tagKey] = tagValue
	}
	destination.Tags = tagMap

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

func (storageAccountsBlobServicesSpec *StorageAccountsBlobServices_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

//Generated from: https://schema.management.azure.com/schemas/2021-04-01/Microsoft.Storage.json#/definitions/ChangeFeed
type ChangeFeed struct {
	//Enabled: Indicates whether change feed event logging is enabled for the Blob
	//service.
	Enabled *bool `json:"enabled,omitempty"`

	// +kubebuilder:validation:Maximum=146000
	// +kubebuilder:validation:Minimum=1
	//RetentionInDays: Indicates the duration of changeFeed retention in days. Minimum
	//value is 1 day and maximum value is 146000 days (400 years). A null value
	//indicates an infinite retention of the change feed.
	RetentionInDays *int `json:"retentionInDays,omitempty"`
}

var _ genruntime.ARMTransformer = &ChangeFeed{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (changeFeed *ChangeFeed) ConvertToARM(name string, resolvedReferences genruntime.ResolvedReferences) (interface{}, error) {
	if changeFeed == nil {
		return nil, nil
	}
	var result ChangeFeedARM

	// Set property ‘Enabled’:
	if changeFeed.Enabled != nil {
		enabled := *changeFeed.Enabled
		result.Enabled = &enabled
	}

	// Set property ‘RetentionInDays’:
	if changeFeed.RetentionInDays != nil {
		retentionInDays := *changeFeed.RetentionInDays
		result.RetentionInDays = &retentionInDays
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (changeFeed *ChangeFeed) CreateEmptyARMValue() interface{} {
	return ChangeFeedARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (changeFeed *ChangeFeed) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(ChangeFeedARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ChangeFeedARM, got %T", armInput)
	}

	// Set property ‘Enabled’:
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		changeFeed.Enabled = &enabled
	}

	// Set property ‘RetentionInDays’:
	if typedInput.RetentionInDays != nil {
		retentionInDays := *typedInput.RetentionInDays
		changeFeed.RetentionInDays = &retentionInDays
	}

	// No error
	return nil
}

// AssignPropertiesFromChangeFeed populates our ChangeFeed from the provided source ChangeFeed
func (changeFeed *ChangeFeed) AssignPropertiesFromChangeFeed(source *v1alpha1api20210401storage.ChangeFeed) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		changeFeed.Enabled = &enabled
	} else {
		changeFeed.Enabled = nil
	}

	// RetentionInDays
	if source.RetentionInDays != nil {
		retentionInDay := *source.RetentionInDays
		changeFeed.RetentionInDays = &retentionInDay
	} else {
		changeFeed.RetentionInDays = nil
	}

	// No error
	return nil
}

// AssignPropertiesToChangeFeed populates the provided destination ChangeFeed from our ChangeFeed
func (changeFeed *ChangeFeed) AssignPropertiesToChangeFeed(destination *v1alpha1api20210401storage.ChangeFeed) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if changeFeed.Enabled != nil {
		enabled := *changeFeed.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// RetentionInDays
	if changeFeed.RetentionInDays != nil {
		retentionInDay := *changeFeed.RetentionInDays
		destination.RetentionInDays = &retentionInDay
	} else {
		destination.RetentionInDays = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type ChangeFeed_Status struct {
	//Enabled: Indicates whether change feed event logging is enabled for the Blob
	//service.
	Enabled *bool `json:"enabled,omitempty"`

	//RetentionInDays: Indicates the duration of changeFeed retention in days. Minimum
	//value is 1 day and maximum value is 146000 days (400 years). A null value
	//indicates an infinite retention of the change feed.
	RetentionInDays *int `json:"retentionInDays,omitempty"`
}

var _ genruntime.FromARMConverter = &ChangeFeed_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (changeFeedStatus *ChangeFeed_Status) CreateEmptyARMValue() interface{} {
	return ChangeFeed_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (changeFeedStatus *ChangeFeed_Status) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(ChangeFeed_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ChangeFeed_StatusARM, got %T", armInput)
	}

	// Set property ‘Enabled’:
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		changeFeedStatus.Enabled = &enabled
	}

	// Set property ‘RetentionInDays’:
	if typedInput.RetentionInDays != nil {
		retentionInDays := *typedInput.RetentionInDays
		changeFeedStatus.RetentionInDays = &retentionInDays
	}

	// No error
	return nil
}

// AssignPropertiesFromChangeFeedStatus populates our ChangeFeed_Status from the provided source ChangeFeed_Status
func (changeFeedStatus *ChangeFeed_Status) AssignPropertiesFromChangeFeedStatus(source *v1alpha1api20210401storage.ChangeFeed_Status) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		changeFeedStatus.Enabled = &enabled
	} else {
		changeFeedStatus.Enabled = nil
	}

	// RetentionInDays
	if source.RetentionInDays != nil {
		retentionInDay := *source.RetentionInDays
		changeFeedStatus.RetentionInDays = &retentionInDay
	} else {
		changeFeedStatus.RetentionInDays = nil
	}

	// No error
	return nil
}

// AssignPropertiesToChangeFeedStatus populates the provided destination ChangeFeed_Status from our ChangeFeed_Status
func (changeFeedStatus *ChangeFeed_Status) AssignPropertiesToChangeFeedStatus(destination *v1alpha1api20210401storage.ChangeFeed_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if changeFeedStatus.Enabled != nil {
		enabled := *changeFeedStatus.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// RetentionInDays
	if changeFeedStatus.RetentionInDays != nil {
		retentionInDay := *changeFeedStatus.RetentionInDays
		destination.RetentionInDays = &retentionInDay
	} else {
		destination.RetentionInDays = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2021-04-01/Microsoft.Storage.json#/definitions/CorsRules
type CorsRules struct {
	//CorsRules: The List of CORS rules. You can include up to five CorsRule elements
	//in the request.
	CorsRules []CorsRule `json:"corsRules,omitempty"`
}

var _ genruntime.ARMTransformer = &CorsRules{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (corsRules *CorsRules) ConvertToARM(name string, resolvedReferences genruntime.ResolvedReferences) (interface{}, error) {
	if corsRules == nil {
		return nil, nil
	}
	var result CorsRulesARM

	// Set property ‘CorsRules’:
	for _, item := range corsRules.CorsRules {
		itemARM, err := item.ConvertToARM(name, resolvedReferences)
		if err != nil {
			return nil, err
		}
		result.CorsRules = append(result.CorsRules, itemARM.(CorsRuleARM))
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (corsRules *CorsRules) CreateEmptyARMValue() interface{} {
	return CorsRulesARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (corsRules *CorsRules) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(CorsRulesARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CorsRulesARM, got %T", armInput)
	}

	// Set property ‘CorsRules’:
	for _, item := range typedInput.CorsRules {
		var item1 CorsRule
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		corsRules.CorsRules = append(corsRules.CorsRules, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromCorsRules populates our CorsRules from the provided source CorsRules
func (corsRules *CorsRules) AssignPropertiesFromCorsRules(source *v1alpha1api20210401storage.CorsRules) error {

	// CorsRules
	corsRuleList := make([]CorsRule, len(source.CorsRules))
	for corsRuleIndex, corsRuleItem := range source.CorsRules {
		// Shadow the loop variable to avoid aliasing
		corsRuleItem := corsRuleItem
		var corsRule CorsRule
		err := corsRule.AssignPropertiesFromCorsRule(&corsRuleItem)
		if err != nil {
			return errors.Wrap(err, "populating CorsRules from CorsRules, calling AssignPropertiesFromCorsRule()")
		}
		corsRuleList[corsRuleIndex] = corsRule
	}
	corsRules.CorsRules = corsRuleList

	// No error
	return nil
}

// AssignPropertiesToCorsRules populates the provided destination CorsRules from our CorsRules
func (corsRules *CorsRules) AssignPropertiesToCorsRules(destination *v1alpha1api20210401storage.CorsRules) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CorsRules
	corsRuleList := make([]v1alpha1api20210401storage.CorsRule, len(corsRules.CorsRules))
	for corsRuleIndex, corsRuleItem := range corsRules.CorsRules {
		// Shadow the loop variable to avoid aliasing
		corsRuleItem := corsRuleItem
		var corsRule v1alpha1api20210401storage.CorsRule
		err := corsRuleItem.AssignPropertiesToCorsRule(&corsRule)
		if err != nil {
			return errors.Wrap(err, "populating CorsRules from CorsRules, calling AssignPropertiesToCorsRule()")
		}
		corsRuleList[corsRuleIndex] = corsRule
	}
	destination.CorsRules = corsRuleList

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type CorsRules_Status struct {
	//CorsRules: The List of CORS rules. You can include up to five CorsRule elements
	//in the request.
	CorsRules []CorsRule_Status `json:"corsRules,omitempty"`
}

var _ genruntime.FromARMConverter = &CorsRules_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (corsRulesStatus *CorsRules_Status) CreateEmptyARMValue() interface{} {
	return CorsRules_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (corsRulesStatus *CorsRules_Status) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(CorsRules_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CorsRules_StatusARM, got %T", armInput)
	}

	// Set property ‘CorsRules’:
	for _, item := range typedInput.CorsRules {
		var item1 CorsRule_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		corsRulesStatus.CorsRules = append(corsRulesStatus.CorsRules, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromCorsRulesStatus populates our CorsRules_Status from the provided source CorsRules_Status
func (corsRulesStatus *CorsRules_Status) AssignPropertiesFromCorsRulesStatus(source *v1alpha1api20210401storage.CorsRules_Status) error {

	// CorsRules
	corsRuleList := make([]CorsRule_Status, len(source.CorsRules))
	for corsRuleIndex, corsRuleItem := range source.CorsRules {
		// Shadow the loop variable to avoid aliasing
		corsRuleItem := corsRuleItem
		var corsRule CorsRule_Status
		err := corsRule.AssignPropertiesFromCorsRuleStatus(&corsRuleItem)
		if err != nil {
			return errors.Wrap(err, "populating CorsRules from CorsRules, calling AssignPropertiesFromCorsRuleStatus()")
		}
		corsRuleList[corsRuleIndex] = corsRule
	}
	corsRulesStatus.CorsRules = corsRuleList

	// No error
	return nil
}

// AssignPropertiesToCorsRulesStatus populates the provided destination CorsRules_Status from our CorsRules_Status
func (corsRulesStatus *CorsRules_Status) AssignPropertiesToCorsRulesStatus(destination *v1alpha1api20210401storage.CorsRules_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CorsRules
	corsRuleList := make([]v1alpha1api20210401storage.CorsRule_Status, len(corsRulesStatus.CorsRules))
	for corsRuleIndex, corsRuleItem := range corsRulesStatus.CorsRules {
		// Shadow the loop variable to avoid aliasing
		corsRuleItem := corsRuleItem
		var corsRule v1alpha1api20210401storage.CorsRule_Status
		err := corsRuleItem.AssignPropertiesToCorsRuleStatus(&corsRule)
		if err != nil {
			return errors.Wrap(err, "populating CorsRules from CorsRules, calling AssignPropertiesToCorsRuleStatus()")
		}
		corsRuleList[corsRuleIndex] = corsRule
	}
	destination.CorsRules = corsRuleList

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2021-04-01/Microsoft.Storage.json#/definitions/DeleteRetentionPolicy
type DeleteRetentionPolicy struct {
	// +kubebuilder:validation:Maximum=365
	// +kubebuilder:validation:Minimum=1
	//Days: Indicates the number of days that the deleted item should be retained. The
	//minimum specified value can be 1 and the maximum value can be 365.
	Days *int `json:"days,omitempty"`

	//Enabled: Indicates whether DeleteRetentionPolicy is enabled.
	Enabled *bool `json:"enabled,omitempty"`
}

var _ genruntime.ARMTransformer = &DeleteRetentionPolicy{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (deleteRetentionPolicy *DeleteRetentionPolicy) ConvertToARM(name string, resolvedReferences genruntime.ResolvedReferences) (interface{}, error) {
	if deleteRetentionPolicy == nil {
		return nil, nil
	}
	var result DeleteRetentionPolicyARM

	// Set property ‘Days’:
	if deleteRetentionPolicy.Days != nil {
		days := *deleteRetentionPolicy.Days
		result.Days = &days
	}

	// Set property ‘Enabled’:
	if deleteRetentionPolicy.Enabled != nil {
		enabled := *deleteRetentionPolicy.Enabled
		result.Enabled = &enabled
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (deleteRetentionPolicy *DeleteRetentionPolicy) CreateEmptyARMValue() interface{} {
	return DeleteRetentionPolicyARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (deleteRetentionPolicy *DeleteRetentionPolicy) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeleteRetentionPolicyARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeleteRetentionPolicyARM, got %T", armInput)
	}

	// Set property ‘Days’:
	if typedInput.Days != nil {
		days := *typedInput.Days
		deleteRetentionPolicy.Days = &days
	}

	// Set property ‘Enabled’:
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		deleteRetentionPolicy.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignPropertiesFromDeleteRetentionPolicy populates our DeleteRetentionPolicy from the provided source DeleteRetentionPolicy
func (deleteRetentionPolicy *DeleteRetentionPolicy) AssignPropertiesFromDeleteRetentionPolicy(source *v1alpha1api20210401storage.DeleteRetentionPolicy) error {

	// Days
	if source.Days != nil {
		day := *source.Days
		deleteRetentionPolicy.Days = &day
	} else {
		deleteRetentionPolicy.Days = nil
	}

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		deleteRetentionPolicy.Enabled = &enabled
	} else {
		deleteRetentionPolicy.Enabled = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDeleteRetentionPolicy populates the provided destination DeleteRetentionPolicy from our DeleteRetentionPolicy
func (deleteRetentionPolicy *DeleteRetentionPolicy) AssignPropertiesToDeleteRetentionPolicy(destination *v1alpha1api20210401storage.DeleteRetentionPolicy) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Days
	if deleteRetentionPolicy.Days != nil {
		day := *deleteRetentionPolicy.Days
		destination.Days = &day
	} else {
		destination.Days = nil
	}

	// Enabled
	if deleteRetentionPolicy.Enabled != nil {
		enabled := *deleteRetentionPolicy.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type DeleteRetentionPolicy_Status struct {
	//Days: Indicates the number of days that the deleted item should be retained. The
	//minimum specified value can be 1 and the maximum value can be 365.
	Days *int `json:"days,omitempty"`

	//Enabled: Indicates whether DeleteRetentionPolicy is enabled.
	Enabled *bool `json:"enabled,omitempty"`
}

var _ genruntime.FromARMConverter = &DeleteRetentionPolicy_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (deleteRetentionPolicyStatus *DeleteRetentionPolicy_Status) CreateEmptyARMValue() interface{} {
	return DeleteRetentionPolicy_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (deleteRetentionPolicyStatus *DeleteRetentionPolicy_Status) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeleteRetentionPolicy_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeleteRetentionPolicy_StatusARM, got %T", armInput)
	}

	// Set property ‘Days’:
	if typedInput.Days != nil {
		days := *typedInput.Days
		deleteRetentionPolicyStatus.Days = &days
	}

	// Set property ‘Enabled’:
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		deleteRetentionPolicyStatus.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignPropertiesFromDeleteRetentionPolicyStatus populates our DeleteRetentionPolicy_Status from the provided source DeleteRetentionPolicy_Status
func (deleteRetentionPolicyStatus *DeleteRetentionPolicy_Status) AssignPropertiesFromDeleteRetentionPolicyStatus(source *v1alpha1api20210401storage.DeleteRetentionPolicy_Status) error {

	// Days
	if source.Days != nil {
		day := *source.Days
		deleteRetentionPolicyStatus.Days = &day
	} else {
		deleteRetentionPolicyStatus.Days = nil
	}

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		deleteRetentionPolicyStatus.Enabled = &enabled
	} else {
		deleteRetentionPolicyStatus.Enabled = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDeleteRetentionPolicyStatus populates the provided destination DeleteRetentionPolicy_Status from our DeleteRetentionPolicy_Status
func (deleteRetentionPolicyStatus *DeleteRetentionPolicy_Status) AssignPropertiesToDeleteRetentionPolicyStatus(destination *v1alpha1api20210401storage.DeleteRetentionPolicy_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Days
	if deleteRetentionPolicyStatus.Days != nil {
		day := *deleteRetentionPolicyStatus.Days
		destination.Days = &day
	} else {
		destination.Days = nil
	}

	// Enabled
	if deleteRetentionPolicyStatus.Enabled != nil {
		enabled := *deleteRetentionPolicyStatus.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2021-04-01/Microsoft.Storage.json#/definitions/LastAccessTimeTrackingPolicy
type LastAccessTimeTrackingPolicy struct {
	//BlobType: An array of predefined supported blob types. Only blockBlob is the
	//supported value. This field is currently read only
	BlobType []string `json:"blobType,omitempty"`

	// +kubebuilder:validation:Required
	//Enable: When set to true last access time based tracking is enabled.
	Enable bool `json:"enable"`

	//Name: Name of the policy. The valid value is AccessTimeTracking. This field is
	//currently read only.
	Name *LastAccessTimeTrackingPolicyName `json:"name,omitempty"`

	//TrackingGranularityInDays: The field specifies blob object tracking granularity
	//in days, typically how often the blob object should be tracked.This field is
	//currently read only with value as 1
	TrackingGranularityInDays *int `json:"trackingGranularityInDays,omitempty"`
}

var _ genruntime.ARMTransformer = &LastAccessTimeTrackingPolicy{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (lastAccessTimeTrackingPolicy *LastAccessTimeTrackingPolicy) ConvertToARM(name string, resolvedReferences genruntime.ResolvedReferences) (interface{}, error) {
	if lastAccessTimeTrackingPolicy == nil {
		return nil, nil
	}
	var result LastAccessTimeTrackingPolicyARM

	// Set property ‘BlobType’:
	for _, item := range lastAccessTimeTrackingPolicy.BlobType {
		result.BlobType = append(result.BlobType, item)
	}

	// Set property ‘Enable’:
	result.Enable = lastAccessTimeTrackingPolicy.Enable

	// Set property ‘Name’:
	if lastAccessTimeTrackingPolicy.Name != nil {
		name := *lastAccessTimeTrackingPolicy.Name
		result.Name = &name
	}

	// Set property ‘TrackingGranularityInDays’:
	if lastAccessTimeTrackingPolicy.TrackingGranularityInDays != nil {
		trackingGranularityInDays := *lastAccessTimeTrackingPolicy.TrackingGranularityInDays
		result.TrackingGranularityInDays = &trackingGranularityInDays
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (lastAccessTimeTrackingPolicy *LastAccessTimeTrackingPolicy) CreateEmptyARMValue() interface{} {
	return LastAccessTimeTrackingPolicyARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (lastAccessTimeTrackingPolicy *LastAccessTimeTrackingPolicy) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(LastAccessTimeTrackingPolicyARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LastAccessTimeTrackingPolicyARM, got %T", armInput)
	}

	// Set property ‘BlobType’:
	for _, item := range typedInput.BlobType {
		lastAccessTimeTrackingPolicy.BlobType = append(lastAccessTimeTrackingPolicy.BlobType, item)
	}

	// Set property ‘Enable’:
	lastAccessTimeTrackingPolicy.Enable = typedInput.Enable

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		lastAccessTimeTrackingPolicy.Name = &name
	}

	// Set property ‘TrackingGranularityInDays’:
	if typedInput.TrackingGranularityInDays != nil {
		trackingGranularityInDays := *typedInput.TrackingGranularityInDays
		lastAccessTimeTrackingPolicy.TrackingGranularityInDays = &trackingGranularityInDays
	}

	// No error
	return nil
}

// AssignPropertiesFromLastAccessTimeTrackingPolicy populates our LastAccessTimeTrackingPolicy from the provided source LastAccessTimeTrackingPolicy
func (lastAccessTimeTrackingPolicy *LastAccessTimeTrackingPolicy) AssignPropertiesFromLastAccessTimeTrackingPolicy(source *v1alpha1api20210401storage.LastAccessTimeTrackingPolicy) error {

	// BlobType
	blobTypeList := make([]string, len(source.BlobType))
	for blobTypeIndex, blobTypeItem := range source.BlobType {
		// Shadow the loop variable to avoid aliasing
		blobTypeItem := blobTypeItem
		blobTypeList[blobTypeIndex] = blobTypeItem
	}
	lastAccessTimeTrackingPolicy.BlobType = blobTypeList

	// Enable
	if source.Enable != nil {
		lastAccessTimeTrackingPolicy.Enable = *source.Enable
	} else {
		lastAccessTimeTrackingPolicy.Enable = false
	}

	// Name
	if source.Name != nil {
		name := LastAccessTimeTrackingPolicyName(*source.Name)
		lastAccessTimeTrackingPolicy.Name = &name
	} else {
		lastAccessTimeTrackingPolicy.Name = nil
	}

	// TrackingGranularityInDays
	if source.TrackingGranularityInDays != nil {
		trackingGranularityInDay := *source.TrackingGranularityInDays
		lastAccessTimeTrackingPolicy.TrackingGranularityInDays = &trackingGranularityInDay
	} else {
		lastAccessTimeTrackingPolicy.TrackingGranularityInDays = nil
	}

	// No error
	return nil
}

// AssignPropertiesToLastAccessTimeTrackingPolicy populates the provided destination LastAccessTimeTrackingPolicy from our LastAccessTimeTrackingPolicy
func (lastAccessTimeTrackingPolicy *LastAccessTimeTrackingPolicy) AssignPropertiesToLastAccessTimeTrackingPolicy(destination *v1alpha1api20210401storage.LastAccessTimeTrackingPolicy) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BlobType
	blobTypeList := make([]string, len(lastAccessTimeTrackingPolicy.BlobType))
	for blobTypeIndex, blobTypeItem := range lastAccessTimeTrackingPolicy.BlobType {
		// Shadow the loop variable to avoid aliasing
		blobTypeItem := blobTypeItem
		blobTypeList[blobTypeIndex] = blobTypeItem
	}
	destination.BlobType = blobTypeList

	// Enable
	enable := lastAccessTimeTrackingPolicy.Enable
	destination.Enable = &enable

	// Name
	if lastAccessTimeTrackingPolicy.Name != nil {
		name := string(*lastAccessTimeTrackingPolicy.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// TrackingGranularityInDays
	if lastAccessTimeTrackingPolicy.TrackingGranularityInDays != nil {
		trackingGranularityInDay := *lastAccessTimeTrackingPolicy.TrackingGranularityInDays
		destination.TrackingGranularityInDays = &trackingGranularityInDay
	} else {
		destination.TrackingGranularityInDays = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type LastAccessTimeTrackingPolicy_Status struct {
	//BlobType: An array of predefined supported blob types. Only blockBlob is the
	//supported value. This field is currently read only
	BlobType []string `json:"blobType,omitempty"`

	// +kubebuilder:validation:Required
	//Enable: When set to true last access time based tracking is enabled.
	Enable bool `json:"enable"`

	//Name: Name of the policy. The valid value is AccessTimeTracking. This field is
	//currently read only
	Name *LastAccessTimeTrackingPolicyStatusName `json:"name,omitempty"`

	//TrackingGranularityInDays: The field specifies blob object tracking granularity
	//in days, typically how often the blob object should be tracked.This field is
	//currently read only with value as 1
	TrackingGranularityInDays *int `json:"trackingGranularityInDays,omitempty"`
}

var _ genruntime.FromARMConverter = &LastAccessTimeTrackingPolicy_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (lastAccessTimeTrackingPolicyStatus *LastAccessTimeTrackingPolicy_Status) CreateEmptyARMValue() interface{} {
	return LastAccessTimeTrackingPolicy_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (lastAccessTimeTrackingPolicyStatus *LastAccessTimeTrackingPolicy_Status) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(LastAccessTimeTrackingPolicy_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LastAccessTimeTrackingPolicy_StatusARM, got %T", armInput)
	}

	// Set property ‘BlobType’:
	for _, item := range typedInput.BlobType {
		lastAccessTimeTrackingPolicyStatus.BlobType = append(lastAccessTimeTrackingPolicyStatus.BlobType, item)
	}

	// Set property ‘Enable’:
	lastAccessTimeTrackingPolicyStatus.Enable = typedInput.Enable

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		lastAccessTimeTrackingPolicyStatus.Name = &name
	}

	// Set property ‘TrackingGranularityInDays’:
	if typedInput.TrackingGranularityInDays != nil {
		trackingGranularityInDays := *typedInput.TrackingGranularityInDays
		lastAccessTimeTrackingPolicyStatus.TrackingGranularityInDays = &trackingGranularityInDays
	}

	// No error
	return nil
}

// AssignPropertiesFromLastAccessTimeTrackingPolicyStatus populates our LastAccessTimeTrackingPolicy_Status from the provided source LastAccessTimeTrackingPolicy_Status
func (lastAccessTimeTrackingPolicyStatus *LastAccessTimeTrackingPolicy_Status) AssignPropertiesFromLastAccessTimeTrackingPolicyStatus(source *v1alpha1api20210401storage.LastAccessTimeTrackingPolicy_Status) error {

	// BlobType
	blobTypeList := make([]string, len(source.BlobType))
	for blobTypeIndex, blobTypeItem := range source.BlobType {
		// Shadow the loop variable to avoid aliasing
		blobTypeItem := blobTypeItem
		blobTypeList[blobTypeIndex] = blobTypeItem
	}
	lastAccessTimeTrackingPolicyStatus.BlobType = blobTypeList

	// Enable
	if source.Enable != nil {
		lastAccessTimeTrackingPolicyStatus.Enable = *source.Enable
	} else {
		lastAccessTimeTrackingPolicyStatus.Enable = false
	}

	// Name
	if source.Name != nil {
		name := LastAccessTimeTrackingPolicyStatusName(*source.Name)
		lastAccessTimeTrackingPolicyStatus.Name = &name
	} else {
		lastAccessTimeTrackingPolicyStatus.Name = nil
	}

	// TrackingGranularityInDays
	if source.TrackingGranularityInDays != nil {
		trackingGranularityInDay := *source.TrackingGranularityInDays
		lastAccessTimeTrackingPolicyStatus.TrackingGranularityInDays = &trackingGranularityInDay
	} else {
		lastAccessTimeTrackingPolicyStatus.TrackingGranularityInDays = nil
	}

	// No error
	return nil
}

// AssignPropertiesToLastAccessTimeTrackingPolicyStatus populates the provided destination LastAccessTimeTrackingPolicy_Status from our LastAccessTimeTrackingPolicy_Status
func (lastAccessTimeTrackingPolicyStatus *LastAccessTimeTrackingPolicy_Status) AssignPropertiesToLastAccessTimeTrackingPolicyStatus(destination *v1alpha1api20210401storage.LastAccessTimeTrackingPolicy_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BlobType
	blobTypeList := make([]string, len(lastAccessTimeTrackingPolicyStatus.BlobType))
	for blobTypeIndex, blobTypeItem := range lastAccessTimeTrackingPolicyStatus.BlobType {
		// Shadow the loop variable to avoid aliasing
		blobTypeItem := blobTypeItem
		blobTypeList[blobTypeIndex] = blobTypeItem
	}
	destination.BlobType = blobTypeList

	// Enable
	enable := lastAccessTimeTrackingPolicyStatus.Enable
	destination.Enable = &enable

	// Name
	if lastAccessTimeTrackingPolicyStatus.Name != nil {
		name := string(*lastAccessTimeTrackingPolicyStatus.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// TrackingGranularityInDays
	if lastAccessTimeTrackingPolicyStatus.TrackingGranularityInDays != nil {
		trackingGranularityInDay := *lastAccessTimeTrackingPolicyStatus.TrackingGranularityInDays
		destination.TrackingGranularityInDays = &trackingGranularityInDay
	} else {
		destination.TrackingGranularityInDays = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2021-04-01/Microsoft.Storage.json#/definitions/RestorePolicyProperties
type RestorePolicyProperties struct {
	// +kubebuilder:validation:Maximum=365
	// +kubebuilder:validation:Minimum=1
	//Days: how long this blob can be restored. It should be great than zero and less
	//than DeleteRetentionPolicy.days.
	Days *int `json:"days,omitempty"`

	// +kubebuilder:validation:Required
	//Enabled: Blob restore is enabled if set to true.
	Enabled bool `json:"enabled"`
}

var _ genruntime.ARMTransformer = &RestorePolicyProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (restorePolicyProperties *RestorePolicyProperties) ConvertToARM(name string, resolvedReferences genruntime.ResolvedReferences) (interface{}, error) {
	if restorePolicyProperties == nil {
		return nil, nil
	}
	var result RestorePolicyPropertiesARM

	// Set property ‘Days’:
	if restorePolicyProperties.Days != nil {
		days := *restorePolicyProperties.Days
		result.Days = &days
	}

	// Set property ‘Enabled’:
	result.Enabled = restorePolicyProperties.Enabled
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (restorePolicyProperties *RestorePolicyProperties) CreateEmptyARMValue() interface{} {
	return RestorePolicyPropertiesARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (restorePolicyProperties *RestorePolicyProperties) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(RestorePolicyPropertiesARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected RestorePolicyPropertiesARM, got %T", armInput)
	}

	// Set property ‘Days’:
	if typedInput.Days != nil {
		days := *typedInput.Days
		restorePolicyProperties.Days = &days
	}

	// Set property ‘Enabled’:
	restorePolicyProperties.Enabled = typedInput.Enabled

	// No error
	return nil
}

// AssignPropertiesFromRestorePolicyProperties populates our RestorePolicyProperties from the provided source RestorePolicyProperties
func (restorePolicyProperties *RestorePolicyProperties) AssignPropertiesFromRestorePolicyProperties(source *v1alpha1api20210401storage.RestorePolicyProperties) error {

	// Days
	if source.Days != nil {
		day := *source.Days
		restorePolicyProperties.Days = &day
	} else {
		restorePolicyProperties.Days = nil
	}

	// Enabled
	if source.Enabled != nil {
		restorePolicyProperties.Enabled = *source.Enabled
	} else {
		restorePolicyProperties.Enabled = false
	}

	// No error
	return nil
}

// AssignPropertiesToRestorePolicyProperties populates the provided destination RestorePolicyProperties from our RestorePolicyProperties
func (restorePolicyProperties *RestorePolicyProperties) AssignPropertiesToRestorePolicyProperties(destination *v1alpha1api20210401storage.RestorePolicyProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Days
	if restorePolicyProperties.Days != nil {
		day := *restorePolicyProperties.Days
		destination.Days = &day
	} else {
		destination.Days = nil
	}

	// Enabled
	enabled := restorePolicyProperties.Enabled
	destination.Enabled = &enabled

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type RestorePolicyProperties_Status struct {
	//Days: how long this blob can be restored. It should be great than zero and less
	//than DeleteRetentionPolicy.days.
	Days *int `json:"days,omitempty"`

	// +kubebuilder:validation:Required
	//Enabled: Blob restore is enabled if set to true.
	Enabled bool `json:"enabled"`

	//LastEnabledTime: Deprecated in favor of minRestoreTime property.
	LastEnabledTime *string `json:"lastEnabledTime,omitempty"`

	//MinRestoreTime: Returns the minimum date and time that the restore can be
	//started.
	MinRestoreTime *string `json:"minRestoreTime,omitempty"`
}

var _ genruntime.FromARMConverter = &RestorePolicyProperties_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (restorePolicyPropertiesStatus *RestorePolicyProperties_Status) CreateEmptyARMValue() interface{} {
	return RestorePolicyProperties_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (restorePolicyPropertiesStatus *RestorePolicyProperties_Status) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(RestorePolicyProperties_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected RestorePolicyProperties_StatusARM, got %T", armInput)
	}

	// Set property ‘Days’:
	if typedInput.Days != nil {
		days := *typedInput.Days
		restorePolicyPropertiesStatus.Days = &days
	}

	// Set property ‘Enabled’:
	restorePolicyPropertiesStatus.Enabled = typedInput.Enabled

	// Set property ‘LastEnabledTime’:
	if typedInput.LastEnabledTime != nil {
		lastEnabledTime := *typedInput.LastEnabledTime
		restorePolicyPropertiesStatus.LastEnabledTime = &lastEnabledTime
	}

	// Set property ‘MinRestoreTime’:
	if typedInput.MinRestoreTime != nil {
		minRestoreTime := *typedInput.MinRestoreTime
		restorePolicyPropertiesStatus.MinRestoreTime = &minRestoreTime
	}

	// No error
	return nil
}

// AssignPropertiesFromRestorePolicyPropertiesStatus populates our RestorePolicyProperties_Status from the provided source RestorePolicyProperties_Status
func (restorePolicyPropertiesStatus *RestorePolicyProperties_Status) AssignPropertiesFromRestorePolicyPropertiesStatus(source *v1alpha1api20210401storage.RestorePolicyProperties_Status) error {

	// Days
	if source.Days != nil {
		day := *source.Days
		restorePolicyPropertiesStatus.Days = &day
	} else {
		restorePolicyPropertiesStatus.Days = nil
	}

	// Enabled
	if source.Enabled != nil {
		restorePolicyPropertiesStatus.Enabled = *source.Enabled
	} else {
		restorePolicyPropertiesStatus.Enabled = false
	}

	// LastEnabledTime
	if source.LastEnabledTime != nil {
		lastEnabledTime := *source.LastEnabledTime
		restorePolicyPropertiesStatus.LastEnabledTime = &lastEnabledTime
	} else {
		restorePolicyPropertiesStatus.LastEnabledTime = nil
	}

	// MinRestoreTime
	if source.MinRestoreTime != nil {
		minRestoreTime := *source.MinRestoreTime
		restorePolicyPropertiesStatus.MinRestoreTime = &minRestoreTime
	} else {
		restorePolicyPropertiesStatus.MinRestoreTime = nil
	}

	// No error
	return nil
}

// AssignPropertiesToRestorePolicyPropertiesStatus populates the provided destination RestorePolicyProperties_Status from our RestorePolicyProperties_Status
func (restorePolicyPropertiesStatus *RestorePolicyProperties_Status) AssignPropertiesToRestorePolicyPropertiesStatus(destination *v1alpha1api20210401storage.RestorePolicyProperties_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Days
	if restorePolicyPropertiesStatus.Days != nil {
		day := *restorePolicyPropertiesStatus.Days
		destination.Days = &day
	} else {
		destination.Days = nil
	}

	// Enabled
	enabled := restorePolicyPropertiesStatus.Enabled
	destination.Enabled = &enabled

	// LastEnabledTime
	if restorePolicyPropertiesStatus.LastEnabledTime != nil {
		lastEnabledTime := *restorePolicyPropertiesStatus.LastEnabledTime
		destination.LastEnabledTime = &lastEnabledTime
	} else {
		destination.LastEnabledTime = nil
	}

	// MinRestoreTime
	if restorePolicyPropertiesStatus.MinRestoreTime != nil {
		minRestoreTime := *restorePolicyPropertiesStatus.MinRestoreTime
		destination.MinRestoreTime = &minRestoreTime
	} else {
		destination.MinRestoreTime = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2021-04-01/Microsoft.Storage.json#/definitions/CorsRule
type CorsRule struct {
	// +kubebuilder:validation:Required
	//AllowedHeaders: Required if CorsRule element is present. A list of headers
	//allowed to be part of the cross-origin request.
	AllowedHeaders []string `json:"allowedHeaders"`

	// +kubebuilder:validation:Required
	//AllowedMethods: Required if CorsRule element is present. A list of HTTP methods
	//that are allowed to be executed by the origin.
	AllowedMethods []CorsRuleAllowedMethods `json:"allowedMethods"`

	// +kubebuilder:validation:Required
	//AllowedOrigins: Required if CorsRule element is present. A list of origin
	//domains that will be allowed via CORS, or "*" to allow all domains
	AllowedOrigins []string `json:"allowedOrigins"`

	// +kubebuilder:validation:Required
	//ExposedHeaders: Required if CorsRule element is present. A list of response
	//headers to expose to CORS clients.
	ExposedHeaders []string `json:"exposedHeaders"`

	// +kubebuilder:validation:Required
	//MaxAgeInSeconds: Required if CorsRule element is present. The number of seconds
	//that the client/browser should cache a preflight response.
	MaxAgeInSeconds int `json:"maxAgeInSeconds"`
}

var _ genruntime.ARMTransformer = &CorsRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (corsRule *CorsRule) ConvertToARM(name string, resolvedReferences genruntime.ResolvedReferences) (interface{}, error) {
	if corsRule == nil {
		return nil, nil
	}
	var result CorsRuleARM

	// Set property ‘AllowedHeaders’:
	for _, item := range corsRule.AllowedHeaders {
		result.AllowedHeaders = append(result.AllowedHeaders, item)
	}

	// Set property ‘AllowedMethods’:
	for _, item := range corsRule.AllowedMethods {
		result.AllowedMethods = append(result.AllowedMethods, item)
	}

	// Set property ‘AllowedOrigins’:
	for _, item := range corsRule.AllowedOrigins {
		result.AllowedOrigins = append(result.AllowedOrigins, item)
	}

	// Set property ‘ExposedHeaders’:
	for _, item := range corsRule.ExposedHeaders {
		result.ExposedHeaders = append(result.ExposedHeaders, item)
	}

	// Set property ‘MaxAgeInSeconds’:
	result.MaxAgeInSeconds = corsRule.MaxAgeInSeconds
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (corsRule *CorsRule) CreateEmptyARMValue() interface{} {
	return CorsRuleARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (corsRule *CorsRule) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(CorsRuleARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CorsRuleARM, got %T", armInput)
	}

	// Set property ‘AllowedHeaders’:
	for _, item := range typedInput.AllowedHeaders {
		corsRule.AllowedHeaders = append(corsRule.AllowedHeaders, item)
	}

	// Set property ‘AllowedMethods’:
	for _, item := range typedInput.AllowedMethods {
		corsRule.AllowedMethods = append(corsRule.AllowedMethods, item)
	}

	// Set property ‘AllowedOrigins’:
	for _, item := range typedInput.AllowedOrigins {
		corsRule.AllowedOrigins = append(corsRule.AllowedOrigins, item)
	}

	// Set property ‘ExposedHeaders’:
	for _, item := range typedInput.ExposedHeaders {
		corsRule.ExposedHeaders = append(corsRule.ExposedHeaders, item)
	}

	// Set property ‘MaxAgeInSeconds’:
	corsRule.MaxAgeInSeconds = typedInput.MaxAgeInSeconds

	// No error
	return nil
}

// AssignPropertiesFromCorsRule populates our CorsRule from the provided source CorsRule
func (corsRule *CorsRule) AssignPropertiesFromCorsRule(source *v1alpha1api20210401storage.CorsRule) error {

	// AllowedHeaders
	allowedHeaderList := make([]string, len(source.AllowedHeaders))
	for allowedHeaderIndex, allowedHeaderItem := range source.AllowedHeaders {
		// Shadow the loop variable to avoid aliasing
		allowedHeaderItem := allowedHeaderItem
		allowedHeaderList[allowedHeaderIndex] = allowedHeaderItem
	}
	corsRule.AllowedHeaders = allowedHeaderList

	// AllowedMethods
	allowedMethodList := make([]CorsRuleAllowedMethods, len(source.AllowedMethods))
	for allowedMethodIndex, allowedMethodItem := range source.AllowedMethods {
		// Shadow the loop variable to avoid aliasing
		allowedMethodItem := allowedMethodItem
		allowedMethodList[allowedMethodIndex] = CorsRuleAllowedMethods(allowedMethodItem)
	}
	corsRule.AllowedMethods = allowedMethodList

	// AllowedOrigins
	allowedOriginList := make([]string, len(source.AllowedOrigins))
	for allowedOriginIndex, allowedOriginItem := range source.AllowedOrigins {
		// Shadow the loop variable to avoid aliasing
		allowedOriginItem := allowedOriginItem
		allowedOriginList[allowedOriginIndex] = allowedOriginItem
	}
	corsRule.AllowedOrigins = allowedOriginList

	// ExposedHeaders
	exposedHeaderList := make([]string, len(source.ExposedHeaders))
	for exposedHeaderIndex, exposedHeaderItem := range source.ExposedHeaders {
		// Shadow the loop variable to avoid aliasing
		exposedHeaderItem := exposedHeaderItem
		exposedHeaderList[exposedHeaderIndex] = exposedHeaderItem
	}
	corsRule.ExposedHeaders = exposedHeaderList

	// MaxAgeInSeconds
	if source.MaxAgeInSeconds != nil {
		corsRule.MaxAgeInSeconds = *source.MaxAgeInSeconds
	} else {
		corsRule.MaxAgeInSeconds = 0
	}

	// No error
	return nil
}

// AssignPropertiesToCorsRule populates the provided destination CorsRule from our CorsRule
func (corsRule *CorsRule) AssignPropertiesToCorsRule(destination *v1alpha1api20210401storage.CorsRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllowedHeaders
	allowedHeaderList := make([]string, len(corsRule.AllowedHeaders))
	for allowedHeaderIndex, allowedHeaderItem := range corsRule.AllowedHeaders {
		// Shadow the loop variable to avoid aliasing
		allowedHeaderItem := allowedHeaderItem
		allowedHeaderList[allowedHeaderIndex] = allowedHeaderItem
	}
	destination.AllowedHeaders = allowedHeaderList

	// AllowedMethods
	allowedMethodList := make([]string, len(corsRule.AllowedMethods))
	for allowedMethodIndex, allowedMethodItem := range corsRule.AllowedMethods {
		// Shadow the loop variable to avoid aliasing
		allowedMethodItem := allowedMethodItem
		allowedMethodList[allowedMethodIndex] = string(allowedMethodItem)
	}
	destination.AllowedMethods = allowedMethodList

	// AllowedOrigins
	allowedOriginList := make([]string, len(corsRule.AllowedOrigins))
	for allowedOriginIndex, allowedOriginItem := range corsRule.AllowedOrigins {
		// Shadow the loop variable to avoid aliasing
		allowedOriginItem := allowedOriginItem
		allowedOriginList[allowedOriginIndex] = allowedOriginItem
	}
	destination.AllowedOrigins = allowedOriginList

	// ExposedHeaders
	exposedHeaderList := make([]string, len(corsRule.ExposedHeaders))
	for exposedHeaderIndex, exposedHeaderItem := range corsRule.ExposedHeaders {
		// Shadow the loop variable to avoid aliasing
		exposedHeaderItem := exposedHeaderItem
		exposedHeaderList[exposedHeaderIndex] = exposedHeaderItem
	}
	destination.ExposedHeaders = exposedHeaderList

	// MaxAgeInSeconds
	maxAgeInSecond := corsRule.MaxAgeInSeconds
	destination.MaxAgeInSeconds = &maxAgeInSecond

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type CorsRule_Status struct {
	// +kubebuilder:validation:Required
	//AllowedHeaders: Required if CorsRule element is present. A list of headers
	//allowed to be part of the cross-origin request.
	AllowedHeaders []string `json:"allowedHeaders"`

	// +kubebuilder:validation:Required
	//AllowedMethods: Required if CorsRule element is present. A list of HTTP methods
	//that are allowed to be executed by the origin.
	AllowedMethods []CorsRuleStatusAllowedMethods `json:"allowedMethods"`

	// +kubebuilder:validation:Required
	//AllowedOrigins: Required if CorsRule element is present. A list of origin
	//domains that will be allowed via CORS, or "*" to allow all domains
	AllowedOrigins []string `json:"allowedOrigins"`

	// +kubebuilder:validation:Required
	//ExposedHeaders: Required if CorsRule element is present. A list of response
	//headers to expose to CORS clients.
	ExposedHeaders []string `json:"exposedHeaders"`

	// +kubebuilder:validation:Required
	//MaxAgeInSeconds: Required if CorsRule element is present. The number of seconds
	//that the client/browser should cache a preflight response.
	MaxAgeInSeconds int `json:"maxAgeInSeconds"`
}

var _ genruntime.FromARMConverter = &CorsRule_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (corsRuleStatus *CorsRule_Status) CreateEmptyARMValue() interface{} {
	return CorsRule_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (corsRuleStatus *CorsRule_Status) PopulateFromARM(owner genruntime.KnownResourceReference, armInput interface{}) error {
	typedInput, ok := armInput.(CorsRule_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CorsRule_StatusARM, got %T", armInput)
	}

	// Set property ‘AllowedHeaders’:
	for _, item := range typedInput.AllowedHeaders {
		corsRuleStatus.AllowedHeaders = append(corsRuleStatus.AllowedHeaders, item)
	}

	// Set property ‘AllowedMethods’:
	for _, item := range typedInput.AllowedMethods {
		corsRuleStatus.AllowedMethods = append(corsRuleStatus.AllowedMethods, item)
	}

	// Set property ‘AllowedOrigins’:
	for _, item := range typedInput.AllowedOrigins {
		corsRuleStatus.AllowedOrigins = append(corsRuleStatus.AllowedOrigins, item)
	}

	// Set property ‘ExposedHeaders’:
	for _, item := range typedInput.ExposedHeaders {
		corsRuleStatus.ExposedHeaders = append(corsRuleStatus.ExposedHeaders, item)
	}

	// Set property ‘MaxAgeInSeconds’:
	corsRuleStatus.MaxAgeInSeconds = typedInput.MaxAgeInSeconds

	// No error
	return nil
}

// AssignPropertiesFromCorsRuleStatus populates our CorsRule_Status from the provided source CorsRule_Status
func (corsRuleStatus *CorsRule_Status) AssignPropertiesFromCorsRuleStatus(source *v1alpha1api20210401storage.CorsRule_Status) error {

	// AllowedHeaders
	allowedHeaderList := make([]string, len(source.AllowedHeaders))
	for allowedHeaderIndex, allowedHeaderItem := range source.AllowedHeaders {
		// Shadow the loop variable to avoid aliasing
		allowedHeaderItem := allowedHeaderItem
		allowedHeaderList[allowedHeaderIndex] = allowedHeaderItem
	}
	corsRuleStatus.AllowedHeaders = allowedHeaderList

	// AllowedMethods
	allowedMethodList := make([]CorsRuleStatusAllowedMethods, len(source.AllowedMethods))
	for allowedMethodIndex, allowedMethodItem := range source.AllowedMethods {
		// Shadow the loop variable to avoid aliasing
		allowedMethodItem := allowedMethodItem
		allowedMethodList[allowedMethodIndex] = CorsRuleStatusAllowedMethods(allowedMethodItem)
	}
	corsRuleStatus.AllowedMethods = allowedMethodList

	// AllowedOrigins
	allowedOriginList := make([]string, len(source.AllowedOrigins))
	for allowedOriginIndex, allowedOriginItem := range source.AllowedOrigins {
		// Shadow the loop variable to avoid aliasing
		allowedOriginItem := allowedOriginItem
		allowedOriginList[allowedOriginIndex] = allowedOriginItem
	}
	corsRuleStatus.AllowedOrigins = allowedOriginList

	// ExposedHeaders
	exposedHeaderList := make([]string, len(source.ExposedHeaders))
	for exposedHeaderIndex, exposedHeaderItem := range source.ExposedHeaders {
		// Shadow the loop variable to avoid aliasing
		exposedHeaderItem := exposedHeaderItem
		exposedHeaderList[exposedHeaderIndex] = exposedHeaderItem
	}
	corsRuleStatus.ExposedHeaders = exposedHeaderList

	// MaxAgeInSeconds
	if source.MaxAgeInSeconds != nil {
		corsRuleStatus.MaxAgeInSeconds = *source.MaxAgeInSeconds
	} else {
		corsRuleStatus.MaxAgeInSeconds = 0
	}

	// No error
	return nil
}

// AssignPropertiesToCorsRuleStatus populates the provided destination CorsRule_Status from our CorsRule_Status
func (corsRuleStatus *CorsRule_Status) AssignPropertiesToCorsRuleStatus(destination *v1alpha1api20210401storage.CorsRule_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllowedHeaders
	allowedHeaderList := make([]string, len(corsRuleStatus.AllowedHeaders))
	for allowedHeaderIndex, allowedHeaderItem := range corsRuleStatus.AllowedHeaders {
		// Shadow the loop variable to avoid aliasing
		allowedHeaderItem := allowedHeaderItem
		allowedHeaderList[allowedHeaderIndex] = allowedHeaderItem
	}
	destination.AllowedHeaders = allowedHeaderList

	// AllowedMethods
	allowedMethodList := make([]string, len(corsRuleStatus.AllowedMethods))
	for allowedMethodIndex, allowedMethodItem := range corsRuleStatus.AllowedMethods {
		// Shadow the loop variable to avoid aliasing
		allowedMethodItem := allowedMethodItem
		allowedMethodList[allowedMethodIndex] = string(allowedMethodItem)
	}
	destination.AllowedMethods = allowedMethodList

	// AllowedOrigins
	allowedOriginList := make([]string, len(corsRuleStatus.AllowedOrigins))
	for allowedOriginIndex, allowedOriginItem := range corsRuleStatus.AllowedOrigins {
		// Shadow the loop variable to avoid aliasing
		allowedOriginItem := allowedOriginItem
		allowedOriginList[allowedOriginIndex] = allowedOriginItem
	}
	destination.AllowedOrigins = allowedOriginList

	// ExposedHeaders
	exposedHeaderList := make([]string, len(corsRuleStatus.ExposedHeaders))
	for exposedHeaderIndex, exposedHeaderItem := range corsRuleStatus.ExposedHeaders {
		// Shadow the loop variable to avoid aliasing
		exposedHeaderItem := exposedHeaderItem
		exposedHeaderList[exposedHeaderIndex] = exposedHeaderItem
	}
	destination.ExposedHeaders = exposedHeaderList

	// MaxAgeInSeconds
	maxAgeInSecond := corsRuleStatus.MaxAgeInSeconds
	destination.MaxAgeInSeconds = &maxAgeInSecond

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"AccessTimeTracking"}
type LastAccessTimeTrackingPolicyName string

const LastAccessTimeTrackingPolicyNameAccessTimeTracking = LastAccessTimeTrackingPolicyName("AccessTimeTracking")

// +kubebuilder:validation:Enum={"DELETE","GET","HEAD","MERGE","OPTIONS","POST","PUT"}
type CorsRuleAllowedMethods string

const (
	CorsRuleAllowedMethodsDELETE  = CorsRuleAllowedMethods("DELETE")
	CorsRuleAllowedMethodsGET     = CorsRuleAllowedMethods("GET")
	CorsRuleAllowedMethodsHEAD    = CorsRuleAllowedMethods("HEAD")
	CorsRuleAllowedMethodsMERGE   = CorsRuleAllowedMethods("MERGE")
	CorsRuleAllowedMethodsOPTIONS = CorsRuleAllowedMethods("OPTIONS")
	CorsRuleAllowedMethodsPOST    = CorsRuleAllowedMethods("POST")
	CorsRuleAllowedMethodsPUT     = CorsRuleAllowedMethods("PUT")
)

func init() {
	SchemeBuilder.Register(&StorageAccountsBlobService{}, &StorageAccountsBlobServiceList{})
}
