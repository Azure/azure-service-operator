/*
* Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
*/

package conversions

import (
	"fmt"
	"go/token"

	"github.com/dave/dst"
	"github.com/pkg/errors"

	"github.com/Azure/azure-service-operator/v2/tools/generator/internal/astbuilder"
	"github.com/Azure/azure-service-operator/v2/tools/generator/internal/astmodel"
)

// PropertyConversion generates the AST for a given property conversion.
// reader is an expression to read the original value.
// writer is a function that accepts an expression for reading a value and creates one or more
// statements to write that value.
// Both of these might be complex expressions, possibly involving indexing into arrays or maps.
type PropertyConversion func(
	reader dst.Expr,
	writer func(dst.Expr) []dst.Stmt,
	knownLocals *astmodel.KnownLocalsSet,
	generationContext *astmodel.CodeGenerationContext,
) ([]dst.Stmt, error)

// PropertyConversionFactory represents factory methods that can be used to create a PropertyConversion for a specific
// pair of properties
// source is the property conversion endpoint that will be read
// destination is the property conversion endpoint that will be written
// ctx contains additional information that may be needed when creating the property conversion
//
// The factory should return one of three result sets:
//   - For a fatal error, one that guarantees no conversion can be generated, return (nil, error)
//     This will abort the conversion process and return an error for logging.
//   - For a valid conversion, return (conversion, nil)
//   - When no conversion could be generated by this factory, return (nil, nil) to delegate to another factory
//
// Each conversion should be written with lead predicates to make sure that it only fires in the correct circumstances.
// This requires, in particular, that most conversions check for optionality and bag items and exit early when those are
// found.
// Phrased another way, conversions should not rely on the order of listing in propertyConversionFactories in order to
// generate the correct code; any conversion that relies on being "protected" from particular situations by having other
// conversions earlier in the list held by propertyConversionFactories is brittle and likely to generate the incorrect
// code if the order of items in the list is modified.
type PropertyConversionFactory func(
	source *TypedConversionEndpoint,
	destination *TypedConversionEndpoint,
	conversionContext *PropertyConversionContext) (PropertyConversion, error)

// A list of all known type conversion factory methods
var propertyConversionFactories []PropertyConversionFactory

func init() {
	propertyConversionFactories = []PropertyConversionFactory{
		// Property bag items
		pullFromBagItem,
		writeToBagItem,
		// Primitive definitions and aliases
		assignPrimitiveFromPrimitive,
		assignAliasedPrimitiveFromAliasedPrimitive,
		// Handcrafted implementations in genruntime
		assignHandcraftedImplementations,
		// Some conversions are forbidden and we just skip them
		neuterForbiddenConversions,
		// Collection Types
		assignArrayFromArray,
		assignMapFromMap,
		// Enumerations
		assignEnumFromEnum,
		assignPrimitiveFromEnum,
		// Complex object definitions
		assignObjectDirectlyFromObject,
		assignObjectDirectlyToObject,
		assignObjectsViaIntermediateObject,
		// Known definitions
		assignUserAssignedIdentityMapFromArray,
		copyKnownType(astmodel.KnownResourceReferenceType, "Copy", returnsValue),
		copyKnownType(astmodel.ResourceReferenceType, "Copy", returnsValue),
		copyKnownType(astmodel.SecretReferenceType, "Copy", returnsValue),
		copyKnownType(astmodel.SecretDestinationType, "Copy", returnsValue),
		copyKnownType(astmodel.ConfigMapReferenceType, "Copy", returnsValue),
		copyKnownType(astmodel.ConfigMapDestinationType, "Copy", returnsValue),
		copyKnownType(astmodel.ArbitraryOwnerReference, "Copy", returnsValue),
		copyKnownType(astmodel.ConditionType, "Copy", returnsValue),
		copyKnownType(astmodel.JSONType, "DeepCopy", returnsReference),
		copyKnownType(astmodel.ObjectMetaType, "DeepCopy", returnsReference),
		// Meta-conversions
		assignFromOptional,
		assignToOptional,
		assignToEnumeration,
		assignFromAliasedType,
		assignToAliasedType,
	}
}

// CreateTypeConversion tries to create a type conversion between the two provided definitions, using
// all of the available type conversion functions in priority order to do so.
//
// The method works by considering the conversion requested by sourceEndpoint & destinationEndpoint,
// with recursive calls breaking the conversion down into multiple steps that are then combined.
//
// Example:
//
// CreateTypeConversion() is called to create a conversion from an optional string to an optional
// Sku, where Sku is a new type based on string:
//
// source *string => destination *Sku
//
// assuming
//
//	type Sku string
//
// assignFromOptional can handle the optionality of sourceEndpoint and makes a recursive call
// to CreateTypeConversion() with the simpler target:
//
// source string => destination *Sku
//
//	assignToOptional can handle the optionality of destinationEndpoint and makes a recursive
//	call to CreateTypeConversion() with a simpler target:
//
//	source string => destination Sku
//
//	    assignToAliasedPrimitive can handle the type conversion of string to Sku, and makes
//	    a recursive call to CreateTypeConversion() with a simpler target:
//
//	    source string => destination string
//
//	        assignPrimitiveFromPrimitive can handle primitive values, and generates a
//	        conversion that does a simple assignment:
//
//	        destination = source
//
//	    assignToAliasedPrimitive injects the necessary type conversion:
//
//	    destination = Sku(source)
//
//	assignToOptional injects a local variable and takes it's address
//
//	sku := Sku(source)
//	destination = &sku
//
// finally, assignFromOptional injects the check to see if we have a value to assign in the
// first place, assigning a suitable zero value if we don't:
//
//	if source != nil {
//	    sku := Sku(source)
//	    destination := &sku
//	} else {
//
//	    destination := ""
//	}
func CreateTypeConversion(
	sourceEndpoint *TypedConversionEndpoint,
	destinationEndpoint *TypedConversionEndpoint,
	conversionContext *PropertyConversionContext) (PropertyConversion, error) {
	var result PropertyConversion
	var err error
	for _, f := range propertyConversionFactories {
		result, err = f(sourceEndpoint, destinationEndpoint, conversionContext)
		if err != nil {
			// Fatal error, no conversion possible
			break
		}

		if result != nil {
			// Conversion found, return it
			return result, nil
		}
	}

	// No conversion found, we need to generate a useful error message, wrapping any existing error
	msg := fmt.Sprintf("no conversion found to assign %q from %q",
		astmodel.DebugDescription(destinationEndpoint.Type()),
		astmodel.DebugDescription(sourceEndpoint.Type()))

	if err != nil {
		err = errors.Wrap(err, msg)
	} else {
		err = errors.New(msg)
	}

	return nil, err
}

// NameOfPropertyAssignmentFunction returns the name of the property assignment function
func NameOfPropertyAssignmentFunction(
	baseName string,
	parameterType astmodel.TypeName,
	direction Direction,
	idFactory astmodel.IdentifierFactory,
) string {
	nameOfOtherType := idFactory.CreateIdentifier(parameterType.Name(), astmodel.Exported)
	dir := direction.SelectString("From", "To")
	return fmt.Sprintf("%s_%s_%s", baseName, dir, nameOfOtherType)
}

// writeToBagItem will generate a conversion where the destination is in our property bag
//
// # For non-optional sources, the value is directly added
//
// <propertyBag>.Add(<propertyName>, <source>)
//
// For optional sources, the value is only added if non-nil; if nil, we remove any existing item
//
//	if <source> != nil {
//	    <propertyBag>.Add(<propertyName>, *<source>)
//	} else {
//
//	   <propertyBag>.Remove(<propertyName>)
//	}
//
// For slice and slice sources, the value is only added if it is non-empty; if empty we remove any existing item
//
//	if len(<source>) > 0 {
//		   <propertyBag>.Add(<propertyName>, <source>)
//	} else {
//
//		   <propertyBag>.Remove(<propertyName>)
//	}
func writeToBagItem(
	sourceEndpoint *TypedConversionEndpoint,
	destinationEndpoint *TypedConversionEndpoint,
	conversionContext *PropertyConversionContext) (PropertyConversion, error) {

	// Require destination to be a property bag item
	destinationBagItem, destinationIsBagItem := AsPropertyBagMemberType(destinationEndpoint.Type())
	if !destinationIsBagItem {
		// Destination is not optional
		return nil, nil
	}

	// Work out our source type, and whether it's optional
	actualSourceType := sourceEndpoint.Type()
	sourceOptional, sourceIsOptional := astmodel.AsOptionalType(actualSourceType)
	if sourceIsOptional {
		actualSourceType = sourceOptional.BaseType()
	}

	// Require the item in the bag to be exactly the same type as our source
	// (We don't want to recursively do all the conversions because our property bag item SHOULD always contain
	// exactly the expected type, so no conversion should be required. Plus, our conversions are designed to isolate
	// the source and destination from each other (so that changes to one don't impact the other), but with the
	// property bag everything gets immediately serialized so everything is already nicely isolated.
	if !astmodel.TypeEquals(destinationBagItem.Element(), actualSourceType) {
		return nil, nil
	}

	_, sourceIsMap := astmodel.AsMapType(actualSourceType)
	_, sourceIsSlice := astmodel.AsArrayType(actualSourceType)

	return func(
		reader dst.Expr,
		_ func(dst.Expr) []dst.Stmt,
		knownLocals *astmodel.KnownLocalsSet,
		generationContext *astmodel.CodeGenerationContext,
	) ([]dst.Stmt, error) {
		createAddToBag := func(expr dst.Expr) dst.Stmt {
			addToBag := astbuilder.CallQualifiedFuncAsStmt(
				conversionContext.PropertyBagName(),
				"Add",
				astbuilder.StringLiteralf(destinationEndpoint.Name()),
				expr)

			return addToBag
		}

		removeFromBag := astbuilder.CallQualifiedFuncAsStmt(
			conversionContext.PropertyBagName(),
			"Remove",
			astbuilder.StringLiteralf(destinationEndpoint.Name()))

		// If pointer to value, check for nil and only store if we have a value
		if sourceIsOptional {
			writer := astbuilder.SimpleIfElse(
				astbuilder.NotNil(reader),
				astbuilder.Statements(createAddToBag(astbuilder.Dereference(reader))),
				astbuilder.Statements(removeFromBag))
			return astbuilder.Statements(writer), nil
		}

		// If slice or map, check for non-empty and only store if we have a value
		if sourceIsSlice || sourceIsMap {
			writer := astbuilder.SimpleIfElse(
				astbuilder.NotEmpty(reader),
				astbuilder.Statements(createAddToBag(reader)),
				astbuilder.Statements(removeFromBag))
			return astbuilder.Statements(writer), nil
		}

		// Otherwise, just store the value
		writer := createAddToBag(reader)
		return astbuilder.Statements(writer), nil
	}, nil
}

// assignToOptional will generate a conversion where the destination is optional, if the
// underlying type of the destination is compatible with the source.
//
// <destination> = &<source>
func assignToOptional(
	sourceEndpoint *TypedConversionEndpoint,
	destinationEndpoint *TypedConversionEndpoint,
	conversionContext *PropertyConversionContext) (PropertyConversion, error) {

	// Require destination to not be a bag item
	if destinationEndpoint.IsBagItem() {
		return nil, nil
	}

	// Require destination to be optional
	destinationOptional, destinationIsOptional := astmodel.AsOptionalType(destinationEndpoint.Type())
	if !destinationIsOptional {
		// Destination is not optional
		return nil, nil
	}

	// Require source to be non-optional
	// (to ensure that assignFromOptional triggers first when handling option to optional conversion)
	if sourceEndpoint.IsOptional() {
		return nil, nil
	}

	// Require a conversion between the unwrapped type and our source
	unwrappedEndpoint := destinationEndpoint.WithType(destinationOptional.Element())
	conversion, err := CreateTypeConversion(sourceEndpoint, unwrappedEndpoint, conversionContext)
	if err != nil {
		return nil, err
	}
	if conversion == nil {
		return nil, nil
	}

	return func(
		reader dst.Expr,
		writer func(dst.Expr) []dst.Stmt,
		knownLocals *astmodel.KnownLocalsSet,
		generationContext *astmodel.CodeGenerationContext,
	) ([]dst.Stmt, error) {
		// Create a writer that uses the address of the passed expression
		// If expr isn't a plain identifier (implying a local variable), we introduce one
		// This both allows us to avoid aliasing and complies with Go language semantics
		addrOfWriter := func(expr dst.Expr) []dst.Stmt {
			if _, ok := expr.(*dst.Ident); ok {
				return writer(astbuilder.AddrOf(expr))
			}

			// Only obtain our local variable name after we know we need it
			// (this avoids reserving the name and not using it, which can interact with other conversions)
			local := knownLocals.CreateSingularLocal(destinationEndpoint.Name(), "", "Temp")

			assignment := astbuilder.ShortDeclaration(local, expr)

			writing := writer(astbuilder.AddrOf(dst.NewIdent(local)))

			return astbuilder.Statements(assignment, writing)
		}

		return conversion(reader, addrOfWriter, knownLocals, generationContext)
	}, nil
}

// pullFromBagItem will populate a property from a property bag
//
//	if <propertyBag>.Contains(<sourceName>) {
//	    var <value> <destinationType>
//	    err := <propertyBag>.Pull(<sourceName>, &<value>)
//	    if err != nil {
//	        return errors.Wrapf(err, ...)
//	    }
//
//	    <destination> = <value>
//	} else {
//
//	    <destination> = <zero>
//	}
func pullFromBagItem(
	sourceEndpoint *TypedConversionEndpoint,
	destinationEndpoint *TypedConversionEndpoint,
	conversionContext *PropertyConversionContext) (PropertyConversion, error) {

	// Require source to be a bag item
	sourceBagItem, sourceIsBagItem := AsPropertyBagMemberType(sourceEndpoint.Type())
	if !sourceIsBagItem {
		return nil, nil
	}

	// Work out our destination type, and whether it's optional
	actualDestinationType := destinationEndpoint.Type()
	destinationOptional, destinationIsOptional := astmodel.AsOptionalType(actualDestinationType)
	if destinationIsOptional {
		actualDestinationType = destinationOptional.BaseType()
	}

	// Require the item in the bag to be exactly the same type as our destination
	// (We don't want to recursively do all the conversions because our property bag item SHOULD always contain
	// exactly the expected type, so no conversion should be required. Plus, our conversions are designed to isolate
	// the source and destination from each other (so that changes to one don't impact the other), but with the
	// property bag everything gets immediately serialized so everything is already nicely isolated.
	if !astmodel.TypeEquals(sourceBagItem.Element(), actualDestinationType) {
		return nil, nil
	}

	errIdent := dst.NewIdent("err")

	return func(
		_ dst.Expr,
		writer func(dst.Expr) []dst.Stmt,
		knownLocals *astmodel.KnownLocalsSet,
		generationContext *astmodel.CodeGenerationContext,
	) ([]dst.Stmt, error) {
		// our first parameter is an expression to read the value from our original instance, but in this case we're
		// going to read from the property bag, so we're ignoring it.

		local := knownLocals.CreateSingularLocal(sourceEndpoint.Name(), "", "Read")
		errorsPkg := generationContext.MustGetImportedPackageName(astmodel.GitHubErrorsReference)

		condition := astbuilder.CallQualifiedFunc(
			conversionContext.PropertyBagName(),
			"Contains",
			astbuilder.StringLiteral(sourceEndpoint.Name()))

		declare := astbuilder.NewVariableWithType(
			local,
			sourceBagItem.AsType(generationContext))

		pull := astbuilder.ShortDeclaration(
			"err",
			astbuilder.CallQualifiedFunc(
				conversionContext.PropertyBagName(),
				"Pull",
				astbuilder.StringLiteral(sourceEndpoint.Name()),
				astbuilder.AddrOf(dst.NewIdent(local))))

		returnIfErr := astbuilder.ReturnIfNotNil(
			errIdent,
			astbuilder.WrappedErrorf(
				errorsPkg,
				"pulling '%s' from propertyBag",
				sourceEndpoint.Name()))
		returnIfErr.Decorations().After = dst.EmptyLine

		var reader dst.Expr
		if destinationIsOptional {
			reader = astbuilder.AddrOf(dst.NewIdent(local))
		} else {
			reader = dst.NewIdent(local)
		}

		assignValue := writer(reader)

		assignZero := writer(destinationEndpoint.Type().AsZero(conversionContext.Types(), generationContext))

		ifStatement := astbuilder.SimpleIfElse(
			condition,
			astbuilder.Statements(declare, pull, returnIfErr, assignValue),
			assignZero)

		return astbuilder.Statements(ifStatement), nil
	}, nil
}

// assignFromOptional will handle the case where the source type may be missing (nil)
//
// <original> := <source>
//
//	if <original> != nil {
//	   <destination> = *<original>
//	} else {
//
//	   <destination> = <zero>
//	}
//
// Must trigger before assignToOptional so we generate the right zero values; to enforce this, assignToOptional includes
// a predicate check that the source is NOT optional, allowing this conversion to trigger first.
func assignFromOptional(
	sourceEndpoint *TypedConversionEndpoint,
	destinationEndpoint *TypedConversionEndpoint,
	conversionContext *PropertyConversionContext) (PropertyConversion, error) {

	// Require source to not be a bag item
	if sourceEndpoint.IsBagItem() {
		return nil, nil
	}

	// Require source to be optional
	sourceOptional, sourceIsOptional := astmodel.AsOptionalType(sourceEndpoint.Type())
	if !sourceIsOptional {
		return nil, nil
	}

	// Require a conversion between the unwrapped type and our source
	unwrappedEndpoint := sourceEndpoint.WithType(sourceOptional.Element())
	conversion, err := CreateTypeConversion(
		unwrappedEndpoint,
		destinationEndpoint,
		conversionContext)
	if err != nil {
		return nil, err
	}
	if conversion == nil {
		return nil, nil
	}

	return func(
		reader dst.Expr,
		writer func(dst.Expr) []dst.Stmt,
		knownLocals *astmodel.KnownLocalsSet,
		generationContext *astmodel.CodeGenerationContext,
	) ([]dst.Stmt, error) {
		var cacheOriginal dst.Stmt
		var actualReader dst.Expr

		// If the value we're reading is a local or a field, it's cheap to read and we can skip
		// using a local (which makes the generated code easier to read). In other cases, we want
		// to cache the value in a local to avoid repeating any expensive conversion.

		switch reader.(type) {
		case *dst.Ident, *dst.SelectorExpr:
			// reading a local variable or a field
			cacheOriginal = nil
			actualReader = reader
		default:
			// Something else, so we cache the original
			local := knownLocals.CreateSingularLocal(sourceEndpoint.Name(), "", "AsRead")
			cacheOriginal = astbuilder.ShortDeclaration(local, reader)
			actualReader = dst.NewIdent(local)
		}

		checkForNil := astbuilder.AreNotEqual(actualReader, astbuilder.Nil())

		// If we have a value, need to convert it to our destination type
		// We use a cloned knownLocals as the write is within our if statement and we don't want locals to leak
		writeActualValue := conversion(
			astbuilder.Dereference(actualReader),
			writer,
			knownLocals.Clone(),
			generationContext)

		writeZeroValue := writer(
			destinationEndpoint.Type().AsZero(conversionContext.Types(), generationContext))

		stmt := astbuilder.SimpleIfElse(
			checkForNil,
			writeActualValue,
			writeZeroValue)

		return astbuilder.Statements(cacheOriginal, stmt), nil
	}, nil
}

// assignToEnumeration will generate a conversion where the destination is an enumeration if
// the source is type compatible with the base type of the enumeration
//
// <destination> = <enumeration-cast>(<source>)
func assignToEnumeration(
	sourceEndpoint *TypedConversionEndpoint,
	destinationEndpoint *TypedConversionEndpoint,
	conversionContext *PropertyConversionContext) (PropertyConversion, error) {

	// Require destination to not be a bag item
	if destinationEndpoint.IsBagItem() {
		return nil, nil
	}

	// Require destination to be non-optional
	if destinationEndpoint.IsOptional() {
		return nil, nil
	}

	// Require destination to be an enumeration
	dstName, dstType, ok := conversionContext.ResolveType(destinationEndpoint.Type())
	if !ok {
		return nil, nil
	}
	dstEnum, ok := astmodel.AsEnumType(dstType)
	if !ok {
		return nil, nil
	}

	// Require a conversion between the base type of the enumeration and our source
	dstEp := destinationEndpoint.WithType(dstEnum.BaseType())
	conversion, err := CreateTypeConversion(sourceEndpoint, dstEp, conversionContext)
	if err != nil {
		return nil, err
	}
	if conversion == nil {
		return nil, nil
	}

	return func(
		reader dst.Expr,
		writer func(dst.Expr) []dst.Stmt,
		knownLocals *astmodel.KnownLocalsSet,
		generationContext *astmodel.CodeGenerationContext,
	) ([]dst.Stmt, error) {
		convertingWriter := func(expr dst.Expr) []dst.Stmt {
			cast := &dst.CallExpr{
				Fun:  dstName.AsType(generationContext),
				Args: []dst.Expr{expr},
			}
			return writer(cast)
		}

		return conversion(
			reader,
			convertingWriter,
			knownLocals,
			generationContext)
	}, nil
}

// assignPrimitiveFromPrimitive will generate a direct assignment if both definitions have the
// same primitive type and are not optional
//
// <destination> = <source>
func assignPrimitiveFromPrimitive(
	sourceEndpoint *TypedConversionEndpoint,
	destinationEndpoint *TypedConversionEndpoint,
	_ *PropertyConversionContext) (PropertyConversion, error) {

	// Require both source and destination to not be bag items
	if sourceEndpoint.IsBagItem() || destinationEndpoint.IsBagItem() {
		return nil, nil
	}

	// Require both source and destination to be non-optional
	if sourceEndpoint.IsOptional() || destinationEndpoint.IsOptional() {
		return nil, nil
	}

	// Require source to be a primitive type
	sourcePrimitive, sourceIsPrimitive := astmodel.AsPrimitiveType(sourceEndpoint.Type())
	if !sourceIsPrimitive {
		return nil, nil
	}

	// Require destination to be a primitive type
	destinationPrimitive, destinationIsPrimitive := astmodel.AsPrimitiveType(destinationEndpoint.Type())
	if !destinationIsPrimitive {
		return nil, nil
	}

	// Require both properties to have the same primitive type
	if !astmodel.TypeEquals(sourcePrimitive, destinationPrimitive) {
		return nil, nil
	}

	return func(
		reader dst.Expr,
		writer func(dst.Expr) []dst.Stmt,
		knownLocals *astmodel.KnownLocalsSet,
		generationContext *astmodel.CodeGenerationContext,
	) ([]dst.Stmt, error) {
		return writer(reader), nil
	}, nil
}

// assignAliasedPrimitiveFromAliasedPrimitive will generate a direct assignment if both
// definitions have the same underlying primitive type and are not optional
//
// <destination> = <cast>(<source>)
func assignAliasedPrimitiveFromAliasedPrimitive(
	sourceEndpoint *TypedConversionEndpoint,
	destinationEndpoint *TypedConversionEndpoint,
	conversionContext *PropertyConversionContext) (PropertyConversion, error) {

	// Require both source and destination to not be bag items
	if sourceEndpoint.IsBagItem() || destinationEndpoint.IsBagItem() {
		return nil, nil
	}

	// Require both source and destination to be non-optional
	if sourceEndpoint.IsOptional() || destinationEndpoint.IsOptional() {
		return nil, nil
	}

	// Require source to be a name that resolves to a primitive type
	_, sourceType, ok := conversionContext.ResolveType(sourceEndpoint.Type())
	if !ok {
		return nil, nil
	}
	sourcePrimitive, sourceIsPrimitive := astmodel.AsPrimitiveType(sourceType)
	if !sourceIsPrimitive {
		return nil, nil
	}

	// Require destination to be a name the resolves to a primitive type
	destinationName, destinationType, ok := conversionContext.ResolveType(destinationEndpoint.Type())
	if !ok {
		return nil, nil
	}
	destinationPrimitive, destinationIsPrimitive := astmodel.AsPrimitiveType(destinationType)
	if !destinationIsPrimitive {
		return nil, nil
	}

	// Require both properties to have the same primitive type
	if !astmodel.TypeEquals(sourcePrimitive, destinationPrimitive) {
		return nil, nil
	}

	return func(
		reader dst.Expr,
		writer func(dst.Expr) []dst.Stmt,
		knownLocals *astmodel.KnownLocalsSet,
		generationContext *astmodel.CodeGenerationContext,
	) ([]dst.Stmt, error) {
		return writer(&dst.CallExpr{
			Fun:  destinationName.AsType(generationContext),
			Args: []dst.Expr{reader},
		}), nil
	}, nil
}

// assignFromAliasedType will convert an alias of a type into that type
// type as long as it is not optional and is not an alias to an object type.
func assignFromAliasedType(
	sourceEndpoint *TypedConversionEndpoint,
	destinationEndpoint *TypedConversionEndpoint,
	conversionContext *PropertyConversionContext) (PropertyConversion, error) {

	// Require source to not be a bag item
	if sourceEndpoint.IsBagItem() {
		return nil, nil
	}

	// Require source to be non-optional
	if sourceEndpoint.IsOptional() {
		return nil, nil
	}

	// Require source to be a name that resolves to a non-object type
	_, sourceType, ok := conversionContext.ResolveType(sourceEndpoint.Type())
	if !ok {
		return nil, nil
	}
	if _, ok = astmodel.AsObjectType(sourceType); ok {
		// Don't match objects, only other aliases - no objects aliases exist because they are removed by
		// the RemoveTypeAliases pipeline stage, so if ResolveType results in an object then we have a normal
		// TypeName -> Object, which is not an alias at all.
		return nil, nil
	}

	// Require a conversion for the underlying type
	sourceType = astmodel.Unwrap(sourceType) // Unwrap to avoid any validations
	updatedSourceEndpoint := sourceEndpoint.WithType(sourceType)
	conversion, err := CreateTypeConversion(updatedSourceEndpoint, destinationEndpoint, conversionContext)
	if err != nil {
		return nil, err
	}
	if conversion == nil {
		return nil, nil
	}

	return func(
		reader dst.Expr,
		writer func(dst.Expr) []dst.Stmt,
		knownLocals *astmodel.KnownLocalsSet,
		generationContext *astmodel.CodeGenerationContext,
	) ([]dst.Stmt, error) {
		actualReader := &dst.CallExpr{
			Fun:  sourceType.AsType(generationContext),
			Args: []dst.Expr{reader},
		}

		return conversion(actualReader, writer, knownLocals, generationContext)
	}, nil
}

// assignToAliasedType will convert a value into the aliased type as long as it
// is not optional and the alias is not to an object type.
//
// <destination> = <cast>(<source>)
func assignToAliasedType(
	sourceEndpoint *TypedConversionEndpoint,
	destinationEndpoint *TypedConversionEndpoint,
	conversionContext *PropertyConversionContext) (PropertyConversion, error) {

	// Require destination to not be a bag item
	if destinationEndpoint.IsBagItem() {
		return nil, nil
	}

	// Require destination to be non-optional
	if destinationEndpoint.IsOptional() {
		return nil, nil
	}

	// Require destination to be a name the resolves to a non-object type
	destinationName, destinationType, ok := conversionContext.ResolveType(destinationEndpoint.Type())
	if !ok {
		return nil, nil
	}
	if _, ok = astmodel.AsObjectType(destinationType); ok {
		// Don't match objects, only other aliases - no objects aliases exist because they are removed by
		// the RemoveTypeAliases pipeline stage, so if ResolveType results in an object then we have a normal
		// TypeName -> Object, which is not an alias at all.
		return nil, nil
	}

	// Require a conversion for the underlying type
	destinationType = astmodel.Unwrap(destinationType) // Unwrap to avoid any validations
	updatedDestinationEndpoint := destinationEndpoint.WithType(destinationType)
	conversion, err := CreateTypeConversion(sourceEndpoint, updatedDestinationEndpoint, conversionContext)
	if err != nil {
		return nil, err
	}
	if conversion == nil {
		return nil, nil
	}

	return func(
		reader dst.Expr,
		writer func(dst.Expr) []dst.Stmt,
		knownLocals *astmodel.KnownLocalsSet,
		generationContext *astmodel.CodeGenerationContext,
	) ([]dst.Stmt, error) {
		actualWriter := func(expr dst.Expr) []dst.Stmt {
			castToAlias := &dst.CallExpr{
				Fun:  destinationName.AsType(generationContext),
				Args: []dst.Expr{expr},
			}

			return writer(castToAlias)
		}

		return conversion(reader, actualWriter, knownLocals, generationContext)
	}, nil
}

// handCraftedConversion represents a hand-coded conversion
// this can be used to share code for common conversions (e.g. []string â†’ []string)
type handCraftedConversion struct {
	fromType astmodel.Type
	toType   astmodel.Type

	implPackage astmodel.PackageReference
	implFunc    string
}

var handCraftedConversions = []handCraftedConversion{
	{
		fromType:    astmodel.NewMapType(astmodel.StringType, astmodel.StringType),
		toType:      astmodel.NewMapType(astmodel.StringType, astmodel.StringType),
		implPackage: astmodel.GenRuntimeReference,
		implFunc:    "CloneMapOfStringToString",
	},
	{
		fromType:    astmodel.NewArrayType(astmodel.StringType),
		toType:      astmodel.NewArrayType(astmodel.StringType),
		implPackage: astmodel.GenRuntimeReference,
		implFunc:    "CloneSliceOfString",
	},
	{
		fromType:    astmodel.NewArrayType(astmodel.ConditionType),
		toType:      astmodel.NewArrayType(astmodel.ConditionType),
		implPackage: astmodel.GenRuntimeReference,
		implFunc:    "CloneSliceOfCondition",
	},
	{
		fromType:    astmodel.OptionalIntType,
		toType:      astmodel.OptionalIntType,
		implPackage: astmodel.GenRuntimeReference,
		implFunc:    "ClonePointerToInt",
	},
	{
		fromType:    astmodel.OptionalStringType,
		toType:      astmodel.OptionalStringType,
		implPackage: astmodel.GenRuntimeReference,
		implFunc:    "ClonePointerToString",
	},
	{
		fromType:    astmodel.OptionalStringType,
		toType:      astmodel.StringType,
		implPackage: astmodel.GenRuntimeReference,
		implFunc:    "GetOptionalStringValue",
	},
	{
		fromType:    astmodel.OptionalIntType,
		toType:      astmodel.IntType,
		implPackage: astmodel.GenRuntimeReference,
		implFunc:    "GetOptionalIntValue",
	},
	{
		fromType:    astmodel.StringType,
		toType:      astmodel.ResourceReferenceType,
		implPackage: astmodel.GenRuntimeReference,
		implFunc:    "CreateResourceReferenceFromARMID",
	},
	{
		fromType:    astmodel.FloatType,
		toType:      astmodel.IntType,
		implPackage: astmodel.GenRuntimeReference,
		implFunc:    "GetIntFromFloat",
	},
}

func assignHandcraftedImplementations(
	sourceEndpoint *TypedConversionEndpoint,
	destinationEndpoint *TypedConversionEndpoint,
	_ *PropertyConversionContext) (PropertyConversion, error) {

	// Require both source and destination to not be bag items
	if sourceEndpoint.IsBagItem() || destinationEndpoint.IsBagItem() {
		return nil, nil
	}

	for _, impl := range handCraftedConversions {
		if astmodel.TypeEquals(sourceEndpoint.Type(), impl.fromType) &&
			astmodel.TypeEquals(destinationEndpoint.Type(), impl.toType) {
				pkg := cgc.MustGetImportedPackageName(impl.implPackage)
			return func(
				reader dst.Expr,
				writer func(dst.Expr) []dst.Stmt,
				knownLocals *astmodel.KnownLocalsSet,
				generationContext *astmodel.CodeGenerationContext,
			) ([]dst.Stmt, error) {
				return writer(astbuilder.CallQualifiedFunc(pkg, impl.implFunc, reader)), nil
			}, nil
		}
	}

	return nil, nil
}

// forbiddenConversion represents a conversion that we know we shouldn't even attempt to do
// Encountering one isn't a fatal error, but it does mean we can't generate a conversion
type forbiddenConversion struct {
	fromType astmodel.Type
	toType   astmodel.Type
}

var forbiddenConversions = []forbiddenConversion{
	{
		// Can't use a string (the value of a secret) to initialize a secret reference (pointing to the value source)
		// We encounter this when initializing the spec of a resource from its status
		fromType: astmodel.StringType,
		toType:   astmodel.SecretReferenceType,
	},
}

// neuterForbiddenConversions is a conversion factory that will return a conversion that does nothing if we encounter a
// forbidden conversion
func neuterForbiddenConversions(
	sourceEndpoint *TypedConversionEndpoint,
	destinationEndpoint *TypedConversionEndpoint,
	_ *PropertyConversionContext) (PropertyConversion, error) {

	// Require both source and destination to not be bag items
	if sourceEndpoint.IsBagItem() || destinationEndpoint.IsBagItem() {
		return nil, nil
	}

	for _, forbidden := range forbiddenConversions {
		if astmodel.TypeEquals(sourceEndpoint.Type(), forbidden.fromType) &&
			astmodel.TypeEquals(destinationEndpoint.Type(), forbidden.toType) {
			return func(
				reader dst.Expr,
				writer func(dst.Expr) []dst.Stmt,
				knownLocals *astmodel.KnownLocalsSet,
				generationContext *astmodel.CodeGenerationContext,
			) ([]dst.Stmt, error) {
				return nil, nil
			}, nil
		}
	}

	return nil, nil
}

// assignArrayFromArray will generate a code fragment to populate an array, assuming the
// underlying definitions of the two arrays are compatible
//
// <arr> := make([]<type>, len(<reader>))
//
//	for <index>, <value> := range <reader> {
//	    // Shadow the loop variable to avoid aliasing
//	    <value> := <value>
//	    <arr>[<index>] := <value> // Or other conversion as required
//	}
//
// <writer> = <arr>
func assignArrayFromArray(
	sourceEndpoint *TypedConversionEndpoint,
	destinationEndpoint *TypedConversionEndpoint,
	conversionContext *PropertyConversionContext) (PropertyConversion, error) {

	// Require both source and destination to not be bag items
	if sourceEndpoint.IsBagItem() || destinationEndpoint.IsBagItem() {
		return nil, nil
	}

	// Require source to be an array type
	sourceArray, sourceIsArray := astmodel.AsArrayType(sourceEndpoint.Type())
	if !sourceIsArray {
		return nil, nil
	}

	// Require destination to be an array type
	destinationArray, destinationIsArray := astmodel.AsArrayType(destinationEndpoint.Type())
	if !destinationIsArray {
		return nil, nil
	}

	// Require a conversion between the array definitions
	unwrappedSourceEndpoint := sourceEndpoint.WithType(sourceArray.Element())
	unwrappedDestinationEndpoint := destinationEndpoint.WithType(destinationArray.Element())
	conversion, err := CreateTypeConversion(
		unwrappedSourceEndpoint,
		unwrappedDestinationEndpoint,
		conversionContext)
	if err != nil {
		return nil, errors.Wrapf(
			err,
			"finding array conversion from %s to %s",
			astmodel.DebugDescription(sourceEndpoint.Type()),
			astmodel.DebugDescription(destinationEndpoint.Type()))
	}
	if conversion == nil {
		return nil, nil
	}

	return func(
		reader dst.Expr,
		writer func(dst.Expr) []dst.Stmt,
		knownLocals *astmodel.KnownLocalsSet,
		generationContext *astmodel.CodeGenerationContext,
	) ([]dst.Stmt, error) {
		var cacheOriginal dst.Stmt
		var actualReader dst.Expr

		// If the value we're reading is a local or a field, it's cheap to read and we can skip
		// using a local (which makes the generated code easier to read). In other cases, we want
		// to cache the value in a local to avoid repeating any expensive conversion.

		switch reader.(type) {
		case *dst.Ident, *dst.SelectorExpr:
			// reading a local variable or a field
			cacheOriginal = nil
			actualReader = reader
		default:
			// Something else, so we cache the original
			local := knownLocals.CreateSingularLocal(sourceEndpoint.Name(), "", "Cache")
			cacheOriginal = astbuilder.ShortDeclaration(local, reader)
			actualReader = dst.NewIdent(local)
		}

		checkForNil := astbuilder.AreNotEqual(actualReader, astbuilder.Nil())

		// We create three obviously related identifiers to use for the array conversion
		// The List is created in the current knownLocals scope because we need it after the loop completes.
		// The other two are created in a nested knownLocals scope because they're only needed within the loop; this
		// ensures any other locals needed for the conversion don't leak out into our main scope.
		// These suffixes must not overlap with those used for map conversion. (If these suffixes overlap, the naming
		// becomes difficult to read when converting maps containing slices or vice versa.)
		branchLocals := knownLocals.Clone()
		tempId := branchLocals.CreateSingularLocal(sourceEndpoint.Name(), "List")
		loopLocals := branchLocals.Clone() // Clone after tempId is created so that it's visible within the loop
		itemId := loopLocals.CreateSingularLocal(sourceEndpoint.Name(), "Item")
		indexId := loopLocals.CreateSingularLocal(sourceEndpoint.Name(), "Index")

		declaration := astbuilder.ShortDeclaration(
			tempId,
			astbuilder.MakeSlice(destinationArray.AsType(generationContext), astbuilder.CallFunc("len", actualReader)))

		writeToElement := func(expr dst.Expr) []dst.Stmt {
			return []dst.Stmt{
				astbuilder.SimpleAssignment(
					&dst.IndexExpr{
						X:     dst.NewIdent(tempId),
						Index: dst.NewIdent(indexId),
					},
					expr),
			}
		}

		avoidAliasing := astbuilder.ShortDeclaration(itemId, dst.NewIdent(itemId))
		avoidAliasing.Decs.Start.Append("// Shadow the loop variable to avoid aliasing")
		avoidAliasing.Decs.Before = dst.NewLine

		loopBody := astbuilder.Statements(
			avoidAliasing,
			conversion(dst.NewIdent(itemId), writeToElement, loopLocals, generationContext))

		assignValue := writer(dst.NewIdent(tempId))
		loop := astbuilder.IterateOverSliceWithIndex(indexId, itemId, reader, loopBody...)
		trueBranch := astbuilder.Statements(declaration, loop, assignValue)

		assignZero := writer(astbuilder.Nil())

		return astbuilder.Statements(
			cacheOriginal,
			astbuilder.SimpleIfElse(checkForNil, trueBranch, assignZero)), nil
	}, nil
}

// assignMapFromMap will generate a code fragment to populate an array, assuming the
// underlying definitions of the two arrays are compatible
//
//	if <reader> != nil {
//	    <map> := make(map[<key>]<type>)
//	    for key, <item> := range <reader> {
//	        <map>[<key>] := <item>
//	    }
//	    <writer> = <map>
//	} else {
//
//	    <writer> = <zero>
//	}
func assignMapFromMap(
	sourceEndpoint *TypedConversionEndpoint,
	destinationEndpoint *TypedConversionEndpoint,
	conversionContext *PropertyConversionContext) (PropertyConversion, error) {

	// Require both source and destination to not be bag items
	if sourceEndpoint.IsBagItem() || destinationEndpoint.IsBagItem() {
		return nil, nil
	}

	// Require source to be a map
	sourceMap, sourceIsMap := astmodel.AsMapType(sourceEndpoint.Type())
	if !sourceIsMap {
		// Source is not a map
		return nil, nil
	}

	// Require destination to be a map
	destinationMap, destinationIsMap := astmodel.AsMapType(destinationEndpoint.Type())
	if !destinationIsMap {
		// Destination is not a map
		return nil, nil
	}

	// Require map keys to be identical
	if !astmodel.TypeEquals(sourceMap.KeyType(), destinationMap.KeyType()) {
		// Keys are different definitions
		return nil, nil
	}

	// Require a conversion between the map items
	unwrappedSourceEndpoint := sourceEndpoint.WithType(sourceMap.ValueType())
	unwrappedDestinationEndpoint := destinationEndpoint.WithType(destinationMap.ValueType())
	conversion, err := CreateTypeConversion(
		unwrappedSourceEndpoint,
		unwrappedDestinationEndpoint,
		conversionContext)
	if err != nil {
		return nil, errors.Wrapf(
			err,
			"finding map conversion from %s to %s",
			astmodel.DebugDescription(sourceEndpoint.Type()),
			astmodel.DebugDescription(destinationEndpoint.Type()))
	}
	if conversion == nil {
		return nil, nil
	}

	return func(
		reader dst.Expr,
		writer func(dst.Expr) []dst.Stmt,
		knownLocals *astmodel.KnownLocalsSet,
		generationContext *astmodel.CodeGenerationContext,
	) ([]dst.Stmt, error) {
		var cacheOriginal dst.Stmt
		var actualReader dst.Expr

		// If the value we're reading is a local or a field, it's cheap to read and we can skip
		// using a local (which makes the generated code easier to read). In other cases, we want
		// to cache the value in a local to avoid repeating any expensive conversion.

		switch reader.(type) {
		case *dst.Ident, *dst.SelectorExpr:
			// reading a local variable or a field
			cacheOriginal = nil
			actualReader = reader
		default:
			// Something else, so we cache the original
			local := knownLocals.CreateSingularLocal(sourceEndpoint.Name(), "", "Cache")
			cacheOriginal = astbuilder.ShortDeclaration(local, reader)
			actualReader = dst.NewIdent(local)
		}

		checkForNil := astbuilder.AreNotEqual(actualReader, astbuilder.Nil())

		// We create three obviously related identifiers to use for the conversion.
		// These are all within the scope of the true branch of our if statement
		// The Map is created in the current knownLocals scope because we need it after the loop completes.
		// The other two are created in a nested knownLocals scope because they're only needed within the loop; this
		// ensures any other locals needed for the conversion don't leak out into our main scope.
		// These suffixes must not overlap with those used for array conversion. (If these suffixes overlap, the naming
		// becomes difficult to read when converting maps containing slices or vice versa.)
		branchLocals := knownLocals.Clone()
		tempId := branchLocals.CreateSingularLocal(sourceEndpoint.Name(), "Map")
		loopLocals := branchLocals.Clone() // Clone after tempId is created so that it's visible within the loop
		itemId := loopLocals.CreateSingularLocal(sourceEndpoint.Name(), "Value")
		keyId := loopLocals.CreateSingularLocal(sourceEndpoint.Name(), "Key")

		declaration := astbuilder.ShortDeclaration(
			tempId,
			astbuilder.MakeMapWithCapacity(
				destinationMap.KeyType().AsType(generationContext),
				destinationMap.ValueType().AsType(generationContext),
				astbuilder.CallFunc("len", actualReader)))

		assignToItem := func(expr dst.Expr) []dst.Stmt {
			return []dst.Stmt{
				astbuilder.SimpleAssignment(
					&dst.IndexExpr{
						X:     dst.NewIdent(tempId),
						Index: dst.NewIdent(keyId),
					},
					expr),
			}
		}

		avoidAliasing := astbuilder.ShortDeclaration(itemId, dst.NewIdent(itemId))
		avoidAliasing.Decs.Start.Append("// Shadow the loop variable to avoid aliasing")
		avoidAliasing.Decs.Before = dst.NewLine

		loopBody := astbuilder.Statements(
			avoidAliasing,
			conversion(dst.NewIdent(itemId), assignToItem, loopLocals, generationContext))

		loop := astbuilder.IterateOverMapWithValue(keyId, itemId, actualReader, loopBody...)
		assignMap := writer(dst.NewIdent(tempId))
		trueBranch := astbuilder.Statements(declaration, loop, assignMap)

		assignNil := writer(astbuilder.Nil())

		return astbuilder.Statements(
			cacheOriginal,
			astbuilder.SimpleIfElse(checkForNil, trueBranch, assignNil)), nil
	}, nil
}

// assignUserAssignedIdentityMapFromArray will generate a code fragment to populate a userAssignedIdentity array from
// a map whose key is the ARM ID of the userAssignedIdentity
//
//	if source.UserAssignedIdentities != nil {
//	    <arr> := make([]<arrType>, 0, len(source.UserAssignedIdentities))
//	    for key, _ := range source.UserAssignedIdentities {
//	        ref := genruntime.CreateResourceReferenceFromARMID(key)
//	        <arr> = append(<arr>, UserAssignedIdentityDetails{Reference: ref})
//	    }
//	    <writer> = <arr>
//	} else {
//	   <writer> = nil
//	}
func assignUserAssignedIdentityMapFromArray(
	sourceEndpoint *TypedConversionEndpoint,
	destinationEndpoint *TypedConversionEndpoint,
	conversionContext *PropertyConversionContext) (PropertyConversion, error) {

	// There's no conversion in the other direction (array -> map) for this because property_conversions only deals with:
	// 1. Conversions between storage types, where UserAssignedIdentity's are arrays on both sides and don't need
	//    special handling.
	// 2. Conversions from Status -> Spec, which is the direction that this conversion method deals with.

	// Require both source and destination to not be bag items
	if sourceEndpoint.IsBagItem() || destinationEndpoint.IsBagItem() {
		return nil, nil
	}

	// Require source to be a map type
	sourceMapType, sourceIsMap := astmodel.AsMapType(sourceEndpoint.Type())
	if !sourceIsMap {
		return nil, nil
	}

	// Require destination to be an array type
	destinationArray, destinationIsArray := astmodel.AsArrayType(destinationEndpoint.Type())
	if !destinationIsArray {
		return nil, nil
	}

	// Require the source endpoint to have the expected property name
	if sourceEndpoint.Name() != astmodel.UserAssignedIdentitiesProperty {
		return nil, nil
	}

	// Require the destination endpoint to have the expected property name
	if destinationEndpoint.Name() != astmodel.UserAssignedIdentitiesProperty {
		return nil, nil
	}

	// The destination should be a typeName
	destinationElement := destinationArray.Element()
	_, ok := astmodel.AsTypeName(destinationElement)
	if !ok {
		return nil, nil
	}

	// The source map should be map[string]TypeName
	_, ok = astmodel.AsTypeName(sourceMapType.ValueType())
	if sourceMapType.KeyType() != astmodel.StringType || !ok {
		return nil, nil
	}

	conversion, err := CreateTypeConversion(
		sourceEndpoint.WithType(astmodel.StringType),
		destinationEndpoint.WithType(astmodel.ResourceReferenceType),
		conversionContext)
	if err != nil {
		return nil, errors.Wrapf(
			err,
			"finding UserAssignedIdentities conversion from %s to %s",
			astmodel.DebugDescription(astmodel.StringType),
			astmodel.DebugDescription(astmodel.ResourceReferenceType))
	}

	return func(
		reader dst.Expr,
		writer func(dst.Expr) []dst.Stmt,
		knownLocals *astmodel.KnownLocalsSet,
		generationContext *astmodel.CodeGenerationContext,
	) ([]dst.Stmt, error) {

		// <source>List := make([]<type>, 0, len(<source>)
		tempId := knownLocals.CreateSingularLocal(sourceEndpoint.Name(), "List")
		declaration := astbuilder.ShortDeclaration(
			tempId,
			astbuilder.MakeEmptySlice(destinationArray.AsType(generationContext), astbuilder.CallFunc("len", reader)))

		loopLocals := knownLocals.Clone()
		keyID := loopLocals.CreateLocal(sourceEndpoint.Name(), "Key")

		intermediateDestination := loopLocals.CreateLocal(destinationEndpoint.Name(), "Ref")
		uaiBuilder := astbuilder.NewCompositeLiteralBuilder(destinationElement.AsType(generationContext))
		uaiBuilder.AddField("Reference", dst.NewIdent(intermediateDestination))

		writeToElement := func(expr dst.Expr) []dst.Stmt {
			return []dst.Stmt{
				astbuilder.ShortDeclaration(intermediateDestination, expr),
			}
		}

		//	for key, _ := range source.UserAssignedIdentities {
		//	   ref := genruntime.CreateResourceReferenceFromARMID(key)
		//	   <arr> = append(<arr>, UserAssignedIdentityDetails{Reference: ref})
		//	}
		loopBody := astbuilder.Statements(
			conversion(dst.NewIdent(keyID), writeToElement, loopLocals, generationContext),
			astbuilder.AppendItemToSlice(dst.NewIdent(tempId), uaiBuilder.Build()),
		)
		loop := astbuilder.IterateOverMapWithKey(
			keyID,
			reader,
			loopBody...,
		)

		// if source.UserAssignedIdentities != nil
		checkForNil := astbuilder.AreNotEqual(reader, astbuilder.Nil())

		// <writer> = nil
		assignNil := writer(astbuilder.Nil())

		// <writer> = <arr>
		assignValue := writer(dst.NewIdent(tempId))

		// if source.UserAssignedIdentities != nil {
		//     <loop>
		// } else {
		//     <writer> = nil
		// }
		trueBranch := astbuilder.Statements(
			declaration,
			loop,
			assignValue)

		return astbuilder.Statements(
			astbuilder.SimpleIfElse(checkForNil, trueBranch, assignNil)), nil
	}, nil
}

// assignEnumFromEnum will generate a conversion if both definitions have the same underlying
// primitive type and neither source nor destination is optional
//
// <local> = <baseType>(<source>)
// <destination> = <enum>(<local>)
//
// We don't technically need this one, but it generates nicer code because it bypasses an unnecessary cast.
func assignEnumFromEnum(
	sourceEndpoint *TypedConversionEndpoint,
	destinationEndpoint *TypedConversionEndpoint,
	conversionContext *PropertyConversionContext) (PropertyConversion, error) {

	// Require both source and destination to not be bag items
	if sourceEndpoint.IsBagItem() || destinationEndpoint.IsBagItem() {
		return nil, nil
	}

	// Require both source and destination to be non-optional
	if sourceEndpoint.IsOptional() || destinationEndpoint.IsOptional() {
		return nil, nil
	}

	// Require source to be an enumeration
	_, sourceType, sourceFound := conversionContext.ResolveType(sourceEndpoint.Type())
	if !sourceFound {
		return nil, nil
	}
	sourceEnum, sourceIsEnum := astmodel.AsEnumType(sourceType)
	if !sourceIsEnum {
		return nil, nil
	}

	// Require destination to be an enumeration
	destinationName, destinationType, destinationFound := conversionContext.ResolveType(destinationEndpoint.Type())
	if !destinationFound {
		return nil, nil
	}
	destinationEnum, destinationIsEnum := astmodel.AsEnumType(destinationType)
	if !destinationIsEnum {
		return nil, nil
	}

	// Require enumerations to have the same base definitions
	if !astmodel.TypeEquals(sourceEnum.BaseType(), destinationEnum.BaseType()) {
		return nil, errors.Errorf(
			"no conversion from %s to %s",
			astmodel.DebugDescription(sourceEnum.BaseType()),
			astmodel.DebugDescription(destinationEnum.BaseType()))
	}

	return func(
		reader dst.Expr,
		writer func(dst.Expr) []dst.Stmt,
		knownLocals *astmodel.KnownLocalsSet,
		generationContext *astmodel.CodeGenerationContext,
	) ([]dst.Stmt, error) {
		local := knownLocals.CreateSingularLocal(destinationEndpoint.Name(), "", "As"+destinationName.Name(), "Value")
		declare := astbuilder.ShortDeclaration(local, astbuilder.CallFunc(destinationName.Name(), reader))
		write := writer(dst.NewIdent(local))
		return astbuilder.Statements(
			declare,
			write,
		), nil
	}, nil
}

// assignPrimitiveFromEnum will generate a conversion from an enumeration if the
// destination has the underlying base type of the enumeration and neither source nor destination
// is optional
//
// <local> = <baseType>(<source>)
// <destination> = <enum>(<local>)
func assignPrimitiveFromEnum(
	sourceEndpoint *TypedConversionEndpoint,
	destinationEndpoint *TypedConversionEndpoint,
	conversionContext *PropertyConversionContext) (PropertyConversion, error) {

	// Require both source and destination to not be bag items
	if sourceEndpoint.IsBagItem() || destinationEndpoint.IsBagItem() {
		return nil, nil
	}

	// Require both source and destination to be non-optional
	if sourceEndpoint.IsOptional() || destinationEndpoint.IsOptional() {
		return nil, nil
	}

	// Require source to be an enumeration
	_, srcType, ok := conversionContext.ResolveType(sourceEndpoint.Type())
	if !ok {
		return nil, nil
	}
	srcEnum, srcIsEnum := astmodel.AsEnumType(srcType)
	if !srcIsEnum {
		return nil, nil
	}

	// Require destination to be a primitive type
	dstPrimitive, ok := astmodel.AsPrimitiveType(destinationEndpoint.Type())
	if !ok {
		return nil, nil
	}

	// Require enumeration to have the destination as base type
	if !astmodel.TypeEquals(srcEnum.BaseType(), dstPrimitive) {
		return nil, nil
	}

	return func(
		reader dst.Expr,
		writer func(dst.Expr) []dst.Stmt,
		knownLocals *astmodel.KnownLocalsSet,
		generationContext *astmodel.CodeGenerationContext,
	) ([]dst.Stmt, error) {
		return writer(astbuilder.CallFunc(dstPrimitive.Name(), reader)), nil
	}, nil
}

// assignObjectDirectlyFromObject will generate a conversion if both properties are TypeNames referencing ObjectType
// definitions, neither property is optional, and the types are adjacent in our storage conversion graph.
//
// var <local> <destinationType>
// err := <local>.AssignPropertiesFrom(<source>)
//
//	if err != nil {
//	    return errors.Wrap(err, "while calling <local>.AssignPropertiesFrom(<source>)")
//	}
//
// <destination> = <local>
func assignObjectDirectlyFromObject(
	sourceEndpoint *TypedConversionEndpoint,
	destinationEndpoint *TypedConversionEndpoint,
	conversionContext *PropertyConversionContext) (PropertyConversion, error) {

	// Require expected direction
	if conversionContext.direction != ConvertFrom {
		return nil, nil
	}

	// Require both source and destination to not be bag items
	if sourceEndpoint.IsBagItem() || destinationEndpoint.IsBagItem() {
		return nil, nil
	}

	// Require both source and destination to be non-optional
	if sourceEndpoint.IsOptional() || destinationEndpoint.IsOptional() {
		return nil, nil
	}

	// Require source to be the name of an object
	sourceName, sourceType, sourceFound := conversionContext.ResolveType(sourceEndpoint.Type())
	if !sourceFound {
		return nil, nil
	}
	if _, sourceIsObject := astmodel.AsObjectType(sourceType); !sourceIsObject {
		return nil, nil
	}

	// Require destination to be the name of an object
	destinationName, destinationType, destinationFound := conversionContext.ResolveType(destinationEndpoint.Type())
	if !destinationFound {
		return nil, nil
	}
	_, destinationIsObject := astmodel.AsObjectType(destinationType)
	if !destinationIsObject {
		return nil, nil
	}

	// If the source and destination types are in different packages, we must consult the conversion graph to make sure
	// this is an expected conversion.
	if !sourceName.PackageReference.Equals(destinationName.PackageReference) {

		// If our two types are not adjacent in our conversion graph, this is not the conversion you're looking for
		nextType, err := conversionContext.FindNextType(destinationName)
		if err != nil {
			return nil, errors.Wrapf(
				err,
				"looking up next type for %s",
				astmodel.DebugDescription(destinationEndpoint.Type()))
		}

		if !nextType.IsEmpty() && !astmodel.TypeEquals(nextType, sourceName) {
			return nil, nil
		}

		// If the two definitions have different names, require an explicit rename from one to the other
		//
		// Challenge: If we can detect incorrect renaming configuration here, why do we need that configuration at all?
		// Answer: Because we need to use that configuration other places (such as ConversionGraph) where we don't have
		// the right information to infer correctly.
		//
		if sourceName.Name() != destinationName.Name() {
			err := conversionContext.validateTypeRename(sourceName, destinationName)
			if err != nil {
				return nil, err
			}
		}
	}

	return func(
		reader dst.Expr,
		writer func(dst.Expr) []dst.Stmt,
		knownLocals *astmodel.KnownLocalsSet,
		generationContext *astmodel.CodeGenerationContext,
	) ([]dst.Stmt, error) {
		copyVar := knownLocals.CreateSingularLocal(destinationEndpoint.Name(), "", "Local", "Copy", "Temp")

		// We have to do this at render time in order to ensure the first conversion generated
		// declares 'err', not a later one
		tok := token.ASSIGN
		if knownLocals.TryCreateLocal("err") {
			tok = token.DEFINE
		}

		localId := dst.NewIdent(copyVar)
		errLocal := dst.NewIdent("err")

		errorsPackageName := generationContext.MustGetImportedPackageName(astmodel.GitHubErrorsReference)

		declaration := astbuilder.LocalVariableDeclaration(copyVar, createTypeDeclaration(destinationName, generationContext), "")

		functionName := NameOfPropertyAssignmentFunction(
			conversionContext.FunctionBaseName(), sourceName, ConvertFrom, conversionContext.idFactory)

		conversion := astbuilder.AssignmentStatement(
			errLocal,
			tok,
			astbuilder.CallExpr(localId, functionName, astbuilder.AsReference(reader)))

		checkForError := astbuilder.ReturnIfNotNil(
			errLocal,
			astbuilder.WrappedErrorf(
				errorsPackageName,
				"calling %s() to %s",
				functionName,
				describeAssignment(sourceEndpoint, destinationEndpoint)))

		assignment := writer(localId)
		return astbuilder.Statements(declaration, conversion, checkForError, assignment), nil
	}, nil
}

// assignObjectDirectlyToObject will generate a conversion if both properties are TypeNames referencing ObjectType
// definitions, neither property is optional, and the types are adjacent in our storage conversion graph.
//
// var <local> <destinationType>
// err := <source>.AssignPropertiesTo(&<local>)
//
//	if err != nil {
//	    return errors.Wrap(err, "while calling <local>.AssignPropertiesTo(<source>)")
//	}
//
// <destination> = <local>
func assignObjectDirectlyToObject(
	sourceEndpoint *TypedConversionEndpoint,
	destinationEndpoint *TypedConversionEndpoint,
	conversionContext *PropertyConversionContext) (PropertyConversion, error) {

	// Require expected direction
	if conversionContext.direction != ConvertTo {
		return nil, nil
	}

	// Require both source and destination to not be bag items
	if sourceEndpoint.IsBagItem() || destinationEndpoint.IsBagItem() {
		return nil, nil
	}

	// Require both source and destination to be non-optional
	if sourceEndpoint.IsOptional() || destinationEndpoint.IsOptional() {
		return nil, nil
	}

	// Require source to be the name of an object
	sourceName, sourceType, sourceFound := conversionContext.ResolveType(sourceEndpoint.Type())
	if !sourceFound {
		return nil, nil
	}
	if _, sourceIsObject := astmodel.AsObjectType(sourceType); !sourceIsObject {
		return nil, nil
	}

	// Require destination to be the name of an object
	destinationName, destinationType, destinationFound := conversionContext.ResolveType(destinationEndpoint.Type())
	if !destinationFound {
		return nil, nil
	}
	_, destinationIsObject := astmodel.AsObjectType(destinationType)
	if !destinationIsObject {
		return nil, nil
	}

	// If the source and destination types are in different packages, we must consult the conversion graph to make sure
	// this is an expected conversion.
	if !sourceName.PackageReference.Equals(destinationName.PackageReference) {

		// If our two types are not adjacent in our conversion graph, this is not the conversion you're looking for
		// Check that
		nextType, err := conversionContext.FindNextType(sourceName)
		if err != nil {
			return nil, errors.Wrapf(
				err,
				"looking up next type for %s",
				astmodel.DebugDescription(sourceEndpoint.Type()))
		}

		if !nextType.IsEmpty() && !astmodel.TypeEquals(nextType, destinationName) {
			return nil, nil
		}

		// If the two definitions have different names, require an explicit rename from one to the other
		//
		// Challenge: If we can detect incorrect renaming configuration here, why do we need that configuration at all?
		// Answer: Because we need to use that configuration other places (such as ConversionGraph) where we don't have
		// the right information to infer correctly.
		//
		if sourceName.Name() != destinationName.Name() {
			err := conversionContext.validateTypeRename(sourceName, destinationName)
			if err != nil {
				return nil, err
			}
		}
	}

	return func(
		reader dst.Expr,
		writer func(dst.Expr) []dst.Stmt,
		knownLocals *astmodel.KnownLocalsSet,
		generationContext *astmodel.CodeGenerationContext,
	) ([]dst.Stmt, error) {
		copyVar := knownLocals.CreateSingularLocal(destinationEndpoint.Name(), "", "Local", "Copy", "Temp")

		// We have to do this at render time in order to ensure the first conversion generated
		// declares 'err', not a later one
		tok := token.ASSIGN
		if knownLocals.TryCreateLocal("err") {
			tok = token.DEFINE
		}

		localId := dst.NewIdent(copyVar)
		errLocal := dst.NewIdent("err")

		errorsPackageName := generationContext.MustGetImportedPackageName(astmodel.GitHubErrorsReference)

		declaration := astbuilder.LocalVariableDeclaration(copyVar, createTypeDeclaration(destinationName, generationContext), "")

		functionName := NameOfPropertyAssignmentFunction(
			conversionContext.FunctionBaseName(), destinationName, ConvertTo, conversionContext.idFactory)
		conversion := astbuilder.AssignmentStatement(
			errLocal,
			tok,
			astbuilder.CallExpr(reader, functionName, astbuilder.AddrOf(localId)))

		checkForError := astbuilder.ReturnIfNotNil(
			errLocal,
			astbuilder.WrappedErrorf(
				errorsPackageName,
				"calling %s() to %s",
				functionName,
				describeAssignment(sourceEndpoint, destinationEndpoint)))

		assignment := writer(dst.NewIdent(copyVar))
		return astbuilder.Statements(declaration, conversion, checkForError, assignment), nil
	}, nil
}

// assignObjectsViaIntermediateObject will generate a conversion if both properties are TypeNames referencing ObjectType
// definitions, neither property is optional, and the types are NOT adjacent in our storage conversion graph.
// The conversion is implemented by assigning properties to an intermediate instance before assigning those to our
// actual destination instance.
//
// For ConvertFrom the generated code will be:
//
// var <local> <intermediateType>
// err := <local>.AssignPropertiesFrom(<source>)
//
//	if err != nil {
//	    return errors.Wrap(err, "while calling <local>.AssignPropertiesFrom(<source>)")
//	}
//
// var <otherlocal> <destinationType>
// err := <otherlocal>.AssignPropertiesFrom(<local>)
//
//	if err != nil {
//	    return errors.Wrap(err, "while calling <otherlocal>.AssignPropertiesFrom(<local>)")
//	}
//
// Note the actual steps are generated by nested conversions; this handler works by finding the two conversions needed
// given our intermediate type and chaining them together.
func assignObjectsViaIntermediateObject(
	sourceEndpoint *TypedConversionEndpoint,
	destinationEndpoint *TypedConversionEndpoint,
	conversionContext *PropertyConversionContext) (PropertyConversion, error) {

	// Require both source and destination to not be bag items
	if sourceEndpoint.IsBagItem() || destinationEndpoint.IsBagItem() {
		return nil, nil
	}

	// Require both source and destination to be non-optional
	if sourceEndpoint.IsOptional() || destinationEndpoint.IsOptional() {
		return nil, nil
	}

	// Require source to be the name of an object
	sourceName, sourceType, sourceFound := conversionContext.ResolveType(sourceEndpoint.Type())
	if !sourceFound {
		return nil, nil
	}
	if _, sourceIsObject := astmodel.AsObjectType(sourceType); !sourceIsObject {
		return nil, nil
	}

	// Require destination to be the name of an object
	destinationName, destinationType, destinationFound := conversionContext.ResolveType(destinationEndpoint.Type())
	if !destinationFound {
		return nil, nil
	}
	_, destinationIsObject := astmodel.AsObjectType(destinationType)
	if !destinationIsObject {
		return nil, nil
	}

	// If our two types are not adjacent in our conversion graph, this *IS* the conversion you're looking for
	earlierName := conversionContext.direction.SelectType(destinationName, sourceName).(astmodel.TypeName)
	intermediateName, err := conversionContext.FindNextType(earlierName)
	if err != nil {
		return nil, errors.Wrapf(
			err,
			"looking up next type for %s",
			astmodel.DebugDescription(destinationEndpoint.Type()))
	}

	if intermediateName.IsEmpty() || astmodel.TypeEquals(intermediateName, sourceName) {
		return nil, nil
	}

	// Make sure we can reference our intermediate type when needed
	conversionContext.AddPackageReference(intermediateName.PackageReference)

	// Need a pair of conversions, using our intermediate type
	intermediateEndpoint := NewTypedConversionEndpoint(
		intermediateName,
		intermediateName.Name()+"Stash")
	firstConversion, err := CreateTypeConversion(sourceEndpoint, intermediateEndpoint, conversionContext)
	if err != nil {
		return nil, errors.Wrapf(
			err,
			"finding first intermediate conversion, from %s to %s",
			astmodel.DebugDescription(sourceName),
			astmodel.DebugDescription(intermediateName))
	}
	if firstConversion == nil {
		return nil, nil
	}

	secondConversion, err := CreateTypeConversion(intermediateEndpoint, destinationEndpoint, conversionContext)
	if err != nil {
		return nil, errors.Wrapf(
			err,
			"finding second intermediate conversion, from %s to %s",
			astmodel.DebugDescription(intermediateName),
			astmodel.DebugDescription(destinationType))
	}

	if secondConversion == nil {
		return nil, nil
	}

	return func(
		reader dst.Expr,
		writer func(dst.Expr) []dst.Stmt,
		knownLocals *astmodel.KnownLocalsSet,
		generationContext *astmodel.CodeGenerationContext,
	) ([]dst.Stmt, error) {

		// We capture the expression written by the first step pass it to the second step,
		// allowing us to avoid extra local variable (this is a bit sneaky, as we rely on assignObjectDirectlyFromObject
		// and assignObjectDirectlyToObject using a local variable themselves.)
		var capture dst.Expr = nil
		capturingWriter := func(expr dst.Expr) []dst.Stmt {
			capture = expr
			return []dst.Stmt{}
		}

		// Capture the first step
		firstStep := firstConversion(reader, capturingWriter, knownLocals, generationContext)
		secondStep := secondConversion(capture, writer, knownLocals, generationContext)

		return astbuilder.Statements(
			firstStep,
			secondStep), nil
	}, nil
}

// assignKnownType will generate an assignment if both definitions have the specified TypeName
//
// <destination> = <source>
//
//nolint:deadcode,unused
func assignKnownType(name astmodel.TypeName) func(*TypedConversionEndpoint, *TypedConversionEndpoint, *PropertyConversionContext) (PropertyConversion, error) {
	return func(sourceEndpoint *TypedConversionEndpoint, destinationEndpoint *TypedConversionEndpoint, _ *PropertyConversionContext) (PropertyConversion, error) {
		// Require both source and destination to not be bag items
		if sourceEndpoint.IsBagItem() || destinationEndpoint.IsBagItem() {
			return nil, nil
		}

		// Require both source and destination to be non-optional
		if sourceEndpoint.IsOptional() || destinationEndpoint.IsOptional() {
			return nil, nil
		}

		// Require source to be a named type
		sourceName, sourceIsName := astmodel.AsTypeName(sourceEndpoint.Type())
		if !sourceIsName {
			return nil, nil
		}

		// Require destination to be a named type
		destinationName, destinationIsName := astmodel.AsTypeName(destinationEndpoint.Type())
		if !destinationIsName {
			return nil, nil
		}

		// Require source to be our specific type
		if !astmodel.TypeEquals(sourceName, name) {
			return nil, nil
		}

		// Require destination to be our specific type
		if !astmodel.TypeEquals(destinationName, name) {
			return nil, nil
		}

		return func(
			reader dst.Expr,
			writer func(dst.Expr) []dst.Stmt,
			knownLocals *astmodel.KnownLocalsSet,
			generationContext *astmodel.CodeGenerationContext,
		) ([]dst.Stmt, error) {
			return writer(reader), nil
		}, nil
	}
}

type knownTypeMethodReturn int

const (
	returnsReference = 0
	returnsValue     = 1
)

// copyKnownType will generate an assignment with the results of a call on the specified TypeName
//
// <destination> = <source>.<methodName>()
func copyKnownType(name astmodel.TypeName, methodName string, returnKind knownTypeMethodReturn) func(*TypedConversionEndpoint, *TypedConversionEndpoint, *PropertyConversionContext) (PropertyConversion, error) {
	return func(sourceEndpoint *TypedConversionEndpoint, destinationEndpoint *TypedConversionEndpoint, _ *PropertyConversionContext) (PropertyConversion, error) {
		// Require both source and destination to not be bag items
		if sourceEndpoint.IsBagItem() || destinationEndpoint.IsBagItem() {
			return nil, nil
		}

		// Require both source and destination to be non-optional
		if sourceEndpoint.IsOptional() || destinationEndpoint.IsOptional() {
			return nil, nil
		}

		// Require source to be a named type
		sourceName, sourceIsName := astmodel.AsTypeName(sourceEndpoint.Type())
		if !sourceIsName {
			return nil, nil
		}

		// Require destination to be a named type
		destinationName, destinationIsName := astmodel.AsTypeName(destinationEndpoint.Type())
		if !destinationIsName {
			return nil, nil
		}

		// Require source to be our specific type
		if !astmodel.TypeEquals(sourceName, name) {
			return nil, nil
		}

		// Require destination to be our specific type
		if !astmodel.TypeEquals(destinationName, name) {
			return nil, nil
		}

		return func(
			reader dst.Expr,
			writer func(dst.Expr) []dst.Stmt,
			knownLocals *astmodel.KnownLocalsSet,
			generationContext *astmodel.CodeGenerationContext,
		) ([]dst.Stmt, error) {
			// If our writer is dereferencing a value, skip that as we don't need to dereference before a method call
			if star, ok := reader.(*dst.StarExpr); ok {
				reader = star.X
			}

			if returnKind == returnsReference {
				// If the copy method returns a ptr, we need to dereference
				// This dereference is always safe because we ensured that both source and destination are always
				// non-optional. The handler assignToOptional() should do the right thing when this happens.
				return writer(astbuilder.Dereference(astbuilder.CallExpr(reader, methodName))), nil
			}

			return writer(astbuilder.CallExpr(reader, methodName)), nil
		}, nil
	}
}

func createTypeDeclaration(name astmodel.TypeName, generationContext *astmodel.CodeGenerationContext) dst.Expr {
	if name.PackageReference.Equals(generationContext.CurrentPackage()) {
		return dst.NewIdent(name.Name())
	}

	packageName := generationContext.MustGetImportedPackageName(name.PackageReference)
	return astbuilder.Selector(dst.NewIdent(packageName), name.Name())
}

func describeAssignment(sourceEndpoint *TypedConversionEndpoint, destinationEndpoint *TypedConversionEndpoint) string {
	if sourceEndpoint.Name() != destinationEndpoint.Name() {
		return fmt.Sprintf("populate field %s from %s", destinationEndpoint.Name(), sourceEndpoint.Name())
	}

	return fmt.Sprintf("populate field %s", destinationEndpoint.Name())
}
