 // Code generated by azure-service-operator-codegen. DO NOT EDIT.
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT license.
 package storage
 
 import (
+	compat "github.com/Azure/azure-service-operator/testing/person/v20211231/storage/compat"
 	storage "github.com/Azure/azure-service-operator/testing/person/v20220630/storage"
 	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
 	"github.com/rotisserie/eris"
 )
 
 // Storage version of v20211231.Person_Spec
 type Person_Spec struct {
 	FamilyName  *string                `json:"familyName,omitempty"`
 	FullName    *string                `json:"fullName,omitempty"`
 	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
 }
 
 // AssignProperties_From_Person_Spec populates our Person_Spec from the provided source Person_Spec
 func (person *Person_Spec) AssignProperties_From_Person_Spec(source *storage.Person_Spec) error {
 	// Clone the existing property bag
 	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)
 
 	// FamilyName
 	person.FamilyName = genruntime.ClonePointerToString(source.FamilyName)
 
 	// FullName
 	person.FullName = genruntime.ClonePointerToString(source.FullName)
 
 	// Residence
 	if source.Residence != nil {
-		propertyBag.Add("Residence", *source.Residence)
+		var residence compat.Residence
+		err := residence.AssignProperties_From_Residence(source.Residence)
+		if err != nil {
+			return eris.Wrap(err, "calling AssignProperties_From_Residence() to populate field Residence")
+		}
+		propertyBag.Add("Residence", residence)
 	} else {
 		propertyBag.Remove("Residence")
 	}
 
 	// Update the property bag
 	if len(propertyBag) > 0 {
 		person.PropertyBag = propertyBag
 	} else {
 		person.PropertyBag = nil
 	}
 
 	// Invoke the augmentConversionForPerson_Spec interface (if implemented) to customize the conversion
 	var personAsAny any = person
 	if augmentedPerson, ok := personAsAny.(augmentConversionForPerson_Spec); ok {
 		err := augmentedPerson.AssignPropertiesFrom(source)
 		if err != nil {
 			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
 		}
 	}
 
 	// No error
 	return nil
 }
 
 // AssignProperties_To_Person_Spec populates the provided destination Person_Spec from our Person_Spec
 func (person *Person_Spec) AssignProperties_To_Person_Spec(destination *storage.Person_Spec) error {
 	// Clone the existing property bag
 	propertyBag := genruntime.NewPropertyBag(person.PropertyBag)
 
 	// FamilyName
 	destination.FamilyName = genruntime.ClonePointerToString(person.FamilyName)
 
 	// FullName
 	destination.FullName = genruntime.ClonePointerToString(person.FullName)
 
 	// Residence
 	if propertyBag.Contains("Residence") {
-		var residence storage.Residence
-		err := propertyBag.Pull("Residence", &residence)
+		var residenceFromBag compat.Residence
+		err := propertyBag.Pull("Residence", &residenceFromBag)
 		if err != nil {
 			return eris.Wrap(err, "pulling 'Residence' from propertyBag")
 		}
 
+		var residence storage.Residence
+		err = residenceFromBag.AssignProperties_To_Residence(&residence)
+		if err != nil {
+			return eris.Wrap(err, "calling AssignProperties_To_Residence() to populate field Residence")
+		}
 		destination.Residence = &residence
 	} else {
 		destination.Residence = nil
 	}
 
 	// Update the property bag
 	if len(propertyBag) > 0 {
 		destination.PropertyBag = propertyBag
 	} else {
 		destination.PropertyBag = nil
 	}
 
 	// Invoke the augmentConversionForPerson_Spec interface (if implemented) to customize the conversion
 	var personAsAny any = person
 	if augmentedPerson, ok := personAsAny.(augmentConversionForPerson_Spec); ok {
 		err := augmentedPerson.AssignPropertiesTo(destination)
 		if err != nil {
 			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
 		}
 	}
 
 	// No error
 	return nil
 }
 
 type augmentConversionForPerson_Spec interface {
 	AssignPropertiesFrom(src *storage.Person_Spec) error
 	AssignPropertiesTo(dst *storage.Person_Spec) error
 }
 
