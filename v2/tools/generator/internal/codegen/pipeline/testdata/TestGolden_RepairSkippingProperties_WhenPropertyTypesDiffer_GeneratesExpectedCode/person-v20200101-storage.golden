 // Code generated by azure-service-operator-codegen. DO NOT EDIT.
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT license.
 package storage
 
 import (
 	v20211231s "github.com/Azure/azure-service-operator/testing/person/v20211231/storage"
-	v20220630s "github.com/Azure/azure-service-operator/testing/person/v20220630/storage"
+	v20211231sc "github.com/Azure/azure-service-operator/testing/person/v20211231/storage/compat"
 	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
 	"github.com/rotisserie/eris"
 )
 
 // Storage version of v20200101.Person_Spec
 type Person_Spec struct {
 	FamilyName  *string                `json:"familyName,omitempty"`
 	FullName    *string                `json:"fullName,omitempty"`
 	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
 	Residence   *Residence             `json:"residence,omitempty"`
 }
 
 // AssignProperties_From_Person_Spec populates our Person_Spec from the provided source Person_Spec
 func (person *Person_Spec) AssignProperties_From_Person_Spec(source *v20211231s.Person_Spec) error {
 	// Clone the existing property bag
 	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)
 
 	// FamilyName
 	person.FamilyName = genruntime.ClonePointerToString(source.FamilyName)
 
 	// FullName
 	person.FullName = genruntime.ClonePointerToString(source.FullName)
 
 	// Residence
 	if propertyBag.Contains("Residence") {
 		var residence Residence
 		err := propertyBag.Pull("Residence", &residence)
 		if err != nil {
 			return eris.Wrap(err, "pulling 'Residence' from propertyBag")
 		}
 
 		person.Residence = &residence
 	} else {
 		person.Residence = nil
 	}
 
 	// Update the property bag
 	if len(propertyBag) > 0 {
 		person.PropertyBag = propertyBag
 	} else {
 		person.PropertyBag = nil
 	}
 
 	// Invoke the augmentConversionForPerson_Spec interface (if implemented) to customize the conversion
 	var personAsAny any = person
 	if augmentedPerson, ok := personAsAny.(augmentConversionForPerson_Spec); ok {
 		err := augmentedPerson.AssignPropertiesFrom(source)
 		if err != nil {
 			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
 		}
 	}
 
 	// No error
 	return nil
 }
 
 // AssignProperties_To_Person_Spec populates the provided destination Person_Spec from our Person_Spec
 func (person *Person_Spec) AssignProperties_To_Person_Spec(destination *v20211231s.Person_Spec) error {
 	// Clone the existing property bag
 	propertyBag := genruntime.NewPropertyBag(person.PropertyBag)
 
 	// FamilyName
 	destination.FamilyName = genruntime.ClonePointerToString(person.FamilyName)
 
 	// FullName
 	destination.FullName = genruntime.ClonePointerToString(person.FullName)
 
 	// Residence
 	if person.Residence != nil {
 		propertyBag.Add("Residence", *person.Residence)
 	} else {
 		propertyBag.Remove("Residence")
 	}
 
 	// Update the property bag
 	if len(propertyBag) > 0 {
 		destination.PropertyBag = propertyBag
 	} else {
 		destination.PropertyBag = nil
 	}
 
 	// Invoke the augmentConversionForPerson_Spec interface (if implemented) to customize the conversion
 	var personAsAny any = person
 	if augmentedPerson, ok := personAsAny.(augmentConversionForPerson_Spec); ok {
 		err := augmentedPerson.AssignPropertiesTo(destination)
 		if err != nil {
 			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
 		}
 	}
 
 	// No error
 	return nil
 }
 
 type augmentConversionForPerson_Spec interface {
 	AssignPropertiesFrom(src *v20211231s.Person_Spec) error
 	AssignPropertiesTo(dst *v20211231s.Person_Spec) error
 }
 
 // Storage version of v20200101.Residence
 type Residence struct {
 	City        *string                `json:"city,omitempty"`
 	FullAddress *string                `json:"fullAddress,omitempty"`
 	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
 }
 
 // AssignProperties_From_Residence populates our Residence from the provided source Residence
-func (residence *Residence) AssignProperties_From_Residence(source *v20220630s.Residence) error {
+func (residence *Residence) AssignProperties_From_Residence(source *v20211231sc.Residence) error {
 	// Clone the existing property bag
 	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)
 
 	// City
 	residence.City = genruntime.ClonePointerToString(source.City)
 
 	// FullAddress
 	residence.FullAddress = genruntime.ClonePointerToString(source.FullAddress)
 
-	// Suburb
-	if source.Suburb != nil {
-		propertyBag.Add("Suburb", *source.Suburb)
-	} else {
-		propertyBag.Remove("Suburb")
-	}
-
 	// Update the property bag
 	if len(propertyBag) > 0 {
 		residence.PropertyBag = propertyBag
 	} else {
 		residence.PropertyBag = nil
 	}
 
 	// Invoke the augmentConversionForResidence interface (if implemented) to customize the conversion
 	var residenceAsAny any = residence
 	if augmentedResidence, ok := residenceAsAny.(augmentConversionForResidence); ok {
 		err := augmentedResidence.AssignPropertiesFrom(source)
 		if err != nil {
 			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
 		}
 	}
 
 	// No error
 	return nil
 }
 
 // AssignProperties_To_Residence populates the provided destination Residence from our Residence
-func (residence *Residence) AssignProperties_To_Residence(destination *v20220630s.Residence) error {
+func (residence *Residence) AssignProperties_To_Residence(destination *v20211231sc.Residence) error {
 	// Clone the existing property bag
 	propertyBag := genruntime.NewPropertyBag(residence.PropertyBag)
 
 	// City
 	destination.City = genruntime.ClonePointerToString(residence.City)
 
 	// FullAddress
 	destination.FullAddress = genruntime.ClonePointerToString(residence.FullAddress)
 
-	// Suburb
-	if propertyBag.Contains("Suburb") {
-		var suburb string
-		err := propertyBag.Pull("Suburb", &suburb)
-		if err != nil {
-			return eris.Wrap(err, "pulling 'Suburb' from propertyBag")
-		}
-
-		destination.Suburb = &suburb
-	} else {
-		destination.Suburb = nil
-	}
-
 	// Update the property bag
 	if len(propertyBag) > 0 {
 		destination.PropertyBag = propertyBag
 	} else {
 		destination.PropertyBag = nil
 	}
 
 	// Invoke the augmentConversionForResidence interface (if implemented) to customize the conversion
 	var residenceAsAny any = residence
 	if augmentedResidence, ok := residenceAsAny.(augmentConversionForResidence); ok {
 		err := augmentedResidence.AssignPropertiesTo(destination)
 		if err != nil {
 			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
 		}
 	}
 
 	// No error
 	return nil
 }
 
 type augmentConversionForResidence interface {
-	AssignPropertiesFrom(src *v20220630s.Residence) error
-	AssignPropertiesTo(dst *v20220630s.Residence) error
+	AssignPropertiesFrom(src *v20211231sc.Residence) error
+	AssignPropertiesTo(dst *v20211231sc.Residence) error
 }
 
