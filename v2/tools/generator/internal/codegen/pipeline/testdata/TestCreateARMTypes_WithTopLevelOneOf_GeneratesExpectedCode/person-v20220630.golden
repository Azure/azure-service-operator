// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v20220630

import (
	"fmt"
	arm "github.com/Azure/azure-service-operator/testing/person/v20220630/arm"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// +kubebuilder:object:root=true
// +kubebuilder:resource:categories={azure,person}
// +kubebuilder:subresource:status
type ClusterDatabase struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ClusterDatabase_Spec   `json:"spec,omitempty"`
	Status            ClusterDatabase_Status `json:"status,omitempty"`
}

// +kubebuilder:object:root=true
type ClusterDatabaseList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ClusterDatabase `json:"items"`
}

type ClusterDatabase_Spec struct {
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName         string                     `json:"azureName,omitempty"`
	ReadOnlyFollowing *ReadOnlyFollowingDatabase `json:"readOnlyFollowing,omitempty"`
	ReadWrite         *ReadWriteDatabase         `json:"readWrite,omitempty"`
}

var _ genruntime.ARMTransformer = &ClusterDatabase_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (database *ClusterDatabase_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if database == nil {
		return nil, nil
	}
	result := &arm.ClusterDatabase_Spec{}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "ReadOnlyFollowing":
	if database.ReadOnlyFollowing != nil {
		readOnlyFollowing_ARM, err := (*database.ReadOnlyFollowing).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		readOnlyFollowing := *readOnlyFollowing_ARM.(*arm.ReadOnlyFollowingDatabase)
		result.ReadOnlyFollowing = &readOnlyFollowing
		result.ReadOnlyFollowing.Name = database.AzureName
	}

	// Set property "ReadWrite":
	if database.ReadWrite != nil {
		readWrite_ARM, err := (*database.ReadWrite).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		readWrite := *readWrite_ARM.(*arm.ReadWriteDatabase)
		result.ReadWrite = &readWrite
		result.ReadWrite.Name = database.AzureName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (database *ClusterDatabase_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ClusterDatabase_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (database *ClusterDatabase_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ClusterDatabase_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ClusterDatabase_Spec, got %T", armInput)
	}

	// Set property "AzureName":
	database.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "ReadOnlyFollowing":
	if typedInput.ReadOnlyFollowing != nil {
		var readOnlyFollowing1 ReadOnlyFollowingDatabase
		err := readOnlyFollowing1.PopulateFromARM(owner, *typedInput.ReadOnlyFollowing)
		if err != nil {
			return err
		}
		readOnlyFollowing := readOnlyFollowing1
		database.ReadOnlyFollowing = &readOnlyFollowing
		database.AzureName = typedInput.ReadOnlyFollowing.Name
	}

	// Set property "ReadWrite":
	if typedInput.ReadWrite != nil {
		var readWrite1 ReadWriteDatabase
		err := readWrite1.PopulateFromARM(owner, *typedInput.ReadWrite)
		if err != nil {
			return err
		}
		readWrite := readWrite1
		database.ReadWrite = &readWrite
		database.AzureName = typedInput.ReadWrite.Name
	}

	// No error
	return nil
}

type ClusterDatabase_Status struct {
	Name *string `json:"name,omitempty"`
}

var _ genruntime.ARMTransformer = &ClusterDatabase_Status{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (status *ClusterDatabase_Status) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if status == nil {
		return nil, nil
	}
	result := &arm.ClusterDatabase_Status{}

	// Set property "Name":
	if status.Name != nil {
		name := *status.Name
		result.Name = &name
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (status *ClusterDatabase_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ClusterDatabase_Status{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (status *ClusterDatabase_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ClusterDatabase_Status)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ClusterDatabase_Status, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		status.Name = &name
	}

	// No error
	return nil
}

type ReadOnlyFollowingDatabase struct {
	Kind       ReadOnlyFollowingDatabaseKind `json:"kind,omitempty"`
	Location   *string                       `json:"location,omitempty"`
	Properties *string                       `json:"properties,omitempty"`
}

var _ genruntime.ARMTransformer = &ReadOnlyFollowingDatabase{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (database *ReadOnlyFollowingDatabase) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if database == nil {
		return nil, nil
	}
	result := &arm.ReadOnlyFollowingDatabase{}

	// Set property "Kind":
	var temp string
	temp = string(database.Kind)
	result.Kind = arm.ReadOnlyFollowingDatabaseKind(temp)

	// Set property "Location":
	if database.Location != nil {
		location := *database.Location
		result.Location = &location
	}

	// no assignment for property "Name"

	// Set property "Properties":
	if database.Properties != nil {
		properties := *database.Properties
		result.Properties = &properties
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (database *ReadOnlyFollowingDatabase) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ReadOnlyFollowingDatabase{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (database *ReadOnlyFollowingDatabase) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ReadOnlyFollowingDatabase)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ReadOnlyFollowingDatabase, got %T", armInput)
	}

	// Set property "Kind":
	var temp string
	temp = string(typedInput.Kind)
	database.Kind = ReadOnlyFollowingDatabaseKind(temp)

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		database.Location = &location
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		properties := *typedInput.Properties
		database.Properties = &properties
	}

	// No error
	return nil
}

type ReadWriteDatabase struct {
	Kind       ReadWriteDatabaseKind `json:"kind,omitempty"`
	Location   *string               `json:"location,omitempty"`
	Properties *string               `json:"properties,omitempty"`
}

var _ genruntime.ARMTransformer = &ReadWriteDatabase{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (database *ReadWriteDatabase) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if database == nil {
		return nil, nil
	}
	result := &arm.ReadWriteDatabase{}

	// Set property "Kind":
	var temp string
	temp = string(database.Kind)
	result.Kind = arm.ReadWriteDatabaseKind(temp)

	// Set property "Location":
	if database.Location != nil {
		location := *database.Location
		result.Location = &location
	}

	// no assignment for property "Name"

	// Set property "Properties":
	if database.Properties != nil {
		properties := *database.Properties
		result.Properties = &properties
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (database *ReadWriteDatabase) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ReadWriteDatabase{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (database *ReadWriteDatabase) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ReadWriteDatabase)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ReadWriteDatabase, got %T", armInput)
	}

	// Set property "Kind":
	var temp string
	temp = string(typedInput.Kind)
	database.Kind = ReadWriteDatabaseKind(temp)

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		database.Location = &location
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		properties := *typedInput.Properties
		database.Properties = &properties
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={ReadOnlyFollowing}
type ReadOnlyFollowingDatabaseKind string

const ReadOnlyFollowingDatabaseKind_ReadOnlyFollowing = ReadOnlyFollowingDatabaseKind(ReadOnlyFollowing)

// Mapping from string to ReadOnlyFollowingDatabaseKind
var readOnlyFollowingDatabaseKind_Values = map[string]ReadOnlyFollowingDatabaseKind{
	readonlyfollowing: ReadOnlyFollowingDatabaseKind_ReadOnlyFollowing,
}

// +kubebuilder:validation:Enum={ReadWrite}
type ReadWriteDatabaseKind string

const ReadWriteDatabaseKind_ReadWrite = ReadWriteDatabaseKind(ReadWrite)

// Mapping from string to ReadWriteDatabaseKind
var readWriteDatabaseKind_Values = map[string]ReadWriteDatabaseKind{
	readwrite: ReadWriteDatabaseKind_ReadWrite,
}

func init() {
	SchemeBuilder.Register(&ClusterDatabase{}, &ClusterDatabaseList{})
}
