// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package arm

import (
	"encoding/json"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
)

type ClusterDatabase_Spec struct {
	Name              string                     `conversion:"pushtoleaf" json:"name,omitempty"`
	ReadOnlyFollowing *ReadOnlyFollowingDatabase `json:"readOnlyFollowing,omitempty"`
	ReadWrite         *ReadWriteDatabase         `json:"readWrite,omitempty"`
}

var _ genruntime.ARMResourceSpec = &ClusterDatabase_Spec{}

// GetAPIVersion returns the ARM API version of the resource. This is always
func (database ClusterDatabase_Spec) GetAPIVersion() string {
	return 
}

// GetName returns the Name of the resource
func (database *ClusterDatabase_Spec) GetName() string {
	return database.Name
}

// GetType returns the ARM Type of the resource. This is always ""
func (database *ClusterDatabase_Spec) GetType() string {
	return ""
}

// MarshalJSON defers JSON marshaling to the first non-nil property, because ClusterDatabase_Spec represents a discriminated union (JSON OneOf)
func (database ClusterDatabase_Spec) MarshalJSON() ([]byte, error) {
	if database.ReadOnlyFollowing != nil {
		return json.Marshal(database.ReadOnlyFollowing)
	}

	if database.ReadWrite != nil {
		return json.Marshal(database.ReadWrite)
	}

	return nil, nil
}

// UnmarshalJSON unmarshals the ClusterDatabase_Spec
func (database *ClusterDatabase_Spec) UnmarshalJSON(data []byte) error {
	var rawJson map[string]interface{}
	err := json.Unmarshal(data, &rawJson)
	if err != nil {
		return err
	}
	discriminator := rawJson["kind"]
	if discriminator == ReadOnlyFollowing {
		database.ReadOnlyFollowing = &ReadOnlyFollowingDatabase{}
		return json.Unmarshal(data, database.ReadOnlyFollowing)
	}
	if discriminator == ReadWrite {
		database.ReadWrite = &ReadWriteDatabase{}
		return json.Unmarshal(data, database.ReadWrite)
	}

	// No error
	return nil
}

type ClusterDatabase_Status struct {
	Name *string `json:"name,omitempty"`
}

type ReadOnlyFollowingDatabase struct {
	Kind       ReadOnlyFollowingDatabaseKind `json:"kind,omitempty"`
	Location   *string                       `json:"location,omitempty"`
	Name       string                        `conversion:"noarmconversion" json:"name,omitempty"`
	Properties *string                       `json:"properties,omitempty"`
}

type ReadWriteDatabase struct {
	Kind       ReadWriteDatabaseKind `json:"kind,omitempty"`
	Location   *string               `json:"location,omitempty"`
	Name       string                `conversion:"noarmconversion" json:"name,omitempty"`
	Properties *string               `json:"properties,omitempty"`
}

// +kubebuilder:validation:Enum={ReadOnlyFollowing}
type ReadOnlyFollowingDatabaseKind string

const ReadOnlyFollowingDatabaseKind_ReadOnlyFollowing = ReadOnlyFollowingDatabaseKind(ReadOnlyFollowing)

// Mapping from string to ReadOnlyFollowingDatabaseKind
var readOnlyFollowingDatabaseKind_Values = map[string]ReadOnlyFollowingDatabaseKind{
	readonlyfollowing: ReadOnlyFollowingDatabaseKind_ReadOnlyFollowing,
}

// +kubebuilder:validation:Enum={ReadWrite}
type ReadWriteDatabaseKind string

const ReadWriteDatabaseKind_ReadWrite = ReadWriteDatabaseKind(ReadWrite)

// Mapping from string to ReadWriteDatabaseKind
var readWriteDatabaseKind_Values = map[string]ReadWriteDatabaseKind{
	readwrite: ReadWriteDatabaseKind_ReadWrite,
}
