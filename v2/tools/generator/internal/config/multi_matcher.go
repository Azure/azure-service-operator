/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 */

package config

import (
	"strings"

	"github.com/pkg/errors"
	kerrors "k8s.io/apimachinery/pkg/util/errors"
)

// MultiMatcher is a matcher that contains multiple other matchers
type MultiMatcher struct {
	matchers []StringMatcher
}

var _ StringMatcher = &MultiMatcher{}

// newMultiMatcher returns a new matcher for multiple strings
func newMultiMatcher(matcher string) *MultiMatcher {
	splits := strings.Split(matcher, ";")
	matchers := make([]StringMatcher, 0, len(splits))
	for _, str := range splits {
		m := NewStringMatcher(str)
		matchers = append(matchers, m)
	}

	return &MultiMatcher{
		matchers: matchers,
	}
}

// Matches returns true if the provided value is matched by any
func (mm *MultiMatcher) Matches(value string) bool {
	result := false
	// MUST not short circuit - for the suggestions generated by any nested matchers to be useful,
	// each matcher must see all potential match candidates.
	for _, m := range mm.matchers {
		if m.Matches(value) {
			result = true
		}
	}

	return result
}

// WasMatched returns nil if every nested matcher had a match, otherwise returns a diagnostic error
func (mm *MultiMatcher) WasMatched() error {
	var errs []error
	count := 0
	for _, m := range mm.matchers {
		if err := m.WasMatched(); err != nil {
			errs = append(errs, err)
			count++
		}
	}

	return errors.Wrapf(
		kerrors.NewAggregate(errs),
		"%d of %d did not match",
		count,
		len(mm.matchers))
}

// HasMultipleMatchers returns true if the matcher contains multiple definitions
func HasMultipleMatchers(matcher string) bool {
	return strings.ContainsRune(matcher, ';')
}

// String returns all the matchers we contain
func (mm *MultiMatcher) String() string {
	var builder strings.Builder
	for i, m := range mm.matchers {
		if i > 0 {
			builder.WriteString(";")
		}

		builder.WriteString(m.String())
	}

	return builder.String()
}
