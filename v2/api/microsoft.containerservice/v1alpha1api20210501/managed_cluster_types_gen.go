// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20210501

import (
	"fmt"
	"github.com/Azure/azure-service-operator/v2/api/microsoft.containerservice/v1alpha1api20210501storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/pkg/errors"
	"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	kerrors "k8s.io/apimachinery/pkg/util/errors"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:rbac:groups=microsoft.containerservice.azure.com,resources=managedclusters,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=microsoft.containerservice.azure.com,resources={managedclusters/status,managedclusters/finalizers},verbs=get;update;patch

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
//Generated from: https://schema.management.azure.com/schemas/2021-05-01/Microsoft.ContainerService.json#/resourceDefinitions/managedClusters
type ManagedCluster struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ManagedClusters_Spec  `json:"spec,omitempty"`
	Status            ManagedCluster_Status `json:"status,omitempty"`
}

var _ conditions.Conditioner = &ManagedCluster{}

// GetConditions returns the conditions of the resource
func (managedCluster *ManagedCluster) GetConditions() conditions.Conditions {
	return managedCluster.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (managedCluster *ManagedCluster) SetConditions(conditions conditions.Conditions) {
	managedCluster.Status.Conditions = conditions
}

// +kubebuilder:webhook:path=/mutate-microsoft-containerservice-azure-com-v1alpha1api20210501-managedcluster,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=microsoft.containerservice.azure.com,resources=managedclusters,verbs=create;update,versions=v1alpha1api20210501,name=default.v1alpha1api20210501.managedclusters.microsoft.containerservice.azure.com,admissionReviewVersions=v1

var _ admission.Defaulter = &ManagedCluster{}

// Default applies defaults to the ManagedCluster resource
func (managedCluster *ManagedCluster) Default() {
	managedCluster.defaultImpl()
	var temp interface{} = managedCluster
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (managedCluster *ManagedCluster) defaultAzureName() {
	if managedCluster.Spec.AzureName == "" {
		managedCluster.Spec.AzureName = managedCluster.Name
	}
}

// defaultImpl applies the code generated defaults to the ManagedCluster resource
func (managedCluster *ManagedCluster) defaultImpl() { managedCluster.defaultAzureName() }

var _ genruntime.KubernetesResource = &ManagedCluster{}

// AzureName returns the Azure name of the resource
func (managedCluster *ManagedCluster) AzureName() string {
	return managedCluster.Spec.AzureName
}

// GetResourceKind returns the kind of the resource
func (managedCluster *ManagedCluster) GetResourceKind() genruntime.ResourceKind {
	return genruntime.ResourceKindNormal
}

// GetSpec returns the specification of this resource
func (managedCluster *ManagedCluster) GetSpec() genruntime.ConvertibleSpec {
	return &managedCluster.Spec
}

// GetStatus returns the status of this resource
func (managedCluster *ManagedCluster) GetStatus() genruntime.ConvertibleStatus {
	return &managedCluster.Status
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.ContainerService/managedClusters"
func (managedCluster *ManagedCluster) GetType() string {
	return "Microsoft.ContainerService/managedClusters"
}

// NewEmptyStatus returns a new empty (blank) status
func (managedCluster *ManagedCluster) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &ManagedCluster_Status{}
}

// Owner returns the ResourceReference of the owner, or nil if there is no owner
func (managedCluster *ManagedCluster) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(managedCluster.Spec)
	return &genruntime.ResourceReference{
		Group:     group,
		Kind:      kind,
		Namespace: managedCluster.Namespace,
		Name:      managedCluster.Spec.Owner.Name,
	}
}

// SetStatus sets the status of this resource
func (managedCluster *ManagedCluster) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*ManagedCluster_Status); ok {
		managedCluster.Status = *st
		return nil
	}

	// Convert status to required version
	var st ManagedCluster_Status
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	managedCluster.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-microsoft-containerservice-azure-com-v1alpha1api20210501-managedcluster,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=microsoft.containerservice.azure.com,resources=managedclusters,verbs=create;update,versions=v1alpha1api20210501,name=validate.v1alpha1api20210501.managedclusters.microsoft.containerservice.azure.com,admissionReviewVersions=v1

var _ admission.Validator = &ManagedCluster{}

// ValidateCreate validates the creation of the resource
func (managedCluster *ManagedCluster) ValidateCreate() error {
	validations := managedCluster.createValidations()
	var temp interface{} = managedCluster
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateDelete validates the deletion of the resource
func (managedCluster *ManagedCluster) ValidateDelete() error {
	validations := managedCluster.deleteValidations()
	var temp interface{} = managedCluster
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateUpdate validates an update of the resource
func (managedCluster *ManagedCluster) ValidateUpdate(old runtime.Object) error {
	validations := managedCluster.updateValidations()
	var temp interface{} = managedCluster
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation(old)
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// createValidations validates the creation of the resource
func (managedCluster *ManagedCluster) createValidations() []func() error {
	return []func() error{managedCluster.validateResourceReferences}
}

// deleteValidations validates the deletion of the resource
func (managedCluster *ManagedCluster) deleteValidations() []func() error {
	return nil
}

// updateValidations validates the update of the resource
func (managedCluster *ManagedCluster) updateValidations() []func(old runtime.Object) error {
	return []func(old runtime.Object) error{
		func(old runtime.Object) error {
			return managedCluster.validateResourceReferences()
		},
	}
}

// validateResourceReferences validates all resource references
func (managedCluster *ManagedCluster) validateResourceReferences() error {
	refs, err := reflecthelpers.FindResourceReferences(&managedCluster.Spec)
	if err != nil {
		return err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// AssignPropertiesFromManagedCluster populates our ManagedCluster from the provided source ManagedCluster
func (managedCluster *ManagedCluster) AssignPropertiesFromManagedCluster(source *v1alpha1api20210501storage.ManagedCluster) error {

	// Spec
	var spec ManagedClusters_Spec
	err := spec.AssignPropertiesFromManagedClustersSpec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "populating Spec from Spec, calling AssignPropertiesFromManagedClustersSpec()")
	}
	managedCluster.Spec = spec

	// Status
	var status ManagedCluster_Status
	err = status.AssignPropertiesFromManagedClusterStatus(&source.Status)
	if err != nil {
		return errors.Wrap(err, "populating Status from Status, calling AssignPropertiesFromManagedClusterStatus()")
	}
	managedCluster.Status = status

	// No error
	return nil
}

// AssignPropertiesToManagedCluster populates the provided destination ManagedCluster from our ManagedCluster
func (managedCluster *ManagedCluster) AssignPropertiesToManagedCluster(destination *v1alpha1api20210501storage.ManagedCluster) error {

	// Spec
	var spec v1alpha1api20210501storage.ManagedClusters_Spec
	err := managedCluster.Spec.AssignPropertiesToManagedClustersSpec(&spec)
	if err != nil {
		return errors.Wrap(err, "populating Spec from Spec, calling AssignPropertiesToManagedClustersSpec()")
	}
	destination.Spec = spec

	// Status
	var status v1alpha1api20210501storage.ManagedCluster_Status
	err = managedCluster.Status.AssignPropertiesToManagedClusterStatus(&status)
	if err != nil {
		return errors.Wrap(err, "populating Status from Status, calling AssignPropertiesToManagedClusterStatus()")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (managedCluster *ManagedCluster) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: managedCluster.Spec.OriginalVersion(),
		Kind:    "ManagedCluster",
	}
}

// +kubebuilder:object:root=true
//Generated from: https://schema.management.azure.com/schemas/2021-05-01/Microsoft.ContainerService.json#/resourceDefinitions/managedClusters
type ManagedClusterList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ManagedCluster `json:"items"`
}

//Generated from:
type ManagedCluster_Status struct {
	//AadProfile: Profile of Azure Active Directory configuration.
	AadProfile *ManagedClusterAADProfile_Status `json:"aadProfile,omitempty"`

	//AddonProfiles: Profile of managed cluster add-on.
	AddonProfiles *v1.JSON `json:"addonProfiles,omitempty"`

	//AgentPoolProfiles: Properties of the agent pool.
	AgentPoolProfiles []ManagedClusterAgentPoolProfile_Status `json:"agentPoolProfiles,omitempty"`

	//ApiServerAccessProfile: Access profile for managed cluster API server.
	ApiServerAccessProfile *ManagedClusterAPIServerAccessProfile_Status `json:"apiServerAccessProfile,omitempty"`

	//AutoScalerProfile: Parameters to be applied to the cluster-autoscaler when
	//enabled
	AutoScalerProfile *ManagedClusterProperties_Status_AutoScalerProfile `json:"autoScalerProfile,omitempty"`

	//AutoUpgradeProfile: Profile of auto upgrade configuration.
	AutoUpgradeProfile *ManagedClusterAutoUpgradeProfile_Status `json:"autoUpgradeProfile,omitempty"`

	//AzurePortalFQDN: FQDN for the master pool which used by proxy config.
	AzurePortalFQDN *string `json:"azurePortalFQDN,omitempty"`

	//Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	//DisableLocalAccounts: If set to true, getting static credential will be disabled
	//for this cluster. Expected to only be used for AAD clusters.
	DisableLocalAccounts *bool `json:"disableLocalAccounts,omitempty"`

	//DiskEncryptionSetID: ResourceId of the disk encryption set to use for enabling
	//encryption at rest.
	DiskEncryptionSetID *string `json:"diskEncryptionSetID,omitempty"`

	//DnsPrefix: DNS prefix specified when creating the managed cluster.
	DnsPrefix *string `json:"dnsPrefix,omitempty"`

	//EnablePodSecurityPolicy: (DEPRECATING) Whether to enable Kubernetes pod security
	//policy (preview). This feature is set for removal on October 15th, 2020. Learn
	//more at aka.ms/aks/azpodpolicy.
	EnablePodSecurityPolicy *bool `json:"enablePodSecurityPolicy,omitempty"`

	//EnableRBAC: Whether to enable Kubernetes Role-Based Access Control.
	EnableRBAC *bool `json:"enableRBAC,omitempty"`

	//ExtendedLocation: The extended location of the Virtual Machine.
	ExtendedLocation *ExtendedLocation_Status `json:"extendedLocation,omitempty"`

	//Fqdn: FQDN for the master pool.
	Fqdn *string `json:"fqdn,omitempty"`

	//FqdnSubdomain: FQDN subdomain specified when creating private cluster with
	//custom private dns zone.
	FqdnSubdomain *string `json:"fqdnSubdomain,omitempty"`

	//HttpProxyConfig: Configurations for provisioning the cluster with HTTP proxy
	//servers.
	HttpProxyConfig *ManagedClusterHTTPProxyConfig_Status `json:"httpProxyConfig,omitempty"`

	//Id: Resource Id
	Id *string `json:"id,omitempty"`

	//Identity: The identity of the managed cluster, if configured.
	Identity *ManagedClusterIdentity_Status `json:"identity,omitempty"`

	//IdentityProfile: Identities associated with the cluster.
	IdentityProfile *v1.JSON `json:"identityProfile,omitempty"`

	//KubernetesVersion: Version of Kubernetes specified when creating the managed
	//cluster.
	KubernetesVersion *string `json:"kubernetesVersion,omitempty"`

	//LinuxProfile: Profile for Linux VMs in the container service cluster.
	LinuxProfile *ContainerServiceLinuxProfile_Status `json:"linuxProfile,omitempty"`

	//Location: Resource location
	Location *string `json:"location,omitempty"`

	//MaxAgentPools: The max number of agent pools for the managed cluster.
	MaxAgentPools *int `json:"maxAgentPools,omitempty"`

	//Name: Resource name
	Name *string `json:"name,omitempty"`

	//NetworkProfile: Profile of network configuration.
	NetworkProfile *ContainerServiceNetworkProfile_Status `json:"networkProfile,omitempty"`

	//NodeResourceGroup: Name of the resource group containing agent pool nodes.
	NodeResourceGroup *string `json:"nodeResourceGroup,omitempty"`

	//PodIdentityProfile: Profile of managed cluster pod identity.
	PodIdentityProfile *ManagedClusterPodIdentityProfile_Status `json:"podIdentityProfile,omitempty"`

	//PowerState: Represents the Power State of the cluster
	PowerState *PowerState_Status `json:"powerState,omitempty"`

	//PrivateFQDN: FQDN of private cluster.
	PrivateFQDN *string `json:"privateFQDN,omitempty"`

	//PrivateLinkResources: Private link resources associated with the cluster.
	PrivateLinkResources []PrivateLinkResource_Status `json:"privateLinkResources,omitempty"`

	//ProvisioningState: The current deployment or provisioning state, which only
	//appears in the response.
	ProvisioningState *string `json:"provisioningState,omitempty"`

	//ServicePrincipalProfile: Information about a service principal identity for the
	//cluster to use for manipulating Azure APIs.
	ServicePrincipalProfile *ManagedClusterServicePrincipalProfile_Status `json:"servicePrincipalProfile,omitempty"`

	//Sku: The managed cluster SKU.
	Sku *ManagedClusterSKU_Status `json:"sku,omitempty"`

	//Tags: Resource tags
	Tags map[string]string `json:"tags,omitempty"`

	//Type: Resource type
	Type *string `json:"type,omitempty"`

	//WindowsProfile: Profile for Windows VMs in the container service cluster.
	WindowsProfile *ManagedClusterWindowsProfile_Status `json:"windowsProfile,omitempty"`
}

var _ genruntime.ConvertibleStatus = &ManagedCluster_Status{}

// ConvertStatusFrom populates our ManagedCluster_Status from the provided source
func (managedClusterStatus *ManagedCluster_Status) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v1alpha1api20210501storage.ManagedCluster_Status)
	if ok {
		// Populate our instance from source
		return managedClusterStatus.AssignPropertiesFromManagedClusterStatus(src)
	}

	// Convert to an intermediate form
	src = &v1alpha1api20210501storage.ManagedCluster_Status{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = managedClusterStatus.AssignPropertiesFromManagedClusterStatus(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our ManagedCluster_Status
func (managedClusterStatus *ManagedCluster_Status) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v1alpha1api20210501storage.ManagedCluster_Status)
	if ok {
		// Populate destination from our instance
		return managedClusterStatus.AssignPropertiesToManagedClusterStatus(dst)
	}

	// Convert to an intermediate form
	dst = &v1alpha1api20210501storage.ManagedCluster_Status{}
	err := managedClusterStatus.AssignPropertiesToManagedClusterStatus(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &ManagedCluster_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (managedClusterStatus *ManagedCluster_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedCluster_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (managedClusterStatus *ManagedCluster_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedCluster_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedCluster_StatusARM, got %T", armInput)
	}

	// Set property ‘AadProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AadProfile != nil {
			var aadProfile1 ManagedClusterAADProfile_Status
			err := aadProfile1.PopulateFromARM(owner, *typedInput.Properties.AadProfile)
			if err != nil {
				return err
			}
			aadProfile := aadProfile1
			managedClusterStatus.AadProfile = &aadProfile
		}
	}

	// Set property ‘AddonProfiles’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AddonProfiles != nil {
			addonProfiles := *(*typedInput.Properties.AddonProfiles).DeepCopy()
			managedClusterStatus.AddonProfiles = &addonProfiles
		}
	}

	// Set property ‘AgentPoolProfiles’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.AgentPoolProfiles {
			var item1 ManagedClusterAgentPoolProfile_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			managedClusterStatus.AgentPoolProfiles = append(managedClusterStatus.AgentPoolProfiles, item1)
		}
	}

	// Set property ‘ApiServerAccessProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ApiServerAccessProfile != nil {
			var apiServerAccessProfile1 ManagedClusterAPIServerAccessProfile_Status
			err := apiServerAccessProfile1.PopulateFromARM(owner, *typedInput.Properties.ApiServerAccessProfile)
			if err != nil {
				return err
			}
			apiServerAccessProfile := apiServerAccessProfile1
			managedClusterStatus.ApiServerAccessProfile = &apiServerAccessProfile
		}
	}

	// Set property ‘AutoScalerProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AutoScalerProfile != nil {
			var autoScalerProfile1 ManagedClusterProperties_Status_AutoScalerProfile
			err := autoScalerProfile1.PopulateFromARM(owner, *typedInput.Properties.AutoScalerProfile)
			if err != nil {
				return err
			}
			autoScalerProfile := autoScalerProfile1
			managedClusterStatus.AutoScalerProfile = &autoScalerProfile
		}
	}

	// Set property ‘AutoUpgradeProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AutoUpgradeProfile != nil {
			var autoUpgradeProfile1 ManagedClusterAutoUpgradeProfile_Status
			err := autoUpgradeProfile1.PopulateFromARM(owner, *typedInput.Properties.AutoUpgradeProfile)
			if err != nil {
				return err
			}
			autoUpgradeProfile := autoUpgradeProfile1
			managedClusterStatus.AutoUpgradeProfile = &autoUpgradeProfile
		}
	}

	// Set property ‘AzurePortalFQDN’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AzurePortalFQDN != nil {
			azurePortalFQDN := *typedInput.Properties.AzurePortalFQDN
			managedClusterStatus.AzurePortalFQDN = &azurePortalFQDN
		}
	}

	// no assignment for property ‘Conditions’

	// Set property ‘DisableLocalAccounts’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DisableLocalAccounts != nil {
			disableLocalAccounts := *typedInput.Properties.DisableLocalAccounts
			managedClusterStatus.DisableLocalAccounts = &disableLocalAccounts
		}
	}

	// Set property ‘DiskEncryptionSetID’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DiskEncryptionSetID != nil {
			diskEncryptionSetID := *typedInput.Properties.DiskEncryptionSetID
			managedClusterStatus.DiskEncryptionSetID = &diskEncryptionSetID
		}
	}

	// Set property ‘DnsPrefix’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsPrefix != nil {
			dnsPrefix := *typedInput.Properties.DnsPrefix
			managedClusterStatus.DnsPrefix = &dnsPrefix
		}
	}

	// Set property ‘EnablePodSecurityPolicy’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnablePodSecurityPolicy != nil {
			enablePodSecurityPolicy := *typedInput.Properties.EnablePodSecurityPolicy
			managedClusterStatus.EnablePodSecurityPolicy = &enablePodSecurityPolicy
		}
	}

	// Set property ‘EnableRBAC’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableRBAC != nil {
			enableRBAC := *typedInput.Properties.EnableRBAC
			managedClusterStatus.EnableRBAC = &enableRBAC
		}
	}

	// Set property ‘ExtendedLocation’:
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation_Status
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		managedClusterStatus.ExtendedLocation = &extendedLocation
	}

	// Set property ‘Fqdn’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Fqdn != nil {
			fqdn := *typedInput.Properties.Fqdn
			managedClusterStatus.Fqdn = &fqdn
		}
	}

	// Set property ‘FqdnSubdomain’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FqdnSubdomain != nil {
			fqdnSubdomain := *typedInput.Properties.FqdnSubdomain
			managedClusterStatus.FqdnSubdomain = &fqdnSubdomain
		}
	}

	// Set property ‘HttpProxyConfig’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HttpProxyConfig != nil {
			var httpProxyConfig1 ManagedClusterHTTPProxyConfig_Status
			err := httpProxyConfig1.PopulateFromARM(owner, *typedInput.Properties.HttpProxyConfig)
			if err != nil {
				return err
			}
			httpProxyConfig := httpProxyConfig1
			managedClusterStatus.HttpProxyConfig = &httpProxyConfig
		}
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		managedClusterStatus.Id = &id
	}

	// Set property ‘Identity’:
	if typedInput.Identity != nil {
		var identity1 ManagedClusterIdentity_Status
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		managedClusterStatus.Identity = &identity
	}

	// Set property ‘IdentityProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdentityProfile != nil {
			identityProfile := *(*typedInput.Properties.IdentityProfile).DeepCopy()
			managedClusterStatus.IdentityProfile = &identityProfile
		}
	}

	// Set property ‘KubernetesVersion’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.KubernetesVersion != nil {
			kubernetesVersion := *typedInput.Properties.KubernetesVersion
			managedClusterStatus.KubernetesVersion = &kubernetesVersion
		}
	}

	// Set property ‘LinuxProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LinuxProfile != nil {
			var linuxProfile1 ContainerServiceLinuxProfile_Status
			err := linuxProfile1.PopulateFromARM(owner, *typedInput.Properties.LinuxProfile)
			if err != nil {
				return err
			}
			linuxProfile := linuxProfile1
			managedClusterStatus.LinuxProfile = &linuxProfile
		}
	}

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		managedClusterStatus.Location = &location
	}

	// Set property ‘MaxAgentPools’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MaxAgentPools != nil {
			maxAgentPools := *typedInput.Properties.MaxAgentPools
			managedClusterStatus.MaxAgentPools = &maxAgentPools
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		managedClusterStatus.Name = &name
	}

	// Set property ‘NetworkProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NetworkProfile != nil {
			var networkProfile1 ContainerServiceNetworkProfile_Status
			err := networkProfile1.PopulateFromARM(owner, *typedInput.Properties.NetworkProfile)
			if err != nil {
				return err
			}
			networkProfile := networkProfile1
			managedClusterStatus.NetworkProfile = &networkProfile
		}
	}

	// Set property ‘NodeResourceGroup’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NodeResourceGroup != nil {
			nodeResourceGroup := *typedInput.Properties.NodeResourceGroup
			managedClusterStatus.NodeResourceGroup = &nodeResourceGroup
		}
	}

	// Set property ‘PodIdentityProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PodIdentityProfile != nil {
			var podIdentityProfile1 ManagedClusterPodIdentityProfile_Status
			err := podIdentityProfile1.PopulateFromARM(owner, *typedInput.Properties.PodIdentityProfile)
			if err != nil {
				return err
			}
			podIdentityProfile := podIdentityProfile1
			managedClusterStatus.PodIdentityProfile = &podIdentityProfile
		}
	}

	// Set property ‘PowerState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PowerState != nil {
			var powerState1 PowerState_Status
			err := powerState1.PopulateFromARM(owner, *typedInput.Properties.PowerState)
			if err != nil {
				return err
			}
			powerState := powerState1
			managedClusterStatus.PowerState = &powerState
		}
	}

	// Set property ‘PrivateFQDN’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateFQDN != nil {
			privateFQDN := *typedInput.Properties.PrivateFQDN
			managedClusterStatus.PrivateFQDN = &privateFQDN
		}
	}

	// Set property ‘PrivateLinkResources’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.PrivateLinkResources {
			var item1 PrivateLinkResource_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			managedClusterStatus.PrivateLinkResources = append(managedClusterStatus.PrivateLinkResources, item1)
		}
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			managedClusterStatus.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘ServicePrincipalProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ServicePrincipalProfile != nil {
			var servicePrincipalProfile1 ManagedClusterServicePrincipalProfile_Status
			err := servicePrincipalProfile1.PopulateFromARM(owner, *typedInput.Properties.ServicePrincipalProfile)
			if err != nil {
				return err
			}
			servicePrincipalProfile := servicePrincipalProfile1
			managedClusterStatus.ServicePrincipalProfile = &servicePrincipalProfile
		}
	}

	// Set property ‘Sku’:
	if typedInput.Sku != nil {
		var sku1 ManagedClusterSKU_Status
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		managedClusterStatus.Sku = &sku
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		managedClusterStatus.Tags = make(map[string]string)
		for key, value := range typedInput.Tags {
			managedClusterStatus.Tags[key] = value
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		managedClusterStatus.Type = &typeVar
	}

	// Set property ‘WindowsProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.WindowsProfile != nil {
			var windowsProfile1 ManagedClusterWindowsProfile_Status
			err := windowsProfile1.PopulateFromARM(owner, *typedInput.Properties.WindowsProfile)
			if err != nil {
				return err
			}
			windowsProfile := windowsProfile1
			managedClusterStatus.WindowsProfile = &windowsProfile
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterStatus populates our ManagedCluster_Status from the provided source ManagedCluster_Status
func (managedClusterStatus *ManagedCluster_Status) AssignPropertiesFromManagedClusterStatus(source *v1alpha1api20210501storage.ManagedCluster_Status) error {

	// AadProfile
	if source.AadProfile != nil {
		var aadProfile ManagedClusterAADProfile_Status
		err := aadProfile.AssignPropertiesFromManagedClusterAADProfileStatus(source.AadProfile)
		if err != nil {
			return errors.Wrap(err, "populating AadProfile from AadProfile, calling AssignPropertiesFromManagedClusterAADProfileStatus()")
		}
		managedClusterStatus.AadProfile = &aadProfile
	} else {
		managedClusterStatus.AadProfile = nil
	}

	// AddonProfiles
	if source.AddonProfiles != nil {
		addonProfile := *source.AddonProfiles.DeepCopy()
		managedClusterStatus.AddonProfiles = &addonProfile
	} else {
		managedClusterStatus.AddonProfiles = nil
	}

	// AgentPoolProfiles
	agentPoolProfileList := make([]ManagedClusterAgentPoolProfile_Status, len(source.AgentPoolProfiles))
	for agentPoolProfileIndex, agentPoolProfileItem := range source.AgentPoolProfiles {
		// Shadow the loop variable to avoid aliasing
		agentPoolProfileItem := agentPoolProfileItem
		var agentPoolProfile ManagedClusterAgentPoolProfile_Status
		err := agentPoolProfile.AssignPropertiesFromManagedClusterAgentPoolProfileStatus(&agentPoolProfileItem)
		if err != nil {
			return errors.Wrap(err, "populating AgentPoolProfiles from AgentPoolProfiles, calling AssignPropertiesFromManagedClusterAgentPoolProfileStatus()")
		}
		agentPoolProfileList[agentPoolProfileIndex] = agentPoolProfile
	}
	managedClusterStatus.AgentPoolProfiles = agentPoolProfileList

	// ApiServerAccessProfile
	if source.ApiServerAccessProfile != nil {
		var apiServerAccessProfile ManagedClusterAPIServerAccessProfile_Status
		err := apiServerAccessProfile.AssignPropertiesFromManagedClusterAPIServerAccessProfileStatus(source.ApiServerAccessProfile)
		if err != nil {
			return errors.Wrap(err, "populating ApiServerAccessProfile from ApiServerAccessProfile, calling AssignPropertiesFromManagedClusterAPIServerAccessProfileStatus()")
		}
		managedClusterStatus.ApiServerAccessProfile = &apiServerAccessProfile
	} else {
		managedClusterStatus.ApiServerAccessProfile = nil
	}

	// AutoScalerProfile
	if source.AutoScalerProfile != nil {
		var autoScalerProfile ManagedClusterProperties_Status_AutoScalerProfile
		err := autoScalerProfile.AssignPropertiesFromManagedClusterPropertiesStatusAutoScalerProfile(source.AutoScalerProfile)
		if err != nil {
			return errors.Wrap(err, "populating AutoScalerProfile from AutoScalerProfile, calling AssignPropertiesFromManagedClusterPropertiesStatusAutoScalerProfile()")
		}
		managedClusterStatus.AutoScalerProfile = &autoScalerProfile
	} else {
		managedClusterStatus.AutoScalerProfile = nil
	}

	// AutoUpgradeProfile
	if source.AutoUpgradeProfile != nil {
		var autoUpgradeProfile ManagedClusterAutoUpgradeProfile_Status
		err := autoUpgradeProfile.AssignPropertiesFromManagedClusterAutoUpgradeProfileStatus(source.AutoUpgradeProfile)
		if err != nil {
			return errors.Wrap(err, "populating AutoUpgradeProfile from AutoUpgradeProfile, calling AssignPropertiesFromManagedClusterAutoUpgradeProfileStatus()")
		}
		managedClusterStatus.AutoUpgradeProfile = &autoUpgradeProfile
	} else {
		managedClusterStatus.AutoUpgradeProfile = nil
	}

	// AzurePortalFQDN
	if source.AzurePortalFQDN != nil {
		azurePortalFQDN := *source.AzurePortalFQDN
		managedClusterStatus.AzurePortalFQDN = &azurePortalFQDN
	} else {
		managedClusterStatus.AzurePortalFQDN = nil
	}

	// Conditions
	conditionList := make([]conditions.Condition, len(source.Conditions))
	for conditionIndex, conditionItem := range source.Conditions {
		// Shadow the loop variable to avoid aliasing
		conditionItem := conditionItem
		conditionList[conditionIndex] = conditionItem.Copy()
	}
	managedClusterStatus.Conditions = conditionList

	// DisableLocalAccounts
	if source.DisableLocalAccounts != nil {
		disableLocalAccount := *source.DisableLocalAccounts
		managedClusterStatus.DisableLocalAccounts = &disableLocalAccount
	} else {
		managedClusterStatus.DisableLocalAccounts = nil
	}

	// DiskEncryptionSetID
	if source.DiskEncryptionSetID != nil {
		diskEncryptionSetID := *source.DiskEncryptionSetID
		managedClusterStatus.DiskEncryptionSetID = &diskEncryptionSetID
	} else {
		managedClusterStatus.DiskEncryptionSetID = nil
	}

	// DnsPrefix
	if source.DnsPrefix != nil {
		dnsPrefix := *source.DnsPrefix
		managedClusterStatus.DnsPrefix = &dnsPrefix
	} else {
		managedClusterStatus.DnsPrefix = nil
	}

	// EnablePodSecurityPolicy
	if source.EnablePodSecurityPolicy != nil {
		enablePodSecurityPolicy := *source.EnablePodSecurityPolicy
		managedClusterStatus.EnablePodSecurityPolicy = &enablePodSecurityPolicy
	} else {
		managedClusterStatus.EnablePodSecurityPolicy = nil
	}

	// EnableRBAC
	if source.EnableRBAC != nil {
		enableRBAC := *source.EnableRBAC
		managedClusterStatus.EnableRBAC = &enableRBAC
	} else {
		managedClusterStatus.EnableRBAC = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation_Status
		err := extendedLocation.AssignPropertiesFromExtendedLocationStatus(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "populating ExtendedLocation from ExtendedLocation, calling AssignPropertiesFromExtendedLocationStatus()")
		}
		managedClusterStatus.ExtendedLocation = &extendedLocation
	} else {
		managedClusterStatus.ExtendedLocation = nil
	}

	// Fqdn
	if source.Fqdn != nil {
		fqdn := *source.Fqdn
		managedClusterStatus.Fqdn = &fqdn
	} else {
		managedClusterStatus.Fqdn = nil
	}

	// FqdnSubdomain
	if source.FqdnSubdomain != nil {
		fqdnSubdomain := *source.FqdnSubdomain
		managedClusterStatus.FqdnSubdomain = &fqdnSubdomain
	} else {
		managedClusterStatus.FqdnSubdomain = nil
	}

	// HttpProxyConfig
	if source.HttpProxyConfig != nil {
		var httpProxyConfig ManagedClusterHTTPProxyConfig_Status
		err := httpProxyConfig.AssignPropertiesFromManagedClusterHTTPProxyConfigStatus(source.HttpProxyConfig)
		if err != nil {
			return errors.Wrap(err, "populating HttpProxyConfig from HttpProxyConfig, calling AssignPropertiesFromManagedClusterHTTPProxyConfigStatus()")
		}
		managedClusterStatus.HttpProxyConfig = &httpProxyConfig
	} else {
		managedClusterStatus.HttpProxyConfig = nil
	}

	// Id
	if source.Id != nil {
		id := *source.Id
		managedClusterStatus.Id = &id
	} else {
		managedClusterStatus.Id = nil
	}

	// Identity
	if source.Identity != nil {
		var identity ManagedClusterIdentity_Status
		err := identity.AssignPropertiesFromManagedClusterIdentityStatus(source.Identity)
		if err != nil {
			return errors.Wrap(err, "populating Identity from Identity, calling AssignPropertiesFromManagedClusterIdentityStatus()")
		}
		managedClusterStatus.Identity = &identity
	} else {
		managedClusterStatus.Identity = nil
	}

	// IdentityProfile
	if source.IdentityProfile != nil {
		identityProfile := *source.IdentityProfile.DeepCopy()
		managedClusterStatus.IdentityProfile = &identityProfile
	} else {
		managedClusterStatus.IdentityProfile = nil
	}

	// KubernetesVersion
	if source.KubernetesVersion != nil {
		kubernetesVersion := *source.KubernetesVersion
		managedClusterStatus.KubernetesVersion = &kubernetesVersion
	} else {
		managedClusterStatus.KubernetesVersion = nil
	}

	// LinuxProfile
	if source.LinuxProfile != nil {
		var linuxProfile ContainerServiceLinuxProfile_Status
		err := linuxProfile.AssignPropertiesFromContainerServiceLinuxProfileStatus(source.LinuxProfile)
		if err != nil {
			return errors.Wrap(err, "populating LinuxProfile from LinuxProfile, calling AssignPropertiesFromContainerServiceLinuxProfileStatus()")
		}
		managedClusterStatus.LinuxProfile = &linuxProfile
	} else {
		managedClusterStatus.LinuxProfile = nil
	}

	// Location
	if source.Location != nil {
		location := *source.Location
		managedClusterStatus.Location = &location
	} else {
		managedClusterStatus.Location = nil
	}

	// MaxAgentPools
	if source.MaxAgentPools != nil {
		maxAgentPool := *source.MaxAgentPools
		managedClusterStatus.MaxAgentPools = &maxAgentPool
	} else {
		managedClusterStatus.MaxAgentPools = nil
	}

	// Name
	if source.Name != nil {
		name := *source.Name
		managedClusterStatus.Name = &name
	} else {
		managedClusterStatus.Name = nil
	}

	// NetworkProfile
	if source.NetworkProfile != nil {
		var networkProfile ContainerServiceNetworkProfile_Status
		err := networkProfile.AssignPropertiesFromContainerServiceNetworkProfileStatus(source.NetworkProfile)
		if err != nil {
			return errors.Wrap(err, "populating NetworkProfile from NetworkProfile, calling AssignPropertiesFromContainerServiceNetworkProfileStatus()")
		}
		managedClusterStatus.NetworkProfile = &networkProfile
	} else {
		managedClusterStatus.NetworkProfile = nil
	}

	// NodeResourceGroup
	if source.NodeResourceGroup != nil {
		nodeResourceGroup := *source.NodeResourceGroup
		managedClusterStatus.NodeResourceGroup = &nodeResourceGroup
	} else {
		managedClusterStatus.NodeResourceGroup = nil
	}

	// PodIdentityProfile
	if source.PodIdentityProfile != nil {
		var podIdentityProfile ManagedClusterPodIdentityProfile_Status
		err := podIdentityProfile.AssignPropertiesFromManagedClusterPodIdentityProfileStatus(source.PodIdentityProfile)
		if err != nil {
			return errors.Wrap(err, "populating PodIdentityProfile from PodIdentityProfile, calling AssignPropertiesFromManagedClusterPodIdentityProfileStatus()")
		}
		managedClusterStatus.PodIdentityProfile = &podIdentityProfile
	} else {
		managedClusterStatus.PodIdentityProfile = nil
	}

	// PowerState
	if source.PowerState != nil {
		var powerState PowerState_Status
		err := powerState.AssignPropertiesFromPowerStateStatus(source.PowerState)
		if err != nil {
			return errors.Wrap(err, "populating PowerState from PowerState, calling AssignPropertiesFromPowerStateStatus()")
		}
		managedClusterStatus.PowerState = &powerState
	} else {
		managedClusterStatus.PowerState = nil
	}

	// PrivateFQDN
	if source.PrivateFQDN != nil {
		privateFQDN := *source.PrivateFQDN
		managedClusterStatus.PrivateFQDN = &privateFQDN
	} else {
		managedClusterStatus.PrivateFQDN = nil
	}

	// PrivateLinkResources
	privateLinkResourceList := make([]PrivateLinkResource_Status, len(source.PrivateLinkResources))
	for privateLinkResourceIndex, privateLinkResourceItem := range source.PrivateLinkResources {
		// Shadow the loop variable to avoid aliasing
		privateLinkResourceItem := privateLinkResourceItem
		var privateLinkResource PrivateLinkResource_Status
		err := privateLinkResource.AssignPropertiesFromPrivateLinkResourceStatus(&privateLinkResourceItem)
		if err != nil {
			return errors.Wrap(err, "populating PrivateLinkResources from PrivateLinkResources, calling AssignPropertiesFromPrivateLinkResourceStatus()")
		}
		privateLinkResourceList[privateLinkResourceIndex] = privateLinkResource
	}
	managedClusterStatus.PrivateLinkResources = privateLinkResourceList

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		managedClusterStatus.ProvisioningState = &provisioningState
	} else {
		managedClusterStatus.ProvisioningState = nil
	}

	// ServicePrincipalProfile
	if source.ServicePrincipalProfile != nil {
		var servicePrincipalProfile ManagedClusterServicePrincipalProfile_Status
		err := servicePrincipalProfile.AssignPropertiesFromManagedClusterServicePrincipalProfileStatus(source.ServicePrincipalProfile)
		if err != nil {
			return errors.Wrap(err, "populating ServicePrincipalProfile from ServicePrincipalProfile, calling AssignPropertiesFromManagedClusterServicePrincipalProfileStatus()")
		}
		managedClusterStatus.ServicePrincipalProfile = &servicePrincipalProfile
	} else {
		managedClusterStatus.ServicePrincipalProfile = nil
	}

	// Sku
	if source.Sku != nil {
		var sku ManagedClusterSKU_Status
		err := sku.AssignPropertiesFromManagedClusterSKUStatus(source.Sku)
		if err != nil {
			return errors.Wrap(err, "populating Sku from Sku, calling AssignPropertiesFromManagedClusterSKUStatus()")
		}
		managedClusterStatus.Sku = &sku
	} else {
		managedClusterStatus.Sku = nil
	}

	// Tags
	tagMap := make(map[string]string)
	for tagKey, tagValue := range source.Tags {
		// Shadow the loop variable to avoid aliasing
		tagValue := tagValue
		tagMap[tagKey] = tagValue
	}
	managedClusterStatus.Tags = tagMap

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		managedClusterStatus.Type = &typeVar
	} else {
		managedClusterStatus.Type = nil
	}

	// WindowsProfile
	if source.WindowsProfile != nil {
		var windowsProfile ManagedClusterWindowsProfile_Status
		err := windowsProfile.AssignPropertiesFromManagedClusterWindowsProfileStatus(source.WindowsProfile)
		if err != nil {
			return errors.Wrap(err, "populating WindowsProfile from WindowsProfile, calling AssignPropertiesFromManagedClusterWindowsProfileStatus()")
		}
		managedClusterStatus.WindowsProfile = &windowsProfile
	} else {
		managedClusterStatus.WindowsProfile = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterStatus populates the provided destination ManagedCluster_Status from our ManagedCluster_Status
func (managedClusterStatus *ManagedCluster_Status) AssignPropertiesToManagedClusterStatus(destination *v1alpha1api20210501storage.ManagedCluster_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AadProfile
	if managedClusterStatus.AadProfile != nil {
		var aadProfile v1alpha1api20210501storage.ManagedClusterAADProfile_Status
		err := (*managedClusterStatus.AadProfile).AssignPropertiesToManagedClusterAADProfileStatus(&aadProfile)
		if err != nil {
			return errors.Wrap(err, "populating AadProfile from AadProfile, calling AssignPropertiesToManagedClusterAADProfileStatus()")
		}
		destination.AadProfile = &aadProfile
	} else {
		destination.AadProfile = nil
	}

	// AddonProfiles
	if managedClusterStatus.AddonProfiles != nil {
		addonProfile := *managedClusterStatus.AddonProfiles.DeepCopy()
		destination.AddonProfiles = &addonProfile
	} else {
		destination.AddonProfiles = nil
	}

	// AgentPoolProfiles
	agentPoolProfileList := make([]v1alpha1api20210501storage.ManagedClusterAgentPoolProfile_Status, len(managedClusterStatus.AgentPoolProfiles))
	for agentPoolProfileIndex, agentPoolProfileItem := range managedClusterStatus.AgentPoolProfiles {
		// Shadow the loop variable to avoid aliasing
		agentPoolProfileItem := agentPoolProfileItem
		var agentPoolProfile v1alpha1api20210501storage.ManagedClusterAgentPoolProfile_Status
		err := agentPoolProfileItem.AssignPropertiesToManagedClusterAgentPoolProfileStatus(&agentPoolProfile)
		if err != nil {
			return errors.Wrap(err, "populating AgentPoolProfiles from AgentPoolProfiles, calling AssignPropertiesToManagedClusterAgentPoolProfileStatus()")
		}
		agentPoolProfileList[agentPoolProfileIndex] = agentPoolProfile
	}
	destination.AgentPoolProfiles = agentPoolProfileList

	// ApiServerAccessProfile
	if managedClusterStatus.ApiServerAccessProfile != nil {
		var apiServerAccessProfile v1alpha1api20210501storage.ManagedClusterAPIServerAccessProfile_Status
		err := (*managedClusterStatus.ApiServerAccessProfile).AssignPropertiesToManagedClusterAPIServerAccessProfileStatus(&apiServerAccessProfile)
		if err != nil {
			return errors.Wrap(err, "populating ApiServerAccessProfile from ApiServerAccessProfile, calling AssignPropertiesToManagedClusterAPIServerAccessProfileStatus()")
		}
		destination.ApiServerAccessProfile = &apiServerAccessProfile
	} else {
		destination.ApiServerAccessProfile = nil
	}

	// AutoScalerProfile
	if managedClusterStatus.AutoScalerProfile != nil {
		var autoScalerProfile v1alpha1api20210501storage.ManagedClusterProperties_Status_AutoScalerProfile
		err := (*managedClusterStatus.AutoScalerProfile).AssignPropertiesToManagedClusterPropertiesStatusAutoScalerProfile(&autoScalerProfile)
		if err != nil {
			return errors.Wrap(err, "populating AutoScalerProfile from AutoScalerProfile, calling AssignPropertiesToManagedClusterPropertiesStatusAutoScalerProfile()")
		}
		destination.AutoScalerProfile = &autoScalerProfile
	} else {
		destination.AutoScalerProfile = nil
	}

	// AutoUpgradeProfile
	if managedClusterStatus.AutoUpgradeProfile != nil {
		var autoUpgradeProfile v1alpha1api20210501storage.ManagedClusterAutoUpgradeProfile_Status
		err := (*managedClusterStatus.AutoUpgradeProfile).AssignPropertiesToManagedClusterAutoUpgradeProfileStatus(&autoUpgradeProfile)
		if err != nil {
			return errors.Wrap(err, "populating AutoUpgradeProfile from AutoUpgradeProfile, calling AssignPropertiesToManagedClusterAutoUpgradeProfileStatus()")
		}
		destination.AutoUpgradeProfile = &autoUpgradeProfile
	} else {
		destination.AutoUpgradeProfile = nil
	}

	// AzurePortalFQDN
	if managedClusterStatus.AzurePortalFQDN != nil {
		azurePortalFQDN := *managedClusterStatus.AzurePortalFQDN
		destination.AzurePortalFQDN = &azurePortalFQDN
	} else {
		destination.AzurePortalFQDN = nil
	}

	// Conditions
	conditionList := make([]conditions.Condition, len(managedClusterStatus.Conditions))
	for conditionIndex, conditionItem := range managedClusterStatus.Conditions {
		// Shadow the loop variable to avoid aliasing
		conditionItem := conditionItem
		conditionList[conditionIndex] = conditionItem.Copy()
	}
	destination.Conditions = conditionList

	// DisableLocalAccounts
	if managedClusterStatus.DisableLocalAccounts != nil {
		disableLocalAccount := *managedClusterStatus.DisableLocalAccounts
		destination.DisableLocalAccounts = &disableLocalAccount
	} else {
		destination.DisableLocalAccounts = nil
	}

	// DiskEncryptionSetID
	if managedClusterStatus.DiskEncryptionSetID != nil {
		diskEncryptionSetID := *managedClusterStatus.DiskEncryptionSetID
		destination.DiskEncryptionSetID = &diskEncryptionSetID
	} else {
		destination.DiskEncryptionSetID = nil
	}

	// DnsPrefix
	if managedClusterStatus.DnsPrefix != nil {
		dnsPrefix := *managedClusterStatus.DnsPrefix
		destination.DnsPrefix = &dnsPrefix
	} else {
		destination.DnsPrefix = nil
	}

	// EnablePodSecurityPolicy
	if managedClusterStatus.EnablePodSecurityPolicy != nil {
		enablePodSecurityPolicy := *managedClusterStatus.EnablePodSecurityPolicy
		destination.EnablePodSecurityPolicy = &enablePodSecurityPolicy
	} else {
		destination.EnablePodSecurityPolicy = nil
	}

	// EnableRBAC
	if managedClusterStatus.EnableRBAC != nil {
		enableRBAC := *managedClusterStatus.EnableRBAC
		destination.EnableRBAC = &enableRBAC
	} else {
		destination.EnableRBAC = nil
	}

	// ExtendedLocation
	if managedClusterStatus.ExtendedLocation != nil {
		var extendedLocation v1alpha1api20210501storage.ExtendedLocation_Status
		err := (*managedClusterStatus.ExtendedLocation).AssignPropertiesToExtendedLocationStatus(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "populating ExtendedLocation from ExtendedLocation, calling AssignPropertiesToExtendedLocationStatus()")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// Fqdn
	if managedClusterStatus.Fqdn != nil {
		fqdn := *managedClusterStatus.Fqdn
		destination.Fqdn = &fqdn
	} else {
		destination.Fqdn = nil
	}

	// FqdnSubdomain
	if managedClusterStatus.FqdnSubdomain != nil {
		fqdnSubdomain := *managedClusterStatus.FqdnSubdomain
		destination.FqdnSubdomain = &fqdnSubdomain
	} else {
		destination.FqdnSubdomain = nil
	}

	// HttpProxyConfig
	if managedClusterStatus.HttpProxyConfig != nil {
		var httpProxyConfig v1alpha1api20210501storage.ManagedClusterHTTPProxyConfig_Status
		err := (*managedClusterStatus.HttpProxyConfig).AssignPropertiesToManagedClusterHTTPProxyConfigStatus(&httpProxyConfig)
		if err != nil {
			return errors.Wrap(err, "populating HttpProxyConfig from HttpProxyConfig, calling AssignPropertiesToManagedClusterHTTPProxyConfigStatus()")
		}
		destination.HttpProxyConfig = &httpProxyConfig
	} else {
		destination.HttpProxyConfig = nil
	}

	// Id
	if managedClusterStatus.Id != nil {
		id := *managedClusterStatus.Id
		destination.Id = &id
	} else {
		destination.Id = nil
	}

	// Identity
	if managedClusterStatus.Identity != nil {
		var identity v1alpha1api20210501storage.ManagedClusterIdentity_Status
		err := (*managedClusterStatus.Identity).AssignPropertiesToManagedClusterIdentityStatus(&identity)
		if err != nil {
			return errors.Wrap(err, "populating Identity from Identity, calling AssignPropertiesToManagedClusterIdentityStatus()")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// IdentityProfile
	if managedClusterStatus.IdentityProfile != nil {
		identityProfile := *managedClusterStatus.IdentityProfile.DeepCopy()
		destination.IdentityProfile = &identityProfile
	} else {
		destination.IdentityProfile = nil
	}

	// KubernetesVersion
	if managedClusterStatus.KubernetesVersion != nil {
		kubernetesVersion := *managedClusterStatus.KubernetesVersion
		destination.KubernetesVersion = &kubernetesVersion
	} else {
		destination.KubernetesVersion = nil
	}

	// LinuxProfile
	if managedClusterStatus.LinuxProfile != nil {
		var linuxProfile v1alpha1api20210501storage.ContainerServiceLinuxProfile_Status
		err := (*managedClusterStatus.LinuxProfile).AssignPropertiesToContainerServiceLinuxProfileStatus(&linuxProfile)
		if err != nil {
			return errors.Wrap(err, "populating LinuxProfile from LinuxProfile, calling AssignPropertiesToContainerServiceLinuxProfileStatus()")
		}
		destination.LinuxProfile = &linuxProfile
	} else {
		destination.LinuxProfile = nil
	}

	// Location
	if managedClusterStatus.Location != nil {
		location := *managedClusterStatus.Location
		destination.Location = &location
	} else {
		destination.Location = nil
	}

	// MaxAgentPools
	if managedClusterStatus.MaxAgentPools != nil {
		maxAgentPool := *managedClusterStatus.MaxAgentPools
		destination.MaxAgentPools = &maxAgentPool
	} else {
		destination.MaxAgentPools = nil
	}

	// Name
	if managedClusterStatus.Name != nil {
		name := *managedClusterStatus.Name
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// NetworkProfile
	if managedClusterStatus.NetworkProfile != nil {
		var networkProfile v1alpha1api20210501storage.ContainerServiceNetworkProfile_Status
		err := (*managedClusterStatus.NetworkProfile).AssignPropertiesToContainerServiceNetworkProfileStatus(&networkProfile)
		if err != nil {
			return errors.Wrap(err, "populating NetworkProfile from NetworkProfile, calling AssignPropertiesToContainerServiceNetworkProfileStatus()")
		}
		destination.NetworkProfile = &networkProfile
	} else {
		destination.NetworkProfile = nil
	}

	// NodeResourceGroup
	if managedClusterStatus.NodeResourceGroup != nil {
		nodeResourceGroup := *managedClusterStatus.NodeResourceGroup
		destination.NodeResourceGroup = &nodeResourceGroup
	} else {
		destination.NodeResourceGroup = nil
	}

	// PodIdentityProfile
	if managedClusterStatus.PodIdentityProfile != nil {
		var podIdentityProfile v1alpha1api20210501storage.ManagedClusterPodIdentityProfile_Status
		err := (*managedClusterStatus.PodIdentityProfile).AssignPropertiesToManagedClusterPodIdentityProfileStatus(&podIdentityProfile)
		if err != nil {
			return errors.Wrap(err, "populating PodIdentityProfile from PodIdentityProfile, calling AssignPropertiesToManagedClusterPodIdentityProfileStatus()")
		}
		destination.PodIdentityProfile = &podIdentityProfile
	} else {
		destination.PodIdentityProfile = nil
	}

	// PowerState
	if managedClusterStatus.PowerState != nil {
		var powerState v1alpha1api20210501storage.PowerState_Status
		err := (*managedClusterStatus.PowerState).AssignPropertiesToPowerStateStatus(&powerState)
		if err != nil {
			return errors.Wrap(err, "populating PowerState from PowerState, calling AssignPropertiesToPowerStateStatus()")
		}
		destination.PowerState = &powerState
	} else {
		destination.PowerState = nil
	}

	// PrivateFQDN
	if managedClusterStatus.PrivateFQDN != nil {
		privateFQDN := *managedClusterStatus.PrivateFQDN
		destination.PrivateFQDN = &privateFQDN
	} else {
		destination.PrivateFQDN = nil
	}

	// PrivateLinkResources
	privateLinkResourceList := make([]v1alpha1api20210501storage.PrivateLinkResource_Status, len(managedClusterStatus.PrivateLinkResources))
	for privateLinkResourceIndex, privateLinkResourceItem := range managedClusterStatus.PrivateLinkResources {
		// Shadow the loop variable to avoid aliasing
		privateLinkResourceItem := privateLinkResourceItem
		var privateLinkResource v1alpha1api20210501storage.PrivateLinkResource_Status
		err := privateLinkResourceItem.AssignPropertiesToPrivateLinkResourceStatus(&privateLinkResource)
		if err != nil {
			return errors.Wrap(err, "populating PrivateLinkResources from PrivateLinkResources, calling AssignPropertiesToPrivateLinkResourceStatus()")
		}
		privateLinkResourceList[privateLinkResourceIndex] = privateLinkResource
	}
	destination.PrivateLinkResources = privateLinkResourceList

	// ProvisioningState
	if managedClusterStatus.ProvisioningState != nil {
		provisioningState := *managedClusterStatus.ProvisioningState
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// ServicePrincipalProfile
	if managedClusterStatus.ServicePrincipalProfile != nil {
		var servicePrincipalProfile v1alpha1api20210501storage.ManagedClusterServicePrincipalProfile_Status
		err := (*managedClusterStatus.ServicePrincipalProfile).AssignPropertiesToManagedClusterServicePrincipalProfileStatus(&servicePrincipalProfile)
		if err != nil {
			return errors.Wrap(err, "populating ServicePrincipalProfile from ServicePrincipalProfile, calling AssignPropertiesToManagedClusterServicePrincipalProfileStatus()")
		}
		destination.ServicePrincipalProfile = &servicePrincipalProfile
	} else {
		destination.ServicePrincipalProfile = nil
	}

	// Sku
	if managedClusterStatus.Sku != nil {
		var sku v1alpha1api20210501storage.ManagedClusterSKU_Status
		err := (*managedClusterStatus.Sku).AssignPropertiesToManagedClusterSKUStatus(&sku)
		if err != nil {
			return errors.Wrap(err, "populating Sku from Sku, calling AssignPropertiesToManagedClusterSKUStatus()")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	tagMap := make(map[string]string)
	for tagKey, tagValue := range managedClusterStatus.Tags {
		// Shadow the loop variable to avoid aliasing
		tagValue := tagValue
		tagMap[tagKey] = tagValue
	}
	destination.Tags = tagMap

	// Type
	if managedClusterStatus.Type != nil {
		typeVar := *managedClusterStatus.Type
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// WindowsProfile
	if managedClusterStatus.WindowsProfile != nil {
		var windowsProfile v1alpha1api20210501storage.ManagedClusterWindowsProfile_Status
		err := (*managedClusterStatus.WindowsProfile).AssignPropertiesToManagedClusterWindowsProfileStatus(&windowsProfile)
		if err != nil {
			return errors.Wrap(err, "populating WindowsProfile from WindowsProfile, calling AssignPropertiesToManagedClusterWindowsProfileStatus()")
		}
		destination.WindowsProfile = &windowsProfile
	} else {
		destination.WindowsProfile = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

type ManagedClusters_Spec struct {
	//AadProfile: For more details see [managed AAD on
	//AKS](https://docs.microsoft.com/azure/aks/managed-aad).
	AadProfile *ManagedClusterAADProfile `json:"aadProfile,omitempty"`

	//AddonProfiles: The profile of managed cluster add-on.
	AddonProfiles map[string]ManagedClusterAddonProfile `json:"addonProfiles,omitempty"`

	//AgentPoolProfiles: The agent pool properties.
	AgentPoolProfiles []ManagedClusterAgentPoolProfile `json:"agentPoolProfiles,omitempty"`

	//ApiServerAccessProfile: Access profile for managed cluster API server.
	ApiServerAccessProfile *ManagedClusterAPIServerAccessProfile `json:"apiServerAccessProfile,omitempty"`

	//AutoScalerProfile: Parameters to be applied to the cluster-autoscaler when
	//enabled
	AutoScalerProfile *ManagedClusterPropertiesAutoScalerProfile `json:"autoScalerProfile,omitempty"`

	//AutoUpgradeProfile: Auto upgrade profile for a managed cluster.
	AutoUpgradeProfile *ManagedClusterAutoUpgradeProfile `json:"autoUpgradeProfile,omitempty"`

	// +kubebuilder:validation:MaxLength=63
	// +kubebuilder:validation:MinLength=1
	// +kubebuilder:validation:Pattern="^[a-zA-Z0-9]$|^[a-zA-Z0-9][-_a-zA-Z0-9]{0,61}[a-zA-Z0-9]$"
	//AzureName: The name of the resource in Azure. This is often the same as the name
	//of the resource in Kubernetes but it doesn't have to be.
	AzureName string `json:"azureName"`

	//DisableLocalAccounts: If set to true, getting static credentials will be
	//disabled for this cluster. This must only be used on Managed Clusters that are
	//AAD enabled. For more details see [disable local
	//accounts](https://docs.microsoft.com/azure/aks/managed-aad#disable-local-accounts-preview).
	DisableLocalAccounts *bool `json:"disableLocalAccounts,omitempty"`

	//DiskEncryptionSetIDReference: This is of the form:
	//'/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/diskEncryptionSets/{encryptionSetName}'
	DiskEncryptionSetIDReference *genruntime.ResourceReference `armReference:"DiskEncryptionSetID" json:"diskEncryptionSetIDReference,omitempty"`

	//DnsPrefix: This cannot be updated once the Managed Cluster has been created.
	DnsPrefix *string `json:"dnsPrefix,omitempty"`

	//EnablePodSecurityPolicy: (DEPRECATING) Whether to enable Kubernetes pod security
	//policy (preview). This feature is set for removal on October 15th, 2020. Learn
	//more at aka.ms/aks/azpodpolicy.
	EnablePodSecurityPolicy *bool `json:"enablePodSecurityPolicy,omitempty"`

	//EnableRBAC: Whether to enable Kubernetes Role-Based Access Control.
	EnableRBAC *bool `json:"enableRBAC,omitempty"`

	//ExtendedLocation: The complex type of the extended location.
	ExtendedLocation *ExtendedLocation `json:"extendedLocation,omitempty"`

	//FqdnSubdomain: This cannot be updated once the Managed Cluster has been created.
	FqdnSubdomain *string `json:"fqdnSubdomain,omitempty"`

	//HttpProxyConfig: Cluster HTTP proxy configuration.
	HttpProxyConfig *ManagedClusterHTTPProxyConfig `json:"httpProxyConfig,omitempty"`

	//Identity: Identity for the managed cluster.
	Identity *ManagedClusterIdentity `json:"identity,omitempty"`

	//IdentityProfile: Identities associated with the cluster.
	IdentityProfile map[string]Componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties `json:"identityProfile,omitempty"`

	//KubernetesVersion: When you upgrade a supported AKS cluster, Kubernetes minor
	//versions cannot be skipped. All upgrades must be performed sequentially by major
	//version number. For example, upgrades between 1.14.x -> 1.15.x or 1.15.x ->
	//1.16.x are allowed, however 1.14.x -> 1.16.x is not allowed. See [upgrading an
	//AKS cluster](https://docs.microsoft.com/azure/aks/upgrade-cluster) for more
	//details.
	KubernetesVersion *string `json:"kubernetesVersion,omitempty"`

	//LinuxProfile: Profile for Linux VMs in the container service cluster.
	LinuxProfile *ContainerServiceLinuxProfile `json:"linuxProfile,omitempty"`

	//Location: Location to deploy resource to
	Location string `json:"location,omitempty"`

	//NetworkProfile: Profile of network configuration.
	NetworkProfile *ContainerServiceNetworkProfile `json:"networkProfile,omitempty"`

	//NodeResourceGroup: The name of the resource group containing agent pool nodes.
	NodeResourceGroup *string `json:"nodeResourceGroup,omitempty"`

	// +kubebuilder:validation:Required
	Owner genruntime.KnownResourceReference `group:"microsoft.resources.azure.com" json:"owner" kind:"ResourceGroup"`

	//PodIdentityProfile: See [use AAD pod
	//identity](https://docs.microsoft.com/azure/aks/use-azure-ad-pod-identity) for
	//more details on pod identity integration.
	PodIdentityProfile *ManagedClusterPodIdentityProfile `json:"podIdentityProfile,omitempty"`

	//PrivateLinkResources: Private link resources associated with the cluster.
	PrivateLinkResources []PrivateLinkResource `json:"privateLinkResources,omitempty"`

	//ServicePrincipalProfile: Information about a service principal identity for the
	//cluster to use for manipulating Azure APIs.
	ServicePrincipalProfile *ManagedClusterServicePrincipalProfile `json:"servicePrincipalProfile,omitempty"`

	//Sku: The SKU of a Managed Cluster.
	Sku *ManagedClusterSKU `json:"sku,omitempty"`

	//Tags: Name-value pairs to add to the resource
	Tags map[string]string `json:"tags,omitempty"`

	//WindowsProfile: Profile for Windows VMs in the managed cluster.
	WindowsProfile *ManagedClusterWindowsProfile `json:"windowsProfile,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusters_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (managedClustersSpec *ManagedClusters_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if managedClustersSpec == nil {
		return nil, nil
	}
	var result ManagedClusters_SpecARM

	// Set property ‘APIVersion’:
	result.APIVersion = ManagedClustersSpecAPIVersion20210501

	// Set property ‘ExtendedLocation’:
	if managedClustersSpec.ExtendedLocation != nil {
		extendedLocationARM, err := (*managedClustersSpec.ExtendedLocation).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		extendedLocation := extendedLocationARM.(ExtendedLocationARM)
		result.ExtendedLocation = &extendedLocation
	}

	// Set property ‘Identity’:
	if managedClustersSpec.Identity != nil {
		identityARM, err := (*managedClustersSpec.Identity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := identityARM.(ManagedClusterIdentityARM)
		result.Identity = &identity
	}

	// Set property ‘Location’:
	result.Location = managedClustersSpec.Location

	// Set property ‘Name’:
	result.Name = resolved.Name

	// Set property ‘Properties’:
	if managedClustersSpec.AadProfile != nil {
		aadProfileARM, err := (*managedClustersSpec.AadProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		aadProfile := aadProfileARM.(ManagedClusterAADProfileARM)
		result.Properties.AadProfile = &aadProfile
	}
	if managedClustersSpec.AddonProfiles != nil {
		result.Properties.AddonProfiles = make(map[string]ManagedClusterAddonProfileARM)
		for key, value := range managedClustersSpec.AddonProfiles {
			valueARM, err := value.ConvertToARM(resolved)
			if err != nil {
				return nil, err
			}
			result.Properties.AddonProfiles[key] = valueARM.(ManagedClusterAddonProfileARM)
		}
	}
	for _, item := range managedClustersSpec.AgentPoolProfiles {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.AgentPoolProfiles = append(result.Properties.AgentPoolProfiles, itemARM.(ManagedClusterAgentPoolProfileARM))
	}
	if managedClustersSpec.ApiServerAccessProfile != nil {
		apiServerAccessProfileARM, err := (*managedClustersSpec.ApiServerAccessProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		apiServerAccessProfile := apiServerAccessProfileARM.(ManagedClusterAPIServerAccessProfileARM)
		result.Properties.ApiServerAccessProfile = &apiServerAccessProfile
	}
	if managedClustersSpec.AutoScalerProfile != nil {
		autoScalerProfileARM, err := (*managedClustersSpec.AutoScalerProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		autoScalerProfile := autoScalerProfileARM.(ManagedClusterPropertiesAutoScalerProfileARM)
		result.Properties.AutoScalerProfile = &autoScalerProfile
	}
	if managedClustersSpec.AutoUpgradeProfile != nil {
		autoUpgradeProfileARM, err := (*managedClustersSpec.AutoUpgradeProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		autoUpgradeProfile := autoUpgradeProfileARM.(ManagedClusterAutoUpgradeProfileARM)
		result.Properties.AutoUpgradeProfile = &autoUpgradeProfile
	}
	if managedClustersSpec.DisableLocalAccounts != nil {
		disableLocalAccounts := *managedClustersSpec.DisableLocalAccounts
		result.Properties.DisableLocalAccounts = &disableLocalAccounts
	}
	if managedClustersSpec.DiskEncryptionSetIDReference != nil {
		diskEncryptionSetIDARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*managedClustersSpec.DiskEncryptionSetIDReference)
		if err != nil {
			return nil, err
		}
		diskEncryptionSetID := diskEncryptionSetIDARMID
		result.Properties.DiskEncryptionSetID = &diskEncryptionSetID
	}
	if managedClustersSpec.DnsPrefix != nil {
		dnsPrefix := *managedClustersSpec.DnsPrefix
		result.Properties.DnsPrefix = &dnsPrefix
	}
	if managedClustersSpec.EnablePodSecurityPolicy != nil {
		enablePodSecurityPolicy := *managedClustersSpec.EnablePodSecurityPolicy
		result.Properties.EnablePodSecurityPolicy = &enablePodSecurityPolicy
	}
	if managedClustersSpec.EnableRBAC != nil {
		enableRBAC := *managedClustersSpec.EnableRBAC
		result.Properties.EnableRBAC = &enableRBAC
	}
	if managedClustersSpec.FqdnSubdomain != nil {
		fqdnSubdomain := *managedClustersSpec.FqdnSubdomain
		result.Properties.FqdnSubdomain = &fqdnSubdomain
	}
	if managedClustersSpec.HttpProxyConfig != nil {
		httpProxyConfigARM, err := (*managedClustersSpec.HttpProxyConfig).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		httpProxyConfig := httpProxyConfigARM.(ManagedClusterHTTPProxyConfigARM)
		result.Properties.HttpProxyConfig = &httpProxyConfig
	}
	if managedClustersSpec.IdentityProfile != nil {
		result.Properties.IdentityProfile = make(map[string]Componentsqit0EtschemasmanagedclusterpropertiespropertiesidentityprofileadditionalpropertiesARM)
		for key, value := range managedClustersSpec.IdentityProfile {
			valueARM, err := value.ConvertToARM(resolved)
			if err != nil {
				return nil, err
			}
			result.Properties.IdentityProfile[key] = valueARM.(Componentsqit0EtschemasmanagedclusterpropertiespropertiesidentityprofileadditionalpropertiesARM)
		}
	}
	if managedClustersSpec.KubernetesVersion != nil {
		kubernetesVersion := *managedClustersSpec.KubernetesVersion
		result.Properties.KubernetesVersion = &kubernetesVersion
	}
	if managedClustersSpec.LinuxProfile != nil {
		linuxProfileARM, err := (*managedClustersSpec.LinuxProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		linuxProfile := linuxProfileARM.(ContainerServiceLinuxProfileARM)
		result.Properties.LinuxProfile = &linuxProfile
	}
	if managedClustersSpec.NetworkProfile != nil {
		networkProfileARM, err := (*managedClustersSpec.NetworkProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		networkProfile := networkProfileARM.(ContainerServiceNetworkProfileARM)
		result.Properties.NetworkProfile = &networkProfile
	}
	if managedClustersSpec.NodeResourceGroup != nil {
		nodeResourceGroup := *managedClustersSpec.NodeResourceGroup
		result.Properties.NodeResourceGroup = &nodeResourceGroup
	}
	if managedClustersSpec.PodIdentityProfile != nil {
		podIdentityProfileARM, err := (*managedClustersSpec.PodIdentityProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		podIdentityProfile := podIdentityProfileARM.(ManagedClusterPodIdentityProfileARM)
		result.Properties.PodIdentityProfile = &podIdentityProfile
	}
	for _, item := range managedClustersSpec.PrivateLinkResources {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.PrivateLinkResources = append(result.Properties.PrivateLinkResources, itemARM.(PrivateLinkResourceARM))
	}
	if managedClustersSpec.ServicePrincipalProfile != nil {
		servicePrincipalProfileARM, err := (*managedClustersSpec.ServicePrincipalProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		servicePrincipalProfile := servicePrincipalProfileARM.(ManagedClusterServicePrincipalProfileARM)
		result.Properties.ServicePrincipalProfile = &servicePrincipalProfile
	}
	if managedClustersSpec.WindowsProfile != nil {
		windowsProfileARM, err := (*managedClustersSpec.WindowsProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		windowsProfile := windowsProfileARM.(ManagedClusterWindowsProfileARM)
		result.Properties.WindowsProfile = &windowsProfile
	}

	// Set property ‘Sku’:
	if managedClustersSpec.Sku != nil {
		skuARM, err := (*managedClustersSpec.Sku).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sku := skuARM.(ManagedClusterSKUARM)
		result.Sku = &sku
	}

	// Set property ‘Tags’:
	if managedClustersSpec.Tags != nil {
		result.Tags = make(map[string]string)
		for key, value := range managedClustersSpec.Tags {
			result.Tags[key] = value
		}
	}

	// Set property ‘Type’:
	result.Type = ManagedClustersSpecTypeMicrosoftContainerServiceManagedClusters
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (managedClustersSpec *ManagedClusters_Spec) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusters_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (managedClustersSpec *ManagedClusters_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusters_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusters_SpecARM, got %T", armInput)
	}

	// Set property ‘AadProfile’:
	// copying flattened property:
	if typedInput.Properties.AadProfile != nil {
		var aadProfile1 ManagedClusterAADProfile
		err := aadProfile1.PopulateFromARM(owner, *typedInput.Properties.AadProfile)
		if err != nil {
			return err
		}
		aadProfile := aadProfile1
		managedClustersSpec.AadProfile = &aadProfile
	}

	// Set property ‘AddonProfiles’:
	// copying flattened property:
	if typedInput.Properties.AddonProfiles != nil {
		managedClustersSpec.AddonProfiles = make(map[string]ManagedClusterAddonProfile)
		for key, value := range typedInput.Properties.AddonProfiles {
			var value1 ManagedClusterAddonProfile
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			managedClustersSpec.AddonProfiles[key] = value1
		}
	}

	// Set property ‘AgentPoolProfiles’:
	// copying flattened property:
	for _, item := range typedInput.Properties.AgentPoolProfiles {
		var item1 ManagedClusterAgentPoolProfile
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		managedClustersSpec.AgentPoolProfiles = append(managedClustersSpec.AgentPoolProfiles, item1)
	}

	// Set property ‘ApiServerAccessProfile’:
	// copying flattened property:
	if typedInput.Properties.ApiServerAccessProfile != nil {
		var apiServerAccessProfile1 ManagedClusterAPIServerAccessProfile
		err := apiServerAccessProfile1.PopulateFromARM(owner, *typedInput.Properties.ApiServerAccessProfile)
		if err != nil {
			return err
		}
		apiServerAccessProfile := apiServerAccessProfile1
		managedClustersSpec.ApiServerAccessProfile = &apiServerAccessProfile
	}

	// Set property ‘AutoScalerProfile’:
	// copying flattened property:
	if typedInput.Properties.AutoScalerProfile != nil {
		var autoScalerProfile1 ManagedClusterPropertiesAutoScalerProfile
		err := autoScalerProfile1.PopulateFromARM(owner, *typedInput.Properties.AutoScalerProfile)
		if err != nil {
			return err
		}
		autoScalerProfile := autoScalerProfile1
		managedClustersSpec.AutoScalerProfile = &autoScalerProfile
	}

	// Set property ‘AutoUpgradeProfile’:
	// copying flattened property:
	if typedInput.Properties.AutoUpgradeProfile != nil {
		var autoUpgradeProfile1 ManagedClusterAutoUpgradeProfile
		err := autoUpgradeProfile1.PopulateFromARM(owner, *typedInput.Properties.AutoUpgradeProfile)
		if err != nil {
			return err
		}
		autoUpgradeProfile := autoUpgradeProfile1
		managedClustersSpec.AutoUpgradeProfile = &autoUpgradeProfile
	}

	// Set property ‘AzureName’:
	managedClustersSpec.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property ‘DisableLocalAccounts’:
	// copying flattened property:
	if typedInput.Properties.DisableLocalAccounts != nil {
		disableLocalAccounts := *typedInput.Properties.DisableLocalAccounts
		managedClustersSpec.DisableLocalAccounts = &disableLocalAccounts
	}

	// no assignment for property ‘DiskEncryptionSetIDReference’

	// Set property ‘DnsPrefix’:
	// copying flattened property:
	if typedInput.Properties.DnsPrefix != nil {
		dnsPrefix := *typedInput.Properties.DnsPrefix
		managedClustersSpec.DnsPrefix = &dnsPrefix
	}

	// Set property ‘EnablePodSecurityPolicy’:
	// copying flattened property:
	if typedInput.Properties.EnablePodSecurityPolicy != nil {
		enablePodSecurityPolicy := *typedInput.Properties.EnablePodSecurityPolicy
		managedClustersSpec.EnablePodSecurityPolicy = &enablePodSecurityPolicy
	}

	// Set property ‘EnableRBAC’:
	// copying flattened property:
	if typedInput.Properties.EnableRBAC != nil {
		enableRBAC := *typedInput.Properties.EnableRBAC
		managedClustersSpec.EnableRBAC = &enableRBAC
	}

	// Set property ‘ExtendedLocation’:
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		managedClustersSpec.ExtendedLocation = &extendedLocation
	}

	// Set property ‘FqdnSubdomain’:
	// copying flattened property:
	if typedInput.Properties.FqdnSubdomain != nil {
		fqdnSubdomain := *typedInput.Properties.FqdnSubdomain
		managedClustersSpec.FqdnSubdomain = &fqdnSubdomain
	}

	// Set property ‘HttpProxyConfig’:
	// copying flattened property:
	if typedInput.Properties.HttpProxyConfig != nil {
		var httpProxyConfig1 ManagedClusterHTTPProxyConfig
		err := httpProxyConfig1.PopulateFromARM(owner, *typedInput.Properties.HttpProxyConfig)
		if err != nil {
			return err
		}
		httpProxyConfig := httpProxyConfig1
		managedClustersSpec.HttpProxyConfig = &httpProxyConfig
	}

	// Set property ‘Identity’:
	if typedInput.Identity != nil {
		var identity1 ManagedClusterIdentity
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		managedClustersSpec.Identity = &identity
	}

	// Set property ‘IdentityProfile’:
	// copying flattened property:
	if typedInput.Properties.IdentityProfile != nil {
		managedClustersSpec.IdentityProfile = make(map[string]Componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties)
		for key, value := range typedInput.Properties.IdentityProfile {
			var value1 Componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			managedClustersSpec.IdentityProfile[key] = value1
		}
	}

	// Set property ‘KubernetesVersion’:
	// copying flattened property:
	if typedInput.Properties.KubernetesVersion != nil {
		kubernetesVersion := *typedInput.Properties.KubernetesVersion
		managedClustersSpec.KubernetesVersion = &kubernetesVersion
	}

	// Set property ‘LinuxProfile’:
	// copying flattened property:
	if typedInput.Properties.LinuxProfile != nil {
		var linuxProfile1 ContainerServiceLinuxProfile
		err := linuxProfile1.PopulateFromARM(owner, *typedInput.Properties.LinuxProfile)
		if err != nil {
			return err
		}
		linuxProfile := linuxProfile1
		managedClustersSpec.LinuxProfile = &linuxProfile
	}

	// Set property ‘Location’:
	managedClustersSpec.Location = typedInput.Location

	// Set property ‘NetworkProfile’:
	// copying flattened property:
	if typedInput.Properties.NetworkProfile != nil {
		var networkProfile1 ContainerServiceNetworkProfile
		err := networkProfile1.PopulateFromARM(owner, *typedInput.Properties.NetworkProfile)
		if err != nil {
			return err
		}
		networkProfile := networkProfile1
		managedClustersSpec.NetworkProfile = &networkProfile
	}

	// Set property ‘NodeResourceGroup’:
	// copying flattened property:
	if typedInput.Properties.NodeResourceGroup != nil {
		nodeResourceGroup := *typedInput.Properties.NodeResourceGroup
		managedClustersSpec.NodeResourceGroup = &nodeResourceGroup
	}

	// Set property ‘Owner’:
	managedClustersSpec.Owner = genruntime.KnownResourceReference{
		Name: owner.Name,
	}

	// Set property ‘PodIdentityProfile’:
	// copying flattened property:
	if typedInput.Properties.PodIdentityProfile != nil {
		var podIdentityProfile1 ManagedClusterPodIdentityProfile
		err := podIdentityProfile1.PopulateFromARM(owner, *typedInput.Properties.PodIdentityProfile)
		if err != nil {
			return err
		}
		podIdentityProfile := podIdentityProfile1
		managedClustersSpec.PodIdentityProfile = &podIdentityProfile
	}

	// Set property ‘PrivateLinkResources’:
	// copying flattened property:
	for _, item := range typedInput.Properties.PrivateLinkResources {
		var item1 PrivateLinkResource
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		managedClustersSpec.PrivateLinkResources = append(managedClustersSpec.PrivateLinkResources, item1)
	}

	// Set property ‘ServicePrincipalProfile’:
	// copying flattened property:
	if typedInput.Properties.ServicePrincipalProfile != nil {
		var servicePrincipalProfile1 ManagedClusterServicePrincipalProfile
		err := servicePrincipalProfile1.PopulateFromARM(owner, *typedInput.Properties.ServicePrincipalProfile)
		if err != nil {
			return err
		}
		servicePrincipalProfile := servicePrincipalProfile1
		managedClustersSpec.ServicePrincipalProfile = &servicePrincipalProfile
	}

	// Set property ‘Sku’:
	if typedInput.Sku != nil {
		var sku1 ManagedClusterSKU
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		managedClustersSpec.Sku = &sku
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		managedClustersSpec.Tags = make(map[string]string)
		for key, value := range typedInput.Tags {
			managedClustersSpec.Tags[key] = value
		}
	}

	// Set property ‘WindowsProfile’:
	// copying flattened property:
	if typedInput.Properties.WindowsProfile != nil {
		var windowsProfile1 ManagedClusterWindowsProfile
		err := windowsProfile1.PopulateFromARM(owner, *typedInput.Properties.WindowsProfile)
		if err != nil {
			return err
		}
		windowsProfile := windowsProfile1
		managedClustersSpec.WindowsProfile = &windowsProfile
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &ManagedClusters_Spec{}

// ConvertSpecFrom populates our ManagedClusters_Spec from the provided source
func (managedClustersSpec *ManagedClusters_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v1alpha1api20210501storage.ManagedClusters_Spec)
	if ok {
		// Populate our instance from source
		return managedClustersSpec.AssignPropertiesFromManagedClustersSpec(src)
	}

	// Convert to an intermediate form
	src = &v1alpha1api20210501storage.ManagedClusters_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = managedClustersSpec.AssignPropertiesFromManagedClustersSpec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our ManagedClusters_Spec
func (managedClustersSpec *ManagedClusters_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v1alpha1api20210501storage.ManagedClusters_Spec)
	if ok {
		// Populate destination from our instance
		return managedClustersSpec.AssignPropertiesToManagedClustersSpec(dst)
	}

	// Convert to an intermediate form
	dst = &v1alpha1api20210501storage.ManagedClusters_Spec{}
	err := managedClustersSpec.AssignPropertiesToManagedClustersSpec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignPropertiesFromManagedClustersSpec populates our ManagedClusters_Spec from the provided source ManagedClusters_Spec
func (managedClustersSpec *ManagedClusters_Spec) AssignPropertiesFromManagedClustersSpec(source *v1alpha1api20210501storage.ManagedClusters_Spec) error {

	// AadProfile
	if source.AadProfile != nil {
		var aadProfile ManagedClusterAADProfile
		err := aadProfile.AssignPropertiesFromManagedClusterAADProfile(source.AadProfile)
		if err != nil {
			return errors.Wrap(err, "populating AadProfile from AadProfile, calling AssignPropertiesFromManagedClusterAADProfile()")
		}
		managedClustersSpec.AadProfile = &aadProfile
	} else {
		managedClustersSpec.AadProfile = nil
	}

	// AddonProfiles
	addonProfileMap := make(map[string]ManagedClusterAddonProfile)
	for addonProfileKey, addonProfileValue := range source.AddonProfiles {
		// Shadow the loop variable to avoid aliasing
		addonProfileValue := addonProfileValue
		var addonProfile ManagedClusterAddonProfile
		err := addonProfile.AssignPropertiesFromManagedClusterAddonProfile(&addonProfileValue)
		if err != nil {
			return errors.Wrap(err, "populating AddonProfiles from AddonProfiles, calling AssignPropertiesFromManagedClusterAddonProfile()")
		}
		addonProfileMap[addonProfileKey] = addonProfile
	}
	managedClustersSpec.AddonProfiles = addonProfileMap

	// AgentPoolProfiles
	agentPoolProfileList := make([]ManagedClusterAgentPoolProfile, len(source.AgentPoolProfiles))
	for agentPoolProfileIndex, agentPoolProfileItem := range source.AgentPoolProfiles {
		// Shadow the loop variable to avoid aliasing
		agentPoolProfileItem := agentPoolProfileItem
		var agentPoolProfile ManagedClusterAgentPoolProfile
		err := agentPoolProfile.AssignPropertiesFromManagedClusterAgentPoolProfile(&agentPoolProfileItem)
		if err != nil {
			return errors.Wrap(err, "populating AgentPoolProfiles from AgentPoolProfiles, calling AssignPropertiesFromManagedClusterAgentPoolProfile()")
		}
		agentPoolProfileList[agentPoolProfileIndex] = agentPoolProfile
	}
	managedClustersSpec.AgentPoolProfiles = agentPoolProfileList

	// ApiServerAccessProfile
	if source.ApiServerAccessProfile != nil {
		var apiServerAccessProfile ManagedClusterAPIServerAccessProfile
		err := apiServerAccessProfile.AssignPropertiesFromManagedClusterAPIServerAccessProfile(source.ApiServerAccessProfile)
		if err != nil {
			return errors.Wrap(err, "populating ApiServerAccessProfile from ApiServerAccessProfile, calling AssignPropertiesFromManagedClusterAPIServerAccessProfile()")
		}
		managedClustersSpec.ApiServerAccessProfile = &apiServerAccessProfile
	} else {
		managedClustersSpec.ApiServerAccessProfile = nil
	}

	// AutoScalerProfile
	if source.AutoScalerProfile != nil {
		var autoScalerProfile ManagedClusterPropertiesAutoScalerProfile
		err := autoScalerProfile.AssignPropertiesFromManagedClusterPropertiesAutoScalerProfile(source.AutoScalerProfile)
		if err != nil {
			return errors.Wrap(err, "populating AutoScalerProfile from AutoScalerProfile, calling AssignPropertiesFromManagedClusterPropertiesAutoScalerProfile()")
		}
		managedClustersSpec.AutoScalerProfile = &autoScalerProfile
	} else {
		managedClustersSpec.AutoScalerProfile = nil
	}

	// AutoUpgradeProfile
	if source.AutoUpgradeProfile != nil {
		var autoUpgradeProfile ManagedClusterAutoUpgradeProfile
		err := autoUpgradeProfile.AssignPropertiesFromManagedClusterAutoUpgradeProfile(source.AutoUpgradeProfile)
		if err != nil {
			return errors.Wrap(err, "populating AutoUpgradeProfile from AutoUpgradeProfile, calling AssignPropertiesFromManagedClusterAutoUpgradeProfile()")
		}
		managedClustersSpec.AutoUpgradeProfile = &autoUpgradeProfile
	} else {
		managedClustersSpec.AutoUpgradeProfile = nil
	}

	// AzureName
	managedClustersSpec.AzureName = source.AzureName

	// DisableLocalAccounts
	if source.DisableLocalAccounts != nil {
		disableLocalAccount := *source.DisableLocalAccounts
		managedClustersSpec.DisableLocalAccounts = &disableLocalAccount
	} else {
		managedClustersSpec.DisableLocalAccounts = nil
	}

	// DiskEncryptionSetIDReference
	if source.DiskEncryptionSetIDReference != nil {
		diskEncryptionSetIDReference := source.DiskEncryptionSetIDReference.Copy()
		managedClustersSpec.DiskEncryptionSetIDReference = &diskEncryptionSetIDReference
	} else {
		managedClustersSpec.DiskEncryptionSetIDReference = nil
	}

	// DnsPrefix
	if source.DnsPrefix != nil {
		dnsPrefix := *source.DnsPrefix
		managedClustersSpec.DnsPrefix = &dnsPrefix
	} else {
		managedClustersSpec.DnsPrefix = nil
	}

	// EnablePodSecurityPolicy
	if source.EnablePodSecurityPolicy != nil {
		enablePodSecurityPolicy := *source.EnablePodSecurityPolicy
		managedClustersSpec.EnablePodSecurityPolicy = &enablePodSecurityPolicy
	} else {
		managedClustersSpec.EnablePodSecurityPolicy = nil
	}

	// EnableRBAC
	if source.EnableRBAC != nil {
		enableRBAC := *source.EnableRBAC
		managedClustersSpec.EnableRBAC = &enableRBAC
	} else {
		managedClustersSpec.EnableRBAC = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation
		err := extendedLocation.AssignPropertiesFromExtendedLocation(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "populating ExtendedLocation from ExtendedLocation, calling AssignPropertiesFromExtendedLocation()")
		}
		managedClustersSpec.ExtendedLocation = &extendedLocation
	} else {
		managedClustersSpec.ExtendedLocation = nil
	}

	// FqdnSubdomain
	if source.FqdnSubdomain != nil {
		fqdnSubdomain := *source.FqdnSubdomain
		managedClustersSpec.FqdnSubdomain = &fqdnSubdomain
	} else {
		managedClustersSpec.FqdnSubdomain = nil
	}

	// HttpProxyConfig
	if source.HttpProxyConfig != nil {
		var httpProxyConfig ManagedClusterHTTPProxyConfig
		err := httpProxyConfig.AssignPropertiesFromManagedClusterHTTPProxyConfig(source.HttpProxyConfig)
		if err != nil {
			return errors.Wrap(err, "populating HttpProxyConfig from HttpProxyConfig, calling AssignPropertiesFromManagedClusterHTTPProxyConfig()")
		}
		managedClustersSpec.HttpProxyConfig = &httpProxyConfig
	} else {
		managedClustersSpec.HttpProxyConfig = nil
	}

	// Identity
	if source.Identity != nil {
		var identity ManagedClusterIdentity
		err := identity.AssignPropertiesFromManagedClusterIdentity(source.Identity)
		if err != nil {
			return errors.Wrap(err, "populating Identity from Identity, calling AssignPropertiesFromManagedClusterIdentity()")
		}
		managedClustersSpec.Identity = &identity
	} else {
		managedClustersSpec.Identity = nil
	}

	// IdentityProfile
	identityProfileMap := make(map[string]Componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties)
	for identityProfileKey, identityProfileValue := range source.IdentityProfile {
		// Shadow the loop variable to avoid aliasing
		identityProfileValue := identityProfileValue
		var identityProfile Componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties
		err := identityProfile.AssignPropertiesFromComponentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties(&identityProfileValue)
		if err != nil {
			return errors.Wrap(err, "populating IdentityProfile from IdentityProfile, calling AssignPropertiesFromComponentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties()")
		}
		identityProfileMap[identityProfileKey] = identityProfile
	}
	managedClustersSpec.IdentityProfile = identityProfileMap

	// KubernetesVersion
	if source.KubernetesVersion != nil {
		kubernetesVersion := *source.KubernetesVersion
		managedClustersSpec.KubernetesVersion = &kubernetesVersion
	} else {
		managedClustersSpec.KubernetesVersion = nil
	}

	// LinuxProfile
	if source.LinuxProfile != nil {
		var linuxProfile ContainerServiceLinuxProfile
		err := linuxProfile.AssignPropertiesFromContainerServiceLinuxProfile(source.LinuxProfile)
		if err != nil {
			return errors.Wrap(err, "populating LinuxProfile from LinuxProfile, calling AssignPropertiesFromContainerServiceLinuxProfile()")
		}
		managedClustersSpec.LinuxProfile = &linuxProfile
	} else {
		managedClustersSpec.LinuxProfile = nil
	}

	// Location
	if source.Location != nil {
		managedClustersSpec.Location = *source.Location
	} else {
		managedClustersSpec.Location = ""
	}

	// NetworkProfile
	if source.NetworkProfile != nil {
		var networkProfile ContainerServiceNetworkProfile
		err := networkProfile.AssignPropertiesFromContainerServiceNetworkProfile(source.NetworkProfile)
		if err != nil {
			return errors.Wrap(err, "populating NetworkProfile from NetworkProfile, calling AssignPropertiesFromContainerServiceNetworkProfile()")
		}
		managedClustersSpec.NetworkProfile = &networkProfile
	} else {
		managedClustersSpec.NetworkProfile = nil
	}

	// NodeResourceGroup
	if source.NodeResourceGroup != nil {
		nodeResourceGroup := *source.NodeResourceGroup
		managedClustersSpec.NodeResourceGroup = &nodeResourceGroup
	} else {
		managedClustersSpec.NodeResourceGroup = nil
	}

	// Owner
	managedClustersSpec.Owner = source.Owner.Copy()

	// PodIdentityProfile
	if source.PodIdentityProfile != nil {
		var podIdentityProfile ManagedClusterPodIdentityProfile
		err := podIdentityProfile.AssignPropertiesFromManagedClusterPodIdentityProfile(source.PodIdentityProfile)
		if err != nil {
			return errors.Wrap(err, "populating PodIdentityProfile from PodIdentityProfile, calling AssignPropertiesFromManagedClusterPodIdentityProfile()")
		}
		managedClustersSpec.PodIdentityProfile = &podIdentityProfile
	} else {
		managedClustersSpec.PodIdentityProfile = nil
	}

	// PrivateLinkResources
	privateLinkResourceList := make([]PrivateLinkResource, len(source.PrivateLinkResources))
	for privateLinkResourceIndex, privateLinkResourceItem := range source.PrivateLinkResources {
		// Shadow the loop variable to avoid aliasing
		privateLinkResourceItem := privateLinkResourceItem
		var privateLinkResource PrivateLinkResource
		err := privateLinkResource.AssignPropertiesFromPrivateLinkResource(&privateLinkResourceItem)
		if err != nil {
			return errors.Wrap(err, "populating PrivateLinkResources from PrivateLinkResources, calling AssignPropertiesFromPrivateLinkResource()")
		}
		privateLinkResourceList[privateLinkResourceIndex] = privateLinkResource
	}
	managedClustersSpec.PrivateLinkResources = privateLinkResourceList

	// ServicePrincipalProfile
	if source.ServicePrincipalProfile != nil {
		var servicePrincipalProfile ManagedClusterServicePrincipalProfile
		err := servicePrincipalProfile.AssignPropertiesFromManagedClusterServicePrincipalProfile(source.ServicePrincipalProfile)
		if err != nil {
			return errors.Wrap(err, "populating ServicePrincipalProfile from ServicePrincipalProfile, calling AssignPropertiesFromManagedClusterServicePrincipalProfile()")
		}
		managedClustersSpec.ServicePrincipalProfile = &servicePrincipalProfile
	} else {
		managedClustersSpec.ServicePrincipalProfile = nil
	}

	// Sku
	if source.Sku != nil {
		var sku ManagedClusterSKU
		err := sku.AssignPropertiesFromManagedClusterSKU(source.Sku)
		if err != nil {
			return errors.Wrap(err, "populating Sku from Sku, calling AssignPropertiesFromManagedClusterSKU()")
		}
		managedClustersSpec.Sku = &sku
	} else {
		managedClustersSpec.Sku = nil
	}

	// Tags
	tagMap := make(map[string]string)
	for tagKey, tagValue := range source.Tags {
		// Shadow the loop variable to avoid aliasing
		tagValue := tagValue
		tagMap[tagKey] = tagValue
	}
	managedClustersSpec.Tags = tagMap

	// WindowsProfile
	if source.WindowsProfile != nil {
		var windowsProfile ManagedClusterWindowsProfile
		err := windowsProfile.AssignPropertiesFromManagedClusterWindowsProfile(source.WindowsProfile)
		if err != nil {
			return errors.Wrap(err, "populating WindowsProfile from WindowsProfile, calling AssignPropertiesFromManagedClusterWindowsProfile()")
		}
		managedClustersSpec.WindowsProfile = &windowsProfile
	} else {
		managedClustersSpec.WindowsProfile = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClustersSpec populates the provided destination ManagedClusters_Spec from our ManagedClusters_Spec
func (managedClustersSpec *ManagedClusters_Spec) AssignPropertiesToManagedClustersSpec(destination *v1alpha1api20210501storage.ManagedClusters_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AadProfile
	if managedClustersSpec.AadProfile != nil {
		var aadProfile v1alpha1api20210501storage.ManagedClusterAADProfile
		err := (*managedClustersSpec.AadProfile).AssignPropertiesToManagedClusterAADProfile(&aadProfile)
		if err != nil {
			return errors.Wrap(err, "populating AadProfile from AadProfile, calling AssignPropertiesToManagedClusterAADProfile()")
		}
		destination.AadProfile = &aadProfile
	} else {
		destination.AadProfile = nil
	}

	// AddonProfiles
	addonProfileMap := make(map[string]v1alpha1api20210501storage.ManagedClusterAddonProfile)
	for addonProfileKey, addonProfileValue := range managedClustersSpec.AddonProfiles {
		// Shadow the loop variable to avoid aliasing
		addonProfileValue := addonProfileValue
		var addonProfile v1alpha1api20210501storage.ManagedClusterAddonProfile
		err := addonProfileValue.AssignPropertiesToManagedClusterAddonProfile(&addonProfile)
		if err != nil {
			return errors.Wrap(err, "populating AddonProfiles from AddonProfiles, calling AssignPropertiesToManagedClusterAddonProfile()")
		}
		addonProfileMap[addonProfileKey] = addonProfile
	}
	destination.AddonProfiles = addonProfileMap

	// AgentPoolProfiles
	agentPoolProfileList := make([]v1alpha1api20210501storage.ManagedClusterAgentPoolProfile, len(managedClustersSpec.AgentPoolProfiles))
	for agentPoolProfileIndex, agentPoolProfileItem := range managedClustersSpec.AgentPoolProfiles {
		// Shadow the loop variable to avoid aliasing
		agentPoolProfileItem := agentPoolProfileItem
		var agentPoolProfile v1alpha1api20210501storage.ManagedClusterAgentPoolProfile
		err := agentPoolProfileItem.AssignPropertiesToManagedClusterAgentPoolProfile(&agentPoolProfile)
		if err != nil {
			return errors.Wrap(err, "populating AgentPoolProfiles from AgentPoolProfiles, calling AssignPropertiesToManagedClusterAgentPoolProfile()")
		}
		agentPoolProfileList[agentPoolProfileIndex] = agentPoolProfile
	}
	destination.AgentPoolProfiles = agentPoolProfileList

	// ApiServerAccessProfile
	if managedClustersSpec.ApiServerAccessProfile != nil {
		var apiServerAccessProfile v1alpha1api20210501storage.ManagedClusterAPIServerAccessProfile
		err := (*managedClustersSpec.ApiServerAccessProfile).AssignPropertiesToManagedClusterAPIServerAccessProfile(&apiServerAccessProfile)
		if err != nil {
			return errors.Wrap(err, "populating ApiServerAccessProfile from ApiServerAccessProfile, calling AssignPropertiesToManagedClusterAPIServerAccessProfile()")
		}
		destination.ApiServerAccessProfile = &apiServerAccessProfile
	} else {
		destination.ApiServerAccessProfile = nil
	}

	// AutoScalerProfile
	if managedClustersSpec.AutoScalerProfile != nil {
		var autoScalerProfile v1alpha1api20210501storage.ManagedClusterPropertiesAutoScalerProfile
		err := (*managedClustersSpec.AutoScalerProfile).AssignPropertiesToManagedClusterPropertiesAutoScalerProfile(&autoScalerProfile)
		if err != nil {
			return errors.Wrap(err, "populating AutoScalerProfile from AutoScalerProfile, calling AssignPropertiesToManagedClusterPropertiesAutoScalerProfile()")
		}
		destination.AutoScalerProfile = &autoScalerProfile
	} else {
		destination.AutoScalerProfile = nil
	}

	// AutoUpgradeProfile
	if managedClustersSpec.AutoUpgradeProfile != nil {
		var autoUpgradeProfile v1alpha1api20210501storage.ManagedClusterAutoUpgradeProfile
		err := (*managedClustersSpec.AutoUpgradeProfile).AssignPropertiesToManagedClusterAutoUpgradeProfile(&autoUpgradeProfile)
		if err != nil {
			return errors.Wrap(err, "populating AutoUpgradeProfile from AutoUpgradeProfile, calling AssignPropertiesToManagedClusterAutoUpgradeProfile()")
		}
		destination.AutoUpgradeProfile = &autoUpgradeProfile
	} else {
		destination.AutoUpgradeProfile = nil
	}

	// AzureName
	destination.AzureName = managedClustersSpec.AzureName

	// DisableLocalAccounts
	if managedClustersSpec.DisableLocalAccounts != nil {
		disableLocalAccount := *managedClustersSpec.DisableLocalAccounts
		destination.DisableLocalAccounts = &disableLocalAccount
	} else {
		destination.DisableLocalAccounts = nil
	}

	// DiskEncryptionSetIDReference
	if managedClustersSpec.DiskEncryptionSetIDReference != nil {
		diskEncryptionSetIDReference := managedClustersSpec.DiskEncryptionSetIDReference.Copy()
		destination.DiskEncryptionSetIDReference = &diskEncryptionSetIDReference
	} else {
		destination.DiskEncryptionSetIDReference = nil
	}

	// DnsPrefix
	if managedClustersSpec.DnsPrefix != nil {
		dnsPrefix := *managedClustersSpec.DnsPrefix
		destination.DnsPrefix = &dnsPrefix
	} else {
		destination.DnsPrefix = nil
	}

	// EnablePodSecurityPolicy
	if managedClustersSpec.EnablePodSecurityPolicy != nil {
		enablePodSecurityPolicy := *managedClustersSpec.EnablePodSecurityPolicy
		destination.EnablePodSecurityPolicy = &enablePodSecurityPolicy
	} else {
		destination.EnablePodSecurityPolicy = nil
	}

	// EnableRBAC
	if managedClustersSpec.EnableRBAC != nil {
		enableRBAC := *managedClustersSpec.EnableRBAC
		destination.EnableRBAC = &enableRBAC
	} else {
		destination.EnableRBAC = nil
	}

	// ExtendedLocation
	if managedClustersSpec.ExtendedLocation != nil {
		var extendedLocation v1alpha1api20210501storage.ExtendedLocation
		err := (*managedClustersSpec.ExtendedLocation).AssignPropertiesToExtendedLocation(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "populating ExtendedLocation from ExtendedLocation, calling AssignPropertiesToExtendedLocation()")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// FqdnSubdomain
	if managedClustersSpec.FqdnSubdomain != nil {
		fqdnSubdomain := *managedClustersSpec.FqdnSubdomain
		destination.FqdnSubdomain = &fqdnSubdomain
	} else {
		destination.FqdnSubdomain = nil
	}

	// HttpProxyConfig
	if managedClustersSpec.HttpProxyConfig != nil {
		var httpProxyConfig v1alpha1api20210501storage.ManagedClusterHTTPProxyConfig
		err := (*managedClustersSpec.HttpProxyConfig).AssignPropertiesToManagedClusterHTTPProxyConfig(&httpProxyConfig)
		if err != nil {
			return errors.Wrap(err, "populating HttpProxyConfig from HttpProxyConfig, calling AssignPropertiesToManagedClusterHTTPProxyConfig()")
		}
		destination.HttpProxyConfig = &httpProxyConfig
	} else {
		destination.HttpProxyConfig = nil
	}

	// Identity
	if managedClustersSpec.Identity != nil {
		var identity v1alpha1api20210501storage.ManagedClusterIdentity
		err := (*managedClustersSpec.Identity).AssignPropertiesToManagedClusterIdentity(&identity)
		if err != nil {
			return errors.Wrap(err, "populating Identity from Identity, calling AssignPropertiesToManagedClusterIdentity()")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// IdentityProfile
	identityProfileMap := make(map[string]v1alpha1api20210501storage.Componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties)
	for identityProfileKey, identityProfileValue := range managedClustersSpec.IdentityProfile {
		// Shadow the loop variable to avoid aliasing
		identityProfileValue := identityProfileValue
		var identityProfile v1alpha1api20210501storage.Componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties
		err := identityProfileValue.AssignPropertiesToComponentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties(&identityProfile)
		if err != nil {
			return errors.Wrap(err, "populating IdentityProfile from IdentityProfile, calling AssignPropertiesToComponentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties()")
		}
		identityProfileMap[identityProfileKey] = identityProfile
	}
	destination.IdentityProfile = identityProfileMap

	// KubernetesVersion
	if managedClustersSpec.KubernetesVersion != nil {
		kubernetesVersion := *managedClustersSpec.KubernetesVersion
		destination.KubernetesVersion = &kubernetesVersion
	} else {
		destination.KubernetesVersion = nil
	}

	// LinuxProfile
	if managedClustersSpec.LinuxProfile != nil {
		var linuxProfile v1alpha1api20210501storage.ContainerServiceLinuxProfile
		err := (*managedClustersSpec.LinuxProfile).AssignPropertiesToContainerServiceLinuxProfile(&linuxProfile)
		if err != nil {
			return errors.Wrap(err, "populating LinuxProfile from LinuxProfile, calling AssignPropertiesToContainerServiceLinuxProfile()")
		}
		destination.LinuxProfile = &linuxProfile
	} else {
		destination.LinuxProfile = nil
	}

	// Location
	location := managedClustersSpec.Location
	destination.Location = &location

	// NetworkProfile
	if managedClustersSpec.NetworkProfile != nil {
		var networkProfile v1alpha1api20210501storage.ContainerServiceNetworkProfile
		err := (*managedClustersSpec.NetworkProfile).AssignPropertiesToContainerServiceNetworkProfile(&networkProfile)
		if err != nil {
			return errors.Wrap(err, "populating NetworkProfile from NetworkProfile, calling AssignPropertiesToContainerServiceNetworkProfile()")
		}
		destination.NetworkProfile = &networkProfile
	} else {
		destination.NetworkProfile = nil
	}

	// NodeResourceGroup
	if managedClustersSpec.NodeResourceGroup != nil {
		nodeResourceGroup := *managedClustersSpec.NodeResourceGroup
		destination.NodeResourceGroup = &nodeResourceGroup
	} else {
		destination.NodeResourceGroup = nil
	}

	// OriginalVersion
	destination.OriginalVersion = managedClustersSpec.OriginalVersion()

	// Owner
	destination.Owner = managedClustersSpec.Owner.Copy()

	// PodIdentityProfile
	if managedClustersSpec.PodIdentityProfile != nil {
		var podIdentityProfile v1alpha1api20210501storage.ManagedClusterPodIdentityProfile
		err := (*managedClustersSpec.PodIdentityProfile).AssignPropertiesToManagedClusterPodIdentityProfile(&podIdentityProfile)
		if err != nil {
			return errors.Wrap(err, "populating PodIdentityProfile from PodIdentityProfile, calling AssignPropertiesToManagedClusterPodIdentityProfile()")
		}
		destination.PodIdentityProfile = &podIdentityProfile
	} else {
		destination.PodIdentityProfile = nil
	}

	// PrivateLinkResources
	privateLinkResourceList := make([]v1alpha1api20210501storage.PrivateLinkResource, len(managedClustersSpec.PrivateLinkResources))
	for privateLinkResourceIndex, privateLinkResourceItem := range managedClustersSpec.PrivateLinkResources {
		// Shadow the loop variable to avoid aliasing
		privateLinkResourceItem := privateLinkResourceItem
		var privateLinkResource v1alpha1api20210501storage.PrivateLinkResource
		err := privateLinkResourceItem.AssignPropertiesToPrivateLinkResource(&privateLinkResource)
		if err != nil {
			return errors.Wrap(err, "populating PrivateLinkResources from PrivateLinkResources, calling AssignPropertiesToPrivateLinkResource()")
		}
		privateLinkResourceList[privateLinkResourceIndex] = privateLinkResource
	}
	destination.PrivateLinkResources = privateLinkResourceList

	// ServicePrincipalProfile
	if managedClustersSpec.ServicePrincipalProfile != nil {
		var servicePrincipalProfile v1alpha1api20210501storage.ManagedClusterServicePrincipalProfile
		err := (*managedClustersSpec.ServicePrincipalProfile).AssignPropertiesToManagedClusterServicePrincipalProfile(&servicePrincipalProfile)
		if err != nil {
			return errors.Wrap(err, "populating ServicePrincipalProfile from ServicePrincipalProfile, calling AssignPropertiesToManagedClusterServicePrincipalProfile()")
		}
		destination.ServicePrincipalProfile = &servicePrincipalProfile
	} else {
		destination.ServicePrincipalProfile = nil
	}

	// Sku
	if managedClustersSpec.Sku != nil {
		var sku v1alpha1api20210501storage.ManagedClusterSKU
		err := (*managedClustersSpec.Sku).AssignPropertiesToManagedClusterSKU(&sku)
		if err != nil {
			return errors.Wrap(err, "populating Sku from Sku, calling AssignPropertiesToManagedClusterSKU()")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	tagMap := make(map[string]string)
	for tagKey, tagValue := range managedClustersSpec.Tags {
		// Shadow the loop variable to avoid aliasing
		tagValue := tagValue
		tagMap[tagKey] = tagValue
	}
	destination.Tags = tagMap

	// WindowsProfile
	if managedClustersSpec.WindowsProfile != nil {
		var windowsProfile v1alpha1api20210501storage.ManagedClusterWindowsProfile
		err := (*managedClustersSpec.WindowsProfile).AssignPropertiesToManagedClusterWindowsProfile(&windowsProfile)
		if err != nil {
			return errors.Wrap(err, "populating WindowsProfile from WindowsProfile, calling AssignPropertiesToManagedClusterWindowsProfile()")
		}
		destination.WindowsProfile = &windowsProfile
	} else {
		destination.WindowsProfile = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

func (managedClustersSpec *ManagedClusters_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (managedClustersSpec *ManagedClusters_Spec) SetAzureName(azureName string) {
	managedClustersSpec.AzureName = azureName
}

//Generated from:
//https://schema.management.azure.com/schemas/2021-05-01/Microsoft.ContainerService.json#/definitions/Componentsqit0etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties
type Componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties struct {
	//ClientId: The client ID of the user assigned identity.
	ClientId *string `json:"clientId,omitempty"`

	//ObjectId: The object ID of the user assigned identity.
	ObjectId *string `json:"objectId,omitempty"`

	//ResourceReference: The resource ID of the user assigned identity.
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceId" json:"resourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &Componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties *Componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties == nil {
		return nil, nil
	}
	var result Componentsqit0EtschemasmanagedclusterpropertiespropertiesidentityprofileadditionalpropertiesARM

	// Set property ‘ClientId’:
	if componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties.ClientId != nil {
		clientId := *componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties.ClientId
		result.ClientId = &clientId
	}

	// Set property ‘ObjectId’:
	if componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties.ObjectId != nil {
		objectId := *componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties.ObjectId
		result.ObjectId = &objectId
	}

	// Set property ‘ResourceId’:
	if componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties.ResourceReference != nil {
		resourceReferenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties.ResourceReference)
		if err != nil {
			return nil, err
		}
		resourceReference := resourceReferenceARMID
		result.ResourceId = &resourceReference
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties *Componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &Componentsqit0EtschemasmanagedclusterpropertiespropertiesidentityprofileadditionalpropertiesARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties *Componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Componentsqit0EtschemasmanagedclusterpropertiespropertiesidentityprofileadditionalpropertiesARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Componentsqit0EtschemasmanagedclusterpropertiespropertiesidentityprofileadditionalpropertiesARM, got %T", armInput)
	}

	// Set property ‘ClientId’:
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties.ClientId = &clientId
	}

	// Set property ‘ObjectId’:
	if typedInput.ObjectId != nil {
		objectId := *typedInput.ObjectId
		componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties.ObjectId = &objectId
	}

	// no assignment for property ‘ResourceReference’

	// No error
	return nil
}

// AssignPropertiesFromComponentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties populates our Componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties from the provided source Componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties
func (componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties *Componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties) AssignPropertiesFromComponentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties(source *v1alpha1api20210501storage.Componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties) error {

	// ClientId
	if source.ClientId != nil {
		clientId := *source.ClientId
		componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties.ClientId = &clientId
	} else {
		componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties.ClientId = nil
	}

	// ObjectId
	if source.ObjectId != nil {
		objectId := *source.ObjectId
		componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties.ObjectId = &objectId
	} else {
		componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties.ObjectId = nil
	}

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties.ResourceReference = &resourceReference
	} else {
		componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties.ResourceReference = nil
	}

	// No error
	return nil
}

// AssignPropertiesToComponentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties populates the provided destination Componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties from our Componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties
func (componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties *Componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties) AssignPropertiesToComponentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties(destination *v1alpha1api20210501storage.Componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	if componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties.ClientId != nil {
		clientId := *componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties.ClientId
		destination.ClientId = &clientId
	} else {
		destination.ClientId = nil
	}

	// ObjectId
	if componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties.ObjectId != nil {
		objectId := *componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties.ObjectId
		destination.ObjectId = &objectId
	} else {
		destination.ObjectId = nil
	}

	// ResourceReference
	if componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties.ResourceReference != nil {
		resourceReference := componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2021-05-01/Microsoft.ContainerService.json#/definitions/ContainerServiceLinuxProfile
type ContainerServiceLinuxProfile struct {
	// +kubebuilder:validation:Required
	// +kubebuilder:validation:Pattern="^[A-Za-z][-A-Za-z0-9_]*$"
	//AdminUsername: The administrator username to use for Linux VMs.
	AdminUsername string `json:"adminUsername"`

	// +kubebuilder:validation:Required
	//Ssh: SSH configuration for Linux-based VMs running on Azure.
	Ssh ContainerServiceSshConfiguration `json:"ssh"`
}

var _ genruntime.ARMTransformer = &ContainerServiceLinuxProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (containerServiceLinuxProfile *ContainerServiceLinuxProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if containerServiceLinuxProfile == nil {
		return nil, nil
	}
	var result ContainerServiceLinuxProfileARM

	// Set property ‘AdminUsername’:
	result.AdminUsername = containerServiceLinuxProfile.AdminUsername

	// Set property ‘Ssh’:
	sshARM, err := containerServiceLinuxProfile.Ssh.ConvertToARM(resolved)
	if err != nil {
		return nil, err
	}
	result.Ssh = sshARM.(ContainerServiceSshConfigurationARM)
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (containerServiceLinuxProfile *ContainerServiceLinuxProfile) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerServiceLinuxProfileARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (containerServiceLinuxProfile *ContainerServiceLinuxProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerServiceLinuxProfileARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerServiceLinuxProfileARM, got %T", armInput)
	}

	// Set property ‘AdminUsername’:
	containerServiceLinuxProfile.AdminUsername = typedInput.AdminUsername

	// Set property ‘Ssh’:
	var ssh ContainerServiceSshConfiguration
	err := ssh.PopulateFromARM(owner, typedInput.Ssh)
	if err != nil {
		return err
	}
	containerServiceLinuxProfile.Ssh = ssh

	// No error
	return nil
}

// AssignPropertiesFromContainerServiceLinuxProfile populates our ContainerServiceLinuxProfile from the provided source ContainerServiceLinuxProfile
func (containerServiceLinuxProfile *ContainerServiceLinuxProfile) AssignPropertiesFromContainerServiceLinuxProfile(source *v1alpha1api20210501storage.ContainerServiceLinuxProfile) error {

	// AdminUsername
	if source.AdminUsername != nil {
		containerServiceLinuxProfile.AdminUsername = *source.AdminUsername
	} else {
		containerServiceLinuxProfile.AdminUsername = ""
	}

	// Ssh
	if source.Ssh != nil {
		var ssh ContainerServiceSshConfiguration
		err := ssh.AssignPropertiesFromContainerServiceSshConfiguration(source.Ssh)
		if err != nil {
			return errors.Wrap(err, "populating Ssh from Ssh, calling AssignPropertiesFromContainerServiceSshConfiguration()")
		}
		containerServiceLinuxProfile.Ssh = ssh
	} else {
		containerServiceLinuxProfile.Ssh = ContainerServiceSshConfiguration{}
	}

	// No error
	return nil
}

// AssignPropertiesToContainerServiceLinuxProfile populates the provided destination ContainerServiceLinuxProfile from our ContainerServiceLinuxProfile
func (containerServiceLinuxProfile *ContainerServiceLinuxProfile) AssignPropertiesToContainerServiceLinuxProfile(destination *v1alpha1api20210501storage.ContainerServiceLinuxProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminUsername
	adminUsername := containerServiceLinuxProfile.AdminUsername
	destination.AdminUsername = &adminUsername

	// Ssh
	var ssh v1alpha1api20210501storage.ContainerServiceSshConfiguration
	err := containerServiceLinuxProfile.Ssh.AssignPropertiesToContainerServiceSshConfiguration(&ssh)
	if err != nil {
		return errors.Wrap(err, "populating Ssh from Ssh, calling AssignPropertiesToContainerServiceSshConfiguration()")
	}
	destination.Ssh = &ssh

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type ContainerServiceLinuxProfile_Status struct {
	// +kubebuilder:validation:Required
	//AdminUsername: The administrator username to use for Linux VMs.
	AdminUsername string `json:"adminUsername"`

	// +kubebuilder:validation:Required
	//Ssh: SSH configuration for Linux-based VMs running on Azure.
	Ssh ContainerServiceSshConfiguration_Status `json:"ssh"`
}

var _ genruntime.FromARMConverter = &ContainerServiceLinuxProfile_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (containerServiceLinuxProfileStatus *ContainerServiceLinuxProfile_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerServiceLinuxProfile_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (containerServiceLinuxProfileStatus *ContainerServiceLinuxProfile_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerServiceLinuxProfile_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerServiceLinuxProfile_StatusARM, got %T", armInput)
	}

	// Set property ‘AdminUsername’:
	containerServiceLinuxProfileStatus.AdminUsername = typedInput.AdminUsername

	// Set property ‘Ssh’:
	var ssh ContainerServiceSshConfiguration_Status
	err := ssh.PopulateFromARM(owner, typedInput.Ssh)
	if err != nil {
		return err
	}
	containerServiceLinuxProfileStatus.Ssh = ssh

	// No error
	return nil
}

// AssignPropertiesFromContainerServiceLinuxProfileStatus populates our ContainerServiceLinuxProfile_Status from the provided source ContainerServiceLinuxProfile_Status
func (containerServiceLinuxProfileStatus *ContainerServiceLinuxProfile_Status) AssignPropertiesFromContainerServiceLinuxProfileStatus(source *v1alpha1api20210501storage.ContainerServiceLinuxProfile_Status) error {

	// AdminUsername
	if source.AdminUsername != nil {
		containerServiceLinuxProfileStatus.AdminUsername = *source.AdminUsername
	} else {
		containerServiceLinuxProfileStatus.AdminUsername = ""
	}

	// Ssh
	if source.Ssh != nil {
		var ssh ContainerServiceSshConfiguration_Status
		err := ssh.AssignPropertiesFromContainerServiceSshConfigurationStatus(source.Ssh)
		if err != nil {
			return errors.Wrap(err, "populating Ssh from Ssh, calling AssignPropertiesFromContainerServiceSshConfigurationStatus()")
		}
		containerServiceLinuxProfileStatus.Ssh = ssh
	} else {
		containerServiceLinuxProfileStatus.Ssh = ContainerServiceSshConfiguration_Status{}
	}

	// No error
	return nil
}

// AssignPropertiesToContainerServiceLinuxProfileStatus populates the provided destination ContainerServiceLinuxProfile_Status from our ContainerServiceLinuxProfile_Status
func (containerServiceLinuxProfileStatus *ContainerServiceLinuxProfile_Status) AssignPropertiesToContainerServiceLinuxProfileStatus(destination *v1alpha1api20210501storage.ContainerServiceLinuxProfile_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminUsername
	adminUsername := containerServiceLinuxProfileStatus.AdminUsername
	destination.AdminUsername = &adminUsername

	// Ssh
	var ssh v1alpha1api20210501storage.ContainerServiceSshConfiguration_Status
	err := containerServiceLinuxProfileStatus.Ssh.AssignPropertiesToContainerServiceSshConfigurationStatus(&ssh)
	if err != nil {
		return errors.Wrap(err, "populating Ssh from Ssh, calling AssignPropertiesToContainerServiceSshConfigurationStatus()")
	}
	destination.Ssh = &ssh

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2021-05-01/Microsoft.ContainerService.json#/definitions/ContainerServiceNetworkProfile
type ContainerServiceNetworkProfile struct {
	// +kubebuilder:validation:Pattern="^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$"
	//DnsServiceIP: An IP address assigned to the Kubernetes DNS service. It must be
	//within the Kubernetes service address range specified in serviceCidr.
	DnsServiceIP *string `json:"dnsServiceIP,omitempty"`

	// +kubebuilder:validation:Pattern="^([0-9]{1,3}\\.){3}[0-9]{1,3}(\\/([0-9]|[1-2][0-9]|3[0-2]))?$"
	//DockerBridgeCidr: A CIDR notation IP range assigned to the Docker bridge
	//network. It must not overlap with any Subnet IP ranges or the Kubernetes service
	//address range.
	DockerBridgeCidr *string `json:"dockerBridgeCidr,omitempty"`

	//LoadBalancerProfile: Profile of the managed cluster load balancer.
	LoadBalancerProfile *ManagedClusterLoadBalancerProfile `json:"loadBalancerProfile,omitempty"`

	//LoadBalancerSku: The default is 'standard'. See [Azure Load Balancer
	//SKUs](https://docs.microsoft.com/azure/load-balancer/skus) for more information
	//about the differences between load balancer SKUs.
	LoadBalancerSku *ContainerServiceNetworkProfileLoadBalancerSku `json:"loadBalancerSku,omitempty"`

	//NetworkMode: This cannot be specified if networkPlugin is anything other than
	//'azure'.
	NetworkMode *ContainerServiceNetworkProfileNetworkMode `json:"networkMode,omitempty"`

	//NetworkPlugin: Network plugin used for building the Kubernetes network.
	NetworkPlugin *ContainerServiceNetworkProfileNetworkPlugin `json:"networkPlugin,omitempty"`

	//NetworkPolicy: Network policy used for building the Kubernetes network.
	NetworkPolicy *ContainerServiceNetworkProfileNetworkPolicy `json:"networkPolicy,omitempty"`

	//OutboundType: This can only be set at cluster creation time and cannot be
	//changed later. For more information see [egress outbound
	//type](https://docs.microsoft.com/azure/aks/egress-outboundtype).
	OutboundType *ContainerServiceNetworkProfileOutboundType `json:"outboundType,omitempty"`

	// +kubebuilder:validation:Pattern="^([0-9]{1,3}\\.){3}[0-9]{1,3}(\\/([0-9]|[1-2][0-9]|3[0-2]))?$"
	//PodCidr: A CIDR notation IP range from which to assign pod IPs when kubenet is
	//used.
	PodCidr *string `json:"podCidr,omitempty"`

	// +kubebuilder:validation:Pattern="^([0-9]{1,3}\\.){3}[0-9]{1,3}(\\/([0-9]|[1-2][0-9]|3[0-2]))?$"
	//ServiceCidr: A CIDR notation IP range from which to assign service cluster IPs.
	//It must not overlap with any Subnet IP ranges.
	ServiceCidr *string `json:"serviceCidr,omitempty"`
}

var _ genruntime.ARMTransformer = &ContainerServiceNetworkProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (containerServiceNetworkProfile *ContainerServiceNetworkProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if containerServiceNetworkProfile == nil {
		return nil, nil
	}
	var result ContainerServiceNetworkProfileARM

	// Set property ‘DnsServiceIP’:
	if containerServiceNetworkProfile.DnsServiceIP != nil {
		dnsServiceIP := *containerServiceNetworkProfile.DnsServiceIP
		result.DnsServiceIP = &dnsServiceIP
	}

	// Set property ‘DockerBridgeCidr’:
	if containerServiceNetworkProfile.DockerBridgeCidr != nil {
		dockerBridgeCidr := *containerServiceNetworkProfile.DockerBridgeCidr
		result.DockerBridgeCidr = &dockerBridgeCidr
	}

	// Set property ‘LoadBalancerProfile’:
	if containerServiceNetworkProfile.LoadBalancerProfile != nil {
		loadBalancerProfileARM, err := (*containerServiceNetworkProfile.LoadBalancerProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		loadBalancerProfile := loadBalancerProfileARM.(ManagedClusterLoadBalancerProfileARM)
		result.LoadBalancerProfile = &loadBalancerProfile
	}

	// Set property ‘LoadBalancerSku’:
	if containerServiceNetworkProfile.LoadBalancerSku != nil {
		loadBalancerSku := *containerServiceNetworkProfile.LoadBalancerSku
		result.LoadBalancerSku = &loadBalancerSku
	}

	// Set property ‘NetworkMode’:
	if containerServiceNetworkProfile.NetworkMode != nil {
		networkMode := *containerServiceNetworkProfile.NetworkMode
		result.NetworkMode = &networkMode
	}

	// Set property ‘NetworkPlugin’:
	if containerServiceNetworkProfile.NetworkPlugin != nil {
		networkPlugin := *containerServiceNetworkProfile.NetworkPlugin
		result.NetworkPlugin = &networkPlugin
	}

	// Set property ‘NetworkPolicy’:
	if containerServiceNetworkProfile.NetworkPolicy != nil {
		networkPolicy := *containerServiceNetworkProfile.NetworkPolicy
		result.NetworkPolicy = &networkPolicy
	}

	// Set property ‘OutboundType’:
	if containerServiceNetworkProfile.OutboundType != nil {
		outboundType := *containerServiceNetworkProfile.OutboundType
		result.OutboundType = &outboundType
	}

	// Set property ‘PodCidr’:
	if containerServiceNetworkProfile.PodCidr != nil {
		podCidr := *containerServiceNetworkProfile.PodCidr
		result.PodCidr = &podCidr
	}

	// Set property ‘ServiceCidr’:
	if containerServiceNetworkProfile.ServiceCidr != nil {
		serviceCidr := *containerServiceNetworkProfile.ServiceCidr
		result.ServiceCidr = &serviceCidr
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (containerServiceNetworkProfile *ContainerServiceNetworkProfile) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerServiceNetworkProfileARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (containerServiceNetworkProfile *ContainerServiceNetworkProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerServiceNetworkProfileARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerServiceNetworkProfileARM, got %T", armInput)
	}

	// Set property ‘DnsServiceIP’:
	if typedInput.DnsServiceIP != nil {
		dnsServiceIP := *typedInput.DnsServiceIP
		containerServiceNetworkProfile.DnsServiceIP = &dnsServiceIP
	}

	// Set property ‘DockerBridgeCidr’:
	if typedInput.DockerBridgeCidr != nil {
		dockerBridgeCidr := *typedInput.DockerBridgeCidr
		containerServiceNetworkProfile.DockerBridgeCidr = &dockerBridgeCidr
	}

	// Set property ‘LoadBalancerProfile’:
	if typedInput.LoadBalancerProfile != nil {
		var loadBalancerProfile1 ManagedClusterLoadBalancerProfile
		err := loadBalancerProfile1.PopulateFromARM(owner, *typedInput.LoadBalancerProfile)
		if err != nil {
			return err
		}
		loadBalancerProfile := loadBalancerProfile1
		containerServiceNetworkProfile.LoadBalancerProfile = &loadBalancerProfile
	}

	// Set property ‘LoadBalancerSku’:
	if typedInput.LoadBalancerSku != nil {
		loadBalancerSku := *typedInput.LoadBalancerSku
		containerServiceNetworkProfile.LoadBalancerSku = &loadBalancerSku
	}

	// Set property ‘NetworkMode’:
	if typedInput.NetworkMode != nil {
		networkMode := *typedInput.NetworkMode
		containerServiceNetworkProfile.NetworkMode = &networkMode
	}

	// Set property ‘NetworkPlugin’:
	if typedInput.NetworkPlugin != nil {
		networkPlugin := *typedInput.NetworkPlugin
		containerServiceNetworkProfile.NetworkPlugin = &networkPlugin
	}

	// Set property ‘NetworkPolicy’:
	if typedInput.NetworkPolicy != nil {
		networkPolicy := *typedInput.NetworkPolicy
		containerServiceNetworkProfile.NetworkPolicy = &networkPolicy
	}

	// Set property ‘OutboundType’:
	if typedInput.OutboundType != nil {
		outboundType := *typedInput.OutboundType
		containerServiceNetworkProfile.OutboundType = &outboundType
	}

	// Set property ‘PodCidr’:
	if typedInput.PodCidr != nil {
		podCidr := *typedInput.PodCidr
		containerServiceNetworkProfile.PodCidr = &podCidr
	}

	// Set property ‘ServiceCidr’:
	if typedInput.ServiceCidr != nil {
		serviceCidr := *typedInput.ServiceCidr
		containerServiceNetworkProfile.ServiceCidr = &serviceCidr
	}

	// No error
	return nil
}

// AssignPropertiesFromContainerServiceNetworkProfile populates our ContainerServiceNetworkProfile from the provided source ContainerServiceNetworkProfile
func (containerServiceNetworkProfile *ContainerServiceNetworkProfile) AssignPropertiesFromContainerServiceNetworkProfile(source *v1alpha1api20210501storage.ContainerServiceNetworkProfile) error {

	// DnsServiceIP
	if source.DnsServiceIP != nil {
		dnsServiceIP := *source.DnsServiceIP
		containerServiceNetworkProfile.DnsServiceIP = &dnsServiceIP
	} else {
		containerServiceNetworkProfile.DnsServiceIP = nil
	}

	// DockerBridgeCidr
	if source.DockerBridgeCidr != nil {
		dockerBridgeCidr := *source.DockerBridgeCidr
		containerServiceNetworkProfile.DockerBridgeCidr = &dockerBridgeCidr
	} else {
		containerServiceNetworkProfile.DockerBridgeCidr = nil
	}

	// LoadBalancerProfile
	if source.LoadBalancerProfile != nil {
		var loadBalancerProfile ManagedClusterLoadBalancerProfile
		err := loadBalancerProfile.AssignPropertiesFromManagedClusterLoadBalancerProfile(source.LoadBalancerProfile)
		if err != nil {
			return errors.Wrap(err, "populating LoadBalancerProfile from LoadBalancerProfile, calling AssignPropertiesFromManagedClusterLoadBalancerProfile()")
		}
		containerServiceNetworkProfile.LoadBalancerProfile = &loadBalancerProfile
	} else {
		containerServiceNetworkProfile.LoadBalancerProfile = nil
	}

	// LoadBalancerSku
	if source.LoadBalancerSku != nil {
		loadBalancerSku := ContainerServiceNetworkProfileLoadBalancerSku(*source.LoadBalancerSku)
		containerServiceNetworkProfile.LoadBalancerSku = &loadBalancerSku
	} else {
		containerServiceNetworkProfile.LoadBalancerSku = nil
	}

	// NetworkMode
	if source.NetworkMode != nil {
		networkMode := ContainerServiceNetworkProfileNetworkMode(*source.NetworkMode)
		containerServiceNetworkProfile.NetworkMode = &networkMode
	} else {
		containerServiceNetworkProfile.NetworkMode = nil
	}

	// NetworkPlugin
	if source.NetworkPlugin != nil {
		networkPlugin := ContainerServiceNetworkProfileNetworkPlugin(*source.NetworkPlugin)
		containerServiceNetworkProfile.NetworkPlugin = &networkPlugin
	} else {
		containerServiceNetworkProfile.NetworkPlugin = nil
	}

	// NetworkPolicy
	if source.NetworkPolicy != nil {
		networkPolicy := ContainerServiceNetworkProfileNetworkPolicy(*source.NetworkPolicy)
		containerServiceNetworkProfile.NetworkPolicy = &networkPolicy
	} else {
		containerServiceNetworkProfile.NetworkPolicy = nil
	}

	// OutboundType
	if source.OutboundType != nil {
		outboundType := ContainerServiceNetworkProfileOutboundType(*source.OutboundType)
		containerServiceNetworkProfile.OutboundType = &outboundType
	} else {
		containerServiceNetworkProfile.OutboundType = nil
	}

	// PodCidr
	if source.PodCidr != nil {
		podCidr := *source.PodCidr
		containerServiceNetworkProfile.PodCidr = &podCidr
	} else {
		containerServiceNetworkProfile.PodCidr = nil
	}

	// ServiceCidr
	if source.ServiceCidr != nil {
		serviceCidr := *source.ServiceCidr
		containerServiceNetworkProfile.ServiceCidr = &serviceCidr
	} else {
		containerServiceNetworkProfile.ServiceCidr = nil
	}

	// No error
	return nil
}

// AssignPropertiesToContainerServiceNetworkProfile populates the provided destination ContainerServiceNetworkProfile from our ContainerServiceNetworkProfile
func (containerServiceNetworkProfile *ContainerServiceNetworkProfile) AssignPropertiesToContainerServiceNetworkProfile(destination *v1alpha1api20210501storage.ContainerServiceNetworkProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DnsServiceIP
	if containerServiceNetworkProfile.DnsServiceIP != nil {
		dnsServiceIP := *containerServiceNetworkProfile.DnsServiceIP
		destination.DnsServiceIP = &dnsServiceIP
	} else {
		destination.DnsServiceIP = nil
	}

	// DockerBridgeCidr
	if containerServiceNetworkProfile.DockerBridgeCidr != nil {
		dockerBridgeCidr := *containerServiceNetworkProfile.DockerBridgeCidr
		destination.DockerBridgeCidr = &dockerBridgeCidr
	} else {
		destination.DockerBridgeCidr = nil
	}

	// LoadBalancerProfile
	if containerServiceNetworkProfile.LoadBalancerProfile != nil {
		var loadBalancerProfile v1alpha1api20210501storage.ManagedClusterLoadBalancerProfile
		err := (*containerServiceNetworkProfile.LoadBalancerProfile).AssignPropertiesToManagedClusterLoadBalancerProfile(&loadBalancerProfile)
		if err != nil {
			return errors.Wrap(err, "populating LoadBalancerProfile from LoadBalancerProfile, calling AssignPropertiesToManagedClusterLoadBalancerProfile()")
		}
		destination.LoadBalancerProfile = &loadBalancerProfile
	} else {
		destination.LoadBalancerProfile = nil
	}

	// LoadBalancerSku
	if containerServiceNetworkProfile.LoadBalancerSku != nil {
		loadBalancerSku := string(*containerServiceNetworkProfile.LoadBalancerSku)
		destination.LoadBalancerSku = &loadBalancerSku
	} else {
		destination.LoadBalancerSku = nil
	}

	// NetworkMode
	if containerServiceNetworkProfile.NetworkMode != nil {
		networkMode := string(*containerServiceNetworkProfile.NetworkMode)
		destination.NetworkMode = &networkMode
	} else {
		destination.NetworkMode = nil
	}

	// NetworkPlugin
	if containerServiceNetworkProfile.NetworkPlugin != nil {
		networkPlugin := string(*containerServiceNetworkProfile.NetworkPlugin)
		destination.NetworkPlugin = &networkPlugin
	} else {
		destination.NetworkPlugin = nil
	}

	// NetworkPolicy
	if containerServiceNetworkProfile.NetworkPolicy != nil {
		networkPolicy := string(*containerServiceNetworkProfile.NetworkPolicy)
		destination.NetworkPolicy = &networkPolicy
	} else {
		destination.NetworkPolicy = nil
	}

	// OutboundType
	if containerServiceNetworkProfile.OutboundType != nil {
		outboundType := string(*containerServiceNetworkProfile.OutboundType)
		destination.OutboundType = &outboundType
	} else {
		destination.OutboundType = nil
	}

	// PodCidr
	if containerServiceNetworkProfile.PodCidr != nil {
		podCidr := *containerServiceNetworkProfile.PodCidr
		destination.PodCidr = &podCidr
	} else {
		destination.PodCidr = nil
	}

	// ServiceCidr
	if containerServiceNetworkProfile.ServiceCidr != nil {
		serviceCidr := *containerServiceNetworkProfile.ServiceCidr
		destination.ServiceCidr = &serviceCidr
	} else {
		destination.ServiceCidr = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type ContainerServiceNetworkProfile_Status struct {
	//DnsServiceIP: An IP address assigned to the Kubernetes DNS service. It must be
	//within the Kubernetes service address range specified in serviceCidr.
	DnsServiceIP *string `json:"dnsServiceIP,omitempty"`

	//DockerBridgeCidr: A CIDR notation IP range assigned to the Docker bridge
	//network. It must not overlap with any Subnet IP ranges or the Kubernetes service
	//address range.
	DockerBridgeCidr *string `json:"dockerBridgeCidr,omitempty"`

	//LoadBalancerProfile: Profile of the cluster load balancer.
	LoadBalancerProfile *ManagedClusterLoadBalancerProfile_Status `json:"loadBalancerProfile,omitempty"`

	//LoadBalancerSku: The load balancer sku for the managed cluster.
	LoadBalancerSku *ContainerServiceNetworkProfileStatusLoadBalancerSku `json:"loadBalancerSku,omitempty"`

	//NetworkMode: Network mode used for building Kubernetes network.
	NetworkMode *ContainerServiceNetworkProfileStatusNetworkMode `json:"networkMode,omitempty"`

	//NetworkPlugin: Network plugin used for building Kubernetes network.
	NetworkPlugin *ContainerServiceNetworkProfileStatusNetworkPlugin `json:"networkPlugin,omitempty"`

	//NetworkPolicy: Network policy used for building Kubernetes network.
	NetworkPolicy *ContainerServiceNetworkProfileStatusNetworkPolicy `json:"networkPolicy,omitempty"`

	//OutboundType: The outbound (egress) routing method.
	OutboundType *ContainerServiceNetworkProfileStatusOutboundType `json:"outboundType,omitempty"`

	//PodCidr: A CIDR notation IP range from which to assign pod IPs when kubenet is
	//used.
	PodCidr *string `json:"podCidr,omitempty"`

	//ServiceCidr: A CIDR notation IP range from which to assign service cluster IPs.
	//It must not overlap with any Subnet IP ranges.
	ServiceCidr *string `json:"serviceCidr,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerServiceNetworkProfile_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (containerServiceNetworkProfileStatus *ContainerServiceNetworkProfile_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerServiceNetworkProfile_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (containerServiceNetworkProfileStatus *ContainerServiceNetworkProfile_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerServiceNetworkProfile_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerServiceNetworkProfile_StatusARM, got %T", armInput)
	}

	// Set property ‘DnsServiceIP’:
	if typedInput.DnsServiceIP != nil {
		dnsServiceIP := *typedInput.DnsServiceIP
		containerServiceNetworkProfileStatus.DnsServiceIP = &dnsServiceIP
	}

	// Set property ‘DockerBridgeCidr’:
	if typedInput.DockerBridgeCidr != nil {
		dockerBridgeCidr := *typedInput.DockerBridgeCidr
		containerServiceNetworkProfileStatus.DockerBridgeCidr = &dockerBridgeCidr
	}

	// Set property ‘LoadBalancerProfile’:
	if typedInput.LoadBalancerProfile != nil {
		var loadBalancerProfile1 ManagedClusterLoadBalancerProfile_Status
		err := loadBalancerProfile1.PopulateFromARM(owner, *typedInput.LoadBalancerProfile)
		if err != nil {
			return err
		}
		loadBalancerProfile := loadBalancerProfile1
		containerServiceNetworkProfileStatus.LoadBalancerProfile = &loadBalancerProfile
	}

	// Set property ‘LoadBalancerSku’:
	if typedInput.LoadBalancerSku != nil {
		loadBalancerSku := *typedInput.LoadBalancerSku
		containerServiceNetworkProfileStatus.LoadBalancerSku = &loadBalancerSku
	}

	// Set property ‘NetworkMode’:
	if typedInput.NetworkMode != nil {
		networkMode := *typedInput.NetworkMode
		containerServiceNetworkProfileStatus.NetworkMode = &networkMode
	}

	// Set property ‘NetworkPlugin’:
	if typedInput.NetworkPlugin != nil {
		networkPlugin := *typedInput.NetworkPlugin
		containerServiceNetworkProfileStatus.NetworkPlugin = &networkPlugin
	}

	// Set property ‘NetworkPolicy’:
	if typedInput.NetworkPolicy != nil {
		networkPolicy := *typedInput.NetworkPolicy
		containerServiceNetworkProfileStatus.NetworkPolicy = &networkPolicy
	}

	// Set property ‘OutboundType’:
	if typedInput.OutboundType != nil {
		outboundType := *typedInput.OutboundType
		containerServiceNetworkProfileStatus.OutboundType = &outboundType
	}

	// Set property ‘PodCidr’:
	if typedInput.PodCidr != nil {
		podCidr := *typedInput.PodCidr
		containerServiceNetworkProfileStatus.PodCidr = &podCidr
	}

	// Set property ‘ServiceCidr’:
	if typedInput.ServiceCidr != nil {
		serviceCidr := *typedInput.ServiceCidr
		containerServiceNetworkProfileStatus.ServiceCidr = &serviceCidr
	}

	// No error
	return nil
}

// AssignPropertiesFromContainerServiceNetworkProfileStatus populates our ContainerServiceNetworkProfile_Status from the provided source ContainerServiceNetworkProfile_Status
func (containerServiceNetworkProfileStatus *ContainerServiceNetworkProfile_Status) AssignPropertiesFromContainerServiceNetworkProfileStatus(source *v1alpha1api20210501storage.ContainerServiceNetworkProfile_Status) error {

	// DnsServiceIP
	if source.DnsServiceIP != nil {
		dnsServiceIP := *source.DnsServiceIP
		containerServiceNetworkProfileStatus.DnsServiceIP = &dnsServiceIP
	} else {
		containerServiceNetworkProfileStatus.DnsServiceIP = nil
	}

	// DockerBridgeCidr
	if source.DockerBridgeCidr != nil {
		dockerBridgeCidr := *source.DockerBridgeCidr
		containerServiceNetworkProfileStatus.DockerBridgeCidr = &dockerBridgeCidr
	} else {
		containerServiceNetworkProfileStatus.DockerBridgeCidr = nil
	}

	// LoadBalancerProfile
	if source.LoadBalancerProfile != nil {
		var loadBalancerProfile ManagedClusterLoadBalancerProfile_Status
		err := loadBalancerProfile.AssignPropertiesFromManagedClusterLoadBalancerProfileStatus(source.LoadBalancerProfile)
		if err != nil {
			return errors.Wrap(err, "populating LoadBalancerProfile from LoadBalancerProfile, calling AssignPropertiesFromManagedClusterLoadBalancerProfileStatus()")
		}
		containerServiceNetworkProfileStatus.LoadBalancerProfile = &loadBalancerProfile
	} else {
		containerServiceNetworkProfileStatus.LoadBalancerProfile = nil
	}

	// LoadBalancerSku
	if source.LoadBalancerSku != nil {
		loadBalancerSku := ContainerServiceNetworkProfileStatusLoadBalancerSku(*source.LoadBalancerSku)
		containerServiceNetworkProfileStatus.LoadBalancerSku = &loadBalancerSku
	} else {
		containerServiceNetworkProfileStatus.LoadBalancerSku = nil
	}

	// NetworkMode
	if source.NetworkMode != nil {
		networkMode := ContainerServiceNetworkProfileStatusNetworkMode(*source.NetworkMode)
		containerServiceNetworkProfileStatus.NetworkMode = &networkMode
	} else {
		containerServiceNetworkProfileStatus.NetworkMode = nil
	}

	// NetworkPlugin
	if source.NetworkPlugin != nil {
		networkPlugin := ContainerServiceNetworkProfileStatusNetworkPlugin(*source.NetworkPlugin)
		containerServiceNetworkProfileStatus.NetworkPlugin = &networkPlugin
	} else {
		containerServiceNetworkProfileStatus.NetworkPlugin = nil
	}

	// NetworkPolicy
	if source.NetworkPolicy != nil {
		networkPolicy := ContainerServiceNetworkProfileStatusNetworkPolicy(*source.NetworkPolicy)
		containerServiceNetworkProfileStatus.NetworkPolicy = &networkPolicy
	} else {
		containerServiceNetworkProfileStatus.NetworkPolicy = nil
	}

	// OutboundType
	if source.OutboundType != nil {
		outboundType := ContainerServiceNetworkProfileStatusOutboundType(*source.OutboundType)
		containerServiceNetworkProfileStatus.OutboundType = &outboundType
	} else {
		containerServiceNetworkProfileStatus.OutboundType = nil
	}

	// PodCidr
	if source.PodCidr != nil {
		podCidr := *source.PodCidr
		containerServiceNetworkProfileStatus.PodCidr = &podCidr
	} else {
		containerServiceNetworkProfileStatus.PodCidr = nil
	}

	// ServiceCidr
	if source.ServiceCidr != nil {
		serviceCidr := *source.ServiceCidr
		containerServiceNetworkProfileStatus.ServiceCidr = &serviceCidr
	} else {
		containerServiceNetworkProfileStatus.ServiceCidr = nil
	}

	// No error
	return nil
}

// AssignPropertiesToContainerServiceNetworkProfileStatus populates the provided destination ContainerServiceNetworkProfile_Status from our ContainerServiceNetworkProfile_Status
func (containerServiceNetworkProfileStatus *ContainerServiceNetworkProfile_Status) AssignPropertiesToContainerServiceNetworkProfileStatus(destination *v1alpha1api20210501storage.ContainerServiceNetworkProfile_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DnsServiceIP
	if containerServiceNetworkProfileStatus.DnsServiceIP != nil {
		dnsServiceIP := *containerServiceNetworkProfileStatus.DnsServiceIP
		destination.DnsServiceIP = &dnsServiceIP
	} else {
		destination.DnsServiceIP = nil
	}

	// DockerBridgeCidr
	if containerServiceNetworkProfileStatus.DockerBridgeCidr != nil {
		dockerBridgeCidr := *containerServiceNetworkProfileStatus.DockerBridgeCidr
		destination.DockerBridgeCidr = &dockerBridgeCidr
	} else {
		destination.DockerBridgeCidr = nil
	}

	// LoadBalancerProfile
	if containerServiceNetworkProfileStatus.LoadBalancerProfile != nil {
		var loadBalancerProfile v1alpha1api20210501storage.ManagedClusterLoadBalancerProfile_Status
		err := (*containerServiceNetworkProfileStatus.LoadBalancerProfile).AssignPropertiesToManagedClusterLoadBalancerProfileStatus(&loadBalancerProfile)
		if err != nil {
			return errors.Wrap(err, "populating LoadBalancerProfile from LoadBalancerProfile, calling AssignPropertiesToManagedClusterLoadBalancerProfileStatus()")
		}
		destination.LoadBalancerProfile = &loadBalancerProfile
	} else {
		destination.LoadBalancerProfile = nil
	}

	// LoadBalancerSku
	if containerServiceNetworkProfileStatus.LoadBalancerSku != nil {
		loadBalancerSku := string(*containerServiceNetworkProfileStatus.LoadBalancerSku)
		destination.LoadBalancerSku = &loadBalancerSku
	} else {
		destination.LoadBalancerSku = nil
	}

	// NetworkMode
	if containerServiceNetworkProfileStatus.NetworkMode != nil {
		networkMode := string(*containerServiceNetworkProfileStatus.NetworkMode)
		destination.NetworkMode = &networkMode
	} else {
		destination.NetworkMode = nil
	}

	// NetworkPlugin
	if containerServiceNetworkProfileStatus.NetworkPlugin != nil {
		networkPlugin := string(*containerServiceNetworkProfileStatus.NetworkPlugin)
		destination.NetworkPlugin = &networkPlugin
	} else {
		destination.NetworkPlugin = nil
	}

	// NetworkPolicy
	if containerServiceNetworkProfileStatus.NetworkPolicy != nil {
		networkPolicy := string(*containerServiceNetworkProfileStatus.NetworkPolicy)
		destination.NetworkPolicy = &networkPolicy
	} else {
		destination.NetworkPolicy = nil
	}

	// OutboundType
	if containerServiceNetworkProfileStatus.OutboundType != nil {
		outboundType := string(*containerServiceNetworkProfileStatus.OutboundType)
		destination.OutboundType = &outboundType
	} else {
		destination.OutboundType = nil
	}

	// PodCidr
	if containerServiceNetworkProfileStatus.PodCidr != nil {
		podCidr := *containerServiceNetworkProfileStatus.PodCidr
		destination.PodCidr = &podCidr
	} else {
		destination.PodCidr = nil
	}

	// ServiceCidr
	if containerServiceNetworkProfileStatus.ServiceCidr != nil {
		serviceCidr := *containerServiceNetworkProfileStatus.ServiceCidr
		destination.ServiceCidr = &serviceCidr
	} else {
		destination.ServiceCidr = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2021-05-01/Microsoft.ContainerService.json#/definitions/ExtendedLocation
type ExtendedLocation struct {
	//Name: The name of the extended location.
	Name *string `json:"name,omitempty"`

	//Type: The type of the extended location.
	Type *ExtendedLocationType `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &ExtendedLocation{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (extendedLocation *ExtendedLocation) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if extendedLocation == nil {
		return nil, nil
	}
	var result ExtendedLocationARM

	// Set property ‘Name’:
	if extendedLocation.Name != nil {
		name := *extendedLocation.Name
		result.Name = &name
	}

	// Set property ‘Type’:
	if extendedLocation.Type != nil {
		typeVar := *extendedLocation.Type
		result.Type = &typeVar
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (extendedLocation *ExtendedLocation) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ExtendedLocationARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (extendedLocation *ExtendedLocation) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ExtendedLocationARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ExtendedLocationARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		extendedLocation.Name = &name
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		extendedLocation.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromExtendedLocation populates our ExtendedLocation from the provided source ExtendedLocation
func (extendedLocation *ExtendedLocation) AssignPropertiesFromExtendedLocation(source *v1alpha1api20210501storage.ExtendedLocation) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		extendedLocation.Name = &name
	} else {
		extendedLocation.Name = nil
	}

	// Type
	if source.Type != nil {
		typeVar := ExtendedLocationType(*source.Type)
		extendedLocation.Type = &typeVar
	} else {
		extendedLocation.Type = nil
	}

	// No error
	return nil
}

// AssignPropertiesToExtendedLocation populates the provided destination ExtendedLocation from our ExtendedLocation
func (extendedLocation *ExtendedLocation) AssignPropertiesToExtendedLocation(destination *v1alpha1api20210501storage.ExtendedLocation) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if extendedLocation.Name != nil {
		name := *extendedLocation.Name
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Type
	if extendedLocation.Type != nil {
		typeVar := string(*extendedLocation.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type ExtendedLocation_Status struct {
	//Name: The name of the extended location.
	Name *string `json:"name,omitempty"`

	//Type: The type of the extended location.
	Type *ExtendedLocationType_Status `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &ExtendedLocation_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (extendedLocationStatus *ExtendedLocation_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ExtendedLocation_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (extendedLocationStatus *ExtendedLocation_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ExtendedLocation_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ExtendedLocation_StatusARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		extendedLocationStatus.Name = &name
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		extendedLocationStatus.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromExtendedLocationStatus populates our ExtendedLocation_Status from the provided source ExtendedLocation_Status
func (extendedLocationStatus *ExtendedLocation_Status) AssignPropertiesFromExtendedLocationStatus(source *v1alpha1api20210501storage.ExtendedLocation_Status) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		extendedLocationStatus.Name = &name
	} else {
		extendedLocationStatus.Name = nil
	}

	// Type
	if source.Type != nil {
		typeVar := ExtendedLocationType_Status(*source.Type)
		extendedLocationStatus.Type = &typeVar
	} else {
		extendedLocationStatus.Type = nil
	}

	// No error
	return nil
}

// AssignPropertiesToExtendedLocationStatus populates the provided destination ExtendedLocation_Status from our ExtendedLocation_Status
func (extendedLocationStatus *ExtendedLocation_Status) AssignPropertiesToExtendedLocationStatus(destination *v1alpha1api20210501storage.ExtendedLocation_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if extendedLocationStatus.Name != nil {
		name := *extendedLocationStatus.Name
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Type
	if extendedLocationStatus.Type != nil {
		typeVar := string(*extendedLocationStatus.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2021-05-01/Microsoft.ContainerService.json#/definitions/ManagedClusterAADProfile
type ManagedClusterAADProfile struct {
	//AdminGroupObjectIDs: The list of AAD group object IDs that will have admin role
	//of the cluster.
	AdminGroupObjectIDs []string `json:"adminGroupObjectIDs,omitempty"`

	//ClientAppID: The client AAD application ID.
	ClientAppID *string `json:"clientAppID,omitempty"`

	//EnableAzureRBAC: Whether to enable Azure RBAC for Kubernetes authorization.
	EnableAzureRBAC *bool `json:"enableAzureRBAC,omitempty"`

	//Managed: Whether to enable managed AAD.
	Managed *bool `json:"managed,omitempty"`

	//ServerAppID: The server AAD application ID.
	ServerAppID *string `json:"serverAppID,omitempty"`

	//ServerAppSecret: The server AAD application secret.
	ServerAppSecret *string `json:"serverAppSecret,omitempty"`

	//TenantID: The AAD tenant ID to use for authentication. If not specified, will
	//use the tenant of the deployment subscription.
	TenantID *string `json:"tenantID,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterAADProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (managedClusterAADProfile *ManagedClusterAADProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if managedClusterAADProfile == nil {
		return nil, nil
	}
	var result ManagedClusterAADProfileARM

	// Set property ‘AdminGroupObjectIDs’:
	for _, item := range managedClusterAADProfile.AdminGroupObjectIDs {
		result.AdminGroupObjectIDs = append(result.AdminGroupObjectIDs, item)
	}

	// Set property ‘ClientAppID’:
	if managedClusterAADProfile.ClientAppID != nil {
		clientAppID := *managedClusterAADProfile.ClientAppID
		result.ClientAppID = &clientAppID
	}

	// Set property ‘EnableAzureRBAC’:
	if managedClusterAADProfile.EnableAzureRBAC != nil {
		enableAzureRBAC := *managedClusterAADProfile.EnableAzureRBAC
		result.EnableAzureRBAC = &enableAzureRBAC
	}

	// Set property ‘Managed’:
	if managedClusterAADProfile.Managed != nil {
		managed := *managedClusterAADProfile.Managed
		result.Managed = &managed
	}

	// Set property ‘ServerAppID’:
	if managedClusterAADProfile.ServerAppID != nil {
		serverAppID := *managedClusterAADProfile.ServerAppID
		result.ServerAppID = &serverAppID
	}

	// Set property ‘ServerAppSecret’:
	if managedClusterAADProfile.ServerAppSecret != nil {
		serverAppSecret := *managedClusterAADProfile.ServerAppSecret
		result.ServerAppSecret = &serverAppSecret
	}

	// Set property ‘TenantID’:
	if managedClusterAADProfile.TenantID != nil {
		tenantID := *managedClusterAADProfile.TenantID
		result.TenantID = &tenantID
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (managedClusterAADProfile *ManagedClusterAADProfile) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterAADProfileARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (managedClusterAADProfile *ManagedClusterAADProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterAADProfileARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterAADProfileARM, got %T", armInput)
	}

	// Set property ‘AdminGroupObjectIDs’:
	for _, item := range typedInput.AdminGroupObjectIDs {
		managedClusterAADProfile.AdminGroupObjectIDs = append(managedClusterAADProfile.AdminGroupObjectIDs, item)
	}

	// Set property ‘ClientAppID’:
	if typedInput.ClientAppID != nil {
		clientAppID := *typedInput.ClientAppID
		managedClusterAADProfile.ClientAppID = &clientAppID
	}

	// Set property ‘EnableAzureRBAC’:
	if typedInput.EnableAzureRBAC != nil {
		enableAzureRBAC := *typedInput.EnableAzureRBAC
		managedClusterAADProfile.EnableAzureRBAC = &enableAzureRBAC
	}

	// Set property ‘Managed’:
	if typedInput.Managed != nil {
		managed := *typedInput.Managed
		managedClusterAADProfile.Managed = &managed
	}

	// Set property ‘ServerAppID’:
	if typedInput.ServerAppID != nil {
		serverAppID := *typedInput.ServerAppID
		managedClusterAADProfile.ServerAppID = &serverAppID
	}

	// Set property ‘ServerAppSecret’:
	if typedInput.ServerAppSecret != nil {
		serverAppSecret := *typedInput.ServerAppSecret
		managedClusterAADProfile.ServerAppSecret = &serverAppSecret
	}

	// Set property ‘TenantID’:
	if typedInput.TenantID != nil {
		tenantID := *typedInput.TenantID
		managedClusterAADProfile.TenantID = &tenantID
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterAADProfile populates our ManagedClusterAADProfile from the provided source ManagedClusterAADProfile
func (managedClusterAADProfile *ManagedClusterAADProfile) AssignPropertiesFromManagedClusterAADProfile(source *v1alpha1api20210501storage.ManagedClusterAADProfile) error {

	// AdminGroupObjectIDs
	adminGroupObjectIDList := make([]string, len(source.AdminGroupObjectIDs))
	for adminGroupObjectIDIndex, adminGroupObjectIDItem := range source.AdminGroupObjectIDs {
		// Shadow the loop variable to avoid aliasing
		adminGroupObjectIDItem := adminGroupObjectIDItem
		adminGroupObjectIDList[adminGroupObjectIDIndex] = adminGroupObjectIDItem
	}
	managedClusterAADProfile.AdminGroupObjectIDs = adminGroupObjectIDList

	// ClientAppID
	if source.ClientAppID != nil {
		clientAppID := *source.ClientAppID
		managedClusterAADProfile.ClientAppID = &clientAppID
	} else {
		managedClusterAADProfile.ClientAppID = nil
	}

	// EnableAzureRBAC
	if source.EnableAzureRBAC != nil {
		enableAzureRBAC := *source.EnableAzureRBAC
		managedClusterAADProfile.EnableAzureRBAC = &enableAzureRBAC
	} else {
		managedClusterAADProfile.EnableAzureRBAC = nil
	}

	// Managed
	if source.Managed != nil {
		managed := *source.Managed
		managedClusterAADProfile.Managed = &managed
	} else {
		managedClusterAADProfile.Managed = nil
	}

	// ServerAppID
	if source.ServerAppID != nil {
		serverAppID := *source.ServerAppID
		managedClusterAADProfile.ServerAppID = &serverAppID
	} else {
		managedClusterAADProfile.ServerAppID = nil
	}

	// ServerAppSecret
	if source.ServerAppSecret != nil {
		serverAppSecret := *source.ServerAppSecret
		managedClusterAADProfile.ServerAppSecret = &serverAppSecret
	} else {
		managedClusterAADProfile.ServerAppSecret = nil
	}

	// TenantID
	if source.TenantID != nil {
		tenantID := *source.TenantID
		managedClusterAADProfile.TenantID = &tenantID
	} else {
		managedClusterAADProfile.TenantID = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterAADProfile populates the provided destination ManagedClusterAADProfile from our ManagedClusterAADProfile
func (managedClusterAADProfile *ManagedClusterAADProfile) AssignPropertiesToManagedClusterAADProfile(destination *v1alpha1api20210501storage.ManagedClusterAADProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminGroupObjectIDs
	adminGroupObjectIDList := make([]string, len(managedClusterAADProfile.AdminGroupObjectIDs))
	for adminGroupObjectIDIndex, adminGroupObjectIDItem := range managedClusterAADProfile.AdminGroupObjectIDs {
		// Shadow the loop variable to avoid aliasing
		adminGroupObjectIDItem := adminGroupObjectIDItem
		adminGroupObjectIDList[adminGroupObjectIDIndex] = adminGroupObjectIDItem
	}
	destination.AdminGroupObjectIDs = adminGroupObjectIDList

	// ClientAppID
	if managedClusterAADProfile.ClientAppID != nil {
		clientAppID := *managedClusterAADProfile.ClientAppID
		destination.ClientAppID = &clientAppID
	} else {
		destination.ClientAppID = nil
	}

	// EnableAzureRBAC
	if managedClusterAADProfile.EnableAzureRBAC != nil {
		enableAzureRBAC := *managedClusterAADProfile.EnableAzureRBAC
		destination.EnableAzureRBAC = &enableAzureRBAC
	} else {
		destination.EnableAzureRBAC = nil
	}

	// Managed
	if managedClusterAADProfile.Managed != nil {
		managed := *managedClusterAADProfile.Managed
		destination.Managed = &managed
	} else {
		destination.Managed = nil
	}

	// ServerAppID
	if managedClusterAADProfile.ServerAppID != nil {
		serverAppID := *managedClusterAADProfile.ServerAppID
		destination.ServerAppID = &serverAppID
	} else {
		destination.ServerAppID = nil
	}

	// ServerAppSecret
	if managedClusterAADProfile.ServerAppSecret != nil {
		serverAppSecret := *managedClusterAADProfile.ServerAppSecret
		destination.ServerAppSecret = &serverAppSecret
	} else {
		destination.ServerAppSecret = nil
	}

	// TenantID
	if managedClusterAADProfile.TenantID != nil {
		tenantID := *managedClusterAADProfile.TenantID
		destination.TenantID = &tenantID
	} else {
		destination.TenantID = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type ManagedClusterAADProfile_Status struct {
	//AdminGroupObjectIDs: AAD group object IDs that will have admin role of the
	//cluster.
	AdminGroupObjectIDs []string `json:"adminGroupObjectIDs,omitempty"`

	//ClientAppID: The client AAD application ID.
	ClientAppID *string `json:"clientAppID,omitempty"`

	//EnableAzureRBAC: Whether to enable Azure RBAC for Kubernetes authorization.
	EnableAzureRBAC *bool `json:"enableAzureRBAC,omitempty"`

	//Managed: Whether to enable managed AAD.
	Managed *bool `json:"managed,omitempty"`

	//ServerAppID: The server AAD application ID.
	ServerAppID *string `json:"serverAppID,omitempty"`

	//ServerAppSecret: The server AAD application secret.
	ServerAppSecret *string `json:"serverAppSecret,omitempty"`

	//TenantID: The AAD tenant ID to use for authentication. If not specified, will
	//use the tenant of the deployment subscription.
	TenantID *string `json:"tenantID,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterAADProfile_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (managedClusterAADProfileStatus *ManagedClusterAADProfile_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterAADProfile_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (managedClusterAADProfileStatus *ManagedClusterAADProfile_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterAADProfile_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterAADProfile_StatusARM, got %T", armInput)
	}

	// Set property ‘AdminGroupObjectIDs’:
	for _, item := range typedInput.AdminGroupObjectIDs {
		managedClusterAADProfileStatus.AdminGroupObjectIDs = append(managedClusterAADProfileStatus.AdminGroupObjectIDs, item)
	}

	// Set property ‘ClientAppID’:
	if typedInput.ClientAppID != nil {
		clientAppID := *typedInput.ClientAppID
		managedClusterAADProfileStatus.ClientAppID = &clientAppID
	}

	// Set property ‘EnableAzureRBAC’:
	if typedInput.EnableAzureRBAC != nil {
		enableAzureRBAC := *typedInput.EnableAzureRBAC
		managedClusterAADProfileStatus.EnableAzureRBAC = &enableAzureRBAC
	}

	// Set property ‘Managed’:
	if typedInput.Managed != nil {
		managed := *typedInput.Managed
		managedClusterAADProfileStatus.Managed = &managed
	}

	// Set property ‘ServerAppID’:
	if typedInput.ServerAppID != nil {
		serverAppID := *typedInput.ServerAppID
		managedClusterAADProfileStatus.ServerAppID = &serverAppID
	}

	// Set property ‘ServerAppSecret’:
	if typedInput.ServerAppSecret != nil {
		serverAppSecret := *typedInput.ServerAppSecret
		managedClusterAADProfileStatus.ServerAppSecret = &serverAppSecret
	}

	// Set property ‘TenantID’:
	if typedInput.TenantID != nil {
		tenantID := *typedInput.TenantID
		managedClusterAADProfileStatus.TenantID = &tenantID
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterAADProfileStatus populates our ManagedClusterAADProfile_Status from the provided source ManagedClusterAADProfile_Status
func (managedClusterAADProfileStatus *ManagedClusterAADProfile_Status) AssignPropertiesFromManagedClusterAADProfileStatus(source *v1alpha1api20210501storage.ManagedClusterAADProfile_Status) error {

	// AdminGroupObjectIDs
	adminGroupObjectIDList := make([]string, len(source.AdminGroupObjectIDs))
	for adminGroupObjectIDIndex, adminGroupObjectIDItem := range source.AdminGroupObjectIDs {
		// Shadow the loop variable to avoid aliasing
		adminGroupObjectIDItem := adminGroupObjectIDItem
		adminGroupObjectIDList[adminGroupObjectIDIndex] = adminGroupObjectIDItem
	}
	managedClusterAADProfileStatus.AdminGroupObjectIDs = adminGroupObjectIDList

	// ClientAppID
	if source.ClientAppID != nil {
		clientAppID := *source.ClientAppID
		managedClusterAADProfileStatus.ClientAppID = &clientAppID
	} else {
		managedClusterAADProfileStatus.ClientAppID = nil
	}

	// EnableAzureRBAC
	if source.EnableAzureRBAC != nil {
		enableAzureRBAC := *source.EnableAzureRBAC
		managedClusterAADProfileStatus.EnableAzureRBAC = &enableAzureRBAC
	} else {
		managedClusterAADProfileStatus.EnableAzureRBAC = nil
	}

	// Managed
	if source.Managed != nil {
		managed := *source.Managed
		managedClusterAADProfileStatus.Managed = &managed
	} else {
		managedClusterAADProfileStatus.Managed = nil
	}

	// ServerAppID
	if source.ServerAppID != nil {
		serverAppID := *source.ServerAppID
		managedClusterAADProfileStatus.ServerAppID = &serverAppID
	} else {
		managedClusterAADProfileStatus.ServerAppID = nil
	}

	// ServerAppSecret
	if source.ServerAppSecret != nil {
		serverAppSecret := *source.ServerAppSecret
		managedClusterAADProfileStatus.ServerAppSecret = &serverAppSecret
	} else {
		managedClusterAADProfileStatus.ServerAppSecret = nil
	}

	// TenantID
	if source.TenantID != nil {
		tenantID := *source.TenantID
		managedClusterAADProfileStatus.TenantID = &tenantID
	} else {
		managedClusterAADProfileStatus.TenantID = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterAADProfileStatus populates the provided destination ManagedClusterAADProfile_Status from our ManagedClusterAADProfile_Status
func (managedClusterAADProfileStatus *ManagedClusterAADProfile_Status) AssignPropertiesToManagedClusterAADProfileStatus(destination *v1alpha1api20210501storage.ManagedClusterAADProfile_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminGroupObjectIDs
	adminGroupObjectIDList := make([]string, len(managedClusterAADProfileStatus.AdminGroupObjectIDs))
	for adminGroupObjectIDIndex, adminGroupObjectIDItem := range managedClusterAADProfileStatus.AdminGroupObjectIDs {
		// Shadow the loop variable to avoid aliasing
		adminGroupObjectIDItem := adminGroupObjectIDItem
		adminGroupObjectIDList[adminGroupObjectIDIndex] = adminGroupObjectIDItem
	}
	destination.AdminGroupObjectIDs = adminGroupObjectIDList

	// ClientAppID
	if managedClusterAADProfileStatus.ClientAppID != nil {
		clientAppID := *managedClusterAADProfileStatus.ClientAppID
		destination.ClientAppID = &clientAppID
	} else {
		destination.ClientAppID = nil
	}

	// EnableAzureRBAC
	if managedClusterAADProfileStatus.EnableAzureRBAC != nil {
		enableAzureRBAC := *managedClusterAADProfileStatus.EnableAzureRBAC
		destination.EnableAzureRBAC = &enableAzureRBAC
	} else {
		destination.EnableAzureRBAC = nil
	}

	// Managed
	if managedClusterAADProfileStatus.Managed != nil {
		managed := *managedClusterAADProfileStatus.Managed
		destination.Managed = &managed
	} else {
		destination.Managed = nil
	}

	// ServerAppID
	if managedClusterAADProfileStatus.ServerAppID != nil {
		serverAppID := *managedClusterAADProfileStatus.ServerAppID
		destination.ServerAppID = &serverAppID
	} else {
		destination.ServerAppID = nil
	}

	// ServerAppSecret
	if managedClusterAADProfileStatus.ServerAppSecret != nil {
		serverAppSecret := *managedClusterAADProfileStatus.ServerAppSecret
		destination.ServerAppSecret = &serverAppSecret
	} else {
		destination.ServerAppSecret = nil
	}

	// TenantID
	if managedClusterAADProfileStatus.TenantID != nil {
		tenantID := *managedClusterAADProfileStatus.TenantID
		destination.TenantID = &tenantID
	} else {
		destination.TenantID = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2021-05-01/Microsoft.ContainerService.json#/definitions/ManagedClusterAPIServerAccessProfile
type ManagedClusterAPIServerAccessProfile struct {
	//AuthorizedIPRanges: IP ranges are specified in CIDR format, e.g.
	//137.117.106.88/29. This feature is not compatible with clusters that use Public
	//IP Per Node, or clusters that are using a Basic Load Balancer. For more
	//information see [API server authorized IP
	//ranges](https://docs.microsoft.com/azure/aks/api-server-authorized-ip-ranges).
	AuthorizedIPRanges []string `json:"authorizedIPRanges,omitempty"`

	//EnablePrivateCluster: For more details, see [Creating a private AKS
	//cluster](https://docs.microsoft.com/azure/aks/private-clusters).
	EnablePrivateCluster *bool `json:"enablePrivateCluster,omitempty"`

	//EnablePrivateClusterPublicFQDN: Whether to create additional public FQDN for
	//private cluster or not.
	EnablePrivateClusterPublicFQDN *bool `json:"enablePrivateClusterPublicFQDN,omitempty"`

	//PrivateDNSZone: The default is System. For more details see [configure private
	//DNS
	//zone](https://docs.microsoft.com/azure/aks/private-clusters#configure-private-dns-zone).
	//Allowed values are 'system' and 'none'.
	PrivateDNSZone *string `json:"privateDNSZone,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterAPIServerAccessProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (managedClusterAPIServerAccessProfile *ManagedClusterAPIServerAccessProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if managedClusterAPIServerAccessProfile == nil {
		return nil, nil
	}
	var result ManagedClusterAPIServerAccessProfileARM

	// Set property ‘AuthorizedIPRanges’:
	for _, item := range managedClusterAPIServerAccessProfile.AuthorizedIPRanges {
		result.AuthorizedIPRanges = append(result.AuthorizedIPRanges, item)
	}

	// Set property ‘EnablePrivateCluster’:
	if managedClusterAPIServerAccessProfile.EnablePrivateCluster != nil {
		enablePrivateCluster := *managedClusterAPIServerAccessProfile.EnablePrivateCluster
		result.EnablePrivateCluster = &enablePrivateCluster
	}

	// Set property ‘EnablePrivateClusterPublicFQDN’:
	if managedClusterAPIServerAccessProfile.EnablePrivateClusterPublicFQDN != nil {
		enablePrivateClusterPublicFQDN := *managedClusterAPIServerAccessProfile.EnablePrivateClusterPublicFQDN
		result.EnablePrivateClusterPublicFQDN = &enablePrivateClusterPublicFQDN
	}

	// Set property ‘PrivateDNSZone’:
	if managedClusterAPIServerAccessProfile.PrivateDNSZone != nil {
		privateDNSZone := *managedClusterAPIServerAccessProfile.PrivateDNSZone
		result.PrivateDNSZone = &privateDNSZone
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (managedClusterAPIServerAccessProfile *ManagedClusterAPIServerAccessProfile) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterAPIServerAccessProfileARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (managedClusterAPIServerAccessProfile *ManagedClusterAPIServerAccessProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterAPIServerAccessProfileARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterAPIServerAccessProfileARM, got %T", armInput)
	}

	// Set property ‘AuthorizedIPRanges’:
	for _, item := range typedInput.AuthorizedIPRanges {
		managedClusterAPIServerAccessProfile.AuthorizedIPRanges = append(managedClusterAPIServerAccessProfile.AuthorizedIPRanges, item)
	}

	// Set property ‘EnablePrivateCluster’:
	if typedInput.EnablePrivateCluster != nil {
		enablePrivateCluster := *typedInput.EnablePrivateCluster
		managedClusterAPIServerAccessProfile.EnablePrivateCluster = &enablePrivateCluster
	}

	// Set property ‘EnablePrivateClusterPublicFQDN’:
	if typedInput.EnablePrivateClusterPublicFQDN != nil {
		enablePrivateClusterPublicFQDN := *typedInput.EnablePrivateClusterPublicFQDN
		managedClusterAPIServerAccessProfile.EnablePrivateClusterPublicFQDN = &enablePrivateClusterPublicFQDN
	}

	// Set property ‘PrivateDNSZone’:
	if typedInput.PrivateDNSZone != nil {
		privateDNSZone := *typedInput.PrivateDNSZone
		managedClusterAPIServerAccessProfile.PrivateDNSZone = &privateDNSZone
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterAPIServerAccessProfile populates our ManagedClusterAPIServerAccessProfile from the provided source ManagedClusterAPIServerAccessProfile
func (managedClusterAPIServerAccessProfile *ManagedClusterAPIServerAccessProfile) AssignPropertiesFromManagedClusterAPIServerAccessProfile(source *v1alpha1api20210501storage.ManagedClusterAPIServerAccessProfile) error {

	// AuthorizedIPRanges
	authorizedIPRangeList := make([]string, len(source.AuthorizedIPRanges))
	for authorizedIPRangeIndex, authorizedIPRangeItem := range source.AuthorizedIPRanges {
		// Shadow the loop variable to avoid aliasing
		authorizedIPRangeItem := authorizedIPRangeItem
		authorizedIPRangeList[authorizedIPRangeIndex] = authorizedIPRangeItem
	}
	managedClusterAPIServerAccessProfile.AuthorizedIPRanges = authorizedIPRangeList

	// EnablePrivateCluster
	if source.EnablePrivateCluster != nil {
		enablePrivateCluster := *source.EnablePrivateCluster
		managedClusterAPIServerAccessProfile.EnablePrivateCluster = &enablePrivateCluster
	} else {
		managedClusterAPIServerAccessProfile.EnablePrivateCluster = nil
	}

	// EnablePrivateClusterPublicFQDN
	if source.EnablePrivateClusterPublicFQDN != nil {
		enablePrivateClusterPublicFQDN := *source.EnablePrivateClusterPublicFQDN
		managedClusterAPIServerAccessProfile.EnablePrivateClusterPublicFQDN = &enablePrivateClusterPublicFQDN
	} else {
		managedClusterAPIServerAccessProfile.EnablePrivateClusterPublicFQDN = nil
	}

	// PrivateDNSZone
	if source.PrivateDNSZone != nil {
		privateDNSZone := *source.PrivateDNSZone
		managedClusterAPIServerAccessProfile.PrivateDNSZone = &privateDNSZone
	} else {
		managedClusterAPIServerAccessProfile.PrivateDNSZone = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterAPIServerAccessProfile populates the provided destination ManagedClusterAPIServerAccessProfile from our ManagedClusterAPIServerAccessProfile
func (managedClusterAPIServerAccessProfile *ManagedClusterAPIServerAccessProfile) AssignPropertiesToManagedClusterAPIServerAccessProfile(destination *v1alpha1api20210501storage.ManagedClusterAPIServerAccessProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthorizedIPRanges
	authorizedIPRangeList := make([]string, len(managedClusterAPIServerAccessProfile.AuthorizedIPRanges))
	for authorizedIPRangeIndex, authorizedIPRangeItem := range managedClusterAPIServerAccessProfile.AuthorizedIPRanges {
		// Shadow the loop variable to avoid aliasing
		authorizedIPRangeItem := authorizedIPRangeItem
		authorizedIPRangeList[authorizedIPRangeIndex] = authorizedIPRangeItem
	}
	destination.AuthorizedIPRanges = authorizedIPRangeList

	// EnablePrivateCluster
	if managedClusterAPIServerAccessProfile.EnablePrivateCluster != nil {
		enablePrivateCluster := *managedClusterAPIServerAccessProfile.EnablePrivateCluster
		destination.EnablePrivateCluster = &enablePrivateCluster
	} else {
		destination.EnablePrivateCluster = nil
	}

	// EnablePrivateClusterPublicFQDN
	if managedClusterAPIServerAccessProfile.EnablePrivateClusterPublicFQDN != nil {
		enablePrivateClusterPublicFQDN := *managedClusterAPIServerAccessProfile.EnablePrivateClusterPublicFQDN
		destination.EnablePrivateClusterPublicFQDN = &enablePrivateClusterPublicFQDN
	} else {
		destination.EnablePrivateClusterPublicFQDN = nil
	}

	// PrivateDNSZone
	if managedClusterAPIServerAccessProfile.PrivateDNSZone != nil {
		privateDNSZone := *managedClusterAPIServerAccessProfile.PrivateDNSZone
		destination.PrivateDNSZone = &privateDNSZone
	} else {
		destination.PrivateDNSZone = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type ManagedClusterAPIServerAccessProfile_Status struct {
	//AuthorizedIPRanges: Authorized IP Ranges to kubernetes API server.
	AuthorizedIPRanges []string `json:"authorizedIPRanges,omitempty"`

	//EnablePrivateCluster: Whether to create the cluster as a private cluster or not.
	EnablePrivateCluster *bool `json:"enablePrivateCluster,omitempty"`

	//EnablePrivateClusterPublicFQDN: Whether to create additional public FQDN for
	//private cluster or not.
	EnablePrivateClusterPublicFQDN *bool `json:"enablePrivateClusterPublicFQDN,omitempty"`

	//PrivateDNSZone: Private dns zone mode for private cluster.
	PrivateDNSZone *string `json:"privateDNSZone,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterAPIServerAccessProfile_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (managedClusterAPIServerAccessProfileStatus *ManagedClusterAPIServerAccessProfile_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterAPIServerAccessProfile_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (managedClusterAPIServerAccessProfileStatus *ManagedClusterAPIServerAccessProfile_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterAPIServerAccessProfile_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterAPIServerAccessProfile_StatusARM, got %T", armInput)
	}

	// Set property ‘AuthorizedIPRanges’:
	for _, item := range typedInput.AuthorizedIPRanges {
		managedClusterAPIServerAccessProfileStatus.AuthorizedIPRanges = append(managedClusterAPIServerAccessProfileStatus.AuthorizedIPRanges, item)
	}

	// Set property ‘EnablePrivateCluster’:
	if typedInput.EnablePrivateCluster != nil {
		enablePrivateCluster := *typedInput.EnablePrivateCluster
		managedClusterAPIServerAccessProfileStatus.EnablePrivateCluster = &enablePrivateCluster
	}

	// Set property ‘EnablePrivateClusterPublicFQDN’:
	if typedInput.EnablePrivateClusterPublicFQDN != nil {
		enablePrivateClusterPublicFQDN := *typedInput.EnablePrivateClusterPublicFQDN
		managedClusterAPIServerAccessProfileStatus.EnablePrivateClusterPublicFQDN = &enablePrivateClusterPublicFQDN
	}

	// Set property ‘PrivateDNSZone’:
	if typedInput.PrivateDNSZone != nil {
		privateDNSZone := *typedInput.PrivateDNSZone
		managedClusterAPIServerAccessProfileStatus.PrivateDNSZone = &privateDNSZone
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterAPIServerAccessProfileStatus populates our ManagedClusterAPIServerAccessProfile_Status from the provided source ManagedClusterAPIServerAccessProfile_Status
func (managedClusterAPIServerAccessProfileStatus *ManagedClusterAPIServerAccessProfile_Status) AssignPropertiesFromManagedClusterAPIServerAccessProfileStatus(source *v1alpha1api20210501storage.ManagedClusterAPIServerAccessProfile_Status) error {

	// AuthorizedIPRanges
	authorizedIPRangeList := make([]string, len(source.AuthorizedIPRanges))
	for authorizedIPRangeIndex, authorizedIPRangeItem := range source.AuthorizedIPRanges {
		// Shadow the loop variable to avoid aliasing
		authorizedIPRangeItem := authorizedIPRangeItem
		authorizedIPRangeList[authorizedIPRangeIndex] = authorizedIPRangeItem
	}
	managedClusterAPIServerAccessProfileStatus.AuthorizedIPRanges = authorizedIPRangeList

	// EnablePrivateCluster
	if source.EnablePrivateCluster != nil {
		enablePrivateCluster := *source.EnablePrivateCluster
		managedClusterAPIServerAccessProfileStatus.EnablePrivateCluster = &enablePrivateCluster
	} else {
		managedClusterAPIServerAccessProfileStatus.EnablePrivateCluster = nil
	}

	// EnablePrivateClusterPublicFQDN
	if source.EnablePrivateClusterPublicFQDN != nil {
		enablePrivateClusterPublicFQDN := *source.EnablePrivateClusterPublicFQDN
		managedClusterAPIServerAccessProfileStatus.EnablePrivateClusterPublicFQDN = &enablePrivateClusterPublicFQDN
	} else {
		managedClusterAPIServerAccessProfileStatus.EnablePrivateClusterPublicFQDN = nil
	}

	// PrivateDNSZone
	if source.PrivateDNSZone != nil {
		privateDNSZone := *source.PrivateDNSZone
		managedClusterAPIServerAccessProfileStatus.PrivateDNSZone = &privateDNSZone
	} else {
		managedClusterAPIServerAccessProfileStatus.PrivateDNSZone = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterAPIServerAccessProfileStatus populates the provided destination ManagedClusterAPIServerAccessProfile_Status from our ManagedClusterAPIServerAccessProfile_Status
func (managedClusterAPIServerAccessProfileStatus *ManagedClusterAPIServerAccessProfile_Status) AssignPropertiesToManagedClusterAPIServerAccessProfileStatus(destination *v1alpha1api20210501storage.ManagedClusterAPIServerAccessProfile_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthorizedIPRanges
	authorizedIPRangeList := make([]string, len(managedClusterAPIServerAccessProfileStatus.AuthorizedIPRanges))
	for authorizedIPRangeIndex, authorizedIPRangeItem := range managedClusterAPIServerAccessProfileStatus.AuthorizedIPRanges {
		// Shadow the loop variable to avoid aliasing
		authorizedIPRangeItem := authorizedIPRangeItem
		authorizedIPRangeList[authorizedIPRangeIndex] = authorizedIPRangeItem
	}
	destination.AuthorizedIPRanges = authorizedIPRangeList

	// EnablePrivateCluster
	if managedClusterAPIServerAccessProfileStatus.EnablePrivateCluster != nil {
		enablePrivateCluster := *managedClusterAPIServerAccessProfileStatus.EnablePrivateCluster
		destination.EnablePrivateCluster = &enablePrivateCluster
	} else {
		destination.EnablePrivateCluster = nil
	}

	// EnablePrivateClusterPublicFQDN
	if managedClusterAPIServerAccessProfileStatus.EnablePrivateClusterPublicFQDN != nil {
		enablePrivateClusterPublicFQDN := *managedClusterAPIServerAccessProfileStatus.EnablePrivateClusterPublicFQDN
		destination.EnablePrivateClusterPublicFQDN = &enablePrivateClusterPublicFQDN
	} else {
		destination.EnablePrivateClusterPublicFQDN = nil
	}

	// PrivateDNSZone
	if managedClusterAPIServerAccessProfileStatus.PrivateDNSZone != nil {
		privateDNSZone := *managedClusterAPIServerAccessProfileStatus.PrivateDNSZone
		destination.PrivateDNSZone = &privateDNSZone
	} else {
		destination.PrivateDNSZone = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2021-05-01/Microsoft.ContainerService.json#/definitions/ManagedClusterAddonProfile
type ManagedClusterAddonProfile struct {
	//Config: Key-value pairs for configuring an add-on.
	Config map[string]string `json:"config,omitempty"`

	// +kubebuilder:validation:Required
	//Enabled: Whether the add-on is enabled or not.
	Enabled bool `json:"enabled"`
}

var _ genruntime.ARMTransformer = &ManagedClusterAddonProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (managedClusterAddonProfile *ManagedClusterAddonProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if managedClusterAddonProfile == nil {
		return nil, nil
	}
	var result ManagedClusterAddonProfileARM

	// Set property ‘Config’:
	if managedClusterAddonProfile.Config != nil {
		result.Config = make(map[string]string)
		for key, value := range managedClusterAddonProfile.Config {
			result.Config[key] = value
		}
	}

	// Set property ‘Enabled’:
	result.Enabled = managedClusterAddonProfile.Enabled
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (managedClusterAddonProfile *ManagedClusterAddonProfile) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterAddonProfileARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (managedClusterAddonProfile *ManagedClusterAddonProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterAddonProfileARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterAddonProfileARM, got %T", armInput)
	}

	// Set property ‘Config’:
	if typedInput.Config != nil {
		managedClusterAddonProfile.Config = make(map[string]string)
		for key, value := range typedInput.Config {
			managedClusterAddonProfile.Config[key] = value
		}
	}

	// Set property ‘Enabled’:
	managedClusterAddonProfile.Enabled = typedInput.Enabled

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterAddonProfile populates our ManagedClusterAddonProfile from the provided source ManagedClusterAddonProfile
func (managedClusterAddonProfile *ManagedClusterAddonProfile) AssignPropertiesFromManagedClusterAddonProfile(source *v1alpha1api20210501storage.ManagedClusterAddonProfile) error {

	// Config
	configMap := make(map[string]string)
	for configKey, configValue := range source.Config {
		// Shadow the loop variable to avoid aliasing
		configValue := configValue
		configMap[configKey] = configValue
	}
	managedClusterAddonProfile.Config = configMap

	// Enabled
	if source.Enabled != nil {
		managedClusterAddonProfile.Enabled = *source.Enabled
	} else {
		managedClusterAddonProfile.Enabled = false
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterAddonProfile populates the provided destination ManagedClusterAddonProfile from our ManagedClusterAddonProfile
func (managedClusterAddonProfile *ManagedClusterAddonProfile) AssignPropertiesToManagedClusterAddonProfile(destination *v1alpha1api20210501storage.ManagedClusterAddonProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Config
	configMap := make(map[string]string)
	for configKey, configValue := range managedClusterAddonProfile.Config {
		// Shadow the loop variable to avoid aliasing
		configValue := configValue
		configMap[configKey] = configValue
	}
	destination.Config = configMap

	// Enabled
	enabled := managedClusterAddonProfile.Enabled
	destination.Enabled = &enabled

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2021-05-01/Microsoft.ContainerService.json#/definitions/ManagedClusterAgentPoolProfile
type ManagedClusterAgentPoolProfile struct {
	//AvailabilityZones: The list of Availability zones to use for nodes. This can
	//only be specified if the AgentPoolType property is 'VirtualMachineScaleSets'.
	AvailabilityZones []string `json:"availabilityZones,omitempty"`

	//Count: Number of agents (VMs) to host docker containers. Allowed values must be
	//in the range of 0 to 1000 (inclusive) for user pools and in the range of 1 to
	//1000 (inclusive) for system pools. The default value is 1.
	Count *int `json:"count,omitempty"`

	//EnableAutoScaling: Whether to enable auto-scaler
	EnableAutoScaling *bool `json:"enableAutoScaling,omitempty"`

	//EnableEncryptionAtHost: This is only supported on certain VM sizes and in
	//certain Azure regions. For more information, see:
	//https://docs.microsoft.com/azure/aks/enable-host-encryption
	EnableEncryptionAtHost *bool `json:"enableEncryptionAtHost,omitempty"`

	//EnableFIPS: See [Add a FIPS-enabled node
	//pool](https://docs.microsoft.com/azure/aks/use-multiple-node-pools#add-a-fips-enabled-node-pool-preview)
	//for more details.
	EnableFIPS *bool `json:"enableFIPS,omitempty"`

	//EnableNodePublicIP: Some scenarios may require nodes in a node pool to receive
	//their own dedicated public IP addresses. A common scenario is for gaming
	//workloads, where a console needs to make a direct connection to a cloud virtual
	//machine to minimize hops. For more information see [assigning a public IP per
	//node](https://docs.microsoft.com/azure/aks/use-multiple-node-pools#assign-a-public-ip-per-node-for-your-node-pools).
	//The default is false.
	EnableNodePublicIP *bool `json:"enableNodePublicIP,omitempty"`

	//EnableUltraSSD: Whether to enable UltraSSD
	EnableUltraSSD *bool `json:"enableUltraSSD,omitempty"`

	//GpuInstanceProfile: GPUInstanceProfile to be used to specify GPU MIG instance
	//profile for supported GPU VM SKU.
	GpuInstanceProfile *ManagedClusterAgentPoolProfileGpuInstanceProfile `json:"gpuInstanceProfile,omitempty"`

	//KubeletConfig: See [AKS custom node
	//configuration](https://docs.microsoft.com/azure/aks/custom-node-configuration)
	//for more details.
	KubeletConfig   *KubeletConfig                                 `json:"kubeletConfig,omitempty"`
	KubeletDiskType *ManagedClusterAgentPoolProfileKubeletDiskType `json:"kubeletDiskType,omitempty"`

	//LinuxOSConfig: See [AKS custom node
	//configuration](https://docs.microsoft.com/azure/aks/custom-node-configuration)
	//for more details.
	LinuxOSConfig *LinuxOSConfig `json:"linuxOSConfig,omitempty"`

	//MaxCount: The maximum number of nodes for auto-scaling
	MaxCount *int `json:"maxCount,omitempty"`

	//MaxPods: The maximum number of pods that can run on a node.
	MaxPods *int `json:"maxPods,omitempty"`

	//MinCount: The minimum number of nodes for auto-scaling
	MinCount *int                                `json:"minCount,omitempty"`
	Mode     *ManagedClusterAgentPoolProfileMode `json:"mode,omitempty"`

	// +kubebuilder:validation:Required
	// +kubebuilder:validation:Pattern="^[a-z][a-z0-9]{0,11}$"
	//Name: Windows agent pool names must be 6 characters or less.
	Name string `json:"name"`

	//NodeLabels: The node labels to be persisted across all nodes in agent pool.
	NodeLabels map[string]string `json:"nodeLabels,omitempty"`

	//NodePublicIPPrefixIDReference: This is of the form:
	///subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/publicIPPrefixes/{publicIPPrefixName}
	NodePublicIPPrefixIDReference *genruntime.ResourceReference `armReference:"NodePublicIPPrefixID" json:"nodePublicIPPrefixIDReference,omitempty"`

	//NodeTaints: The taints added to new nodes during node pool create and scale. For
	//example, key=value:NoSchedule.
	NodeTaints []string `json:"nodeTaints,omitempty"`

	//OrchestratorVersion: As a best practice, you should upgrade all node pools in an
	//AKS cluster to the same Kubernetes version. The node pool version must have the
	//same major version as the control plane. The node pool minor version must be
	//within two minor versions of the control plane version. The node pool version
	//cannot be greater than the control plane version. For more information see
	//[upgrading a node
	//pool](https://docs.microsoft.com/azure/aks/use-multiple-node-pools#upgrade-a-node-pool).
	OrchestratorVersion *string `json:"orchestratorVersion,omitempty"`

	// +kubebuilder:validation:Maximum=2048
	// +kubebuilder:validation:Minimum=0
	//OsDiskSizeGB: OS Disk Size in GB to be used to specify the disk size for every
	//machine in the master/agent pool. If you specify 0, it will apply the default
	//osDisk size according to the vmSize specified.
	OsDiskSizeGB *int                                      `json:"osDiskSizeGB,omitempty"`
	OsDiskType   *ManagedClusterAgentPoolProfileOsDiskType `json:"osDiskType,omitempty"`
	OsSKU        *ManagedClusterAgentPoolProfileOsSKU      `json:"osSKU,omitempty"`
	OsType       *ManagedClusterAgentPoolProfileOsType     `json:"osType,omitempty"`

	//PodSubnetIDReference: If omitted, pod IPs are statically assigned on the node
	//subnet (see vnetSubnetID for more details). This is of the form:
	///subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}
	PodSubnetIDReference *genruntime.ResourceReference `armReference:"PodSubnetID" json:"podSubnetIDReference,omitempty"`

	//ProximityPlacementGroupID: The ID for Proximity Placement Group.
	ProximityPlacementGroupID *string `json:"proximityPlacementGroupID,omitempty"`

	//ScaleSetEvictionPolicy: This cannot be specified unless the scaleSetPriority is
	//'Spot'. If not specified, the default is 'Delete'.
	ScaleSetEvictionPolicy *ManagedClusterAgentPoolProfileScaleSetEvictionPolicy `json:"scaleSetEvictionPolicy,omitempty"`

	//ScaleSetPriority: The Virtual Machine Scale Set priority. If not specified, the
	//default is 'Regular'.
	ScaleSetPriority *ManagedClusterAgentPoolProfileScaleSetPriority `json:"scaleSetPriority,omitempty"`

	//SpotMaxPrice: Possible values are any decimal value greater than zero or -1
	//which indicates the willingness to pay any on-demand price. For more details on
	//spot pricing, see [spot VMs
	//pricing](https://docs.microsoft.com/azure/virtual-machines/spot-vms#pricing)
	SpotMaxPrice *float64 `json:"spotMaxPrice,omitempty"`

	//Tags: The tags to be persisted on the agent pool virtual machine scale set.
	Tags map[string]string                   `json:"tags,omitempty"`
	Type *ManagedClusterAgentPoolProfileType `json:"type,omitempty"`

	//UpgradeSettings: Settings for upgrading an agentpool
	UpgradeSettings *AgentPoolUpgradeSettings `json:"upgradeSettings,omitempty"`

	//VmSize: VM size availability varies by region. If a node contains insufficient
	//compute resources (memory, cpu, etc) pods might fail to run correctly. For more
	//details on restricted VM sizes, see:
	//https://docs.microsoft.com/azure/aks/quotas-skus-regions
	VmSize *string `json:"vmSize,omitempty"`

	//VnetSubnetIDReference: If this is not specified, a VNET and subnet will be
	//generated and used. If no podSubnetID is specified, this applies to nodes and
	//pods, otherwise it applies to just nodes. This is of the form:
	///subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}
	VnetSubnetIDReference *genruntime.ResourceReference `armReference:"VnetSubnetID" json:"vnetSubnetIDReference,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterAgentPoolProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (managedClusterAgentPoolProfile *ManagedClusterAgentPoolProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if managedClusterAgentPoolProfile == nil {
		return nil, nil
	}
	var result ManagedClusterAgentPoolProfileARM

	// Set property ‘AvailabilityZones’:
	for _, item := range managedClusterAgentPoolProfile.AvailabilityZones {
		result.AvailabilityZones = append(result.AvailabilityZones, item)
	}

	// Set property ‘Count’:
	if managedClusterAgentPoolProfile.Count != nil {
		count := *managedClusterAgentPoolProfile.Count
		result.Count = &count
	}

	// Set property ‘EnableAutoScaling’:
	if managedClusterAgentPoolProfile.EnableAutoScaling != nil {
		enableAutoScaling := *managedClusterAgentPoolProfile.EnableAutoScaling
		result.EnableAutoScaling = &enableAutoScaling
	}

	// Set property ‘EnableEncryptionAtHost’:
	if managedClusterAgentPoolProfile.EnableEncryptionAtHost != nil {
		enableEncryptionAtHost := *managedClusterAgentPoolProfile.EnableEncryptionAtHost
		result.EnableEncryptionAtHost = &enableEncryptionAtHost
	}

	// Set property ‘EnableFIPS’:
	if managedClusterAgentPoolProfile.EnableFIPS != nil {
		enableFIPS := *managedClusterAgentPoolProfile.EnableFIPS
		result.EnableFIPS = &enableFIPS
	}

	// Set property ‘EnableNodePublicIP’:
	if managedClusterAgentPoolProfile.EnableNodePublicIP != nil {
		enableNodePublicIP := *managedClusterAgentPoolProfile.EnableNodePublicIP
		result.EnableNodePublicIP = &enableNodePublicIP
	}

	// Set property ‘EnableUltraSSD’:
	if managedClusterAgentPoolProfile.EnableUltraSSD != nil {
		enableUltraSSD := *managedClusterAgentPoolProfile.EnableUltraSSD
		result.EnableUltraSSD = &enableUltraSSD
	}

	// Set property ‘GpuInstanceProfile’:
	if managedClusterAgentPoolProfile.GpuInstanceProfile != nil {
		gpuInstanceProfile := *managedClusterAgentPoolProfile.GpuInstanceProfile
		result.GpuInstanceProfile = &gpuInstanceProfile
	}

	// Set property ‘KubeletConfig’:
	if managedClusterAgentPoolProfile.KubeletConfig != nil {
		kubeletConfigARM, err := (*managedClusterAgentPoolProfile.KubeletConfig).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		kubeletConfig := kubeletConfigARM.(KubeletConfigARM)
		result.KubeletConfig = &kubeletConfig
	}

	// Set property ‘KubeletDiskType’:
	if managedClusterAgentPoolProfile.KubeletDiskType != nil {
		kubeletDiskType := *managedClusterAgentPoolProfile.KubeletDiskType
		result.KubeletDiskType = &kubeletDiskType
	}

	// Set property ‘LinuxOSConfig’:
	if managedClusterAgentPoolProfile.LinuxOSConfig != nil {
		linuxOSConfigARM, err := (*managedClusterAgentPoolProfile.LinuxOSConfig).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		linuxOSConfig := linuxOSConfigARM.(LinuxOSConfigARM)
		result.LinuxOSConfig = &linuxOSConfig
	}

	// Set property ‘MaxCount’:
	if managedClusterAgentPoolProfile.MaxCount != nil {
		maxCount := *managedClusterAgentPoolProfile.MaxCount
		result.MaxCount = &maxCount
	}

	// Set property ‘MaxPods’:
	if managedClusterAgentPoolProfile.MaxPods != nil {
		maxPods := *managedClusterAgentPoolProfile.MaxPods
		result.MaxPods = &maxPods
	}

	// Set property ‘MinCount’:
	if managedClusterAgentPoolProfile.MinCount != nil {
		minCount := *managedClusterAgentPoolProfile.MinCount
		result.MinCount = &minCount
	}

	// Set property ‘Mode’:
	if managedClusterAgentPoolProfile.Mode != nil {
		mode := *managedClusterAgentPoolProfile.Mode
		result.Mode = &mode
	}

	// Set property ‘Name’:
	result.Name = managedClusterAgentPoolProfile.Name

	// Set property ‘NodeLabels’:
	if managedClusterAgentPoolProfile.NodeLabels != nil {
		result.NodeLabels = make(map[string]string)
		for key, value := range managedClusterAgentPoolProfile.NodeLabels {
			result.NodeLabels[key] = value
		}
	}

	// Set property ‘NodePublicIPPrefixID’:
	if managedClusterAgentPoolProfile.NodePublicIPPrefixIDReference != nil {
		nodePublicIPPrefixIDReferenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*managedClusterAgentPoolProfile.NodePublicIPPrefixIDReference)
		if err != nil {
			return nil, err
		}
		nodePublicIPPrefixIDReference := nodePublicIPPrefixIDReferenceARMID
		result.NodePublicIPPrefixID = &nodePublicIPPrefixIDReference
	}

	// Set property ‘NodeTaints’:
	for _, item := range managedClusterAgentPoolProfile.NodeTaints {
		result.NodeTaints = append(result.NodeTaints, item)
	}

	// Set property ‘OrchestratorVersion’:
	if managedClusterAgentPoolProfile.OrchestratorVersion != nil {
		orchestratorVersion := *managedClusterAgentPoolProfile.OrchestratorVersion
		result.OrchestratorVersion = &orchestratorVersion
	}

	// Set property ‘OsDiskSizeGB’:
	if managedClusterAgentPoolProfile.OsDiskSizeGB != nil {
		osDiskSizeGB := *managedClusterAgentPoolProfile.OsDiskSizeGB
		result.OsDiskSizeGB = &osDiskSizeGB
	}

	// Set property ‘OsDiskType’:
	if managedClusterAgentPoolProfile.OsDiskType != nil {
		osDiskType := *managedClusterAgentPoolProfile.OsDiskType
		result.OsDiskType = &osDiskType
	}

	// Set property ‘OsSKU’:
	if managedClusterAgentPoolProfile.OsSKU != nil {
		osSKU := *managedClusterAgentPoolProfile.OsSKU
		result.OsSKU = &osSKU
	}

	// Set property ‘OsType’:
	if managedClusterAgentPoolProfile.OsType != nil {
		osType := *managedClusterAgentPoolProfile.OsType
		result.OsType = &osType
	}

	// Set property ‘PodSubnetID’:
	if managedClusterAgentPoolProfile.PodSubnetIDReference != nil {
		podSubnetIDReferenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*managedClusterAgentPoolProfile.PodSubnetIDReference)
		if err != nil {
			return nil, err
		}
		podSubnetIDReference := podSubnetIDReferenceARMID
		result.PodSubnetID = &podSubnetIDReference
	}

	// Set property ‘ProximityPlacementGroupID’:
	if managedClusterAgentPoolProfile.ProximityPlacementGroupID != nil {
		proximityPlacementGroupID := *managedClusterAgentPoolProfile.ProximityPlacementGroupID
		result.ProximityPlacementGroupID = &proximityPlacementGroupID
	}

	// Set property ‘ScaleSetEvictionPolicy’:
	if managedClusterAgentPoolProfile.ScaleSetEvictionPolicy != nil {
		scaleSetEvictionPolicy := *managedClusterAgentPoolProfile.ScaleSetEvictionPolicy
		result.ScaleSetEvictionPolicy = &scaleSetEvictionPolicy
	}

	// Set property ‘ScaleSetPriority’:
	if managedClusterAgentPoolProfile.ScaleSetPriority != nil {
		scaleSetPriority := *managedClusterAgentPoolProfile.ScaleSetPriority
		result.ScaleSetPriority = &scaleSetPriority
	}

	// Set property ‘SpotMaxPrice’:
	if managedClusterAgentPoolProfile.SpotMaxPrice != nil {
		spotMaxPrice := *managedClusterAgentPoolProfile.SpotMaxPrice
		result.SpotMaxPrice = &spotMaxPrice
	}

	// Set property ‘Tags’:
	if managedClusterAgentPoolProfile.Tags != nil {
		result.Tags = make(map[string]string)
		for key, value := range managedClusterAgentPoolProfile.Tags {
			result.Tags[key] = value
		}
	}

	// Set property ‘Type’:
	if managedClusterAgentPoolProfile.Type != nil {
		typeVar := *managedClusterAgentPoolProfile.Type
		result.Type = &typeVar
	}

	// Set property ‘UpgradeSettings’:
	if managedClusterAgentPoolProfile.UpgradeSettings != nil {
		upgradeSettingsARM, err := (*managedClusterAgentPoolProfile.UpgradeSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		upgradeSettings := upgradeSettingsARM.(AgentPoolUpgradeSettingsARM)
		result.UpgradeSettings = &upgradeSettings
	}

	// Set property ‘VmSize’:
	if managedClusterAgentPoolProfile.VmSize != nil {
		vmSize := *managedClusterAgentPoolProfile.VmSize
		result.VmSize = &vmSize
	}

	// Set property ‘VnetSubnetID’:
	if managedClusterAgentPoolProfile.VnetSubnetIDReference != nil {
		vnetSubnetIDReferenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*managedClusterAgentPoolProfile.VnetSubnetIDReference)
		if err != nil {
			return nil, err
		}
		vnetSubnetIDReference := vnetSubnetIDReferenceARMID
		result.VnetSubnetID = &vnetSubnetIDReference
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (managedClusterAgentPoolProfile *ManagedClusterAgentPoolProfile) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterAgentPoolProfileARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (managedClusterAgentPoolProfile *ManagedClusterAgentPoolProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterAgentPoolProfileARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterAgentPoolProfileARM, got %T", armInput)
	}

	// Set property ‘AvailabilityZones’:
	for _, item := range typedInput.AvailabilityZones {
		managedClusterAgentPoolProfile.AvailabilityZones = append(managedClusterAgentPoolProfile.AvailabilityZones, item)
	}

	// Set property ‘Count’:
	if typedInput.Count != nil {
		count := *typedInput.Count
		managedClusterAgentPoolProfile.Count = &count
	}

	// Set property ‘EnableAutoScaling’:
	if typedInput.EnableAutoScaling != nil {
		enableAutoScaling := *typedInput.EnableAutoScaling
		managedClusterAgentPoolProfile.EnableAutoScaling = &enableAutoScaling
	}

	// Set property ‘EnableEncryptionAtHost’:
	if typedInput.EnableEncryptionAtHost != nil {
		enableEncryptionAtHost := *typedInput.EnableEncryptionAtHost
		managedClusterAgentPoolProfile.EnableEncryptionAtHost = &enableEncryptionAtHost
	}

	// Set property ‘EnableFIPS’:
	if typedInput.EnableFIPS != nil {
		enableFIPS := *typedInput.EnableFIPS
		managedClusterAgentPoolProfile.EnableFIPS = &enableFIPS
	}

	// Set property ‘EnableNodePublicIP’:
	if typedInput.EnableNodePublicIP != nil {
		enableNodePublicIP := *typedInput.EnableNodePublicIP
		managedClusterAgentPoolProfile.EnableNodePublicIP = &enableNodePublicIP
	}

	// Set property ‘EnableUltraSSD’:
	if typedInput.EnableUltraSSD != nil {
		enableUltraSSD := *typedInput.EnableUltraSSD
		managedClusterAgentPoolProfile.EnableUltraSSD = &enableUltraSSD
	}

	// Set property ‘GpuInstanceProfile’:
	if typedInput.GpuInstanceProfile != nil {
		gpuInstanceProfile := *typedInput.GpuInstanceProfile
		managedClusterAgentPoolProfile.GpuInstanceProfile = &gpuInstanceProfile
	}

	// Set property ‘KubeletConfig’:
	if typedInput.KubeletConfig != nil {
		var kubeletConfig1 KubeletConfig
		err := kubeletConfig1.PopulateFromARM(owner, *typedInput.KubeletConfig)
		if err != nil {
			return err
		}
		kubeletConfig := kubeletConfig1
		managedClusterAgentPoolProfile.KubeletConfig = &kubeletConfig
	}

	// Set property ‘KubeletDiskType’:
	if typedInput.KubeletDiskType != nil {
		kubeletDiskType := *typedInput.KubeletDiskType
		managedClusterAgentPoolProfile.KubeletDiskType = &kubeletDiskType
	}

	// Set property ‘LinuxOSConfig’:
	if typedInput.LinuxOSConfig != nil {
		var linuxOSConfig1 LinuxOSConfig
		err := linuxOSConfig1.PopulateFromARM(owner, *typedInput.LinuxOSConfig)
		if err != nil {
			return err
		}
		linuxOSConfig := linuxOSConfig1
		managedClusterAgentPoolProfile.LinuxOSConfig = &linuxOSConfig
	}

	// Set property ‘MaxCount’:
	if typedInput.MaxCount != nil {
		maxCount := *typedInput.MaxCount
		managedClusterAgentPoolProfile.MaxCount = &maxCount
	}

	// Set property ‘MaxPods’:
	if typedInput.MaxPods != nil {
		maxPods := *typedInput.MaxPods
		managedClusterAgentPoolProfile.MaxPods = &maxPods
	}

	// Set property ‘MinCount’:
	if typedInput.MinCount != nil {
		minCount := *typedInput.MinCount
		managedClusterAgentPoolProfile.MinCount = &minCount
	}

	// Set property ‘Mode’:
	if typedInput.Mode != nil {
		mode := *typedInput.Mode
		managedClusterAgentPoolProfile.Mode = &mode
	}

	// Set property ‘Name’:
	managedClusterAgentPoolProfile.Name = typedInput.Name

	// Set property ‘NodeLabels’:
	if typedInput.NodeLabels != nil {
		managedClusterAgentPoolProfile.NodeLabels = make(map[string]string)
		for key, value := range typedInput.NodeLabels {
			managedClusterAgentPoolProfile.NodeLabels[key] = value
		}
	}

	// no assignment for property ‘NodePublicIPPrefixIDReference’

	// Set property ‘NodeTaints’:
	for _, item := range typedInput.NodeTaints {
		managedClusterAgentPoolProfile.NodeTaints = append(managedClusterAgentPoolProfile.NodeTaints, item)
	}

	// Set property ‘OrchestratorVersion’:
	if typedInput.OrchestratorVersion != nil {
		orchestratorVersion := *typedInput.OrchestratorVersion
		managedClusterAgentPoolProfile.OrchestratorVersion = &orchestratorVersion
	}

	// Set property ‘OsDiskSizeGB’:
	if typedInput.OsDiskSizeGB != nil {
		osDiskSizeGB := *typedInput.OsDiskSizeGB
		managedClusterAgentPoolProfile.OsDiskSizeGB = &osDiskSizeGB
	}

	// Set property ‘OsDiskType’:
	if typedInput.OsDiskType != nil {
		osDiskType := *typedInput.OsDiskType
		managedClusterAgentPoolProfile.OsDiskType = &osDiskType
	}

	// Set property ‘OsSKU’:
	if typedInput.OsSKU != nil {
		osSKU := *typedInput.OsSKU
		managedClusterAgentPoolProfile.OsSKU = &osSKU
	}

	// Set property ‘OsType’:
	if typedInput.OsType != nil {
		osType := *typedInput.OsType
		managedClusterAgentPoolProfile.OsType = &osType
	}

	// no assignment for property ‘PodSubnetIDReference’

	// Set property ‘ProximityPlacementGroupID’:
	if typedInput.ProximityPlacementGroupID != nil {
		proximityPlacementGroupID := *typedInput.ProximityPlacementGroupID
		managedClusterAgentPoolProfile.ProximityPlacementGroupID = &proximityPlacementGroupID
	}

	// Set property ‘ScaleSetEvictionPolicy’:
	if typedInput.ScaleSetEvictionPolicy != nil {
		scaleSetEvictionPolicy := *typedInput.ScaleSetEvictionPolicy
		managedClusterAgentPoolProfile.ScaleSetEvictionPolicy = &scaleSetEvictionPolicy
	}

	// Set property ‘ScaleSetPriority’:
	if typedInput.ScaleSetPriority != nil {
		scaleSetPriority := *typedInput.ScaleSetPriority
		managedClusterAgentPoolProfile.ScaleSetPriority = &scaleSetPriority
	}

	// Set property ‘SpotMaxPrice’:
	if typedInput.SpotMaxPrice != nil {
		spotMaxPrice := *typedInput.SpotMaxPrice
		managedClusterAgentPoolProfile.SpotMaxPrice = &spotMaxPrice
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		managedClusterAgentPoolProfile.Tags = make(map[string]string)
		for key, value := range typedInput.Tags {
			managedClusterAgentPoolProfile.Tags[key] = value
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		managedClusterAgentPoolProfile.Type = &typeVar
	}

	// Set property ‘UpgradeSettings’:
	if typedInput.UpgradeSettings != nil {
		var upgradeSettings1 AgentPoolUpgradeSettings
		err := upgradeSettings1.PopulateFromARM(owner, *typedInput.UpgradeSettings)
		if err != nil {
			return err
		}
		upgradeSettings := upgradeSettings1
		managedClusterAgentPoolProfile.UpgradeSettings = &upgradeSettings
	}

	// Set property ‘VmSize’:
	if typedInput.VmSize != nil {
		vmSize := *typedInput.VmSize
		managedClusterAgentPoolProfile.VmSize = &vmSize
	}

	// no assignment for property ‘VnetSubnetIDReference’

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterAgentPoolProfile populates our ManagedClusterAgentPoolProfile from the provided source ManagedClusterAgentPoolProfile
func (managedClusterAgentPoolProfile *ManagedClusterAgentPoolProfile) AssignPropertiesFromManagedClusterAgentPoolProfile(source *v1alpha1api20210501storage.ManagedClusterAgentPoolProfile) error {

	// AvailabilityZones
	availabilityZoneList := make([]string, len(source.AvailabilityZones))
	for availabilityZoneIndex, availabilityZoneItem := range source.AvailabilityZones {
		// Shadow the loop variable to avoid aliasing
		availabilityZoneItem := availabilityZoneItem
		availabilityZoneList[availabilityZoneIndex] = availabilityZoneItem
	}
	managedClusterAgentPoolProfile.AvailabilityZones = availabilityZoneList

	// Count
	if source.Count != nil {
		count := *source.Count
		managedClusterAgentPoolProfile.Count = &count
	} else {
		managedClusterAgentPoolProfile.Count = nil
	}

	// EnableAutoScaling
	if source.EnableAutoScaling != nil {
		enableAutoScaling := *source.EnableAutoScaling
		managedClusterAgentPoolProfile.EnableAutoScaling = &enableAutoScaling
	} else {
		managedClusterAgentPoolProfile.EnableAutoScaling = nil
	}

	// EnableEncryptionAtHost
	if source.EnableEncryptionAtHost != nil {
		enableEncryptionAtHost := *source.EnableEncryptionAtHost
		managedClusterAgentPoolProfile.EnableEncryptionAtHost = &enableEncryptionAtHost
	} else {
		managedClusterAgentPoolProfile.EnableEncryptionAtHost = nil
	}

	// EnableFIPS
	if source.EnableFIPS != nil {
		enableFIPS := *source.EnableFIPS
		managedClusterAgentPoolProfile.EnableFIPS = &enableFIPS
	} else {
		managedClusterAgentPoolProfile.EnableFIPS = nil
	}

	// EnableNodePublicIP
	if source.EnableNodePublicIP != nil {
		enableNodePublicIP := *source.EnableNodePublicIP
		managedClusterAgentPoolProfile.EnableNodePublicIP = &enableNodePublicIP
	} else {
		managedClusterAgentPoolProfile.EnableNodePublicIP = nil
	}

	// EnableUltraSSD
	if source.EnableUltraSSD != nil {
		enableUltraSSD := *source.EnableUltraSSD
		managedClusterAgentPoolProfile.EnableUltraSSD = &enableUltraSSD
	} else {
		managedClusterAgentPoolProfile.EnableUltraSSD = nil
	}

	// GpuInstanceProfile
	if source.GpuInstanceProfile != nil {
		gpuInstanceProfile := ManagedClusterAgentPoolProfileGpuInstanceProfile(*source.GpuInstanceProfile)
		managedClusterAgentPoolProfile.GpuInstanceProfile = &gpuInstanceProfile
	} else {
		managedClusterAgentPoolProfile.GpuInstanceProfile = nil
	}

	// KubeletConfig
	if source.KubeletConfig != nil {
		var kubeletConfig KubeletConfig
		err := kubeletConfig.AssignPropertiesFromKubeletConfig(source.KubeletConfig)
		if err != nil {
			return errors.Wrap(err, "populating KubeletConfig from KubeletConfig, calling AssignPropertiesFromKubeletConfig()")
		}
		managedClusterAgentPoolProfile.KubeletConfig = &kubeletConfig
	} else {
		managedClusterAgentPoolProfile.KubeletConfig = nil
	}

	// KubeletDiskType
	if source.KubeletDiskType != nil {
		kubeletDiskType := ManagedClusterAgentPoolProfileKubeletDiskType(*source.KubeletDiskType)
		managedClusterAgentPoolProfile.KubeletDiskType = &kubeletDiskType
	} else {
		managedClusterAgentPoolProfile.KubeletDiskType = nil
	}

	// LinuxOSConfig
	if source.LinuxOSConfig != nil {
		var linuxOSConfig LinuxOSConfig
		err := linuxOSConfig.AssignPropertiesFromLinuxOSConfig(source.LinuxOSConfig)
		if err != nil {
			return errors.Wrap(err, "populating LinuxOSConfig from LinuxOSConfig, calling AssignPropertiesFromLinuxOSConfig()")
		}
		managedClusterAgentPoolProfile.LinuxOSConfig = &linuxOSConfig
	} else {
		managedClusterAgentPoolProfile.LinuxOSConfig = nil
	}

	// MaxCount
	if source.MaxCount != nil {
		maxCount := *source.MaxCount
		managedClusterAgentPoolProfile.MaxCount = &maxCount
	} else {
		managedClusterAgentPoolProfile.MaxCount = nil
	}

	// MaxPods
	if source.MaxPods != nil {
		maxPod := *source.MaxPods
		managedClusterAgentPoolProfile.MaxPods = &maxPod
	} else {
		managedClusterAgentPoolProfile.MaxPods = nil
	}

	// MinCount
	if source.MinCount != nil {
		minCount := *source.MinCount
		managedClusterAgentPoolProfile.MinCount = &minCount
	} else {
		managedClusterAgentPoolProfile.MinCount = nil
	}

	// Mode
	if source.Mode != nil {
		mode := ManagedClusterAgentPoolProfileMode(*source.Mode)
		managedClusterAgentPoolProfile.Mode = &mode
	} else {
		managedClusterAgentPoolProfile.Mode = nil
	}

	// Name
	if source.Name != nil {
		managedClusterAgentPoolProfile.Name = *source.Name
	} else {
		managedClusterAgentPoolProfile.Name = ""
	}

	// NodeLabels
	nodeLabelMap := make(map[string]string)
	for nodeLabelKey, nodeLabelValue := range source.NodeLabels {
		// Shadow the loop variable to avoid aliasing
		nodeLabelValue := nodeLabelValue
		nodeLabelMap[nodeLabelKey] = nodeLabelValue
	}
	managedClusterAgentPoolProfile.NodeLabels = nodeLabelMap

	// NodePublicIPPrefixIDReference
	if source.NodePublicIPPrefixIDReference != nil {
		nodePublicIPPrefixIDReference := source.NodePublicIPPrefixIDReference.Copy()
		managedClusterAgentPoolProfile.NodePublicIPPrefixIDReference = &nodePublicIPPrefixIDReference
	} else {
		managedClusterAgentPoolProfile.NodePublicIPPrefixIDReference = nil
	}

	// NodeTaints
	nodeTaintList := make([]string, len(source.NodeTaints))
	for nodeTaintIndex, nodeTaintItem := range source.NodeTaints {
		// Shadow the loop variable to avoid aliasing
		nodeTaintItem := nodeTaintItem
		nodeTaintList[nodeTaintIndex] = nodeTaintItem
	}
	managedClusterAgentPoolProfile.NodeTaints = nodeTaintList

	// OrchestratorVersion
	if source.OrchestratorVersion != nil {
		orchestratorVersion := *source.OrchestratorVersion
		managedClusterAgentPoolProfile.OrchestratorVersion = &orchestratorVersion
	} else {
		managedClusterAgentPoolProfile.OrchestratorVersion = nil
	}

	// OsDiskSizeGB
	if source.OsDiskSizeGB != nil {
		osDiskSizeGB := *source.OsDiskSizeGB
		managedClusterAgentPoolProfile.OsDiskSizeGB = &osDiskSizeGB
	} else {
		managedClusterAgentPoolProfile.OsDiskSizeGB = nil
	}

	// OsDiskType
	if source.OsDiskType != nil {
		osDiskType := ManagedClusterAgentPoolProfileOsDiskType(*source.OsDiskType)
		managedClusterAgentPoolProfile.OsDiskType = &osDiskType
	} else {
		managedClusterAgentPoolProfile.OsDiskType = nil
	}

	// OsSKU
	if source.OsSKU != nil {
		osSKU := ManagedClusterAgentPoolProfileOsSKU(*source.OsSKU)
		managedClusterAgentPoolProfile.OsSKU = &osSKU
	} else {
		managedClusterAgentPoolProfile.OsSKU = nil
	}

	// OsType
	if source.OsType != nil {
		osType := ManagedClusterAgentPoolProfileOsType(*source.OsType)
		managedClusterAgentPoolProfile.OsType = &osType
	} else {
		managedClusterAgentPoolProfile.OsType = nil
	}

	// PodSubnetIDReference
	if source.PodSubnetIDReference != nil {
		podSubnetIDReference := source.PodSubnetIDReference.Copy()
		managedClusterAgentPoolProfile.PodSubnetIDReference = &podSubnetIDReference
	} else {
		managedClusterAgentPoolProfile.PodSubnetIDReference = nil
	}

	// ProximityPlacementGroupID
	if source.ProximityPlacementGroupID != nil {
		proximityPlacementGroupID := *source.ProximityPlacementGroupID
		managedClusterAgentPoolProfile.ProximityPlacementGroupID = &proximityPlacementGroupID
	} else {
		managedClusterAgentPoolProfile.ProximityPlacementGroupID = nil
	}

	// ScaleSetEvictionPolicy
	if source.ScaleSetEvictionPolicy != nil {
		scaleSetEvictionPolicy := ManagedClusterAgentPoolProfileScaleSetEvictionPolicy(*source.ScaleSetEvictionPolicy)
		managedClusterAgentPoolProfile.ScaleSetEvictionPolicy = &scaleSetEvictionPolicy
	} else {
		managedClusterAgentPoolProfile.ScaleSetEvictionPolicy = nil
	}

	// ScaleSetPriority
	if source.ScaleSetPriority != nil {
		scaleSetPriority := ManagedClusterAgentPoolProfileScaleSetPriority(*source.ScaleSetPriority)
		managedClusterAgentPoolProfile.ScaleSetPriority = &scaleSetPriority
	} else {
		managedClusterAgentPoolProfile.ScaleSetPriority = nil
	}

	// SpotMaxPrice
	if source.SpotMaxPrice != nil {
		spotMaxPrice := *source.SpotMaxPrice
		managedClusterAgentPoolProfile.SpotMaxPrice = &spotMaxPrice
	} else {
		managedClusterAgentPoolProfile.SpotMaxPrice = nil
	}

	// Tags
	tagMap := make(map[string]string)
	for tagKey, tagValue := range source.Tags {
		// Shadow the loop variable to avoid aliasing
		tagValue := tagValue
		tagMap[tagKey] = tagValue
	}
	managedClusterAgentPoolProfile.Tags = tagMap

	// Type
	if source.Type != nil {
		typeVar := ManagedClusterAgentPoolProfileType(*source.Type)
		managedClusterAgentPoolProfile.Type = &typeVar
	} else {
		managedClusterAgentPoolProfile.Type = nil
	}

	// UpgradeSettings
	if source.UpgradeSettings != nil {
		var upgradeSetting AgentPoolUpgradeSettings
		err := upgradeSetting.AssignPropertiesFromAgentPoolUpgradeSettings(source.UpgradeSettings)
		if err != nil {
			return errors.Wrap(err, "populating UpgradeSettings from UpgradeSettings, calling AssignPropertiesFromAgentPoolUpgradeSettings()")
		}
		managedClusterAgentPoolProfile.UpgradeSettings = &upgradeSetting
	} else {
		managedClusterAgentPoolProfile.UpgradeSettings = nil
	}

	// VmSize
	if source.VmSize != nil {
		vmSize := *source.VmSize
		managedClusterAgentPoolProfile.VmSize = &vmSize
	} else {
		managedClusterAgentPoolProfile.VmSize = nil
	}

	// VnetSubnetIDReference
	if source.VnetSubnetIDReference != nil {
		vnetSubnetIDReference := source.VnetSubnetIDReference.Copy()
		managedClusterAgentPoolProfile.VnetSubnetIDReference = &vnetSubnetIDReference
	} else {
		managedClusterAgentPoolProfile.VnetSubnetIDReference = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterAgentPoolProfile populates the provided destination ManagedClusterAgentPoolProfile from our ManagedClusterAgentPoolProfile
func (managedClusterAgentPoolProfile *ManagedClusterAgentPoolProfile) AssignPropertiesToManagedClusterAgentPoolProfile(destination *v1alpha1api20210501storage.ManagedClusterAgentPoolProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AvailabilityZones
	availabilityZoneList := make([]string, len(managedClusterAgentPoolProfile.AvailabilityZones))
	for availabilityZoneIndex, availabilityZoneItem := range managedClusterAgentPoolProfile.AvailabilityZones {
		// Shadow the loop variable to avoid aliasing
		availabilityZoneItem := availabilityZoneItem
		availabilityZoneList[availabilityZoneIndex] = availabilityZoneItem
	}
	destination.AvailabilityZones = availabilityZoneList

	// Count
	if managedClusterAgentPoolProfile.Count != nil {
		count := *managedClusterAgentPoolProfile.Count
		destination.Count = &count
	} else {
		destination.Count = nil
	}

	// EnableAutoScaling
	if managedClusterAgentPoolProfile.EnableAutoScaling != nil {
		enableAutoScaling := *managedClusterAgentPoolProfile.EnableAutoScaling
		destination.EnableAutoScaling = &enableAutoScaling
	} else {
		destination.EnableAutoScaling = nil
	}

	// EnableEncryptionAtHost
	if managedClusterAgentPoolProfile.EnableEncryptionAtHost != nil {
		enableEncryptionAtHost := *managedClusterAgentPoolProfile.EnableEncryptionAtHost
		destination.EnableEncryptionAtHost = &enableEncryptionAtHost
	} else {
		destination.EnableEncryptionAtHost = nil
	}

	// EnableFIPS
	if managedClusterAgentPoolProfile.EnableFIPS != nil {
		enableFIPS := *managedClusterAgentPoolProfile.EnableFIPS
		destination.EnableFIPS = &enableFIPS
	} else {
		destination.EnableFIPS = nil
	}

	// EnableNodePublicIP
	if managedClusterAgentPoolProfile.EnableNodePublicIP != nil {
		enableNodePublicIP := *managedClusterAgentPoolProfile.EnableNodePublicIP
		destination.EnableNodePublicIP = &enableNodePublicIP
	} else {
		destination.EnableNodePublicIP = nil
	}

	// EnableUltraSSD
	if managedClusterAgentPoolProfile.EnableUltraSSD != nil {
		enableUltraSSD := *managedClusterAgentPoolProfile.EnableUltraSSD
		destination.EnableUltraSSD = &enableUltraSSD
	} else {
		destination.EnableUltraSSD = nil
	}

	// GpuInstanceProfile
	if managedClusterAgentPoolProfile.GpuInstanceProfile != nil {
		gpuInstanceProfile := string(*managedClusterAgentPoolProfile.GpuInstanceProfile)
		destination.GpuInstanceProfile = &gpuInstanceProfile
	} else {
		destination.GpuInstanceProfile = nil
	}

	// KubeletConfig
	if managedClusterAgentPoolProfile.KubeletConfig != nil {
		var kubeletConfig v1alpha1api20210501storage.KubeletConfig
		err := (*managedClusterAgentPoolProfile.KubeletConfig).AssignPropertiesToKubeletConfig(&kubeletConfig)
		if err != nil {
			return errors.Wrap(err, "populating KubeletConfig from KubeletConfig, calling AssignPropertiesToKubeletConfig()")
		}
		destination.KubeletConfig = &kubeletConfig
	} else {
		destination.KubeletConfig = nil
	}

	// KubeletDiskType
	if managedClusterAgentPoolProfile.KubeletDiskType != nil {
		kubeletDiskType := string(*managedClusterAgentPoolProfile.KubeletDiskType)
		destination.KubeletDiskType = &kubeletDiskType
	} else {
		destination.KubeletDiskType = nil
	}

	// LinuxOSConfig
	if managedClusterAgentPoolProfile.LinuxOSConfig != nil {
		var linuxOSConfig v1alpha1api20210501storage.LinuxOSConfig
		err := (*managedClusterAgentPoolProfile.LinuxOSConfig).AssignPropertiesToLinuxOSConfig(&linuxOSConfig)
		if err != nil {
			return errors.Wrap(err, "populating LinuxOSConfig from LinuxOSConfig, calling AssignPropertiesToLinuxOSConfig()")
		}
		destination.LinuxOSConfig = &linuxOSConfig
	} else {
		destination.LinuxOSConfig = nil
	}

	// MaxCount
	if managedClusterAgentPoolProfile.MaxCount != nil {
		maxCount := *managedClusterAgentPoolProfile.MaxCount
		destination.MaxCount = &maxCount
	} else {
		destination.MaxCount = nil
	}

	// MaxPods
	if managedClusterAgentPoolProfile.MaxPods != nil {
		maxPod := *managedClusterAgentPoolProfile.MaxPods
		destination.MaxPods = &maxPod
	} else {
		destination.MaxPods = nil
	}

	// MinCount
	if managedClusterAgentPoolProfile.MinCount != nil {
		minCount := *managedClusterAgentPoolProfile.MinCount
		destination.MinCount = &minCount
	} else {
		destination.MinCount = nil
	}

	// Mode
	if managedClusterAgentPoolProfile.Mode != nil {
		mode := string(*managedClusterAgentPoolProfile.Mode)
		destination.Mode = &mode
	} else {
		destination.Mode = nil
	}

	// Name
	name := managedClusterAgentPoolProfile.Name
	destination.Name = &name

	// NodeLabels
	nodeLabelMap := make(map[string]string)
	for nodeLabelKey, nodeLabelValue := range managedClusterAgentPoolProfile.NodeLabels {
		// Shadow the loop variable to avoid aliasing
		nodeLabelValue := nodeLabelValue
		nodeLabelMap[nodeLabelKey] = nodeLabelValue
	}
	destination.NodeLabels = nodeLabelMap

	// NodePublicIPPrefixIDReference
	if managedClusterAgentPoolProfile.NodePublicIPPrefixIDReference != nil {
		nodePublicIPPrefixIDReference := managedClusterAgentPoolProfile.NodePublicIPPrefixIDReference.Copy()
		destination.NodePublicIPPrefixIDReference = &nodePublicIPPrefixIDReference
	} else {
		destination.NodePublicIPPrefixIDReference = nil
	}

	// NodeTaints
	nodeTaintList := make([]string, len(managedClusterAgentPoolProfile.NodeTaints))
	for nodeTaintIndex, nodeTaintItem := range managedClusterAgentPoolProfile.NodeTaints {
		// Shadow the loop variable to avoid aliasing
		nodeTaintItem := nodeTaintItem
		nodeTaintList[nodeTaintIndex] = nodeTaintItem
	}
	destination.NodeTaints = nodeTaintList

	// OrchestratorVersion
	if managedClusterAgentPoolProfile.OrchestratorVersion != nil {
		orchestratorVersion := *managedClusterAgentPoolProfile.OrchestratorVersion
		destination.OrchestratorVersion = &orchestratorVersion
	} else {
		destination.OrchestratorVersion = nil
	}

	// OsDiskSizeGB
	if managedClusterAgentPoolProfile.OsDiskSizeGB != nil {
		osDiskSizeGB := *managedClusterAgentPoolProfile.OsDiskSizeGB
		destination.OsDiskSizeGB = &osDiskSizeGB
	} else {
		destination.OsDiskSizeGB = nil
	}

	// OsDiskType
	if managedClusterAgentPoolProfile.OsDiskType != nil {
		osDiskType := string(*managedClusterAgentPoolProfile.OsDiskType)
		destination.OsDiskType = &osDiskType
	} else {
		destination.OsDiskType = nil
	}

	// OsSKU
	if managedClusterAgentPoolProfile.OsSKU != nil {
		osSKU := string(*managedClusterAgentPoolProfile.OsSKU)
		destination.OsSKU = &osSKU
	} else {
		destination.OsSKU = nil
	}

	// OsType
	if managedClusterAgentPoolProfile.OsType != nil {
		osType := string(*managedClusterAgentPoolProfile.OsType)
		destination.OsType = &osType
	} else {
		destination.OsType = nil
	}

	// PodSubnetIDReference
	if managedClusterAgentPoolProfile.PodSubnetIDReference != nil {
		podSubnetIDReference := managedClusterAgentPoolProfile.PodSubnetIDReference.Copy()
		destination.PodSubnetIDReference = &podSubnetIDReference
	} else {
		destination.PodSubnetIDReference = nil
	}

	// ProximityPlacementGroupID
	if managedClusterAgentPoolProfile.ProximityPlacementGroupID != nil {
		proximityPlacementGroupID := *managedClusterAgentPoolProfile.ProximityPlacementGroupID
		destination.ProximityPlacementGroupID = &proximityPlacementGroupID
	} else {
		destination.ProximityPlacementGroupID = nil
	}

	// ScaleSetEvictionPolicy
	if managedClusterAgentPoolProfile.ScaleSetEvictionPolicy != nil {
		scaleSetEvictionPolicy := string(*managedClusterAgentPoolProfile.ScaleSetEvictionPolicy)
		destination.ScaleSetEvictionPolicy = &scaleSetEvictionPolicy
	} else {
		destination.ScaleSetEvictionPolicy = nil
	}

	// ScaleSetPriority
	if managedClusterAgentPoolProfile.ScaleSetPriority != nil {
		scaleSetPriority := string(*managedClusterAgentPoolProfile.ScaleSetPriority)
		destination.ScaleSetPriority = &scaleSetPriority
	} else {
		destination.ScaleSetPriority = nil
	}

	// SpotMaxPrice
	if managedClusterAgentPoolProfile.SpotMaxPrice != nil {
		spotMaxPrice := *managedClusterAgentPoolProfile.SpotMaxPrice
		destination.SpotMaxPrice = &spotMaxPrice
	} else {
		destination.SpotMaxPrice = nil
	}

	// Tags
	tagMap := make(map[string]string)
	for tagKey, tagValue := range managedClusterAgentPoolProfile.Tags {
		// Shadow the loop variable to avoid aliasing
		tagValue := tagValue
		tagMap[tagKey] = tagValue
	}
	destination.Tags = tagMap

	// Type
	if managedClusterAgentPoolProfile.Type != nil {
		typeVar := string(*managedClusterAgentPoolProfile.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UpgradeSettings
	if managedClusterAgentPoolProfile.UpgradeSettings != nil {
		var upgradeSetting v1alpha1api20210501storage.AgentPoolUpgradeSettings
		err := (*managedClusterAgentPoolProfile.UpgradeSettings).AssignPropertiesToAgentPoolUpgradeSettings(&upgradeSetting)
		if err != nil {
			return errors.Wrap(err, "populating UpgradeSettings from UpgradeSettings, calling AssignPropertiesToAgentPoolUpgradeSettings()")
		}
		destination.UpgradeSettings = &upgradeSetting
	} else {
		destination.UpgradeSettings = nil
	}

	// VmSize
	if managedClusterAgentPoolProfile.VmSize != nil {
		vmSize := *managedClusterAgentPoolProfile.VmSize
		destination.VmSize = &vmSize
	} else {
		destination.VmSize = nil
	}

	// VnetSubnetIDReference
	if managedClusterAgentPoolProfile.VnetSubnetIDReference != nil {
		vnetSubnetIDReference := managedClusterAgentPoolProfile.VnetSubnetIDReference.Copy()
		destination.VnetSubnetIDReference = &vnetSubnetIDReference
	} else {
		destination.VnetSubnetIDReference = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type ManagedClusterAgentPoolProfile_Status struct {
	//AvailabilityZones: Availability zones for nodes. Must use
	//VirtualMachineScaleSets AgentPoolType.
	AvailabilityZones []string `json:"availabilityZones,omitempty"`

	//Count: Number of agents (VMs) to host docker containers. Allowed values must be
	//in the range of 0 to 1000 (inclusive) for user pools and in the range of 1 to
	//1000 (inclusive) for system pools. The default value is 1.
	Count *int `json:"count,omitempty"`

	//EnableAutoScaling: Whether to enable auto-scaler
	EnableAutoScaling *bool `json:"enableAutoScaling,omitempty"`

	//EnableEncryptionAtHost: Whether to enable EncryptionAtHost
	EnableEncryptionAtHost *bool `json:"enableEncryptionAtHost,omitempty"`

	//EnableFIPS: Whether to use FIPS enabled OS
	EnableFIPS *bool `json:"enableFIPS,omitempty"`

	//EnableNodePublicIP: Enable public IP for nodes
	EnableNodePublicIP *bool `json:"enableNodePublicIP,omitempty"`

	//EnableUltraSSD: Whether to enable UltraSSD
	EnableUltraSSD *bool `json:"enableUltraSSD,omitempty"`

	//GpuInstanceProfile: GPUInstanceProfile to be used to specify GPU MIG instance
	//profile for supported GPU VM SKU. Supported values are MIG1g, MIG2g, MIG3g,
	//MIG4g and MIG7g.
	GpuInstanceProfile *GPUInstanceProfile_Status `json:"gpuInstanceProfile,omitempty"`

	//KubeletConfig: KubeletConfig specifies the configuration of kubelet on agent
	//nodes.
	KubeletConfig *KubeletConfig_Status `json:"kubeletConfig,omitempty"`

	//KubeletDiskType: KubeletDiskType determines the placement of emptyDir volumes,
	//container runtime data root, and Kubelet ephemeral storage. Currently allows one
	//value, OS, resulting in Kubelet using the OS disk for data.
	KubeletDiskType *KubeletDiskType_Status `json:"kubeletDiskType,omitempty"`

	//LinuxOSConfig: LinuxOSConfig specifies the OS configuration of linux agent nodes.
	LinuxOSConfig *LinuxOSConfig_Status `json:"linuxOSConfig,omitempty"`

	//MaxCount: Maximum number of nodes for auto-scaling
	MaxCount *int `json:"maxCount,omitempty"`

	//MaxPods: Maximum number of pods that can run on a node.
	MaxPods *int `json:"maxPods,omitempty"`

	//MinCount: Minimum number of nodes for auto-scaling
	MinCount *int `json:"minCount,omitempty"`

	//Mode: AgentPoolMode represents mode of an agent pool
	Mode *AgentPoolMode_Status `json:"mode,omitempty"`

	//Name: Unique name of the agent pool profile in the context of the subscription
	//and resource group.
	Name *string `json:"name,omitempty"`

	//NodeImageVersion: Version of node image
	NodeImageVersion *string `json:"nodeImageVersion,omitempty"`

	//NodeLabels: Agent pool node labels to be persisted across all nodes in agent
	//pool.
	NodeLabels map[string]string `json:"nodeLabels,omitempty"`

	//NodePublicIPPrefixID: Public IP Prefix ID. VM nodes use IPs assigned from this
	//Public IP Prefix.
	NodePublicIPPrefixID *string `json:"nodePublicIPPrefixID,omitempty"`

	//NodeTaints: Taints added to new nodes during node pool create and scale. For
	//example, key=value:NoSchedule.
	NodeTaints []string `json:"nodeTaints,omitempty"`

	//OrchestratorVersion: Version of orchestrator specified when creating the managed
	//cluster.
	OrchestratorVersion *string `json:"orchestratorVersion,omitempty"`

	//OsDiskSizeGB: OS Disk Size in GB to be used to specify the disk size for every
	//machine in this master/agent pool. If you specify 0, it will apply the default
	//osDisk size according to the vmSize specified.
	OsDiskSizeGB *int `json:"osDiskSizeGB,omitempty"`

	//OsDiskType: OS disk type to be used for machines in a given agent pool. Allowed
	//values are 'Ephemeral' and 'Managed'. If unspecified, defaults to 'Ephemeral'
	//when the VM supports ephemeral OS and has a cache disk larger than the requested
	//OSDiskSizeGB. Otherwise, defaults to 'Managed'. May not be changed after
	//creation.
	OsDiskType *OSDiskType_Status `json:"osDiskType,omitempty"`

	//OsSKU: OsSKU to be used to specify os sku. Choose from Ubuntu(default) and
	//CBLMariner for Linux OSType. Not applicable to Windows OSType.
	OsSKU *OSSKU_Status `json:"osSKU,omitempty"`

	//OsType: OsType to be used to specify os type. Choose from Linux and Windows.
	//Default to Linux.
	OsType *OSType_Status `json:"osType,omitempty"`

	//PodSubnetID: Pod SubnetID specifies the VNet's subnet identifier for pods.
	PodSubnetID *string `json:"podSubnetID,omitempty"`

	//PowerState: Describes whether the Agent Pool is Running or Stopped
	PowerState *PowerState_Status `json:"powerState,omitempty"`

	//ProvisioningState: The current deployment or provisioning state, which only
	//appears in the response.
	ProvisioningState *string `json:"provisioningState,omitempty"`

	//ProximityPlacementGroupID: The ID for Proximity Placement Group.
	ProximityPlacementGroupID *string `json:"proximityPlacementGroupID,omitempty"`

	//ScaleSetEvictionPolicy: ScaleSetEvictionPolicy to be used to specify eviction
	//policy for Spot virtual machine scale set. Default to Delete.
	ScaleSetEvictionPolicy *ScaleSetEvictionPolicy_Status `json:"scaleSetEvictionPolicy,omitempty"`

	//ScaleSetPriority: ScaleSetPriority to be used to specify virtual machine scale
	//set priority. Default to regular.
	ScaleSetPriority *ScaleSetPriority_Status `json:"scaleSetPriority,omitempty"`

	//SpotMaxPrice: SpotMaxPrice to be used to specify the maximum price you are
	//willing to pay in US Dollars. Possible values are any decimal value greater than
	//zero or -1 which indicates default price to be up-to on-demand.
	SpotMaxPrice *float64 `json:"spotMaxPrice,omitempty"`

	//Tags: Agent pool tags to be persisted on the agent pool virtual machine scale
	//set.
	Tags map[string]string `json:"tags,omitempty"`

	//Type: AgentPoolType represents types of an agent pool
	Type *AgentPoolType_Status `json:"type,omitempty"`

	//UpgradeSettings: Settings for upgrading the agentpool
	UpgradeSettings *AgentPoolUpgradeSettings_Status `json:"upgradeSettings,omitempty"`

	//VmSize: Size of agent VMs.
	VmSize *string `json:"vmSize,omitempty"`

	//VnetSubnetID: VNet SubnetID specifies the VNet's subnet identifier for nodes and
	//maybe pods
	VnetSubnetID *string `json:"vnetSubnetID,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterAgentPoolProfile_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (managedClusterAgentPoolProfileStatus *ManagedClusterAgentPoolProfile_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterAgentPoolProfile_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (managedClusterAgentPoolProfileStatus *ManagedClusterAgentPoolProfile_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterAgentPoolProfile_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterAgentPoolProfile_StatusARM, got %T", armInput)
	}

	// Set property ‘AvailabilityZones’:
	for _, item := range typedInput.AvailabilityZones {
		managedClusterAgentPoolProfileStatus.AvailabilityZones = append(managedClusterAgentPoolProfileStatus.AvailabilityZones, item)
	}

	// Set property ‘Count’:
	if typedInput.Count != nil {
		count := *typedInput.Count
		managedClusterAgentPoolProfileStatus.Count = &count
	}

	// Set property ‘EnableAutoScaling’:
	if typedInput.EnableAutoScaling != nil {
		enableAutoScaling := *typedInput.EnableAutoScaling
		managedClusterAgentPoolProfileStatus.EnableAutoScaling = &enableAutoScaling
	}

	// Set property ‘EnableEncryptionAtHost’:
	if typedInput.EnableEncryptionAtHost != nil {
		enableEncryptionAtHost := *typedInput.EnableEncryptionAtHost
		managedClusterAgentPoolProfileStatus.EnableEncryptionAtHost = &enableEncryptionAtHost
	}

	// Set property ‘EnableFIPS’:
	if typedInput.EnableFIPS != nil {
		enableFIPS := *typedInput.EnableFIPS
		managedClusterAgentPoolProfileStatus.EnableFIPS = &enableFIPS
	}

	// Set property ‘EnableNodePublicIP’:
	if typedInput.EnableNodePublicIP != nil {
		enableNodePublicIP := *typedInput.EnableNodePublicIP
		managedClusterAgentPoolProfileStatus.EnableNodePublicIP = &enableNodePublicIP
	}

	// Set property ‘EnableUltraSSD’:
	if typedInput.EnableUltraSSD != nil {
		enableUltraSSD := *typedInput.EnableUltraSSD
		managedClusterAgentPoolProfileStatus.EnableUltraSSD = &enableUltraSSD
	}

	// Set property ‘GpuInstanceProfile’:
	if typedInput.GpuInstanceProfile != nil {
		gpuInstanceProfile := *typedInput.GpuInstanceProfile
		managedClusterAgentPoolProfileStatus.GpuInstanceProfile = &gpuInstanceProfile
	}

	// Set property ‘KubeletConfig’:
	if typedInput.KubeletConfig != nil {
		var kubeletConfig1 KubeletConfig_Status
		err := kubeletConfig1.PopulateFromARM(owner, *typedInput.KubeletConfig)
		if err != nil {
			return err
		}
		kubeletConfig := kubeletConfig1
		managedClusterAgentPoolProfileStatus.KubeletConfig = &kubeletConfig
	}

	// Set property ‘KubeletDiskType’:
	if typedInput.KubeletDiskType != nil {
		kubeletDiskType := *typedInput.KubeletDiskType
		managedClusterAgentPoolProfileStatus.KubeletDiskType = &kubeletDiskType
	}

	// Set property ‘LinuxOSConfig’:
	if typedInput.LinuxOSConfig != nil {
		var linuxOSConfig1 LinuxOSConfig_Status
		err := linuxOSConfig1.PopulateFromARM(owner, *typedInput.LinuxOSConfig)
		if err != nil {
			return err
		}
		linuxOSConfig := linuxOSConfig1
		managedClusterAgentPoolProfileStatus.LinuxOSConfig = &linuxOSConfig
	}

	// Set property ‘MaxCount’:
	if typedInput.MaxCount != nil {
		maxCount := *typedInput.MaxCount
		managedClusterAgentPoolProfileStatus.MaxCount = &maxCount
	}

	// Set property ‘MaxPods’:
	if typedInput.MaxPods != nil {
		maxPods := *typedInput.MaxPods
		managedClusterAgentPoolProfileStatus.MaxPods = &maxPods
	}

	// Set property ‘MinCount’:
	if typedInput.MinCount != nil {
		minCount := *typedInput.MinCount
		managedClusterAgentPoolProfileStatus.MinCount = &minCount
	}

	// Set property ‘Mode’:
	if typedInput.Mode != nil {
		mode := *typedInput.Mode
		managedClusterAgentPoolProfileStatus.Mode = &mode
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		managedClusterAgentPoolProfileStatus.Name = &name
	}

	// Set property ‘NodeImageVersion’:
	if typedInput.NodeImageVersion != nil {
		nodeImageVersion := *typedInput.NodeImageVersion
		managedClusterAgentPoolProfileStatus.NodeImageVersion = &nodeImageVersion
	}

	// Set property ‘NodeLabels’:
	if typedInput.NodeLabels != nil {
		managedClusterAgentPoolProfileStatus.NodeLabels = make(map[string]string)
		for key, value := range typedInput.NodeLabels {
			managedClusterAgentPoolProfileStatus.NodeLabels[key] = value
		}
	}

	// Set property ‘NodePublicIPPrefixID’:
	if typedInput.NodePublicIPPrefixID != nil {
		nodePublicIPPrefixID := *typedInput.NodePublicIPPrefixID
		managedClusterAgentPoolProfileStatus.NodePublicIPPrefixID = &nodePublicIPPrefixID
	}

	// Set property ‘NodeTaints’:
	for _, item := range typedInput.NodeTaints {
		managedClusterAgentPoolProfileStatus.NodeTaints = append(managedClusterAgentPoolProfileStatus.NodeTaints, item)
	}

	// Set property ‘OrchestratorVersion’:
	if typedInput.OrchestratorVersion != nil {
		orchestratorVersion := *typedInput.OrchestratorVersion
		managedClusterAgentPoolProfileStatus.OrchestratorVersion = &orchestratorVersion
	}

	// Set property ‘OsDiskSizeGB’:
	if typedInput.OsDiskSizeGB != nil {
		osDiskSizeGB := *typedInput.OsDiskSizeGB
		managedClusterAgentPoolProfileStatus.OsDiskSizeGB = &osDiskSizeGB
	}

	// Set property ‘OsDiskType’:
	if typedInput.OsDiskType != nil {
		osDiskType := *typedInput.OsDiskType
		managedClusterAgentPoolProfileStatus.OsDiskType = &osDiskType
	}

	// Set property ‘OsSKU’:
	if typedInput.OsSKU != nil {
		osSKU := *typedInput.OsSKU
		managedClusterAgentPoolProfileStatus.OsSKU = &osSKU
	}

	// Set property ‘OsType’:
	if typedInput.OsType != nil {
		osType := *typedInput.OsType
		managedClusterAgentPoolProfileStatus.OsType = &osType
	}

	// Set property ‘PodSubnetID’:
	if typedInput.PodSubnetID != nil {
		podSubnetID := *typedInput.PodSubnetID
		managedClusterAgentPoolProfileStatus.PodSubnetID = &podSubnetID
	}

	// Set property ‘PowerState’:
	if typedInput.PowerState != nil {
		var powerState1 PowerState_Status
		err := powerState1.PopulateFromARM(owner, *typedInput.PowerState)
		if err != nil {
			return err
		}
		powerState := powerState1
		managedClusterAgentPoolProfileStatus.PowerState = &powerState
	}

	// Set property ‘ProvisioningState’:
	if typedInput.ProvisioningState != nil {
		provisioningState := *typedInput.ProvisioningState
		managedClusterAgentPoolProfileStatus.ProvisioningState = &provisioningState
	}

	// Set property ‘ProximityPlacementGroupID’:
	if typedInput.ProximityPlacementGroupID != nil {
		proximityPlacementGroupID := *typedInput.ProximityPlacementGroupID
		managedClusterAgentPoolProfileStatus.ProximityPlacementGroupID = &proximityPlacementGroupID
	}

	// Set property ‘ScaleSetEvictionPolicy’:
	if typedInput.ScaleSetEvictionPolicy != nil {
		scaleSetEvictionPolicy := *typedInput.ScaleSetEvictionPolicy
		managedClusterAgentPoolProfileStatus.ScaleSetEvictionPolicy = &scaleSetEvictionPolicy
	}

	// Set property ‘ScaleSetPriority’:
	if typedInput.ScaleSetPriority != nil {
		scaleSetPriority := *typedInput.ScaleSetPriority
		managedClusterAgentPoolProfileStatus.ScaleSetPriority = &scaleSetPriority
	}

	// Set property ‘SpotMaxPrice’:
	if typedInput.SpotMaxPrice != nil {
		spotMaxPrice := *typedInput.SpotMaxPrice
		managedClusterAgentPoolProfileStatus.SpotMaxPrice = &spotMaxPrice
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		managedClusterAgentPoolProfileStatus.Tags = make(map[string]string)
		for key, value := range typedInput.Tags {
			managedClusterAgentPoolProfileStatus.Tags[key] = value
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		managedClusterAgentPoolProfileStatus.Type = &typeVar
	}

	// Set property ‘UpgradeSettings’:
	if typedInput.UpgradeSettings != nil {
		var upgradeSettings1 AgentPoolUpgradeSettings_Status
		err := upgradeSettings1.PopulateFromARM(owner, *typedInput.UpgradeSettings)
		if err != nil {
			return err
		}
		upgradeSettings := upgradeSettings1
		managedClusterAgentPoolProfileStatus.UpgradeSettings = &upgradeSettings
	}

	// Set property ‘VmSize’:
	if typedInput.VmSize != nil {
		vmSize := *typedInput.VmSize
		managedClusterAgentPoolProfileStatus.VmSize = &vmSize
	}

	// Set property ‘VnetSubnetID’:
	if typedInput.VnetSubnetID != nil {
		vnetSubnetID := *typedInput.VnetSubnetID
		managedClusterAgentPoolProfileStatus.VnetSubnetID = &vnetSubnetID
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterAgentPoolProfileStatus populates our ManagedClusterAgentPoolProfile_Status from the provided source ManagedClusterAgentPoolProfile_Status
func (managedClusterAgentPoolProfileStatus *ManagedClusterAgentPoolProfile_Status) AssignPropertiesFromManagedClusterAgentPoolProfileStatus(source *v1alpha1api20210501storage.ManagedClusterAgentPoolProfile_Status) error {

	// AvailabilityZones
	availabilityZoneList := make([]string, len(source.AvailabilityZones))
	for availabilityZoneIndex, availabilityZoneItem := range source.AvailabilityZones {
		// Shadow the loop variable to avoid aliasing
		availabilityZoneItem := availabilityZoneItem
		availabilityZoneList[availabilityZoneIndex] = availabilityZoneItem
	}
	managedClusterAgentPoolProfileStatus.AvailabilityZones = availabilityZoneList

	// Count
	if source.Count != nil {
		count := *source.Count
		managedClusterAgentPoolProfileStatus.Count = &count
	} else {
		managedClusterAgentPoolProfileStatus.Count = nil
	}

	// EnableAutoScaling
	if source.EnableAutoScaling != nil {
		enableAutoScaling := *source.EnableAutoScaling
		managedClusterAgentPoolProfileStatus.EnableAutoScaling = &enableAutoScaling
	} else {
		managedClusterAgentPoolProfileStatus.EnableAutoScaling = nil
	}

	// EnableEncryptionAtHost
	if source.EnableEncryptionAtHost != nil {
		enableEncryptionAtHost := *source.EnableEncryptionAtHost
		managedClusterAgentPoolProfileStatus.EnableEncryptionAtHost = &enableEncryptionAtHost
	} else {
		managedClusterAgentPoolProfileStatus.EnableEncryptionAtHost = nil
	}

	// EnableFIPS
	if source.EnableFIPS != nil {
		enableFIPS := *source.EnableFIPS
		managedClusterAgentPoolProfileStatus.EnableFIPS = &enableFIPS
	} else {
		managedClusterAgentPoolProfileStatus.EnableFIPS = nil
	}

	// EnableNodePublicIP
	if source.EnableNodePublicIP != nil {
		enableNodePublicIP := *source.EnableNodePublicIP
		managedClusterAgentPoolProfileStatus.EnableNodePublicIP = &enableNodePublicIP
	} else {
		managedClusterAgentPoolProfileStatus.EnableNodePublicIP = nil
	}

	// EnableUltraSSD
	if source.EnableUltraSSD != nil {
		enableUltraSSD := *source.EnableUltraSSD
		managedClusterAgentPoolProfileStatus.EnableUltraSSD = &enableUltraSSD
	} else {
		managedClusterAgentPoolProfileStatus.EnableUltraSSD = nil
	}

	// GpuInstanceProfile
	if source.GpuInstanceProfile != nil {
		gpuInstanceProfile := GPUInstanceProfile_Status(*source.GpuInstanceProfile)
		managedClusterAgentPoolProfileStatus.GpuInstanceProfile = &gpuInstanceProfile
	} else {
		managedClusterAgentPoolProfileStatus.GpuInstanceProfile = nil
	}

	// KubeletConfig
	if source.KubeletConfig != nil {
		var kubeletConfig KubeletConfig_Status
		err := kubeletConfig.AssignPropertiesFromKubeletConfigStatus(source.KubeletConfig)
		if err != nil {
			return errors.Wrap(err, "populating KubeletConfig from KubeletConfig, calling AssignPropertiesFromKubeletConfigStatus()")
		}
		managedClusterAgentPoolProfileStatus.KubeletConfig = &kubeletConfig
	} else {
		managedClusterAgentPoolProfileStatus.KubeletConfig = nil
	}

	// KubeletDiskType
	if source.KubeletDiskType != nil {
		kubeletDiskType := KubeletDiskType_Status(*source.KubeletDiskType)
		managedClusterAgentPoolProfileStatus.KubeletDiskType = &kubeletDiskType
	} else {
		managedClusterAgentPoolProfileStatus.KubeletDiskType = nil
	}

	// LinuxOSConfig
	if source.LinuxOSConfig != nil {
		var linuxOSConfig LinuxOSConfig_Status
		err := linuxOSConfig.AssignPropertiesFromLinuxOSConfigStatus(source.LinuxOSConfig)
		if err != nil {
			return errors.Wrap(err, "populating LinuxOSConfig from LinuxOSConfig, calling AssignPropertiesFromLinuxOSConfigStatus()")
		}
		managedClusterAgentPoolProfileStatus.LinuxOSConfig = &linuxOSConfig
	} else {
		managedClusterAgentPoolProfileStatus.LinuxOSConfig = nil
	}

	// MaxCount
	if source.MaxCount != nil {
		maxCount := *source.MaxCount
		managedClusterAgentPoolProfileStatus.MaxCount = &maxCount
	} else {
		managedClusterAgentPoolProfileStatus.MaxCount = nil
	}

	// MaxPods
	if source.MaxPods != nil {
		maxPod := *source.MaxPods
		managedClusterAgentPoolProfileStatus.MaxPods = &maxPod
	} else {
		managedClusterAgentPoolProfileStatus.MaxPods = nil
	}

	// MinCount
	if source.MinCount != nil {
		minCount := *source.MinCount
		managedClusterAgentPoolProfileStatus.MinCount = &minCount
	} else {
		managedClusterAgentPoolProfileStatus.MinCount = nil
	}

	// Mode
	if source.Mode != nil {
		mode := AgentPoolMode_Status(*source.Mode)
		managedClusterAgentPoolProfileStatus.Mode = &mode
	} else {
		managedClusterAgentPoolProfileStatus.Mode = nil
	}

	// Name
	if source.Name != nil {
		name := *source.Name
		managedClusterAgentPoolProfileStatus.Name = &name
	} else {
		managedClusterAgentPoolProfileStatus.Name = nil
	}

	// NodeImageVersion
	if source.NodeImageVersion != nil {
		nodeImageVersion := *source.NodeImageVersion
		managedClusterAgentPoolProfileStatus.NodeImageVersion = &nodeImageVersion
	} else {
		managedClusterAgentPoolProfileStatus.NodeImageVersion = nil
	}

	// NodeLabels
	nodeLabelMap := make(map[string]string)
	for nodeLabelKey, nodeLabelValue := range source.NodeLabels {
		// Shadow the loop variable to avoid aliasing
		nodeLabelValue := nodeLabelValue
		nodeLabelMap[nodeLabelKey] = nodeLabelValue
	}
	managedClusterAgentPoolProfileStatus.NodeLabels = nodeLabelMap

	// NodePublicIPPrefixID
	if source.NodePublicIPPrefixID != nil {
		nodePublicIPPrefixID := *source.NodePublicIPPrefixID
		managedClusterAgentPoolProfileStatus.NodePublicIPPrefixID = &nodePublicIPPrefixID
	} else {
		managedClusterAgentPoolProfileStatus.NodePublicIPPrefixID = nil
	}

	// NodeTaints
	nodeTaintList := make([]string, len(source.NodeTaints))
	for nodeTaintIndex, nodeTaintItem := range source.NodeTaints {
		// Shadow the loop variable to avoid aliasing
		nodeTaintItem := nodeTaintItem
		nodeTaintList[nodeTaintIndex] = nodeTaintItem
	}
	managedClusterAgentPoolProfileStatus.NodeTaints = nodeTaintList

	// OrchestratorVersion
	if source.OrchestratorVersion != nil {
		orchestratorVersion := *source.OrchestratorVersion
		managedClusterAgentPoolProfileStatus.OrchestratorVersion = &orchestratorVersion
	} else {
		managedClusterAgentPoolProfileStatus.OrchestratorVersion = nil
	}

	// OsDiskSizeGB
	if source.OsDiskSizeGB != nil {
		osDiskSizeGB := *source.OsDiskSizeGB
		managedClusterAgentPoolProfileStatus.OsDiskSizeGB = &osDiskSizeGB
	} else {
		managedClusterAgentPoolProfileStatus.OsDiskSizeGB = nil
	}

	// OsDiskType
	if source.OsDiskType != nil {
		osDiskType := OSDiskType_Status(*source.OsDiskType)
		managedClusterAgentPoolProfileStatus.OsDiskType = &osDiskType
	} else {
		managedClusterAgentPoolProfileStatus.OsDiskType = nil
	}

	// OsSKU
	if source.OsSKU != nil {
		osSKU := OSSKU_Status(*source.OsSKU)
		managedClusterAgentPoolProfileStatus.OsSKU = &osSKU
	} else {
		managedClusterAgentPoolProfileStatus.OsSKU = nil
	}

	// OsType
	if source.OsType != nil {
		osType := OSType_Status(*source.OsType)
		managedClusterAgentPoolProfileStatus.OsType = &osType
	} else {
		managedClusterAgentPoolProfileStatus.OsType = nil
	}

	// PodSubnetID
	if source.PodSubnetID != nil {
		podSubnetID := *source.PodSubnetID
		managedClusterAgentPoolProfileStatus.PodSubnetID = &podSubnetID
	} else {
		managedClusterAgentPoolProfileStatus.PodSubnetID = nil
	}

	// PowerState
	if source.PowerState != nil {
		var powerState PowerState_Status
		err := powerState.AssignPropertiesFromPowerStateStatus(source.PowerState)
		if err != nil {
			return errors.Wrap(err, "populating PowerState from PowerState, calling AssignPropertiesFromPowerStateStatus()")
		}
		managedClusterAgentPoolProfileStatus.PowerState = &powerState
	} else {
		managedClusterAgentPoolProfileStatus.PowerState = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		managedClusterAgentPoolProfileStatus.ProvisioningState = &provisioningState
	} else {
		managedClusterAgentPoolProfileStatus.ProvisioningState = nil
	}

	// ProximityPlacementGroupID
	if source.ProximityPlacementGroupID != nil {
		proximityPlacementGroupID := *source.ProximityPlacementGroupID
		managedClusterAgentPoolProfileStatus.ProximityPlacementGroupID = &proximityPlacementGroupID
	} else {
		managedClusterAgentPoolProfileStatus.ProximityPlacementGroupID = nil
	}

	// ScaleSetEvictionPolicy
	if source.ScaleSetEvictionPolicy != nil {
		scaleSetEvictionPolicy := ScaleSetEvictionPolicy_Status(*source.ScaleSetEvictionPolicy)
		managedClusterAgentPoolProfileStatus.ScaleSetEvictionPolicy = &scaleSetEvictionPolicy
	} else {
		managedClusterAgentPoolProfileStatus.ScaleSetEvictionPolicy = nil
	}

	// ScaleSetPriority
	if source.ScaleSetPriority != nil {
		scaleSetPriority := ScaleSetPriority_Status(*source.ScaleSetPriority)
		managedClusterAgentPoolProfileStatus.ScaleSetPriority = &scaleSetPriority
	} else {
		managedClusterAgentPoolProfileStatus.ScaleSetPriority = nil
	}

	// SpotMaxPrice
	if source.SpotMaxPrice != nil {
		spotMaxPrice := *source.SpotMaxPrice
		managedClusterAgentPoolProfileStatus.SpotMaxPrice = &spotMaxPrice
	} else {
		managedClusterAgentPoolProfileStatus.SpotMaxPrice = nil
	}

	// Tags
	tagMap := make(map[string]string)
	for tagKey, tagValue := range source.Tags {
		// Shadow the loop variable to avoid aliasing
		tagValue := tagValue
		tagMap[tagKey] = tagValue
	}
	managedClusterAgentPoolProfileStatus.Tags = tagMap

	// Type
	if source.Type != nil {
		typeVar := AgentPoolType_Status(*source.Type)
		managedClusterAgentPoolProfileStatus.Type = &typeVar
	} else {
		managedClusterAgentPoolProfileStatus.Type = nil
	}

	// UpgradeSettings
	if source.UpgradeSettings != nil {
		var upgradeSetting AgentPoolUpgradeSettings_Status
		err := upgradeSetting.AssignPropertiesFromAgentPoolUpgradeSettingsStatus(source.UpgradeSettings)
		if err != nil {
			return errors.Wrap(err, "populating UpgradeSettings from UpgradeSettings, calling AssignPropertiesFromAgentPoolUpgradeSettingsStatus()")
		}
		managedClusterAgentPoolProfileStatus.UpgradeSettings = &upgradeSetting
	} else {
		managedClusterAgentPoolProfileStatus.UpgradeSettings = nil
	}

	// VmSize
	if source.VmSize != nil {
		vmSize := *source.VmSize
		managedClusterAgentPoolProfileStatus.VmSize = &vmSize
	} else {
		managedClusterAgentPoolProfileStatus.VmSize = nil
	}

	// VnetSubnetID
	if source.VnetSubnetID != nil {
		vnetSubnetID := *source.VnetSubnetID
		managedClusterAgentPoolProfileStatus.VnetSubnetID = &vnetSubnetID
	} else {
		managedClusterAgentPoolProfileStatus.VnetSubnetID = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterAgentPoolProfileStatus populates the provided destination ManagedClusterAgentPoolProfile_Status from our ManagedClusterAgentPoolProfile_Status
func (managedClusterAgentPoolProfileStatus *ManagedClusterAgentPoolProfile_Status) AssignPropertiesToManagedClusterAgentPoolProfileStatus(destination *v1alpha1api20210501storage.ManagedClusterAgentPoolProfile_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AvailabilityZones
	availabilityZoneList := make([]string, len(managedClusterAgentPoolProfileStatus.AvailabilityZones))
	for availabilityZoneIndex, availabilityZoneItem := range managedClusterAgentPoolProfileStatus.AvailabilityZones {
		// Shadow the loop variable to avoid aliasing
		availabilityZoneItem := availabilityZoneItem
		availabilityZoneList[availabilityZoneIndex] = availabilityZoneItem
	}
	destination.AvailabilityZones = availabilityZoneList

	// Count
	if managedClusterAgentPoolProfileStatus.Count != nil {
		count := *managedClusterAgentPoolProfileStatus.Count
		destination.Count = &count
	} else {
		destination.Count = nil
	}

	// EnableAutoScaling
	if managedClusterAgentPoolProfileStatus.EnableAutoScaling != nil {
		enableAutoScaling := *managedClusterAgentPoolProfileStatus.EnableAutoScaling
		destination.EnableAutoScaling = &enableAutoScaling
	} else {
		destination.EnableAutoScaling = nil
	}

	// EnableEncryptionAtHost
	if managedClusterAgentPoolProfileStatus.EnableEncryptionAtHost != nil {
		enableEncryptionAtHost := *managedClusterAgentPoolProfileStatus.EnableEncryptionAtHost
		destination.EnableEncryptionAtHost = &enableEncryptionAtHost
	} else {
		destination.EnableEncryptionAtHost = nil
	}

	// EnableFIPS
	if managedClusterAgentPoolProfileStatus.EnableFIPS != nil {
		enableFIPS := *managedClusterAgentPoolProfileStatus.EnableFIPS
		destination.EnableFIPS = &enableFIPS
	} else {
		destination.EnableFIPS = nil
	}

	// EnableNodePublicIP
	if managedClusterAgentPoolProfileStatus.EnableNodePublicIP != nil {
		enableNodePublicIP := *managedClusterAgentPoolProfileStatus.EnableNodePublicIP
		destination.EnableNodePublicIP = &enableNodePublicIP
	} else {
		destination.EnableNodePublicIP = nil
	}

	// EnableUltraSSD
	if managedClusterAgentPoolProfileStatus.EnableUltraSSD != nil {
		enableUltraSSD := *managedClusterAgentPoolProfileStatus.EnableUltraSSD
		destination.EnableUltraSSD = &enableUltraSSD
	} else {
		destination.EnableUltraSSD = nil
	}

	// GpuInstanceProfile
	if managedClusterAgentPoolProfileStatus.GpuInstanceProfile != nil {
		gpuInstanceProfile := string(*managedClusterAgentPoolProfileStatus.GpuInstanceProfile)
		destination.GpuInstanceProfile = &gpuInstanceProfile
	} else {
		destination.GpuInstanceProfile = nil
	}

	// KubeletConfig
	if managedClusterAgentPoolProfileStatus.KubeletConfig != nil {
		var kubeletConfig v1alpha1api20210501storage.KubeletConfig_Status
		err := (*managedClusterAgentPoolProfileStatus.KubeletConfig).AssignPropertiesToKubeletConfigStatus(&kubeletConfig)
		if err != nil {
			return errors.Wrap(err, "populating KubeletConfig from KubeletConfig, calling AssignPropertiesToKubeletConfigStatus()")
		}
		destination.KubeletConfig = &kubeletConfig
	} else {
		destination.KubeletConfig = nil
	}

	// KubeletDiskType
	if managedClusterAgentPoolProfileStatus.KubeletDiskType != nil {
		kubeletDiskType := string(*managedClusterAgentPoolProfileStatus.KubeletDiskType)
		destination.KubeletDiskType = &kubeletDiskType
	} else {
		destination.KubeletDiskType = nil
	}

	// LinuxOSConfig
	if managedClusterAgentPoolProfileStatus.LinuxOSConfig != nil {
		var linuxOSConfig v1alpha1api20210501storage.LinuxOSConfig_Status
		err := (*managedClusterAgentPoolProfileStatus.LinuxOSConfig).AssignPropertiesToLinuxOSConfigStatus(&linuxOSConfig)
		if err != nil {
			return errors.Wrap(err, "populating LinuxOSConfig from LinuxOSConfig, calling AssignPropertiesToLinuxOSConfigStatus()")
		}
		destination.LinuxOSConfig = &linuxOSConfig
	} else {
		destination.LinuxOSConfig = nil
	}

	// MaxCount
	if managedClusterAgentPoolProfileStatus.MaxCount != nil {
		maxCount := *managedClusterAgentPoolProfileStatus.MaxCount
		destination.MaxCount = &maxCount
	} else {
		destination.MaxCount = nil
	}

	// MaxPods
	if managedClusterAgentPoolProfileStatus.MaxPods != nil {
		maxPod := *managedClusterAgentPoolProfileStatus.MaxPods
		destination.MaxPods = &maxPod
	} else {
		destination.MaxPods = nil
	}

	// MinCount
	if managedClusterAgentPoolProfileStatus.MinCount != nil {
		minCount := *managedClusterAgentPoolProfileStatus.MinCount
		destination.MinCount = &minCount
	} else {
		destination.MinCount = nil
	}

	// Mode
	if managedClusterAgentPoolProfileStatus.Mode != nil {
		mode := string(*managedClusterAgentPoolProfileStatus.Mode)
		destination.Mode = &mode
	} else {
		destination.Mode = nil
	}

	// Name
	if managedClusterAgentPoolProfileStatus.Name != nil {
		name := *managedClusterAgentPoolProfileStatus.Name
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// NodeImageVersion
	if managedClusterAgentPoolProfileStatus.NodeImageVersion != nil {
		nodeImageVersion := *managedClusterAgentPoolProfileStatus.NodeImageVersion
		destination.NodeImageVersion = &nodeImageVersion
	} else {
		destination.NodeImageVersion = nil
	}

	// NodeLabels
	nodeLabelMap := make(map[string]string)
	for nodeLabelKey, nodeLabelValue := range managedClusterAgentPoolProfileStatus.NodeLabels {
		// Shadow the loop variable to avoid aliasing
		nodeLabelValue := nodeLabelValue
		nodeLabelMap[nodeLabelKey] = nodeLabelValue
	}
	destination.NodeLabels = nodeLabelMap

	// NodePublicIPPrefixID
	if managedClusterAgentPoolProfileStatus.NodePublicIPPrefixID != nil {
		nodePublicIPPrefixID := *managedClusterAgentPoolProfileStatus.NodePublicIPPrefixID
		destination.NodePublicIPPrefixID = &nodePublicIPPrefixID
	} else {
		destination.NodePublicIPPrefixID = nil
	}

	// NodeTaints
	nodeTaintList := make([]string, len(managedClusterAgentPoolProfileStatus.NodeTaints))
	for nodeTaintIndex, nodeTaintItem := range managedClusterAgentPoolProfileStatus.NodeTaints {
		// Shadow the loop variable to avoid aliasing
		nodeTaintItem := nodeTaintItem
		nodeTaintList[nodeTaintIndex] = nodeTaintItem
	}
	destination.NodeTaints = nodeTaintList

	// OrchestratorVersion
	if managedClusterAgentPoolProfileStatus.OrchestratorVersion != nil {
		orchestratorVersion := *managedClusterAgentPoolProfileStatus.OrchestratorVersion
		destination.OrchestratorVersion = &orchestratorVersion
	} else {
		destination.OrchestratorVersion = nil
	}

	// OsDiskSizeGB
	if managedClusterAgentPoolProfileStatus.OsDiskSizeGB != nil {
		osDiskSizeGB := *managedClusterAgentPoolProfileStatus.OsDiskSizeGB
		destination.OsDiskSizeGB = &osDiskSizeGB
	} else {
		destination.OsDiskSizeGB = nil
	}

	// OsDiskType
	if managedClusterAgentPoolProfileStatus.OsDiskType != nil {
		osDiskType := string(*managedClusterAgentPoolProfileStatus.OsDiskType)
		destination.OsDiskType = &osDiskType
	} else {
		destination.OsDiskType = nil
	}

	// OsSKU
	if managedClusterAgentPoolProfileStatus.OsSKU != nil {
		osSKU := string(*managedClusterAgentPoolProfileStatus.OsSKU)
		destination.OsSKU = &osSKU
	} else {
		destination.OsSKU = nil
	}

	// OsType
	if managedClusterAgentPoolProfileStatus.OsType != nil {
		osType := string(*managedClusterAgentPoolProfileStatus.OsType)
		destination.OsType = &osType
	} else {
		destination.OsType = nil
	}

	// PodSubnetID
	if managedClusterAgentPoolProfileStatus.PodSubnetID != nil {
		podSubnetID := *managedClusterAgentPoolProfileStatus.PodSubnetID
		destination.PodSubnetID = &podSubnetID
	} else {
		destination.PodSubnetID = nil
	}

	// PowerState
	if managedClusterAgentPoolProfileStatus.PowerState != nil {
		var powerState v1alpha1api20210501storage.PowerState_Status
		err := (*managedClusterAgentPoolProfileStatus.PowerState).AssignPropertiesToPowerStateStatus(&powerState)
		if err != nil {
			return errors.Wrap(err, "populating PowerState from PowerState, calling AssignPropertiesToPowerStateStatus()")
		}
		destination.PowerState = &powerState
	} else {
		destination.PowerState = nil
	}

	// ProvisioningState
	if managedClusterAgentPoolProfileStatus.ProvisioningState != nil {
		provisioningState := *managedClusterAgentPoolProfileStatus.ProvisioningState
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// ProximityPlacementGroupID
	if managedClusterAgentPoolProfileStatus.ProximityPlacementGroupID != nil {
		proximityPlacementGroupID := *managedClusterAgentPoolProfileStatus.ProximityPlacementGroupID
		destination.ProximityPlacementGroupID = &proximityPlacementGroupID
	} else {
		destination.ProximityPlacementGroupID = nil
	}

	// ScaleSetEvictionPolicy
	if managedClusterAgentPoolProfileStatus.ScaleSetEvictionPolicy != nil {
		scaleSetEvictionPolicy := string(*managedClusterAgentPoolProfileStatus.ScaleSetEvictionPolicy)
		destination.ScaleSetEvictionPolicy = &scaleSetEvictionPolicy
	} else {
		destination.ScaleSetEvictionPolicy = nil
	}

	// ScaleSetPriority
	if managedClusterAgentPoolProfileStatus.ScaleSetPriority != nil {
		scaleSetPriority := string(*managedClusterAgentPoolProfileStatus.ScaleSetPriority)
		destination.ScaleSetPriority = &scaleSetPriority
	} else {
		destination.ScaleSetPriority = nil
	}

	// SpotMaxPrice
	if managedClusterAgentPoolProfileStatus.SpotMaxPrice != nil {
		spotMaxPrice := *managedClusterAgentPoolProfileStatus.SpotMaxPrice
		destination.SpotMaxPrice = &spotMaxPrice
	} else {
		destination.SpotMaxPrice = nil
	}

	// Tags
	tagMap := make(map[string]string)
	for tagKey, tagValue := range managedClusterAgentPoolProfileStatus.Tags {
		// Shadow the loop variable to avoid aliasing
		tagValue := tagValue
		tagMap[tagKey] = tagValue
	}
	destination.Tags = tagMap

	// Type
	if managedClusterAgentPoolProfileStatus.Type != nil {
		typeVar := string(*managedClusterAgentPoolProfileStatus.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UpgradeSettings
	if managedClusterAgentPoolProfileStatus.UpgradeSettings != nil {
		var upgradeSetting v1alpha1api20210501storage.AgentPoolUpgradeSettings_Status
		err := (*managedClusterAgentPoolProfileStatus.UpgradeSettings).AssignPropertiesToAgentPoolUpgradeSettingsStatus(&upgradeSetting)
		if err != nil {
			return errors.Wrap(err, "populating UpgradeSettings from UpgradeSettings, calling AssignPropertiesToAgentPoolUpgradeSettingsStatus()")
		}
		destination.UpgradeSettings = &upgradeSetting
	} else {
		destination.UpgradeSettings = nil
	}

	// VmSize
	if managedClusterAgentPoolProfileStatus.VmSize != nil {
		vmSize := *managedClusterAgentPoolProfileStatus.VmSize
		destination.VmSize = &vmSize
	} else {
		destination.VmSize = nil
	}

	// VnetSubnetID
	if managedClusterAgentPoolProfileStatus.VnetSubnetID != nil {
		vnetSubnetID := *managedClusterAgentPoolProfileStatus.VnetSubnetID
		destination.VnetSubnetID = &vnetSubnetID
	} else {
		destination.VnetSubnetID = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2021-05-01/Microsoft.ContainerService.json#/definitions/ManagedClusterAutoUpgradeProfile
type ManagedClusterAutoUpgradeProfile struct {
	//UpgradeChannel: For more information see [setting the AKS cluster auto-upgrade
	//channel](https://docs.microsoft.com/azure/aks/upgrade-cluster#set-auto-upgrade-channel).
	UpgradeChannel *ManagedClusterAutoUpgradeProfileUpgradeChannel `json:"upgradeChannel,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterAutoUpgradeProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (managedClusterAutoUpgradeProfile *ManagedClusterAutoUpgradeProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if managedClusterAutoUpgradeProfile == nil {
		return nil, nil
	}
	var result ManagedClusterAutoUpgradeProfileARM

	// Set property ‘UpgradeChannel’:
	if managedClusterAutoUpgradeProfile.UpgradeChannel != nil {
		upgradeChannel := *managedClusterAutoUpgradeProfile.UpgradeChannel
		result.UpgradeChannel = &upgradeChannel
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (managedClusterAutoUpgradeProfile *ManagedClusterAutoUpgradeProfile) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterAutoUpgradeProfileARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (managedClusterAutoUpgradeProfile *ManagedClusterAutoUpgradeProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterAutoUpgradeProfileARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterAutoUpgradeProfileARM, got %T", armInput)
	}

	// Set property ‘UpgradeChannel’:
	if typedInput.UpgradeChannel != nil {
		upgradeChannel := *typedInput.UpgradeChannel
		managedClusterAutoUpgradeProfile.UpgradeChannel = &upgradeChannel
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterAutoUpgradeProfile populates our ManagedClusterAutoUpgradeProfile from the provided source ManagedClusterAutoUpgradeProfile
func (managedClusterAutoUpgradeProfile *ManagedClusterAutoUpgradeProfile) AssignPropertiesFromManagedClusterAutoUpgradeProfile(source *v1alpha1api20210501storage.ManagedClusterAutoUpgradeProfile) error {

	// UpgradeChannel
	if source.UpgradeChannel != nil {
		upgradeChannel := ManagedClusterAutoUpgradeProfileUpgradeChannel(*source.UpgradeChannel)
		managedClusterAutoUpgradeProfile.UpgradeChannel = &upgradeChannel
	} else {
		managedClusterAutoUpgradeProfile.UpgradeChannel = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterAutoUpgradeProfile populates the provided destination ManagedClusterAutoUpgradeProfile from our ManagedClusterAutoUpgradeProfile
func (managedClusterAutoUpgradeProfile *ManagedClusterAutoUpgradeProfile) AssignPropertiesToManagedClusterAutoUpgradeProfile(destination *v1alpha1api20210501storage.ManagedClusterAutoUpgradeProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// UpgradeChannel
	if managedClusterAutoUpgradeProfile.UpgradeChannel != nil {
		upgradeChannel := string(*managedClusterAutoUpgradeProfile.UpgradeChannel)
		destination.UpgradeChannel = &upgradeChannel
	} else {
		destination.UpgradeChannel = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type ManagedClusterAutoUpgradeProfile_Status struct {
	//UpgradeChannel: upgrade channel for auto upgrade.
	UpgradeChannel *ManagedClusterAutoUpgradeProfileStatusUpgradeChannel `json:"upgradeChannel,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterAutoUpgradeProfile_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (managedClusterAutoUpgradeProfileStatus *ManagedClusterAutoUpgradeProfile_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterAutoUpgradeProfile_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (managedClusterAutoUpgradeProfileStatus *ManagedClusterAutoUpgradeProfile_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterAutoUpgradeProfile_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterAutoUpgradeProfile_StatusARM, got %T", armInput)
	}

	// Set property ‘UpgradeChannel’:
	if typedInput.UpgradeChannel != nil {
		upgradeChannel := *typedInput.UpgradeChannel
		managedClusterAutoUpgradeProfileStatus.UpgradeChannel = &upgradeChannel
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterAutoUpgradeProfileStatus populates our ManagedClusterAutoUpgradeProfile_Status from the provided source ManagedClusterAutoUpgradeProfile_Status
func (managedClusterAutoUpgradeProfileStatus *ManagedClusterAutoUpgradeProfile_Status) AssignPropertiesFromManagedClusterAutoUpgradeProfileStatus(source *v1alpha1api20210501storage.ManagedClusterAutoUpgradeProfile_Status) error {

	// UpgradeChannel
	if source.UpgradeChannel != nil {
		upgradeChannel := ManagedClusterAutoUpgradeProfileStatusUpgradeChannel(*source.UpgradeChannel)
		managedClusterAutoUpgradeProfileStatus.UpgradeChannel = &upgradeChannel
	} else {
		managedClusterAutoUpgradeProfileStatus.UpgradeChannel = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterAutoUpgradeProfileStatus populates the provided destination ManagedClusterAutoUpgradeProfile_Status from our ManagedClusterAutoUpgradeProfile_Status
func (managedClusterAutoUpgradeProfileStatus *ManagedClusterAutoUpgradeProfile_Status) AssignPropertiesToManagedClusterAutoUpgradeProfileStatus(destination *v1alpha1api20210501storage.ManagedClusterAutoUpgradeProfile_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// UpgradeChannel
	if managedClusterAutoUpgradeProfileStatus.UpgradeChannel != nil {
		upgradeChannel := string(*managedClusterAutoUpgradeProfileStatus.UpgradeChannel)
		destination.UpgradeChannel = &upgradeChannel
	} else {
		destination.UpgradeChannel = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2021-05-01/Microsoft.ContainerService.json#/definitions/ManagedClusterHTTPProxyConfig
type ManagedClusterHTTPProxyConfig struct {
	//HttpProxy: The HTTP proxy server endpoint to use.
	HttpProxy *string `json:"httpProxy,omitempty"`

	//HttpsProxy: The HTTPS proxy server endpoint to use.
	HttpsProxy *string `json:"httpsProxy,omitempty"`

	//NoProxy: The endpoints that should not go through proxy.
	NoProxy []string `json:"noProxy,omitempty"`

	//TrustedCa: Alternative CA cert to use for connecting to proxy servers.
	TrustedCa *string `json:"trustedCa,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterHTTPProxyConfig{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (managedClusterHTTPProxyConfig *ManagedClusterHTTPProxyConfig) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if managedClusterHTTPProxyConfig == nil {
		return nil, nil
	}
	var result ManagedClusterHTTPProxyConfigARM

	// Set property ‘HttpProxy’:
	if managedClusterHTTPProxyConfig.HttpProxy != nil {
		httpProxy := *managedClusterHTTPProxyConfig.HttpProxy
		result.HttpProxy = &httpProxy
	}

	// Set property ‘HttpsProxy’:
	if managedClusterHTTPProxyConfig.HttpsProxy != nil {
		httpsProxy := *managedClusterHTTPProxyConfig.HttpsProxy
		result.HttpsProxy = &httpsProxy
	}

	// Set property ‘NoProxy’:
	for _, item := range managedClusterHTTPProxyConfig.NoProxy {
		result.NoProxy = append(result.NoProxy, item)
	}

	// Set property ‘TrustedCa’:
	if managedClusterHTTPProxyConfig.TrustedCa != nil {
		trustedCa := *managedClusterHTTPProxyConfig.TrustedCa
		result.TrustedCa = &trustedCa
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (managedClusterHTTPProxyConfig *ManagedClusterHTTPProxyConfig) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterHTTPProxyConfigARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (managedClusterHTTPProxyConfig *ManagedClusterHTTPProxyConfig) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterHTTPProxyConfigARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterHTTPProxyConfigARM, got %T", armInput)
	}

	// Set property ‘HttpProxy’:
	if typedInput.HttpProxy != nil {
		httpProxy := *typedInput.HttpProxy
		managedClusterHTTPProxyConfig.HttpProxy = &httpProxy
	}

	// Set property ‘HttpsProxy’:
	if typedInput.HttpsProxy != nil {
		httpsProxy := *typedInput.HttpsProxy
		managedClusterHTTPProxyConfig.HttpsProxy = &httpsProxy
	}

	// Set property ‘NoProxy’:
	for _, item := range typedInput.NoProxy {
		managedClusterHTTPProxyConfig.NoProxy = append(managedClusterHTTPProxyConfig.NoProxy, item)
	}

	// Set property ‘TrustedCa’:
	if typedInput.TrustedCa != nil {
		trustedCa := *typedInput.TrustedCa
		managedClusterHTTPProxyConfig.TrustedCa = &trustedCa
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterHTTPProxyConfig populates our ManagedClusterHTTPProxyConfig from the provided source ManagedClusterHTTPProxyConfig
func (managedClusterHTTPProxyConfig *ManagedClusterHTTPProxyConfig) AssignPropertiesFromManagedClusterHTTPProxyConfig(source *v1alpha1api20210501storage.ManagedClusterHTTPProxyConfig) error {

	// HttpProxy
	if source.HttpProxy != nil {
		httpProxy := *source.HttpProxy
		managedClusterHTTPProxyConfig.HttpProxy = &httpProxy
	} else {
		managedClusterHTTPProxyConfig.HttpProxy = nil
	}

	// HttpsProxy
	if source.HttpsProxy != nil {
		httpsProxy := *source.HttpsProxy
		managedClusterHTTPProxyConfig.HttpsProxy = &httpsProxy
	} else {
		managedClusterHTTPProxyConfig.HttpsProxy = nil
	}

	// NoProxy
	noProxyList := make([]string, len(source.NoProxy))
	for noProxyIndex, noProxyItem := range source.NoProxy {
		// Shadow the loop variable to avoid aliasing
		noProxyItem := noProxyItem
		noProxyList[noProxyIndex] = noProxyItem
	}
	managedClusterHTTPProxyConfig.NoProxy = noProxyList

	// TrustedCa
	if source.TrustedCa != nil {
		trustedCa := *source.TrustedCa
		managedClusterHTTPProxyConfig.TrustedCa = &trustedCa
	} else {
		managedClusterHTTPProxyConfig.TrustedCa = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterHTTPProxyConfig populates the provided destination ManagedClusterHTTPProxyConfig from our ManagedClusterHTTPProxyConfig
func (managedClusterHTTPProxyConfig *ManagedClusterHTTPProxyConfig) AssignPropertiesToManagedClusterHTTPProxyConfig(destination *v1alpha1api20210501storage.ManagedClusterHTTPProxyConfig) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HttpProxy
	if managedClusterHTTPProxyConfig.HttpProxy != nil {
		httpProxy := *managedClusterHTTPProxyConfig.HttpProxy
		destination.HttpProxy = &httpProxy
	} else {
		destination.HttpProxy = nil
	}

	// HttpsProxy
	if managedClusterHTTPProxyConfig.HttpsProxy != nil {
		httpsProxy := *managedClusterHTTPProxyConfig.HttpsProxy
		destination.HttpsProxy = &httpsProxy
	} else {
		destination.HttpsProxy = nil
	}

	// NoProxy
	noProxyList := make([]string, len(managedClusterHTTPProxyConfig.NoProxy))
	for noProxyIndex, noProxyItem := range managedClusterHTTPProxyConfig.NoProxy {
		// Shadow the loop variable to avoid aliasing
		noProxyItem := noProxyItem
		noProxyList[noProxyIndex] = noProxyItem
	}
	destination.NoProxy = noProxyList

	// TrustedCa
	if managedClusterHTTPProxyConfig.TrustedCa != nil {
		trustedCa := *managedClusterHTTPProxyConfig.TrustedCa
		destination.TrustedCa = &trustedCa
	} else {
		destination.TrustedCa = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type ManagedClusterHTTPProxyConfig_Status struct {
	//HttpProxy: HTTP proxy server endpoint to use.
	HttpProxy *string `json:"httpProxy,omitempty"`

	//HttpsProxy: HTTPS proxy server endpoint to use.
	HttpsProxy *string `json:"httpsProxy,omitempty"`

	//NoProxy: Endpoints that should not go through proxy.
	NoProxy []string `json:"noProxy,omitempty"`

	//TrustedCa: Alternative CA cert to use for connecting to proxy servers.
	TrustedCa *string `json:"trustedCa,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterHTTPProxyConfig_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (managedClusterHTTPProxyConfigStatus *ManagedClusterHTTPProxyConfig_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterHTTPProxyConfig_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (managedClusterHTTPProxyConfigStatus *ManagedClusterHTTPProxyConfig_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterHTTPProxyConfig_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterHTTPProxyConfig_StatusARM, got %T", armInput)
	}

	// Set property ‘HttpProxy’:
	if typedInput.HttpProxy != nil {
		httpProxy := *typedInput.HttpProxy
		managedClusterHTTPProxyConfigStatus.HttpProxy = &httpProxy
	}

	// Set property ‘HttpsProxy’:
	if typedInput.HttpsProxy != nil {
		httpsProxy := *typedInput.HttpsProxy
		managedClusterHTTPProxyConfigStatus.HttpsProxy = &httpsProxy
	}

	// Set property ‘NoProxy’:
	for _, item := range typedInput.NoProxy {
		managedClusterHTTPProxyConfigStatus.NoProxy = append(managedClusterHTTPProxyConfigStatus.NoProxy, item)
	}

	// Set property ‘TrustedCa’:
	if typedInput.TrustedCa != nil {
		trustedCa := *typedInput.TrustedCa
		managedClusterHTTPProxyConfigStatus.TrustedCa = &trustedCa
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterHTTPProxyConfigStatus populates our ManagedClusterHTTPProxyConfig_Status from the provided source ManagedClusterHTTPProxyConfig_Status
func (managedClusterHTTPProxyConfigStatus *ManagedClusterHTTPProxyConfig_Status) AssignPropertiesFromManagedClusterHTTPProxyConfigStatus(source *v1alpha1api20210501storage.ManagedClusterHTTPProxyConfig_Status) error {

	// HttpProxy
	if source.HttpProxy != nil {
		httpProxy := *source.HttpProxy
		managedClusterHTTPProxyConfigStatus.HttpProxy = &httpProxy
	} else {
		managedClusterHTTPProxyConfigStatus.HttpProxy = nil
	}

	// HttpsProxy
	if source.HttpsProxy != nil {
		httpsProxy := *source.HttpsProxy
		managedClusterHTTPProxyConfigStatus.HttpsProxy = &httpsProxy
	} else {
		managedClusterHTTPProxyConfigStatus.HttpsProxy = nil
	}

	// NoProxy
	noProxyList := make([]string, len(source.NoProxy))
	for noProxyIndex, noProxyItem := range source.NoProxy {
		// Shadow the loop variable to avoid aliasing
		noProxyItem := noProxyItem
		noProxyList[noProxyIndex] = noProxyItem
	}
	managedClusterHTTPProxyConfigStatus.NoProxy = noProxyList

	// TrustedCa
	if source.TrustedCa != nil {
		trustedCa := *source.TrustedCa
		managedClusterHTTPProxyConfigStatus.TrustedCa = &trustedCa
	} else {
		managedClusterHTTPProxyConfigStatus.TrustedCa = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterHTTPProxyConfigStatus populates the provided destination ManagedClusterHTTPProxyConfig_Status from our ManagedClusterHTTPProxyConfig_Status
func (managedClusterHTTPProxyConfigStatus *ManagedClusterHTTPProxyConfig_Status) AssignPropertiesToManagedClusterHTTPProxyConfigStatus(destination *v1alpha1api20210501storage.ManagedClusterHTTPProxyConfig_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HttpProxy
	if managedClusterHTTPProxyConfigStatus.HttpProxy != nil {
		httpProxy := *managedClusterHTTPProxyConfigStatus.HttpProxy
		destination.HttpProxy = &httpProxy
	} else {
		destination.HttpProxy = nil
	}

	// HttpsProxy
	if managedClusterHTTPProxyConfigStatus.HttpsProxy != nil {
		httpsProxy := *managedClusterHTTPProxyConfigStatus.HttpsProxy
		destination.HttpsProxy = &httpsProxy
	} else {
		destination.HttpsProxy = nil
	}

	// NoProxy
	noProxyList := make([]string, len(managedClusterHTTPProxyConfigStatus.NoProxy))
	for noProxyIndex, noProxyItem := range managedClusterHTTPProxyConfigStatus.NoProxy {
		// Shadow the loop variable to avoid aliasing
		noProxyItem := noProxyItem
		noProxyList[noProxyIndex] = noProxyItem
	}
	destination.NoProxy = noProxyList

	// TrustedCa
	if managedClusterHTTPProxyConfigStatus.TrustedCa != nil {
		trustedCa := *managedClusterHTTPProxyConfigStatus.TrustedCa
		destination.TrustedCa = &trustedCa
	} else {
		destination.TrustedCa = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2021-05-01/Microsoft.ContainerService.json#/definitions/ManagedClusterIdentity
type ManagedClusterIdentity struct {
	//Type: For more information see [use managed identities in
	//AKS](https://docs.microsoft.com/azure/aks/use-managed-identity).
	Type *ManagedClusterIdentityType `json:"type,omitempty"`

	//UserAssignedIdentities: The keys must be ARM resource IDs in the form:
	//'/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities map[string]v1.JSON `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterIdentity{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (managedClusterIdentity *ManagedClusterIdentity) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if managedClusterIdentity == nil {
		return nil, nil
	}
	var result ManagedClusterIdentityARM

	// Set property ‘Type’:
	if managedClusterIdentity.Type != nil {
		typeVar := *managedClusterIdentity.Type
		result.Type = &typeVar
	}

	// Set property ‘UserAssignedIdentities’:
	if managedClusterIdentity.UserAssignedIdentities != nil {
		result.UserAssignedIdentities = make(map[string]v1.JSON)
		for key, value := range managedClusterIdentity.UserAssignedIdentities {
			result.UserAssignedIdentities[key] = *value.DeepCopy()
		}
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (managedClusterIdentity *ManagedClusterIdentity) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterIdentityARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (managedClusterIdentity *ManagedClusterIdentity) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterIdentityARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterIdentityARM, got %T", armInput)
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		managedClusterIdentity.Type = &typeVar
	}

	// Set property ‘UserAssignedIdentities’:
	if typedInput.UserAssignedIdentities != nil {
		managedClusterIdentity.UserAssignedIdentities = make(map[string]v1.JSON)
		for key, value := range typedInput.UserAssignedIdentities {
			managedClusterIdentity.UserAssignedIdentities[key] = *value.DeepCopy()
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterIdentity populates our ManagedClusterIdentity from the provided source ManagedClusterIdentity
func (managedClusterIdentity *ManagedClusterIdentity) AssignPropertiesFromManagedClusterIdentity(source *v1alpha1api20210501storage.ManagedClusterIdentity) error {

	// Type
	if source.Type != nil {
		typeVar := ManagedClusterIdentityType(*source.Type)
		managedClusterIdentity.Type = &typeVar
	} else {
		managedClusterIdentity.Type = nil
	}

	// UserAssignedIdentities
	userAssignedIdentityMap := make(map[string]v1.JSON)
	for userAssignedIdentityKey, userAssignedIdentityValue := range source.UserAssignedIdentities {
		// Shadow the loop variable to avoid aliasing
		userAssignedIdentityValue := userAssignedIdentityValue
		userAssignedIdentityMap[userAssignedIdentityKey] = *userAssignedIdentityValue.DeepCopy()
	}
	managedClusterIdentity.UserAssignedIdentities = userAssignedIdentityMap

	// No error
	return nil
}

// AssignPropertiesToManagedClusterIdentity populates the provided destination ManagedClusterIdentity from our ManagedClusterIdentity
func (managedClusterIdentity *ManagedClusterIdentity) AssignPropertiesToManagedClusterIdentity(destination *v1alpha1api20210501storage.ManagedClusterIdentity) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if managedClusterIdentity.Type != nil {
		typeVar := string(*managedClusterIdentity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	userAssignedIdentityMap := make(map[string]v1.JSON)
	for userAssignedIdentityKey, userAssignedIdentityValue := range managedClusterIdentity.UserAssignedIdentities {
		// Shadow the loop variable to avoid aliasing
		userAssignedIdentityValue := userAssignedIdentityValue
		userAssignedIdentityMap[userAssignedIdentityKey] = *userAssignedIdentityValue.DeepCopy()
	}
	destination.UserAssignedIdentities = userAssignedIdentityMap

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type ManagedClusterIdentity_Status struct {
	//PrincipalId: The principal id of the system assigned identity which is used by
	//master components.
	PrincipalId *string `json:"principalId,omitempty"`

	//TenantId: The tenant id of the system assigned identity which is used by master
	//components.
	TenantId *string `json:"tenantId,omitempty"`

	//Type: The type of identity used for the managed cluster. Type 'SystemAssigned'
	//will use an implicitly created identity in master components and an auto-created
	//user assigned identity in MC_ resource group in agent nodes. Type 'None' will
	//not use MSI for the managed cluster, service principal will be used instead.
	Type *ManagedClusterIdentityStatusType `json:"type,omitempty"`

	//UserAssignedIdentities: The user identity associated with the managed cluster.
	//This identity will be used in control plane and only one user assigned identity
	//is allowed. The user identity dictionary key references will be ARM resource ids
	//in the form:
	//'/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities map[string]ManagedClusterIdentity_Status_UserAssignedIdentities `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterIdentity_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (managedClusterIdentityStatus *ManagedClusterIdentity_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterIdentity_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (managedClusterIdentityStatus *ManagedClusterIdentity_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterIdentity_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterIdentity_StatusARM, got %T", armInput)
	}

	// Set property ‘PrincipalId’:
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		managedClusterIdentityStatus.PrincipalId = &principalId
	}

	// Set property ‘TenantId’:
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		managedClusterIdentityStatus.TenantId = &tenantId
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		managedClusterIdentityStatus.Type = &typeVar
	}

	// Set property ‘UserAssignedIdentities’:
	if typedInput.UserAssignedIdentities != nil {
		managedClusterIdentityStatus.UserAssignedIdentities = make(map[string]ManagedClusterIdentity_Status_UserAssignedIdentities)
		for key, value := range typedInput.UserAssignedIdentities {
			var value1 ManagedClusterIdentity_Status_UserAssignedIdentities
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			managedClusterIdentityStatus.UserAssignedIdentities[key] = value1
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterIdentityStatus populates our ManagedClusterIdentity_Status from the provided source ManagedClusterIdentity_Status
func (managedClusterIdentityStatus *ManagedClusterIdentity_Status) AssignPropertiesFromManagedClusterIdentityStatus(source *v1alpha1api20210501storage.ManagedClusterIdentity_Status) error {

	// PrincipalId
	if source.PrincipalId != nil {
		principalId := *source.PrincipalId
		managedClusterIdentityStatus.PrincipalId = &principalId
	} else {
		managedClusterIdentityStatus.PrincipalId = nil
	}

	// TenantId
	if source.TenantId != nil {
		tenantId := *source.TenantId
		managedClusterIdentityStatus.TenantId = &tenantId
	} else {
		managedClusterIdentityStatus.TenantId = nil
	}

	// Type
	if source.Type != nil {
		typeVar := ManagedClusterIdentityStatusType(*source.Type)
		managedClusterIdentityStatus.Type = &typeVar
	} else {
		managedClusterIdentityStatus.Type = nil
	}

	// UserAssignedIdentities
	userAssignedIdentityMap := make(map[string]ManagedClusterIdentity_Status_UserAssignedIdentities)
	for userAssignedIdentityKey, userAssignedIdentityValue := range source.UserAssignedIdentities {
		// Shadow the loop variable to avoid aliasing
		userAssignedIdentityValue := userAssignedIdentityValue
		var userAssignedIdentity ManagedClusterIdentity_Status_UserAssignedIdentities
		err := userAssignedIdentity.AssignPropertiesFromManagedClusterIdentityStatusUserAssignedIdentities(&userAssignedIdentityValue)
		if err != nil {
			return errors.Wrap(err, "populating UserAssignedIdentities from UserAssignedIdentities, calling AssignPropertiesFromManagedClusterIdentityStatusUserAssignedIdentities()")
		}
		userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
	}
	managedClusterIdentityStatus.UserAssignedIdentities = userAssignedIdentityMap

	// No error
	return nil
}

// AssignPropertiesToManagedClusterIdentityStatus populates the provided destination ManagedClusterIdentity_Status from our ManagedClusterIdentity_Status
func (managedClusterIdentityStatus *ManagedClusterIdentity_Status) AssignPropertiesToManagedClusterIdentityStatus(destination *v1alpha1api20210501storage.ManagedClusterIdentity_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrincipalId
	if managedClusterIdentityStatus.PrincipalId != nil {
		principalId := *managedClusterIdentityStatus.PrincipalId
		destination.PrincipalId = &principalId
	} else {
		destination.PrincipalId = nil
	}

	// TenantId
	if managedClusterIdentityStatus.TenantId != nil {
		tenantId := *managedClusterIdentityStatus.TenantId
		destination.TenantId = &tenantId
	} else {
		destination.TenantId = nil
	}

	// Type
	if managedClusterIdentityStatus.Type != nil {
		typeVar := string(*managedClusterIdentityStatus.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	userAssignedIdentityMap := make(map[string]v1alpha1api20210501storage.ManagedClusterIdentity_Status_UserAssignedIdentities)
	for userAssignedIdentityKey, userAssignedIdentityValue := range managedClusterIdentityStatus.UserAssignedIdentities {
		// Shadow the loop variable to avoid aliasing
		userAssignedIdentityValue := userAssignedIdentityValue
		var userAssignedIdentity v1alpha1api20210501storage.ManagedClusterIdentity_Status_UserAssignedIdentities
		err := userAssignedIdentityValue.AssignPropertiesToManagedClusterIdentityStatusUserAssignedIdentities(&userAssignedIdentity)
		if err != nil {
			return errors.Wrap(err, "populating UserAssignedIdentities from UserAssignedIdentities, calling AssignPropertiesToManagedClusterIdentityStatusUserAssignedIdentities()")
		}
		userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
	}
	destination.UserAssignedIdentities = userAssignedIdentityMap

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2021-05-01/Microsoft.ContainerService.json#/definitions/ManagedClusterPodIdentityProfile
type ManagedClusterPodIdentityProfile struct {
	//AllowNetworkPluginKubenet: Running in Kubenet is disabled by default due to the
	//security related nature of AAD Pod Identity and the risks of IP spoofing. See
	//[using Kubenet network plugin with AAD Pod
	//Identity](https://docs.microsoft.com/azure/aks/use-azure-ad-pod-identity#using-kubenet-network-plugin-with-azure-active-directory-pod-managed-identities)
	//for more information.
	AllowNetworkPluginKubenet *bool `json:"allowNetworkPluginKubenet,omitempty"`

	//Enabled: Whether the pod identity addon is enabled.
	Enabled *bool `json:"enabled,omitempty"`

	//UserAssignedIdentities: The pod identities to use in the cluster.
	UserAssignedIdentities []ManagedClusterPodIdentity `json:"userAssignedIdentities,omitempty"`

	//UserAssignedIdentityExceptions: The pod identity exceptions to allow.
	UserAssignedIdentityExceptions []ManagedClusterPodIdentityException `json:"userAssignedIdentityExceptions,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterPodIdentityProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (managedClusterPodIdentityProfile *ManagedClusterPodIdentityProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if managedClusterPodIdentityProfile == nil {
		return nil, nil
	}
	var result ManagedClusterPodIdentityProfileARM

	// Set property ‘AllowNetworkPluginKubenet’:
	if managedClusterPodIdentityProfile.AllowNetworkPluginKubenet != nil {
		allowNetworkPluginKubenet := *managedClusterPodIdentityProfile.AllowNetworkPluginKubenet
		result.AllowNetworkPluginKubenet = &allowNetworkPluginKubenet
	}

	// Set property ‘Enabled’:
	if managedClusterPodIdentityProfile.Enabled != nil {
		enabled := *managedClusterPodIdentityProfile.Enabled
		result.Enabled = &enabled
	}

	// Set property ‘UserAssignedIdentities’:
	for _, item := range managedClusterPodIdentityProfile.UserAssignedIdentities {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.UserAssignedIdentities = append(result.UserAssignedIdentities, itemARM.(ManagedClusterPodIdentityARM))
	}

	// Set property ‘UserAssignedIdentityExceptions’:
	for _, item := range managedClusterPodIdentityProfile.UserAssignedIdentityExceptions {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.UserAssignedIdentityExceptions = append(result.UserAssignedIdentityExceptions, itemARM.(ManagedClusterPodIdentityExceptionARM))
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (managedClusterPodIdentityProfile *ManagedClusterPodIdentityProfile) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterPodIdentityProfileARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (managedClusterPodIdentityProfile *ManagedClusterPodIdentityProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterPodIdentityProfileARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterPodIdentityProfileARM, got %T", armInput)
	}

	// Set property ‘AllowNetworkPluginKubenet’:
	if typedInput.AllowNetworkPluginKubenet != nil {
		allowNetworkPluginKubenet := *typedInput.AllowNetworkPluginKubenet
		managedClusterPodIdentityProfile.AllowNetworkPluginKubenet = &allowNetworkPluginKubenet
	}

	// Set property ‘Enabled’:
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		managedClusterPodIdentityProfile.Enabled = &enabled
	}

	// Set property ‘UserAssignedIdentities’:
	for _, item := range typedInput.UserAssignedIdentities {
		var item1 ManagedClusterPodIdentity
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		managedClusterPodIdentityProfile.UserAssignedIdentities = append(managedClusterPodIdentityProfile.UserAssignedIdentities, item1)
	}

	// Set property ‘UserAssignedIdentityExceptions’:
	for _, item := range typedInput.UserAssignedIdentityExceptions {
		var item1 ManagedClusterPodIdentityException
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		managedClusterPodIdentityProfile.UserAssignedIdentityExceptions = append(managedClusterPodIdentityProfile.UserAssignedIdentityExceptions, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterPodIdentityProfile populates our ManagedClusterPodIdentityProfile from the provided source ManagedClusterPodIdentityProfile
func (managedClusterPodIdentityProfile *ManagedClusterPodIdentityProfile) AssignPropertiesFromManagedClusterPodIdentityProfile(source *v1alpha1api20210501storage.ManagedClusterPodIdentityProfile) error {

	// AllowNetworkPluginKubenet
	if source.AllowNetworkPluginKubenet != nil {
		allowNetworkPluginKubenet := *source.AllowNetworkPluginKubenet
		managedClusterPodIdentityProfile.AllowNetworkPluginKubenet = &allowNetworkPluginKubenet
	} else {
		managedClusterPodIdentityProfile.AllowNetworkPluginKubenet = nil
	}

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		managedClusterPodIdentityProfile.Enabled = &enabled
	} else {
		managedClusterPodIdentityProfile.Enabled = nil
	}

	// UserAssignedIdentities
	userAssignedIdentityList := make([]ManagedClusterPodIdentity, len(source.UserAssignedIdentities))
	for userAssignedIdentityIndex, userAssignedIdentityItem := range source.UserAssignedIdentities {
		// Shadow the loop variable to avoid aliasing
		userAssignedIdentityItem := userAssignedIdentityItem
		var userAssignedIdentity ManagedClusterPodIdentity
		err := userAssignedIdentity.AssignPropertiesFromManagedClusterPodIdentity(&userAssignedIdentityItem)
		if err != nil {
			return errors.Wrap(err, "populating UserAssignedIdentities from UserAssignedIdentities, calling AssignPropertiesFromManagedClusterPodIdentity()")
		}
		userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
	}
	managedClusterPodIdentityProfile.UserAssignedIdentities = userAssignedIdentityList

	// UserAssignedIdentityExceptions
	userAssignedIdentityExceptionList := make([]ManagedClusterPodIdentityException, len(source.UserAssignedIdentityExceptions))
	for userAssignedIdentityExceptionIndex, userAssignedIdentityExceptionItem := range source.UserAssignedIdentityExceptions {
		// Shadow the loop variable to avoid aliasing
		userAssignedIdentityExceptionItem := userAssignedIdentityExceptionItem
		var userAssignedIdentityException ManagedClusterPodIdentityException
		err := userAssignedIdentityException.AssignPropertiesFromManagedClusterPodIdentityException(&userAssignedIdentityExceptionItem)
		if err != nil {
			return errors.Wrap(err, "populating UserAssignedIdentityExceptions from UserAssignedIdentityExceptions, calling AssignPropertiesFromManagedClusterPodIdentityException()")
		}
		userAssignedIdentityExceptionList[userAssignedIdentityExceptionIndex] = userAssignedIdentityException
	}
	managedClusterPodIdentityProfile.UserAssignedIdentityExceptions = userAssignedIdentityExceptionList

	// No error
	return nil
}

// AssignPropertiesToManagedClusterPodIdentityProfile populates the provided destination ManagedClusterPodIdentityProfile from our ManagedClusterPodIdentityProfile
func (managedClusterPodIdentityProfile *ManagedClusterPodIdentityProfile) AssignPropertiesToManagedClusterPodIdentityProfile(destination *v1alpha1api20210501storage.ManagedClusterPodIdentityProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllowNetworkPluginKubenet
	if managedClusterPodIdentityProfile.AllowNetworkPluginKubenet != nil {
		allowNetworkPluginKubenet := *managedClusterPodIdentityProfile.AllowNetworkPluginKubenet
		destination.AllowNetworkPluginKubenet = &allowNetworkPluginKubenet
	} else {
		destination.AllowNetworkPluginKubenet = nil
	}

	// Enabled
	if managedClusterPodIdentityProfile.Enabled != nil {
		enabled := *managedClusterPodIdentityProfile.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// UserAssignedIdentities
	userAssignedIdentityList := make([]v1alpha1api20210501storage.ManagedClusterPodIdentity, len(managedClusterPodIdentityProfile.UserAssignedIdentities))
	for userAssignedIdentityIndex, userAssignedIdentityItem := range managedClusterPodIdentityProfile.UserAssignedIdentities {
		// Shadow the loop variable to avoid aliasing
		userAssignedIdentityItem := userAssignedIdentityItem
		var userAssignedIdentity v1alpha1api20210501storage.ManagedClusterPodIdentity
		err := userAssignedIdentityItem.AssignPropertiesToManagedClusterPodIdentity(&userAssignedIdentity)
		if err != nil {
			return errors.Wrap(err, "populating UserAssignedIdentities from UserAssignedIdentities, calling AssignPropertiesToManagedClusterPodIdentity()")
		}
		userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
	}
	destination.UserAssignedIdentities = userAssignedIdentityList

	// UserAssignedIdentityExceptions
	userAssignedIdentityExceptionList := make([]v1alpha1api20210501storage.ManagedClusterPodIdentityException, len(managedClusterPodIdentityProfile.UserAssignedIdentityExceptions))
	for userAssignedIdentityExceptionIndex, userAssignedIdentityExceptionItem := range managedClusterPodIdentityProfile.UserAssignedIdentityExceptions {
		// Shadow the loop variable to avoid aliasing
		userAssignedIdentityExceptionItem := userAssignedIdentityExceptionItem
		var userAssignedIdentityException v1alpha1api20210501storage.ManagedClusterPodIdentityException
		err := userAssignedIdentityExceptionItem.AssignPropertiesToManagedClusterPodIdentityException(&userAssignedIdentityException)
		if err != nil {
			return errors.Wrap(err, "populating UserAssignedIdentityExceptions from UserAssignedIdentityExceptions, calling AssignPropertiesToManagedClusterPodIdentityException()")
		}
		userAssignedIdentityExceptionList[userAssignedIdentityExceptionIndex] = userAssignedIdentityException
	}
	destination.UserAssignedIdentityExceptions = userAssignedIdentityExceptionList

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type ManagedClusterPodIdentityProfile_Status struct {
	//AllowNetworkPluginKubenet: Customer consent for enabling AAD pod identity addon
	//in cluster using Kubenet network plugin.
	AllowNetworkPluginKubenet *bool `json:"allowNetworkPluginKubenet,omitempty"`

	//Enabled: Whether the pod identity addon is enabled.
	Enabled *bool `json:"enabled,omitempty"`

	//UserAssignedIdentities: User assigned pod identity settings.
	UserAssignedIdentities []ManagedClusterPodIdentity_Status `json:"userAssignedIdentities,omitempty"`

	//UserAssignedIdentityExceptions: User assigned pod identity exception settings.
	UserAssignedIdentityExceptions []ManagedClusterPodIdentityException_Status `json:"userAssignedIdentityExceptions,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterPodIdentityProfile_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (managedClusterPodIdentityProfileStatus *ManagedClusterPodIdentityProfile_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterPodIdentityProfile_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (managedClusterPodIdentityProfileStatus *ManagedClusterPodIdentityProfile_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterPodIdentityProfile_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterPodIdentityProfile_StatusARM, got %T", armInput)
	}

	// Set property ‘AllowNetworkPluginKubenet’:
	if typedInput.AllowNetworkPluginKubenet != nil {
		allowNetworkPluginKubenet := *typedInput.AllowNetworkPluginKubenet
		managedClusterPodIdentityProfileStatus.AllowNetworkPluginKubenet = &allowNetworkPluginKubenet
	}

	// Set property ‘Enabled’:
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		managedClusterPodIdentityProfileStatus.Enabled = &enabled
	}

	// Set property ‘UserAssignedIdentities’:
	for _, item := range typedInput.UserAssignedIdentities {
		var item1 ManagedClusterPodIdentity_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		managedClusterPodIdentityProfileStatus.UserAssignedIdentities = append(managedClusterPodIdentityProfileStatus.UserAssignedIdentities, item1)
	}

	// Set property ‘UserAssignedIdentityExceptions’:
	for _, item := range typedInput.UserAssignedIdentityExceptions {
		var item1 ManagedClusterPodIdentityException_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		managedClusterPodIdentityProfileStatus.UserAssignedIdentityExceptions = append(managedClusterPodIdentityProfileStatus.UserAssignedIdentityExceptions, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterPodIdentityProfileStatus populates our ManagedClusterPodIdentityProfile_Status from the provided source ManagedClusterPodIdentityProfile_Status
func (managedClusterPodIdentityProfileStatus *ManagedClusterPodIdentityProfile_Status) AssignPropertiesFromManagedClusterPodIdentityProfileStatus(source *v1alpha1api20210501storage.ManagedClusterPodIdentityProfile_Status) error {

	// AllowNetworkPluginKubenet
	if source.AllowNetworkPluginKubenet != nil {
		allowNetworkPluginKubenet := *source.AllowNetworkPluginKubenet
		managedClusterPodIdentityProfileStatus.AllowNetworkPluginKubenet = &allowNetworkPluginKubenet
	} else {
		managedClusterPodIdentityProfileStatus.AllowNetworkPluginKubenet = nil
	}

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		managedClusterPodIdentityProfileStatus.Enabled = &enabled
	} else {
		managedClusterPodIdentityProfileStatus.Enabled = nil
	}

	// UserAssignedIdentities
	userAssignedIdentityList := make([]ManagedClusterPodIdentity_Status, len(source.UserAssignedIdentities))
	for userAssignedIdentityIndex, userAssignedIdentityItem := range source.UserAssignedIdentities {
		// Shadow the loop variable to avoid aliasing
		userAssignedIdentityItem := userAssignedIdentityItem
		var userAssignedIdentity ManagedClusterPodIdentity_Status
		err := userAssignedIdentity.AssignPropertiesFromManagedClusterPodIdentityStatus(&userAssignedIdentityItem)
		if err != nil {
			return errors.Wrap(err, "populating UserAssignedIdentities from UserAssignedIdentities, calling AssignPropertiesFromManagedClusterPodIdentityStatus()")
		}
		userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
	}
	managedClusterPodIdentityProfileStatus.UserAssignedIdentities = userAssignedIdentityList

	// UserAssignedIdentityExceptions
	userAssignedIdentityExceptionList := make([]ManagedClusterPodIdentityException_Status, len(source.UserAssignedIdentityExceptions))
	for userAssignedIdentityExceptionIndex, userAssignedIdentityExceptionItem := range source.UserAssignedIdentityExceptions {
		// Shadow the loop variable to avoid aliasing
		userAssignedIdentityExceptionItem := userAssignedIdentityExceptionItem
		var userAssignedIdentityException ManagedClusterPodIdentityException_Status
		err := userAssignedIdentityException.AssignPropertiesFromManagedClusterPodIdentityExceptionStatus(&userAssignedIdentityExceptionItem)
		if err != nil {
			return errors.Wrap(err, "populating UserAssignedIdentityExceptions from UserAssignedIdentityExceptions, calling AssignPropertiesFromManagedClusterPodIdentityExceptionStatus()")
		}
		userAssignedIdentityExceptionList[userAssignedIdentityExceptionIndex] = userAssignedIdentityException
	}
	managedClusterPodIdentityProfileStatus.UserAssignedIdentityExceptions = userAssignedIdentityExceptionList

	// No error
	return nil
}

// AssignPropertiesToManagedClusterPodIdentityProfileStatus populates the provided destination ManagedClusterPodIdentityProfile_Status from our ManagedClusterPodIdentityProfile_Status
func (managedClusterPodIdentityProfileStatus *ManagedClusterPodIdentityProfile_Status) AssignPropertiesToManagedClusterPodIdentityProfileStatus(destination *v1alpha1api20210501storage.ManagedClusterPodIdentityProfile_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllowNetworkPluginKubenet
	if managedClusterPodIdentityProfileStatus.AllowNetworkPluginKubenet != nil {
		allowNetworkPluginKubenet := *managedClusterPodIdentityProfileStatus.AllowNetworkPluginKubenet
		destination.AllowNetworkPluginKubenet = &allowNetworkPluginKubenet
	} else {
		destination.AllowNetworkPluginKubenet = nil
	}

	// Enabled
	if managedClusterPodIdentityProfileStatus.Enabled != nil {
		enabled := *managedClusterPodIdentityProfileStatus.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// UserAssignedIdentities
	userAssignedIdentityList := make([]v1alpha1api20210501storage.ManagedClusterPodIdentity_Status, len(managedClusterPodIdentityProfileStatus.UserAssignedIdentities))
	for userAssignedIdentityIndex, userAssignedIdentityItem := range managedClusterPodIdentityProfileStatus.UserAssignedIdentities {
		// Shadow the loop variable to avoid aliasing
		userAssignedIdentityItem := userAssignedIdentityItem
		var userAssignedIdentity v1alpha1api20210501storage.ManagedClusterPodIdentity_Status
		err := userAssignedIdentityItem.AssignPropertiesToManagedClusterPodIdentityStatus(&userAssignedIdentity)
		if err != nil {
			return errors.Wrap(err, "populating UserAssignedIdentities from UserAssignedIdentities, calling AssignPropertiesToManagedClusterPodIdentityStatus()")
		}
		userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
	}
	destination.UserAssignedIdentities = userAssignedIdentityList

	// UserAssignedIdentityExceptions
	userAssignedIdentityExceptionList := make([]v1alpha1api20210501storage.ManagedClusterPodIdentityException_Status, len(managedClusterPodIdentityProfileStatus.UserAssignedIdentityExceptions))
	for userAssignedIdentityExceptionIndex, userAssignedIdentityExceptionItem := range managedClusterPodIdentityProfileStatus.UserAssignedIdentityExceptions {
		// Shadow the loop variable to avoid aliasing
		userAssignedIdentityExceptionItem := userAssignedIdentityExceptionItem
		var userAssignedIdentityException v1alpha1api20210501storage.ManagedClusterPodIdentityException_Status
		err := userAssignedIdentityExceptionItem.AssignPropertiesToManagedClusterPodIdentityExceptionStatus(&userAssignedIdentityException)
		if err != nil {
			return errors.Wrap(err, "populating UserAssignedIdentityExceptions from UserAssignedIdentityExceptions, calling AssignPropertiesToManagedClusterPodIdentityExceptionStatus()")
		}
		userAssignedIdentityExceptionList[userAssignedIdentityExceptionIndex] = userAssignedIdentityException
	}
	destination.UserAssignedIdentityExceptions = userAssignedIdentityExceptionList

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2021-05-01/Microsoft.ContainerService.json#/definitions/ManagedClusterPropertiesAutoScalerProfile
type ManagedClusterPropertiesAutoScalerProfile struct {
	//BalanceSimilarNodeGroups: Valid values are 'true' and 'false'
	BalanceSimilarNodeGroups *string `json:"balance-similar-node-groups,omitempty"`

	//Expander: If not specified, the default is 'random'. See
	//[expanders](https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#what-are-expanders)
	//for more information.
	Expander *ManagedClusterPropertiesAutoScalerProfileExpander `json:"expander,omitempty"`

	//MaxEmptyBulkDelete: The default is 10.
	MaxEmptyBulkDelete *string `json:"max-empty-bulk-delete,omitempty"`

	//MaxGracefulTerminationSec: The default is 600.
	MaxGracefulTerminationSec *string `json:"max-graceful-termination-sec,omitempty"`

	//MaxNodeProvisionTime: The default is '15m'. Values must be an integer followed
	//by an 'm'. No unit of time other than minutes (m) is supported.
	MaxNodeProvisionTime *string `json:"max-node-provision-time,omitempty"`

	//MaxTotalUnreadyPercentage: The default is 45. The maximum is 100 and the minimum
	//is 0.
	MaxTotalUnreadyPercentage *string `json:"max-total-unready-percentage,omitempty"`

	//NewPodScaleUpDelay: For scenarios like burst/batch scale where you don't want CA
	//to act before the kubernetes scheduler could schedule all the pods, you can tell
	//CA to ignore unscheduled pods before they're a certain age. The default is '0s'.
	//Values must be an integer followed by a unit ('s' for seconds, 'm' for minutes,
	//'h' for hours, etc).
	NewPodScaleUpDelay *string `json:"new-pod-scale-up-delay,omitempty"`

	//OkTotalUnreadyCount: This must be an integer. The default is 3.
	OkTotalUnreadyCount *string `json:"ok-total-unready-count,omitempty"`

	//ScaleDownDelayAfterAdd: The default is '10m'. Values must be an integer followed
	//by an 'm'. No unit of time other than minutes (m) is supported.
	ScaleDownDelayAfterAdd *string `json:"scale-down-delay-after-add,omitempty"`

	//ScaleDownDelayAfterDelete: The default is the scan-interval. Values must be an
	//integer followed by an 'm'. No unit of time other than minutes (m) is supported.
	ScaleDownDelayAfterDelete *string `json:"scale-down-delay-after-delete,omitempty"`

	//ScaleDownDelayAfterFailure: The default is '3m'. Values must be an integer
	//followed by an 'm'. No unit of time other than minutes (m) is supported.
	ScaleDownDelayAfterFailure *string `json:"scale-down-delay-after-failure,omitempty"`

	//ScaleDownUnneededTime: The default is '10m'. Values must be an integer followed
	//by an 'm'. No unit of time other than minutes (m) is supported.
	ScaleDownUnneededTime *string `json:"scale-down-unneeded-time,omitempty"`

	//ScaleDownUnreadyTime: The default is '20m'. Values must be an integer followed
	//by an 'm'. No unit of time other than minutes (m) is supported.
	ScaleDownUnreadyTime *string `json:"scale-down-unready-time,omitempty"`

	//ScaleDownUtilizationThreshold: The default is '0.5'.
	ScaleDownUtilizationThreshold *string `json:"scale-down-utilization-threshold,omitempty"`

	//ScanInterval: The default is '10'. Values must be an integer number of seconds.
	ScanInterval *string `json:"scan-interval,omitempty"`

	//SkipNodesWithLocalStorage: The default is true.
	SkipNodesWithLocalStorage *string `json:"skip-nodes-with-local-storage,omitempty"`

	//SkipNodesWithSystemPods: The default is true.
	SkipNodesWithSystemPods *string `json:"skip-nodes-with-system-pods,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterPropertiesAutoScalerProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (managedClusterPropertiesAutoScalerProfile *ManagedClusterPropertiesAutoScalerProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if managedClusterPropertiesAutoScalerProfile == nil {
		return nil, nil
	}
	var result ManagedClusterPropertiesAutoScalerProfileARM

	// Set property ‘BalanceSimilarNodeGroups’:
	if managedClusterPropertiesAutoScalerProfile.BalanceSimilarNodeGroups != nil {
		balanceSimilarNodeGroups := *managedClusterPropertiesAutoScalerProfile.BalanceSimilarNodeGroups
		result.BalanceSimilarNodeGroups = &balanceSimilarNodeGroups
	}

	// Set property ‘Expander’:
	if managedClusterPropertiesAutoScalerProfile.Expander != nil {
		expander := *managedClusterPropertiesAutoScalerProfile.Expander
		result.Expander = &expander
	}

	// Set property ‘MaxEmptyBulkDelete’:
	if managedClusterPropertiesAutoScalerProfile.MaxEmptyBulkDelete != nil {
		maxEmptyBulkDelete := *managedClusterPropertiesAutoScalerProfile.MaxEmptyBulkDelete
		result.MaxEmptyBulkDelete = &maxEmptyBulkDelete
	}

	// Set property ‘MaxGracefulTerminationSec’:
	if managedClusterPropertiesAutoScalerProfile.MaxGracefulTerminationSec != nil {
		maxGracefulTerminationSec := *managedClusterPropertiesAutoScalerProfile.MaxGracefulTerminationSec
		result.MaxGracefulTerminationSec = &maxGracefulTerminationSec
	}

	// Set property ‘MaxNodeProvisionTime’:
	if managedClusterPropertiesAutoScalerProfile.MaxNodeProvisionTime != nil {
		maxNodeProvisionTime := *managedClusterPropertiesAutoScalerProfile.MaxNodeProvisionTime
		result.MaxNodeProvisionTime = &maxNodeProvisionTime
	}

	// Set property ‘MaxTotalUnreadyPercentage’:
	if managedClusterPropertiesAutoScalerProfile.MaxTotalUnreadyPercentage != nil {
		maxTotalUnreadyPercentage := *managedClusterPropertiesAutoScalerProfile.MaxTotalUnreadyPercentage
		result.MaxTotalUnreadyPercentage = &maxTotalUnreadyPercentage
	}

	// Set property ‘NewPodScaleUpDelay’:
	if managedClusterPropertiesAutoScalerProfile.NewPodScaleUpDelay != nil {
		newPodScaleUpDelay := *managedClusterPropertiesAutoScalerProfile.NewPodScaleUpDelay
		result.NewPodScaleUpDelay = &newPodScaleUpDelay
	}

	// Set property ‘OkTotalUnreadyCount’:
	if managedClusterPropertiesAutoScalerProfile.OkTotalUnreadyCount != nil {
		okTotalUnreadyCount := *managedClusterPropertiesAutoScalerProfile.OkTotalUnreadyCount
		result.OkTotalUnreadyCount = &okTotalUnreadyCount
	}

	// Set property ‘ScaleDownDelayAfterAdd’:
	if managedClusterPropertiesAutoScalerProfile.ScaleDownDelayAfterAdd != nil {
		scaleDownDelayAfterAdd := *managedClusterPropertiesAutoScalerProfile.ScaleDownDelayAfterAdd
		result.ScaleDownDelayAfterAdd = &scaleDownDelayAfterAdd
	}

	// Set property ‘ScaleDownDelayAfterDelete’:
	if managedClusterPropertiesAutoScalerProfile.ScaleDownDelayAfterDelete != nil {
		scaleDownDelayAfterDelete := *managedClusterPropertiesAutoScalerProfile.ScaleDownDelayAfterDelete
		result.ScaleDownDelayAfterDelete = &scaleDownDelayAfterDelete
	}

	// Set property ‘ScaleDownDelayAfterFailure’:
	if managedClusterPropertiesAutoScalerProfile.ScaleDownDelayAfterFailure != nil {
		scaleDownDelayAfterFailure := *managedClusterPropertiesAutoScalerProfile.ScaleDownDelayAfterFailure
		result.ScaleDownDelayAfterFailure = &scaleDownDelayAfterFailure
	}

	// Set property ‘ScaleDownUnneededTime’:
	if managedClusterPropertiesAutoScalerProfile.ScaleDownUnneededTime != nil {
		scaleDownUnneededTime := *managedClusterPropertiesAutoScalerProfile.ScaleDownUnneededTime
		result.ScaleDownUnneededTime = &scaleDownUnneededTime
	}

	// Set property ‘ScaleDownUnreadyTime’:
	if managedClusterPropertiesAutoScalerProfile.ScaleDownUnreadyTime != nil {
		scaleDownUnreadyTime := *managedClusterPropertiesAutoScalerProfile.ScaleDownUnreadyTime
		result.ScaleDownUnreadyTime = &scaleDownUnreadyTime
	}

	// Set property ‘ScaleDownUtilizationThreshold’:
	if managedClusterPropertiesAutoScalerProfile.ScaleDownUtilizationThreshold != nil {
		scaleDownUtilizationThreshold := *managedClusterPropertiesAutoScalerProfile.ScaleDownUtilizationThreshold
		result.ScaleDownUtilizationThreshold = &scaleDownUtilizationThreshold
	}

	// Set property ‘ScanInterval’:
	if managedClusterPropertiesAutoScalerProfile.ScanInterval != nil {
		scanInterval := *managedClusterPropertiesAutoScalerProfile.ScanInterval
		result.ScanInterval = &scanInterval
	}

	// Set property ‘SkipNodesWithLocalStorage’:
	if managedClusterPropertiesAutoScalerProfile.SkipNodesWithLocalStorage != nil {
		skipNodesWithLocalStorage := *managedClusterPropertiesAutoScalerProfile.SkipNodesWithLocalStorage
		result.SkipNodesWithLocalStorage = &skipNodesWithLocalStorage
	}

	// Set property ‘SkipNodesWithSystemPods’:
	if managedClusterPropertiesAutoScalerProfile.SkipNodesWithSystemPods != nil {
		skipNodesWithSystemPods := *managedClusterPropertiesAutoScalerProfile.SkipNodesWithSystemPods
		result.SkipNodesWithSystemPods = &skipNodesWithSystemPods
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (managedClusterPropertiesAutoScalerProfile *ManagedClusterPropertiesAutoScalerProfile) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterPropertiesAutoScalerProfileARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (managedClusterPropertiesAutoScalerProfile *ManagedClusterPropertiesAutoScalerProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterPropertiesAutoScalerProfileARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterPropertiesAutoScalerProfileARM, got %T", armInput)
	}

	// Set property ‘BalanceSimilarNodeGroups’:
	if typedInput.BalanceSimilarNodeGroups != nil {
		balanceSimilarNodeGroups := *typedInput.BalanceSimilarNodeGroups
		managedClusterPropertiesAutoScalerProfile.BalanceSimilarNodeGroups = &balanceSimilarNodeGroups
	}

	// Set property ‘Expander’:
	if typedInput.Expander != nil {
		expander := *typedInput.Expander
		managedClusterPropertiesAutoScalerProfile.Expander = &expander
	}

	// Set property ‘MaxEmptyBulkDelete’:
	if typedInput.MaxEmptyBulkDelete != nil {
		maxEmptyBulkDelete := *typedInput.MaxEmptyBulkDelete
		managedClusterPropertiesAutoScalerProfile.MaxEmptyBulkDelete = &maxEmptyBulkDelete
	}

	// Set property ‘MaxGracefulTerminationSec’:
	if typedInput.MaxGracefulTerminationSec != nil {
		maxGracefulTerminationSec := *typedInput.MaxGracefulTerminationSec
		managedClusterPropertiesAutoScalerProfile.MaxGracefulTerminationSec = &maxGracefulTerminationSec
	}

	// Set property ‘MaxNodeProvisionTime’:
	if typedInput.MaxNodeProvisionTime != nil {
		maxNodeProvisionTime := *typedInput.MaxNodeProvisionTime
		managedClusterPropertiesAutoScalerProfile.MaxNodeProvisionTime = &maxNodeProvisionTime
	}

	// Set property ‘MaxTotalUnreadyPercentage’:
	if typedInput.MaxTotalUnreadyPercentage != nil {
		maxTotalUnreadyPercentage := *typedInput.MaxTotalUnreadyPercentage
		managedClusterPropertiesAutoScalerProfile.MaxTotalUnreadyPercentage = &maxTotalUnreadyPercentage
	}

	// Set property ‘NewPodScaleUpDelay’:
	if typedInput.NewPodScaleUpDelay != nil {
		newPodScaleUpDelay := *typedInput.NewPodScaleUpDelay
		managedClusterPropertiesAutoScalerProfile.NewPodScaleUpDelay = &newPodScaleUpDelay
	}

	// Set property ‘OkTotalUnreadyCount’:
	if typedInput.OkTotalUnreadyCount != nil {
		okTotalUnreadyCount := *typedInput.OkTotalUnreadyCount
		managedClusterPropertiesAutoScalerProfile.OkTotalUnreadyCount = &okTotalUnreadyCount
	}

	// Set property ‘ScaleDownDelayAfterAdd’:
	if typedInput.ScaleDownDelayAfterAdd != nil {
		scaleDownDelayAfterAdd := *typedInput.ScaleDownDelayAfterAdd
		managedClusterPropertiesAutoScalerProfile.ScaleDownDelayAfterAdd = &scaleDownDelayAfterAdd
	}

	// Set property ‘ScaleDownDelayAfterDelete’:
	if typedInput.ScaleDownDelayAfterDelete != nil {
		scaleDownDelayAfterDelete := *typedInput.ScaleDownDelayAfterDelete
		managedClusterPropertiesAutoScalerProfile.ScaleDownDelayAfterDelete = &scaleDownDelayAfterDelete
	}

	// Set property ‘ScaleDownDelayAfterFailure’:
	if typedInput.ScaleDownDelayAfterFailure != nil {
		scaleDownDelayAfterFailure := *typedInput.ScaleDownDelayAfterFailure
		managedClusterPropertiesAutoScalerProfile.ScaleDownDelayAfterFailure = &scaleDownDelayAfterFailure
	}

	// Set property ‘ScaleDownUnneededTime’:
	if typedInput.ScaleDownUnneededTime != nil {
		scaleDownUnneededTime := *typedInput.ScaleDownUnneededTime
		managedClusterPropertiesAutoScalerProfile.ScaleDownUnneededTime = &scaleDownUnneededTime
	}

	// Set property ‘ScaleDownUnreadyTime’:
	if typedInput.ScaleDownUnreadyTime != nil {
		scaleDownUnreadyTime := *typedInput.ScaleDownUnreadyTime
		managedClusterPropertiesAutoScalerProfile.ScaleDownUnreadyTime = &scaleDownUnreadyTime
	}

	// Set property ‘ScaleDownUtilizationThreshold’:
	if typedInput.ScaleDownUtilizationThreshold != nil {
		scaleDownUtilizationThreshold := *typedInput.ScaleDownUtilizationThreshold
		managedClusterPropertiesAutoScalerProfile.ScaleDownUtilizationThreshold = &scaleDownUtilizationThreshold
	}

	// Set property ‘ScanInterval’:
	if typedInput.ScanInterval != nil {
		scanInterval := *typedInput.ScanInterval
		managedClusterPropertiesAutoScalerProfile.ScanInterval = &scanInterval
	}

	// Set property ‘SkipNodesWithLocalStorage’:
	if typedInput.SkipNodesWithLocalStorage != nil {
		skipNodesWithLocalStorage := *typedInput.SkipNodesWithLocalStorage
		managedClusterPropertiesAutoScalerProfile.SkipNodesWithLocalStorage = &skipNodesWithLocalStorage
	}

	// Set property ‘SkipNodesWithSystemPods’:
	if typedInput.SkipNodesWithSystemPods != nil {
		skipNodesWithSystemPods := *typedInput.SkipNodesWithSystemPods
		managedClusterPropertiesAutoScalerProfile.SkipNodesWithSystemPods = &skipNodesWithSystemPods
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterPropertiesAutoScalerProfile populates our ManagedClusterPropertiesAutoScalerProfile from the provided source ManagedClusterPropertiesAutoScalerProfile
func (managedClusterPropertiesAutoScalerProfile *ManagedClusterPropertiesAutoScalerProfile) AssignPropertiesFromManagedClusterPropertiesAutoScalerProfile(source *v1alpha1api20210501storage.ManagedClusterPropertiesAutoScalerProfile) error {

	// BalanceSimilarNodeGroups
	if source.BalanceSimilarNodeGroups != nil {
		balanceSimilarNodeGroup := *source.BalanceSimilarNodeGroups
		managedClusterPropertiesAutoScalerProfile.BalanceSimilarNodeGroups = &balanceSimilarNodeGroup
	} else {
		managedClusterPropertiesAutoScalerProfile.BalanceSimilarNodeGroups = nil
	}

	// Expander
	if source.Expander != nil {
		expander := ManagedClusterPropertiesAutoScalerProfileExpander(*source.Expander)
		managedClusterPropertiesAutoScalerProfile.Expander = &expander
	} else {
		managedClusterPropertiesAutoScalerProfile.Expander = nil
	}

	// MaxEmptyBulkDelete
	if source.MaxEmptyBulkDelete != nil {
		maxEmptyBulkDelete := *source.MaxEmptyBulkDelete
		managedClusterPropertiesAutoScalerProfile.MaxEmptyBulkDelete = &maxEmptyBulkDelete
	} else {
		managedClusterPropertiesAutoScalerProfile.MaxEmptyBulkDelete = nil
	}

	// MaxGracefulTerminationSec
	if source.MaxGracefulTerminationSec != nil {
		maxGracefulTerminationSec := *source.MaxGracefulTerminationSec
		managedClusterPropertiesAutoScalerProfile.MaxGracefulTerminationSec = &maxGracefulTerminationSec
	} else {
		managedClusterPropertiesAutoScalerProfile.MaxGracefulTerminationSec = nil
	}

	// MaxNodeProvisionTime
	if source.MaxNodeProvisionTime != nil {
		maxNodeProvisionTime := *source.MaxNodeProvisionTime
		managedClusterPropertiesAutoScalerProfile.MaxNodeProvisionTime = &maxNodeProvisionTime
	} else {
		managedClusterPropertiesAutoScalerProfile.MaxNodeProvisionTime = nil
	}

	// MaxTotalUnreadyPercentage
	if source.MaxTotalUnreadyPercentage != nil {
		maxTotalUnreadyPercentage := *source.MaxTotalUnreadyPercentage
		managedClusterPropertiesAutoScalerProfile.MaxTotalUnreadyPercentage = &maxTotalUnreadyPercentage
	} else {
		managedClusterPropertiesAutoScalerProfile.MaxTotalUnreadyPercentage = nil
	}

	// NewPodScaleUpDelay
	if source.NewPodScaleUpDelay != nil {
		newPodScaleUpDelay := *source.NewPodScaleUpDelay
		managedClusterPropertiesAutoScalerProfile.NewPodScaleUpDelay = &newPodScaleUpDelay
	} else {
		managedClusterPropertiesAutoScalerProfile.NewPodScaleUpDelay = nil
	}

	// OkTotalUnreadyCount
	if source.OkTotalUnreadyCount != nil {
		okTotalUnreadyCount := *source.OkTotalUnreadyCount
		managedClusterPropertiesAutoScalerProfile.OkTotalUnreadyCount = &okTotalUnreadyCount
	} else {
		managedClusterPropertiesAutoScalerProfile.OkTotalUnreadyCount = nil
	}

	// ScaleDownDelayAfterAdd
	if source.ScaleDownDelayAfterAdd != nil {
		scaleDownDelayAfterAdd := *source.ScaleDownDelayAfterAdd
		managedClusterPropertiesAutoScalerProfile.ScaleDownDelayAfterAdd = &scaleDownDelayAfterAdd
	} else {
		managedClusterPropertiesAutoScalerProfile.ScaleDownDelayAfterAdd = nil
	}

	// ScaleDownDelayAfterDelete
	if source.ScaleDownDelayAfterDelete != nil {
		scaleDownDelayAfterDelete := *source.ScaleDownDelayAfterDelete
		managedClusterPropertiesAutoScalerProfile.ScaleDownDelayAfterDelete = &scaleDownDelayAfterDelete
	} else {
		managedClusterPropertiesAutoScalerProfile.ScaleDownDelayAfterDelete = nil
	}

	// ScaleDownDelayAfterFailure
	if source.ScaleDownDelayAfterFailure != nil {
		scaleDownDelayAfterFailure := *source.ScaleDownDelayAfterFailure
		managedClusterPropertiesAutoScalerProfile.ScaleDownDelayAfterFailure = &scaleDownDelayAfterFailure
	} else {
		managedClusterPropertiesAutoScalerProfile.ScaleDownDelayAfterFailure = nil
	}

	// ScaleDownUnneededTime
	if source.ScaleDownUnneededTime != nil {
		scaleDownUnneededTime := *source.ScaleDownUnneededTime
		managedClusterPropertiesAutoScalerProfile.ScaleDownUnneededTime = &scaleDownUnneededTime
	} else {
		managedClusterPropertiesAutoScalerProfile.ScaleDownUnneededTime = nil
	}

	// ScaleDownUnreadyTime
	if source.ScaleDownUnreadyTime != nil {
		scaleDownUnreadyTime := *source.ScaleDownUnreadyTime
		managedClusterPropertiesAutoScalerProfile.ScaleDownUnreadyTime = &scaleDownUnreadyTime
	} else {
		managedClusterPropertiesAutoScalerProfile.ScaleDownUnreadyTime = nil
	}

	// ScaleDownUtilizationThreshold
	if source.ScaleDownUtilizationThreshold != nil {
		scaleDownUtilizationThreshold := *source.ScaleDownUtilizationThreshold
		managedClusterPropertiesAutoScalerProfile.ScaleDownUtilizationThreshold = &scaleDownUtilizationThreshold
	} else {
		managedClusterPropertiesAutoScalerProfile.ScaleDownUtilizationThreshold = nil
	}

	// ScanInterval
	if source.ScanInterval != nil {
		scanInterval := *source.ScanInterval
		managedClusterPropertiesAutoScalerProfile.ScanInterval = &scanInterval
	} else {
		managedClusterPropertiesAutoScalerProfile.ScanInterval = nil
	}

	// SkipNodesWithLocalStorage
	if source.SkipNodesWithLocalStorage != nil {
		skipNodesWithLocalStorage := *source.SkipNodesWithLocalStorage
		managedClusterPropertiesAutoScalerProfile.SkipNodesWithLocalStorage = &skipNodesWithLocalStorage
	} else {
		managedClusterPropertiesAutoScalerProfile.SkipNodesWithLocalStorage = nil
	}

	// SkipNodesWithSystemPods
	if source.SkipNodesWithSystemPods != nil {
		skipNodesWithSystemPod := *source.SkipNodesWithSystemPods
		managedClusterPropertiesAutoScalerProfile.SkipNodesWithSystemPods = &skipNodesWithSystemPod
	} else {
		managedClusterPropertiesAutoScalerProfile.SkipNodesWithSystemPods = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterPropertiesAutoScalerProfile populates the provided destination ManagedClusterPropertiesAutoScalerProfile from our ManagedClusterPropertiesAutoScalerProfile
func (managedClusterPropertiesAutoScalerProfile *ManagedClusterPropertiesAutoScalerProfile) AssignPropertiesToManagedClusterPropertiesAutoScalerProfile(destination *v1alpha1api20210501storage.ManagedClusterPropertiesAutoScalerProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BalanceSimilarNodeGroups
	if managedClusterPropertiesAutoScalerProfile.BalanceSimilarNodeGroups != nil {
		balanceSimilarNodeGroup := *managedClusterPropertiesAutoScalerProfile.BalanceSimilarNodeGroups
		destination.BalanceSimilarNodeGroups = &balanceSimilarNodeGroup
	} else {
		destination.BalanceSimilarNodeGroups = nil
	}

	// Expander
	if managedClusterPropertiesAutoScalerProfile.Expander != nil {
		expander := string(*managedClusterPropertiesAutoScalerProfile.Expander)
		destination.Expander = &expander
	} else {
		destination.Expander = nil
	}

	// MaxEmptyBulkDelete
	if managedClusterPropertiesAutoScalerProfile.MaxEmptyBulkDelete != nil {
		maxEmptyBulkDelete := *managedClusterPropertiesAutoScalerProfile.MaxEmptyBulkDelete
		destination.MaxEmptyBulkDelete = &maxEmptyBulkDelete
	} else {
		destination.MaxEmptyBulkDelete = nil
	}

	// MaxGracefulTerminationSec
	if managedClusterPropertiesAutoScalerProfile.MaxGracefulTerminationSec != nil {
		maxGracefulTerminationSec := *managedClusterPropertiesAutoScalerProfile.MaxGracefulTerminationSec
		destination.MaxGracefulTerminationSec = &maxGracefulTerminationSec
	} else {
		destination.MaxGracefulTerminationSec = nil
	}

	// MaxNodeProvisionTime
	if managedClusterPropertiesAutoScalerProfile.MaxNodeProvisionTime != nil {
		maxNodeProvisionTime := *managedClusterPropertiesAutoScalerProfile.MaxNodeProvisionTime
		destination.MaxNodeProvisionTime = &maxNodeProvisionTime
	} else {
		destination.MaxNodeProvisionTime = nil
	}

	// MaxTotalUnreadyPercentage
	if managedClusterPropertiesAutoScalerProfile.MaxTotalUnreadyPercentage != nil {
		maxTotalUnreadyPercentage := *managedClusterPropertiesAutoScalerProfile.MaxTotalUnreadyPercentage
		destination.MaxTotalUnreadyPercentage = &maxTotalUnreadyPercentage
	} else {
		destination.MaxTotalUnreadyPercentage = nil
	}

	// NewPodScaleUpDelay
	if managedClusterPropertiesAutoScalerProfile.NewPodScaleUpDelay != nil {
		newPodScaleUpDelay := *managedClusterPropertiesAutoScalerProfile.NewPodScaleUpDelay
		destination.NewPodScaleUpDelay = &newPodScaleUpDelay
	} else {
		destination.NewPodScaleUpDelay = nil
	}

	// OkTotalUnreadyCount
	if managedClusterPropertiesAutoScalerProfile.OkTotalUnreadyCount != nil {
		okTotalUnreadyCount := *managedClusterPropertiesAutoScalerProfile.OkTotalUnreadyCount
		destination.OkTotalUnreadyCount = &okTotalUnreadyCount
	} else {
		destination.OkTotalUnreadyCount = nil
	}

	// ScaleDownDelayAfterAdd
	if managedClusterPropertiesAutoScalerProfile.ScaleDownDelayAfterAdd != nil {
		scaleDownDelayAfterAdd := *managedClusterPropertiesAutoScalerProfile.ScaleDownDelayAfterAdd
		destination.ScaleDownDelayAfterAdd = &scaleDownDelayAfterAdd
	} else {
		destination.ScaleDownDelayAfterAdd = nil
	}

	// ScaleDownDelayAfterDelete
	if managedClusterPropertiesAutoScalerProfile.ScaleDownDelayAfterDelete != nil {
		scaleDownDelayAfterDelete := *managedClusterPropertiesAutoScalerProfile.ScaleDownDelayAfterDelete
		destination.ScaleDownDelayAfterDelete = &scaleDownDelayAfterDelete
	} else {
		destination.ScaleDownDelayAfterDelete = nil
	}

	// ScaleDownDelayAfterFailure
	if managedClusterPropertiesAutoScalerProfile.ScaleDownDelayAfterFailure != nil {
		scaleDownDelayAfterFailure := *managedClusterPropertiesAutoScalerProfile.ScaleDownDelayAfterFailure
		destination.ScaleDownDelayAfterFailure = &scaleDownDelayAfterFailure
	} else {
		destination.ScaleDownDelayAfterFailure = nil
	}

	// ScaleDownUnneededTime
	if managedClusterPropertiesAutoScalerProfile.ScaleDownUnneededTime != nil {
		scaleDownUnneededTime := *managedClusterPropertiesAutoScalerProfile.ScaleDownUnneededTime
		destination.ScaleDownUnneededTime = &scaleDownUnneededTime
	} else {
		destination.ScaleDownUnneededTime = nil
	}

	// ScaleDownUnreadyTime
	if managedClusterPropertiesAutoScalerProfile.ScaleDownUnreadyTime != nil {
		scaleDownUnreadyTime := *managedClusterPropertiesAutoScalerProfile.ScaleDownUnreadyTime
		destination.ScaleDownUnreadyTime = &scaleDownUnreadyTime
	} else {
		destination.ScaleDownUnreadyTime = nil
	}

	// ScaleDownUtilizationThreshold
	if managedClusterPropertiesAutoScalerProfile.ScaleDownUtilizationThreshold != nil {
		scaleDownUtilizationThreshold := *managedClusterPropertiesAutoScalerProfile.ScaleDownUtilizationThreshold
		destination.ScaleDownUtilizationThreshold = &scaleDownUtilizationThreshold
	} else {
		destination.ScaleDownUtilizationThreshold = nil
	}

	// ScanInterval
	if managedClusterPropertiesAutoScalerProfile.ScanInterval != nil {
		scanInterval := *managedClusterPropertiesAutoScalerProfile.ScanInterval
		destination.ScanInterval = &scanInterval
	} else {
		destination.ScanInterval = nil
	}

	// SkipNodesWithLocalStorage
	if managedClusterPropertiesAutoScalerProfile.SkipNodesWithLocalStorage != nil {
		skipNodesWithLocalStorage := *managedClusterPropertiesAutoScalerProfile.SkipNodesWithLocalStorage
		destination.SkipNodesWithLocalStorage = &skipNodesWithLocalStorage
	} else {
		destination.SkipNodesWithLocalStorage = nil
	}

	// SkipNodesWithSystemPods
	if managedClusterPropertiesAutoScalerProfile.SkipNodesWithSystemPods != nil {
		skipNodesWithSystemPod := *managedClusterPropertiesAutoScalerProfile.SkipNodesWithSystemPods
		destination.SkipNodesWithSystemPods = &skipNodesWithSystemPod
	} else {
		destination.SkipNodesWithSystemPods = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

type ManagedClusterProperties_Status_AutoScalerProfile struct {
	BalanceSimilarNodeGroups      *string                                                  `json:"balance-similar-node-groups,omitempty"`
	Expander                      *ManagedClusterPropertiesStatusAutoScalerProfileExpander `json:"expander,omitempty"`
	MaxEmptyBulkDelete            *string                                                  `json:"max-empty-bulk-delete,omitempty"`
	MaxGracefulTerminationSec     *string                                                  `json:"max-graceful-termination-sec,omitempty"`
	MaxNodeProvisionTime          *string                                                  `json:"max-node-provision-time,omitempty"`
	MaxTotalUnreadyPercentage     *string                                                  `json:"max-total-unready-percentage,omitempty"`
	NewPodScaleUpDelay            *string                                                  `json:"new-pod-scale-up-delay,omitempty"`
	OkTotalUnreadyCount           *string                                                  `json:"ok-total-unready-count,omitempty"`
	ScaleDownDelayAfterAdd        *string                                                  `json:"scale-down-delay-after-add,omitempty"`
	ScaleDownDelayAfterDelete     *string                                                  `json:"scale-down-delay-after-delete,omitempty"`
	ScaleDownDelayAfterFailure    *string                                                  `json:"scale-down-delay-after-failure,omitempty"`
	ScaleDownUnneededTime         *string                                                  `json:"scale-down-unneeded-time,omitempty"`
	ScaleDownUnreadyTime          *string                                                  `json:"scale-down-unready-time,omitempty"`
	ScaleDownUtilizationThreshold *string                                                  `json:"scale-down-utilization-threshold,omitempty"`
	ScanInterval                  *string                                                  `json:"scan-interval,omitempty"`
	SkipNodesWithLocalStorage     *string                                                  `json:"skip-nodes-with-local-storage,omitempty"`
	SkipNodesWithSystemPods       *string                                                  `json:"skip-nodes-with-system-pods,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterProperties_Status_AutoScalerProfile{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (managedClusterPropertiesStatusAutoScalerProfile *ManagedClusterProperties_Status_AutoScalerProfile) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterProperties_Status_AutoScalerProfileARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (managedClusterPropertiesStatusAutoScalerProfile *ManagedClusterProperties_Status_AutoScalerProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterProperties_Status_AutoScalerProfileARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterProperties_Status_AutoScalerProfileARM, got %T", armInput)
	}

	// Set property ‘BalanceSimilarNodeGroups’:
	if typedInput.BalanceSimilarNodeGroups != nil {
		balanceSimilarNodeGroups := *typedInput.BalanceSimilarNodeGroups
		managedClusterPropertiesStatusAutoScalerProfile.BalanceSimilarNodeGroups = &balanceSimilarNodeGroups
	}

	// Set property ‘Expander’:
	if typedInput.Expander != nil {
		expander := *typedInput.Expander
		managedClusterPropertiesStatusAutoScalerProfile.Expander = &expander
	}

	// Set property ‘MaxEmptyBulkDelete’:
	if typedInput.MaxEmptyBulkDelete != nil {
		maxEmptyBulkDelete := *typedInput.MaxEmptyBulkDelete
		managedClusterPropertiesStatusAutoScalerProfile.MaxEmptyBulkDelete = &maxEmptyBulkDelete
	}

	// Set property ‘MaxGracefulTerminationSec’:
	if typedInput.MaxGracefulTerminationSec != nil {
		maxGracefulTerminationSec := *typedInput.MaxGracefulTerminationSec
		managedClusterPropertiesStatusAutoScalerProfile.MaxGracefulTerminationSec = &maxGracefulTerminationSec
	}

	// Set property ‘MaxNodeProvisionTime’:
	if typedInput.MaxNodeProvisionTime != nil {
		maxNodeProvisionTime := *typedInput.MaxNodeProvisionTime
		managedClusterPropertiesStatusAutoScalerProfile.MaxNodeProvisionTime = &maxNodeProvisionTime
	}

	// Set property ‘MaxTotalUnreadyPercentage’:
	if typedInput.MaxTotalUnreadyPercentage != nil {
		maxTotalUnreadyPercentage := *typedInput.MaxTotalUnreadyPercentage
		managedClusterPropertiesStatusAutoScalerProfile.MaxTotalUnreadyPercentage = &maxTotalUnreadyPercentage
	}

	// Set property ‘NewPodScaleUpDelay’:
	if typedInput.NewPodScaleUpDelay != nil {
		newPodScaleUpDelay := *typedInput.NewPodScaleUpDelay
		managedClusterPropertiesStatusAutoScalerProfile.NewPodScaleUpDelay = &newPodScaleUpDelay
	}

	// Set property ‘OkTotalUnreadyCount’:
	if typedInput.OkTotalUnreadyCount != nil {
		okTotalUnreadyCount := *typedInput.OkTotalUnreadyCount
		managedClusterPropertiesStatusAutoScalerProfile.OkTotalUnreadyCount = &okTotalUnreadyCount
	}

	// Set property ‘ScaleDownDelayAfterAdd’:
	if typedInput.ScaleDownDelayAfterAdd != nil {
		scaleDownDelayAfterAdd := *typedInput.ScaleDownDelayAfterAdd
		managedClusterPropertiesStatusAutoScalerProfile.ScaleDownDelayAfterAdd = &scaleDownDelayAfterAdd
	}

	// Set property ‘ScaleDownDelayAfterDelete’:
	if typedInput.ScaleDownDelayAfterDelete != nil {
		scaleDownDelayAfterDelete := *typedInput.ScaleDownDelayAfterDelete
		managedClusterPropertiesStatusAutoScalerProfile.ScaleDownDelayAfterDelete = &scaleDownDelayAfterDelete
	}

	// Set property ‘ScaleDownDelayAfterFailure’:
	if typedInput.ScaleDownDelayAfterFailure != nil {
		scaleDownDelayAfterFailure := *typedInput.ScaleDownDelayAfterFailure
		managedClusterPropertiesStatusAutoScalerProfile.ScaleDownDelayAfterFailure = &scaleDownDelayAfterFailure
	}

	// Set property ‘ScaleDownUnneededTime’:
	if typedInput.ScaleDownUnneededTime != nil {
		scaleDownUnneededTime := *typedInput.ScaleDownUnneededTime
		managedClusterPropertiesStatusAutoScalerProfile.ScaleDownUnneededTime = &scaleDownUnneededTime
	}

	// Set property ‘ScaleDownUnreadyTime’:
	if typedInput.ScaleDownUnreadyTime != nil {
		scaleDownUnreadyTime := *typedInput.ScaleDownUnreadyTime
		managedClusterPropertiesStatusAutoScalerProfile.ScaleDownUnreadyTime = &scaleDownUnreadyTime
	}

	// Set property ‘ScaleDownUtilizationThreshold’:
	if typedInput.ScaleDownUtilizationThreshold != nil {
		scaleDownUtilizationThreshold := *typedInput.ScaleDownUtilizationThreshold
		managedClusterPropertiesStatusAutoScalerProfile.ScaleDownUtilizationThreshold = &scaleDownUtilizationThreshold
	}

	// Set property ‘ScanInterval’:
	if typedInput.ScanInterval != nil {
		scanInterval := *typedInput.ScanInterval
		managedClusterPropertiesStatusAutoScalerProfile.ScanInterval = &scanInterval
	}

	// Set property ‘SkipNodesWithLocalStorage’:
	if typedInput.SkipNodesWithLocalStorage != nil {
		skipNodesWithLocalStorage := *typedInput.SkipNodesWithLocalStorage
		managedClusterPropertiesStatusAutoScalerProfile.SkipNodesWithLocalStorage = &skipNodesWithLocalStorage
	}

	// Set property ‘SkipNodesWithSystemPods’:
	if typedInput.SkipNodesWithSystemPods != nil {
		skipNodesWithSystemPods := *typedInput.SkipNodesWithSystemPods
		managedClusterPropertiesStatusAutoScalerProfile.SkipNodesWithSystemPods = &skipNodesWithSystemPods
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterPropertiesStatusAutoScalerProfile populates our ManagedClusterProperties_Status_AutoScalerProfile from the provided source ManagedClusterProperties_Status_AutoScalerProfile
func (managedClusterPropertiesStatusAutoScalerProfile *ManagedClusterProperties_Status_AutoScalerProfile) AssignPropertiesFromManagedClusterPropertiesStatusAutoScalerProfile(source *v1alpha1api20210501storage.ManagedClusterProperties_Status_AutoScalerProfile) error {

	// BalanceSimilarNodeGroups
	if source.BalanceSimilarNodeGroups != nil {
		balanceSimilarNodeGroup := *source.BalanceSimilarNodeGroups
		managedClusterPropertiesStatusAutoScalerProfile.BalanceSimilarNodeGroups = &balanceSimilarNodeGroup
	} else {
		managedClusterPropertiesStatusAutoScalerProfile.BalanceSimilarNodeGroups = nil
	}

	// Expander
	if source.Expander != nil {
		expander := ManagedClusterPropertiesStatusAutoScalerProfileExpander(*source.Expander)
		managedClusterPropertiesStatusAutoScalerProfile.Expander = &expander
	} else {
		managedClusterPropertiesStatusAutoScalerProfile.Expander = nil
	}

	// MaxEmptyBulkDelete
	if source.MaxEmptyBulkDelete != nil {
		maxEmptyBulkDelete := *source.MaxEmptyBulkDelete
		managedClusterPropertiesStatusAutoScalerProfile.MaxEmptyBulkDelete = &maxEmptyBulkDelete
	} else {
		managedClusterPropertiesStatusAutoScalerProfile.MaxEmptyBulkDelete = nil
	}

	// MaxGracefulTerminationSec
	if source.MaxGracefulTerminationSec != nil {
		maxGracefulTerminationSec := *source.MaxGracefulTerminationSec
		managedClusterPropertiesStatusAutoScalerProfile.MaxGracefulTerminationSec = &maxGracefulTerminationSec
	} else {
		managedClusterPropertiesStatusAutoScalerProfile.MaxGracefulTerminationSec = nil
	}

	// MaxNodeProvisionTime
	if source.MaxNodeProvisionTime != nil {
		maxNodeProvisionTime := *source.MaxNodeProvisionTime
		managedClusterPropertiesStatusAutoScalerProfile.MaxNodeProvisionTime = &maxNodeProvisionTime
	} else {
		managedClusterPropertiesStatusAutoScalerProfile.MaxNodeProvisionTime = nil
	}

	// MaxTotalUnreadyPercentage
	if source.MaxTotalUnreadyPercentage != nil {
		maxTotalUnreadyPercentage := *source.MaxTotalUnreadyPercentage
		managedClusterPropertiesStatusAutoScalerProfile.MaxTotalUnreadyPercentage = &maxTotalUnreadyPercentage
	} else {
		managedClusterPropertiesStatusAutoScalerProfile.MaxTotalUnreadyPercentage = nil
	}

	// NewPodScaleUpDelay
	if source.NewPodScaleUpDelay != nil {
		newPodScaleUpDelay := *source.NewPodScaleUpDelay
		managedClusterPropertiesStatusAutoScalerProfile.NewPodScaleUpDelay = &newPodScaleUpDelay
	} else {
		managedClusterPropertiesStatusAutoScalerProfile.NewPodScaleUpDelay = nil
	}

	// OkTotalUnreadyCount
	if source.OkTotalUnreadyCount != nil {
		okTotalUnreadyCount := *source.OkTotalUnreadyCount
		managedClusterPropertiesStatusAutoScalerProfile.OkTotalUnreadyCount = &okTotalUnreadyCount
	} else {
		managedClusterPropertiesStatusAutoScalerProfile.OkTotalUnreadyCount = nil
	}

	// ScaleDownDelayAfterAdd
	if source.ScaleDownDelayAfterAdd != nil {
		scaleDownDelayAfterAdd := *source.ScaleDownDelayAfterAdd
		managedClusterPropertiesStatusAutoScalerProfile.ScaleDownDelayAfterAdd = &scaleDownDelayAfterAdd
	} else {
		managedClusterPropertiesStatusAutoScalerProfile.ScaleDownDelayAfterAdd = nil
	}

	// ScaleDownDelayAfterDelete
	if source.ScaleDownDelayAfterDelete != nil {
		scaleDownDelayAfterDelete := *source.ScaleDownDelayAfterDelete
		managedClusterPropertiesStatusAutoScalerProfile.ScaleDownDelayAfterDelete = &scaleDownDelayAfterDelete
	} else {
		managedClusterPropertiesStatusAutoScalerProfile.ScaleDownDelayAfterDelete = nil
	}

	// ScaleDownDelayAfterFailure
	if source.ScaleDownDelayAfterFailure != nil {
		scaleDownDelayAfterFailure := *source.ScaleDownDelayAfterFailure
		managedClusterPropertiesStatusAutoScalerProfile.ScaleDownDelayAfterFailure = &scaleDownDelayAfterFailure
	} else {
		managedClusterPropertiesStatusAutoScalerProfile.ScaleDownDelayAfterFailure = nil
	}

	// ScaleDownUnneededTime
	if source.ScaleDownUnneededTime != nil {
		scaleDownUnneededTime := *source.ScaleDownUnneededTime
		managedClusterPropertiesStatusAutoScalerProfile.ScaleDownUnneededTime = &scaleDownUnneededTime
	} else {
		managedClusterPropertiesStatusAutoScalerProfile.ScaleDownUnneededTime = nil
	}

	// ScaleDownUnreadyTime
	if source.ScaleDownUnreadyTime != nil {
		scaleDownUnreadyTime := *source.ScaleDownUnreadyTime
		managedClusterPropertiesStatusAutoScalerProfile.ScaleDownUnreadyTime = &scaleDownUnreadyTime
	} else {
		managedClusterPropertiesStatusAutoScalerProfile.ScaleDownUnreadyTime = nil
	}

	// ScaleDownUtilizationThreshold
	if source.ScaleDownUtilizationThreshold != nil {
		scaleDownUtilizationThreshold := *source.ScaleDownUtilizationThreshold
		managedClusterPropertiesStatusAutoScalerProfile.ScaleDownUtilizationThreshold = &scaleDownUtilizationThreshold
	} else {
		managedClusterPropertiesStatusAutoScalerProfile.ScaleDownUtilizationThreshold = nil
	}

	// ScanInterval
	if source.ScanInterval != nil {
		scanInterval := *source.ScanInterval
		managedClusterPropertiesStatusAutoScalerProfile.ScanInterval = &scanInterval
	} else {
		managedClusterPropertiesStatusAutoScalerProfile.ScanInterval = nil
	}

	// SkipNodesWithLocalStorage
	if source.SkipNodesWithLocalStorage != nil {
		skipNodesWithLocalStorage := *source.SkipNodesWithLocalStorage
		managedClusterPropertiesStatusAutoScalerProfile.SkipNodesWithLocalStorage = &skipNodesWithLocalStorage
	} else {
		managedClusterPropertiesStatusAutoScalerProfile.SkipNodesWithLocalStorage = nil
	}

	// SkipNodesWithSystemPods
	if source.SkipNodesWithSystemPods != nil {
		skipNodesWithSystemPod := *source.SkipNodesWithSystemPods
		managedClusterPropertiesStatusAutoScalerProfile.SkipNodesWithSystemPods = &skipNodesWithSystemPod
	} else {
		managedClusterPropertiesStatusAutoScalerProfile.SkipNodesWithSystemPods = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterPropertiesStatusAutoScalerProfile populates the provided destination ManagedClusterProperties_Status_AutoScalerProfile from our ManagedClusterProperties_Status_AutoScalerProfile
func (managedClusterPropertiesStatusAutoScalerProfile *ManagedClusterProperties_Status_AutoScalerProfile) AssignPropertiesToManagedClusterPropertiesStatusAutoScalerProfile(destination *v1alpha1api20210501storage.ManagedClusterProperties_Status_AutoScalerProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BalanceSimilarNodeGroups
	if managedClusterPropertiesStatusAutoScalerProfile.BalanceSimilarNodeGroups != nil {
		balanceSimilarNodeGroup := *managedClusterPropertiesStatusAutoScalerProfile.BalanceSimilarNodeGroups
		destination.BalanceSimilarNodeGroups = &balanceSimilarNodeGroup
	} else {
		destination.BalanceSimilarNodeGroups = nil
	}

	// Expander
	if managedClusterPropertiesStatusAutoScalerProfile.Expander != nil {
		expander := string(*managedClusterPropertiesStatusAutoScalerProfile.Expander)
		destination.Expander = &expander
	} else {
		destination.Expander = nil
	}

	// MaxEmptyBulkDelete
	if managedClusterPropertiesStatusAutoScalerProfile.MaxEmptyBulkDelete != nil {
		maxEmptyBulkDelete := *managedClusterPropertiesStatusAutoScalerProfile.MaxEmptyBulkDelete
		destination.MaxEmptyBulkDelete = &maxEmptyBulkDelete
	} else {
		destination.MaxEmptyBulkDelete = nil
	}

	// MaxGracefulTerminationSec
	if managedClusterPropertiesStatusAutoScalerProfile.MaxGracefulTerminationSec != nil {
		maxGracefulTerminationSec := *managedClusterPropertiesStatusAutoScalerProfile.MaxGracefulTerminationSec
		destination.MaxGracefulTerminationSec = &maxGracefulTerminationSec
	} else {
		destination.MaxGracefulTerminationSec = nil
	}

	// MaxNodeProvisionTime
	if managedClusterPropertiesStatusAutoScalerProfile.MaxNodeProvisionTime != nil {
		maxNodeProvisionTime := *managedClusterPropertiesStatusAutoScalerProfile.MaxNodeProvisionTime
		destination.MaxNodeProvisionTime = &maxNodeProvisionTime
	} else {
		destination.MaxNodeProvisionTime = nil
	}

	// MaxTotalUnreadyPercentage
	if managedClusterPropertiesStatusAutoScalerProfile.MaxTotalUnreadyPercentage != nil {
		maxTotalUnreadyPercentage := *managedClusterPropertiesStatusAutoScalerProfile.MaxTotalUnreadyPercentage
		destination.MaxTotalUnreadyPercentage = &maxTotalUnreadyPercentage
	} else {
		destination.MaxTotalUnreadyPercentage = nil
	}

	// NewPodScaleUpDelay
	if managedClusterPropertiesStatusAutoScalerProfile.NewPodScaleUpDelay != nil {
		newPodScaleUpDelay := *managedClusterPropertiesStatusAutoScalerProfile.NewPodScaleUpDelay
		destination.NewPodScaleUpDelay = &newPodScaleUpDelay
	} else {
		destination.NewPodScaleUpDelay = nil
	}

	// OkTotalUnreadyCount
	if managedClusterPropertiesStatusAutoScalerProfile.OkTotalUnreadyCount != nil {
		okTotalUnreadyCount := *managedClusterPropertiesStatusAutoScalerProfile.OkTotalUnreadyCount
		destination.OkTotalUnreadyCount = &okTotalUnreadyCount
	} else {
		destination.OkTotalUnreadyCount = nil
	}

	// ScaleDownDelayAfterAdd
	if managedClusterPropertiesStatusAutoScalerProfile.ScaleDownDelayAfterAdd != nil {
		scaleDownDelayAfterAdd := *managedClusterPropertiesStatusAutoScalerProfile.ScaleDownDelayAfterAdd
		destination.ScaleDownDelayAfterAdd = &scaleDownDelayAfterAdd
	} else {
		destination.ScaleDownDelayAfterAdd = nil
	}

	// ScaleDownDelayAfterDelete
	if managedClusterPropertiesStatusAutoScalerProfile.ScaleDownDelayAfterDelete != nil {
		scaleDownDelayAfterDelete := *managedClusterPropertiesStatusAutoScalerProfile.ScaleDownDelayAfterDelete
		destination.ScaleDownDelayAfterDelete = &scaleDownDelayAfterDelete
	} else {
		destination.ScaleDownDelayAfterDelete = nil
	}

	// ScaleDownDelayAfterFailure
	if managedClusterPropertiesStatusAutoScalerProfile.ScaleDownDelayAfterFailure != nil {
		scaleDownDelayAfterFailure := *managedClusterPropertiesStatusAutoScalerProfile.ScaleDownDelayAfterFailure
		destination.ScaleDownDelayAfterFailure = &scaleDownDelayAfterFailure
	} else {
		destination.ScaleDownDelayAfterFailure = nil
	}

	// ScaleDownUnneededTime
	if managedClusterPropertiesStatusAutoScalerProfile.ScaleDownUnneededTime != nil {
		scaleDownUnneededTime := *managedClusterPropertiesStatusAutoScalerProfile.ScaleDownUnneededTime
		destination.ScaleDownUnneededTime = &scaleDownUnneededTime
	} else {
		destination.ScaleDownUnneededTime = nil
	}

	// ScaleDownUnreadyTime
	if managedClusterPropertiesStatusAutoScalerProfile.ScaleDownUnreadyTime != nil {
		scaleDownUnreadyTime := *managedClusterPropertiesStatusAutoScalerProfile.ScaleDownUnreadyTime
		destination.ScaleDownUnreadyTime = &scaleDownUnreadyTime
	} else {
		destination.ScaleDownUnreadyTime = nil
	}

	// ScaleDownUtilizationThreshold
	if managedClusterPropertiesStatusAutoScalerProfile.ScaleDownUtilizationThreshold != nil {
		scaleDownUtilizationThreshold := *managedClusterPropertiesStatusAutoScalerProfile.ScaleDownUtilizationThreshold
		destination.ScaleDownUtilizationThreshold = &scaleDownUtilizationThreshold
	} else {
		destination.ScaleDownUtilizationThreshold = nil
	}

	// ScanInterval
	if managedClusterPropertiesStatusAutoScalerProfile.ScanInterval != nil {
		scanInterval := *managedClusterPropertiesStatusAutoScalerProfile.ScanInterval
		destination.ScanInterval = &scanInterval
	} else {
		destination.ScanInterval = nil
	}

	// SkipNodesWithLocalStorage
	if managedClusterPropertiesStatusAutoScalerProfile.SkipNodesWithLocalStorage != nil {
		skipNodesWithLocalStorage := *managedClusterPropertiesStatusAutoScalerProfile.SkipNodesWithLocalStorage
		destination.SkipNodesWithLocalStorage = &skipNodesWithLocalStorage
	} else {
		destination.SkipNodesWithLocalStorage = nil
	}

	// SkipNodesWithSystemPods
	if managedClusterPropertiesStatusAutoScalerProfile.SkipNodesWithSystemPods != nil {
		skipNodesWithSystemPod := *managedClusterPropertiesStatusAutoScalerProfile.SkipNodesWithSystemPods
		destination.SkipNodesWithSystemPods = &skipNodesWithSystemPod
	} else {
		destination.SkipNodesWithSystemPods = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2021-05-01/Microsoft.ContainerService.json#/definitions/ManagedClusterSKU
type ManagedClusterSKU struct {
	//Name: The name of a managed cluster SKU.
	Name *ManagedClusterSKUName `json:"name,omitempty"`

	//Tier: If not specified, the default is 'Free'. See [uptime
	//SLA](https://docs.microsoft.com/azure/aks/uptime-sla) for more details.
	Tier *ManagedClusterSKUTier `json:"tier,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterSKU{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (managedClusterSKU *ManagedClusterSKU) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if managedClusterSKU == nil {
		return nil, nil
	}
	var result ManagedClusterSKUARM

	// Set property ‘Name’:
	if managedClusterSKU.Name != nil {
		name := *managedClusterSKU.Name
		result.Name = &name
	}

	// Set property ‘Tier’:
	if managedClusterSKU.Tier != nil {
		tier := *managedClusterSKU.Tier
		result.Tier = &tier
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (managedClusterSKU *ManagedClusterSKU) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterSKUARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (managedClusterSKU *ManagedClusterSKU) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterSKUARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterSKUARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		managedClusterSKU.Name = &name
	}

	// Set property ‘Tier’:
	if typedInput.Tier != nil {
		tier := *typedInput.Tier
		managedClusterSKU.Tier = &tier
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterSKU populates our ManagedClusterSKU from the provided source ManagedClusterSKU
func (managedClusterSKU *ManagedClusterSKU) AssignPropertiesFromManagedClusterSKU(source *v1alpha1api20210501storage.ManagedClusterSKU) error {

	// Name
	if source.Name != nil {
		name := ManagedClusterSKUName(*source.Name)
		managedClusterSKU.Name = &name
	} else {
		managedClusterSKU.Name = nil
	}

	// Tier
	if source.Tier != nil {
		tier := ManagedClusterSKUTier(*source.Tier)
		managedClusterSKU.Tier = &tier
	} else {
		managedClusterSKU.Tier = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterSKU populates the provided destination ManagedClusterSKU from our ManagedClusterSKU
func (managedClusterSKU *ManagedClusterSKU) AssignPropertiesToManagedClusterSKU(destination *v1alpha1api20210501storage.ManagedClusterSKU) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if managedClusterSKU.Name != nil {
		name := string(*managedClusterSKU.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Tier
	if managedClusterSKU.Tier != nil {
		tier := string(*managedClusterSKU.Tier)
		destination.Tier = &tier
	} else {
		destination.Tier = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type ManagedClusterSKU_Status struct {
	//Name: Name of a managed cluster SKU.
	Name *ManagedClusterSKUStatusName `json:"name,omitempty"`

	//Tier: Tier of a managed cluster SKU.
	Tier *ManagedClusterSKUStatusTier `json:"tier,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterSKU_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (managedClusterSKUStatus *ManagedClusterSKU_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterSKU_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (managedClusterSKUStatus *ManagedClusterSKU_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterSKU_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterSKU_StatusARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		managedClusterSKUStatus.Name = &name
	}

	// Set property ‘Tier’:
	if typedInput.Tier != nil {
		tier := *typedInput.Tier
		managedClusterSKUStatus.Tier = &tier
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterSKUStatus populates our ManagedClusterSKU_Status from the provided source ManagedClusterSKU_Status
func (managedClusterSKUStatus *ManagedClusterSKU_Status) AssignPropertiesFromManagedClusterSKUStatus(source *v1alpha1api20210501storage.ManagedClusterSKU_Status) error {

	// Name
	if source.Name != nil {
		name := ManagedClusterSKUStatusName(*source.Name)
		managedClusterSKUStatus.Name = &name
	} else {
		managedClusterSKUStatus.Name = nil
	}

	// Tier
	if source.Tier != nil {
		tier := ManagedClusterSKUStatusTier(*source.Tier)
		managedClusterSKUStatus.Tier = &tier
	} else {
		managedClusterSKUStatus.Tier = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterSKUStatus populates the provided destination ManagedClusterSKU_Status from our ManagedClusterSKU_Status
func (managedClusterSKUStatus *ManagedClusterSKU_Status) AssignPropertiesToManagedClusterSKUStatus(destination *v1alpha1api20210501storage.ManagedClusterSKU_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if managedClusterSKUStatus.Name != nil {
		name := string(*managedClusterSKUStatus.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Tier
	if managedClusterSKUStatus.Tier != nil {
		tier := string(*managedClusterSKUStatus.Tier)
		destination.Tier = &tier
	} else {
		destination.Tier = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2021-05-01/Microsoft.ContainerService.json#/definitions/ManagedClusterServicePrincipalProfile
type ManagedClusterServicePrincipalProfile struct {
	// +kubebuilder:validation:Required
	//ClientId: The ID for the service principal.
	ClientId string `json:"clientId"`

	//Secret: The secret password associated with the service principal in plain text.
	Secret *string `json:"secret,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterServicePrincipalProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (managedClusterServicePrincipalProfile *ManagedClusterServicePrincipalProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if managedClusterServicePrincipalProfile == nil {
		return nil, nil
	}
	var result ManagedClusterServicePrincipalProfileARM

	// Set property ‘ClientId’:
	result.ClientId = managedClusterServicePrincipalProfile.ClientId

	// Set property ‘Secret’:
	if managedClusterServicePrincipalProfile.Secret != nil {
		secret := *managedClusterServicePrincipalProfile.Secret
		result.Secret = &secret
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (managedClusterServicePrincipalProfile *ManagedClusterServicePrincipalProfile) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterServicePrincipalProfileARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (managedClusterServicePrincipalProfile *ManagedClusterServicePrincipalProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterServicePrincipalProfileARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterServicePrincipalProfileARM, got %T", armInput)
	}

	// Set property ‘ClientId’:
	managedClusterServicePrincipalProfile.ClientId = typedInput.ClientId

	// Set property ‘Secret’:
	if typedInput.Secret != nil {
		secret := *typedInput.Secret
		managedClusterServicePrincipalProfile.Secret = &secret
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterServicePrincipalProfile populates our ManagedClusterServicePrincipalProfile from the provided source ManagedClusterServicePrincipalProfile
func (managedClusterServicePrincipalProfile *ManagedClusterServicePrincipalProfile) AssignPropertiesFromManagedClusterServicePrincipalProfile(source *v1alpha1api20210501storage.ManagedClusterServicePrincipalProfile) error {

	// ClientId
	if source.ClientId != nil {
		managedClusterServicePrincipalProfile.ClientId = *source.ClientId
	} else {
		managedClusterServicePrincipalProfile.ClientId = ""
	}

	// Secret
	if source.Secret != nil {
		secret := *source.Secret
		managedClusterServicePrincipalProfile.Secret = &secret
	} else {
		managedClusterServicePrincipalProfile.Secret = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterServicePrincipalProfile populates the provided destination ManagedClusterServicePrincipalProfile from our ManagedClusterServicePrincipalProfile
func (managedClusterServicePrincipalProfile *ManagedClusterServicePrincipalProfile) AssignPropertiesToManagedClusterServicePrincipalProfile(destination *v1alpha1api20210501storage.ManagedClusterServicePrincipalProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	clientId := managedClusterServicePrincipalProfile.ClientId
	destination.ClientId = &clientId

	// Secret
	if managedClusterServicePrincipalProfile.Secret != nil {
		secret := *managedClusterServicePrincipalProfile.Secret
		destination.Secret = &secret
	} else {
		destination.Secret = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type ManagedClusterServicePrincipalProfile_Status struct {
	// +kubebuilder:validation:Required
	//ClientId: The ID for the service principal.
	ClientId string `json:"clientId"`

	//Secret: The secret password associated with the service principal in plain text.
	Secret *string `json:"secret,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterServicePrincipalProfile_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (managedClusterServicePrincipalProfileStatus *ManagedClusterServicePrincipalProfile_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterServicePrincipalProfile_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (managedClusterServicePrincipalProfileStatus *ManagedClusterServicePrincipalProfile_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterServicePrincipalProfile_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterServicePrincipalProfile_StatusARM, got %T", armInput)
	}

	// Set property ‘ClientId’:
	managedClusterServicePrincipalProfileStatus.ClientId = typedInput.ClientId

	// Set property ‘Secret’:
	if typedInput.Secret != nil {
		secret := *typedInput.Secret
		managedClusterServicePrincipalProfileStatus.Secret = &secret
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterServicePrincipalProfileStatus populates our ManagedClusterServicePrincipalProfile_Status from the provided source ManagedClusterServicePrincipalProfile_Status
func (managedClusterServicePrincipalProfileStatus *ManagedClusterServicePrincipalProfile_Status) AssignPropertiesFromManagedClusterServicePrincipalProfileStatus(source *v1alpha1api20210501storage.ManagedClusterServicePrincipalProfile_Status) error {

	// ClientId
	if source.ClientId != nil {
		managedClusterServicePrincipalProfileStatus.ClientId = *source.ClientId
	} else {
		managedClusterServicePrincipalProfileStatus.ClientId = ""
	}

	// Secret
	if source.Secret != nil {
		secret := *source.Secret
		managedClusterServicePrincipalProfileStatus.Secret = &secret
	} else {
		managedClusterServicePrincipalProfileStatus.Secret = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterServicePrincipalProfileStatus populates the provided destination ManagedClusterServicePrincipalProfile_Status from our ManagedClusterServicePrincipalProfile_Status
func (managedClusterServicePrincipalProfileStatus *ManagedClusterServicePrincipalProfile_Status) AssignPropertiesToManagedClusterServicePrincipalProfileStatus(destination *v1alpha1api20210501storage.ManagedClusterServicePrincipalProfile_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	clientId := managedClusterServicePrincipalProfileStatus.ClientId
	destination.ClientId = &clientId

	// Secret
	if managedClusterServicePrincipalProfileStatus.Secret != nil {
		secret := *managedClusterServicePrincipalProfileStatus.Secret
		destination.Secret = &secret
	} else {
		destination.Secret = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2021-05-01/Microsoft.ContainerService.json#/definitions/ManagedClusterWindowsProfile
type ManagedClusterWindowsProfile struct {
	//AdminPassword: Specifies the password of the administrator account.
	//Minimum-length: 8 characters
	//Max-length: 123 characters
	//Complexity requirements: 3 out of 4 conditions below need to be fulfilled
	//Has lower characters
	//Has upper characters
	//Has a digit
	//Has a special character (Regex match [\W_])
	//Disallowed values: "abc@123", "P@$$w0rd", "P@ssw0rd", "P@ssword123", "Pa$$word",
	//"pass@word1", "Password!", "Password1", "Password22", "iloveyou!"
	AdminPassword *string `json:"adminPassword,omitempty"`

	// +kubebuilder:validation:Required
	//AdminUsername: Specifies the name of the administrator account.
	//Restriction: Cannot end in "."
	//Disallowed values: "administrator", "admin", "user", "user1", "test", "user2",
	//"test1", "user3", "admin1", "1", "123", "a", "actuser", "adm", "admin2",
	//"aspnet", "backup", "console", "david", "guest", "john", "owner", "root",
	//"server", "sql", "support", "support_388945a0", "sys", "test2", "test3",
	//"user4", "user5".
	//Minimum-length: 1 character
	//Max-length: 20 characters
	AdminUsername string `json:"adminUsername"`

	//EnableCSIProxy: For more details on CSI proxy, see the [CSI proxy GitHub
	//repo](https://github.com/kubernetes-csi/csi-proxy).
	EnableCSIProxy *bool `json:"enableCSIProxy,omitempty"`

	//LicenseType: The license type to use for Windows VMs. See [Azure Hybrid User
	//Benefits](https://azure.microsoft.com/pricing/hybrid-benefit/faq/) for more
	//details.
	LicenseType *ManagedClusterWindowsProfileLicenseType `json:"licenseType,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterWindowsProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (managedClusterWindowsProfile *ManagedClusterWindowsProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if managedClusterWindowsProfile == nil {
		return nil, nil
	}
	var result ManagedClusterWindowsProfileARM

	// Set property ‘AdminPassword’:
	if managedClusterWindowsProfile.AdminPassword != nil {
		adminPassword := *managedClusterWindowsProfile.AdminPassword
		result.AdminPassword = &adminPassword
	}

	// Set property ‘AdminUsername’:
	result.AdminUsername = managedClusterWindowsProfile.AdminUsername

	// Set property ‘EnableCSIProxy’:
	if managedClusterWindowsProfile.EnableCSIProxy != nil {
		enableCSIProxy := *managedClusterWindowsProfile.EnableCSIProxy
		result.EnableCSIProxy = &enableCSIProxy
	}

	// Set property ‘LicenseType’:
	if managedClusterWindowsProfile.LicenseType != nil {
		licenseType := *managedClusterWindowsProfile.LicenseType
		result.LicenseType = &licenseType
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (managedClusterWindowsProfile *ManagedClusterWindowsProfile) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterWindowsProfileARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (managedClusterWindowsProfile *ManagedClusterWindowsProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterWindowsProfileARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterWindowsProfileARM, got %T", armInput)
	}

	// Set property ‘AdminPassword’:
	if typedInput.AdminPassword != nil {
		adminPassword := *typedInput.AdminPassword
		managedClusterWindowsProfile.AdminPassword = &adminPassword
	}

	// Set property ‘AdminUsername’:
	managedClusterWindowsProfile.AdminUsername = typedInput.AdminUsername

	// Set property ‘EnableCSIProxy’:
	if typedInput.EnableCSIProxy != nil {
		enableCSIProxy := *typedInput.EnableCSIProxy
		managedClusterWindowsProfile.EnableCSIProxy = &enableCSIProxy
	}

	// Set property ‘LicenseType’:
	if typedInput.LicenseType != nil {
		licenseType := *typedInput.LicenseType
		managedClusterWindowsProfile.LicenseType = &licenseType
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterWindowsProfile populates our ManagedClusterWindowsProfile from the provided source ManagedClusterWindowsProfile
func (managedClusterWindowsProfile *ManagedClusterWindowsProfile) AssignPropertiesFromManagedClusterWindowsProfile(source *v1alpha1api20210501storage.ManagedClusterWindowsProfile) error {

	// AdminPassword
	if source.AdminPassword != nil {
		adminPassword := *source.AdminPassword
		managedClusterWindowsProfile.AdminPassword = &adminPassword
	} else {
		managedClusterWindowsProfile.AdminPassword = nil
	}

	// AdminUsername
	if source.AdminUsername != nil {
		managedClusterWindowsProfile.AdminUsername = *source.AdminUsername
	} else {
		managedClusterWindowsProfile.AdminUsername = ""
	}

	// EnableCSIProxy
	if source.EnableCSIProxy != nil {
		enableCSIProxy := *source.EnableCSIProxy
		managedClusterWindowsProfile.EnableCSIProxy = &enableCSIProxy
	} else {
		managedClusterWindowsProfile.EnableCSIProxy = nil
	}

	// LicenseType
	if source.LicenseType != nil {
		licenseType := ManagedClusterWindowsProfileLicenseType(*source.LicenseType)
		managedClusterWindowsProfile.LicenseType = &licenseType
	} else {
		managedClusterWindowsProfile.LicenseType = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterWindowsProfile populates the provided destination ManagedClusterWindowsProfile from our ManagedClusterWindowsProfile
func (managedClusterWindowsProfile *ManagedClusterWindowsProfile) AssignPropertiesToManagedClusterWindowsProfile(destination *v1alpha1api20210501storage.ManagedClusterWindowsProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminPassword
	if managedClusterWindowsProfile.AdminPassword != nil {
		adminPassword := *managedClusterWindowsProfile.AdminPassword
		destination.AdminPassword = &adminPassword
	} else {
		destination.AdminPassword = nil
	}

	// AdminUsername
	adminUsername := managedClusterWindowsProfile.AdminUsername
	destination.AdminUsername = &adminUsername

	// EnableCSIProxy
	if managedClusterWindowsProfile.EnableCSIProxy != nil {
		enableCSIProxy := *managedClusterWindowsProfile.EnableCSIProxy
		destination.EnableCSIProxy = &enableCSIProxy
	} else {
		destination.EnableCSIProxy = nil
	}

	// LicenseType
	if managedClusterWindowsProfile.LicenseType != nil {
		licenseType := string(*managedClusterWindowsProfile.LicenseType)
		destination.LicenseType = &licenseType
	} else {
		destination.LicenseType = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type ManagedClusterWindowsProfile_Status struct {
	//AdminPassword: Specifies the password of the administrator account.
	//Minimum-length: 8 characters
	//Max-length: 123 characters
	//Complexity requirements: 3 out of 4 conditions below need to be fulfilled
	//Has lower characters
	//Has upper characters
	//Has a digit
	//Has a special character (Regex match [\W_])
	//Disallowed values: "abc@123", "P@$$w0rd", "P@ssw0rd", "P@ssword123", "Pa$$word",
	//"pass@word1", "Password!", "Password1", "Password22", "iloveyou!"
	AdminPassword *string `json:"adminPassword,omitempty"`

	// +kubebuilder:validation:Required
	//AdminUsername: Specifies the name of the administrator account.
	//restriction: Cannot end in "."
	//Disallowed values: "administrator", "admin", "user", "user1", "test", "user2",
	//"test1", "user3", "admin1", "1", "123", "a", "actuser", "adm", "admin2",
	//"aspnet", "backup", "console", "david", "guest", "john", "owner", "root",
	//"server", "sql", "support", "support_388945a0", "sys", "test2", "test3",
	//"user4", "user5".
	//Minimum-length: 1 character
	//Max-length: 20 characters
	AdminUsername string `json:"adminUsername"`

	//EnableCSIProxy: Whether to enable CSI proxy.
	EnableCSIProxy *bool `json:"enableCSIProxy,omitempty"`

	//LicenseType: The licenseType to use for Windows VMs. Windows_Server is used to
	//enable Azure Hybrid User Benefits for Windows VMs.
	LicenseType *ManagedClusterWindowsProfileStatusLicenseType `json:"licenseType,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterWindowsProfile_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (managedClusterWindowsProfileStatus *ManagedClusterWindowsProfile_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterWindowsProfile_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (managedClusterWindowsProfileStatus *ManagedClusterWindowsProfile_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterWindowsProfile_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterWindowsProfile_StatusARM, got %T", armInput)
	}

	// Set property ‘AdminPassword’:
	if typedInput.AdminPassword != nil {
		adminPassword := *typedInput.AdminPassword
		managedClusterWindowsProfileStatus.AdminPassword = &adminPassword
	}

	// Set property ‘AdminUsername’:
	managedClusterWindowsProfileStatus.AdminUsername = typedInput.AdminUsername

	// Set property ‘EnableCSIProxy’:
	if typedInput.EnableCSIProxy != nil {
		enableCSIProxy := *typedInput.EnableCSIProxy
		managedClusterWindowsProfileStatus.EnableCSIProxy = &enableCSIProxy
	}

	// Set property ‘LicenseType’:
	if typedInput.LicenseType != nil {
		licenseType := *typedInput.LicenseType
		managedClusterWindowsProfileStatus.LicenseType = &licenseType
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterWindowsProfileStatus populates our ManagedClusterWindowsProfile_Status from the provided source ManagedClusterWindowsProfile_Status
func (managedClusterWindowsProfileStatus *ManagedClusterWindowsProfile_Status) AssignPropertiesFromManagedClusterWindowsProfileStatus(source *v1alpha1api20210501storage.ManagedClusterWindowsProfile_Status) error {

	// AdminPassword
	if source.AdminPassword != nil {
		adminPassword := *source.AdminPassword
		managedClusterWindowsProfileStatus.AdminPassword = &adminPassword
	} else {
		managedClusterWindowsProfileStatus.AdminPassword = nil
	}

	// AdminUsername
	if source.AdminUsername != nil {
		managedClusterWindowsProfileStatus.AdminUsername = *source.AdminUsername
	} else {
		managedClusterWindowsProfileStatus.AdminUsername = ""
	}

	// EnableCSIProxy
	if source.EnableCSIProxy != nil {
		enableCSIProxy := *source.EnableCSIProxy
		managedClusterWindowsProfileStatus.EnableCSIProxy = &enableCSIProxy
	} else {
		managedClusterWindowsProfileStatus.EnableCSIProxy = nil
	}

	// LicenseType
	if source.LicenseType != nil {
		licenseType := ManagedClusterWindowsProfileStatusLicenseType(*source.LicenseType)
		managedClusterWindowsProfileStatus.LicenseType = &licenseType
	} else {
		managedClusterWindowsProfileStatus.LicenseType = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterWindowsProfileStatus populates the provided destination ManagedClusterWindowsProfile_Status from our ManagedClusterWindowsProfile_Status
func (managedClusterWindowsProfileStatus *ManagedClusterWindowsProfile_Status) AssignPropertiesToManagedClusterWindowsProfileStatus(destination *v1alpha1api20210501storage.ManagedClusterWindowsProfile_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminPassword
	if managedClusterWindowsProfileStatus.AdminPassword != nil {
		adminPassword := *managedClusterWindowsProfileStatus.AdminPassword
		destination.AdminPassword = &adminPassword
	} else {
		destination.AdminPassword = nil
	}

	// AdminUsername
	adminUsername := managedClusterWindowsProfileStatus.AdminUsername
	destination.AdminUsername = &adminUsername

	// EnableCSIProxy
	if managedClusterWindowsProfileStatus.EnableCSIProxy != nil {
		enableCSIProxy := *managedClusterWindowsProfileStatus.EnableCSIProxy
		destination.EnableCSIProxy = &enableCSIProxy
	} else {
		destination.EnableCSIProxy = nil
	}

	// LicenseType
	if managedClusterWindowsProfileStatus.LicenseType != nil {
		licenseType := string(*managedClusterWindowsProfileStatus.LicenseType)
		destination.LicenseType = &licenseType
	} else {
		destination.LicenseType = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type PowerState_Status struct {
	//Code: Tells whether the cluster is Running or Stopped
	Code *PowerStateStatusCode `json:"code,omitempty"`
}

var _ genruntime.FromARMConverter = &PowerState_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (powerStateStatus *PowerState_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &PowerState_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (powerStateStatus *PowerState_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(PowerState_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PowerState_StatusARM, got %T", armInput)
	}

	// Set property ‘Code’:
	if typedInput.Code != nil {
		code := *typedInput.Code
		powerStateStatus.Code = &code
	}

	// No error
	return nil
}

// AssignPropertiesFromPowerStateStatus populates our PowerState_Status from the provided source PowerState_Status
func (powerStateStatus *PowerState_Status) AssignPropertiesFromPowerStateStatus(source *v1alpha1api20210501storage.PowerState_Status) error {

	// Code
	if source.Code != nil {
		code := PowerStateStatusCode(*source.Code)
		powerStateStatus.Code = &code
	} else {
		powerStateStatus.Code = nil
	}

	// No error
	return nil
}

// AssignPropertiesToPowerStateStatus populates the provided destination PowerState_Status from our PowerState_Status
func (powerStateStatus *PowerState_Status) AssignPropertiesToPowerStateStatus(destination *v1alpha1api20210501storage.PowerState_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Code
	if powerStateStatus.Code != nil {
		code := string(*powerStateStatus.Code)
		destination.Code = &code
	} else {
		destination.Code = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2021-05-01/Microsoft.ContainerService.json#/definitions/PrivateLinkResource
type PrivateLinkResource struct {
	//GroupId: The group ID of the resource.
	GroupId *string `json:"groupId,omitempty"`

	//Name: The name of the private link resource.
	Name *string `json:"name,omitempty"`

	//Reference: The ID of the private link resource.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`

	//RequiredMembers: The RequiredMembers of the resource
	RequiredMembers []string `json:"requiredMembers,omitempty"`

	//Type: The resource type.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &PrivateLinkResource{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (privateLinkResource *PrivateLinkResource) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if privateLinkResource == nil {
		return nil, nil
	}
	var result PrivateLinkResourceARM

	// Set property ‘GroupId’:
	if privateLinkResource.GroupId != nil {
		groupId := *privateLinkResource.GroupId
		result.GroupId = &groupId
	}

	// Set property ‘Id’:
	if privateLinkResource.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*privateLinkResource.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property ‘Name’:
	if privateLinkResource.Name != nil {
		name := *privateLinkResource.Name
		result.Name = &name
	}

	// Set property ‘RequiredMembers’:
	for _, item := range privateLinkResource.RequiredMembers {
		result.RequiredMembers = append(result.RequiredMembers, item)
	}

	// Set property ‘Type’:
	if privateLinkResource.Type != nil {
		typeVar := *privateLinkResource.Type
		result.Type = &typeVar
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (privateLinkResource *PrivateLinkResource) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &PrivateLinkResourceARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (privateLinkResource *PrivateLinkResource) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(PrivateLinkResourceARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PrivateLinkResourceARM, got %T", armInput)
	}

	// Set property ‘GroupId’:
	if typedInput.GroupId != nil {
		groupId := *typedInput.GroupId
		privateLinkResource.GroupId = &groupId
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		privateLinkResource.Name = &name
	}

	// no assignment for property ‘Reference’

	// Set property ‘RequiredMembers’:
	for _, item := range typedInput.RequiredMembers {
		privateLinkResource.RequiredMembers = append(privateLinkResource.RequiredMembers, item)
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		privateLinkResource.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromPrivateLinkResource populates our PrivateLinkResource from the provided source PrivateLinkResource
func (privateLinkResource *PrivateLinkResource) AssignPropertiesFromPrivateLinkResource(source *v1alpha1api20210501storage.PrivateLinkResource) error {

	// GroupId
	if source.GroupId != nil {
		groupId := *source.GroupId
		privateLinkResource.GroupId = &groupId
	} else {
		privateLinkResource.GroupId = nil
	}

	// Name
	if source.Name != nil {
		name := *source.Name
		privateLinkResource.Name = &name
	} else {
		privateLinkResource.Name = nil
	}

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		privateLinkResource.Reference = &reference
	} else {
		privateLinkResource.Reference = nil
	}

	// RequiredMembers
	requiredMemberList := make([]string, len(source.RequiredMembers))
	for requiredMemberIndex, requiredMemberItem := range source.RequiredMembers {
		// Shadow the loop variable to avoid aliasing
		requiredMemberItem := requiredMemberItem
		requiredMemberList[requiredMemberIndex] = requiredMemberItem
	}
	privateLinkResource.RequiredMembers = requiredMemberList

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		privateLinkResource.Type = &typeVar
	} else {
		privateLinkResource.Type = nil
	}

	// No error
	return nil
}

// AssignPropertiesToPrivateLinkResource populates the provided destination PrivateLinkResource from our PrivateLinkResource
func (privateLinkResource *PrivateLinkResource) AssignPropertiesToPrivateLinkResource(destination *v1alpha1api20210501storage.PrivateLinkResource) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// GroupId
	if privateLinkResource.GroupId != nil {
		groupId := *privateLinkResource.GroupId
		destination.GroupId = &groupId
	} else {
		destination.GroupId = nil
	}

	// Name
	if privateLinkResource.Name != nil {
		name := *privateLinkResource.Name
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Reference
	if privateLinkResource.Reference != nil {
		reference := privateLinkResource.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// RequiredMembers
	requiredMemberList := make([]string, len(privateLinkResource.RequiredMembers))
	for requiredMemberIndex, requiredMemberItem := range privateLinkResource.RequiredMembers {
		// Shadow the loop variable to avoid aliasing
		requiredMemberItem := requiredMemberItem
		requiredMemberList[requiredMemberIndex] = requiredMemberItem
	}
	destination.RequiredMembers = requiredMemberList

	// Type
	if privateLinkResource.Type != nil {
		typeVar := *privateLinkResource.Type
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type PrivateLinkResource_Status struct {
	//GroupId: The group ID of the resource.
	GroupId *string `json:"groupId,omitempty"`

	//Id: The ID of the private link resource.
	Id *string `json:"id,omitempty"`

	//Name: The name of the private link resource.
	Name *string `json:"name,omitempty"`

	//PrivateLinkServiceID: The private link service ID of the resource, this field is
	//exposed only to NRP internally.
	PrivateLinkServiceID *string `json:"privateLinkServiceID,omitempty"`

	//RequiredMembers: RequiredMembers of the resource
	RequiredMembers []string `json:"requiredMembers,omitempty"`

	//Type: The resource type.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &PrivateLinkResource_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (privateLinkResourceStatus *PrivateLinkResource_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &PrivateLinkResource_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (privateLinkResourceStatus *PrivateLinkResource_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(PrivateLinkResource_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PrivateLinkResource_StatusARM, got %T", armInput)
	}

	// Set property ‘GroupId’:
	if typedInput.GroupId != nil {
		groupId := *typedInput.GroupId
		privateLinkResourceStatus.GroupId = &groupId
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		privateLinkResourceStatus.Id = &id
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		privateLinkResourceStatus.Name = &name
	}

	// Set property ‘PrivateLinkServiceID’:
	if typedInput.PrivateLinkServiceID != nil {
		privateLinkServiceID := *typedInput.PrivateLinkServiceID
		privateLinkResourceStatus.PrivateLinkServiceID = &privateLinkServiceID
	}

	// Set property ‘RequiredMembers’:
	for _, item := range typedInput.RequiredMembers {
		privateLinkResourceStatus.RequiredMembers = append(privateLinkResourceStatus.RequiredMembers, item)
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		privateLinkResourceStatus.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromPrivateLinkResourceStatus populates our PrivateLinkResource_Status from the provided source PrivateLinkResource_Status
func (privateLinkResourceStatus *PrivateLinkResource_Status) AssignPropertiesFromPrivateLinkResourceStatus(source *v1alpha1api20210501storage.PrivateLinkResource_Status) error {

	// GroupId
	if source.GroupId != nil {
		groupId := *source.GroupId
		privateLinkResourceStatus.GroupId = &groupId
	} else {
		privateLinkResourceStatus.GroupId = nil
	}

	// Id
	if source.Id != nil {
		id := *source.Id
		privateLinkResourceStatus.Id = &id
	} else {
		privateLinkResourceStatus.Id = nil
	}

	// Name
	if source.Name != nil {
		name := *source.Name
		privateLinkResourceStatus.Name = &name
	} else {
		privateLinkResourceStatus.Name = nil
	}

	// PrivateLinkServiceID
	if source.PrivateLinkServiceID != nil {
		privateLinkServiceID := *source.PrivateLinkServiceID
		privateLinkResourceStatus.PrivateLinkServiceID = &privateLinkServiceID
	} else {
		privateLinkResourceStatus.PrivateLinkServiceID = nil
	}

	// RequiredMembers
	requiredMemberList := make([]string, len(source.RequiredMembers))
	for requiredMemberIndex, requiredMemberItem := range source.RequiredMembers {
		// Shadow the loop variable to avoid aliasing
		requiredMemberItem := requiredMemberItem
		requiredMemberList[requiredMemberIndex] = requiredMemberItem
	}
	privateLinkResourceStatus.RequiredMembers = requiredMemberList

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		privateLinkResourceStatus.Type = &typeVar
	} else {
		privateLinkResourceStatus.Type = nil
	}

	// No error
	return nil
}

// AssignPropertiesToPrivateLinkResourceStatus populates the provided destination PrivateLinkResource_Status from our PrivateLinkResource_Status
func (privateLinkResourceStatus *PrivateLinkResource_Status) AssignPropertiesToPrivateLinkResourceStatus(destination *v1alpha1api20210501storage.PrivateLinkResource_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// GroupId
	if privateLinkResourceStatus.GroupId != nil {
		groupId := *privateLinkResourceStatus.GroupId
		destination.GroupId = &groupId
	} else {
		destination.GroupId = nil
	}

	// Id
	if privateLinkResourceStatus.Id != nil {
		id := *privateLinkResourceStatus.Id
		destination.Id = &id
	} else {
		destination.Id = nil
	}

	// Name
	if privateLinkResourceStatus.Name != nil {
		name := *privateLinkResourceStatus.Name
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// PrivateLinkServiceID
	if privateLinkResourceStatus.PrivateLinkServiceID != nil {
		privateLinkServiceID := *privateLinkResourceStatus.PrivateLinkServiceID
		destination.PrivateLinkServiceID = &privateLinkServiceID
	} else {
		destination.PrivateLinkServiceID = nil
	}

	// RequiredMembers
	requiredMemberList := make([]string, len(privateLinkResourceStatus.RequiredMembers))
	for requiredMemberIndex, requiredMemberItem := range privateLinkResourceStatus.RequiredMembers {
		// Shadow the loop variable to avoid aliasing
		requiredMemberItem := requiredMemberItem
		requiredMemberList[requiredMemberIndex] = requiredMemberItem
	}
	destination.RequiredMembers = requiredMemberList

	// Type
	if privateLinkResourceStatus.Type != nil {
		typeVar := *privateLinkResourceStatus.Type
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"basic","standard"}
type ContainerServiceNetworkProfileLoadBalancerSku string

const (
	ContainerServiceNetworkProfileLoadBalancerSkuBasic    = ContainerServiceNetworkProfileLoadBalancerSku("basic")
	ContainerServiceNetworkProfileLoadBalancerSkuStandard = ContainerServiceNetworkProfileLoadBalancerSku("standard")
)

// +kubebuilder:validation:Enum={"bridge","transparent"}
type ContainerServiceNetworkProfileNetworkMode string

const (
	ContainerServiceNetworkProfileNetworkModeBridge      = ContainerServiceNetworkProfileNetworkMode("bridge")
	ContainerServiceNetworkProfileNetworkModeTransparent = ContainerServiceNetworkProfileNetworkMode("transparent")
)

// +kubebuilder:validation:Enum={"azure","kubenet"}
type ContainerServiceNetworkProfileNetworkPlugin string

const (
	ContainerServiceNetworkProfileNetworkPluginAzure   = ContainerServiceNetworkProfileNetworkPlugin("azure")
	ContainerServiceNetworkProfileNetworkPluginKubenet = ContainerServiceNetworkProfileNetworkPlugin("kubenet")
)

// +kubebuilder:validation:Enum={"azure","calico"}
type ContainerServiceNetworkProfileNetworkPolicy string

const (
	ContainerServiceNetworkProfileNetworkPolicyAzure  = ContainerServiceNetworkProfileNetworkPolicy("azure")
	ContainerServiceNetworkProfileNetworkPolicyCalico = ContainerServiceNetworkProfileNetworkPolicy("calico")
)

// +kubebuilder:validation:Enum={"loadBalancer","userDefinedRouting"}
type ContainerServiceNetworkProfileOutboundType string

const (
	ContainerServiceNetworkProfileOutboundTypeLoadBalancer       = ContainerServiceNetworkProfileOutboundType("loadBalancer")
	ContainerServiceNetworkProfileOutboundTypeUserDefinedRouting = ContainerServiceNetworkProfileOutboundType("userDefinedRouting")
)

type ContainerServiceNetworkProfileStatusLoadBalancerSku string

const (
	ContainerServiceNetworkProfileStatusLoadBalancerSkuBasic    = ContainerServiceNetworkProfileStatusLoadBalancerSku("basic")
	ContainerServiceNetworkProfileStatusLoadBalancerSkuStandard = ContainerServiceNetworkProfileStatusLoadBalancerSku("standard")
)

type ContainerServiceNetworkProfileStatusNetworkMode string

const (
	ContainerServiceNetworkProfileStatusNetworkModeBridge      = ContainerServiceNetworkProfileStatusNetworkMode("bridge")
	ContainerServiceNetworkProfileStatusNetworkModeTransparent = ContainerServiceNetworkProfileStatusNetworkMode("transparent")
)

type ContainerServiceNetworkProfileStatusNetworkPlugin string

const (
	ContainerServiceNetworkProfileStatusNetworkPluginAzure   = ContainerServiceNetworkProfileStatusNetworkPlugin("azure")
	ContainerServiceNetworkProfileStatusNetworkPluginKubenet = ContainerServiceNetworkProfileStatusNetworkPlugin("kubenet")
)

type ContainerServiceNetworkProfileStatusNetworkPolicy string

const (
	ContainerServiceNetworkProfileStatusNetworkPolicyAzure  = ContainerServiceNetworkProfileStatusNetworkPolicy("azure")
	ContainerServiceNetworkProfileStatusNetworkPolicyCalico = ContainerServiceNetworkProfileStatusNetworkPolicy("calico")
)

type ContainerServiceNetworkProfileStatusOutboundType string

const (
	ContainerServiceNetworkProfileStatusOutboundTypeLoadBalancer       = ContainerServiceNetworkProfileStatusOutboundType("loadBalancer")
	ContainerServiceNetworkProfileStatusOutboundTypeUserDefinedRouting = ContainerServiceNetworkProfileStatusOutboundType("userDefinedRouting")
)

//Generated from: https://schema.management.azure.com/schemas/2021-05-01/Microsoft.ContainerService.json#/definitions/ContainerServiceSshConfiguration
type ContainerServiceSshConfiguration struct {
	// +kubebuilder:validation:Required
	//PublicKeys: The list of SSH public keys used to authenticate with Linux-based
	//VMs. A maximum of 1 key may be specified.
	PublicKeys []ContainerServiceSshPublicKey `json:"publicKeys"`
}

var _ genruntime.ARMTransformer = &ContainerServiceSshConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (containerServiceSshConfiguration *ContainerServiceSshConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if containerServiceSshConfiguration == nil {
		return nil, nil
	}
	var result ContainerServiceSshConfigurationARM

	// Set property ‘PublicKeys’:
	for _, item := range containerServiceSshConfiguration.PublicKeys {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.PublicKeys = append(result.PublicKeys, itemARM.(ContainerServiceSshPublicKeyARM))
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (containerServiceSshConfiguration *ContainerServiceSshConfiguration) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerServiceSshConfigurationARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (containerServiceSshConfiguration *ContainerServiceSshConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerServiceSshConfigurationARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerServiceSshConfigurationARM, got %T", armInput)
	}

	// Set property ‘PublicKeys’:
	for _, item := range typedInput.PublicKeys {
		var item1 ContainerServiceSshPublicKey
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		containerServiceSshConfiguration.PublicKeys = append(containerServiceSshConfiguration.PublicKeys, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromContainerServiceSshConfiguration populates our ContainerServiceSshConfiguration from the provided source ContainerServiceSshConfiguration
func (containerServiceSshConfiguration *ContainerServiceSshConfiguration) AssignPropertiesFromContainerServiceSshConfiguration(source *v1alpha1api20210501storage.ContainerServiceSshConfiguration) error {

	// PublicKeys
	publicKeyList := make([]ContainerServiceSshPublicKey, len(source.PublicKeys))
	for publicKeyIndex, publicKeyItem := range source.PublicKeys {
		// Shadow the loop variable to avoid aliasing
		publicKeyItem := publicKeyItem
		var publicKey ContainerServiceSshPublicKey
		err := publicKey.AssignPropertiesFromContainerServiceSshPublicKey(&publicKeyItem)
		if err != nil {
			return errors.Wrap(err, "populating PublicKeys from PublicKeys, calling AssignPropertiesFromContainerServiceSshPublicKey()")
		}
		publicKeyList[publicKeyIndex] = publicKey
	}
	containerServiceSshConfiguration.PublicKeys = publicKeyList

	// No error
	return nil
}

// AssignPropertiesToContainerServiceSshConfiguration populates the provided destination ContainerServiceSshConfiguration from our ContainerServiceSshConfiguration
func (containerServiceSshConfiguration *ContainerServiceSshConfiguration) AssignPropertiesToContainerServiceSshConfiguration(destination *v1alpha1api20210501storage.ContainerServiceSshConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PublicKeys
	publicKeyList := make([]v1alpha1api20210501storage.ContainerServiceSshPublicKey, len(containerServiceSshConfiguration.PublicKeys))
	for publicKeyIndex, publicKeyItem := range containerServiceSshConfiguration.PublicKeys {
		// Shadow the loop variable to avoid aliasing
		publicKeyItem := publicKeyItem
		var publicKey v1alpha1api20210501storage.ContainerServiceSshPublicKey
		err := publicKeyItem.AssignPropertiesToContainerServiceSshPublicKey(&publicKey)
		if err != nil {
			return errors.Wrap(err, "populating PublicKeys from PublicKeys, calling AssignPropertiesToContainerServiceSshPublicKey()")
		}
		publicKeyList[publicKeyIndex] = publicKey
	}
	destination.PublicKeys = publicKeyList

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type ContainerServiceSshConfiguration_Status struct {
	// +kubebuilder:validation:Required
	//PublicKeys: The list of SSH public keys used to authenticate with Linux-based
	//VMs. Only expect one key specified.
	PublicKeys []ContainerServiceSshPublicKey_Status `json:"publicKeys"`
}

var _ genruntime.FromARMConverter = &ContainerServiceSshConfiguration_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (containerServiceSshConfigurationStatus *ContainerServiceSshConfiguration_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerServiceSshConfiguration_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (containerServiceSshConfigurationStatus *ContainerServiceSshConfiguration_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerServiceSshConfiguration_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerServiceSshConfiguration_StatusARM, got %T", armInput)
	}

	// Set property ‘PublicKeys’:
	for _, item := range typedInput.PublicKeys {
		var item1 ContainerServiceSshPublicKey_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		containerServiceSshConfigurationStatus.PublicKeys = append(containerServiceSshConfigurationStatus.PublicKeys, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromContainerServiceSshConfigurationStatus populates our ContainerServiceSshConfiguration_Status from the provided source ContainerServiceSshConfiguration_Status
func (containerServiceSshConfigurationStatus *ContainerServiceSshConfiguration_Status) AssignPropertiesFromContainerServiceSshConfigurationStatus(source *v1alpha1api20210501storage.ContainerServiceSshConfiguration_Status) error {

	// PublicKeys
	publicKeyList := make([]ContainerServiceSshPublicKey_Status, len(source.PublicKeys))
	for publicKeyIndex, publicKeyItem := range source.PublicKeys {
		// Shadow the loop variable to avoid aliasing
		publicKeyItem := publicKeyItem
		var publicKey ContainerServiceSshPublicKey_Status
		err := publicKey.AssignPropertiesFromContainerServiceSshPublicKeyStatus(&publicKeyItem)
		if err != nil {
			return errors.Wrap(err, "populating PublicKeys from PublicKeys, calling AssignPropertiesFromContainerServiceSshPublicKeyStatus()")
		}
		publicKeyList[publicKeyIndex] = publicKey
	}
	containerServiceSshConfigurationStatus.PublicKeys = publicKeyList

	// No error
	return nil
}

// AssignPropertiesToContainerServiceSshConfigurationStatus populates the provided destination ContainerServiceSshConfiguration_Status from our ContainerServiceSshConfiguration_Status
func (containerServiceSshConfigurationStatus *ContainerServiceSshConfiguration_Status) AssignPropertiesToContainerServiceSshConfigurationStatus(destination *v1alpha1api20210501storage.ContainerServiceSshConfiguration_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PublicKeys
	publicKeyList := make([]v1alpha1api20210501storage.ContainerServiceSshPublicKey_Status, len(containerServiceSshConfigurationStatus.PublicKeys))
	for publicKeyIndex, publicKeyItem := range containerServiceSshConfigurationStatus.PublicKeys {
		// Shadow the loop variable to avoid aliasing
		publicKeyItem := publicKeyItem
		var publicKey v1alpha1api20210501storage.ContainerServiceSshPublicKey_Status
		err := publicKeyItem.AssignPropertiesToContainerServiceSshPublicKeyStatus(&publicKey)
		if err != nil {
			return errors.Wrap(err, "populating PublicKeys from PublicKeys, calling AssignPropertiesToContainerServiceSshPublicKeyStatus()")
		}
		publicKeyList[publicKeyIndex] = publicKey
	}
	destination.PublicKeys = publicKeyList

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"MIG1g","MIG2g","MIG3g","MIG4g","MIG7g"}
type ManagedClusterAgentPoolProfileGpuInstanceProfile string

const (
	ManagedClusterAgentPoolProfileGpuInstanceProfileMIG1G = ManagedClusterAgentPoolProfileGpuInstanceProfile("MIG1g")
	ManagedClusterAgentPoolProfileGpuInstanceProfileMIG2G = ManagedClusterAgentPoolProfileGpuInstanceProfile("MIG2g")
	ManagedClusterAgentPoolProfileGpuInstanceProfileMIG3G = ManagedClusterAgentPoolProfileGpuInstanceProfile("MIG3g")
	ManagedClusterAgentPoolProfileGpuInstanceProfileMIG4G = ManagedClusterAgentPoolProfileGpuInstanceProfile("MIG4g")
	ManagedClusterAgentPoolProfileGpuInstanceProfileMIG7G = ManagedClusterAgentPoolProfileGpuInstanceProfile("MIG7g")
)

// +kubebuilder:validation:Enum={"OS","Temporary"}
type ManagedClusterAgentPoolProfileKubeletDiskType string

const (
	ManagedClusterAgentPoolProfileKubeletDiskTypeOS        = ManagedClusterAgentPoolProfileKubeletDiskType("OS")
	ManagedClusterAgentPoolProfileKubeletDiskTypeTemporary = ManagedClusterAgentPoolProfileKubeletDiskType("Temporary")
)

// +kubebuilder:validation:Enum={"System","User"}
type ManagedClusterAgentPoolProfileMode string

const (
	ManagedClusterAgentPoolProfileModeSystem = ManagedClusterAgentPoolProfileMode("System")
	ManagedClusterAgentPoolProfileModeUser   = ManagedClusterAgentPoolProfileMode("User")
)

// +kubebuilder:validation:Enum={"Ephemeral","Managed"}
type ManagedClusterAgentPoolProfileOsDiskType string

const (
	ManagedClusterAgentPoolProfileOsDiskTypeEphemeral = ManagedClusterAgentPoolProfileOsDiskType("Ephemeral")
	ManagedClusterAgentPoolProfileOsDiskTypeManaged   = ManagedClusterAgentPoolProfileOsDiskType("Managed")
)

// +kubebuilder:validation:Enum={"CBLMariner","Ubuntu"}
type ManagedClusterAgentPoolProfileOsSKU string

const (
	ManagedClusterAgentPoolProfileOsSKUCBLMariner = ManagedClusterAgentPoolProfileOsSKU("CBLMariner")
	ManagedClusterAgentPoolProfileOsSKUUbuntu     = ManagedClusterAgentPoolProfileOsSKU("Ubuntu")
)

// +kubebuilder:validation:Enum={"Linux","Windows"}
type ManagedClusterAgentPoolProfileOsType string

const (
	ManagedClusterAgentPoolProfileOsTypeLinux   = ManagedClusterAgentPoolProfileOsType("Linux")
	ManagedClusterAgentPoolProfileOsTypeWindows = ManagedClusterAgentPoolProfileOsType("Windows")
)

// +kubebuilder:validation:Enum={"Deallocate","Delete"}
type ManagedClusterAgentPoolProfileScaleSetEvictionPolicy string

const (
	ManagedClusterAgentPoolProfileScaleSetEvictionPolicyDeallocate = ManagedClusterAgentPoolProfileScaleSetEvictionPolicy("Deallocate")
	ManagedClusterAgentPoolProfileScaleSetEvictionPolicyDelete     = ManagedClusterAgentPoolProfileScaleSetEvictionPolicy("Delete")
)

// +kubebuilder:validation:Enum={"Regular","Spot"}
type ManagedClusterAgentPoolProfileScaleSetPriority string

const (
	ManagedClusterAgentPoolProfileScaleSetPriorityRegular = ManagedClusterAgentPoolProfileScaleSetPriority("Regular")
	ManagedClusterAgentPoolProfileScaleSetPrioritySpot    = ManagedClusterAgentPoolProfileScaleSetPriority("Spot")
)

// +kubebuilder:validation:Enum={"AvailabilitySet","VirtualMachineScaleSets"}
type ManagedClusterAgentPoolProfileType string

const (
	ManagedClusterAgentPoolProfileTypeAvailabilitySet         = ManagedClusterAgentPoolProfileType("AvailabilitySet")
	ManagedClusterAgentPoolProfileTypeVirtualMachineScaleSets = ManagedClusterAgentPoolProfileType("VirtualMachineScaleSets")
)

type ManagedClusterAutoUpgradeProfileStatusUpgradeChannel string

const (
	ManagedClusterAutoUpgradeProfileStatusUpgradeChannelNodeImage = ManagedClusterAutoUpgradeProfileStatusUpgradeChannel("node-image")
	ManagedClusterAutoUpgradeProfileStatusUpgradeChannelNone      = ManagedClusterAutoUpgradeProfileStatusUpgradeChannel("none")
	ManagedClusterAutoUpgradeProfileStatusUpgradeChannelPatch     = ManagedClusterAutoUpgradeProfileStatusUpgradeChannel("patch")
	ManagedClusterAutoUpgradeProfileStatusUpgradeChannelRapid     = ManagedClusterAutoUpgradeProfileStatusUpgradeChannel("rapid")
	ManagedClusterAutoUpgradeProfileStatusUpgradeChannelStable    = ManagedClusterAutoUpgradeProfileStatusUpgradeChannel("stable")
)

// +kubebuilder:validation:Enum={"node-image","none","patch","rapid","stable"}
type ManagedClusterAutoUpgradeProfileUpgradeChannel string

const (
	ManagedClusterAutoUpgradeProfileUpgradeChannelNodeImage = ManagedClusterAutoUpgradeProfileUpgradeChannel("node-image")
	ManagedClusterAutoUpgradeProfileUpgradeChannelNone      = ManagedClusterAutoUpgradeProfileUpgradeChannel("none")
	ManagedClusterAutoUpgradeProfileUpgradeChannelPatch     = ManagedClusterAutoUpgradeProfileUpgradeChannel("patch")
	ManagedClusterAutoUpgradeProfileUpgradeChannelRapid     = ManagedClusterAutoUpgradeProfileUpgradeChannel("rapid")
	ManagedClusterAutoUpgradeProfileUpgradeChannelStable    = ManagedClusterAutoUpgradeProfileUpgradeChannel("stable")
)

type ManagedClusterIdentity_Status_UserAssignedIdentities struct {
	//ClientId: The client id of user assigned identity.
	ClientId *string `json:"clientId,omitempty"`

	//PrincipalId: The principal id of user assigned identity.
	PrincipalId *string `json:"principalId,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterIdentity_Status_UserAssignedIdentities{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (managedClusterIdentityStatusUserAssignedIdentities *ManagedClusterIdentity_Status_UserAssignedIdentities) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterIdentity_Status_UserAssignedIdentitiesARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (managedClusterIdentityStatusUserAssignedIdentities *ManagedClusterIdentity_Status_UserAssignedIdentities) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterIdentity_Status_UserAssignedIdentitiesARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterIdentity_Status_UserAssignedIdentitiesARM, got %T", armInput)
	}

	// Set property ‘ClientId’:
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		managedClusterIdentityStatusUserAssignedIdentities.ClientId = &clientId
	}

	// Set property ‘PrincipalId’:
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		managedClusterIdentityStatusUserAssignedIdentities.PrincipalId = &principalId
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterIdentityStatusUserAssignedIdentities populates our ManagedClusterIdentity_Status_UserAssignedIdentities from the provided source ManagedClusterIdentity_Status_UserAssignedIdentities
func (managedClusterIdentityStatusUserAssignedIdentities *ManagedClusterIdentity_Status_UserAssignedIdentities) AssignPropertiesFromManagedClusterIdentityStatusUserAssignedIdentities(source *v1alpha1api20210501storage.ManagedClusterIdentity_Status_UserAssignedIdentities) error {

	// ClientId
	if source.ClientId != nil {
		clientId := *source.ClientId
		managedClusterIdentityStatusUserAssignedIdentities.ClientId = &clientId
	} else {
		managedClusterIdentityStatusUserAssignedIdentities.ClientId = nil
	}

	// PrincipalId
	if source.PrincipalId != nil {
		principalId := *source.PrincipalId
		managedClusterIdentityStatusUserAssignedIdentities.PrincipalId = &principalId
	} else {
		managedClusterIdentityStatusUserAssignedIdentities.PrincipalId = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterIdentityStatusUserAssignedIdentities populates the provided destination ManagedClusterIdentity_Status_UserAssignedIdentities from our ManagedClusterIdentity_Status_UserAssignedIdentities
func (managedClusterIdentityStatusUserAssignedIdentities *ManagedClusterIdentity_Status_UserAssignedIdentities) AssignPropertiesToManagedClusterIdentityStatusUserAssignedIdentities(destination *v1alpha1api20210501storage.ManagedClusterIdentity_Status_UserAssignedIdentities) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	if managedClusterIdentityStatusUserAssignedIdentities.ClientId != nil {
		clientId := *managedClusterIdentityStatusUserAssignedIdentities.ClientId
		destination.ClientId = &clientId
	} else {
		destination.ClientId = nil
	}

	// PrincipalId
	if managedClusterIdentityStatusUserAssignedIdentities.PrincipalId != nil {
		principalId := *managedClusterIdentityStatusUserAssignedIdentities.PrincipalId
		destination.PrincipalId = &principalId
	} else {
		destination.PrincipalId = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2021-05-01/Microsoft.ContainerService.json#/definitions/ManagedClusterLoadBalancerProfile
type ManagedClusterLoadBalancerProfile struct {
	// +kubebuilder:validation:Maximum=64000
	// +kubebuilder:validation:Minimum=0
	//AllocatedOutboundPorts: The desired number of allocated SNAT ports per VM.
	//Allowed values are in the range of 0 to 64000 (inclusive). The default value is
	//0 which results in Azure dynamically allocating ports.
	AllocatedOutboundPorts *int `json:"allocatedOutboundPorts,omitempty"`

	//EffectiveOutboundIPs: The effective outbound IP resources of the cluster load
	//balancer.
	EffectiveOutboundIPs []ResourceReference `json:"effectiveOutboundIPs,omitempty"`

	// +kubebuilder:validation:Maximum=120
	// +kubebuilder:validation:Minimum=4
	//IdleTimeoutInMinutes: Desired outbound flow idle timeout in minutes. Allowed
	//values are in the range of 4 to 120 (inclusive). The default value is 30 minutes.
	IdleTimeoutInMinutes *int `json:"idleTimeoutInMinutes,omitempty"`

	//ManagedOutboundIPs: Desired managed outbound IPs for the cluster load balancer.
	ManagedOutboundIPs *ManagedClusterLoadBalancerProfileManagedOutboundIPs `json:"managedOutboundIPs,omitempty"`

	//OutboundIPPrefixes: Desired outbound IP Prefix resources for the cluster load
	//balancer.
	OutboundIPPrefixes *ManagedClusterLoadBalancerProfileOutboundIPPrefixes `json:"outboundIPPrefixes,omitempty"`

	//OutboundIPs: Desired outbound IP resources for the cluster load balancer.
	OutboundIPs *ManagedClusterLoadBalancerProfileOutboundIPs `json:"outboundIPs,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterLoadBalancerProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (managedClusterLoadBalancerProfile *ManagedClusterLoadBalancerProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if managedClusterLoadBalancerProfile == nil {
		return nil, nil
	}
	var result ManagedClusterLoadBalancerProfileARM

	// Set property ‘AllocatedOutboundPorts’:
	if managedClusterLoadBalancerProfile.AllocatedOutboundPorts != nil {
		allocatedOutboundPorts := *managedClusterLoadBalancerProfile.AllocatedOutboundPorts
		result.AllocatedOutboundPorts = &allocatedOutboundPorts
	}

	// Set property ‘EffectiveOutboundIPs’:
	for _, item := range managedClusterLoadBalancerProfile.EffectiveOutboundIPs {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.EffectiveOutboundIPs = append(result.EffectiveOutboundIPs, itemARM.(ResourceReferenceARM))
	}

	// Set property ‘IdleTimeoutInMinutes’:
	if managedClusterLoadBalancerProfile.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinutes := *managedClusterLoadBalancerProfile.IdleTimeoutInMinutes
		result.IdleTimeoutInMinutes = &idleTimeoutInMinutes
	}

	// Set property ‘ManagedOutboundIPs’:
	if managedClusterLoadBalancerProfile.ManagedOutboundIPs != nil {
		managedOutboundIPsARM, err := (*managedClusterLoadBalancerProfile.ManagedOutboundIPs).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		managedOutboundIPs := managedOutboundIPsARM.(ManagedClusterLoadBalancerProfileManagedOutboundIPsARM)
		result.ManagedOutboundIPs = &managedOutboundIPs
	}

	// Set property ‘OutboundIPPrefixes’:
	if managedClusterLoadBalancerProfile.OutboundIPPrefixes != nil {
		outboundIPPrefixesARM, err := (*managedClusterLoadBalancerProfile.OutboundIPPrefixes).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		outboundIPPrefixes := outboundIPPrefixesARM.(ManagedClusterLoadBalancerProfileOutboundIPPrefixesARM)
		result.OutboundIPPrefixes = &outboundIPPrefixes
	}

	// Set property ‘OutboundIPs’:
	if managedClusterLoadBalancerProfile.OutboundIPs != nil {
		outboundIPsARM, err := (*managedClusterLoadBalancerProfile.OutboundIPs).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		outboundIPs := outboundIPsARM.(ManagedClusterLoadBalancerProfileOutboundIPsARM)
		result.OutboundIPs = &outboundIPs
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (managedClusterLoadBalancerProfile *ManagedClusterLoadBalancerProfile) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterLoadBalancerProfileARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (managedClusterLoadBalancerProfile *ManagedClusterLoadBalancerProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterLoadBalancerProfileARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterLoadBalancerProfileARM, got %T", armInput)
	}

	// Set property ‘AllocatedOutboundPorts’:
	if typedInput.AllocatedOutboundPorts != nil {
		allocatedOutboundPorts := *typedInput.AllocatedOutboundPorts
		managedClusterLoadBalancerProfile.AllocatedOutboundPorts = &allocatedOutboundPorts
	}

	// Set property ‘EffectiveOutboundIPs’:
	for _, item := range typedInput.EffectiveOutboundIPs {
		var item1 ResourceReference
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		managedClusterLoadBalancerProfile.EffectiveOutboundIPs = append(managedClusterLoadBalancerProfile.EffectiveOutboundIPs, item1)
	}

	// Set property ‘IdleTimeoutInMinutes’:
	if typedInput.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinutes := *typedInput.IdleTimeoutInMinutes
		managedClusterLoadBalancerProfile.IdleTimeoutInMinutes = &idleTimeoutInMinutes
	}

	// Set property ‘ManagedOutboundIPs’:
	if typedInput.ManagedOutboundIPs != nil {
		var managedOutboundIPs1 ManagedClusterLoadBalancerProfileManagedOutboundIPs
		err := managedOutboundIPs1.PopulateFromARM(owner, *typedInput.ManagedOutboundIPs)
		if err != nil {
			return err
		}
		managedOutboundIPs := managedOutboundIPs1
		managedClusterLoadBalancerProfile.ManagedOutboundIPs = &managedOutboundIPs
	}

	// Set property ‘OutboundIPPrefixes’:
	if typedInput.OutboundIPPrefixes != nil {
		var outboundIPPrefixes1 ManagedClusterLoadBalancerProfileOutboundIPPrefixes
		err := outboundIPPrefixes1.PopulateFromARM(owner, *typedInput.OutboundIPPrefixes)
		if err != nil {
			return err
		}
		outboundIPPrefixes := outboundIPPrefixes1
		managedClusterLoadBalancerProfile.OutboundIPPrefixes = &outboundIPPrefixes
	}

	// Set property ‘OutboundIPs’:
	if typedInput.OutboundIPs != nil {
		var outboundIPs1 ManagedClusterLoadBalancerProfileOutboundIPs
		err := outboundIPs1.PopulateFromARM(owner, *typedInput.OutboundIPs)
		if err != nil {
			return err
		}
		outboundIPs := outboundIPs1
		managedClusterLoadBalancerProfile.OutboundIPs = &outboundIPs
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterLoadBalancerProfile populates our ManagedClusterLoadBalancerProfile from the provided source ManagedClusterLoadBalancerProfile
func (managedClusterLoadBalancerProfile *ManagedClusterLoadBalancerProfile) AssignPropertiesFromManagedClusterLoadBalancerProfile(source *v1alpha1api20210501storage.ManagedClusterLoadBalancerProfile) error {

	// AllocatedOutboundPorts
	if source.AllocatedOutboundPorts != nil {
		allocatedOutboundPort := *source.AllocatedOutboundPorts
		managedClusterLoadBalancerProfile.AllocatedOutboundPorts = &allocatedOutboundPort
	} else {
		managedClusterLoadBalancerProfile.AllocatedOutboundPorts = nil
	}

	// EffectiveOutboundIPs
	effectiveOutboundIPList := make([]ResourceReference, len(source.EffectiveOutboundIPs))
	for effectiveOutboundIPIndex, effectiveOutboundIPItem := range source.EffectiveOutboundIPs {
		// Shadow the loop variable to avoid aliasing
		effectiveOutboundIPItem := effectiveOutboundIPItem
		var effectiveOutboundIP ResourceReference
		err := effectiveOutboundIP.AssignPropertiesFromResourceReference(&effectiveOutboundIPItem)
		if err != nil {
			return errors.Wrap(err, "populating EffectiveOutboundIPs from EffectiveOutboundIPs, calling AssignPropertiesFromResourceReference()")
		}
		effectiveOutboundIPList[effectiveOutboundIPIndex] = effectiveOutboundIP
	}
	managedClusterLoadBalancerProfile.EffectiveOutboundIPs = effectiveOutboundIPList

	// IdleTimeoutInMinutes
	if source.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinute := *source.IdleTimeoutInMinutes
		managedClusterLoadBalancerProfile.IdleTimeoutInMinutes = &idleTimeoutInMinute
	} else {
		managedClusterLoadBalancerProfile.IdleTimeoutInMinutes = nil
	}

	// ManagedOutboundIPs
	if source.ManagedOutboundIPs != nil {
		var managedOutboundIP ManagedClusterLoadBalancerProfileManagedOutboundIPs
		err := managedOutboundIP.AssignPropertiesFromManagedClusterLoadBalancerProfileManagedOutboundIPs(source.ManagedOutboundIPs)
		if err != nil {
			return errors.Wrap(err, "populating ManagedOutboundIPs from ManagedOutboundIPs, calling AssignPropertiesFromManagedClusterLoadBalancerProfileManagedOutboundIPs()")
		}
		managedClusterLoadBalancerProfile.ManagedOutboundIPs = &managedOutboundIP
	} else {
		managedClusterLoadBalancerProfile.ManagedOutboundIPs = nil
	}

	// OutboundIPPrefixes
	if source.OutboundIPPrefixes != nil {
		var outboundIPPrefix ManagedClusterLoadBalancerProfileOutboundIPPrefixes
		err := outboundIPPrefix.AssignPropertiesFromManagedClusterLoadBalancerProfileOutboundIPPrefixes(source.OutboundIPPrefixes)
		if err != nil {
			return errors.Wrap(err, "populating OutboundIPPrefixes from OutboundIPPrefixes, calling AssignPropertiesFromManagedClusterLoadBalancerProfileOutboundIPPrefixes()")
		}
		managedClusterLoadBalancerProfile.OutboundIPPrefixes = &outboundIPPrefix
	} else {
		managedClusterLoadBalancerProfile.OutboundIPPrefixes = nil
	}

	// OutboundIPs
	if source.OutboundIPs != nil {
		var outboundIP ManagedClusterLoadBalancerProfileOutboundIPs
		err := outboundIP.AssignPropertiesFromManagedClusterLoadBalancerProfileOutboundIPs(source.OutboundIPs)
		if err != nil {
			return errors.Wrap(err, "populating OutboundIPs from OutboundIPs, calling AssignPropertiesFromManagedClusterLoadBalancerProfileOutboundIPs()")
		}
		managedClusterLoadBalancerProfile.OutboundIPs = &outboundIP
	} else {
		managedClusterLoadBalancerProfile.OutboundIPs = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterLoadBalancerProfile populates the provided destination ManagedClusterLoadBalancerProfile from our ManagedClusterLoadBalancerProfile
func (managedClusterLoadBalancerProfile *ManagedClusterLoadBalancerProfile) AssignPropertiesToManagedClusterLoadBalancerProfile(destination *v1alpha1api20210501storage.ManagedClusterLoadBalancerProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllocatedOutboundPorts
	if managedClusterLoadBalancerProfile.AllocatedOutboundPorts != nil {
		allocatedOutboundPort := *managedClusterLoadBalancerProfile.AllocatedOutboundPorts
		destination.AllocatedOutboundPorts = &allocatedOutboundPort
	} else {
		destination.AllocatedOutboundPorts = nil
	}

	// EffectiveOutboundIPs
	effectiveOutboundIPList := make([]v1alpha1api20210501storage.ResourceReference, len(managedClusterLoadBalancerProfile.EffectiveOutboundIPs))
	for effectiveOutboundIPIndex, effectiveOutboundIPItem := range managedClusterLoadBalancerProfile.EffectiveOutboundIPs {
		// Shadow the loop variable to avoid aliasing
		effectiveOutboundIPItem := effectiveOutboundIPItem
		var effectiveOutboundIP v1alpha1api20210501storage.ResourceReference
		err := effectiveOutboundIPItem.AssignPropertiesToResourceReference(&effectiveOutboundIP)
		if err != nil {
			return errors.Wrap(err, "populating EffectiveOutboundIPs from EffectiveOutboundIPs, calling AssignPropertiesToResourceReference()")
		}
		effectiveOutboundIPList[effectiveOutboundIPIndex] = effectiveOutboundIP
	}
	destination.EffectiveOutboundIPs = effectiveOutboundIPList

	// IdleTimeoutInMinutes
	if managedClusterLoadBalancerProfile.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinute := *managedClusterLoadBalancerProfile.IdleTimeoutInMinutes
		destination.IdleTimeoutInMinutes = &idleTimeoutInMinute
	} else {
		destination.IdleTimeoutInMinutes = nil
	}

	// ManagedOutboundIPs
	if managedClusterLoadBalancerProfile.ManagedOutboundIPs != nil {
		var managedOutboundIP v1alpha1api20210501storage.ManagedClusterLoadBalancerProfileManagedOutboundIPs
		err := (*managedClusterLoadBalancerProfile.ManagedOutboundIPs).AssignPropertiesToManagedClusterLoadBalancerProfileManagedOutboundIPs(&managedOutboundIP)
		if err != nil {
			return errors.Wrap(err, "populating ManagedOutboundIPs from ManagedOutboundIPs, calling AssignPropertiesToManagedClusterLoadBalancerProfileManagedOutboundIPs()")
		}
		destination.ManagedOutboundIPs = &managedOutboundIP
	} else {
		destination.ManagedOutboundIPs = nil
	}

	// OutboundIPPrefixes
	if managedClusterLoadBalancerProfile.OutboundIPPrefixes != nil {
		var outboundIPPrefix v1alpha1api20210501storage.ManagedClusterLoadBalancerProfileOutboundIPPrefixes
		err := (*managedClusterLoadBalancerProfile.OutboundIPPrefixes).AssignPropertiesToManagedClusterLoadBalancerProfileOutboundIPPrefixes(&outboundIPPrefix)
		if err != nil {
			return errors.Wrap(err, "populating OutboundIPPrefixes from OutboundIPPrefixes, calling AssignPropertiesToManagedClusterLoadBalancerProfileOutboundIPPrefixes()")
		}
		destination.OutboundIPPrefixes = &outboundIPPrefix
	} else {
		destination.OutboundIPPrefixes = nil
	}

	// OutboundIPs
	if managedClusterLoadBalancerProfile.OutboundIPs != nil {
		var outboundIP v1alpha1api20210501storage.ManagedClusterLoadBalancerProfileOutboundIPs
		err := (*managedClusterLoadBalancerProfile.OutboundIPs).AssignPropertiesToManagedClusterLoadBalancerProfileOutboundIPs(&outboundIP)
		if err != nil {
			return errors.Wrap(err, "populating OutboundIPs from OutboundIPs, calling AssignPropertiesToManagedClusterLoadBalancerProfileOutboundIPs()")
		}
		destination.OutboundIPs = &outboundIP
	} else {
		destination.OutboundIPs = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type ManagedClusterLoadBalancerProfile_Status struct {
	//AllocatedOutboundPorts: Desired number of allocated SNAT ports per VM. Allowed
	//values must be in the range of 0 to 64000 (inclusive). The default value is 0
	//which results in Azure dynamically allocating ports.
	AllocatedOutboundPorts *int `json:"allocatedOutboundPorts,omitempty"`

	//EffectiveOutboundIPs: The effective outbound IP resources of the cluster load
	//balancer.
	EffectiveOutboundIPs []ResourceReference_Status `json:"effectiveOutboundIPs,omitempty"`

	//IdleTimeoutInMinutes: Desired outbound flow idle timeout in minutes. Allowed
	//values must be in the range of 4 to 120 (inclusive). The default value is 30
	//minutes.
	IdleTimeoutInMinutes *int `json:"idleTimeoutInMinutes,omitempty"`

	//ManagedOutboundIPs: Desired managed outbound IPs for the cluster load balancer.
	ManagedOutboundIPs *ManagedClusterLoadBalancerProfile_Status_ManagedOutboundIPs `json:"managedOutboundIPs,omitempty"`

	//OutboundIPPrefixes: Desired outbound IP Prefix resources for the cluster load
	//balancer.
	OutboundIPPrefixes *ManagedClusterLoadBalancerProfile_Status_OutboundIPPrefixes `json:"outboundIPPrefixes,omitempty"`

	//OutboundIPs: Desired outbound IP resources for the cluster load balancer.
	OutboundIPs *ManagedClusterLoadBalancerProfile_Status_OutboundIPs `json:"outboundIPs,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterLoadBalancerProfile_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (managedClusterLoadBalancerProfileStatus *ManagedClusterLoadBalancerProfile_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterLoadBalancerProfile_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (managedClusterLoadBalancerProfileStatus *ManagedClusterLoadBalancerProfile_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterLoadBalancerProfile_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterLoadBalancerProfile_StatusARM, got %T", armInput)
	}

	// Set property ‘AllocatedOutboundPorts’:
	if typedInput.AllocatedOutboundPorts != nil {
		allocatedOutboundPorts := *typedInput.AllocatedOutboundPorts
		managedClusterLoadBalancerProfileStatus.AllocatedOutboundPorts = &allocatedOutboundPorts
	}

	// Set property ‘EffectiveOutboundIPs’:
	for _, item := range typedInput.EffectiveOutboundIPs {
		var item1 ResourceReference_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		managedClusterLoadBalancerProfileStatus.EffectiveOutboundIPs = append(managedClusterLoadBalancerProfileStatus.EffectiveOutboundIPs, item1)
	}

	// Set property ‘IdleTimeoutInMinutes’:
	if typedInput.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinutes := *typedInput.IdleTimeoutInMinutes
		managedClusterLoadBalancerProfileStatus.IdleTimeoutInMinutes = &idleTimeoutInMinutes
	}

	// Set property ‘ManagedOutboundIPs’:
	if typedInput.ManagedOutboundIPs != nil {
		var managedOutboundIPs1 ManagedClusterLoadBalancerProfile_Status_ManagedOutboundIPs
		err := managedOutboundIPs1.PopulateFromARM(owner, *typedInput.ManagedOutboundIPs)
		if err != nil {
			return err
		}
		managedOutboundIPs := managedOutboundIPs1
		managedClusterLoadBalancerProfileStatus.ManagedOutboundIPs = &managedOutboundIPs
	}

	// Set property ‘OutboundIPPrefixes’:
	if typedInput.OutboundIPPrefixes != nil {
		var outboundIPPrefixes1 ManagedClusterLoadBalancerProfile_Status_OutboundIPPrefixes
		err := outboundIPPrefixes1.PopulateFromARM(owner, *typedInput.OutboundIPPrefixes)
		if err != nil {
			return err
		}
		outboundIPPrefixes := outboundIPPrefixes1
		managedClusterLoadBalancerProfileStatus.OutboundIPPrefixes = &outboundIPPrefixes
	}

	// Set property ‘OutboundIPs’:
	if typedInput.OutboundIPs != nil {
		var outboundIPs1 ManagedClusterLoadBalancerProfile_Status_OutboundIPs
		err := outboundIPs1.PopulateFromARM(owner, *typedInput.OutboundIPs)
		if err != nil {
			return err
		}
		outboundIPs := outboundIPs1
		managedClusterLoadBalancerProfileStatus.OutboundIPs = &outboundIPs
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterLoadBalancerProfileStatus populates our ManagedClusterLoadBalancerProfile_Status from the provided source ManagedClusterLoadBalancerProfile_Status
func (managedClusterLoadBalancerProfileStatus *ManagedClusterLoadBalancerProfile_Status) AssignPropertiesFromManagedClusterLoadBalancerProfileStatus(source *v1alpha1api20210501storage.ManagedClusterLoadBalancerProfile_Status) error {

	// AllocatedOutboundPorts
	if source.AllocatedOutboundPorts != nil {
		allocatedOutboundPort := *source.AllocatedOutboundPorts
		managedClusterLoadBalancerProfileStatus.AllocatedOutboundPorts = &allocatedOutboundPort
	} else {
		managedClusterLoadBalancerProfileStatus.AllocatedOutboundPorts = nil
	}

	// EffectiveOutboundIPs
	effectiveOutboundIPList := make([]ResourceReference_Status, len(source.EffectiveOutboundIPs))
	for effectiveOutboundIPIndex, effectiveOutboundIPItem := range source.EffectiveOutboundIPs {
		// Shadow the loop variable to avoid aliasing
		effectiveOutboundIPItem := effectiveOutboundIPItem
		var effectiveOutboundIP ResourceReference_Status
		err := effectiveOutboundIP.AssignPropertiesFromResourceReferenceStatus(&effectiveOutboundIPItem)
		if err != nil {
			return errors.Wrap(err, "populating EffectiveOutboundIPs from EffectiveOutboundIPs, calling AssignPropertiesFromResourceReferenceStatus()")
		}
		effectiveOutboundIPList[effectiveOutboundIPIndex] = effectiveOutboundIP
	}
	managedClusterLoadBalancerProfileStatus.EffectiveOutboundIPs = effectiveOutboundIPList

	// IdleTimeoutInMinutes
	if source.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinute := *source.IdleTimeoutInMinutes
		managedClusterLoadBalancerProfileStatus.IdleTimeoutInMinutes = &idleTimeoutInMinute
	} else {
		managedClusterLoadBalancerProfileStatus.IdleTimeoutInMinutes = nil
	}

	// ManagedOutboundIPs
	if source.ManagedOutboundIPs != nil {
		var managedOutboundIP ManagedClusterLoadBalancerProfile_Status_ManagedOutboundIPs
		err := managedOutboundIP.AssignPropertiesFromManagedClusterLoadBalancerProfileStatusManagedOutboundIPs(source.ManagedOutboundIPs)
		if err != nil {
			return errors.Wrap(err, "populating ManagedOutboundIPs from ManagedOutboundIPs, calling AssignPropertiesFromManagedClusterLoadBalancerProfileStatusManagedOutboundIPs()")
		}
		managedClusterLoadBalancerProfileStatus.ManagedOutboundIPs = &managedOutboundIP
	} else {
		managedClusterLoadBalancerProfileStatus.ManagedOutboundIPs = nil
	}

	// OutboundIPPrefixes
	if source.OutboundIPPrefixes != nil {
		var outboundIPPrefix ManagedClusterLoadBalancerProfile_Status_OutboundIPPrefixes
		err := outboundIPPrefix.AssignPropertiesFromManagedClusterLoadBalancerProfileStatusOutboundIPPrefixes(source.OutboundIPPrefixes)
		if err != nil {
			return errors.Wrap(err, "populating OutboundIPPrefixes from OutboundIPPrefixes, calling AssignPropertiesFromManagedClusterLoadBalancerProfileStatusOutboundIPPrefixes()")
		}
		managedClusterLoadBalancerProfileStatus.OutboundIPPrefixes = &outboundIPPrefix
	} else {
		managedClusterLoadBalancerProfileStatus.OutboundIPPrefixes = nil
	}

	// OutboundIPs
	if source.OutboundIPs != nil {
		var outboundIP ManagedClusterLoadBalancerProfile_Status_OutboundIPs
		err := outboundIP.AssignPropertiesFromManagedClusterLoadBalancerProfileStatusOutboundIPs(source.OutboundIPs)
		if err != nil {
			return errors.Wrap(err, "populating OutboundIPs from OutboundIPs, calling AssignPropertiesFromManagedClusterLoadBalancerProfileStatusOutboundIPs()")
		}
		managedClusterLoadBalancerProfileStatus.OutboundIPs = &outboundIP
	} else {
		managedClusterLoadBalancerProfileStatus.OutboundIPs = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterLoadBalancerProfileStatus populates the provided destination ManagedClusterLoadBalancerProfile_Status from our ManagedClusterLoadBalancerProfile_Status
func (managedClusterLoadBalancerProfileStatus *ManagedClusterLoadBalancerProfile_Status) AssignPropertiesToManagedClusterLoadBalancerProfileStatus(destination *v1alpha1api20210501storage.ManagedClusterLoadBalancerProfile_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllocatedOutboundPorts
	if managedClusterLoadBalancerProfileStatus.AllocatedOutboundPorts != nil {
		allocatedOutboundPort := *managedClusterLoadBalancerProfileStatus.AllocatedOutboundPorts
		destination.AllocatedOutboundPorts = &allocatedOutboundPort
	} else {
		destination.AllocatedOutboundPorts = nil
	}

	// EffectiveOutboundIPs
	effectiveOutboundIPList := make([]v1alpha1api20210501storage.ResourceReference_Status, len(managedClusterLoadBalancerProfileStatus.EffectiveOutboundIPs))
	for effectiveOutboundIPIndex, effectiveOutboundIPItem := range managedClusterLoadBalancerProfileStatus.EffectiveOutboundIPs {
		// Shadow the loop variable to avoid aliasing
		effectiveOutboundIPItem := effectiveOutboundIPItem
		var effectiveOutboundIP v1alpha1api20210501storage.ResourceReference_Status
		err := effectiveOutboundIPItem.AssignPropertiesToResourceReferenceStatus(&effectiveOutboundIP)
		if err != nil {
			return errors.Wrap(err, "populating EffectiveOutboundIPs from EffectiveOutboundIPs, calling AssignPropertiesToResourceReferenceStatus()")
		}
		effectiveOutboundIPList[effectiveOutboundIPIndex] = effectiveOutboundIP
	}
	destination.EffectiveOutboundIPs = effectiveOutboundIPList

	// IdleTimeoutInMinutes
	if managedClusterLoadBalancerProfileStatus.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinute := *managedClusterLoadBalancerProfileStatus.IdleTimeoutInMinutes
		destination.IdleTimeoutInMinutes = &idleTimeoutInMinute
	} else {
		destination.IdleTimeoutInMinutes = nil
	}

	// ManagedOutboundIPs
	if managedClusterLoadBalancerProfileStatus.ManagedOutboundIPs != nil {
		var managedOutboundIP v1alpha1api20210501storage.ManagedClusterLoadBalancerProfile_Status_ManagedOutboundIPs
		err := (*managedClusterLoadBalancerProfileStatus.ManagedOutboundIPs).AssignPropertiesToManagedClusterLoadBalancerProfileStatusManagedOutboundIPs(&managedOutboundIP)
		if err != nil {
			return errors.Wrap(err, "populating ManagedOutboundIPs from ManagedOutboundIPs, calling AssignPropertiesToManagedClusterLoadBalancerProfileStatusManagedOutboundIPs()")
		}
		destination.ManagedOutboundIPs = &managedOutboundIP
	} else {
		destination.ManagedOutboundIPs = nil
	}

	// OutboundIPPrefixes
	if managedClusterLoadBalancerProfileStatus.OutboundIPPrefixes != nil {
		var outboundIPPrefix v1alpha1api20210501storage.ManagedClusterLoadBalancerProfile_Status_OutboundIPPrefixes
		err := (*managedClusterLoadBalancerProfileStatus.OutboundIPPrefixes).AssignPropertiesToManagedClusterLoadBalancerProfileStatusOutboundIPPrefixes(&outboundIPPrefix)
		if err != nil {
			return errors.Wrap(err, "populating OutboundIPPrefixes from OutboundIPPrefixes, calling AssignPropertiesToManagedClusterLoadBalancerProfileStatusOutboundIPPrefixes()")
		}
		destination.OutboundIPPrefixes = &outboundIPPrefix
	} else {
		destination.OutboundIPPrefixes = nil
	}

	// OutboundIPs
	if managedClusterLoadBalancerProfileStatus.OutboundIPs != nil {
		var outboundIP v1alpha1api20210501storage.ManagedClusterLoadBalancerProfile_Status_OutboundIPs
		err := (*managedClusterLoadBalancerProfileStatus.OutboundIPs).AssignPropertiesToManagedClusterLoadBalancerProfileStatusOutboundIPs(&outboundIP)
		if err != nil {
			return errors.Wrap(err, "populating OutboundIPs from OutboundIPs, calling AssignPropertiesToManagedClusterLoadBalancerProfileStatusOutboundIPs()")
		}
		destination.OutboundIPs = &outboundIP
	} else {
		destination.OutboundIPs = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2021-05-01/Microsoft.ContainerService.json#/definitions/ManagedClusterPodIdentity
type ManagedClusterPodIdentity struct {
	//BindingSelector: The binding selector to use for the AzureIdentityBinding
	//resource.
	BindingSelector *string `json:"bindingSelector,omitempty"`

	// +kubebuilder:validation:Required
	//Identity: Details about a user assigned identity.
	Identity UserAssignedIdentity `json:"identity"`

	// +kubebuilder:validation:Required
	//Name: The name of the pod identity.
	Name string `json:"name"`

	// +kubebuilder:validation:Required
	//Namespace: The namespace of the pod identity.
	Namespace string `json:"namespace"`
}

var _ genruntime.ARMTransformer = &ManagedClusterPodIdentity{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (managedClusterPodIdentity *ManagedClusterPodIdentity) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if managedClusterPodIdentity == nil {
		return nil, nil
	}
	var result ManagedClusterPodIdentityARM

	// Set property ‘BindingSelector’:
	if managedClusterPodIdentity.BindingSelector != nil {
		bindingSelector := *managedClusterPodIdentity.BindingSelector
		result.BindingSelector = &bindingSelector
	}

	// Set property ‘Identity’:
	identityARM, err := managedClusterPodIdentity.Identity.ConvertToARM(resolved)
	if err != nil {
		return nil, err
	}
	result.Identity = identityARM.(UserAssignedIdentityARM)

	// Set property ‘Name’:
	result.Name = managedClusterPodIdentity.Name

	// Set property ‘Namespace’:
	result.Namespace = managedClusterPodIdentity.Namespace
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (managedClusterPodIdentity *ManagedClusterPodIdentity) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterPodIdentityARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (managedClusterPodIdentity *ManagedClusterPodIdentity) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterPodIdentityARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterPodIdentityARM, got %T", armInput)
	}

	// Set property ‘BindingSelector’:
	if typedInput.BindingSelector != nil {
		bindingSelector := *typedInput.BindingSelector
		managedClusterPodIdentity.BindingSelector = &bindingSelector
	}

	// Set property ‘Identity’:
	var identity UserAssignedIdentity
	err := identity.PopulateFromARM(owner, typedInput.Identity)
	if err != nil {
		return err
	}
	managedClusterPodIdentity.Identity = identity

	// Set property ‘Name’:
	managedClusterPodIdentity.Name = typedInput.Name

	// Set property ‘Namespace’:
	managedClusterPodIdentity.Namespace = typedInput.Namespace

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterPodIdentity populates our ManagedClusterPodIdentity from the provided source ManagedClusterPodIdentity
func (managedClusterPodIdentity *ManagedClusterPodIdentity) AssignPropertiesFromManagedClusterPodIdentity(source *v1alpha1api20210501storage.ManagedClusterPodIdentity) error {

	// BindingSelector
	if source.BindingSelector != nil {
		bindingSelector := *source.BindingSelector
		managedClusterPodIdentity.BindingSelector = &bindingSelector
	} else {
		managedClusterPodIdentity.BindingSelector = nil
	}

	// Identity
	if source.Identity != nil {
		var identity UserAssignedIdentity
		err := identity.AssignPropertiesFromUserAssignedIdentity(source.Identity)
		if err != nil {
			return errors.Wrap(err, "populating Identity from Identity, calling AssignPropertiesFromUserAssignedIdentity()")
		}
		managedClusterPodIdentity.Identity = identity
	} else {
		managedClusterPodIdentity.Identity = UserAssignedIdentity{}
	}

	// Name
	if source.Name != nil {
		managedClusterPodIdentity.Name = *source.Name
	} else {
		managedClusterPodIdentity.Name = ""
	}

	// Namespace
	if source.Namespace != nil {
		managedClusterPodIdentity.Namespace = *source.Namespace
	} else {
		managedClusterPodIdentity.Namespace = ""
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterPodIdentity populates the provided destination ManagedClusterPodIdentity from our ManagedClusterPodIdentity
func (managedClusterPodIdentity *ManagedClusterPodIdentity) AssignPropertiesToManagedClusterPodIdentity(destination *v1alpha1api20210501storage.ManagedClusterPodIdentity) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BindingSelector
	if managedClusterPodIdentity.BindingSelector != nil {
		bindingSelector := *managedClusterPodIdentity.BindingSelector
		destination.BindingSelector = &bindingSelector
	} else {
		destination.BindingSelector = nil
	}

	// Identity
	var identity v1alpha1api20210501storage.UserAssignedIdentity
	err := managedClusterPodIdentity.Identity.AssignPropertiesToUserAssignedIdentity(&identity)
	if err != nil {
		return errors.Wrap(err, "populating Identity from Identity, calling AssignPropertiesToUserAssignedIdentity()")
	}
	destination.Identity = &identity

	// Name
	name := managedClusterPodIdentity.Name
	destination.Name = &name

	// Namespace
	namespace := managedClusterPodIdentity.Namespace
	destination.Namespace = &namespace

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2021-05-01/Microsoft.ContainerService.json#/definitions/ManagedClusterPodIdentityException
type ManagedClusterPodIdentityException struct {
	// +kubebuilder:validation:Required
	//Name: The name of the pod identity exception.
	Name string `json:"name"`

	// +kubebuilder:validation:Required
	//Namespace: The namespace of the pod identity exception.
	Namespace string `json:"namespace"`

	// +kubebuilder:validation:Required
	//PodLabels: The pod labels to match.
	PodLabels map[string]string `json:"podLabels"`
}

var _ genruntime.ARMTransformer = &ManagedClusterPodIdentityException{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (managedClusterPodIdentityException *ManagedClusterPodIdentityException) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if managedClusterPodIdentityException == nil {
		return nil, nil
	}
	var result ManagedClusterPodIdentityExceptionARM

	// Set property ‘Name’:
	result.Name = managedClusterPodIdentityException.Name

	// Set property ‘Namespace’:
	result.Namespace = managedClusterPodIdentityException.Namespace

	// Set property ‘PodLabels’:
	if managedClusterPodIdentityException.PodLabels != nil {
		result.PodLabels = make(map[string]string)
		for key, value := range managedClusterPodIdentityException.PodLabels {
			result.PodLabels[key] = value
		}
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (managedClusterPodIdentityException *ManagedClusterPodIdentityException) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterPodIdentityExceptionARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (managedClusterPodIdentityException *ManagedClusterPodIdentityException) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterPodIdentityExceptionARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterPodIdentityExceptionARM, got %T", armInput)
	}

	// Set property ‘Name’:
	managedClusterPodIdentityException.Name = typedInput.Name

	// Set property ‘Namespace’:
	managedClusterPodIdentityException.Namespace = typedInput.Namespace

	// Set property ‘PodLabels’:
	if typedInput.PodLabels != nil {
		managedClusterPodIdentityException.PodLabels = make(map[string]string)
		for key, value := range typedInput.PodLabels {
			managedClusterPodIdentityException.PodLabels[key] = value
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterPodIdentityException populates our ManagedClusterPodIdentityException from the provided source ManagedClusterPodIdentityException
func (managedClusterPodIdentityException *ManagedClusterPodIdentityException) AssignPropertiesFromManagedClusterPodIdentityException(source *v1alpha1api20210501storage.ManagedClusterPodIdentityException) error {

	// Name
	if source.Name != nil {
		managedClusterPodIdentityException.Name = *source.Name
	} else {
		managedClusterPodIdentityException.Name = ""
	}

	// Namespace
	if source.Namespace != nil {
		managedClusterPodIdentityException.Namespace = *source.Namespace
	} else {
		managedClusterPodIdentityException.Namespace = ""
	}

	// PodLabels
	podLabelMap := make(map[string]string)
	for podLabelKey, podLabelValue := range source.PodLabels {
		// Shadow the loop variable to avoid aliasing
		podLabelValue := podLabelValue
		podLabelMap[podLabelKey] = podLabelValue
	}
	managedClusterPodIdentityException.PodLabels = podLabelMap

	// No error
	return nil
}

// AssignPropertiesToManagedClusterPodIdentityException populates the provided destination ManagedClusterPodIdentityException from our ManagedClusterPodIdentityException
func (managedClusterPodIdentityException *ManagedClusterPodIdentityException) AssignPropertiesToManagedClusterPodIdentityException(destination *v1alpha1api20210501storage.ManagedClusterPodIdentityException) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	name := managedClusterPodIdentityException.Name
	destination.Name = &name

	// Namespace
	namespace := managedClusterPodIdentityException.Namespace
	destination.Namespace = &namespace

	// PodLabels
	podLabelMap := make(map[string]string)
	for podLabelKey, podLabelValue := range managedClusterPodIdentityException.PodLabels {
		// Shadow the loop variable to avoid aliasing
		podLabelValue := podLabelValue
		podLabelMap[podLabelKey] = podLabelValue
	}
	destination.PodLabels = podLabelMap

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type ManagedClusterPodIdentityException_Status struct {
	// +kubebuilder:validation:Required
	//Name: Name of the pod identity exception.
	Name string `json:"name"`

	// +kubebuilder:validation:Required
	//Namespace: Namespace of the pod identity exception.
	Namespace string `json:"namespace"`

	// +kubebuilder:validation:Required
	//PodLabels: Pod labels to match.
	PodLabels map[string]string `json:"podLabels"`
}

var _ genruntime.FromARMConverter = &ManagedClusterPodIdentityException_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (managedClusterPodIdentityExceptionStatus *ManagedClusterPodIdentityException_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterPodIdentityException_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (managedClusterPodIdentityExceptionStatus *ManagedClusterPodIdentityException_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterPodIdentityException_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterPodIdentityException_StatusARM, got %T", armInput)
	}

	// Set property ‘Name’:
	managedClusterPodIdentityExceptionStatus.Name = typedInput.Name

	// Set property ‘Namespace’:
	managedClusterPodIdentityExceptionStatus.Namespace = typedInput.Namespace

	// Set property ‘PodLabels’:
	if typedInput.PodLabels != nil {
		managedClusterPodIdentityExceptionStatus.PodLabels = make(map[string]string)
		for key, value := range typedInput.PodLabels {
			managedClusterPodIdentityExceptionStatus.PodLabels[key] = value
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterPodIdentityExceptionStatus populates our ManagedClusterPodIdentityException_Status from the provided source ManagedClusterPodIdentityException_Status
func (managedClusterPodIdentityExceptionStatus *ManagedClusterPodIdentityException_Status) AssignPropertiesFromManagedClusterPodIdentityExceptionStatus(source *v1alpha1api20210501storage.ManagedClusterPodIdentityException_Status) error {

	// Name
	if source.Name != nil {
		managedClusterPodIdentityExceptionStatus.Name = *source.Name
	} else {
		managedClusterPodIdentityExceptionStatus.Name = ""
	}

	// Namespace
	if source.Namespace != nil {
		managedClusterPodIdentityExceptionStatus.Namespace = *source.Namespace
	} else {
		managedClusterPodIdentityExceptionStatus.Namespace = ""
	}

	// PodLabels
	podLabelMap := make(map[string]string)
	for podLabelKey, podLabelValue := range source.PodLabels {
		// Shadow the loop variable to avoid aliasing
		podLabelValue := podLabelValue
		podLabelMap[podLabelKey] = podLabelValue
	}
	managedClusterPodIdentityExceptionStatus.PodLabels = podLabelMap

	// No error
	return nil
}

// AssignPropertiesToManagedClusterPodIdentityExceptionStatus populates the provided destination ManagedClusterPodIdentityException_Status from our ManagedClusterPodIdentityException_Status
func (managedClusterPodIdentityExceptionStatus *ManagedClusterPodIdentityException_Status) AssignPropertiesToManagedClusterPodIdentityExceptionStatus(destination *v1alpha1api20210501storage.ManagedClusterPodIdentityException_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	name := managedClusterPodIdentityExceptionStatus.Name
	destination.Name = &name

	// Namespace
	namespace := managedClusterPodIdentityExceptionStatus.Namespace
	destination.Namespace = &namespace

	// PodLabels
	podLabelMap := make(map[string]string)
	for podLabelKey, podLabelValue := range managedClusterPodIdentityExceptionStatus.PodLabels {
		// Shadow the loop variable to avoid aliasing
		podLabelValue := podLabelValue
		podLabelMap[podLabelKey] = podLabelValue
	}
	destination.PodLabels = podLabelMap

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type ManagedClusterPodIdentity_Status struct {
	//BindingSelector: Binding selector to use for the AzureIdentityBinding resource.
	BindingSelector *string `json:"bindingSelector,omitempty"`

	// +kubebuilder:validation:Required
	//Identity: Information of the user assigned identity.
	Identity UserAssignedIdentity_Status `json:"identity"`

	// +kubebuilder:validation:Required
	//Name: Name of the pod identity.
	Name string `json:"name"`

	// +kubebuilder:validation:Required
	//Namespace: Namespace of the pod identity.
	Namespace        string                                             `json:"namespace"`
	ProvisioningInfo *ManagedClusterPodIdentity_Status_ProvisioningInfo `json:"provisioningInfo,omitempty"`

	//ProvisioningState: The current provisioning state of the pod identity.
	ProvisioningState *ManagedClusterPodIdentityStatusProvisioningState `json:"provisioningState,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterPodIdentity_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (managedClusterPodIdentityStatus *ManagedClusterPodIdentity_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterPodIdentity_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (managedClusterPodIdentityStatus *ManagedClusterPodIdentity_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterPodIdentity_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterPodIdentity_StatusARM, got %T", armInput)
	}

	// Set property ‘BindingSelector’:
	if typedInput.BindingSelector != nil {
		bindingSelector := *typedInput.BindingSelector
		managedClusterPodIdentityStatus.BindingSelector = &bindingSelector
	}

	// Set property ‘Identity’:
	var identity UserAssignedIdentity_Status
	err := identity.PopulateFromARM(owner, typedInput.Identity)
	if err != nil {
		return err
	}
	managedClusterPodIdentityStatus.Identity = identity

	// Set property ‘Name’:
	managedClusterPodIdentityStatus.Name = typedInput.Name

	// Set property ‘Namespace’:
	managedClusterPodIdentityStatus.Namespace = typedInput.Namespace

	// Set property ‘ProvisioningInfo’:
	if typedInput.ProvisioningInfo != nil {
		var provisioningInfo1 ManagedClusterPodIdentity_Status_ProvisioningInfo
		err = provisioningInfo1.PopulateFromARM(owner, *typedInput.ProvisioningInfo)
		if err != nil {
			return err
		}
		provisioningInfo := provisioningInfo1
		managedClusterPodIdentityStatus.ProvisioningInfo = &provisioningInfo
	}

	// Set property ‘ProvisioningState’:
	if typedInput.ProvisioningState != nil {
		provisioningState := *typedInput.ProvisioningState
		managedClusterPodIdentityStatus.ProvisioningState = &provisioningState
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterPodIdentityStatus populates our ManagedClusterPodIdentity_Status from the provided source ManagedClusterPodIdentity_Status
func (managedClusterPodIdentityStatus *ManagedClusterPodIdentity_Status) AssignPropertiesFromManagedClusterPodIdentityStatus(source *v1alpha1api20210501storage.ManagedClusterPodIdentity_Status) error {

	// BindingSelector
	if source.BindingSelector != nil {
		bindingSelector := *source.BindingSelector
		managedClusterPodIdentityStatus.BindingSelector = &bindingSelector
	} else {
		managedClusterPodIdentityStatus.BindingSelector = nil
	}

	// Identity
	if source.Identity != nil {
		var identity UserAssignedIdentity_Status
		err := identity.AssignPropertiesFromUserAssignedIdentityStatus(source.Identity)
		if err != nil {
			return errors.Wrap(err, "populating Identity from Identity, calling AssignPropertiesFromUserAssignedIdentityStatus()")
		}
		managedClusterPodIdentityStatus.Identity = identity
	} else {
		managedClusterPodIdentityStatus.Identity = UserAssignedIdentity_Status{}
	}

	// Name
	if source.Name != nil {
		managedClusterPodIdentityStatus.Name = *source.Name
	} else {
		managedClusterPodIdentityStatus.Name = ""
	}

	// Namespace
	if source.Namespace != nil {
		managedClusterPodIdentityStatus.Namespace = *source.Namespace
	} else {
		managedClusterPodIdentityStatus.Namespace = ""
	}

	// ProvisioningInfo
	if source.ProvisioningInfo != nil {
		var provisioningInfo ManagedClusterPodIdentity_Status_ProvisioningInfo
		err := provisioningInfo.AssignPropertiesFromManagedClusterPodIdentityStatusProvisioningInfo(source.ProvisioningInfo)
		if err != nil {
			return errors.Wrap(err, "populating ProvisioningInfo from ProvisioningInfo, calling AssignPropertiesFromManagedClusterPodIdentityStatusProvisioningInfo()")
		}
		managedClusterPodIdentityStatus.ProvisioningInfo = &provisioningInfo
	} else {
		managedClusterPodIdentityStatus.ProvisioningInfo = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ManagedClusterPodIdentityStatusProvisioningState(*source.ProvisioningState)
		managedClusterPodIdentityStatus.ProvisioningState = &provisioningState
	} else {
		managedClusterPodIdentityStatus.ProvisioningState = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterPodIdentityStatus populates the provided destination ManagedClusterPodIdentity_Status from our ManagedClusterPodIdentity_Status
func (managedClusterPodIdentityStatus *ManagedClusterPodIdentity_Status) AssignPropertiesToManagedClusterPodIdentityStatus(destination *v1alpha1api20210501storage.ManagedClusterPodIdentity_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BindingSelector
	if managedClusterPodIdentityStatus.BindingSelector != nil {
		bindingSelector := *managedClusterPodIdentityStatus.BindingSelector
		destination.BindingSelector = &bindingSelector
	} else {
		destination.BindingSelector = nil
	}

	// Identity
	var identity v1alpha1api20210501storage.UserAssignedIdentity_Status
	err := managedClusterPodIdentityStatus.Identity.AssignPropertiesToUserAssignedIdentityStatus(&identity)
	if err != nil {
		return errors.Wrap(err, "populating Identity from Identity, calling AssignPropertiesToUserAssignedIdentityStatus()")
	}
	destination.Identity = &identity

	// Name
	name := managedClusterPodIdentityStatus.Name
	destination.Name = &name

	// Namespace
	namespace := managedClusterPodIdentityStatus.Namespace
	destination.Namespace = &namespace

	// ProvisioningInfo
	if managedClusterPodIdentityStatus.ProvisioningInfo != nil {
		var provisioningInfo v1alpha1api20210501storage.ManagedClusterPodIdentity_Status_ProvisioningInfo
		err = (*managedClusterPodIdentityStatus.ProvisioningInfo).AssignPropertiesToManagedClusterPodIdentityStatusProvisioningInfo(&provisioningInfo)
		if err != nil {
			return errors.Wrap(err, "populating ProvisioningInfo from ProvisioningInfo, calling AssignPropertiesToManagedClusterPodIdentityStatusProvisioningInfo()")
		}
		destination.ProvisioningInfo = &provisioningInfo
	} else {
		destination.ProvisioningInfo = nil
	}

	// ProvisioningState
	if managedClusterPodIdentityStatus.ProvisioningState != nil {
		provisioningState := string(*managedClusterPodIdentityStatus.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"least-waste","most-pods","priority","random"}
type ManagedClusterPropertiesAutoScalerProfileExpander string

const (
	ManagedClusterPropertiesAutoScalerProfileExpanderLeastWaste = ManagedClusterPropertiesAutoScalerProfileExpander("least-waste")
	ManagedClusterPropertiesAutoScalerProfileExpanderMostPods   = ManagedClusterPropertiesAutoScalerProfileExpander("most-pods")
	ManagedClusterPropertiesAutoScalerProfileExpanderPriority   = ManagedClusterPropertiesAutoScalerProfileExpander("priority")
	ManagedClusterPropertiesAutoScalerProfileExpanderRandom     = ManagedClusterPropertiesAutoScalerProfileExpander("random")
)

type ManagedClusterPropertiesStatusAutoScalerProfileExpander string

const (
	ManagedClusterPropertiesStatusAutoScalerProfileExpanderLeastWaste = ManagedClusterPropertiesStatusAutoScalerProfileExpander("least-waste")
	ManagedClusterPropertiesStatusAutoScalerProfileExpanderMostPods   = ManagedClusterPropertiesStatusAutoScalerProfileExpander("most-pods")
	ManagedClusterPropertiesStatusAutoScalerProfileExpanderPriority   = ManagedClusterPropertiesStatusAutoScalerProfileExpander("priority")
	ManagedClusterPropertiesStatusAutoScalerProfileExpanderRandom     = ManagedClusterPropertiesStatusAutoScalerProfileExpander("random")
)

// +kubebuilder:validation:Enum={"None","Windows_Server"}
type ManagedClusterWindowsProfileLicenseType string

const (
	ManagedClusterWindowsProfileLicenseTypeNone          = ManagedClusterWindowsProfileLicenseType("None")
	ManagedClusterWindowsProfileLicenseTypeWindowsServer = ManagedClusterWindowsProfileLicenseType("Windows_Server")
)

type ManagedClusterWindowsProfileStatusLicenseType string

const (
	ManagedClusterWindowsProfileStatusLicenseTypeNone          = ManagedClusterWindowsProfileStatusLicenseType("None")
	ManagedClusterWindowsProfileStatusLicenseTypeWindowsServer = ManagedClusterWindowsProfileStatusLicenseType("Windows_Server")
)

//Generated from: https://schema.management.azure.com/schemas/2021-05-01/Microsoft.ContainerService.json#/definitions/ContainerServiceSshPublicKey
type ContainerServiceSshPublicKey struct {
	// +kubebuilder:validation:Required
	//KeyData: Certificate public key used to authenticate with VMs through SSH. The
	//certificate must be in PEM format with or without headers.
	KeyData string `json:"keyData"`
}

var _ genruntime.ARMTransformer = &ContainerServiceSshPublicKey{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (containerServiceSshPublicKey *ContainerServiceSshPublicKey) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if containerServiceSshPublicKey == nil {
		return nil, nil
	}
	var result ContainerServiceSshPublicKeyARM

	// Set property ‘KeyData’:
	result.KeyData = containerServiceSshPublicKey.KeyData
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (containerServiceSshPublicKey *ContainerServiceSshPublicKey) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerServiceSshPublicKeyARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (containerServiceSshPublicKey *ContainerServiceSshPublicKey) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerServiceSshPublicKeyARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerServiceSshPublicKeyARM, got %T", armInput)
	}

	// Set property ‘KeyData’:
	containerServiceSshPublicKey.KeyData = typedInput.KeyData

	// No error
	return nil
}

// AssignPropertiesFromContainerServiceSshPublicKey populates our ContainerServiceSshPublicKey from the provided source ContainerServiceSshPublicKey
func (containerServiceSshPublicKey *ContainerServiceSshPublicKey) AssignPropertiesFromContainerServiceSshPublicKey(source *v1alpha1api20210501storage.ContainerServiceSshPublicKey) error {

	// KeyData
	if source.KeyData != nil {
		containerServiceSshPublicKey.KeyData = *source.KeyData
	} else {
		containerServiceSshPublicKey.KeyData = ""
	}

	// No error
	return nil
}

// AssignPropertiesToContainerServiceSshPublicKey populates the provided destination ContainerServiceSshPublicKey from our ContainerServiceSshPublicKey
func (containerServiceSshPublicKey *ContainerServiceSshPublicKey) AssignPropertiesToContainerServiceSshPublicKey(destination *v1alpha1api20210501storage.ContainerServiceSshPublicKey) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyData
	keyDatum := containerServiceSshPublicKey.KeyData
	destination.KeyData = &keyDatum

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type ContainerServiceSshPublicKey_Status struct {
	// +kubebuilder:validation:Required
	//KeyData: Certificate public key used to authenticate with VMs through SSH. The
	//certificate must be in PEM format with or without headers.
	KeyData string `json:"keyData"`
}

var _ genruntime.FromARMConverter = &ContainerServiceSshPublicKey_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (containerServiceSshPublicKeyStatus *ContainerServiceSshPublicKey_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerServiceSshPublicKey_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (containerServiceSshPublicKeyStatus *ContainerServiceSshPublicKey_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerServiceSshPublicKey_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerServiceSshPublicKey_StatusARM, got %T", armInput)
	}

	// Set property ‘KeyData’:
	containerServiceSshPublicKeyStatus.KeyData = typedInput.KeyData

	// No error
	return nil
}

// AssignPropertiesFromContainerServiceSshPublicKeyStatus populates our ContainerServiceSshPublicKey_Status from the provided source ContainerServiceSshPublicKey_Status
func (containerServiceSshPublicKeyStatus *ContainerServiceSshPublicKey_Status) AssignPropertiesFromContainerServiceSshPublicKeyStatus(source *v1alpha1api20210501storage.ContainerServiceSshPublicKey_Status) error {

	// KeyData
	if source.KeyData != nil {
		containerServiceSshPublicKeyStatus.KeyData = *source.KeyData
	} else {
		containerServiceSshPublicKeyStatus.KeyData = ""
	}

	// No error
	return nil
}

// AssignPropertiesToContainerServiceSshPublicKeyStatus populates the provided destination ContainerServiceSshPublicKey_Status from our ContainerServiceSshPublicKey_Status
func (containerServiceSshPublicKeyStatus *ContainerServiceSshPublicKey_Status) AssignPropertiesToContainerServiceSshPublicKeyStatus(destination *v1alpha1api20210501storage.ContainerServiceSshPublicKey_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyData
	keyDatum := containerServiceSshPublicKeyStatus.KeyData
	destination.KeyData = &keyDatum

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2021-05-01/Microsoft.ContainerService.json#/definitions/ManagedClusterLoadBalancerProfileManagedOutboundIPs
type ManagedClusterLoadBalancerProfileManagedOutboundIPs struct {
	// +kubebuilder:validation:Maximum=100
	// +kubebuilder:validation:Minimum=1
	//Count: The desired number of outbound IPs created/managed by Azure for the
	//cluster load balancer. Allowed values must be in the range of 1 to 100
	//(inclusive). The default value is 1.
	Count *int `json:"count,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterLoadBalancerProfileManagedOutboundIPs{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (managedClusterLoadBalancerProfileManagedOutboundIPs *ManagedClusterLoadBalancerProfileManagedOutboundIPs) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if managedClusterLoadBalancerProfileManagedOutboundIPs == nil {
		return nil, nil
	}
	var result ManagedClusterLoadBalancerProfileManagedOutboundIPsARM

	// Set property ‘Count’:
	if managedClusterLoadBalancerProfileManagedOutboundIPs.Count != nil {
		count := *managedClusterLoadBalancerProfileManagedOutboundIPs.Count
		result.Count = &count
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (managedClusterLoadBalancerProfileManagedOutboundIPs *ManagedClusterLoadBalancerProfileManagedOutboundIPs) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterLoadBalancerProfileManagedOutboundIPsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (managedClusterLoadBalancerProfileManagedOutboundIPs *ManagedClusterLoadBalancerProfileManagedOutboundIPs) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterLoadBalancerProfileManagedOutboundIPsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterLoadBalancerProfileManagedOutboundIPsARM, got %T", armInput)
	}

	// Set property ‘Count’:
	if typedInput.Count != nil {
		count := *typedInput.Count
		managedClusterLoadBalancerProfileManagedOutboundIPs.Count = &count
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterLoadBalancerProfileManagedOutboundIPs populates our ManagedClusterLoadBalancerProfileManagedOutboundIPs from the provided source ManagedClusterLoadBalancerProfileManagedOutboundIPs
func (managedClusterLoadBalancerProfileManagedOutboundIPs *ManagedClusterLoadBalancerProfileManagedOutboundIPs) AssignPropertiesFromManagedClusterLoadBalancerProfileManagedOutboundIPs(source *v1alpha1api20210501storage.ManagedClusterLoadBalancerProfileManagedOutboundIPs) error {

	// Count
	if source.Count != nil {
		count := *source.Count
		managedClusterLoadBalancerProfileManagedOutboundIPs.Count = &count
	} else {
		managedClusterLoadBalancerProfileManagedOutboundIPs.Count = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterLoadBalancerProfileManagedOutboundIPs populates the provided destination ManagedClusterLoadBalancerProfileManagedOutboundIPs from our ManagedClusterLoadBalancerProfileManagedOutboundIPs
func (managedClusterLoadBalancerProfileManagedOutboundIPs *ManagedClusterLoadBalancerProfileManagedOutboundIPs) AssignPropertiesToManagedClusterLoadBalancerProfileManagedOutboundIPs(destination *v1alpha1api20210501storage.ManagedClusterLoadBalancerProfileManagedOutboundIPs) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Count
	if managedClusterLoadBalancerProfileManagedOutboundIPs.Count != nil {
		count := *managedClusterLoadBalancerProfileManagedOutboundIPs.Count
		destination.Count = &count
	} else {
		destination.Count = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2021-05-01/Microsoft.ContainerService.json#/definitions/ManagedClusterLoadBalancerProfileOutboundIPPrefixes
type ManagedClusterLoadBalancerProfileOutboundIPPrefixes struct {
	//PublicIPPrefixes: A list of public IP prefix resources.
	PublicIPPrefixes []ResourceReference `json:"publicIPPrefixes,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterLoadBalancerProfileOutboundIPPrefixes{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (managedClusterLoadBalancerProfileOutboundIPPrefixes *ManagedClusterLoadBalancerProfileOutboundIPPrefixes) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if managedClusterLoadBalancerProfileOutboundIPPrefixes == nil {
		return nil, nil
	}
	var result ManagedClusterLoadBalancerProfileOutboundIPPrefixesARM

	// Set property ‘PublicIPPrefixes’:
	for _, item := range managedClusterLoadBalancerProfileOutboundIPPrefixes.PublicIPPrefixes {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.PublicIPPrefixes = append(result.PublicIPPrefixes, itemARM.(ResourceReferenceARM))
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (managedClusterLoadBalancerProfileOutboundIPPrefixes *ManagedClusterLoadBalancerProfileOutboundIPPrefixes) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterLoadBalancerProfileOutboundIPPrefixesARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (managedClusterLoadBalancerProfileOutboundIPPrefixes *ManagedClusterLoadBalancerProfileOutboundIPPrefixes) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterLoadBalancerProfileOutboundIPPrefixesARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterLoadBalancerProfileOutboundIPPrefixesARM, got %T", armInput)
	}

	// Set property ‘PublicIPPrefixes’:
	for _, item := range typedInput.PublicIPPrefixes {
		var item1 ResourceReference
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		managedClusterLoadBalancerProfileOutboundIPPrefixes.PublicIPPrefixes = append(managedClusterLoadBalancerProfileOutboundIPPrefixes.PublicIPPrefixes, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterLoadBalancerProfileOutboundIPPrefixes populates our ManagedClusterLoadBalancerProfileOutboundIPPrefixes from the provided source ManagedClusterLoadBalancerProfileOutboundIPPrefixes
func (managedClusterLoadBalancerProfileOutboundIPPrefixes *ManagedClusterLoadBalancerProfileOutboundIPPrefixes) AssignPropertiesFromManagedClusterLoadBalancerProfileOutboundIPPrefixes(source *v1alpha1api20210501storage.ManagedClusterLoadBalancerProfileOutboundIPPrefixes) error {

	// PublicIPPrefixes
	publicIPPrefixList := make([]ResourceReference, len(source.PublicIPPrefixes))
	for publicIPPrefixIndex, publicIPPrefixItem := range source.PublicIPPrefixes {
		// Shadow the loop variable to avoid aliasing
		publicIPPrefixItem := publicIPPrefixItem
		var publicIPPrefix ResourceReference
		err := publicIPPrefix.AssignPropertiesFromResourceReference(&publicIPPrefixItem)
		if err != nil {
			return errors.Wrap(err, "populating PublicIPPrefixes from PublicIPPrefixes, calling AssignPropertiesFromResourceReference()")
		}
		publicIPPrefixList[publicIPPrefixIndex] = publicIPPrefix
	}
	managedClusterLoadBalancerProfileOutboundIPPrefixes.PublicIPPrefixes = publicIPPrefixList

	// No error
	return nil
}

// AssignPropertiesToManagedClusterLoadBalancerProfileOutboundIPPrefixes populates the provided destination ManagedClusterLoadBalancerProfileOutboundIPPrefixes from our ManagedClusterLoadBalancerProfileOutboundIPPrefixes
func (managedClusterLoadBalancerProfileOutboundIPPrefixes *ManagedClusterLoadBalancerProfileOutboundIPPrefixes) AssignPropertiesToManagedClusterLoadBalancerProfileOutboundIPPrefixes(destination *v1alpha1api20210501storage.ManagedClusterLoadBalancerProfileOutboundIPPrefixes) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PublicIPPrefixes
	publicIPPrefixList := make([]v1alpha1api20210501storage.ResourceReference, len(managedClusterLoadBalancerProfileOutboundIPPrefixes.PublicIPPrefixes))
	for publicIPPrefixIndex, publicIPPrefixItem := range managedClusterLoadBalancerProfileOutboundIPPrefixes.PublicIPPrefixes {
		// Shadow the loop variable to avoid aliasing
		publicIPPrefixItem := publicIPPrefixItem
		var publicIPPrefix v1alpha1api20210501storage.ResourceReference
		err := publicIPPrefixItem.AssignPropertiesToResourceReference(&publicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "populating PublicIPPrefixes from PublicIPPrefixes, calling AssignPropertiesToResourceReference()")
		}
		publicIPPrefixList[publicIPPrefixIndex] = publicIPPrefix
	}
	destination.PublicIPPrefixes = publicIPPrefixList

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2021-05-01/Microsoft.ContainerService.json#/definitions/ManagedClusterLoadBalancerProfileOutboundIPs
type ManagedClusterLoadBalancerProfileOutboundIPs struct {
	//PublicIPs: A list of public IP resources.
	PublicIPs []ResourceReference `json:"publicIPs,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedClusterLoadBalancerProfileOutboundIPs{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (managedClusterLoadBalancerProfileOutboundIPs *ManagedClusterLoadBalancerProfileOutboundIPs) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if managedClusterLoadBalancerProfileOutboundIPs == nil {
		return nil, nil
	}
	var result ManagedClusterLoadBalancerProfileOutboundIPsARM

	// Set property ‘PublicIPs’:
	for _, item := range managedClusterLoadBalancerProfileOutboundIPs.PublicIPs {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.PublicIPs = append(result.PublicIPs, itemARM.(ResourceReferenceARM))
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (managedClusterLoadBalancerProfileOutboundIPs *ManagedClusterLoadBalancerProfileOutboundIPs) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterLoadBalancerProfileOutboundIPsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (managedClusterLoadBalancerProfileOutboundIPs *ManagedClusterLoadBalancerProfileOutboundIPs) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterLoadBalancerProfileOutboundIPsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterLoadBalancerProfileOutboundIPsARM, got %T", armInput)
	}

	// Set property ‘PublicIPs’:
	for _, item := range typedInput.PublicIPs {
		var item1 ResourceReference
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		managedClusterLoadBalancerProfileOutboundIPs.PublicIPs = append(managedClusterLoadBalancerProfileOutboundIPs.PublicIPs, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterLoadBalancerProfileOutboundIPs populates our ManagedClusterLoadBalancerProfileOutboundIPs from the provided source ManagedClusterLoadBalancerProfileOutboundIPs
func (managedClusterLoadBalancerProfileOutboundIPs *ManagedClusterLoadBalancerProfileOutboundIPs) AssignPropertiesFromManagedClusterLoadBalancerProfileOutboundIPs(source *v1alpha1api20210501storage.ManagedClusterLoadBalancerProfileOutboundIPs) error {

	// PublicIPs
	publicIPList := make([]ResourceReference, len(source.PublicIPs))
	for publicIPIndex, publicIPItem := range source.PublicIPs {
		// Shadow the loop variable to avoid aliasing
		publicIPItem := publicIPItem
		var publicIP ResourceReference
		err := publicIP.AssignPropertiesFromResourceReference(&publicIPItem)
		if err != nil {
			return errors.Wrap(err, "populating PublicIPs from PublicIPs, calling AssignPropertiesFromResourceReference()")
		}
		publicIPList[publicIPIndex] = publicIP
	}
	managedClusterLoadBalancerProfileOutboundIPs.PublicIPs = publicIPList

	// No error
	return nil
}

// AssignPropertiesToManagedClusterLoadBalancerProfileOutboundIPs populates the provided destination ManagedClusterLoadBalancerProfileOutboundIPs from our ManagedClusterLoadBalancerProfileOutboundIPs
func (managedClusterLoadBalancerProfileOutboundIPs *ManagedClusterLoadBalancerProfileOutboundIPs) AssignPropertiesToManagedClusterLoadBalancerProfileOutboundIPs(destination *v1alpha1api20210501storage.ManagedClusterLoadBalancerProfileOutboundIPs) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PublicIPs
	publicIPList := make([]v1alpha1api20210501storage.ResourceReference, len(managedClusterLoadBalancerProfileOutboundIPs.PublicIPs))
	for publicIPIndex, publicIPItem := range managedClusterLoadBalancerProfileOutboundIPs.PublicIPs {
		// Shadow the loop variable to avoid aliasing
		publicIPItem := publicIPItem
		var publicIP v1alpha1api20210501storage.ResourceReference
		err := publicIPItem.AssignPropertiesToResourceReference(&publicIP)
		if err != nil {
			return errors.Wrap(err, "populating PublicIPs from PublicIPs, calling AssignPropertiesToResourceReference()")
		}
		publicIPList[publicIPIndex] = publicIP
	}
	destination.PublicIPs = publicIPList

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

type ManagedClusterLoadBalancerProfile_Status_ManagedOutboundIPs struct {
	//Count: Desired number of outbound IP created/managed by Azure for the cluster
	//load balancer. Allowed values must be in the range of 1 to 100 (inclusive). The
	//default value is 1.
	Count *int `json:"count,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterLoadBalancerProfile_Status_ManagedOutboundIPs{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (managedClusterLoadBalancerProfileStatusManagedOutboundIPs *ManagedClusterLoadBalancerProfile_Status_ManagedOutboundIPs) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterLoadBalancerProfile_Status_ManagedOutboundIPsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (managedClusterLoadBalancerProfileStatusManagedOutboundIPs *ManagedClusterLoadBalancerProfile_Status_ManagedOutboundIPs) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterLoadBalancerProfile_Status_ManagedOutboundIPsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterLoadBalancerProfile_Status_ManagedOutboundIPsARM, got %T", armInput)
	}

	// Set property ‘Count’:
	if typedInput.Count != nil {
		count := *typedInput.Count
		managedClusterLoadBalancerProfileStatusManagedOutboundIPs.Count = &count
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterLoadBalancerProfileStatusManagedOutboundIPs populates our ManagedClusterLoadBalancerProfile_Status_ManagedOutboundIPs from the provided source ManagedClusterLoadBalancerProfile_Status_ManagedOutboundIPs
func (managedClusterLoadBalancerProfileStatusManagedOutboundIPs *ManagedClusterLoadBalancerProfile_Status_ManagedOutboundIPs) AssignPropertiesFromManagedClusterLoadBalancerProfileStatusManagedOutboundIPs(source *v1alpha1api20210501storage.ManagedClusterLoadBalancerProfile_Status_ManagedOutboundIPs) error {

	// Count
	if source.Count != nil {
		count := *source.Count
		managedClusterLoadBalancerProfileStatusManagedOutboundIPs.Count = &count
	} else {
		managedClusterLoadBalancerProfileStatusManagedOutboundIPs.Count = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterLoadBalancerProfileStatusManagedOutboundIPs populates the provided destination ManagedClusterLoadBalancerProfile_Status_ManagedOutboundIPs from our ManagedClusterLoadBalancerProfile_Status_ManagedOutboundIPs
func (managedClusterLoadBalancerProfileStatusManagedOutboundIPs *ManagedClusterLoadBalancerProfile_Status_ManagedOutboundIPs) AssignPropertiesToManagedClusterLoadBalancerProfileStatusManagedOutboundIPs(destination *v1alpha1api20210501storage.ManagedClusterLoadBalancerProfile_Status_ManagedOutboundIPs) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Count
	if managedClusterLoadBalancerProfileStatusManagedOutboundIPs.Count != nil {
		count := *managedClusterLoadBalancerProfileStatusManagedOutboundIPs.Count
		destination.Count = &count
	} else {
		destination.Count = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

type ManagedClusterLoadBalancerProfile_Status_OutboundIPPrefixes struct {
	//PublicIPPrefixes: A list of public IP prefix resources.
	PublicIPPrefixes []ResourceReference_Status `json:"publicIPPrefixes,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterLoadBalancerProfile_Status_OutboundIPPrefixes{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (managedClusterLoadBalancerProfileStatusOutboundIPPrefixes *ManagedClusterLoadBalancerProfile_Status_OutboundIPPrefixes) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterLoadBalancerProfile_Status_OutboundIPPrefixesARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (managedClusterLoadBalancerProfileStatusOutboundIPPrefixes *ManagedClusterLoadBalancerProfile_Status_OutboundIPPrefixes) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterLoadBalancerProfile_Status_OutboundIPPrefixesARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterLoadBalancerProfile_Status_OutboundIPPrefixesARM, got %T", armInput)
	}

	// Set property ‘PublicIPPrefixes’:
	for _, item := range typedInput.PublicIPPrefixes {
		var item1 ResourceReference_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		managedClusterLoadBalancerProfileStatusOutboundIPPrefixes.PublicIPPrefixes = append(managedClusterLoadBalancerProfileStatusOutboundIPPrefixes.PublicIPPrefixes, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterLoadBalancerProfileStatusOutboundIPPrefixes populates our ManagedClusterLoadBalancerProfile_Status_OutboundIPPrefixes from the provided source ManagedClusterLoadBalancerProfile_Status_OutboundIPPrefixes
func (managedClusterLoadBalancerProfileStatusOutboundIPPrefixes *ManagedClusterLoadBalancerProfile_Status_OutboundIPPrefixes) AssignPropertiesFromManagedClusterLoadBalancerProfileStatusOutboundIPPrefixes(source *v1alpha1api20210501storage.ManagedClusterLoadBalancerProfile_Status_OutboundIPPrefixes) error {

	// PublicIPPrefixes
	publicIPPrefixList := make([]ResourceReference_Status, len(source.PublicIPPrefixes))
	for publicIPPrefixIndex, publicIPPrefixItem := range source.PublicIPPrefixes {
		// Shadow the loop variable to avoid aliasing
		publicIPPrefixItem := publicIPPrefixItem
		var publicIPPrefix ResourceReference_Status
		err := publicIPPrefix.AssignPropertiesFromResourceReferenceStatus(&publicIPPrefixItem)
		if err != nil {
			return errors.Wrap(err, "populating PublicIPPrefixes from PublicIPPrefixes, calling AssignPropertiesFromResourceReferenceStatus()")
		}
		publicIPPrefixList[publicIPPrefixIndex] = publicIPPrefix
	}
	managedClusterLoadBalancerProfileStatusOutboundIPPrefixes.PublicIPPrefixes = publicIPPrefixList

	// No error
	return nil
}

// AssignPropertiesToManagedClusterLoadBalancerProfileStatusOutboundIPPrefixes populates the provided destination ManagedClusterLoadBalancerProfile_Status_OutboundIPPrefixes from our ManagedClusterLoadBalancerProfile_Status_OutboundIPPrefixes
func (managedClusterLoadBalancerProfileStatusOutboundIPPrefixes *ManagedClusterLoadBalancerProfile_Status_OutboundIPPrefixes) AssignPropertiesToManagedClusterLoadBalancerProfileStatusOutboundIPPrefixes(destination *v1alpha1api20210501storage.ManagedClusterLoadBalancerProfile_Status_OutboundIPPrefixes) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PublicIPPrefixes
	publicIPPrefixList := make([]v1alpha1api20210501storage.ResourceReference_Status, len(managedClusterLoadBalancerProfileStatusOutboundIPPrefixes.PublicIPPrefixes))
	for publicIPPrefixIndex, publicIPPrefixItem := range managedClusterLoadBalancerProfileStatusOutboundIPPrefixes.PublicIPPrefixes {
		// Shadow the loop variable to avoid aliasing
		publicIPPrefixItem := publicIPPrefixItem
		var publicIPPrefix v1alpha1api20210501storage.ResourceReference_Status
		err := publicIPPrefixItem.AssignPropertiesToResourceReferenceStatus(&publicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "populating PublicIPPrefixes from PublicIPPrefixes, calling AssignPropertiesToResourceReferenceStatus()")
		}
		publicIPPrefixList[publicIPPrefixIndex] = publicIPPrefix
	}
	destination.PublicIPPrefixes = publicIPPrefixList

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

type ManagedClusterLoadBalancerProfile_Status_OutboundIPs struct {
	//PublicIPs: A list of public IP resources.
	PublicIPs []ResourceReference_Status `json:"publicIPs,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterLoadBalancerProfile_Status_OutboundIPs{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (managedClusterLoadBalancerProfileStatusOutboundIPs *ManagedClusterLoadBalancerProfile_Status_OutboundIPs) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterLoadBalancerProfile_Status_OutboundIPsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (managedClusterLoadBalancerProfileStatusOutboundIPs *ManagedClusterLoadBalancerProfile_Status_OutboundIPs) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterLoadBalancerProfile_Status_OutboundIPsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterLoadBalancerProfile_Status_OutboundIPsARM, got %T", armInput)
	}

	// Set property ‘PublicIPs’:
	for _, item := range typedInput.PublicIPs {
		var item1 ResourceReference_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		managedClusterLoadBalancerProfileStatusOutboundIPs.PublicIPs = append(managedClusterLoadBalancerProfileStatusOutboundIPs.PublicIPs, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterLoadBalancerProfileStatusOutboundIPs populates our ManagedClusterLoadBalancerProfile_Status_OutboundIPs from the provided source ManagedClusterLoadBalancerProfile_Status_OutboundIPs
func (managedClusterLoadBalancerProfileStatusOutboundIPs *ManagedClusterLoadBalancerProfile_Status_OutboundIPs) AssignPropertiesFromManagedClusterLoadBalancerProfileStatusOutboundIPs(source *v1alpha1api20210501storage.ManagedClusterLoadBalancerProfile_Status_OutboundIPs) error {

	// PublicIPs
	publicIPList := make([]ResourceReference_Status, len(source.PublicIPs))
	for publicIPIndex, publicIPItem := range source.PublicIPs {
		// Shadow the loop variable to avoid aliasing
		publicIPItem := publicIPItem
		var publicIP ResourceReference_Status
		err := publicIP.AssignPropertiesFromResourceReferenceStatus(&publicIPItem)
		if err != nil {
			return errors.Wrap(err, "populating PublicIPs from PublicIPs, calling AssignPropertiesFromResourceReferenceStatus()")
		}
		publicIPList[publicIPIndex] = publicIP
	}
	managedClusterLoadBalancerProfileStatusOutboundIPs.PublicIPs = publicIPList

	// No error
	return nil
}

// AssignPropertiesToManagedClusterLoadBalancerProfileStatusOutboundIPs populates the provided destination ManagedClusterLoadBalancerProfile_Status_OutboundIPs from our ManagedClusterLoadBalancerProfile_Status_OutboundIPs
func (managedClusterLoadBalancerProfileStatusOutboundIPs *ManagedClusterLoadBalancerProfile_Status_OutboundIPs) AssignPropertiesToManagedClusterLoadBalancerProfileStatusOutboundIPs(destination *v1alpha1api20210501storage.ManagedClusterLoadBalancerProfile_Status_OutboundIPs) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PublicIPs
	publicIPList := make([]v1alpha1api20210501storage.ResourceReference_Status, len(managedClusterLoadBalancerProfileStatusOutboundIPs.PublicIPs))
	for publicIPIndex, publicIPItem := range managedClusterLoadBalancerProfileStatusOutboundIPs.PublicIPs {
		// Shadow the loop variable to avoid aliasing
		publicIPItem := publicIPItem
		var publicIP v1alpha1api20210501storage.ResourceReference_Status
		err := publicIPItem.AssignPropertiesToResourceReferenceStatus(&publicIP)
		if err != nil {
			return errors.Wrap(err, "populating PublicIPs from PublicIPs, calling AssignPropertiesToResourceReferenceStatus()")
		}
		publicIPList[publicIPIndex] = publicIP
	}
	destination.PublicIPs = publicIPList

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

type ManagedClusterPodIdentityStatusProvisioningState string

const (
	ManagedClusterPodIdentityStatusProvisioningStateAssigned = ManagedClusterPodIdentityStatusProvisioningState("Assigned")
	ManagedClusterPodIdentityStatusProvisioningStateDeleting = ManagedClusterPodIdentityStatusProvisioningState("Deleting")
	ManagedClusterPodIdentityStatusProvisioningStateFailed   = ManagedClusterPodIdentityStatusProvisioningState("Failed")
	ManagedClusterPodIdentityStatusProvisioningStateUpdating = ManagedClusterPodIdentityStatusProvisioningState("Updating")
)

type ManagedClusterPodIdentity_Status_ProvisioningInfo struct {
	//Error: Pod identity assignment error (if any).
	Error *CloudError_Status `json:"error,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedClusterPodIdentity_Status_ProvisioningInfo{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (managedClusterPodIdentityStatusProvisioningInfo *ManagedClusterPodIdentity_Status_ProvisioningInfo) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedClusterPodIdentity_Status_ProvisioningInfoARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (managedClusterPodIdentityStatusProvisioningInfo *ManagedClusterPodIdentity_Status_ProvisioningInfo) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedClusterPodIdentity_Status_ProvisioningInfoARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedClusterPodIdentity_Status_ProvisioningInfoARM, got %T", armInput)
	}

	// Set property ‘Error’:
	if typedInput.Error != nil {
		var error1 CloudError_Status
		err := error1.PopulateFromARM(owner, *typedInput.Error)
		if err != nil {
			return err
		}
		error := error1
		managedClusterPodIdentityStatusProvisioningInfo.Error = &error
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedClusterPodIdentityStatusProvisioningInfo populates our ManagedClusterPodIdentity_Status_ProvisioningInfo from the provided source ManagedClusterPodIdentity_Status_ProvisioningInfo
func (managedClusterPodIdentityStatusProvisioningInfo *ManagedClusterPodIdentity_Status_ProvisioningInfo) AssignPropertiesFromManagedClusterPodIdentityStatusProvisioningInfo(source *v1alpha1api20210501storage.ManagedClusterPodIdentity_Status_ProvisioningInfo) error {

	// Error
	if source.Error != nil {
		var error CloudError_Status
		err := error.AssignPropertiesFromCloudErrorStatus(source.Error)
		if err != nil {
			return errors.Wrap(err, "populating Error from Error, calling AssignPropertiesFromCloudErrorStatus()")
		}
		managedClusterPodIdentityStatusProvisioningInfo.Error = &error
	} else {
		managedClusterPodIdentityStatusProvisioningInfo.Error = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterPodIdentityStatusProvisioningInfo populates the provided destination ManagedClusterPodIdentity_Status_ProvisioningInfo from our ManagedClusterPodIdentity_Status_ProvisioningInfo
func (managedClusterPodIdentityStatusProvisioningInfo *ManagedClusterPodIdentity_Status_ProvisioningInfo) AssignPropertiesToManagedClusterPodIdentityStatusProvisioningInfo(destination *v1alpha1api20210501storage.ManagedClusterPodIdentity_Status_ProvisioningInfo) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Error
	if managedClusterPodIdentityStatusProvisioningInfo.Error != nil {
		var error v1alpha1api20210501storage.CloudError_Status
		err := (*managedClusterPodIdentityStatusProvisioningInfo.Error).AssignPropertiesToCloudErrorStatus(&error)
		if err != nil {
			return errors.Wrap(err, "populating Error from Error, calling AssignPropertiesToCloudErrorStatus()")
		}
		destination.Error = &error
	} else {
		destination.Error = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2021-05-01/Microsoft.ContainerService.json#/definitions/ResourceReference
type ResourceReference struct {
	//Reference: The fully qualified Azure resource id.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &ResourceReference{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (resourceReference *ResourceReference) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if resourceReference == nil {
		return nil, nil
	}
	var result ResourceReferenceARM

	// Set property ‘Id’:
	if resourceReference.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*resourceReference.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resourceReference *ResourceReference) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ResourceReferenceARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resourceReference *ResourceReference) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(ResourceReferenceARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ResourceReferenceARM, got %T", armInput)
	}

	// no assignment for property ‘Reference’

	// No error
	return nil
}

// AssignPropertiesFromResourceReference populates our ResourceReference from the provided source ResourceReference
func (resourceReference *ResourceReference) AssignPropertiesFromResourceReference(source *v1alpha1api20210501storage.ResourceReference) error {

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		resourceReference.Reference = &reference
	} else {
		resourceReference.Reference = nil
	}

	// No error
	return nil
}

// AssignPropertiesToResourceReference populates the provided destination ResourceReference from our ResourceReference
func (resourceReference *ResourceReference) AssignPropertiesToResourceReference(destination *v1alpha1api20210501storage.ResourceReference) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if resourceReference.Reference != nil {
		reference := resourceReference.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type ResourceReference_Status struct {
	//Id: The fully qualified Azure resource id.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &ResourceReference_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resourceReferenceStatus *ResourceReference_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ResourceReference_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resourceReferenceStatus *ResourceReference_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ResourceReference_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ResourceReference_StatusARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		resourceReferenceStatus.Id = &id
	}

	// No error
	return nil
}

// AssignPropertiesFromResourceReferenceStatus populates our ResourceReference_Status from the provided source ResourceReference_Status
func (resourceReferenceStatus *ResourceReference_Status) AssignPropertiesFromResourceReferenceStatus(source *v1alpha1api20210501storage.ResourceReference_Status) error {

	// Id
	if source.Id != nil {
		id := *source.Id
		resourceReferenceStatus.Id = &id
	} else {
		resourceReferenceStatus.Id = nil
	}

	// No error
	return nil
}

// AssignPropertiesToResourceReferenceStatus populates the provided destination ResourceReference_Status from our ResourceReference_Status
func (resourceReferenceStatus *ResourceReference_Status) AssignPropertiesToResourceReferenceStatus(destination *v1alpha1api20210501storage.ResourceReference_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	if resourceReferenceStatus.Id != nil {
		id := *resourceReferenceStatus.Id
		destination.Id = &id
	} else {
		destination.Id = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2021-05-01/Microsoft.ContainerService.json#/definitions/UserAssignedIdentity
type UserAssignedIdentity struct {
	//ClientId: The client ID of the user assigned identity.
	ClientId *string `json:"clientId,omitempty"`

	//ObjectId: The object ID of the user assigned identity.
	ObjectId *string `json:"objectId,omitempty"`

	//ResourceReference: The resource ID of the user assigned identity.
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceId" json:"resourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &UserAssignedIdentity{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (userAssignedIdentity *UserAssignedIdentity) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if userAssignedIdentity == nil {
		return nil, nil
	}
	var result UserAssignedIdentityARM

	// Set property ‘ClientId’:
	if userAssignedIdentity.ClientId != nil {
		clientId := *userAssignedIdentity.ClientId
		result.ClientId = &clientId
	}

	// Set property ‘ObjectId’:
	if userAssignedIdentity.ObjectId != nil {
		objectId := *userAssignedIdentity.ObjectId
		result.ObjectId = &objectId
	}

	// Set property ‘ResourceId’:
	if userAssignedIdentity.ResourceReference != nil {
		resourceReferenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*userAssignedIdentity.ResourceReference)
		if err != nil {
			return nil, err
		}
		resourceReference := resourceReferenceARMID
		result.ResourceId = &resourceReference
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (userAssignedIdentity *UserAssignedIdentity) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &UserAssignedIdentityARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (userAssignedIdentity *UserAssignedIdentity) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(UserAssignedIdentityARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected UserAssignedIdentityARM, got %T", armInput)
	}

	// Set property ‘ClientId’:
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		userAssignedIdentity.ClientId = &clientId
	}

	// Set property ‘ObjectId’:
	if typedInput.ObjectId != nil {
		objectId := *typedInput.ObjectId
		userAssignedIdentity.ObjectId = &objectId
	}

	// no assignment for property ‘ResourceReference’

	// No error
	return nil
}

// AssignPropertiesFromUserAssignedIdentity populates our UserAssignedIdentity from the provided source UserAssignedIdentity
func (userAssignedIdentity *UserAssignedIdentity) AssignPropertiesFromUserAssignedIdentity(source *v1alpha1api20210501storage.UserAssignedIdentity) error {

	// ClientId
	if source.ClientId != nil {
		clientId := *source.ClientId
		userAssignedIdentity.ClientId = &clientId
	} else {
		userAssignedIdentity.ClientId = nil
	}

	// ObjectId
	if source.ObjectId != nil {
		objectId := *source.ObjectId
		userAssignedIdentity.ObjectId = &objectId
	} else {
		userAssignedIdentity.ObjectId = nil
	}

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		userAssignedIdentity.ResourceReference = &resourceReference
	} else {
		userAssignedIdentity.ResourceReference = nil
	}

	// No error
	return nil
}

// AssignPropertiesToUserAssignedIdentity populates the provided destination UserAssignedIdentity from our UserAssignedIdentity
func (userAssignedIdentity *UserAssignedIdentity) AssignPropertiesToUserAssignedIdentity(destination *v1alpha1api20210501storage.UserAssignedIdentity) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	if userAssignedIdentity.ClientId != nil {
		clientId := *userAssignedIdentity.ClientId
		destination.ClientId = &clientId
	} else {
		destination.ClientId = nil
	}

	// ObjectId
	if userAssignedIdentity.ObjectId != nil {
		objectId := *userAssignedIdentity.ObjectId
		destination.ObjectId = &objectId
	} else {
		destination.ObjectId = nil
	}

	// ResourceReference
	if userAssignedIdentity.ResourceReference != nil {
		resourceReference := userAssignedIdentity.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type UserAssignedIdentity_Status struct {
	//ClientId: The client id of the user assigned identity.
	ClientId *string `json:"clientId,omitempty"`

	//ObjectId: The object id of the user assigned identity.
	ObjectId *string `json:"objectId,omitempty"`

	//ResourceId: The resource id of the user assigned identity.
	ResourceId *string `json:"resourceId,omitempty"`
}

var _ genruntime.FromARMConverter = &UserAssignedIdentity_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (userAssignedIdentityStatus *UserAssignedIdentity_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &UserAssignedIdentity_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (userAssignedIdentityStatus *UserAssignedIdentity_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(UserAssignedIdentity_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected UserAssignedIdentity_StatusARM, got %T", armInput)
	}

	// Set property ‘ClientId’:
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		userAssignedIdentityStatus.ClientId = &clientId
	}

	// Set property ‘ObjectId’:
	if typedInput.ObjectId != nil {
		objectId := *typedInput.ObjectId
		userAssignedIdentityStatus.ObjectId = &objectId
	}

	// Set property ‘ResourceId’:
	if typedInput.ResourceId != nil {
		resourceId := *typedInput.ResourceId
		userAssignedIdentityStatus.ResourceId = &resourceId
	}

	// No error
	return nil
}

// AssignPropertiesFromUserAssignedIdentityStatus populates our UserAssignedIdentity_Status from the provided source UserAssignedIdentity_Status
func (userAssignedIdentityStatus *UserAssignedIdentity_Status) AssignPropertiesFromUserAssignedIdentityStatus(source *v1alpha1api20210501storage.UserAssignedIdentity_Status) error {

	// ClientId
	if source.ClientId != nil {
		clientId := *source.ClientId
		userAssignedIdentityStatus.ClientId = &clientId
	} else {
		userAssignedIdentityStatus.ClientId = nil
	}

	// ObjectId
	if source.ObjectId != nil {
		objectId := *source.ObjectId
		userAssignedIdentityStatus.ObjectId = &objectId
	} else {
		userAssignedIdentityStatus.ObjectId = nil
	}

	// ResourceId
	if source.ResourceId != nil {
		resourceId := *source.ResourceId
		userAssignedIdentityStatus.ResourceId = &resourceId
	} else {
		userAssignedIdentityStatus.ResourceId = nil
	}

	// No error
	return nil
}

// AssignPropertiesToUserAssignedIdentityStatus populates the provided destination UserAssignedIdentity_Status from our UserAssignedIdentity_Status
func (userAssignedIdentityStatus *UserAssignedIdentity_Status) AssignPropertiesToUserAssignedIdentityStatus(destination *v1alpha1api20210501storage.UserAssignedIdentity_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	if userAssignedIdentityStatus.ClientId != nil {
		clientId := *userAssignedIdentityStatus.ClientId
		destination.ClientId = &clientId
	} else {
		destination.ClientId = nil
	}

	// ObjectId
	if userAssignedIdentityStatus.ObjectId != nil {
		objectId := *userAssignedIdentityStatus.ObjectId
		destination.ObjectId = &objectId
	} else {
		destination.ObjectId = nil
	}

	// ResourceId
	if userAssignedIdentityStatus.ResourceId != nil {
		resourceId := *userAssignedIdentityStatus.ResourceId
		destination.ResourceId = &resourceId
	} else {
		destination.ResourceId = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type CloudError_Status struct {
	//Error: Details about the error.
	Error *CloudErrorBody_Status `json:"error,omitempty"`
}

var _ genruntime.FromARMConverter = &CloudError_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (cloudErrorStatus *CloudError_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &CloudError_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (cloudErrorStatus *CloudError_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(CloudError_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CloudError_StatusARM, got %T", armInput)
	}

	// Set property ‘Error’:
	if typedInput.Error != nil {
		var error1 CloudErrorBody_Status
		err := error1.PopulateFromARM(owner, *typedInput.Error)
		if err != nil {
			return err
		}
		error := error1
		cloudErrorStatus.Error = &error
	}

	// No error
	return nil
}

// AssignPropertiesFromCloudErrorStatus populates our CloudError_Status from the provided source CloudError_Status
func (cloudErrorStatus *CloudError_Status) AssignPropertiesFromCloudErrorStatus(source *v1alpha1api20210501storage.CloudError_Status) error {

	// Error
	if source.Error != nil {
		var error CloudErrorBody_Status
		err := error.AssignPropertiesFromCloudErrorBodyStatus(source.Error)
		if err != nil {
			return errors.Wrap(err, "populating Error from Error, calling AssignPropertiesFromCloudErrorBodyStatus()")
		}
		cloudErrorStatus.Error = &error
	} else {
		cloudErrorStatus.Error = nil
	}

	// No error
	return nil
}

// AssignPropertiesToCloudErrorStatus populates the provided destination CloudError_Status from our CloudError_Status
func (cloudErrorStatus *CloudError_Status) AssignPropertiesToCloudErrorStatus(destination *v1alpha1api20210501storage.CloudError_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Error
	if cloudErrorStatus.Error != nil {
		var error v1alpha1api20210501storage.CloudErrorBody_Status
		err := (*cloudErrorStatus.Error).AssignPropertiesToCloudErrorBodyStatus(&error)
		if err != nil {
			return errors.Wrap(err, "populating Error from Error, calling AssignPropertiesToCloudErrorBodyStatus()")
		}
		destination.Error = &error
	} else {
		destination.Error = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type CloudErrorBody_Status struct {
	//Code: An identifier for the error. Codes are invariant and are intended to be
	//consumed programmatically.
	Code *string `json:"code,omitempty"`

	//Details: A list of additional details about the error.
	Details []CloudErrorBody_Status_Unrolled `json:"details,omitempty"`

	//Message: A message describing the error, intended to be suitable for display in
	//a user interface.
	Message *string `json:"message,omitempty"`

	//Target: The target of the particular error. For example, the name of the
	//property in error.
	Target *string `json:"target,omitempty"`
}

var _ genruntime.FromARMConverter = &CloudErrorBody_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (cloudErrorBodyStatus *CloudErrorBody_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &CloudErrorBody_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (cloudErrorBodyStatus *CloudErrorBody_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(CloudErrorBody_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CloudErrorBody_StatusARM, got %T", armInput)
	}

	// Set property ‘Code’:
	if typedInput.Code != nil {
		code := *typedInput.Code
		cloudErrorBodyStatus.Code = &code
	}

	// Set property ‘Details’:
	for _, item := range typedInput.Details {
		var item1 CloudErrorBody_Status_Unrolled
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		cloudErrorBodyStatus.Details = append(cloudErrorBodyStatus.Details, item1)
	}

	// Set property ‘Message’:
	if typedInput.Message != nil {
		message := *typedInput.Message
		cloudErrorBodyStatus.Message = &message
	}

	// Set property ‘Target’:
	if typedInput.Target != nil {
		target := *typedInput.Target
		cloudErrorBodyStatus.Target = &target
	}

	// No error
	return nil
}

// AssignPropertiesFromCloudErrorBodyStatus populates our CloudErrorBody_Status from the provided source CloudErrorBody_Status
func (cloudErrorBodyStatus *CloudErrorBody_Status) AssignPropertiesFromCloudErrorBodyStatus(source *v1alpha1api20210501storage.CloudErrorBody_Status) error {

	// Code
	if source.Code != nil {
		code := *source.Code
		cloudErrorBodyStatus.Code = &code
	} else {
		cloudErrorBodyStatus.Code = nil
	}

	// Details
	detailList := make([]CloudErrorBody_Status_Unrolled, len(source.Details))
	for detailIndex, detailItem := range source.Details {
		// Shadow the loop variable to avoid aliasing
		detailItem := detailItem
		var detail CloudErrorBody_Status_Unrolled
		err := detail.AssignPropertiesFromCloudErrorBodyStatusUnrolled(&detailItem)
		if err != nil {
			return errors.Wrap(err, "populating Details from Details, calling AssignPropertiesFromCloudErrorBodyStatusUnrolled()")
		}
		detailList[detailIndex] = detail
	}
	cloudErrorBodyStatus.Details = detailList

	// Message
	if source.Message != nil {
		message := *source.Message
		cloudErrorBodyStatus.Message = &message
	} else {
		cloudErrorBodyStatus.Message = nil
	}

	// Target
	if source.Target != nil {
		target := *source.Target
		cloudErrorBodyStatus.Target = &target
	} else {
		cloudErrorBodyStatus.Target = nil
	}

	// No error
	return nil
}

// AssignPropertiesToCloudErrorBodyStatus populates the provided destination CloudErrorBody_Status from our CloudErrorBody_Status
func (cloudErrorBodyStatus *CloudErrorBody_Status) AssignPropertiesToCloudErrorBodyStatus(destination *v1alpha1api20210501storage.CloudErrorBody_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Code
	if cloudErrorBodyStatus.Code != nil {
		code := *cloudErrorBodyStatus.Code
		destination.Code = &code
	} else {
		destination.Code = nil
	}

	// Details
	detailList := make([]v1alpha1api20210501storage.CloudErrorBody_Status_Unrolled, len(cloudErrorBodyStatus.Details))
	for detailIndex, detailItem := range cloudErrorBodyStatus.Details {
		// Shadow the loop variable to avoid aliasing
		detailItem := detailItem
		var detail v1alpha1api20210501storage.CloudErrorBody_Status_Unrolled
		err := detailItem.AssignPropertiesToCloudErrorBodyStatusUnrolled(&detail)
		if err != nil {
			return errors.Wrap(err, "populating Details from Details, calling AssignPropertiesToCloudErrorBodyStatusUnrolled()")
		}
		detailList[detailIndex] = detail
	}
	destination.Details = detailList

	// Message
	if cloudErrorBodyStatus.Message != nil {
		message := *cloudErrorBodyStatus.Message
		destination.Message = &message
	} else {
		destination.Message = nil
	}

	// Target
	if cloudErrorBodyStatus.Target != nil {
		target := *cloudErrorBodyStatus.Target
		destination.Target = &target
	} else {
		destination.Target = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

type CloudErrorBody_Status_Unrolled struct {
	//Code: An identifier for the error. Codes are invariant and are intended to be
	//consumed programmatically.
	Code *string `json:"code,omitempty"`

	//Message: A message describing the error, intended to be suitable for display in
	//a user interface.
	Message *string `json:"message,omitempty"`

	//Target: The target of the particular error. For example, the name of the
	//property in error.
	Target *string `json:"target,omitempty"`
}

var _ genruntime.FromARMConverter = &CloudErrorBody_Status_Unrolled{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (cloudErrorBodyStatusUnrolled *CloudErrorBody_Status_Unrolled) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &CloudErrorBody_Status_UnrolledARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (cloudErrorBodyStatusUnrolled *CloudErrorBody_Status_Unrolled) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(CloudErrorBody_Status_UnrolledARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CloudErrorBody_Status_UnrolledARM, got %T", armInput)
	}

	// Set property ‘Code’:
	if typedInput.Code != nil {
		code := *typedInput.Code
		cloudErrorBodyStatusUnrolled.Code = &code
	}

	// Set property ‘Message’:
	if typedInput.Message != nil {
		message := *typedInput.Message
		cloudErrorBodyStatusUnrolled.Message = &message
	}

	// Set property ‘Target’:
	if typedInput.Target != nil {
		target := *typedInput.Target
		cloudErrorBodyStatusUnrolled.Target = &target
	}

	// No error
	return nil
}

// AssignPropertiesFromCloudErrorBodyStatusUnrolled populates our CloudErrorBody_Status_Unrolled from the provided source CloudErrorBody_Status_Unrolled
func (cloudErrorBodyStatusUnrolled *CloudErrorBody_Status_Unrolled) AssignPropertiesFromCloudErrorBodyStatusUnrolled(source *v1alpha1api20210501storage.CloudErrorBody_Status_Unrolled) error {

	// Code
	if source.Code != nil {
		code := *source.Code
		cloudErrorBodyStatusUnrolled.Code = &code
	} else {
		cloudErrorBodyStatusUnrolled.Code = nil
	}

	// Message
	if source.Message != nil {
		message := *source.Message
		cloudErrorBodyStatusUnrolled.Message = &message
	} else {
		cloudErrorBodyStatusUnrolled.Message = nil
	}

	// Target
	if source.Target != nil {
		target := *source.Target
		cloudErrorBodyStatusUnrolled.Target = &target
	} else {
		cloudErrorBodyStatusUnrolled.Target = nil
	}

	// No error
	return nil
}

// AssignPropertiesToCloudErrorBodyStatusUnrolled populates the provided destination CloudErrorBody_Status_Unrolled from our CloudErrorBody_Status_Unrolled
func (cloudErrorBodyStatusUnrolled *CloudErrorBody_Status_Unrolled) AssignPropertiesToCloudErrorBodyStatusUnrolled(destination *v1alpha1api20210501storage.CloudErrorBody_Status_Unrolled) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Code
	if cloudErrorBodyStatusUnrolled.Code != nil {
		code := *cloudErrorBodyStatusUnrolled.Code
		destination.Code = &code
	} else {
		destination.Code = nil
	}

	// Message
	if cloudErrorBodyStatusUnrolled.Message != nil {
		message := *cloudErrorBodyStatusUnrolled.Message
		destination.Message = &message
	} else {
		destination.Message = nil
	}

	// Target
	if cloudErrorBodyStatusUnrolled.Target != nil {
		target := *cloudErrorBodyStatusUnrolled.Target
		destination.Target = &target
	} else {
		destination.Target = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&ManagedCluster{}, &ManagedClusterList{})
}
