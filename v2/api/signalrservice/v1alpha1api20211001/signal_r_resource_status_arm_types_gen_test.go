// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20211001

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_SignalRResource_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRResource_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRResourceSTATUSARM, SignalRResourceSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRResourceSTATUSARM runs a test to see if a specific instance of SignalRResource_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRResourceSTATUSARM(subject SignalRResource_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRResource_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRResource_STATUSARM instances for property testing - lazily instantiated by
// SignalRResourceSTATUSARMGenerator()
var signalRResourceSTATUSARMGenerator gopter.Gen

// SignalRResourceSTATUSARMGenerator returns a generator of SignalRResource_STATUSARM instances for property testing.
// We first initialize signalRResourceSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SignalRResourceSTATUSARMGenerator() gopter.Gen {
	if signalRResourceSTATUSARMGenerator != nil {
		return signalRResourceSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRResourceSTATUSARM(generators)
	signalRResourceSTATUSARMGenerator = gen.Struct(reflect.TypeOf(SignalRResource_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRResourceSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForSignalRResourceSTATUSARM(generators)
	signalRResourceSTATUSARMGenerator = gen.Struct(reflect.TypeOf(SignalRResource_STATUSARM{}), generators)

	return signalRResourceSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForSignalRResourceSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRResourceSTATUSARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(ServiceKind_STATUS_RawWebSockets, ServiceKind_STATUS_SignalR))
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSignalRResourceSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSignalRResourceSTATUSARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedIdentitySTATUSARMGenerator())
	gens["Properties"] = gen.PtrOf(SignalRPropertiesSTATUSARMGenerator())
	gens["Sku"] = gen.PtrOf(ResourceSkuSTATUSARMGenerator())
	gens["SystemData"] = gen.PtrOf(SystemDataSTATUSARMGenerator())
}

func Test_ManagedIdentity_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedIdentity_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedIdentitySTATUSARM, ManagedIdentitySTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedIdentitySTATUSARM runs a test to see if a specific instance of ManagedIdentity_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedIdentitySTATUSARM(subject ManagedIdentity_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedIdentity_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedIdentity_STATUSARM instances for property testing - lazily instantiated by
// ManagedIdentitySTATUSARMGenerator()
var managedIdentitySTATUSARMGenerator gopter.Gen

// ManagedIdentitySTATUSARMGenerator returns a generator of ManagedIdentity_STATUSARM instances for property testing.
// We first initialize managedIdentitySTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedIdentitySTATUSARMGenerator() gopter.Gen {
	if managedIdentitySTATUSARMGenerator != nil {
		return managedIdentitySTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedIdentitySTATUSARM(generators)
	managedIdentitySTATUSARMGenerator = gen.Struct(reflect.TypeOf(ManagedIdentity_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedIdentitySTATUSARM(generators)
	AddRelatedPropertyGeneratorsForManagedIdentitySTATUSARM(generators)
	managedIdentitySTATUSARMGenerator = gen.Struct(reflect.TypeOf(ManagedIdentity_STATUSARM{}), generators)

	return managedIdentitySTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedIdentitySTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedIdentitySTATUSARM(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ManagedIdentityType_STATUS_None, ManagedIdentityType_STATUS_SystemAssigned, ManagedIdentityType_STATUS_UserAssigned))
}

// AddRelatedPropertyGeneratorsForManagedIdentitySTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedIdentitySTATUSARM(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), UserAssignedIdentityPropertySTATUSARMGenerator())
}

func Test_ResourceSku_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceSku_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceSkuSTATUSARM, ResourceSkuSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceSkuSTATUSARM runs a test to see if a specific instance of ResourceSku_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceSkuSTATUSARM(subject ResourceSku_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceSku_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceSku_STATUSARM instances for property testing - lazily instantiated by
// ResourceSkuSTATUSARMGenerator()
var resourceSkuSTATUSARMGenerator gopter.Gen

// ResourceSkuSTATUSARMGenerator returns a generator of ResourceSku_STATUSARM instances for property testing.
func ResourceSkuSTATUSARMGenerator() gopter.Gen {
	if resourceSkuSTATUSARMGenerator != nil {
		return resourceSkuSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceSkuSTATUSARM(generators)
	resourceSkuSTATUSARMGenerator = gen.Struct(reflect.TypeOf(ResourceSku_STATUSARM{}), generators)

	return resourceSkuSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForResourceSkuSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceSkuSTATUSARM(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Family"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Size"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(
		SignalRSkuTier_STATUS_Basic,
		SignalRSkuTier_STATUS_Free,
		SignalRSkuTier_STATUS_Premium,
		SignalRSkuTier_STATUS_Standard))
}

func Test_SignalRProperties_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRProperties_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRPropertiesSTATUSARM, SignalRPropertiesSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRPropertiesSTATUSARM runs a test to see if a specific instance of SignalRProperties_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRPropertiesSTATUSARM(subject SignalRProperties_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRProperties_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRProperties_STATUSARM instances for property testing - lazily instantiated by
// SignalRPropertiesSTATUSARMGenerator()
var signalRPropertiesSTATUSARMGenerator gopter.Gen

// SignalRPropertiesSTATUSARMGenerator returns a generator of SignalRProperties_STATUSARM instances for property testing.
// We first initialize signalRPropertiesSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SignalRPropertiesSTATUSARMGenerator() gopter.Gen {
	if signalRPropertiesSTATUSARMGenerator != nil {
		return signalRPropertiesSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRPropertiesSTATUSARM(generators)
	signalRPropertiesSTATUSARMGenerator = gen.Struct(reflect.TypeOf(SignalRProperties_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRPropertiesSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForSignalRPropertiesSTATUSARM(generators)
	signalRPropertiesSTATUSARMGenerator = gen.Struct(reflect.TypeOf(SignalRProperties_STATUSARM{}), generators)

	return signalRPropertiesSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForSignalRPropertiesSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRPropertiesSTATUSARM(gens map[string]gopter.Gen) {
	gens["DisableAadAuth"] = gen.PtrOf(gen.Bool())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["ExternalIP"] = gen.PtrOf(gen.AlphaString())
	gens["HostName"] = gen.PtrOf(gen.AlphaString())
	gens["HostNamePrefix"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_STATUS_Canceled,
		ProvisioningState_STATUS_Creating,
		ProvisioningState_STATUS_Deleting,
		ProvisioningState_STATUS_Failed,
		ProvisioningState_STATUS_Moving,
		ProvisioningState_STATUS_Running,
		ProvisioningState_STATUS_Succeeded,
		ProvisioningState_STATUS_Unknown,
		ProvisioningState_STATUS_Updating))
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.AlphaString())
	gens["PublicPort"] = gen.PtrOf(gen.Int())
	gens["ServerPort"] = gen.PtrOf(gen.Int())
	gens["Version"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSignalRPropertiesSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSignalRPropertiesSTATUSARM(gens map[string]gopter.Gen) {
	gens["Cors"] = gen.PtrOf(SignalRCorsSettingsSTATUSARMGenerator())
	gens["Features"] = gen.SliceOf(SignalRFeatureSTATUSARMGenerator())
	gens["NetworkACLs"] = gen.PtrOf(SignalRNetworkACLsSTATUSARMGenerator())
	gens["PrivateEndpointConnections"] = gen.SliceOf(PrivateEndpointConnectionSTATUSSignalRSubResourceEmbeddedARMGenerator())
	gens["ResourceLogConfiguration"] = gen.PtrOf(ResourceLogConfigurationSTATUSARMGenerator())
	gens["SharedPrivateLinkResources"] = gen.SliceOf(SharedPrivateLinkResourceSTATUSSignalRSubResourceEmbeddedARMGenerator())
	gens["Tls"] = gen.PtrOf(SignalRTlsSettingsSTATUSARMGenerator())
	gens["Upstream"] = gen.PtrOf(ServerlessUpstreamSettingsSTATUSARMGenerator())
}

func Test_SystemData_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SystemData_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSystemDataSTATUSARM, SystemDataSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSystemDataSTATUSARM runs a test to see if a specific instance of SystemData_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSystemDataSTATUSARM(subject SystemData_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SystemData_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SystemData_STATUSARM instances for property testing - lazily instantiated by
// SystemDataSTATUSARMGenerator()
var systemDataSTATUSARMGenerator gopter.Gen

// SystemDataSTATUSARMGenerator returns a generator of SystemData_STATUSARM instances for property testing.
func SystemDataSTATUSARMGenerator() gopter.Gen {
	if systemDataSTATUSARMGenerator != nil {
		return systemDataSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSystemDataSTATUSARM(generators)
	systemDataSTATUSARMGenerator = gen.Struct(reflect.TypeOf(SystemData_STATUSARM{}), generators)

	return systemDataSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForSystemDataSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSystemDataSTATUSARM(gens map[string]gopter.Gen) {
	gens["CreatedAt"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedBy"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemDataSTATUSCreatedByType_Application,
		SystemDataSTATUSCreatedByType_Key,
		SystemDataSTATUSCreatedByType_ManagedIdentity,
		SystemDataSTATUSCreatedByType_User))
	gens["LastModifiedAt"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedBy"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemDataSTATUSLastModifiedByType_Application,
		SystemDataSTATUSLastModifiedByType_Key,
		SystemDataSTATUSLastModifiedByType_ManagedIdentity,
		SystemDataSTATUSLastModifiedByType_User))
}

func Test_PrivateEndpointConnection_STATUS_SignalR_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointConnection_STATUS_SignalR_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointConnectionSTATUSSignalRSubResourceEmbeddedARM, PrivateEndpointConnectionSTATUSSignalRSubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointConnectionSTATUSSignalRSubResourceEmbeddedARM runs a test to see if a specific instance of PrivateEndpointConnection_STATUS_SignalR_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointConnectionSTATUSSignalRSubResourceEmbeddedARM(subject PrivateEndpointConnection_STATUS_SignalR_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointConnection_STATUS_SignalR_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointConnection_STATUS_SignalR_SubResourceEmbeddedARM instances for property testing - lazily
// instantiated by PrivateEndpointConnectionSTATUSSignalRSubResourceEmbeddedARMGenerator()
var privateEndpointConnectionSTATUSSignalRSubResourceEmbeddedARMGenerator gopter.Gen

// PrivateEndpointConnectionSTATUSSignalRSubResourceEmbeddedARMGenerator returns a generator of PrivateEndpointConnection_STATUS_SignalR_SubResourceEmbeddedARM instances for property testing.
// We first initialize privateEndpointConnectionSTATUSSignalRSubResourceEmbeddedARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateEndpointConnectionSTATUSSignalRSubResourceEmbeddedARMGenerator() gopter.Gen {
	if privateEndpointConnectionSTATUSSignalRSubResourceEmbeddedARMGenerator != nil {
		return privateEndpointConnectionSTATUSSignalRSubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnectionSTATUSSignalRSubResourceEmbeddedARM(generators)
	privateEndpointConnectionSTATUSSignalRSubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnection_STATUS_SignalR_SubResourceEmbeddedARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnectionSTATUSSignalRSubResourceEmbeddedARM(generators)
	AddRelatedPropertyGeneratorsForPrivateEndpointConnectionSTATUSSignalRSubResourceEmbeddedARM(generators)
	privateEndpointConnectionSTATUSSignalRSubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnection_STATUS_SignalR_SubResourceEmbeddedARM{}), generators)

	return privateEndpointConnectionSTATUSSignalRSubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointConnectionSTATUSSignalRSubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointConnectionSTATUSSignalRSubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPrivateEndpointConnectionSTATUSSignalRSubResourceEmbeddedARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateEndpointConnectionSTATUSSignalRSubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["SystemData"] = gen.PtrOf(SystemDataSTATUSARMGenerator())
}

func Test_ResourceLogConfiguration_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceLogConfiguration_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceLogConfigurationSTATUSARM, ResourceLogConfigurationSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceLogConfigurationSTATUSARM runs a test to see if a specific instance of ResourceLogConfiguration_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceLogConfigurationSTATUSARM(subject ResourceLogConfiguration_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceLogConfiguration_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceLogConfiguration_STATUSARM instances for property testing - lazily instantiated by
// ResourceLogConfigurationSTATUSARMGenerator()
var resourceLogConfigurationSTATUSARMGenerator gopter.Gen

// ResourceLogConfigurationSTATUSARMGenerator returns a generator of ResourceLogConfiguration_STATUSARM instances for property testing.
func ResourceLogConfigurationSTATUSARMGenerator() gopter.Gen {
	if resourceLogConfigurationSTATUSARMGenerator != nil {
		return resourceLogConfigurationSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForResourceLogConfigurationSTATUSARM(generators)
	resourceLogConfigurationSTATUSARMGenerator = gen.Struct(reflect.TypeOf(ResourceLogConfiguration_STATUSARM{}), generators)

	return resourceLogConfigurationSTATUSARMGenerator
}

// AddRelatedPropertyGeneratorsForResourceLogConfigurationSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResourceLogConfigurationSTATUSARM(gens map[string]gopter.Gen) {
	gens["Categories"] = gen.SliceOf(ResourceLogCategorySTATUSARMGenerator())
}

func Test_ServerlessUpstreamSettings_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServerlessUpstreamSettings_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServerlessUpstreamSettingsSTATUSARM, ServerlessUpstreamSettingsSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServerlessUpstreamSettingsSTATUSARM runs a test to see if a specific instance of ServerlessUpstreamSettings_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForServerlessUpstreamSettingsSTATUSARM(subject ServerlessUpstreamSettings_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServerlessUpstreamSettings_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServerlessUpstreamSettings_STATUSARM instances for property testing - lazily instantiated by
// ServerlessUpstreamSettingsSTATUSARMGenerator()
var serverlessUpstreamSettingsSTATUSARMGenerator gopter.Gen

// ServerlessUpstreamSettingsSTATUSARMGenerator returns a generator of ServerlessUpstreamSettings_STATUSARM instances for property testing.
func ServerlessUpstreamSettingsSTATUSARMGenerator() gopter.Gen {
	if serverlessUpstreamSettingsSTATUSARMGenerator != nil {
		return serverlessUpstreamSettingsSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForServerlessUpstreamSettingsSTATUSARM(generators)
	serverlessUpstreamSettingsSTATUSARMGenerator = gen.Struct(reflect.TypeOf(ServerlessUpstreamSettings_STATUSARM{}), generators)

	return serverlessUpstreamSettingsSTATUSARMGenerator
}

// AddRelatedPropertyGeneratorsForServerlessUpstreamSettingsSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForServerlessUpstreamSettingsSTATUSARM(gens map[string]gopter.Gen) {
	gens["Templates"] = gen.SliceOf(UpstreamTemplateSTATUSARMGenerator())
}

func Test_SharedPrivateLinkResource_STATUS_SignalR_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SharedPrivateLinkResource_STATUS_SignalR_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSharedPrivateLinkResourceSTATUSSignalRSubResourceEmbeddedARM, SharedPrivateLinkResourceSTATUSSignalRSubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSharedPrivateLinkResourceSTATUSSignalRSubResourceEmbeddedARM runs a test to see if a specific instance of SharedPrivateLinkResource_STATUS_SignalR_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSharedPrivateLinkResourceSTATUSSignalRSubResourceEmbeddedARM(subject SharedPrivateLinkResource_STATUS_SignalR_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SharedPrivateLinkResource_STATUS_SignalR_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SharedPrivateLinkResource_STATUS_SignalR_SubResourceEmbeddedARM instances for property testing - lazily
// instantiated by SharedPrivateLinkResourceSTATUSSignalRSubResourceEmbeddedARMGenerator()
var sharedPrivateLinkResourceSTATUSSignalRSubResourceEmbeddedARMGenerator gopter.Gen

// SharedPrivateLinkResourceSTATUSSignalRSubResourceEmbeddedARMGenerator returns a generator of SharedPrivateLinkResource_STATUS_SignalR_SubResourceEmbeddedARM instances for property testing.
// We first initialize sharedPrivateLinkResourceSTATUSSignalRSubResourceEmbeddedARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SharedPrivateLinkResourceSTATUSSignalRSubResourceEmbeddedARMGenerator() gopter.Gen {
	if sharedPrivateLinkResourceSTATUSSignalRSubResourceEmbeddedARMGenerator != nil {
		return sharedPrivateLinkResourceSTATUSSignalRSubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSharedPrivateLinkResourceSTATUSSignalRSubResourceEmbeddedARM(generators)
	sharedPrivateLinkResourceSTATUSSignalRSubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(SharedPrivateLinkResource_STATUS_SignalR_SubResourceEmbeddedARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSharedPrivateLinkResourceSTATUSSignalRSubResourceEmbeddedARM(generators)
	AddRelatedPropertyGeneratorsForSharedPrivateLinkResourceSTATUSSignalRSubResourceEmbeddedARM(generators)
	sharedPrivateLinkResourceSTATUSSignalRSubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(SharedPrivateLinkResource_STATUS_SignalR_SubResourceEmbeddedARM{}), generators)

	return sharedPrivateLinkResourceSTATUSSignalRSubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForSharedPrivateLinkResourceSTATUSSignalRSubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSharedPrivateLinkResourceSTATUSSignalRSubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSharedPrivateLinkResourceSTATUSSignalRSubResourceEmbeddedARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSharedPrivateLinkResourceSTATUSSignalRSubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["SystemData"] = gen.PtrOf(SystemDataSTATUSARMGenerator())
}

func Test_SignalRCorsSettings_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRCorsSettings_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRCorsSettingsSTATUSARM, SignalRCorsSettingsSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRCorsSettingsSTATUSARM runs a test to see if a specific instance of SignalRCorsSettings_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRCorsSettingsSTATUSARM(subject SignalRCorsSettings_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRCorsSettings_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRCorsSettings_STATUSARM instances for property testing - lazily instantiated by
// SignalRCorsSettingsSTATUSARMGenerator()
var signalRCorsSettingsSTATUSARMGenerator gopter.Gen

// SignalRCorsSettingsSTATUSARMGenerator returns a generator of SignalRCorsSettings_STATUSARM instances for property testing.
func SignalRCorsSettingsSTATUSARMGenerator() gopter.Gen {
	if signalRCorsSettingsSTATUSARMGenerator != nil {
		return signalRCorsSettingsSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRCorsSettingsSTATUSARM(generators)
	signalRCorsSettingsSTATUSARMGenerator = gen.Struct(reflect.TypeOf(SignalRCorsSettings_STATUSARM{}), generators)

	return signalRCorsSettingsSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForSignalRCorsSettingsSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRCorsSettingsSTATUSARM(gens map[string]gopter.Gen) {
	gens["AllowedOrigins"] = gen.SliceOf(gen.AlphaString())
}

func Test_SignalRFeature_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRFeature_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRFeatureSTATUSARM, SignalRFeatureSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRFeatureSTATUSARM runs a test to see if a specific instance of SignalRFeature_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRFeatureSTATUSARM(subject SignalRFeature_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRFeature_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRFeature_STATUSARM instances for property testing - lazily instantiated by
// SignalRFeatureSTATUSARMGenerator()
var signalRFeatureSTATUSARMGenerator gopter.Gen

// SignalRFeatureSTATUSARMGenerator returns a generator of SignalRFeature_STATUSARM instances for property testing.
func SignalRFeatureSTATUSARMGenerator() gopter.Gen {
	if signalRFeatureSTATUSARMGenerator != nil {
		return signalRFeatureSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRFeatureSTATUSARM(generators)
	signalRFeatureSTATUSARMGenerator = gen.Struct(reflect.TypeOf(SignalRFeature_STATUSARM{}), generators)

	return signalRFeatureSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForSignalRFeatureSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRFeatureSTATUSARM(gens map[string]gopter.Gen) {
	gens["Flag"] = gen.PtrOf(gen.OneConstOf(
		FeatureFlags_STATUS_EnableConnectivityLogs,
		FeatureFlags_STATUS_EnableLiveTrace,
		FeatureFlags_STATUS_EnableMessagingLogs,
		FeatureFlags_STATUS_ServiceMode))
	gens["Properties"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_SignalRNetworkACLs_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRNetworkACLs_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRNetworkACLsSTATUSARM, SignalRNetworkACLsSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRNetworkACLsSTATUSARM runs a test to see if a specific instance of SignalRNetworkACLs_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRNetworkACLsSTATUSARM(subject SignalRNetworkACLs_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRNetworkACLs_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRNetworkACLs_STATUSARM instances for property testing - lazily instantiated by
// SignalRNetworkACLsSTATUSARMGenerator()
var signalRNetworkACLsSTATUSARMGenerator gopter.Gen

// SignalRNetworkACLsSTATUSARMGenerator returns a generator of SignalRNetworkACLs_STATUSARM instances for property testing.
// We first initialize signalRNetworkACLsSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SignalRNetworkACLsSTATUSARMGenerator() gopter.Gen {
	if signalRNetworkACLsSTATUSARMGenerator != nil {
		return signalRNetworkACLsSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRNetworkACLsSTATUSARM(generators)
	signalRNetworkACLsSTATUSARMGenerator = gen.Struct(reflect.TypeOf(SignalRNetworkACLs_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRNetworkACLsSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForSignalRNetworkACLsSTATUSARM(generators)
	signalRNetworkACLsSTATUSARMGenerator = gen.Struct(reflect.TypeOf(SignalRNetworkACLs_STATUSARM{}), generators)

	return signalRNetworkACLsSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForSignalRNetworkACLsSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRNetworkACLsSTATUSARM(gens map[string]gopter.Gen) {
	gens["DefaultAction"] = gen.PtrOf(gen.OneConstOf(ACLAction_STATUS_Allow, ACLAction_STATUS_Deny))
}

// AddRelatedPropertyGeneratorsForSignalRNetworkACLsSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSignalRNetworkACLsSTATUSARM(gens map[string]gopter.Gen) {
	gens["PrivateEndpoints"] = gen.SliceOf(PrivateEndpointACLSTATUSARMGenerator())
	gens["PublicNetwork"] = gen.PtrOf(NetworkACLSTATUSARMGenerator())
}

func Test_SignalRTlsSettings_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRTlsSettings_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRTlsSettingsSTATUSARM, SignalRTlsSettingsSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRTlsSettingsSTATUSARM runs a test to see if a specific instance of SignalRTlsSettings_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRTlsSettingsSTATUSARM(subject SignalRTlsSettings_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRTlsSettings_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRTlsSettings_STATUSARM instances for property testing - lazily instantiated by
// SignalRTlsSettingsSTATUSARMGenerator()
var signalRTlsSettingsSTATUSARMGenerator gopter.Gen

// SignalRTlsSettingsSTATUSARMGenerator returns a generator of SignalRTlsSettings_STATUSARM instances for property testing.
func SignalRTlsSettingsSTATUSARMGenerator() gopter.Gen {
	if signalRTlsSettingsSTATUSARMGenerator != nil {
		return signalRTlsSettingsSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRTlsSettingsSTATUSARM(generators)
	signalRTlsSettingsSTATUSARMGenerator = gen.Struct(reflect.TypeOf(SignalRTlsSettings_STATUSARM{}), generators)

	return signalRTlsSettingsSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForSignalRTlsSettingsSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRTlsSettingsSTATUSARM(gens map[string]gopter.Gen) {
	gens["ClientCertEnabled"] = gen.PtrOf(gen.Bool())
}

func Test_UserAssignedIdentityProperty_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentityProperty_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentityPropertySTATUSARM, UserAssignedIdentityPropertySTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentityPropertySTATUSARM runs a test to see if a specific instance of UserAssignedIdentityProperty_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentityPropertySTATUSARM(subject UserAssignedIdentityProperty_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentityProperty_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentityProperty_STATUSARM instances for property testing - lazily instantiated by
// UserAssignedIdentityPropertySTATUSARMGenerator()
var userAssignedIdentityPropertySTATUSARMGenerator gopter.Gen

// UserAssignedIdentityPropertySTATUSARMGenerator returns a generator of UserAssignedIdentityProperty_STATUSARM instances for property testing.
func UserAssignedIdentityPropertySTATUSARMGenerator() gopter.Gen {
	if userAssignedIdentityPropertySTATUSARMGenerator != nil {
		return userAssignedIdentityPropertySTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserAssignedIdentityPropertySTATUSARM(generators)
	userAssignedIdentityPropertySTATUSARMGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentityProperty_STATUSARM{}), generators)

	return userAssignedIdentityPropertySTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForUserAssignedIdentityPropertySTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserAssignedIdentityPropertySTATUSARM(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_NetworkACL_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkACL_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkACLSTATUSARM, NetworkACLSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkACLSTATUSARM runs a test to see if a specific instance of NetworkACL_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkACLSTATUSARM(subject NetworkACL_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkACL_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkACL_STATUSARM instances for property testing - lazily instantiated by
// NetworkACLSTATUSARMGenerator()
var networkACLSTATUSARMGenerator gopter.Gen

// NetworkACLSTATUSARMGenerator returns a generator of NetworkACL_STATUSARM instances for property testing.
func NetworkACLSTATUSARMGenerator() gopter.Gen {
	if networkACLSTATUSARMGenerator != nil {
		return networkACLSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkACLSTATUSARM(generators)
	networkACLSTATUSARMGenerator = gen.Struct(reflect.TypeOf(NetworkACL_STATUSARM{}), generators)

	return networkACLSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkACLSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkACLSTATUSARM(gens map[string]gopter.Gen) {
	gens["Allow"] = gen.SliceOf(gen.OneConstOf(
		SignalRRequestType_STATUS_ClientConnection,
		SignalRRequestType_STATUS_RESTAPI,
		SignalRRequestType_STATUS_ServerConnection,
		SignalRRequestType_STATUS_Trace))
	gens["Deny"] = gen.SliceOf(gen.OneConstOf(
		SignalRRequestType_STATUS_ClientConnection,
		SignalRRequestType_STATUS_RESTAPI,
		SignalRRequestType_STATUS_ServerConnection,
		SignalRRequestType_STATUS_Trace))
}

func Test_PrivateEndpointACL_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointACL_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointACLSTATUSARM, PrivateEndpointACLSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointACLSTATUSARM runs a test to see if a specific instance of PrivateEndpointACL_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointACLSTATUSARM(subject PrivateEndpointACL_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointACL_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointACL_STATUSARM instances for property testing - lazily instantiated by
// PrivateEndpointACLSTATUSARMGenerator()
var privateEndpointACLSTATUSARMGenerator gopter.Gen

// PrivateEndpointACLSTATUSARMGenerator returns a generator of PrivateEndpointACL_STATUSARM instances for property testing.
func PrivateEndpointACLSTATUSARMGenerator() gopter.Gen {
	if privateEndpointACLSTATUSARMGenerator != nil {
		return privateEndpointACLSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointACLSTATUSARM(generators)
	privateEndpointACLSTATUSARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointACL_STATUSARM{}), generators)

	return privateEndpointACLSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointACLSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointACLSTATUSARM(gens map[string]gopter.Gen) {
	gens["Allow"] = gen.SliceOf(gen.OneConstOf(
		SignalRRequestType_STATUS_ClientConnection,
		SignalRRequestType_STATUS_RESTAPI,
		SignalRRequestType_STATUS_ServerConnection,
		SignalRRequestType_STATUS_Trace))
	gens["Deny"] = gen.SliceOf(gen.OneConstOf(
		SignalRRequestType_STATUS_ClientConnection,
		SignalRRequestType_STATUS_RESTAPI,
		SignalRRequestType_STATUS_ServerConnection,
		SignalRRequestType_STATUS_Trace))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_ResourceLogCategory_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceLogCategory_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceLogCategorySTATUSARM, ResourceLogCategorySTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceLogCategorySTATUSARM runs a test to see if a specific instance of ResourceLogCategory_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceLogCategorySTATUSARM(subject ResourceLogCategory_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceLogCategory_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceLogCategory_STATUSARM instances for property testing - lazily instantiated by
// ResourceLogCategorySTATUSARMGenerator()
var resourceLogCategorySTATUSARMGenerator gopter.Gen

// ResourceLogCategorySTATUSARMGenerator returns a generator of ResourceLogCategory_STATUSARM instances for property testing.
func ResourceLogCategorySTATUSARMGenerator() gopter.Gen {
	if resourceLogCategorySTATUSARMGenerator != nil {
		return resourceLogCategorySTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceLogCategorySTATUSARM(generators)
	resourceLogCategorySTATUSARMGenerator = gen.Struct(reflect.TypeOf(ResourceLogCategory_STATUSARM{}), generators)

	return resourceLogCategorySTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForResourceLogCategorySTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceLogCategorySTATUSARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_UpstreamTemplate_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UpstreamTemplate_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUpstreamTemplateSTATUSARM, UpstreamTemplateSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUpstreamTemplateSTATUSARM runs a test to see if a specific instance of UpstreamTemplate_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUpstreamTemplateSTATUSARM(subject UpstreamTemplate_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UpstreamTemplate_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UpstreamTemplate_STATUSARM instances for property testing - lazily instantiated by
// UpstreamTemplateSTATUSARMGenerator()
var upstreamTemplateSTATUSARMGenerator gopter.Gen

// UpstreamTemplateSTATUSARMGenerator returns a generator of UpstreamTemplate_STATUSARM instances for property testing.
// We first initialize upstreamTemplateSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UpstreamTemplateSTATUSARMGenerator() gopter.Gen {
	if upstreamTemplateSTATUSARMGenerator != nil {
		return upstreamTemplateSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpstreamTemplateSTATUSARM(generators)
	upstreamTemplateSTATUSARMGenerator = gen.Struct(reflect.TypeOf(UpstreamTemplate_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpstreamTemplateSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForUpstreamTemplateSTATUSARM(generators)
	upstreamTemplateSTATUSARMGenerator = gen.Struct(reflect.TypeOf(UpstreamTemplate_STATUSARM{}), generators)

	return upstreamTemplateSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForUpstreamTemplateSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUpstreamTemplateSTATUSARM(gens map[string]gopter.Gen) {
	gens["CategoryPattern"] = gen.PtrOf(gen.AlphaString())
	gens["EventPattern"] = gen.PtrOf(gen.AlphaString())
	gens["HubPattern"] = gen.PtrOf(gen.AlphaString())
	gens["UrlTemplate"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForUpstreamTemplateSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUpstreamTemplateSTATUSARM(gens map[string]gopter.Gen) {
	gens["Auth"] = gen.PtrOf(UpstreamAuthSettingsSTATUSARMGenerator())
}

func Test_UpstreamAuthSettings_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UpstreamAuthSettings_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUpstreamAuthSettingsSTATUSARM, UpstreamAuthSettingsSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUpstreamAuthSettingsSTATUSARM runs a test to see if a specific instance of UpstreamAuthSettings_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUpstreamAuthSettingsSTATUSARM(subject UpstreamAuthSettings_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UpstreamAuthSettings_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UpstreamAuthSettings_STATUSARM instances for property testing - lazily instantiated by
// UpstreamAuthSettingsSTATUSARMGenerator()
var upstreamAuthSettingsSTATUSARMGenerator gopter.Gen

// UpstreamAuthSettingsSTATUSARMGenerator returns a generator of UpstreamAuthSettings_STATUSARM instances for property testing.
// We first initialize upstreamAuthSettingsSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UpstreamAuthSettingsSTATUSARMGenerator() gopter.Gen {
	if upstreamAuthSettingsSTATUSARMGenerator != nil {
		return upstreamAuthSettingsSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpstreamAuthSettingsSTATUSARM(generators)
	upstreamAuthSettingsSTATUSARMGenerator = gen.Struct(reflect.TypeOf(UpstreamAuthSettings_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpstreamAuthSettingsSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForUpstreamAuthSettingsSTATUSARM(generators)
	upstreamAuthSettingsSTATUSARMGenerator = gen.Struct(reflect.TypeOf(UpstreamAuthSettings_STATUSARM{}), generators)

	return upstreamAuthSettingsSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForUpstreamAuthSettingsSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUpstreamAuthSettingsSTATUSARM(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(UpstreamAuthType_STATUS_ManagedIdentity, UpstreamAuthType_STATUS_None))
}

// AddRelatedPropertyGeneratorsForUpstreamAuthSettingsSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUpstreamAuthSettingsSTATUSARM(gens map[string]gopter.Gen) {
	gens["ManagedIdentity"] = gen.PtrOf(ManagedIdentitySettingsSTATUSARMGenerator())
}

func Test_ManagedIdentitySettings_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedIdentitySettings_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedIdentitySettingsSTATUSARM, ManagedIdentitySettingsSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedIdentitySettingsSTATUSARM runs a test to see if a specific instance of ManagedIdentitySettings_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedIdentitySettingsSTATUSARM(subject ManagedIdentitySettings_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedIdentitySettings_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedIdentitySettings_STATUSARM instances for property testing - lazily instantiated by
// ManagedIdentitySettingsSTATUSARMGenerator()
var managedIdentitySettingsSTATUSARMGenerator gopter.Gen

// ManagedIdentitySettingsSTATUSARMGenerator returns a generator of ManagedIdentitySettings_STATUSARM instances for property testing.
func ManagedIdentitySettingsSTATUSARMGenerator() gopter.Gen {
	if managedIdentitySettingsSTATUSARMGenerator != nil {
		return managedIdentitySettingsSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedIdentitySettingsSTATUSARM(generators)
	managedIdentitySettingsSTATUSARMGenerator = gen.Struct(reflect.TypeOf(ManagedIdentitySettings_STATUSARM{}), generators)

	return managedIdentitySettingsSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedIdentitySettingsSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedIdentitySettingsSTATUSARM(gens map[string]gopter.Gen) {
	gens["Resource"] = gen.PtrOf(gen.AlphaString())
}
