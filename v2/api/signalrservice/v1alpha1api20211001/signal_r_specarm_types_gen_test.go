// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20211001

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_SignalR_SPECARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalR_SPECARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalR_SPECARM, SignalR_SPECARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalR_SPECARM runs a test to see if a specific instance of SignalR_SPECARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalR_SPECARM(subject SignalR_SPECARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalR_SPECARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalR_SPECARM instances for property testing - lazily instantiated by SignalR_SPECARMGenerator()
var signalR_specarmGenerator gopter.Gen

// SignalR_SPECARMGenerator returns a generator of SignalR_SPECARM instances for property testing.
// We first initialize signalR_specarmGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SignalR_SPECARMGenerator() gopter.Gen {
	if signalR_specarmGenerator != nil {
		return signalR_specarmGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalR_SPECARM(generators)
	signalR_specarmGenerator = gen.Struct(reflect.TypeOf(SignalR_SPECARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalR_SPECARM(generators)
	AddRelatedPropertyGeneratorsForSignalR_SPECARM(generators)
	signalR_specarmGenerator = gen.Struct(reflect.TypeOf(SignalR_SPECARM{}), generators)

	return signalR_specarmGenerator
}

// AddIndependentPropertyGeneratorsForSignalR_SPECARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalR_SPECARM(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(ServiceKind_SpecRawWebSockets, ServiceKind_SpecSignalR))
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSignalR_SPECARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSignalR_SPECARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedIdentity_SpecARMGenerator())
	gens["Properties"] = gen.PtrOf(SignalRProperties_SpecARMGenerator())
	gens["Sku"] = gen.PtrOf(ResourceSku_SpecARMGenerator())
}

func Test_ManagedIdentity_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedIdentity_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedIdentity_SpecARM, ManagedIdentity_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedIdentity_SpecARM runs a test to see if a specific instance of ManagedIdentity_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedIdentity_SpecARM(subject ManagedIdentity_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedIdentity_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedIdentity_SpecARM instances for property testing - lazily instantiated by
//ManagedIdentity_SpecARMGenerator()
var managedIdentity_specARMGenerator gopter.Gen

// ManagedIdentity_SpecARMGenerator returns a generator of ManagedIdentity_SpecARM instances for property testing.
func ManagedIdentity_SpecARMGenerator() gopter.Gen {
	if managedIdentity_specARMGenerator != nil {
		return managedIdentity_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedIdentity_SpecARM(generators)
	managedIdentity_specARMGenerator = gen.Struct(reflect.TypeOf(ManagedIdentity_SpecARM{}), generators)

	return managedIdentity_specARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedIdentity_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedIdentity_SpecARM(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ManagedIdentityType_SpecNone, ManagedIdentityType_SpecSystemAssigned, ManagedIdentityType_SpecUserAssigned))
}

func Test_ResourceSku_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceSku_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceSku_SpecARM, ResourceSku_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceSku_SpecARM runs a test to see if a specific instance of ResourceSku_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceSku_SpecARM(subject ResourceSku_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceSku_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceSku_SpecARM instances for property testing - lazily instantiated by
//ResourceSku_SpecARMGenerator()
var resourceSku_specARMGenerator gopter.Gen

// ResourceSku_SpecARMGenerator returns a generator of ResourceSku_SpecARM instances for property testing.
func ResourceSku_SpecARMGenerator() gopter.Gen {
	if resourceSku_specARMGenerator != nil {
		return resourceSku_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceSku_SpecARM(generators)
	resourceSku_specARMGenerator = gen.Struct(reflect.TypeOf(ResourceSku_SpecARM{}), generators)

	return resourceSku_specARMGenerator
}

// AddIndependentPropertyGeneratorsForResourceSku_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceSku_SpecARM(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.AlphaString()
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(
		SignalRSkuTier_SpecBasic,
		SignalRSkuTier_SpecFree,
		SignalRSkuTier_SpecPremium,
		SignalRSkuTier_SpecStandard))
}

func Test_SignalRProperties_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRProperties_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRProperties_SpecARM, SignalRProperties_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRProperties_SpecARM runs a test to see if a specific instance of SignalRProperties_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRProperties_SpecARM(subject SignalRProperties_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRProperties_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRProperties_SpecARM instances for property testing - lazily instantiated by
//SignalRProperties_SpecARMGenerator()
var signalRProperties_specARMGenerator gopter.Gen

// SignalRProperties_SpecARMGenerator returns a generator of SignalRProperties_SpecARM instances for property testing.
// We first initialize signalRProperties_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SignalRProperties_SpecARMGenerator() gopter.Gen {
	if signalRProperties_specARMGenerator != nil {
		return signalRProperties_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRProperties_SpecARM(generators)
	signalRProperties_specARMGenerator = gen.Struct(reflect.TypeOf(SignalRProperties_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRProperties_SpecARM(generators)
	AddRelatedPropertyGeneratorsForSignalRProperties_SpecARM(generators)
	signalRProperties_specARMGenerator = gen.Struct(reflect.TypeOf(SignalRProperties_SpecARM{}), generators)

	return signalRProperties_specARMGenerator
}

// AddIndependentPropertyGeneratorsForSignalRProperties_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRProperties_SpecARM(gens map[string]gopter.Gen) {
	gens["DisableAadAuth"] = gen.PtrOf(gen.Bool())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSignalRProperties_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSignalRProperties_SpecARM(gens map[string]gopter.Gen) {
	gens["Cors"] = gen.PtrOf(SignalRCorsSettings_SpecARMGenerator())
	gens["Features"] = gen.SliceOf(SignalRFeature_SpecARMGenerator())
	gens["NetworkACLs"] = gen.PtrOf(SignalRNetworkACLs_SpecARMGenerator())
	gens["ResourceLogConfiguration"] = gen.PtrOf(ResourceLogConfiguration_SpecARMGenerator())
	gens["Tls"] = gen.PtrOf(SignalRTlsSettings_SpecARMGenerator())
	gens["Upstream"] = gen.PtrOf(ServerlessUpstreamSettings_SpecARMGenerator())
}

func Test_ResourceLogConfiguration_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceLogConfiguration_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceLogConfiguration_SpecARM, ResourceLogConfiguration_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceLogConfiguration_SpecARM runs a test to see if a specific instance of ResourceLogConfiguration_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceLogConfiguration_SpecARM(subject ResourceLogConfiguration_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceLogConfiguration_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceLogConfiguration_SpecARM instances for property testing - lazily instantiated by
//ResourceLogConfiguration_SpecARMGenerator()
var resourceLogConfiguration_specARMGenerator gopter.Gen

// ResourceLogConfiguration_SpecARMGenerator returns a generator of ResourceLogConfiguration_SpecARM instances for property testing.
func ResourceLogConfiguration_SpecARMGenerator() gopter.Gen {
	if resourceLogConfiguration_specARMGenerator != nil {
		return resourceLogConfiguration_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForResourceLogConfiguration_SpecARM(generators)
	resourceLogConfiguration_specARMGenerator = gen.Struct(reflect.TypeOf(ResourceLogConfiguration_SpecARM{}), generators)

	return resourceLogConfiguration_specARMGenerator
}

// AddRelatedPropertyGeneratorsForResourceLogConfiguration_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResourceLogConfiguration_SpecARM(gens map[string]gopter.Gen) {
	gens["Categories"] = gen.SliceOf(ResourceLogCategory_SpecARMGenerator())
}

func Test_ServerlessUpstreamSettings_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServerlessUpstreamSettings_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServerlessUpstreamSettings_SpecARM, ServerlessUpstreamSettings_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServerlessUpstreamSettings_SpecARM runs a test to see if a specific instance of ServerlessUpstreamSettings_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForServerlessUpstreamSettings_SpecARM(subject ServerlessUpstreamSettings_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServerlessUpstreamSettings_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServerlessUpstreamSettings_SpecARM instances for property testing - lazily instantiated by
//ServerlessUpstreamSettings_SpecARMGenerator()
var serverlessUpstreamSettings_specARMGenerator gopter.Gen

// ServerlessUpstreamSettings_SpecARMGenerator returns a generator of ServerlessUpstreamSettings_SpecARM instances for property testing.
func ServerlessUpstreamSettings_SpecARMGenerator() gopter.Gen {
	if serverlessUpstreamSettings_specARMGenerator != nil {
		return serverlessUpstreamSettings_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForServerlessUpstreamSettings_SpecARM(generators)
	serverlessUpstreamSettings_specARMGenerator = gen.Struct(reflect.TypeOf(ServerlessUpstreamSettings_SpecARM{}), generators)

	return serverlessUpstreamSettings_specARMGenerator
}

// AddRelatedPropertyGeneratorsForServerlessUpstreamSettings_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForServerlessUpstreamSettings_SpecARM(gens map[string]gopter.Gen) {
	gens["Templates"] = gen.SliceOf(UpstreamTemplate_SpecARMGenerator())
}

func Test_SignalRCorsSettings_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRCorsSettings_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRCorsSettings_SpecARM, SignalRCorsSettings_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRCorsSettings_SpecARM runs a test to see if a specific instance of SignalRCorsSettings_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRCorsSettings_SpecARM(subject SignalRCorsSettings_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRCorsSettings_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRCorsSettings_SpecARM instances for property testing - lazily instantiated by
//SignalRCorsSettings_SpecARMGenerator()
var signalRCorsSettings_specARMGenerator gopter.Gen

// SignalRCorsSettings_SpecARMGenerator returns a generator of SignalRCorsSettings_SpecARM instances for property testing.
func SignalRCorsSettings_SpecARMGenerator() gopter.Gen {
	if signalRCorsSettings_specARMGenerator != nil {
		return signalRCorsSettings_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRCorsSettings_SpecARM(generators)
	signalRCorsSettings_specARMGenerator = gen.Struct(reflect.TypeOf(SignalRCorsSettings_SpecARM{}), generators)

	return signalRCorsSettings_specARMGenerator
}

// AddIndependentPropertyGeneratorsForSignalRCorsSettings_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRCorsSettings_SpecARM(gens map[string]gopter.Gen) {
	gens["AllowedOrigins"] = gen.SliceOf(gen.AlphaString())
}

func Test_SignalRFeature_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRFeature_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRFeature_SpecARM, SignalRFeature_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRFeature_SpecARM runs a test to see if a specific instance of SignalRFeature_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRFeature_SpecARM(subject SignalRFeature_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRFeature_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRFeature_SpecARM instances for property testing - lazily instantiated by
//SignalRFeature_SpecARMGenerator()
var signalRFeature_specARMGenerator gopter.Gen

// SignalRFeature_SpecARMGenerator returns a generator of SignalRFeature_SpecARM instances for property testing.
func SignalRFeature_SpecARMGenerator() gopter.Gen {
	if signalRFeature_specARMGenerator != nil {
		return signalRFeature_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRFeature_SpecARM(generators)
	signalRFeature_specARMGenerator = gen.Struct(reflect.TypeOf(SignalRFeature_SpecARM{}), generators)

	return signalRFeature_specARMGenerator
}

// AddIndependentPropertyGeneratorsForSignalRFeature_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRFeature_SpecARM(gens map[string]gopter.Gen) {
	gens["Flag"] = gen.OneConstOf(
		FeatureFlags_SpecEnableConnectivityLogs,
		FeatureFlags_SpecEnableLiveTrace,
		FeatureFlags_SpecEnableMessagingLogs,
		FeatureFlags_SpecServiceMode)
	gens["Properties"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Value"] = gen.AlphaString()
}

func Test_SignalRNetworkACLs_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRNetworkACLs_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRNetworkACLs_SpecARM, SignalRNetworkACLs_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRNetworkACLs_SpecARM runs a test to see if a specific instance of SignalRNetworkACLs_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRNetworkACLs_SpecARM(subject SignalRNetworkACLs_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRNetworkACLs_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRNetworkACLs_SpecARM instances for property testing - lazily instantiated by
//SignalRNetworkACLs_SpecARMGenerator()
var signalRNetworkACLs_specARMGenerator gopter.Gen

// SignalRNetworkACLs_SpecARMGenerator returns a generator of SignalRNetworkACLs_SpecARM instances for property testing.
// We first initialize signalRNetworkACLs_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SignalRNetworkACLs_SpecARMGenerator() gopter.Gen {
	if signalRNetworkACLs_specARMGenerator != nil {
		return signalRNetworkACLs_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRNetworkACLs_SpecARM(generators)
	signalRNetworkACLs_specARMGenerator = gen.Struct(reflect.TypeOf(SignalRNetworkACLs_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRNetworkACLs_SpecARM(generators)
	AddRelatedPropertyGeneratorsForSignalRNetworkACLs_SpecARM(generators)
	signalRNetworkACLs_specARMGenerator = gen.Struct(reflect.TypeOf(SignalRNetworkACLs_SpecARM{}), generators)

	return signalRNetworkACLs_specARMGenerator
}

// AddIndependentPropertyGeneratorsForSignalRNetworkACLs_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRNetworkACLs_SpecARM(gens map[string]gopter.Gen) {
	gens["DefaultAction"] = gen.PtrOf(gen.OneConstOf(ACLAction_SpecAllow, ACLAction_SpecDeny))
}

// AddRelatedPropertyGeneratorsForSignalRNetworkACLs_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSignalRNetworkACLs_SpecARM(gens map[string]gopter.Gen) {
	gens["PrivateEndpoints"] = gen.SliceOf(PrivateEndpointACL_SpecARMGenerator())
	gens["PublicNetwork"] = gen.PtrOf(NetworkACL_SpecARMGenerator())
}

func Test_SignalRTlsSettings_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRTlsSettings_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRTlsSettings_SpecARM, SignalRTlsSettings_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRTlsSettings_SpecARM runs a test to see if a specific instance of SignalRTlsSettings_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRTlsSettings_SpecARM(subject SignalRTlsSettings_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRTlsSettings_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRTlsSettings_SpecARM instances for property testing - lazily instantiated by
//SignalRTlsSettings_SpecARMGenerator()
var signalRTlsSettings_specARMGenerator gopter.Gen

// SignalRTlsSettings_SpecARMGenerator returns a generator of SignalRTlsSettings_SpecARM instances for property testing.
func SignalRTlsSettings_SpecARMGenerator() gopter.Gen {
	if signalRTlsSettings_specARMGenerator != nil {
		return signalRTlsSettings_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRTlsSettings_SpecARM(generators)
	signalRTlsSettings_specARMGenerator = gen.Struct(reflect.TypeOf(SignalRTlsSettings_SpecARM{}), generators)

	return signalRTlsSettings_specARMGenerator
}

// AddIndependentPropertyGeneratorsForSignalRTlsSettings_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRTlsSettings_SpecARM(gens map[string]gopter.Gen) {
	gens["ClientCertEnabled"] = gen.PtrOf(gen.Bool())
}

func Test_NetworkACL_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkACL_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkACL_SpecARM, NetworkACL_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkACL_SpecARM runs a test to see if a specific instance of NetworkACL_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkACL_SpecARM(subject NetworkACL_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkACL_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkACL_SpecARM instances for property testing - lazily instantiated by NetworkACL_SpecARMGenerator()
var networkACL_specARMGenerator gopter.Gen

// NetworkACL_SpecARMGenerator returns a generator of NetworkACL_SpecARM instances for property testing.
func NetworkACL_SpecARMGenerator() gopter.Gen {
	if networkACL_specARMGenerator != nil {
		return networkACL_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkACL_SpecARM(generators)
	networkACL_specARMGenerator = gen.Struct(reflect.TypeOf(NetworkACL_SpecARM{}), generators)

	return networkACL_specARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkACL_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkACL_SpecARM(gens map[string]gopter.Gen) {
	gens["Allow"] = gen.SliceOf(gen.OneConstOf(
		SignalRRequestType_SpecClientConnection,
		SignalRRequestType_SpecRESTAPI,
		SignalRRequestType_SpecServerConnection,
		SignalRRequestType_SpecTrace))
	gens["Deny"] = gen.SliceOf(gen.OneConstOf(
		SignalRRequestType_SpecClientConnection,
		SignalRRequestType_SpecRESTAPI,
		SignalRRequestType_SpecServerConnection,
		SignalRRequestType_SpecTrace))
}

func Test_PrivateEndpointACL_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointACL_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointACL_SpecARM, PrivateEndpointACL_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointACL_SpecARM runs a test to see if a specific instance of PrivateEndpointACL_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointACL_SpecARM(subject PrivateEndpointACL_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointACL_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointACL_SpecARM instances for property testing - lazily instantiated by
//PrivateEndpointACL_SpecARMGenerator()
var privateEndpointACL_specARMGenerator gopter.Gen

// PrivateEndpointACL_SpecARMGenerator returns a generator of PrivateEndpointACL_SpecARM instances for property testing.
func PrivateEndpointACL_SpecARMGenerator() gopter.Gen {
	if privateEndpointACL_specARMGenerator != nil {
		return privateEndpointACL_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointACL_SpecARM(generators)
	privateEndpointACL_specARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointACL_SpecARM{}), generators)

	return privateEndpointACL_specARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointACL_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointACL_SpecARM(gens map[string]gopter.Gen) {
	gens["Allow"] = gen.SliceOf(gen.OneConstOf(
		SignalRRequestType_SpecClientConnection,
		SignalRRequestType_SpecRESTAPI,
		SignalRRequestType_SpecServerConnection,
		SignalRRequestType_SpecTrace))
	gens["Deny"] = gen.SliceOf(gen.OneConstOf(
		SignalRRequestType_SpecClientConnection,
		SignalRRequestType_SpecRESTAPI,
		SignalRRequestType_SpecServerConnection,
		SignalRRequestType_SpecTrace))
	gens["Name"] = gen.AlphaString()
}

func Test_ResourceLogCategory_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceLogCategory_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceLogCategory_SpecARM, ResourceLogCategory_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceLogCategory_SpecARM runs a test to see if a specific instance of ResourceLogCategory_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceLogCategory_SpecARM(subject ResourceLogCategory_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceLogCategory_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceLogCategory_SpecARM instances for property testing - lazily instantiated by
//ResourceLogCategory_SpecARMGenerator()
var resourceLogCategory_specARMGenerator gopter.Gen

// ResourceLogCategory_SpecARMGenerator returns a generator of ResourceLogCategory_SpecARM instances for property testing.
func ResourceLogCategory_SpecARMGenerator() gopter.Gen {
	if resourceLogCategory_specARMGenerator != nil {
		return resourceLogCategory_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceLogCategory_SpecARM(generators)
	resourceLogCategory_specARMGenerator = gen.Struct(reflect.TypeOf(ResourceLogCategory_SpecARM{}), generators)

	return resourceLogCategory_specARMGenerator
}

// AddIndependentPropertyGeneratorsForResourceLogCategory_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceLogCategory_SpecARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_UpstreamTemplate_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UpstreamTemplate_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUpstreamTemplate_SpecARM, UpstreamTemplate_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUpstreamTemplate_SpecARM runs a test to see if a specific instance of UpstreamTemplate_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUpstreamTemplate_SpecARM(subject UpstreamTemplate_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UpstreamTemplate_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UpstreamTemplate_SpecARM instances for property testing - lazily instantiated by
//UpstreamTemplate_SpecARMGenerator()
var upstreamTemplate_specARMGenerator gopter.Gen

// UpstreamTemplate_SpecARMGenerator returns a generator of UpstreamTemplate_SpecARM instances for property testing.
// We first initialize upstreamTemplate_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UpstreamTemplate_SpecARMGenerator() gopter.Gen {
	if upstreamTemplate_specARMGenerator != nil {
		return upstreamTemplate_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpstreamTemplate_SpecARM(generators)
	upstreamTemplate_specARMGenerator = gen.Struct(reflect.TypeOf(UpstreamTemplate_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpstreamTemplate_SpecARM(generators)
	AddRelatedPropertyGeneratorsForUpstreamTemplate_SpecARM(generators)
	upstreamTemplate_specARMGenerator = gen.Struct(reflect.TypeOf(UpstreamTemplate_SpecARM{}), generators)

	return upstreamTemplate_specARMGenerator
}

// AddIndependentPropertyGeneratorsForUpstreamTemplate_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUpstreamTemplate_SpecARM(gens map[string]gopter.Gen) {
	gens["CategoryPattern"] = gen.PtrOf(gen.AlphaString())
	gens["EventPattern"] = gen.PtrOf(gen.AlphaString())
	gens["HubPattern"] = gen.PtrOf(gen.AlphaString())
	gens["UrlTemplate"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForUpstreamTemplate_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUpstreamTemplate_SpecARM(gens map[string]gopter.Gen) {
	gens["Auth"] = gen.PtrOf(UpstreamAuthSettings_SpecARMGenerator())
}

func Test_UpstreamAuthSettings_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UpstreamAuthSettings_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUpstreamAuthSettings_SpecARM, UpstreamAuthSettings_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUpstreamAuthSettings_SpecARM runs a test to see if a specific instance of UpstreamAuthSettings_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUpstreamAuthSettings_SpecARM(subject UpstreamAuthSettings_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UpstreamAuthSettings_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UpstreamAuthSettings_SpecARM instances for property testing - lazily instantiated by
//UpstreamAuthSettings_SpecARMGenerator()
var upstreamAuthSettings_specARMGenerator gopter.Gen

// UpstreamAuthSettings_SpecARMGenerator returns a generator of UpstreamAuthSettings_SpecARM instances for property testing.
// We first initialize upstreamAuthSettings_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UpstreamAuthSettings_SpecARMGenerator() gopter.Gen {
	if upstreamAuthSettings_specARMGenerator != nil {
		return upstreamAuthSettings_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpstreamAuthSettings_SpecARM(generators)
	upstreamAuthSettings_specARMGenerator = gen.Struct(reflect.TypeOf(UpstreamAuthSettings_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpstreamAuthSettings_SpecARM(generators)
	AddRelatedPropertyGeneratorsForUpstreamAuthSettings_SpecARM(generators)
	upstreamAuthSettings_specARMGenerator = gen.Struct(reflect.TypeOf(UpstreamAuthSettings_SpecARM{}), generators)

	return upstreamAuthSettings_specARMGenerator
}

// AddIndependentPropertyGeneratorsForUpstreamAuthSettings_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUpstreamAuthSettings_SpecARM(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(UpstreamAuthType_SpecManagedIdentity, UpstreamAuthType_SpecNone))
}

// AddRelatedPropertyGeneratorsForUpstreamAuthSettings_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUpstreamAuthSettings_SpecARM(gens map[string]gopter.Gen) {
	gens["ManagedIdentity"] = gen.PtrOf(ManagedIdentitySettings_SpecARMGenerator())
}

func Test_ManagedIdentitySettings_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedIdentitySettings_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedIdentitySettings_SpecARM, ManagedIdentitySettings_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedIdentitySettings_SpecARM runs a test to see if a specific instance of ManagedIdentitySettings_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedIdentitySettings_SpecARM(subject ManagedIdentitySettings_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedIdentitySettings_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedIdentitySettings_SpecARM instances for property testing - lazily instantiated by
//ManagedIdentitySettings_SpecARMGenerator()
var managedIdentitySettings_specARMGenerator gopter.Gen

// ManagedIdentitySettings_SpecARMGenerator returns a generator of ManagedIdentitySettings_SpecARM instances for property testing.
func ManagedIdentitySettings_SpecARMGenerator() gopter.Gen {
	if managedIdentitySettings_specARMGenerator != nil {
		return managedIdentitySettings_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedIdentitySettings_SpecARM(generators)
	managedIdentitySettings_specARMGenerator = gen.Struct(reflect.TypeOf(ManagedIdentitySettings_SpecARM{}), generators)

	return managedIdentitySettings_specARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedIdentitySettings_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedIdentitySettings_SpecARM(gens map[string]gopter.Gen) {
	gens["Resource"] = gen.PtrOf(gen.AlphaString())
}
