// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20211001

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_SignalR_SPECARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalR_SPECARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRSPECARM, SignalRSPECARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRSPECARM runs a test to see if a specific instance of SignalR_SPECARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRSPECARM(subject SignalR_SPECARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalR_SPECARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalR_SPECARM instances for property testing - lazily instantiated by SignalRSPECARMGenerator()
var signalRSPECARMGenerator gopter.Gen

// SignalRSPECARMGenerator returns a generator of SignalR_SPECARM instances for property testing.
// We first initialize signalRSPECARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SignalRSPECARMGenerator() gopter.Gen {
	if signalRSPECARMGenerator != nil {
		return signalRSPECARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRSPECARM(generators)
	signalRSPECARMGenerator = gen.Struct(reflect.TypeOf(SignalR_SPECARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRSPECARM(generators)
	AddRelatedPropertyGeneratorsForSignalRSPECARM(generators)
	signalRSPECARMGenerator = gen.Struct(reflect.TypeOf(SignalR_SPECARM{}), generators)

	return signalRSPECARMGenerator
}

// AddIndependentPropertyGeneratorsForSignalRSPECARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRSPECARM(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(ServiceKind_SpecRawWebSockets, ServiceKind_SpecSignalR))
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSignalRSPECARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSignalRSPECARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedIdentitySpecARMGenerator())
	gens["Properties"] = gen.PtrOf(SignalRPropertiesSpecARMGenerator())
	gens["Sku"] = gen.PtrOf(ResourceSkuSpecARMGenerator())
}

func Test_ManagedIdentity_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedIdentity_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedIdentitySpecARM, ManagedIdentitySpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedIdentitySpecARM runs a test to see if a specific instance of ManagedIdentity_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedIdentitySpecARM(subject ManagedIdentity_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedIdentity_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedIdentity_SpecARM instances for property testing - lazily instantiated by
//ManagedIdentitySpecARMGenerator()
var managedIdentitySpecARMGenerator gopter.Gen

// ManagedIdentitySpecARMGenerator returns a generator of ManagedIdentity_SpecARM instances for property testing.
func ManagedIdentitySpecARMGenerator() gopter.Gen {
	if managedIdentitySpecARMGenerator != nil {
		return managedIdentitySpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedIdentitySpecARM(generators)
	managedIdentitySpecARMGenerator = gen.Struct(reflect.TypeOf(ManagedIdentity_SpecARM{}), generators)

	return managedIdentitySpecARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedIdentitySpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedIdentitySpecARM(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ManagedIdentityType_SpecNone, ManagedIdentityType_SpecSystemAssigned, ManagedIdentityType_SpecUserAssigned))
}

func Test_ResourceSku_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceSku_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceSkuSpecARM, ResourceSkuSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceSkuSpecARM runs a test to see if a specific instance of ResourceSku_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceSkuSpecARM(subject ResourceSku_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceSku_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceSku_SpecARM instances for property testing - lazily instantiated by ResourceSkuSpecARMGenerator()
var resourceSkuSpecARMGenerator gopter.Gen

// ResourceSkuSpecARMGenerator returns a generator of ResourceSku_SpecARM instances for property testing.
func ResourceSkuSpecARMGenerator() gopter.Gen {
	if resourceSkuSpecARMGenerator != nil {
		return resourceSkuSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceSkuSpecARM(generators)
	resourceSkuSpecARMGenerator = gen.Struct(reflect.TypeOf(ResourceSku_SpecARM{}), generators)

	return resourceSkuSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForResourceSkuSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceSkuSpecARM(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.AlphaString()
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(
		SignalRSkuTier_SpecBasic,
		SignalRSkuTier_SpecFree,
		SignalRSkuTier_SpecPremium,
		SignalRSkuTier_SpecStandard))
}

func Test_SignalRProperties_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRProperties_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRPropertiesSpecARM, SignalRPropertiesSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRPropertiesSpecARM runs a test to see if a specific instance of SignalRProperties_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRPropertiesSpecARM(subject SignalRProperties_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRProperties_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRProperties_SpecARM instances for property testing - lazily instantiated by
//SignalRPropertiesSpecARMGenerator()
var signalRPropertiesSpecARMGenerator gopter.Gen

// SignalRPropertiesSpecARMGenerator returns a generator of SignalRProperties_SpecARM instances for property testing.
// We first initialize signalRPropertiesSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SignalRPropertiesSpecARMGenerator() gopter.Gen {
	if signalRPropertiesSpecARMGenerator != nil {
		return signalRPropertiesSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRPropertiesSpecARM(generators)
	signalRPropertiesSpecARMGenerator = gen.Struct(reflect.TypeOf(SignalRProperties_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRPropertiesSpecARM(generators)
	AddRelatedPropertyGeneratorsForSignalRPropertiesSpecARM(generators)
	signalRPropertiesSpecARMGenerator = gen.Struct(reflect.TypeOf(SignalRProperties_SpecARM{}), generators)

	return signalRPropertiesSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForSignalRPropertiesSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRPropertiesSpecARM(gens map[string]gopter.Gen) {
	gens["DisableAadAuth"] = gen.PtrOf(gen.Bool())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSignalRPropertiesSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSignalRPropertiesSpecARM(gens map[string]gopter.Gen) {
	gens["Cors"] = gen.PtrOf(SignalRCorsSettingsSpecARMGenerator())
	gens["Features"] = gen.SliceOf(SignalRFeatureSpecARMGenerator())
	gens["NetworkACLs"] = gen.PtrOf(SignalRNetworkACLsSpecARMGenerator())
	gens["ResourceLogConfiguration"] = gen.PtrOf(ResourceLogConfigurationSpecARMGenerator())
	gens["Tls"] = gen.PtrOf(SignalRTlsSettingsSpecARMGenerator())
	gens["Upstream"] = gen.PtrOf(ServerlessUpstreamSettingsSpecARMGenerator())
}

func Test_ResourceLogConfiguration_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceLogConfiguration_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceLogConfigurationSpecARM, ResourceLogConfigurationSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceLogConfigurationSpecARM runs a test to see if a specific instance of ResourceLogConfiguration_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceLogConfigurationSpecARM(subject ResourceLogConfiguration_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceLogConfiguration_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceLogConfiguration_SpecARM instances for property testing - lazily instantiated by
//ResourceLogConfigurationSpecARMGenerator()
var resourceLogConfigurationSpecARMGenerator gopter.Gen

// ResourceLogConfigurationSpecARMGenerator returns a generator of ResourceLogConfiguration_SpecARM instances for property testing.
func ResourceLogConfigurationSpecARMGenerator() gopter.Gen {
	if resourceLogConfigurationSpecARMGenerator != nil {
		return resourceLogConfigurationSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForResourceLogConfigurationSpecARM(generators)
	resourceLogConfigurationSpecARMGenerator = gen.Struct(reflect.TypeOf(ResourceLogConfiguration_SpecARM{}), generators)

	return resourceLogConfigurationSpecARMGenerator
}

// AddRelatedPropertyGeneratorsForResourceLogConfigurationSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResourceLogConfigurationSpecARM(gens map[string]gopter.Gen) {
	gens["Categories"] = gen.SliceOf(ResourceLogCategorySpecARMGenerator())
}

func Test_ServerlessUpstreamSettings_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServerlessUpstreamSettings_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServerlessUpstreamSettingsSpecARM, ServerlessUpstreamSettingsSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServerlessUpstreamSettingsSpecARM runs a test to see if a specific instance of ServerlessUpstreamSettings_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForServerlessUpstreamSettingsSpecARM(subject ServerlessUpstreamSettings_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServerlessUpstreamSettings_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServerlessUpstreamSettings_SpecARM instances for property testing - lazily instantiated by
//ServerlessUpstreamSettingsSpecARMGenerator()
var serverlessUpstreamSettingsSpecARMGenerator gopter.Gen

// ServerlessUpstreamSettingsSpecARMGenerator returns a generator of ServerlessUpstreamSettings_SpecARM instances for property testing.
func ServerlessUpstreamSettingsSpecARMGenerator() gopter.Gen {
	if serverlessUpstreamSettingsSpecARMGenerator != nil {
		return serverlessUpstreamSettingsSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForServerlessUpstreamSettingsSpecARM(generators)
	serverlessUpstreamSettingsSpecARMGenerator = gen.Struct(reflect.TypeOf(ServerlessUpstreamSettings_SpecARM{}), generators)

	return serverlessUpstreamSettingsSpecARMGenerator
}

// AddRelatedPropertyGeneratorsForServerlessUpstreamSettingsSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForServerlessUpstreamSettingsSpecARM(gens map[string]gopter.Gen) {
	gens["Templates"] = gen.SliceOf(UpstreamTemplateSpecARMGenerator())
}

func Test_SignalRCorsSettings_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRCorsSettings_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRCorsSettingsSpecARM, SignalRCorsSettingsSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRCorsSettingsSpecARM runs a test to see if a specific instance of SignalRCorsSettings_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRCorsSettingsSpecARM(subject SignalRCorsSettings_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRCorsSettings_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRCorsSettings_SpecARM instances for property testing - lazily instantiated by
//SignalRCorsSettingsSpecARMGenerator()
var signalRCorsSettingsSpecARMGenerator gopter.Gen

// SignalRCorsSettingsSpecARMGenerator returns a generator of SignalRCorsSettings_SpecARM instances for property testing.
func SignalRCorsSettingsSpecARMGenerator() gopter.Gen {
	if signalRCorsSettingsSpecARMGenerator != nil {
		return signalRCorsSettingsSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRCorsSettingsSpecARM(generators)
	signalRCorsSettingsSpecARMGenerator = gen.Struct(reflect.TypeOf(SignalRCorsSettings_SpecARM{}), generators)

	return signalRCorsSettingsSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForSignalRCorsSettingsSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRCorsSettingsSpecARM(gens map[string]gopter.Gen) {
	gens["AllowedOrigins"] = gen.SliceOf(gen.AlphaString())
}

func Test_SignalRFeature_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRFeature_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRFeatureSpecARM, SignalRFeatureSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRFeatureSpecARM runs a test to see if a specific instance of SignalRFeature_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRFeatureSpecARM(subject SignalRFeature_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRFeature_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRFeature_SpecARM instances for property testing - lazily instantiated by
//SignalRFeatureSpecARMGenerator()
var signalRFeatureSpecARMGenerator gopter.Gen

// SignalRFeatureSpecARMGenerator returns a generator of SignalRFeature_SpecARM instances for property testing.
func SignalRFeatureSpecARMGenerator() gopter.Gen {
	if signalRFeatureSpecARMGenerator != nil {
		return signalRFeatureSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRFeatureSpecARM(generators)
	signalRFeatureSpecARMGenerator = gen.Struct(reflect.TypeOf(SignalRFeature_SpecARM{}), generators)

	return signalRFeatureSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForSignalRFeatureSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRFeatureSpecARM(gens map[string]gopter.Gen) {
	gens["Flag"] = gen.OneConstOf(
		FeatureFlags_SpecEnableConnectivityLogs,
		FeatureFlags_SpecEnableLiveTrace,
		FeatureFlags_SpecEnableMessagingLogs,
		FeatureFlags_SpecServiceMode)
	gens["Properties"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Value"] = gen.AlphaString()
}

func Test_SignalRNetworkACLs_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRNetworkACLs_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRNetworkACLsSpecARM, SignalRNetworkACLsSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRNetworkACLsSpecARM runs a test to see if a specific instance of SignalRNetworkACLs_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRNetworkACLsSpecARM(subject SignalRNetworkACLs_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRNetworkACLs_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRNetworkACLs_SpecARM instances for property testing - lazily instantiated by
//SignalRNetworkACLsSpecARMGenerator()
var signalRNetworkACLsSpecARMGenerator gopter.Gen

// SignalRNetworkACLsSpecARMGenerator returns a generator of SignalRNetworkACLs_SpecARM instances for property testing.
// We first initialize signalRNetworkACLsSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SignalRNetworkACLsSpecARMGenerator() gopter.Gen {
	if signalRNetworkACLsSpecARMGenerator != nil {
		return signalRNetworkACLsSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRNetworkACLsSpecARM(generators)
	signalRNetworkACLsSpecARMGenerator = gen.Struct(reflect.TypeOf(SignalRNetworkACLs_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRNetworkACLsSpecARM(generators)
	AddRelatedPropertyGeneratorsForSignalRNetworkACLsSpecARM(generators)
	signalRNetworkACLsSpecARMGenerator = gen.Struct(reflect.TypeOf(SignalRNetworkACLs_SpecARM{}), generators)

	return signalRNetworkACLsSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForSignalRNetworkACLsSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRNetworkACLsSpecARM(gens map[string]gopter.Gen) {
	gens["DefaultAction"] = gen.PtrOf(gen.OneConstOf(ACLAction_SpecAllow, ACLAction_SpecDeny))
}

// AddRelatedPropertyGeneratorsForSignalRNetworkACLsSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSignalRNetworkACLsSpecARM(gens map[string]gopter.Gen) {
	gens["PrivateEndpoints"] = gen.SliceOf(PrivateEndpointACLSpecARMGenerator())
	gens["PublicNetwork"] = gen.PtrOf(NetworkACLSpecARMGenerator())
}

func Test_SignalRTlsSettings_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRTlsSettings_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRTlsSettingsSpecARM, SignalRTlsSettingsSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRTlsSettingsSpecARM runs a test to see if a specific instance of SignalRTlsSettings_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRTlsSettingsSpecARM(subject SignalRTlsSettings_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRTlsSettings_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRTlsSettings_SpecARM instances for property testing - lazily instantiated by
//SignalRTlsSettingsSpecARMGenerator()
var signalRTlsSettingsSpecARMGenerator gopter.Gen

// SignalRTlsSettingsSpecARMGenerator returns a generator of SignalRTlsSettings_SpecARM instances for property testing.
func SignalRTlsSettingsSpecARMGenerator() gopter.Gen {
	if signalRTlsSettingsSpecARMGenerator != nil {
		return signalRTlsSettingsSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRTlsSettingsSpecARM(generators)
	signalRTlsSettingsSpecARMGenerator = gen.Struct(reflect.TypeOf(SignalRTlsSettings_SpecARM{}), generators)

	return signalRTlsSettingsSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForSignalRTlsSettingsSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRTlsSettingsSpecARM(gens map[string]gopter.Gen) {
	gens["ClientCertEnabled"] = gen.PtrOf(gen.Bool())
}

func Test_NetworkACL_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkACL_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkACLSpecARM, NetworkACLSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkACLSpecARM runs a test to see if a specific instance of NetworkACL_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkACLSpecARM(subject NetworkACL_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkACL_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkACL_SpecARM instances for property testing - lazily instantiated by NetworkACLSpecARMGenerator()
var networkACLSpecARMGenerator gopter.Gen

// NetworkACLSpecARMGenerator returns a generator of NetworkACL_SpecARM instances for property testing.
func NetworkACLSpecARMGenerator() gopter.Gen {
	if networkACLSpecARMGenerator != nil {
		return networkACLSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkACLSpecARM(generators)
	networkACLSpecARMGenerator = gen.Struct(reflect.TypeOf(NetworkACL_SpecARM{}), generators)

	return networkACLSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkACLSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkACLSpecARM(gens map[string]gopter.Gen) {
	gens["Allow"] = gen.SliceOf(gen.OneConstOf(
		SignalRRequestType_SpecClientConnection,
		SignalRRequestType_SpecRESTAPI,
		SignalRRequestType_SpecServerConnection,
		SignalRRequestType_SpecTrace))
	gens["Deny"] = gen.SliceOf(gen.OneConstOf(
		SignalRRequestType_SpecClientConnection,
		SignalRRequestType_SpecRESTAPI,
		SignalRRequestType_SpecServerConnection,
		SignalRRequestType_SpecTrace))
}

func Test_PrivateEndpointACL_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointACL_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointACLSpecARM, PrivateEndpointACLSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointACLSpecARM runs a test to see if a specific instance of PrivateEndpointACL_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointACLSpecARM(subject PrivateEndpointACL_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointACL_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointACL_SpecARM instances for property testing - lazily instantiated by
//PrivateEndpointACLSpecARMGenerator()
var privateEndpointACLSpecARMGenerator gopter.Gen

// PrivateEndpointACLSpecARMGenerator returns a generator of PrivateEndpointACL_SpecARM instances for property testing.
func PrivateEndpointACLSpecARMGenerator() gopter.Gen {
	if privateEndpointACLSpecARMGenerator != nil {
		return privateEndpointACLSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointACLSpecARM(generators)
	privateEndpointACLSpecARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointACL_SpecARM{}), generators)

	return privateEndpointACLSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointACLSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointACLSpecARM(gens map[string]gopter.Gen) {
	gens["Allow"] = gen.SliceOf(gen.OneConstOf(
		SignalRRequestType_SpecClientConnection,
		SignalRRequestType_SpecRESTAPI,
		SignalRRequestType_SpecServerConnection,
		SignalRRequestType_SpecTrace))
	gens["Deny"] = gen.SliceOf(gen.OneConstOf(
		SignalRRequestType_SpecClientConnection,
		SignalRRequestType_SpecRESTAPI,
		SignalRRequestType_SpecServerConnection,
		SignalRRequestType_SpecTrace))
	gens["Name"] = gen.AlphaString()
}

func Test_ResourceLogCategory_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceLogCategory_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceLogCategorySpecARM, ResourceLogCategorySpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceLogCategorySpecARM runs a test to see if a specific instance of ResourceLogCategory_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceLogCategorySpecARM(subject ResourceLogCategory_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceLogCategory_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceLogCategory_SpecARM instances for property testing - lazily instantiated by
//ResourceLogCategorySpecARMGenerator()
var resourceLogCategorySpecARMGenerator gopter.Gen

// ResourceLogCategorySpecARMGenerator returns a generator of ResourceLogCategory_SpecARM instances for property testing.
func ResourceLogCategorySpecARMGenerator() gopter.Gen {
	if resourceLogCategorySpecARMGenerator != nil {
		return resourceLogCategorySpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceLogCategorySpecARM(generators)
	resourceLogCategorySpecARMGenerator = gen.Struct(reflect.TypeOf(ResourceLogCategory_SpecARM{}), generators)

	return resourceLogCategorySpecARMGenerator
}

// AddIndependentPropertyGeneratorsForResourceLogCategorySpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceLogCategorySpecARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_UpstreamTemplate_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UpstreamTemplate_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUpstreamTemplateSpecARM, UpstreamTemplateSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUpstreamTemplateSpecARM runs a test to see if a specific instance of UpstreamTemplate_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUpstreamTemplateSpecARM(subject UpstreamTemplate_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UpstreamTemplate_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UpstreamTemplate_SpecARM instances for property testing - lazily instantiated by
//UpstreamTemplateSpecARMGenerator()
var upstreamTemplateSpecARMGenerator gopter.Gen

// UpstreamTemplateSpecARMGenerator returns a generator of UpstreamTemplate_SpecARM instances for property testing.
// We first initialize upstreamTemplateSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UpstreamTemplateSpecARMGenerator() gopter.Gen {
	if upstreamTemplateSpecARMGenerator != nil {
		return upstreamTemplateSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpstreamTemplateSpecARM(generators)
	upstreamTemplateSpecARMGenerator = gen.Struct(reflect.TypeOf(UpstreamTemplate_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpstreamTemplateSpecARM(generators)
	AddRelatedPropertyGeneratorsForUpstreamTemplateSpecARM(generators)
	upstreamTemplateSpecARMGenerator = gen.Struct(reflect.TypeOf(UpstreamTemplate_SpecARM{}), generators)

	return upstreamTemplateSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForUpstreamTemplateSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUpstreamTemplateSpecARM(gens map[string]gopter.Gen) {
	gens["CategoryPattern"] = gen.PtrOf(gen.AlphaString())
	gens["EventPattern"] = gen.PtrOf(gen.AlphaString())
	gens["HubPattern"] = gen.PtrOf(gen.AlphaString())
	gens["UrlTemplate"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForUpstreamTemplateSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUpstreamTemplateSpecARM(gens map[string]gopter.Gen) {
	gens["Auth"] = gen.PtrOf(UpstreamAuthSettingsSpecARMGenerator())
}

func Test_UpstreamAuthSettings_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UpstreamAuthSettings_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUpstreamAuthSettingsSpecARM, UpstreamAuthSettingsSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUpstreamAuthSettingsSpecARM runs a test to see if a specific instance of UpstreamAuthSettings_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUpstreamAuthSettingsSpecARM(subject UpstreamAuthSettings_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UpstreamAuthSettings_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UpstreamAuthSettings_SpecARM instances for property testing - lazily instantiated by
//UpstreamAuthSettingsSpecARMGenerator()
var upstreamAuthSettingsSpecARMGenerator gopter.Gen

// UpstreamAuthSettingsSpecARMGenerator returns a generator of UpstreamAuthSettings_SpecARM instances for property testing.
// We first initialize upstreamAuthSettingsSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UpstreamAuthSettingsSpecARMGenerator() gopter.Gen {
	if upstreamAuthSettingsSpecARMGenerator != nil {
		return upstreamAuthSettingsSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpstreamAuthSettingsSpecARM(generators)
	upstreamAuthSettingsSpecARMGenerator = gen.Struct(reflect.TypeOf(UpstreamAuthSettings_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpstreamAuthSettingsSpecARM(generators)
	AddRelatedPropertyGeneratorsForUpstreamAuthSettingsSpecARM(generators)
	upstreamAuthSettingsSpecARMGenerator = gen.Struct(reflect.TypeOf(UpstreamAuthSettings_SpecARM{}), generators)

	return upstreamAuthSettingsSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForUpstreamAuthSettingsSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUpstreamAuthSettingsSpecARM(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(UpstreamAuthType_SpecManagedIdentity, UpstreamAuthType_SpecNone))
}

// AddRelatedPropertyGeneratorsForUpstreamAuthSettingsSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUpstreamAuthSettingsSpecARM(gens map[string]gopter.Gen) {
	gens["ManagedIdentity"] = gen.PtrOf(ManagedIdentitySettingsSpecARMGenerator())
}

func Test_ManagedIdentitySettings_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedIdentitySettings_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedIdentitySettingsSpecARM, ManagedIdentitySettingsSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedIdentitySettingsSpecARM runs a test to see if a specific instance of ManagedIdentitySettings_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedIdentitySettingsSpecARM(subject ManagedIdentitySettings_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedIdentitySettings_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedIdentitySettings_SpecARM instances for property testing - lazily instantiated by
//ManagedIdentitySettingsSpecARMGenerator()
var managedIdentitySettingsSpecARMGenerator gopter.Gen

// ManagedIdentitySettingsSpecARMGenerator returns a generator of ManagedIdentitySettings_SpecARM instances for property testing.
func ManagedIdentitySettingsSpecARMGenerator() gopter.Gen {
	if managedIdentitySettingsSpecARMGenerator != nil {
		return managedIdentitySettingsSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedIdentitySettingsSpecARM(generators)
	managedIdentitySettingsSpecARMGenerator = gen.Struct(reflect.TypeOf(ManagedIdentitySettings_SpecARM{}), generators)

	return managedIdentitySettingsSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedIdentitySettingsSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedIdentitySettingsSpecARM(gens map[string]gopter.Gen) {
	gens["Resource"] = gen.PtrOf(gen.AlphaString())
}
