// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20211001

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_SignalR_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalR_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalR_SpecARM, SignalR_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalR_SpecARM runs a test to see if a specific instance of SignalR_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalR_SpecARM(subject SignalR_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalR_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalR_SpecARM instances for property testing - lazily instantiated by SignalR_SpecARMGenerator()
var signalR_SpecARMGenerator gopter.Gen

// SignalR_SpecARMGenerator returns a generator of SignalR_SpecARM instances for property testing.
// We first initialize signalR_SpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SignalR_SpecARMGenerator() gopter.Gen {
	if signalR_SpecARMGenerator != nil {
		return signalR_SpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalR_SpecARM(generators)
	signalR_SpecARMGenerator = gen.Struct(reflect.TypeOf(SignalR_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalR_SpecARM(generators)
	AddRelatedPropertyGeneratorsForSignalR_SpecARM(generators)
	signalR_SpecARMGenerator = gen.Struct(reflect.TypeOf(SignalR_SpecARM{}), generators)

	return signalR_SpecARMGenerator
}

// AddIndependentPropertyGeneratorsForSignalR_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalR_SpecARM(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(ServiceKind_RawWebSockets, ServiceKind_SignalR))
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSignalR_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSignalR_SpecARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedIdentityARMGenerator())
	gens["Properties"] = gen.PtrOf(SignalRPropertiesARMGenerator())
	gens["Sku"] = gen.PtrOf(ResourceSkuARMGenerator())
	gens["SystemData"] = gen.PtrOf(SystemDataARMGenerator())
}

func Test_ManagedIdentityARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedIdentityARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedIdentityARM, ManagedIdentityARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedIdentityARM runs a test to see if a specific instance of ManagedIdentityARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedIdentityARM(subject ManagedIdentityARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedIdentityARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedIdentityARM instances for property testing - lazily instantiated by ManagedIdentityARMGenerator()
var managedIdentityARMGenerator gopter.Gen

// ManagedIdentityARMGenerator returns a generator of ManagedIdentityARM instances for property testing.
// We first initialize managedIdentityARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedIdentityARMGenerator() gopter.Gen {
	if managedIdentityARMGenerator != nil {
		return managedIdentityARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedIdentityARM(generators)
	managedIdentityARMGenerator = gen.Struct(reflect.TypeOf(ManagedIdentityARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedIdentityARM(generators)
	AddRelatedPropertyGeneratorsForManagedIdentityARM(generators)
	managedIdentityARMGenerator = gen.Struct(reflect.TypeOf(ManagedIdentityARM{}), generators)

	return managedIdentityARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedIdentityARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedIdentityARM(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ManagedIdentityType_None, ManagedIdentityType_SystemAssigned, ManagedIdentityType_UserAssigned))
}

// AddRelatedPropertyGeneratorsForManagedIdentityARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedIdentityARM(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), UserAssignedIdentityPropertyARMGenerator())
}

func Test_ResourceSkuARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceSkuARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceSkuARM, ResourceSkuARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceSkuARM runs a test to see if a specific instance of ResourceSkuARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceSkuARM(subject ResourceSkuARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceSkuARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceSkuARM instances for property testing - lazily instantiated by ResourceSkuARMGenerator()
var resourceSkuARMGenerator gopter.Gen

// ResourceSkuARMGenerator returns a generator of ResourceSkuARM instances for property testing.
func ResourceSkuARMGenerator() gopter.Gen {
	if resourceSkuARMGenerator != nil {
		return resourceSkuARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceSkuARM(generators)
	resourceSkuARMGenerator = gen.Struct(reflect.TypeOf(ResourceSkuARM{}), generators)

	return resourceSkuARMGenerator
}

// AddIndependentPropertyGeneratorsForResourceSkuARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceSkuARM(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Family"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Size"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(
		SignalRSkuTier_Basic,
		SignalRSkuTier_Free,
		SignalRSkuTier_Premium,
		SignalRSkuTier_Standard))
}

func Test_SignalRPropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRPropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRPropertiesARM, SignalRPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRPropertiesARM runs a test to see if a specific instance of SignalRPropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRPropertiesARM(subject SignalRPropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRPropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRPropertiesARM instances for property testing - lazily instantiated by
// SignalRPropertiesARMGenerator()
var signalRPropertiesARMGenerator gopter.Gen

// SignalRPropertiesARMGenerator returns a generator of SignalRPropertiesARM instances for property testing.
// We first initialize signalRPropertiesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SignalRPropertiesARMGenerator() gopter.Gen {
	if signalRPropertiesARMGenerator != nil {
		return signalRPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRPropertiesARM(generators)
	signalRPropertiesARMGenerator = gen.Struct(reflect.TypeOf(SignalRPropertiesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRPropertiesARM(generators)
	AddRelatedPropertyGeneratorsForSignalRPropertiesARM(generators)
	signalRPropertiesARMGenerator = gen.Struct(reflect.TypeOf(SignalRPropertiesARM{}), generators)

	return signalRPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForSignalRPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRPropertiesARM(gens map[string]gopter.Gen) {
	gens["DisableAadAuth"] = gen.PtrOf(gen.Bool())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["ExternalIP"] = gen.PtrOf(gen.AlphaString())
	gens["HostName"] = gen.PtrOf(gen.AlphaString())
	gens["HostNamePrefix"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_Canceled,
		ProvisioningState_Creating,
		ProvisioningState_Deleting,
		ProvisioningState_Failed,
		ProvisioningState_Moving,
		ProvisioningState_Running,
		ProvisioningState_Succeeded,
		ProvisioningState_Unknown,
		ProvisioningState_Updating))
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.AlphaString())
	gens["PublicPort"] = gen.PtrOf(gen.Int())
	gens["ServerPort"] = gen.PtrOf(gen.Int())
	gens["Version"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSignalRPropertiesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSignalRPropertiesARM(gens map[string]gopter.Gen) {
	gens["Cors"] = gen.PtrOf(SignalRCorsSettingsARMGenerator())
	gens["Features"] = gen.SliceOf(SignalRFeatureARMGenerator())
	gens["NetworkACLs"] = gen.PtrOf(SignalRNetworkACLsARMGenerator())
	gens["PrivateEndpointConnections"] = gen.SliceOf(PrivateEndpointConnection_SignalR_SubResourceEmbeddedARMGenerator())
	gens["ResourceLogConfiguration"] = gen.PtrOf(ResourceLogConfigurationARMGenerator())
	gens["SharedPrivateLinkResources"] = gen.SliceOf(SharedPrivateLinkResource_SignalR_SubResourceEmbeddedARMGenerator())
	gens["Tls"] = gen.PtrOf(SignalRTlsSettingsARMGenerator())
	gens["Upstream"] = gen.PtrOf(ServerlessUpstreamSettingsARMGenerator())
}

func Test_SystemDataARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SystemDataARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSystemDataARM, SystemDataARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSystemDataARM runs a test to see if a specific instance of SystemDataARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSystemDataARM(subject SystemDataARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SystemDataARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SystemDataARM instances for property testing - lazily instantiated by SystemDataARMGenerator()
var systemDataARMGenerator gopter.Gen

// SystemDataARMGenerator returns a generator of SystemDataARM instances for property testing.
func SystemDataARMGenerator() gopter.Gen {
	if systemDataARMGenerator != nil {
		return systemDataARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSystemDataARM(generators)
	systemDataARMGenerator = gen.Struct(reflect.TypeOf(SystemDataARM{}), generators)

	return systemDataARMGenerator
}

// AddIndependentPropertyGeneratorsForSystemDataARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSystemDataARM(gens map[string]gopter.Gen) {
	gens["CreatedAt"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedBy"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemData_CreatedByType_Application,
		SystemData_CreatedByType_Key,
		SystemData_CreatedByType_ManagedIdentity,
		SystemData_CreatedByType_User))
	gens["LastModifiedAt"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedBy"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemData_LastModifiedByType_Application,
		SystemData_LastModifiedByType_Key,
		SystemData_LastModifiedByType_ManagedIdentity,
		SystemData_LastModifiedByType_User))
}

func Test_PrivateEndpointConnection_SignalR_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointConnection_SignalR_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointConnection_SignalR_SubResourceEmbeddedARM, PrivateEndpointConnection_SignalR_SubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointConnection_SignalR_SubResourceEmbeddedARM runs a test to see if a specific instance of PrivateEndpointConnection_SignalR_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointConnection_SignalR_SubResourceEmbeddedARM(subject PrivateEndpointConnection_SignalR_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointConnection_SignalR_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointConnection_SignalR_SubResourceEmbeddedARM instances for property testing - lazily
// instantiated by PrivateEndpointConnection_SignalR_SubResourceEmbeddedARMGenerator()
var privateEndpointConnection_SignalR_SubResourceEmbeddedARMGenerator gopter.Gen

// PrivateEndpointConnection_SignalR_SubResourceEmbeddedARMGenerator returns a generator of PrivateEndpointConnection_SignalR_SubResourceEmbeddedARM instances for property testing.
// We first initialize privateEndpointConnection_SignalR_SubResourceEmbeddedARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateEndpointConnection_SignalR_SubResourceEmbeddedARMGenerator() gopter.Gen {
	if privateEndpointConnection_SignalR_SubResourceEmbeddedARMGenerator != nil {
		return privateEndpointConnection_SignalR_SubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnection_SignalR_SubResourceEmbeddedARM(generators)
	privateEndpointConnection_SignalR_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnection_SignalR_SubResourceEmbeddedARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnection_SignalR_SubResourceEmbeddedARM(generators)
	AddRelatedPropertyGeneratorsForPrivateEndpointConnection_SignalR_SubResourceEmbeddedARM(generators)
	privateEndpointConnection_SignalR_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnection_SignalR_SubResourceEmbeddedARM{}), generators)

	return privateEndpointConnection_SignalR_SubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointConnection_SignalR_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointConnection_SignalR_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPrivateEndpointConnection_SignalR_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateEndpointConnection_SignalR_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["SystemData"] = gen.PtrOf(SystemDataARMGenerator())
}

func Test_ResourceLogConfigurationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceLogConfigurationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceLogConfigurationARM, ResourceLogConfigurationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceLogConfigurationARM runs a test to see if a specific instance of ResourceLogConfigurationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceLogConfigurationARM(subject ResourceLogConfigurationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceLogConfigurationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceLogConfigurationARM instances for property testing - lazily instantiated by
// ResourceLogConfigurationARMGenerator()
var resourceLogConfigurationARMGenerator gopter.Gen

// ResourceLogConfigurationARMGenerator returns a generator of ResourceLogConfigurationARM instances for property testing.
func ResourceLogConfigurationARMGenerator() gopter.Gen {
	if resourceLogConfigurationARMGenerator != nil {
		return resourceLogConfigurationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForResourceLogConfigurationARM(generators)
	resourceLogConfigurationARMGenerator = gen.Struct(reflect.TypeOf(ResourceLogConfigurationARM{}), generators)

	return resourceLogConfigurationARMGenerator
}

// AddRelatedPropertyGeneratorsForResourceLogConfigurationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResourceLogConfigurationARM(gens map[string]gopter.Gen) {
	gens["Categories"] = gen.SliceOf(ResourceLogCategoryARMGenerator())
}

func Test_ServerlessUpstreamSettingsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServerlessUpstreamSettingsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServerlessUpstreamSettingsARM, ServerlessUpstreamSettingsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServerlessUpstreamSettingsARM runs a test to see if a specific instance of ServerlessUpstreamSettingsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForServerlessUpstreamSettingsARM(subject ServerlessUpstreamSettingsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServerlessUpstreamSettingsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServerlessUpstreamSettingsARM instances for property testing - lazily instantiated by
// ServerlessUpstreamSettingsARMGenerator()
var serverlessUpstreamSettingsARMGenerator gopter.Gen

// ServerlessUpstreamSettingsARMGenerator returns a generator of ServerlessUpstreamSettingsARM instances for property testing.
func ServerlessUpstreamSettingsARMGenerator() gopter.Gen {
	if serverlessUpstreamSettingsARMGenerator != nil {
		return serverlessUpstreamSettingsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForServerlessUpstreamSettingsARM(generators)
	serverlessUpstreamSettingsARMGenerator = gen.Struct(reflect.TypeOf(ServerlessUpstreamSettingsARM{}), generators)

	return serverlessUpstreamSettingsARMGenerator
}

// AddRelatedPropertyGeneratorsForServerlessUpstreamSettingsARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForServerlessUpstreamSettingsARM(gens map[string]gopter.Gen) {
	gens["Templates"] = gen.SliceOf(UpstreamTemplateARMGenerator())
}

func Test_SharedPrivateLinkResource_SignalR_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SharedPrivateLinkResource_SignalR_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSharedPrivateLinkResource_SignalR_SubResourceEmbeddedARM, SharedPrivateLinkResource_SignalR_SubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSharedPrivateLinkResource_SignalR_SubResourceEmbeddedARM runs a test to see if a specific instance of SharedPrivateLinkResource_SignalR_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSharedPrivateLinkResource_SignalR_SubResourceEmbeddedARM(subject SharedPrivateLinkResource_SignalR_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SharedPrivateLinkResource_SignalR_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SharedPrivateLinkResource_SignalR_SubResourceEmbeddedARM instances for property testing - lazily
// instantiated by SharedPrivateLinkResource_SignalR_SubResourceEmbeddedARMGenerator()
var sharedPrivateLinkResource_SignalR_SubResourceEmbeddedARMGenerator gopter.Gen

// SharedPrivateLinkResource_SignalR_SubResourceEmbeddedARMGenerator returns a generator of SharedPrivateLinkResource_SignalR_SubResourceEmbeddedARM instances for property testing.
// We first initialize sharedPrivateLinkResource_SignalR_SubResourceEmbeddedARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SharedPrivateLinkResource_SignalR_SubResourceEmbeddedARMGenerator() gopter.Gen {
	if sharedPrivateLinkResource_SignalR_SubResourceEmbeddedARMGenerator != nil {
		return sharedPrivateLinkResource_SignalR_SubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSharedPrivateLinkResource_SignalR_SubResourceEmbeddedARM(generators)
	sharedPrivateLinkResource_SignalR_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(SharedPrivateLinkResource_SignalR_SubResourceEmbeddedARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSharedPrivateLinkResource_SignalR_SubResourceEmbeddedARM(generators)
	AddRelatedPropertyGeneratorsForSharedPrivateLinkResource_SignalR_SubResourceEmbeddedARM(generators)
	sharedPrivateLinkResource_SignalR_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(SharedPrivateLinkResource_SignalR_SubResourceEmbeddedARM{}), generators)

	return sharedPrivateLinkResource_SignalR_SubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForSharedPrivateLinkResource_SignalR_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSharedPrivateLinkResource_SignalR_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSharedPrivateLinkResource_SignalR_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSharedPrivateLinkResource_SignalR_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["SystemData"] = gen.PtrOf(SystemDataARMGenerator())
}

func Test_SignalRCorsSettingsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRCorsSettingsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRCorsSettingsARM, SignalRCorsSettingsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRCorsSettingsARM runs a test to see if a specific instance of SignalRCorsSettingsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRCorsSettingsARM(subject SignalRCorsSettingsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRCorsSettingsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRCorsSettingsARM instances for property testing - lazily instantiated by
// SignalRCorsSettingsARMGenerator()
var signalRCorsSettingsARMGenerator gopter.Gen

// SignalRCorsSettingsARMGenerator returns a generator of SignalRCorsSettingsARM instances for property testing.
func SignalRCorsSettingsARMGenerator() gopter.Gen {
	if signalRCorsSettingsARMGenerator != nil {
		return signalRCorsSettingsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRCorsSettingsARM(generators)
	signalRCorsSettingsARMGenerator = gen.Struct(reflect.TypeOf(SignalRCorsSettingsARM{}), generators)

	return signalRCorsSettingsARMGenerator
}

// AddIndependentPropertyGeneratorsForSignalRCorsSettingsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRCorsSettingsARM(gens map[string]gopter.Gen) {
	gens["AllowedOrigins"] = gen.SliceOf(gen.AlphaString())
}

func Test_SignalRFeatureARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRFeatureARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRFeatureARM, SignalRFeatureARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRFeatureARM runs a test to see if a specific instance of SignalRFeatureARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRFeatureARM(subject SignalRFeatureARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRFeatureARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRFeatureARM instances for property testing - lazily instantiated by SignalRFeatureARMGenerator()
var signalRFeatureARMGenerator gopter.Gen

// SignalRFeatureARMGenerator returns a generator of SignalRFeatureARM instances for property testing.
func SignalRFeatureARMGenerator() gopter.Gen {
	if signalRFeatureARMGenerator != nil {
		return signalRFeatureARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRFeatureARM(generators)
	signalRFeatureARMGenerator = gen.Struct(reflect.TypeOf(SignalRFeatureARM{}), generators)

	return signalRFeatureARMGenerator
}

// AddIndependentPropertyGeneratorsForSignalRFeatureARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRFeatureARM(gens map[string]gopter.Gen) {
	gens["Flag"] = gen.PtrOf(gen.OneConstOf(
		FeatureFlags_EnableConnectivityLogs,
		FeatureFlags_EnableLiveTrace,
		FeatureFlags_EnableMessagingLogs,
		FeatureFlags_ServiceMode))
	gens["Properties"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_SignalRNetworkACLsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRNetworkACLsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRNetworkACLsARM, SignalRNetworkACLsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRNetworkACLsARM runs a test to see if a specific instance of SignalRNetworkACLsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRNetworkACLsARM(subject SignalRNetworkACLsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRNetworkACLsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRNetworkACLsARM instances for property testing - lazily instantiated by
// SignalRNetworkACLsARMGenerator()
var signalRNetworkACLsARMGenerator gopter.Gen

// SignalRNetworkACLsARMGenerator returns a generator of SignalRNetworkACLsARM instances for property testing.
// We first initialize signalRNetworkACLsARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SignalRNetworkACLsARMGenerator() gopter.Gen {
	if signalRNetworkACLsARMGenerator != nil {
		return signalRNetworkACLsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRNetworkACLsARM(generators)
	signalRNetworkACLsARMGenerator = gen.Struct(reflect.TypeOf(SignalRNetworkACLsARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRNetworkACLsARM(generators)
	AddRelatedPropertyGeneratorsForSignalRNetworkACLsARM(generators)
	signalRNetworkACLsARMGenerator = gen.Struct(reflect.TypeOf(SignalRNetworkACLsARM{}), generators)

	return signalRNetworkACLsARMGenerator
}

// AddIndependentPropertyGeneratorsForSignalRNetworkACLsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRNetworkACLsARM(gens map[string]gopter.Gen) {
	gens["DefaultAction"] = gen.PtrOf(gen.OneConstOf(ACLAction_Allow, ACLAction_Deny))
}

// AddRelatedPropertyGeneratorsForSignalRNetworkACLsARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSignalRNetworkACLsARM(gens map[string]gopter.Gen) {
	gens["PrivateEndpoints"] = gen.SliceOf(PrivateEndpointACLARMGenerator())
	gens["PublicNetwork"] = gen.PtrOf(NetworkACLARMGenerator())
}

func Test_SignalRTlsSettingsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRTlsSettingsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRTlsSettingsARM, SignalRTlsSettingsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRTlsSettingsARM runs a test to see if a specific instance of SignalRTlsSettingsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRTlsSettingsARM(subject SignalRTlsSettingsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRTlsSettingsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRTlsSettingsARM instances for property testing - lazily instantiated by
// SignalRTlsSettingsARMGenerator()
var signalRTlsSettingsARMGenerator gopter.Gen

// SignalRTlsSettingsARMGenerator returns a generator of SignalRTlsSettingsARM instances for property testing.
func SignalRTlsSettingsARMGenerator() gopter.Gen {
	if signalRTlsSettingsARMGenerator != nil {
		return signalRTlsSettingsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRTlsSettingsARM(generators)
	signalRTlsSettingsARMGenerator = gen.Struct(reflect.TypeOf(SignalRTlsSettingsARM{}), generators)

	return signalRTlsSettingsARMGenerator
}

// AddIndependentPropertyGeneratorsForSignalRTlsSettingsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRTlsSettingsARM(gens map[string]gopter.Gen) {
	gens["ClientCertEnabled"] = gen.PtrOf(gen.Bool())
}

func Test_UserAssignedIdentityPropertyARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentityPropertyARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentityPropertyARM, UserAssignedIdentityPropertyARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentityPropertyARM runs a test to see if a specific instance of UserAssignedIdentityPropertyARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentityPropertyARM(subject UserAssignedIdentityPropertyARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentityPropertyARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentityPropertyARM instances for property testing - lazily instantiated by
// UserAssignedIdentityPropertyARMGenerator()
var userAssignedIdentityPropertyARMGenerator gopter.Gen

// UserAssignedIdentityPropertyARMGenerator returns a generator of UserAssignedIdentityPropertyARM instances for property testing.
func UserAssignedIdentityPropertyARMGenerator() gopter.Gen {
	if userAssignedIdentityPropertyARMGenerator != nil {
		return userAssignedIdentityPropertyARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserAssignedIdentityPropertyARM(generators)
	userAssignedIdentityPropertyARMGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentityPropertyARM{}), generators)

	return userAssignedIdentityPropertyARMGenerator
}

// AddIndependentPropertyGeneratorsForUserAssignedIdentityPropertyARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserAssignedIdentityPropertyARM(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_NetworkACLARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkACLARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkACLARM, NetworkACLARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkACLARM runs a test to see if a specific instance of NetworkACLARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkACLARM(subject NetworkACLARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkACLARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkACLARM instances for property testing - lazily instantiated by NetworkACLARMGenerator()
var networkACLARMGenerator gopter.Gen

// NetworkACLARMGenerator returns a generator of NetworkACLARM instances for property testing.
func NetworkACLARMGenerator() gopter.Gen {
	if networkACLARMGenerator != nil {
		return networkACLARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkACLARM(generators)
	networkACLARMGenerator = gen.Struct(reflect.TypeOf(NetworkACLARM{}), generators)

	return networkACLARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkACLARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkACLARM(gens map[string]gopter.Gen) {
	gens["Allow"] = gen.SliceOf(gen.OneConstOf(
		SignalRRequestType_ClientConnection,
		SignalRRequestType_RESTAPI,
		SignalRRequestType_ServerConnection,
		SignalRRequestType_Trace))
	gens["Deny"] = gen.SliceOf(gen.OneConstOf(
		SignalRRequestType_ClientConnection,
		SignalRRequestType_RESTAPI,
		SignalRRequestType_ServerConnection,
		SignalRRequestType_Trace))
}

func Test_PrivateEndpointACLARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointACLARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointACLARM, PrivateEndpointACLARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointACLARM runs a test to see if a specific instance of PrivateEndpointACLARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointACLARM(subject PrivateEndpointACLARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointACLARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointACLARM instances for property testing - lazily instantiated by
// PrivateEndpointACLARMGenerator()
var privateEndpointACLARMGenerator gopter.Gen

// PrivateEndpointACLARMGenerator returns a generator of PrivateEndpointACLARM instances for property testing.
func PrivateEndpointACLARMGenerator() gopter.Gen {
	if privateEndpointACLARMGenerator != nil {
		return privateEndpointACLARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointACLARM(generators)
	privateEndpointACLARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointACLARM{}), generators)

	return privateEndpointACLARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointACLARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointACLARM(gens map[string]gopter.Gen) {
	gens["Allow"] = gen.SliceOf(gen.OneConstOf(
		SignalRRequestType_ClientConnection,
		SignalRRequestType_RESTAPI,
		SignalRRequestType_ServerConnection,
		SignalRRequestType_Trace))
	gens["Deny"] = gen.SliceOf(gen.OneConstOf(
		SignalRRequestType_ClientConnection,
		SignalRRequestType_RESTAPI,
		SignalRRequestType_ServerConnection,
		SignalRRequestType_Trace))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_ResourceLogCategoryARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceLogCategoryARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceLogCategoryARM, ResourceLogCategoryARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceLogCategoryARM runs a test to see if a specific instance of ResourceLogCategoryARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceLogCategoryARM(subject ResourceLogCategoryARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceLogCategoryARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceLogCategoryARM instances for property testing - lazily instantiated by
// ResourceLogCategoryARMGenerator()
var resourceLogCategoryARMGenerator gopter.Gen

// ResourceLogCategoryARMGenerator returns a generator of ResourceLogCategoryARM instances for property testing.
func ResourceLogCategoryARMGenerator() gopter.Gen {
	if resourceLogCategoryARMGenerator != nil {
		return resourceLogCategoryARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceLogCategoryARM(generators)
	resourceLogCategoryARMGenerator = gen.Struct(reflect.TypeOf(ResourceLogCategoryARM{}), generators)

	return resourceLogCategoryARMGenerator
}

// AddIndependentPropertyGeneratorsForResourceLogCategoryARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceLogCategoryARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_UpstreamTemplateARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UpstreamTemplateARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUpstreamTemplateARM, UpstreamTemplateARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUpstreamTemplateARM runs a test to see if a specific instance of UpstreamTemplateARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUpstreamTemplateARM(subject UpstreamTemplateARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UpstreamTemplateARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UpstreamTemplateARM instances for property testing - lazily instantiated by
// UpstreamTemplateARMGenerator()
var upstreamTemplateARMGenerator gopter.Gen

// UpstreamTemplateARMGenerator returns a generator of UpstreamTemplateARM instances for property testing.
// We first initialize upstreamTemplateARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UpstreamTemplateARMGenerator() gopter.Gen {
	if upstreamTemplateARMGenerator != nil {
		return upstreamTemplateARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpstreamTemplateARM(generators)
	upstreamTemplateARMGenerator = gen.Struct(reflect.TypeOf(UpstreamTemplateARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpstreamTemplateARM(generators)
	AddRelatedPropertyGeneratorsForUpstreamTemplateARM(generators)
	upstreamTemplateARMGenerator = gen.Struct(reflect.TypeOf(UpstreamTemplateARM{}), generators)

	return upstreamTemplateARMGenerator
}

// AddIndependentPropertyGeneratorsForUpstreamTemplateARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUpstreamTemplateARM(gens map[string]gopter.Gen) {
	gens["CategoryPattern"] = gen.PtrOf(gen.AlphaString())
	gens["EventPattern"] = gen.PtrOf(gen.AlphaString())
	gens["HubPattern"] = gen.PtrOf(gen.AlphaString())
	gens["UrlTemplate"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForUpstreamTemplateARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUpstreamTemplateARM(gens map[string]gopter.Gen) {
	gens["Auth"] = gen.PtrOf(UpstreamAuthSettingsARMGenerator())
}

func Test_UpstreamAuthSettingsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UpstreamAuthSettingsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUpstreamAuthSettingsARM, UpstreamAuthSettingsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUpstreamAuthSettingsARM runs a test to see if a specific instance of UpstreamAuthSettingsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUpstreamAuthSettingsARM(subject UpstreamAuthSettingsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UpstreamAuthSettingsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UpstreamAuthSettingsARM instances for property testing - lazily instantiated by
// UpstreamAuthSettingsARMGenerator()
var upstreamAuthSettingsARMGenerator gopter.Gen

// UpstreamAuthSettingsARMGenerator returns a generator of UpstreamAuthSettingsARM instances for property testing.
// We first initialize upstreamAuthSettingsARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UpstreamAuthSettingsARMGenerator() gopter.Gen {
	if upstreamAuthSettingsARMGenerator != nil {
		return upstreamAuthSettingsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpstreamAuthSettingsARM(generators)
	upstreamAuthSettingsARMGenerator = gen.Struct(reflect.TypeOf(UpstreamAuthSettingsARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpstreamAuthSettingsARM(generators)
	AddRelatedPropertyGeneratorsForUpstreamAuthSettingsARM(generators)
	upstreamAuthSettingsARMGenerator = gen.Struct(reflect.TypeOf(UpstreamAuthSettingsARM{}), generators)

	return upstreamAuthSettingsARMGenerator
}

// AddIndependentPropertyGeneratorsForUpstreamAuthSettingsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUpstreamAuthSettingsARM(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(UpstreamAuthType_ManagedIdentity, UpstreamAuthType_None))
}

// AddRelatedPropertyGeneratorsForUpstreamAuthSettingsARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUpstreamAuthSettingsARM(gens map[string]gopter.Gen) {
	gens["ManagedIdentity"] = gen.PtrOf(ManagedIdentitySettingsARMGenerator())
}

func Test_ManagedIdentitySettingsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedIdentitySettingsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedIdentitySettingsARM, ManagedIdentitySettingsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedIdentitySettingsARM runs a test to see if a specific instance of ManagedIdentitySettingsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedIdentitySettingsARM(subject ManagedIdentitySettingsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedIdentitySettingsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedIdentitySettingsARM instances for property testing - lazily instantiated by
// ManagedIdentitySettingsARMGenerator()
var managedIdentitySettingsARMGenerator gopter.Gen

// ManagedIdentitySettingsARMGenerator returns a generator of ManagedIdentitySettingsARM instances for property testing.
func ManagedIdentitySettingsARMGenerator() gopter.Gen {
	if managedIdentitySettingsARMGenerator != nil {
		return managedIdentitySettingsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedIdentitySettingsARM(generators)
	managedIdentitySettingsARMGenerator = gen.Struct(reflect.TypeOf(ManagedIdentitySettingsARM{}), generators)

	return managedIdentitySettingsARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedIdentitySettingsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedIdentitySettingsARM(gens map[string]gopter.Gen) {
	gens["Resource"] = gen.PtrOf(gen.AlphaString())
}
