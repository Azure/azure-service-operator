// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20211001

import (
	"encoding/json"
	"github.com/Azure/azure-service-operator/v2/api/signalrservice/v1alpha1api20211001storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_SignalR_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SignalR to hub returns original",
		prop.ForAll(RunResourceConversionTestForSignalR, SignalRGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForSignalR tests if a specific instance of SignalR round trips to the hub storage version and back losslessly
func RunResourceConversionTestForSignalR(subject SignalR) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v1alpha1api20211001storage.SignalR
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual SignalR
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SignalR_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SignalR to SignalR via AssignPropertiesToSignalR & AssignPropertiesFromSignalR returns original",
		prop.ForAll(RunPropertyAssignmentTestForSignalR, SignalRGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSignalR tests if a specific instance of SignalR can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForSignalR(subject SignalR) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.SignalR
	err := copied.AssignPropertiesToSignalR(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SignalR
	err = actual.AssignPropertiesFromSignalR(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SignalR_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalR via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalR, SignalRGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalR runs a test to see if a specific instance of SignalR round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalR(subject SignalR) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalR
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalR instances for property testing - lazily instantiated by SignalRGenerator()
var signalRGenerator gopter.Gen

// SignalRGenerator returns a generator of SignalR instances for property testing.
func SignalRGenerator() gopter.Gen {
	if signalRGenerator != nil {
		return signalRGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForSignalR(generators)
	signalRGenerator = gen.Struct(reflect.TypeOf(SignalR{}), generators)

	return signalRGenerator
}

// AddRelatedPropertyGeneratorsForSignalR is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSignalR(gens map[string]gopter.Gen) {
	gens["Spec"] = SignalR_SPECGenerator()
	gens["Status"] = SignalRResource_StatusGenerator()
}

func Test_SignalRResource_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SignalRResource_Status to SignalRResource_Status via AssignPropertiesToSignalRResource_Status & AssignPropertiesFromSignalRResource_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForSignalRResource_Status, SignalRResource_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSignalRResource_Status tests if a specific instance of SignalRResource_Status can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForSignalRResource_Status(subject SignalRResource_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.SignalRResource_Status
	err := copied.AssignPropertiesToSignalRResource_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SignalRResource_Status
	err = actual.AssignPropertiesFromSignalRResource_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SignalRResource_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRResource_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRResource_Status, SignalRResource_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRResource_Status runs a test to see if a specific instance of SignalRResource_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRResource_Status(subject SignalRResource_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRResource_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRResource_Status instances for property testing - lazily instantiated by
//SignalRResource_StatusGenerator()
var signalRResource_statusGenerator gopter.Gen

// SignalRResource_StatusGenerator returns a generator of SignalRResource_Status instances for property testing.
// We first initialize signalRResource_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SignalRResource_StatusGenerator() gopter.Gen {
	if signalRResource_statusGenerator != nil {
		return signalRResource_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRResource_Status(generators)
	signalRResource_statusGenerator = gen.Struct(reflect.TypeOf(SignalRResource_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRResource_Status(generators)
	AddRelatedPropertyGeneratorsForSignalRResource_Status(generators)
	signalRResource_statusGenerator = gen.Struct(reflect.TypeOf(SignalRResource_Status{}), generators)

	return signalRResource_statusGenerator
}

// AddIndependentPropertyGeneratorsForSignalRResource_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRResource_Status(gens map[string]gopter.Gen) {
	gens["DisableAadAuth"] = gen.PtrOf(gen.Bool())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["ExternalIP"] = gen.PtrOf(gen.AlphaString())
	gens["HostName"] = gen.PtrOf(gen.AlphaString())
	gens["HostNamePrefix"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(ServiceKind_StatusRawWebSockets, ServiceKind_StatusSignalR))
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_StatusCanceled,
		ProvisioningState_StatusCreating,
		ProvisioningState_StatusDeleting,
		ProvisioningState_StatusFailed,
		ProvisioningState_StatusMoving,
		ProvisioningState_StatusRunning,
		ProvisioningState_StatusSucceeded,
		ProvisioningState_StatusUnknown,
		ProvisioningState_StatusUpdating))
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.AlphaString())
	gens["PublicPort"] = gen.PtrOf(gen.Int())
	gens["ServerPort"] = gen.PtrOf(gen.Int())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["Version"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSignalRResource_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSignalRResource_Status(gens map[string]gopter.Gen) {
	gens["Cors"] = gen.PtrOf(SignalRCorsSettings_StatusGenerator())
	gens["Features"] = gen.SliceOf(SignalRFeature_StatusGenerator())
	gens["Identity"] = gen.PtrOf(ManagedIdentity_StatusGenerator())
	gens["NetworkACLs"] = gen.PtrOf(SignalRNetworkACLs_StatusGenerator())
	gens["PrivateEndpointConnections"] = gen.SliceOf(PrivateEndpointConnection_Status_SignalR_SubResourceEmbeddedGenerator())
	gens["ResourceLogConfiguration"] = gen.PtrOf(ResourceLogConfiguration_StatusGenerator())
	gens["SharedPrivateLinkResources"] = gen.SliceOf(SharedPrivateLinkResource_Status_SignalR_SubResourceEmbeddedGenerator())
	gens["Sku"] = gen.PtrOf(ResourceSku_StatusGenerator())
	gens["SystemData"] = gen.PtrOf(SystemData_StatusGenerator())
	gens["Tls"] = gen.PtrOf(SignalRTlsSettings_StatusGenerator())
	gens["Upstream"] = gen.PtrOf(ServerlessUpstreamSettings_StatusGenerator())
}

func Test_SignalR_SPEC_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SignalR_SPEC to SignalR_SPEC via AssignPropertiesToSignalR_SPEC & AssignPropertiesFromSignalR_SPEC returns original",
		prop.ForAll(RunPropertyAssignmentTestForSignalR_SPEC, SignalR_SPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSignalR_SPEC tests if a specific instance of SignalR_SPEC can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForSignalR_SPEC(subject SignalR_SPEC) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.SignalR_SPEC
	err := copied.AssignPropertiesToSignalR_SPEC(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SignalR_SPEC
	err = actual.AssignPropertiesFromSignalR_SPEC(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SignalR_SPEC_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalR_SPEC via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalR_SPEC, SignalR_SPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalR_SPEC runs a test to see if a specific instance of SignalR_SPEC round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalR_SPEC(subject SignalR_SPEC) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalR_SPEC
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalR_SPEC instances for property testing - lazily instantiated by SignalR_SPECGenerator()
var signalR_specGenerator gopter.Gen

// SignalR_SPECGenerator returns a generator of SignalR_SPEC instances for property testing.
// We first initialize signalR_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SignalR_SPECGenerator() gopter.Gen {
	if signalR_specGenerator != nil {
		return signalR_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalR_SPEC(generators)
	signalR_specGenerator = gen.Struct(reflect.TypeOf(SignalR_SPEC{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalR_SPEC(generators)
	AddRelatedPropertyGeneratorsForSignalR_SPEC(generators)
	signalR_specGenerator = gen.Struct(reflect.TypeOf(SignalR_SPEC{}), generators)

	return signalR_specGenerator
}

// AddIndependentPropertyGeneratorsForSignalR_SPEC is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalR_SPEC(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["DisableAadAuth"] = gen.PtrOf(gen.Bool())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(ServiceKind_SpecRawWebSockets, ServiceKind_SpecSignalR))
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSignalR_SPEC is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSignalR_SPEC(gens map[string]gopter.Gen) {
	gens["Cors"] = gen.PtrOf(SignalRCorsSettings_SpecGenerator())
	gens["Features"] = gen.SliceOf(SignalRFeature_SpecGenerator())
	gens["Identity"] = gen.PtrOf(ManagedIdentity_SpecGenerator())
	gens["NetworkACLs"] = gen.PtrOf(SignalRNetworkACLs_SpecGenerator())
	gens["ResourceLogConfiguration"] = gen.PtrOf(ResourceLogConfiguration_SpecGenerator())
	gens["Sku"] = gen.PtrOf(ResourceSku_SpecGenerator())
	gens["Tls"] = gen.PtrOf(SignalRTlsSettings_SpecGenerator())
	gens["Upstream"] = gen.PtrOf(ServerlessUpstreamSettings_SpecGenerator())
}

func Test_ManagedIdentity_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedIdentity_Spec to ManagedIdentity_Spec via AssignPropertiesToManagedIdentity_Spec & AssignPropertiesFromManagedIdentity_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedIdentity_Spec, ManagedIdentity_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedIdentity_Spec tests if a specific instance of ManagedIdentity_Spec can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForManagedIdentity_Spec(subject ManagedIdentity_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.ManagedIdentity_Spec
	err := copied.AssignPropertiesToManagedIdentity_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedIdentity_Spec
	err = actual.AssignPropertiesFromManagedIdentity_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedIdentity_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedIdentity_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedIdentity_Spec, ManagedIdentity_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedIdentity_Spec runs a test to see if a specific instance of ManagedIdentity_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedIdentity_Spec(subject ManagedIdentity_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedIdentity_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedIdentity_Spec instances for property testing - lazily instantiated by
//ManagedIdentity_SpecGenerator()
var managedIdentity_specGenerator gopter.Gen

// ManagedIdentity_SpecGenerator returns a generator of ManagedIdentity_Spec instances for property testing.
func ManagedIdentity_SpecGenerator() gopter.Gen {
	if managedIdentity_specGenerator != nil {
		return managedIdentity_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedIdentity_Spec(generators)
	managedIdentity_specGenerator = gen.Struct(reflect.TypeOf(ManagedIdentity_Spec{}), generators)

	return managedIdentity_specGenerator
}

// AddIndependentPropertyGeneratorsForManagedIdentity_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedIdentity_Spec(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ManagedIdentityType_SpecNone, ManagedIdentityType_SpecSystemAssigned, ManagedIdentityType_SpecUserAssigned))
}

func Test_ManagedIdentity_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedIdentity_Status to ManagedIdentity_Status via AssignPropertiesToManagedIdentity_Status & AssignPropertiesFromManagedIdentity_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedIdentity_Status, ManagedIdentity_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedIdentity_Status tests if a specific instance of ManagedIdentity_Status can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForManagedIdentity_Status(subject ManagedIdentity_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.ManagedIdentity_Status
	err := copied.AssignPropertiesToManagedIdentity_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedIdentity_Status
	err = actual.AssignPropertiesFromManagedIdentity_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedIdentity_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedIdentity_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedIdentity_Status, ManagedIdentity_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedIdentity_Status runs a test to see if a specific instance of ManagedIdentity_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedIdentity_Status(subject ManagedIdentity_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedIdentity_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedIdentity_Status instances for property testing - lazily instantiated by
//ManagedIdentity_StatusGenerator()
var managedIdentity_statusGenerator gopter.Gen

// ManagedIdentity_StatusGenerator returns a generator of ManagedIdentity_Status instances for property testing.
// We first initialize managedIdentity_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedIdentity_StatusGenerator() gopter.Gen {
	if managedIdentity_statusGenerator != nil {
		return managedIdentity_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedIdentity_Status(generators)
	managedIdentity_statusGenerator = gen.Struct(reflect.TypeOf(ManagedIdentity_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedIdentity_Status(generators)
	AddRelatedPropertyGeneratorsForManagedIdentity_Status(generators)
	managedIdentity_statusGenerator = gen.Struct(reflect.TypeOf(ManagedIdentity_Status{}), generators)

	return managedIdentity_statusGenerator
}

// AddIndependentPropertyGeneratorsForManagedIdentity_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedIdentity_Status(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ManagedIdentityType_StatusNone, ManagedIdentityType_StatusSystemAssigned, ManagedIdentityType_StatusUserAssigned))
}

// AddRelatedPropertyGeneratorsForManagedIdentity_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedIdentity_Status(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), UserAssignedIdentityProperty_StatusGenerator())
}

func Test_PrivateEndpointConnection_Status_SignalR_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PrivateEndpointConnection_Status_SignalR_SubResourceEmbedded to PrivateEndpointConnection_Status_SignalR_SubResourceEmbedded via AssignPropertiesToPrivateEndpointConnection_Status_SignalR_SubResourceEmbedded & AssignPropertiesFromPrivateEndpointConnection_Status_SignalR_SubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForPrivateEndpointConnection_Status_SignalR_SubResourceEmbedded, PrivateEndpointConnection_Status_SignalR_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPrivateEndpointConnection_Status_SignalR_SubResourceEmbedded tests if a specific instance of PrivateEndpointConnection_Status_SignalR_SubResourceEmbedded can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForPrivateEndpointConnection_Status_SignalR_SubResourceEmbedded(subject PrivateEndpointConnection_Status_SignalR_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.PrivateEndpointConnection_Status_SignalR_SubResourceEmbedded
	err := copied.AssignPropertiesToPrivateEndpointConnection_Status_SignalR_SubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PrivateEndpointConnection_Status_SignalR_SubResourceEmbedded
	err = actual.AssignPropertiesFromPrivateEndpointConnection_Status_SignalR_SubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PrivateEndpointConnection_Status_SignalR_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointConnection_Status_SignalR_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointConnection_Status_SignalR_SubResourceEmbedded, PrivateEndpointConnection_Status_SignalR_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointConnection_Status_SignalR_SubResourceEmbedded runs a test to see if a specific instance of PrivateEndpointConnection_Status_SignalR_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointConnection_Status_SignalR_SubResourceEmbedded(subject PrivateEndpointConnection_Status_SignalR_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointConnection_Status_SignalR_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointConnection_Status_SignalR_SubResourceEmbedded instances for property testing - lazily
//instantiated by PrivateEndpointConnection_Status_SignalR_SubResourceEmbeddedGenerator()
var privateEndpointConnection_status_signalR_subResourceEmbeddedGenerator gopter.Gen

// PrivateEndpointConnection_Status_SignalR_SubResourceEmbeddedGenerator returns a generator of PrivateEndpointConnection_Status_SignalR_SubResourceEmbedded instances for property testing.
// We first initialize privateEndpointConnection_status_signalR_subResourceEmbeddedGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateEndpointConnection_Status_SignalR_SubResourceEmbeddedGenerator() gopter.Gen {
	if privateEndpointConnection_status_signalR_subResourceEmbeddedGenerator != nil {
		return privateEndpointConnection_status_signalR_subResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnection_Status_SignalR_SubResourceEmbedded(generators)
	privateEndpointConnection_status_signalR_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnection_Status_SignalR_SubResourceEmbedded{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnection_Status_SignalR_SubResourceEmbedded(generators)
	AddRelatedPropertyGeneratorsForPrivateEndpointConnection_Status_SignalR_SubResourceEmbedded(generators)
	privateEndpointConnection_status_signalR_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnection_Status_SignalR_SubResourceEmbedded{}), generators)

	return privateEndpointConnection_status_signalR_subResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointConnection_Status_SignalR_SubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointConnection_Status_SignalR_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPrivateEndpointConnection_Status_SignalR_SubResourceEmbedded is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateEndpointConnection_Status_SignalR_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["SystemData"] = gen.PtrOf(SystemData_StatusGenerator())
}

func Test_ResourceLogConfiguration_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResourceLogConfiguration_Spec to ResourceLogConfiguration_Spec via AssignPropertiesToResourceLogConfiguration_Spec & AssignPropertiesFromResourceLogConfiguration_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForResourceLogConfiguration_Spec, ResourceLogConfiguration_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResourceLogConfiguration_Spec tests if a specific instance of ResourceLogConfiguration_Spec can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForResourceLogConfiguration_Spec(subject ResourceLogConfiguration_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.ResourceLogConfiguration_Spec
	err := copied.AssignPropertiesToResourceLogConfiguration_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResourceLogConfiguration_Spec
	err = actual.AssignPropertiesFromResourceLogConfiguration_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResourceLogConfiguration_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceLogConfiguration_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceLogConfiguration_Spec, ResourceLogConfiguration_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceLogConfiguration_Spec runs a test to see if a specific instance of ResourceLogConfiguration_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceLogConfiguration_Spec(subject ResourceLogConfiguration_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceLogConfiguration_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceLogConfiguration_Spec instances for property testing - lazily instantiated by
//ResourceLogConfiguration_SpecGenerator()
var resourceLogConfiguration_specGenerator gopter.Gen

// ResourceLogConfiguration_SpecGenerator returns a generator of ResourceLogConfiguration_Spec instances for property testing.
func ResourceLogConfiguration_SpecGenerator() gopter.Gen {
	if resourceLogConfiguration_specGenerator != nil {
		return resourceLogConfiguration_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForResourceLogConfiguration_Spec(generators)
	resourceLogConfiguration_specGenerator = gen.Struct(reflect.TypeOf(ResourceLogConfiguration_Spec{}), generators)

	return resourceLogConfiguration_specGenerator
}

// AddRelatedPropertyGeneratorsForResourceLogConfiguration_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResourceLogConfiguration_Spec(gens map[string]gopter.Gen) {
	gens["Categories"] = gen.SliceOf(ResourceLogCategory_SpecGenerator())
}

func Test_ResourceLogConfiguration_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResourceLogConfiguration_Status to ResourceLogConfiguration_Status via AssignPropertiesToResourceLogConfiguration_Status & AssignPropertiesFromResourceLogConfiguration_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForResourceLogConfiguration_Status, ResourceLogConfiguration_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResourceLogConfiguration_Status tests if a specific instance of ResourceLogConfiguration_Status can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForResourceLogConfiguration_Status(subject ResourceLogConfiguration_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.ResourceLogConfiguration_Status
	err := copied.AssignPropertiesToResourceLogConfiguration_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResourceLogConfiguration_Status
	err = actual.AssignPropertiesFromResourceLogConfiguration_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResourceLogConfiguration_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceLogConfiguration_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceLogConfiguration_Status, ResourceLogConfiguration_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceLogConfiguration_Status runs a test to see if a specific instance of ResourceLogConfiguration_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceLogConfiguration_Status(subject ResourceLogConfiguration_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceLogConfiguration_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceLogConfiguration_Status instances for property testing - lazily instantiated by
//ResourceLogConfiguration_StatusGenerator()
var resourceLogConfiguration_statusGenerator gopter.Gen

// ResourceLogConfiguration_StatusGenerator returns a generator of ResourceLogConfiguration_Status instances for property testing.
func ResourceLogConfiguration_StatusGenerator() gopter.Gen {
	if resourceLogConfiguration_statusGenerator != nil {
		return resourceLogConfiguration_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForResourceLogConfiguration_Status(generators)
	resourceLogConfiguration_statusGenerator = gen.Struct(reflect.TypeOf(ResourceLogConfiguration_Status{}), generators)

	return resourceLogConfiguration_statusGenerator
}

// AddRelatedPropertyGeneratorsForResourceLogConfiguration_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResourceLogConfiguration_Status(gens map[string]gopter.Gen) {
	gens["Categories"] = gen.SliceOf(ResourceLogCategory_StatusGenerator())
}

func Test_ResourceSku_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResourceSku_Spec to ResourceSku_Spec via AssignPropertiesToResourceSku_Spec & AssignPropertiesFromResourceSku_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForResourceSku_Spec, ResourceSku_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResourceSku_Spec tests if a specific instance of ResourceSku_Spec can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForResourceSku_Spec(subject ResourceSku_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.ResourceSku_Spec
	err := copied.AssignPropertiesToResourceSku_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResourceSku_Spec
	err = actual.AssignPropertiesFromResourceSku_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResourceSku_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceSku_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceSku_Spec, ResourceSku_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceSku_Spec runs a test to see if a specific instance of ResourceSku_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceSku_Spec(subject ResourceSku_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceSku_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceSku_Spec instances for property testing - lazily instantiated by ResourceSku_SpecGenerator()
var resourceSku_specGenerator gopter.Gen

// ResourceSku_SpecGenerator returns a generator of ResourceSku_Spec instances for property testing.
func ResourceSku_SpecGenerator() gopter.Gen {
	if resourceSku_specGenerator != nil {
		return resourceSku_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceSku_Spec(generators)
	resourceSku_specGenerator = gen.Struct(reflect.TypeOf(ResourceSku_Spec{}), generators)

	return resourceSku_specGenerator
}

// AddIndependentPropertyGeneratorsForResourceSku_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceSku_Spec(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.AlphaString()
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(
		SignalRSkuTier_SpecBasic,
		SignalRSkuTier_SpecFree,
		SignalRSkuTier_SpecPremium,
		SignalRSkuTier_SpecStandard))
}

func Test_ResourceSku_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResourceSku_Status to ResourceSku_Status via AssignPropertiesToResourceSku_Status & AssignPropertiesFromResourceSku_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForResourceSku_Status, ResourceSku_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResourceSku_Status tests if a specific instance of ResourceSku_Status can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForResourceSku_Status(subject ResourceSku_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.ResourceSku_Status
	err := copied.AssignPropertiesToResourceSku_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResourceSku_Status
	err = actual.AssignPropertiesFromResourceSku_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResourceSku_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceSku_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceSku_Status, ResourceSku_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceSku_Status runs a test to see if a specific instance of ResourceSku_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceSku_Status(subject ResourceSku_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceSku_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceSku_Status instances for property testing - lazily instantiated by ResourceSku_StatusGenerator()
var resourceSku_statusGenerator gopter.Gen

// ResourceSku_StatusGenerator returns a generator of ResourceSku_Status instances for property testing.
func ResourceSku_StatusGenerator() gopter.Gen {
	if resourceSku_statusGenerator != nil {
		return resourceSku_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceSku_Status(generators)
	resourceSku_statusGenerator = gen.Struct(reflect.TypeOf(ResourceSku_Status{}), generators)

	return resourceSku_statusGenerator
}

// AddIndependentPropertyGeneratorsForResourceSku_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceSku_Status(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Family"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Size"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(
		SignalRSkuTier_StatusBasic,
		SignalRSkuTier_StatusFree,
		SignalRSkuTier_StatusPremium,
		SignalRSkuTier_StatusStandard))
}

func Test_ServerlessUpstreamSettings_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ServerlessUpstreamSettings_Spec to ServerlessUpstreamSettings_Spec via AssignPropertiesToServerlessUpstreamSettings_Spec & AssignPropertiesFromServerlessUpstreamSettings_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForServerlessUpstreamSettings_Spec, ServerlessUpstreamSettings_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForServerlessUpstreamSettings_Spec tests if a specific instance of ServerlessUpstreamSettings_Spec can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForServerlessUpstreamSettings_Spec(subject ServerlessUpstreamSettings_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.ServerlessUpstreamSettings_Spec
	err := copied.AssignPropertiesToServerlessUpstreamSettings_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ServerlessUpstreamSettings_Spec
	err = actual.AssignPropertiesFromServerlessUpstreamSettings_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ServerlessUpstreamSettings_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServerlessUpstreamSettings_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServerlessUpstreamSettings_Spec, ServerlessUpstreamSettings_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServerlessUpstreamSettings_Spec runs a test to see if a specific instance of ServerlessUpstreamSettings_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForServerlessUpstreamSettings_Spec(subject ServerlessUpstreamSettings_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServerlessUpstreamSettings_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServerlessUpstreamSettings_Spec instances for property testing - lazily instantiated by
//ServerlessUpstreamSettings_SpecGenerator()
var serverlessUpstreamSettings_specGenerator gopter.Gen

// ServerlessUpstreamSettings_SpecGenerator returns a generator of ServerlessUpstreamSettings_Spec instances for property testing.
func ServerlessUpstreamSettings_SpecGenerator() gopter.Gen {
	if serverlessUpstreamSettings_specGenerator != nil {
		return serverlessUpstreamSettings_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForServerlessUpstreamSettings_Spec(generators)
	serverlessUpstreamSettings_specGenerator = gen.Struct(reflect.TypeOf(ServerlessUpstreamSettings_Spec{}), generators)

	return serverlessUpstreamSettings_specGenerator
}

// AddRelatedPropertyGeneratorsForServerlessUpstreamSettings_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForServerlessUpstreamSettings_Spec(gens map[string]gopter.Gen) {
	gens["Templates"] = gen.SliceOf(UpstreamTemplate_SpecGenerator())
}

func Test_ServerlessUpstreamSettings_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ServerlessUpstreamSettings_Status to ServerlessUpstreamSettings_Status via AssignPropertiesToServerlessUpstreamSettings_Status & AssignPropertiesFromServerlessUpstreamSettings_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForServerlessUpstreamSettings_Status, ServerlessUpstreamSettings_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForServerlessUpstreamSettings_Status tests if a specific instance of ServerlessUpstreamSettings_Status can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForServerlessUpstreamSettings_Status(subject ServerlessUpstreamSettings_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.ServerlessUpstreamSettings_Status
	err := copied.AssignPropertiesToServerlessUpstreamSettings_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ServerlessUpstreamSettings_Status
	err = actual.AssignPropertiesFromServerlessUpstreamSettings_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ServerlessUpstreamSettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServerlessUpstreamSettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServerlessUpstreamSettings_Status, ServerlessUpstreamSettings_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServerlessUpstreamSettings_Status runs a test to see if a specific instance of ServerlessUpstreamSettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForServerlessUpstreamSettings_Status(subject ServerlessUpstreamSettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServerlessUpstreamSettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServerlessUpstreamSettings_Status instances for property testing - lazily instantiated by
//ServerlessUpstreamSettings_StatusGenerator()
var serverlessUpstreamSettings_statusGenerator gopter.Gen

// ServerlessUpstreamSettings_StatusGenerator returns a generator of ServerlessUpstreamSettings_Status instances for property testing.
func ServerlessUpstreamSettings_StatusGenerator() gopter.Gen {
	if serverlessUpstreamSettings_statusGenerator != nil {
		return serverlessUpstreamSettings_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForServerlessUpstreamSettings_Status(generators)
	serverlessUpstreamSettings_statusGenerator = gen.Struct(reflect.TypeOf(ServerlessUpstreamSettings_Status{}), generators)

	return serverlessUpstreamSettings_statusGenerator
}

// AddRelatedPropertyGeneratorsForServerlessUpstreamSettings_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForServerlessUpstreamSettings_Status(gens map[string]gopter.Gen) {
	gens["Templates"] = gen.SliceOf(UpstreamTemplate_StatusGenerator())
}

func Test_SharedPrivateLinkResource_Status_SignalR_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SharedPrivateLinkResource_Status_SignalR_SubResourceEmbedded to SharedPrivateLinkResource_Status_SignalR_SubResourceEmbedded via AssignPropertiesToSharedPrivateLinkResource_Status_SignalR_SubResourceEmbedded & AssignPropertiesFromSharedPrivateLinkResource_Status_SignalR_SubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForSharedPrivateLinkResource_Status_SignalR_SubResourceEmbedded, SharedPrivateLinkResource_Status_SignalR_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSharedPrivateLinkResource_Status_SignalR_SubResourceEmbedded tests if a specific instance of SharedPrivateLinkResource_Status_SignalR_SubResourceEmbedded can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForSharedPrivateLinkResource_Status_SignalR_SubResourceEmbedded(subject SharedPrivateLinkResource_Status_SignalR_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.SharedPrivateLinkResource_Status_SignalR_SubResourceEmbedded
	err := copied.AssignPropertiesToSharedPrivateLinkResource_Status_SignalR_SubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SharedPrivateLinkResource_Status_SignalR_SubResourceEmbedded
	err = actual.AssignPropertiesFromSharedPrivateLinkResource_Status_SignalR_SubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SharedPrivateLinkResource_Status_SignalR_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SharedPrivateLinkResource_Status_SignalR_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSharedPrivateLinkResource_Status_SignalR_SubResourceEmbedded, SharedPrivateLinkResource_Status_SignalR_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSharedPrivateLinkResource_Status_SignalR_SubResourceEmbedded runs a test to see if a specific instance of SharedPrivateLinkResource_Status_SignalR_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForSharedPrivateLinkResource_Status_SignalR_SubResourceEmbedded(subject SharedPrivateLinkResource_Status_SignalR_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SharedPrivateLinkResource_Status_SignalR_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SharedPrivateLinkResource_Status_SignalR_SubResourceEmbedded instances for property testing - lazily
//instantiated by SharedPrivateLinkResource_Status_SignalR_SubResourceEmbeddedGenerator()
var sharedPrivateLinkResource_status_signalR_subResourceEmbeddedGenerator gopter.Gen

// SharedPrivateLinkResource_Status_SignalR_SubResourceEmbeddedGenerator returns a generator of SharedPrivateLinkResource_Status_SignalR_SubResourceEmbedded instances for property testing.
// We first initialize sharedPrivateLinkResource_status_signalR_subResourceEmbeddedGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SharedPrivateLinkResource_Status_SignalR_SubResourceEmbeddedGenerator() gopter.Gen {
	if sharedPrivateLinkResource_status_signalR_subResourceEmbeddedGenerator != nil {
		return sharedPrivateLinkResource_status_signalR_subResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSharedPrivateLinkResource_Status_SignalR_SubResourceEmbedded(generators)
	sharedPrivateLinkResource_status_signalR_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(SharedPrivateLinkResource_Status_SignalR_SubResourceEmbedded{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSharedPrivateLinkResource_Status_SignalR_SubResourceEmbedded(generators)
	AddRelatedPropertyGeneratorsForSharedPrivateLinkResource_Status_SignalR_SubResourceEmbedded(generators)
	sharedPrivateLinkResource_status_signalR_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(SharedPrivateLinkResource_Status_SignalR_SubResourceEmbedded{}), generators)

	return sharedPrivateLinkResource_status_signalR_subResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForSharedPrivateLinkResource_Status_SignalR_SubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSharedPrivateLinkResource_Status_SignalR_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSharedPrivateLinkResource_Status_SignalR_SubResourceEmbedded is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSharedPrivateLinkResource_Status_SignalR_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["SystemData"] = gen.PtrOf(SystemData_StatusGenerator())
}

func Test_SignalRCorsSettings_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SignalRCorsSettings_Spec to SignalRCorsSettings_Spec via AssignPropertiesToSignalRCorsSettings_Spec & AssignPropertiesFromSignalRCorsSettings_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForSignalRCorsSettings_Spec, SignalRCorsSettings_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSignalRCorsSettings_Spec tests if a specific instance of SignalRCorsSettings_Spec can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForSignalRCorsSettings_Spec(subject SignalRCorsSettings_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.SignalRCorsSettings_Spec
	err := copied.AssignPropertiesToSignalRCorsSettings_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SignalRCorsSettings_Spec
	err = actual.AssignPropertiesFromSignalRCorsSettings_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SignalRCorsSettings_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRCorsSettings_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRCorsSettings_Spec, SignalRCorsSettings_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRCorsSettings_Spec runs a test to see if a specific instance of SignalRCorsSettings_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRCorsSettings_Spec(subject SignalRCorsSettings_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRCorsSettings_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRCorsSettings_Spec instances for property testing - lazily instantiated by
//SignalRCorsSettings_SpecGenerator()
var signalRCorsSettings_specGenerator gopter.Gen

// SignalRCorsSettings_SpecGenerator returns a generator of SignalRCorsSettings_Spec instances for property testing.
func SignalRCorsSettings_SpecGenerator() gopter.Gen {
	if signalRCorsSettings_specGenerator != nil {
		return signalRCorsSettings_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRCorsSettings_Spec(generators)
	signalRCorsSettings_specGenerator = gen.Struct(reflect.TypeOf(SignalRCorsSettings_Spec{}), generators)

	return signalRCorsSettings_specGenerator
}

// AddIndependentPropertyGeneratorsForSignalRCorsSettings_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRCorsSettings_Spec(gens map[string]gopter.Gen) {
	gens["AllowedOrigins"] = gen.SliceOf(gen.AlphaString())
}

func Test_SignalRCorsSettings_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SignalRCorsSettings_Status to SignalRCorsSettings_Status via AssignPropertiesToSignalRCorsSettings_Status & AssignPropertiesFromSignalRCorsSettings_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForSignalRCorsSettings_Status, SignalRCorsSettings_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSignalRCorsSettings_Status tests if a specific instance of SignalRCorsSettings_Status can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForSignalRCorsSettings_Status(subject SignalRCorsSettings_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.SignalRCorsSettings_Status
	err := copied.AssignPropertiesToSignalRCorsSettings_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SignalRCorsSettings_Status
	err = actual.AssignPropertiesFromSignalRCorsSettings_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SignalRCorsSettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRCorsSettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRCorsSettings_Status, SignalRCorsSettings_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRCorsSettings_Status runs a test to see if a specific instance of SignalRCorsSettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRCorsSettings_Status(subject SignalRCorsSettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRCorsSettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRCorsSettings_Status instances for property testing - lazily instantiated by
//SignalRCorsSettings_StatusGenerator()
var signalRCorsSettings_statusGenerator gopter.Gen

// SignalRCorsSettings_StatusGenerator returns a generator of SignalRCorsSettings_Status instances for property testing.
func SignalRCorsSettings_StatusGenerator() gopter.Gen {
	if signalRCorsSettings_statusGenerator != nil {
		return signalRCorsSettings_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRCorsSettings_Status(generators)
	signalRCorsSettings_statusGenerator = gen.Struct(reflect.TypeOf(SignalRCorsSettings_Status{}), generators)

	return signalRCorsSettings_statusGenerator
}

// AddIndependentPropertyGeneratorsForSignalRCorsSettings_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRCorsSettings_Status(gens map[string]gopter.Gen) {
	gens["AllowedOrigins"] = gen.SliceOf(gen.AlphaString())
}

func Test_SignalRFeature_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SignalRFeature_Spec to SignalRFeature_Spec via AssignPropertiesToSignalRFeature_Spec & AssignPropertiesFromSignalRFeature_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForSignalRFeature_Spec, SignalRFeature_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSignalRFeature_Spec tests if a specific instance of SignalRFeature_Spec can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForSignalRFeature_Spec(subject SignalRFeature_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.SignalRFeature_Spec
	err := copied.AssignPropertiesToSignalRFeature_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SignalRFeature_Spec
	err = actual.AssignPropertiesFromSignalRFeature_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SignalRFeature_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRFeature_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRFeature_Spec, SignalRFeature_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRFeature_Spec runs a test to see if a specific instance of SignalRFeature_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRFeature_Spec(subject SignalRFeature_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRFeature_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRFeature_Spec instances for property testing - lazily instantiated by
//SignalRFeature_SpecGenerator()
var signalRFeature_specGenerator gopter.Gen

// SignalRFeature_SpecGenerator returns a generator of SignalRFeature_Spec instances for property testing.
func SignalRFeature_SpecGenerator() gopter.Gen {
	if signalRFeature_specGenerator != nil {
		return signalRFeature_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRFeature_Spec(generators)
	signalRFeature_specGenerator = gen.Struct(reflect.TypeOf(SignalRFeature_Spec{}), generators)

	return signalRFeature_specGenerator
}

// AddIndependentPropertyGeneratorsForSignalRFeature_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRFeature_Spec(gens map[string]gopter.Gen) {
	gens["Flag"] = gen.OneConstOf(
		FeatureFlags_SpecEnableConnectivityLogs,
		FeatureFlags_SpecEnableLiveTrace,
		FeatureFlags_SpecEnableMessagingLogs,
		FeatureFlags_SpecServiceMode)
	gens["Properties"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Value"] = gen.AlphaString()
}

func Test_SignalRFeature_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SignalRFeature_Status to SignalRFeature_Status via AssignPropertiesToSignalRFeature_Status & AssignPropertiesFromSignalRFeature_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForSignalRFeature_Status, SignalRFeature_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSignalRFeature_Status tests if a specific instance of SignalRFeature_Status can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForSignalRFeature_Status(subject SignalRFeature_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.SignalRFeature_Status
	err := copied.AssignPropertiesToSignalRFeature_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SignalRFeature_Status
	err = actual.AssignPropertiesFromSignalRFeature_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SignalRFeature_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRFeature_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRFeature_Status, SignalRFeature_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRFeature_Status runs a test to see if a specific instance of SignalRFeature_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRFeature_Status(subject SignalRFeature_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRFeature_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRFeature_Status instances for property testing - lazily instantiated by
//SignalRFeature_StatusGenerator()
var signalRFeature_statusGenerator gopter.Gen

// SignalRFeature_StatusGenerator returns a generator of SignalRFeature_Status instances for property testing.
func SignalRFeature_StatusGenerator() gopter.Gen {
	if signalRFeature_statusGenerator != nil {
		return signalRFeature_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRFeature_Status(generators)
	signalRFeature_statusGenerator = gen.Struct(reflect.TypeOf(SignalRFeature_Status{}), generators)

	return signalRFeature_statusGenerator
}

// AddIndependentPropertyGeneratorsForSignalRFeature_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRFeature_Status(gens map[string]gopter.Gen) {
	gens["Flag"] = gen.OneConstOf(
		FeatureFlags_StatusEnableConnectivityLogs,
		FeatureFlags_StatusEnableLiveTrace,
		FeatureFlags_StatusEnableMessagingLogs,
		FeatureFlags_StatusServiceMode)
	gens["Properties"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Value"] = gen.AlphaString()
}

func Test_SignalRNetworkACLs_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SignalRNetworkACLs_Spec to SignalRNetworkACLs_Spec via AssignPropertiesToSignalRNetworkACLs_Spec & AssignPropertiesFromSignalRNetworkACLs_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForSignalRNetworkACLs_Spec, SignalRNetworkACLs_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSignalRNetworkACLs_Spec tests if a specific instance of SignalRNetworkACLs_Spec can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForSignalRNetworkACLs_Spec(subject SignalRNetworkACLs_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.SignalRNetworkACLs_Spec
	err := copied.AssignPropertiesToSignalRNetworkACLs_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SignalRNetworkACLs_Spec
	err = actual.AssignPropertiesFromSignalRNetworkACLs_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SignalRNetworkACLs_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRNetworkACLs_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRNetworkACLs_Spec, SignalRNetworkACLs_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRNetworkACLs_Spec runs a test to see if a specific instance of SignalRNetworkACLs_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRNetworkACLs_Spec(subject SignalRNetworkACLs_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRNetworkACLs_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRNetworkACLs_Spec instances for property testing - lazily instantiated by
//SignalRNetworkACLs_SpecGenerator()
var signalRNetworkACLs_specGenerator gopter.Gen

// SignalRNetworkACLs_SpecGenerator returns a generator of SignalRNetworkACLs_Spec instances for property testing.
// We first initialize signalRNetworkACLs_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SignalRNetworkACLs_SpecGenerator() gopter.Gen {
	if signalRNetworkACLs_specGenerator != nil {
		return signalRNetworkACLs_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRNetworkACLs_Spec(generators)
	signalRNetworkACLs_specGenerator = gen.Struct(reflect.TypeOf(SignalRNetworkACLs_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRNetworkACLs_Spec(generators)
	AddRelatedPropertyGeneratorsForSignalRNetworkACLs_Spec(generators)
	signalRNetworkACLs_specGenerator = gen.Struct(reflect.TypeOf(SignalRNetworkACLs_Spec{}), generators)

	return signalRNetworkACLs_specGenerator
}

// AddIndependentPropertyGeneratorsForSignalRNetworkACLs_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRNetworkACLs_Spec(gens map[string]gopter.Gen) {
	gens["DefaultAction"] = gen.PtrOf(gen.OneConstOf(ACLAction_SpecAllow, ACLAction_SpecDeny))
}

// AddRelatedPropertyGeneratorsForSignalRNetworkACLs_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSignalRNetworkACLs_Spec(gens map[string]gopter.Gen) {
	gens["PrivateEndpoints"] = gen.SliceOf(PrivateEndpointACL_SpecGenerator())
	gens["PublicNetwork"] = gen.PtrOf(NetworkACL_SpecGenerator())
}

func Test_SignalRNetworkACLs_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SignalRNetworkACLs_Status to SignalRNetworkACLs_Status via AssignPropertiesToSignalRNetworkACLs_Status & AssignPropertiesFromSignalRNetworkACLs_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForSignalRNetworkACLs_Status, SignalRNetworkACLs_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSignalRNetworkACLs_Status tests if a specific instance of SignalRNetworkACLs_Status can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForSignalRNetworkACLs_Status(subject SignalRNetworkACLs_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.SignalRNetworkACLs_Status
	err := copied.AssignPropertiesToSignalRNetworkACLs_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SignalRNetworkACLs_Status
	err = actual.AssignPropertiesFromSignalRNetworkACLs_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SignalRNetworkACLs_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRNetworkACLs_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRNetworkACLs_Status, SignalRNetworkACLs_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRNetworkACLs_Status runs a test to see if a specific instance of SignalRNetworkACLs_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRNetworkACLs_Status(subject SignalRNetworkACLs_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRNetworkACLs_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRNetworkACLs_Status instances for property testing - lazily instantiated by
//SignalRNetworkACLs_StatusGenerator()
var signalRNetworkACLs_statusGenerator gopter.Gen

// SignalRNetworkACLs_StatusGenerator returns a generator of SignalRNetworkACLs_Status instances for property testing.
// We first initialize signalRNetworkACLs_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SignalRNetworkACLs_StatusGenerator() gopter.Gen {
	if signalRNetworkACLs_statusGenerator != nil {
		return signalRNetworkACLs_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRNetworkACLs_Status(generators)
	signalRNetworkACLs_statusGenerator = gen.Struct(reflect.TypeOf(SignalRNetworkACLs_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRNetworkACLs_Status(generators)
	AddRelatedPropertyGeneratorsForSignalRNetworkACLs_Status(generators)
	signalRNetworkACLs_statusGenerator = gen.Struct(reflect.TypeOf(SignalRNetworkACLs_Status{}), generators)

	return signalRNetworkACLs_statusGenerator
}

// AddIndependentPropertyGeneratorsForSignalRNetworkACLs_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRNetworkACLs_Status(gens map[string]gopter.Gen) {
	gens["DefaultAction"] = gen.PtrOf(gen.OneConstOf(ACLAction_StatusAllow, ACLAction_StatusDeny))
}

// AddRelatedPropertyGeneratorsForSignalRNetworkACLs_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSignalRNetworkACLs_Status(gens map[string]gopter.Gen) {
	gens["PrivateEndpoints"] = gen.SliceOf(PrivateEndpointACL_StatusGenerator())
	gens["PublicNetwork"] = gen.PtrOf(NetworkACL_StatusGenerator())
}

func Test_SignalRTlsSettings_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SignalRTlsSettings_Spec to SignalRTlsSettings_Spec via AssignPropertiesToSignalRTlsSettings_Spec & AssignPropertiesFromSignalRTlsSettings_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForSignalRTlsSettings_Spec, SignalRTlsSettings_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSignalRTlsSettings_Spec tests if a specific instance of SignalRTlsSettings_Spec can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForSignalRTlsSettings_Spec(subject SignalRTlsSettings_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.SignalRTlsSettings_Spec
	err := copied.AssignPropertiesToSignalRTlsSettings_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SignalRTlsSettings_Spec
	err = actual.AssignPropertiesFromSignalRTlsSettings_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SignalRTlsSettings_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRTlsSettings_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRTlsSettings_Spec, SignalRTlsSettings_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRTlsSettings_Spec runs a test to see if a specific instance of SignalRTlsSettings_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRTlsSettings_Spec(subject SignalRTlsSettings_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRTlsSettings_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRTlsSettings_Spec instances for property testing - lazily instantiated by
//SignalRTlsSettings_SpecGenerator()
var signalRTlsSettings_specGenerator gopter.Gen

// SignalRTlsSettings_SpecGenerator returns a generator of SignalRTlsSettings_Spec instances for property testing.
func SignalRTlsSettings_SpecGenerator() gopter.Gen {
	if signalRTlsSettings_specGenerator != nil {
		return signalRTlsSettings_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRTlsSettings_Spec(generators)
	signalRTlsSettings_specGenerator = gen.Struct(reflect.TypeOf(SignalRTlsSettings_Spec{}), generators)

	return signalRTlsSettings_specGenerator
}

// AddIndependentPropertyGeneratorsForSignalRTlsSettings_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRTlsSettings_Spec(gens map[string]gopter.Gen) {
	gens["ClientCertEnabled"] = gen.PtrOf(gen.Bool())
}

func Test_SignalRTlsSettings_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SignalRTlsSettings_Status to SignalRTlsSettings_Status via AssignPropertiesToSignalRTlsSettings_Status & AssignPropertiesFromSignalRTlsSettings_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForSignalRTlsSettings_Status, SignalRTlsSettings_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSignalRTlsSettings_Status tests if a specific instance of SignalRTlsSettings_Status can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForSignalRTlsSettings_Status(subject SignalRTlsSettings_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.SignalRTlsSettings_Status
	err := copied.AssignPropertiesToSignalRTlsSettings_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SignalRTlsSettings_Status
	err = actual.AssignPropertiesFromSignalRTlsSettings_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SignalRTlsSettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRTlsSettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRTlsSettings_Status, SignalRTlsSettings_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRTlsSettings_Status runs a test to see if a specific instance of SignalRTlsSettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRTlsSettings_Status(subject SignalRTlsSettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRTlsSettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRTlsSettings_Status instances for property testing - lazily instantiated by
//SignalRTlsSettings_StatusGenerator()
var signalRTlsSettings_statusGenerator gopter.Gen

// SignalRTlsSettings_StatusGenerator returns a generator of SignalRTlsSettings_Status instances for property testing.
func SignalRTlsSettings_StatusGenerator() gopter.Gen {
	if signalRTlsSettings_statusGenerator != nil {
		return signalRTlsSettings_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRTlsSettings_Status(generators)
	signalRTlsSettings_statusGenerator = gen.Struct(reflect.TypeOf(SignalRTlsSettings_Status{}), generators)

	return signalRTlsSettings_statusGenerator
}

// AddIndependentPropertyGeneratorsForSignalRTlsSettings_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRTlsSettings_Status(gens map[string]gopter.Gen) {
	gens["ClientCertEnabled"] = gen.PtrOf(gen.Bool())
}

func Test_SystemData_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SystemData_Status to SystemData_Status via AssignPropertiesToSystemData_Status & AssignPropertiesFromSystemData_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForSystemData_Status, SystemData_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSystemData_Status tests if a specific instance of SystemData_Status can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForSystemData_Status(subject SystemData_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.SystemData_Status
	err := copied.AssignPropertiesToSystemData_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SystemData_Status
	err = actual.AssignPropertiesFromSystemData_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SystemData_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SystemData_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSystemData_Status, SystemData_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSystemData_Status runs a test to see if a specific instance of SystemData_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSystemData_Status(subject SystemData_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SystemData_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SystemData_Status instances for property testing - lazily instantiated by SystemData_StatusGenerator()
var systemData_statusGenerator gopter.Gen

// SystemData_StatusGenerator returns a generator of SystemData_Status instances for property testing.
func SystemData_StatusGenerator() gopter.Gen {
	if systemData_statusGenerator != nil {
		return systemData_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSystemData_Status(generators)
	systemData_statusGenerator = gen.Struct(reflect.TypeOf(SystemData_Status{}), generators)

	return systemData_statusGenerator
}

// AddIndependentPropertyGeneratorsForSystemData_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSystemData_Status(gens map[string]gopter.Gen) {
	gens["CreatedAt"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedBy"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemData_CreatedByType_StatusApplication,
		SystemData_CreatedByType_StatusKey,
		SystemData_CreatedByType_StatusManagedIdentity,
		SystemData_CreatedByType_StatusUser))
	gens["LastModifiedAt"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedBy"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemData_LastModifiedByType_StatusApplication,
		SystemData_LastModifiedByType_StatusKey,
		SystemData_LastModifiedByType_StatusManagedIdentity,
		SystemData_LastModifiedByType_StatusUser))
}

func Test_NetworkACL_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NetworkACL_Spec to NetworkACL_Spec via AssignPropertiesToNetworkACL_Spec & AssignPropertiesFromNetworkACL_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForNetworkACL_Spec, NetworkACL_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNetworkACL_Spec tests if a specific instance of NetworkACL_Spec can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForNetworkACL_Spec(subject NetworkACL_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.NetworkACL_Spec
	err := copied.AssignPropertiesToNetworkACL_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NetworkACL_Spec
	err = actual.AssignPropertiesFromNetworkACL_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NetworkACL_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkACL_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkACL_Spec, NetworkACL_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkACL_Spec runs a test to see if a specific instance of NetworkACL_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkACL_Spec(subject NetworkACL_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkACL_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkACL_Spec instances for property testing - lazily instantiated by NetworkACL_SpecGenerator()
var networkACL_specGenerator gopter.Gen

// NetworkACL_SpecGenerator returns a generator of NetworkACL_Spec instances for property testing.
func NetworkACL_SpecGenerator() gopter.Gen {
	if networkACL_specGenerator != nil {
		return networkACL_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkACL_Spec(generators)
	networkACL_specGenerator = gen.Struct(reflect.TypeOf(NetworkACL_Spec{}), generators)

	return networkACL_specGenerator
}

// AddIndependentPropertyGeneratorsForNetworkACL_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkACL_Spec(gens map[string]gopter.Gen) {
	gens["Allow"] = gen.SliceOf(gen.OneConstOf(
		SignalRRequestType_SpecClientConnection,
		SignalRRequestType_SpecRESTAPI,
		SignalRRequestType_SpecServerConnection,
		SignalRRequestType_SpecTrace))
	gens["Deny"] = gen.SliceOf(gen.OneConstOf(
		SignalRRequestType_SpecClientConnection,
		SignalRRequestType_SpecRESTAPI,
		SignalRRequestType_SpecServerConnection,
		SignalRRequestType_SpecTrace))
}

func Test_NetworkACL_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NetworkACL_Status to NetworkACL_Status via AssignPropertiesToNetworkACL_Status & AssignPropertiesFromNetworkACL_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForNetworkACL_Status, NetworkACL_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNetworkACL_Status tests if a specific instance of NetworkACL_Status can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForNetworkACL_Status(subject NetworkACL_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.NetworkACL_Status
	err := copied.AssignPropertiesToNetworkACL_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NetworkACL_Status
	err = actual.AssignPropertiesFromNetworkACL_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NetworkACL_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkACL_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkACL_Status, NetworkACL_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkACL_Status runs a test to see if a specific instance of NetworkACL_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkACL_Status(subject NetworkACL_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkACL_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkACL_Status instances for property testing - lazily instantiated by NetworkACL_StatusGenerator()
var networkACL_statusGenerator gopter.Gen

// NetworkACL_StatusGenerator returns a generator of NetworkACL_Status instances for property testing.
func NetworkACL_StatusGenerator() gopter.Gen {
	if networkACL_statusGenerator != nil {
		return networkACL_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkACL_Status(generators)
	networkACL_statusGenerator = gen.Struct(reflect.TypeOf(NetworkACL_Status{}), generators)

	return networkACL_statusGenerator
}

// AddIndependentPropertyGeneratorsForNetworkACL_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkACL_Status(gens map[string]gopter.Gen) {
	gens["Allow"] = gen.SliceOf(gen.OneConstOf(
		SignalRRequestType_StatusClientConnection,
		SignalRRequestType_StatusRESTAPI,
		SignalRRequestType_StatusServerConnection,
		SignalRRequestType_StatusTrace))
	gens["Deny"] = gen.SliceOf(gen.OneConstOf(
		SignalRRequestType_StatusClientConnection,
		SignalRRequestType_StatusRESTAPI,
		SignalRRequestType_StatusServerConnection,
		SignalRRequestType_StatusTrace))
}

func Test_PrivateEndpointACL_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PrivateEndpointACL_Spec to PrivateEndpointACL_Spec via AssignPropertiesToPrivateEndpointACL_Spec & AssignPropertiesFromPrivateEndpointACL_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForPrivateEndpointACL_Spec, PrivateEndpointACL_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPrivateEndpointACL_Spec tests if a specific instance of PrivateEndpointACL_Spec can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForPrivateEndpointACL_Spec(subject PrivateEndpointACL_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.PrivateEndpointACL_Spec
	err := copied.AssignPropertiesToPrivateEndpointACL_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PrivateEndpointACL_Spec
	err = actual.AssignPropertiesFromPrivateEndpointACL_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PrivateEndpointACL_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointACL_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointACL_Spec, PrivateEndpointACL_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointACL_Spec runs a test to see if a specific instance of PrivateEndpointACL_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointACL_Spec(subject PrivateEndpointACL_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointACL_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointACL_Spec instances for property testing - lazily instantiated by
//PrivateEndpointACL_SpecGenerator()
var privateEndpointACL_specGenerator gopter.Gen

// PrivateEndpointACL_SpecGenerator returns a generator of PrivateEndpointACL_Spec instances for property testing.
func PrivateEndpointACL_SpecGenerator() gopter.Gen {
	if privateEndpointACL_specGenerator != nil {
		return privateEndpointACL_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointACL_Spec(generators)
	privateEndpointACL_specGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointACL_Spec{}), generators)

	return privateEndpointACL_specGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointACL_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointACL_Spec(gens map[string]gopter.Gen) {
	gens["Allow"] = gen.SliceOf(gen.OneConstOf(
		SignalRRequestType_SpecClientConnection,
		SignalRRequestType_SpecRESTAPI,
		SignalRRequestType_SpecServerConnection,
		SignalRRequestType_SpecTrace))
	gens["Deny"] = gen.SliceOf(gen.OneConstOf(
		SignalRRequestType_SpecClientConnection,
		SignalRRequestType_SpecRESTAPI,
		SignalRRequestType_SpecServerConnection,
		SignalRRequestType_SpecTrace))
	gens["Name"] = gen.AlphaString()
}

func Test_PrivateEndpointACL_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PrivateEndpointACL_Status to PrivateEndpointACL_Status via AssignPropertiesToPrivateEndpointACL_Status & AssignPropertiesFromPrivateEndpointACL_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForPrivateEndpointACL_Status, PrivateEndpointACL_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPrivateEndpointACL_Status tests if a specific instance of PrivateEndpointACL_Status can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForPrivateEndpointACL_Status(subject PrivateEndpointACL_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.PrivateEndpointACL_Status
	err := copied.AssignPropertiesToPrivateEndpointACL_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PrivateEndpointACL_Status
	err = actual.AssignPropertiesFromPrivateEndpointACL_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PrivateEndpointACL_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointACL_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointACL_Status, PrivateEndpointACL_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointACL_Status runs a test to see if a specific instance of PrivateEndpointACL_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointACL_Status(subject PrivateEndpointACL_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointACL_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointACL_Status instances for property testing - lazily instantiated by
//PrivateEndpointACL_StatusGenerator()
var privateEndpointACL_statusGenerator gopter.Gen

// PrivateEndpointACL_StatusGenerator returns a generator of PrivateEndpointACL_Status instances for property testing.
func PrivateEndpointACL_StatusGenerator() gopter.Gen {
	if privateEndpointACL_statusGenerator != nil {
		return privateEndpointACL_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointACL_Status(generators)
	privateEndpointACL_statusGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointACL_Status{}), generators)

	return privateEndpointACL_statusGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointACL_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointACL_Status(gens map[string]gopter.Gen) {
	gens["Allow"] = gen.SliceOf(gen.OneConstOf(
		SignalRRequestType_StatusClientConnection,
		SignalRRequestType_StatusRESTAPI,
		SignalRRequestType_StatusServerConnection,
		SignalRRequestType_StatusTrace))
	gens["Deny"] = gen.SliceOf(gen.OneConstOf(
		SignalRRequestType_StatusClientConnection,
		SignalRRequestType_StatusRESTAPI,
		SignalRRequestType_StatusServerConnection,
		SignalRRequestType_StatusTrace))
	gens["Name"] = gen.AlphaString()
}

func Test_ResourceLogCategory_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResourceLogCategory_Spec to ResourceLogCategory_Spec via AssignPropertiesToResourceLogCategory_Spec & AssignPropertiesFromResourceLogCategory_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForResourceLogCategory_Spec, ResourceLogCategory_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResourceLogCategory_Spec tests if a specific instance of ResourceLogCategory_Spec can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForResourceLogCategory_Spec(subject ResourceLogCategory_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.ResourceLogCategory_Spec
	err := copied.AssignPropertiesToResourceLogCategory_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResourceLogCategory_Spec
	err = actual.AssignPropertiesFromResourceLogCategory_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResourceLogCategory_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceLogCategory_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceLogCategory_Spec, ResourceLogCategory_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceLogCategory_Spec runs a test to see if a specific instance of ResourceLogCategory_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceLogCategory_Spec(subject ResourceLogCategory_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceLogCategory_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceLogCategory_Spec instances for property testing - lazily instantiated by
//ResourceLogCategory_SpecGenerator()
var resourceLogCategory_specGenerator gopter.Gen

// ResourceLogCategory_SpecGenerator returns a generator of ResourceLogCategory_Spec instances for property testing.
func ResourceLogCategory_SpecGenerator() gopter.Gen {
	if resourceLogCategory_specGenerator != nil {
		return resourceLogCategory_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceLogCategory_Spec(generators)
	resourceLogCategory_specGenerator = gen.Struct(reflect.TypeOf(ResourceLogCategory_Spec{}), generators)

	return resourceLogCategory_specGenerator
}

// AddIndependentPropertyGeneratorsForResourceLogCategory_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceLogCategory_Spec(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_ResourceLogCategory_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResourceLogCategory_Status to ResourceLogCategory_Status via AssignPropertiesToResourceLogCategory_Status & AssignPropertiesFromResourceLogCategory_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForResourceLogCategory_Status, ResourceLogCategory_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResourceLogCategory_Status tests if a specific instance of ResourceLogCategory_Status can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForResourceLogCategory_Status(subject ResourceLogCategory_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.ResourceLogCategory_Status
	err := copied.AssignPropertiesToResourceLogCategory_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResourceLogCategory_Status
	err = actual.AssignPropertiesFromResourceLogCategory_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResourceLogCategory_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceLogCategory_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceLogCategory_Status, ResourceLogCategory_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceLogCategory_Status runs a test to see if a specific instance of ResourceLogCategory_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceLogCategory_Status(subject ResourceLogCategory_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceLogCategory_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceLogCategory_Status instances for property testing - lazily instantiated by
//ResourceLogCategory_StatusGenerator()
var resourceLogCategory_statusGenerator gopter.Gen

// ResourceLogCategory_StatusGenerator returns a generator of ResourceLogCategory_Status instances for property testing.
func ResourceLogCategory_StatusGenerator() gopter.Gen {
	if resourceLogCategory_statusGenerator != nil {
		return resourceLogCategory_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceLogCategory_Status(generators)
	resourceLogCategory_statusGenerator = gen.Struct(reflect.TypeOf(ResourceLogCategory_Status{}), generators)

	return resourceLogCategory_statusGenerator
}

// AddIndependentPropertyGeneratorsForResourceLogCategory_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceLogCategory_Status(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_UpstreamTemplate_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UpstreamTemplate_Spec to UpstreamTemplate_Spec via AssignPropertiesToUpstreamTemplate_Spec & AssignPropertiesFromUpstreamTemplate_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForUpstreamTemplate_Spec, UpstreamTemplate_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUpstreamTemplate_Spec tests if a specific instance of UpstreamTemplate_Spec can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForUpstreamTemplate_Spec(subject UpstreamTemplate_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.UpstreamTemplate_Spec
	err := copied.AssignPropertiesToUpstreamTemplate_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UpstreamTemplate_Spec
	err = actual.AssignPropertiesFromUpstreamTemplate_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UpstreamTemplate_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UpstreamTemplate_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUpstreamTemplate_Spec, UpstreamTemplate_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUpstreamTemplate_Spec runs a test to see if a specific instance of UpstreamTemplate_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForUpstreamTemplate_Spec(subject UpstreamTemplate_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UpstreamTemplate_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UpstreamTemplate_Spec instances for property testing - lazily instantiated by
//UpstreamTemplate_SpecGenerator()
var upstreamTemplate_specGenerator gopter.Gen

// UpstreamTemplate_SpecGenerator returns a generator of UpstreamTemplate_Spec instances for property testing.
// We first initialize upstreamTemplate_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UpstreamTemplate_SpecGenerator() gopter.Gen {
	if upstreamTemplate_specGenerator != nil {
		return upstreamTemplate_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpstreamTemplate_Spec(generators)
	upstreamTemplate_specGenerator = gen.Struct(reflect.TypeOf(UpstreamTemplate_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpstreamTemplate_Spec(generators)
	AddRelatedPropertyGeneratorsForUpstreamTemplate_Spec(generators)
	upstreamTemplate_specGenerator = gen.Struct(reflect.TypeOf(UpstreamTemplate_Spec{}), generators)

	return upstreamTemplate_specGenerator
}

// AddIndependentPropertyGeneratorsForUpstreamTemplate_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUpstreamTemplate_Spec(gens map[string]gopter.Gen) {
	gens["CategoryPattern"] = gen.PtrOf(gen.AlphaString())
	gens["EventPattern"] = gen.PtrOf(gen.AlphaString())
	gens["HubPattern"] = gen.PtrOf(gen.AlphaString())
	gens["UrlTemplate"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForUpstreamTemplate_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUpstreamTemplate_Spec(gens map[string]gopter.Gen) {
	gens["Auth"] = gen.PtrOf(UpstreamAuthSettings_SpecGenerator())
}

func Test_UpstreamTemplate_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UpstreamTemplate_Status to UpstreamTemplate_Status via AssignPropertiesToUpstreamTemplate_Status & AssignPropertiesFromUpstreamTemplate_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForUpstreamTemplate_Status, UpstreamTemplate_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUpstreamTemplate_Status tests if a specific instance of UpstreamTemplate_Status can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForUpstreamTemplate_Status(subject UpstreamTemplate_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.UpstreamTemplate_Status
	err := copied.AssignPropertiesToUpstreamTemplate_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UpstreamTemplate_Status
	err = actual.AssignPropertiesFromUpstreamTemplate_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UpstreamTemplate_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UpstreamTemplate_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUpstreamTemplate_Status, UpstreamTemplate_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUpstreamTemplate_Status runs a test to see if a specific instance of UpstreamTemplate_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForUpstreamTemplate_Status(subject UpstreamTemplate_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UpstreamTemplate_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UpstreamTemplate_Status instances for property testing - lazily instantiated by
//UpstreamTemplate_StatusGenerator()
var upstreamTemplate_statusGenerator gopter.Gen

// UpstreamTemplate_StatusGenerator returns a generator of UpstreamTemplate_Status instances for property testing.
// We first initialize upstreamTemplate_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UpstreamTemplate_StatusGenerator() gopter.Gen {
	if upstreamTemplate_statusGenerator != nil {
		return upstreamTemplate_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpstreamTemplate_Status(generators)
	upstreamTemplate_statusGenerator = gen.Struct(reflect.TypeOf(UpstreamTemplate_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpstreamTemplate_Status(generators)
	AddRelatedPropertyGeneratorsForUpstreamTemplate_Status(generators)
	upstreamTemplate_statusGenerator = gen.Struct(reflect.TypeOf(UpstreamTemplate_Status{}), generators)

	return upstreamTemplate_statusGenerator
}

// AddIndependentPropertyGeneratorsForUpstreamTemplate_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUpstreamTemplate_Status(gens map[string]gopter.Gen) {
	gens["CategoryPattern"] = gen.PtrOf(gen.AlphaString())
	gens["EventPattern"] = gen.PtrOf(gen.AlphaString())
	gens["HubPattern"] = gen.PtrOf(gen.AlphaString())
	gens["UrlTemplate"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForUpstreamTemplate_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUpstreamTemplate_Status(gens map[string]gopter.Gen) {
	gens["Auth"] = gen.PtrOf(UpstreamAuthSettings_StatusGenerator())
}

func Test_UserAssignedIdentityProperty_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UserAssignedIdentityProperty_Status to UserAssignedIdentityProperty_Status via AssignPropertiesToUserAssignedIdentityProperty_Status & AssignPropertiesFromUserAssignedIdentityProperty_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForUserAssignedIdentityProperty_Status, UserAssignedIdentityProperty_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUserAssignedIdentityProperty_Status tests if a specific instance of UserAssignedIdentityProperty_Status can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForUserAssignedIdentityProperty_Status(subject UserAssignedIdentityProperty_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.UserAssignedIdentityProperty_Status
	err := copied.AssignPropertiesToUserAssignedIdentityProperty_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UserAssignedIdentityProperty_Status
	err = actual.AssignPropertiesFromUserAssignedIdentityProperty_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UserAssignedIdentityProperty_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentityProperty_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentityProperty_Status, UserAssignedIdentityProperty_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentityProperty_Status runs a test to see if a specific instance of UserAssignedIdentityProperty_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentityProperty_Status(subject UserAssignedIdentityProperty_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentityProperty_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentityProperty_Status instances for property testing - lazily instantiated by
//UserAssignedIdentityProperty_StatusGenerator()
var userAssignedIdentityProperty_statusGenerator gopter.Gen

// UserAssignedIdentityProperty_StatusGenerator returns a generator of UserAssignedIdentityProperty_Status instances for property testing.
func UserAssignedIdentityProperty_StatusGenerator() gopter.Gen {
	if userAssignedIdentityProperty_statusGenerator != nil {
		return userAssignedIdentityProperty_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserAssignedIdentityProperty_Status(generators)
	userAssignedIdentityProperty_statusGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentityProperty_Status{}), generators)

	return userAssignedIdentityProperty_statusGenerator
}

// AddIndependentPropertyGeneratorsForUserAssignedIdentityProperty_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserAssignedIdentityProperty_Status(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_UpstreamAuthSettings_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UpstreamAuthSettings_Spec to UpstreamAuthSettings_Spec via AssignPropertiesToUpstreamAuthSettings_Spec & AssignPropertiesFromUpstreamAuthSettings_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForUpstreamAuthSettings_Spec, UpstreamAuthSettings_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUpstreamAuthSettings_Spec tests if a specific instance of UpstreamAuthSettings_Spec can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForUpstreamAuthSettings_Spec(subject UpstreamAuthSettings_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.UpstreamAuthSettings_Spec
	err := copied.AssignPropertiesToUpstreamAuthSettings_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UpstreamAuthSettings_Spec
	err = actual.AssignPropertiesFromUpstreamAuthSettings_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UpstreamAuthSettings_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UpstreamAuthSettings_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUpstreamAuthSettings_Spec, UpstreamAuthSettings_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUpstreamAuthSettings_Spec runs a test to see if a specific instance of UpstreamAuthSettings_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForUpstreamAuthSettings_Spec(subject UpstreamAuthSettings_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UpstreamAuthSettings_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UpstreamAuthSettings_Spec instances for property testing - lazily instantiated by
//UpstreamAuthSettings_SpecGenerator()
var upstreamAuthSettings_specGenerator gopter.Gen

// UpstreamAuthSettings_SpecGenerator returns a generator of UpstreamAuthSettings_Spec instances for property testing.
// We first initialize upstreamAuthSettings_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UpstreamAuthSettings_SpecGenerator() gopter.Gen {
	if upstreamAuthSettings_specGenerator != nil {
		return upstreamAuthSettings_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpstreamAuthSettings_Spec(generators)
	upstreamAuthSettings_specGenerator = gen.Struct(reflect.TypeOf(UpstreamAuthSettings_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpstreamAuthSettings_Spec(generators)
	AddRelatedPropertyGeneratorsForUpstreamAuthSettings_Spec(generators)
	upstreamAuthSettings_specGenerator = gen.Struct(reflect.TypeOf(UpstreamAuthSettings_Spec{}), generators)

	return upstreamAuthSettings_specGenerator
}

// AddIndependentPropertyGeneratorsForUpstreamAuthSettings_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUpstreamAuthSettings_Spec(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(UpstreamAuthType_SpecManagedIdentity, UpstreamAuthType_SpecNone))
}

// AddRelatedPropertyGeneratorsForUpstreamAuthSettings_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUpstreamAuthSettings_Spec(gens map[string]gopter.Gen) {
	gens["ManagedIdentity"] = gen.PtrOf(ManagedIdentitySettings_SpecGenerator())
}

func Test_UpstreamAuthSettings_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UpstreamAuthSettings_Status to UpstreamAuthSettings_Status via AssignPropertiesToUpstreamAuthSettings_Status & AssignPropertiesFromUpstreamAuthSettings_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForUpstreamAuthSettings_Status, UpstreamAuthSettings_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUpstreamAuthSettings_Status tests if a specific instance of UpstreamAuthSettings_Status can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForUpstreamAuthSettings_Status(subject UpstreamAuthSettings_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.UpstreamAuthSettings_Status
	err := copied.AssignPropertiesToUpstreamAuthSettings_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UpstreamAuthSettings_Status
	err = actual.AssignPropertiesFromUpstreamAuthSettings_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UpstreamAuthSettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UpstreamAuthSettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUpstreamAuthSettings_Status, UpstreamAuthSettings_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUpstreamAuthSettings_Status runs a test to see if a specific instance of UpstreamAuthSettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForUpstreamAuthSettings_Status(subject UpstreamAuthSettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UpstreamAuthSettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UpstreamAuthSettings_Status instances for property testing - lazily instantiated by
//UpstreamAuthSettings_StatusGenerator()
var upstreamAuthSettings_statusGenerator gopter.Gen

// UpstreamAuthSettings_StatusGenerator returns a generator of UpstreamAuthSettings_Status instances for property testing.
// We first initialize upstreamAuthSettings_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UpstreamAuthSettings_StatusGenerator() gopter.Gen {
	if upstreamAuthSettings_statusGenerator != nil {
		return upstreamAuthSettings_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpstreamAuthSettings_Status(generators)
	upstreamAuthSettings_statusGenerator = gen.Struct(reflect.TypeOf(UpstreamAuthSettings_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpstreamAuthSettings_Status(generators)
	AddRelatedPropertyGeneratorsForUpstreamAuthSettings_Status(generators)
	upstreamAuthSettings_statusGenerator = gen.Struct(reflect.TypeOf(UpstreamAuthSettings_Status{}), generators)

	return upstreamAuthSettings_statusGenerator
}

// AddIndependentPropertyGeneratorsForUpstreamAuthSettings_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUpstreamAuthSettings_Status(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(UpstreamAuthType_StatusManagedIdentity, UpstreamAuthType_StatusNone))
}

// AddRelatedPropertyGeneratorsForUpstreamAuthSettings_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUpstreamAuthSettings_Status(gens map[string]gopter.Gen) {
	gens["ManagedIdentity"] = gen.PtrOf(ManagedIdentitySettings_StatusGenerator())
}

func Test_ManagedIdentitySettings_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedIdentitySettings_Spec to ManagedIdentitySettings_Spec via AssignPropertiesToManagedIdentitySettings_Spec & AssignPropertiesFromManagedIdentitySettings_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedIdentitySettings_Spec, ManagedIdentitySettings_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedIdentitySettings_Spec tests if a specific instance of ManagedIdentitySettings_Spec can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForManagedIdentitySettings_Spec(subject ManagedIdentitySettings_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.ManagedIdentitySettings_Spec
	err := copied.AssignPropertiesToManagedIdentitySettings_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedIdentitySettings_Spec
	err = actual.AssignPropertiesFromManagedIdentitySettings_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedIdentitySettings_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedIdentitySettings_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedIdentitySettings_Spec, ManagedIdentitySettings_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedIdentitySettings_Spec runs a test to see if a specific instance of ManagedIdentitySettings_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedIdentitySettings_Spec(subject ManagedIdentitySettings_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedIdentitySettings_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedIdentitySettings_Spec instances for property testing - lazily instantiated by
//ManagedIdentitySettings_SpecGenerator()
var managedIdentitySettings_specGenerator gopter.Gen

// ManagedIdentitySettings_SpecGenerator returns a generator of ManagedIdentitySettings_Spec instances for property testing.
func ManagedIdentitySettings_SpecGenerator() gopter.Gen {
	if managedIdentitySettings_specGenerator != nil {
		return managedIdentitySettings_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedIdentitySettings_Spec(generators)
	managedIdentitySettings_specGenerator = gen.Struct(reflect.TypeOf(ManagedIdentitySettings_Spec{}), generators)

	return managedIdentitySettings_specGenerator
}

// AddIndependentPropertyGeneratorsForManagedIdentitySettings_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedIdentitySettings_Spec(gens map[string]gopter.Gen) {
	gens["Resource"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedIdentitySettings_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedIdentitySettings_Status to ManagedIdentitySettings_Status via AssignPropertiesToManagedIdentitySettings_Status & AssignPropertiesFromManagedIdentitySettings_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedIdentitySettings_Status, ManagedIdentitySettings_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedIdentitySettings_Status tests if a specific instance of ManagedIdentitySettings_Status can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForManagedIdentitySettings_Status(subject ManagedIdentitySettings_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.ManagedIdentitySettings_Status
	err := copied.AssignPropertiesToManagedIdentitySettings_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedIdentitySettings_Status
	err = actual.AssignPropertiesFromManagedIdentitySettings_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedIdentitySettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedIdentitySettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedIdentitySettings_Status, ManagedIdentitySettings_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedIdentitySettings_Status runs a test to see if a specific instance of ManagedIdentitySettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedIdentitySettings_Status(subject ManagedIdentitySettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedIdentitySettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedIdentitySettings_Status instances for property testing - lazily instantiated by
//ManagedIdentitySettings_StatusGenerator()
var managedIdentitySettings_statusGenerator gopter.Gen

// ManagedIdentitySettings_StatusGenerator returns a generator of ManagedIdentitySettings_Status instances for property testing.
func ManagedIdentitySettings_StatusGenerator() gopter.Gen {
	if managedIdentitySettings_statusGenerator != nil {
		return managedIdentitySettings_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedIdentitySettings_Status(generators)
	managedIdentitySettings_statusGenerator = gen.Struct(reflect.TypeOf(ManagedIdentitySettings_Status{}), generators)

	return managedIdentitySettings_statusGenerator
}

// AddIndependentPropertyGeneratorsForManagedIdentitySettings_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedIdentitySettings_Status(gens map[string]gopter.Gen) {
	gens["Resource"] = gen.PtrOf(gen.AlphaString())
}
