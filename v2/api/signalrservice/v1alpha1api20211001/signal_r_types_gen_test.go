// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20211001

import (
	"encoding/json"
	"github.com/Azure/azure-service-operator/v2/api/signalrservice/v1alpha1api20211001storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_SignalR_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SignalR to hub returns original",
		prop.ForAll(RunResourceConversionTestForSignalR, SignalRGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForSignalR tests if a specific instance of SignalR round trips to the hub storage version and back losslessly
func RunResourceConversionTestForSignalR(subject SignalR) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v1alpha1api20211001storage.SignalR
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual SignalR
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SignalR_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SignalR to SignalR via AssignPropertiesToSignalR & AssignPropertiesFromSignalR returns original",
		prop.ForAll(RunPropertyAssignmentTestForSignalR, SignalRGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSignalR tests if a specific instance of SignalR can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForSignalR(subject SignalR) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.SignalR
	err := copied.AssignPropertiesToSignalR(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SignalR
	err = actual.AssignPropertiesFromSignalR(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SignalR_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalR via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalR, SignalRGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalR runs a test to see if a specific instance of SignalR round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalR(subject SignalR) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalR
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalR instances for property testing - lazily instantiated by SignalRGenerator()
var signalRGenerator gopter.Gen

// SignalRGenerator returns a generator of SignalR instances for property testing.
func SignalRGenerator() gopter.Gen {
	if signalRGenerator != nil {
		return signalRGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForSignalR(generators)
	signalRGenerator = gen.Struct(reflect.TypeOf(SignalR{}), generators)

	return signalRGenerator
}

// AddRelatedPropertyGeneratorsForSignalR is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSignalR(gens map[string]gopter.Gen) {
	gens["Spec"] = SignalRSPECGenerator()
	gens["Status"] = SignalRResourceStatusGenerator()
}

func Test_SignalRResource_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SignalRResource_Status to SignalRResource_Status via AssignPropertiesToSignalRResourceStatus & AssignPropertiesFromSignalRResourceStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForSignalRResourceStatus, SignalRResourceStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSignalRResourceStatus tests if a specific instance of SignalRResource_Status can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForSignalRResourceStatus(subject SignalRResource_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.SignalRResource_Status
	err := copied.AssignPropertiesToSignalRResourceStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SignalRResource_Status
	err = actual.AssignPropertiesFromSignalRResourceStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SignalRResource_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRResource_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRResourceStatus, SignalRResourceStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRResourceStatus runs a test to see if a specific instance of SignalRResource_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRResourceStatus(subject SignalRResource_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRResource_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRResource_Status instances for property testing - lazily instantiated by
//SignalRResourceStatusGenerator()
var signalRResourceStatusGenerator gopter.Gen

// SignalRResourceStatusGenerator returns a generator of SignalRResource_Status instances for property testing.
// We first initialize signalRResourceStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SignalRResourceStatusGenerator() gopter.Gen {
	if signalRResourceStatusGenerator != nil {
		return signalRResourceStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRResourceStatus(generators)
	signalRResourceStatusGenerator = gen.Struct(reflect.TypeOf(SignalRResource_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRResourceStatus(generators)
	AddRelatedPropertyGeneratorsForSignalRResourceStatus(generators)
	signalRResourceStatusGenerator = gen.Struct(reflect.TypeOf(SignalRResource_Status{}), generators)

	return signalRResourceStatusGenerator
}

// AddIndependentPropertyGeneratorsForSignalRResourceStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRResourceStatus(gens map[string]gopter.Gen) {
	gens["DisableAadAuth"] = gen.PtrOf(gen.Bool())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["ExternalIP"] = gen.PtrOf(gen.AlphaString())
	gens["HostName"] = gen.PtrOf(gen.AlphaString())
	gens["HostNamePrefix"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(ServiceKind_StatusRawWebSockets, ServiceKind_StatusSignalR))
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_StatusCanceled,
		ProvisioningState_StatusCreating,
		ProvisioningState_StatusDeleting,
		ProvisioningState_StatusFailed,
		ProvisioningState_StatusMoving,
		ProvisioningState_StatusRunning,
		ProvisioningState_StatusSucceeded,
		ProvisioningState_StatusUnknown,
		ProvisioningState_StatusUpdating))
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.AlphaString())
	gens["PublicPort"] = gen.PtrOf(gen.Int())
	gens["ServerPort"] = gen.PtrOf(gen.Int())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["Version"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSignalRResourceStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSignalRResourceStatus(gens map[string]gopter.Gen) {
	gens["Cors"] = gen.PtrOf(SignalRCorsSettingsStatusGenerator())
	gens["Features"] = gen.SliceOf(SignalRFeatureStatusGenerator())
	gens["Identity"] = gen.PtrOf(ManagedIdentityStatusGenerator())
	gens["NetworkACLs"] = gen.PtrOf(SignalRNetworkACLsStatusGenerator())
	gens["PrivateEndpointConnections"] = gen.SliceOf(PrivateEndpointConnectionStatusSignalRSubResourceEmbeddedGenerator())
	gens["ResourceLogConfiguration"] = gen.PtrOf(ResourceLogConfigurationStatusGenerator())
	gens["SharedPrivateLinkResources"] = gen.SliceOf(SharedPrivateLinkResourceStatusSignalRSubResourceEmbeddedGenerator())
	gens["Sku"] = gen.PtrOf(ResourceSkuStatusGenerator())
	gens["SystemData"] = gen.PtrOf(SystemDataStatusGenerator())
	gens["Tls"] = gen.PtrOf(SignalRTlsSettingsStatusGenerator())
	gens["Upstream"] = gen.PtrOf(ServerlessUpstreamSettingsStatusGenerator())
}

func Test_SignalR_SPEC_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SignalR_SPEC to SignalR_SPEC via AssignPropertiesToSignalRSPEC & AssignPropertiesFromSignalRSPEC returns original",
		prop.ForAll(RunPropertyAssignmentTestForSignalRSPEC, SignalRSPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSignalRSPEC tests if a specific instance of SignalR_SPEC can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForSignalRSPEC(subject SignalR_SPEC) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.SignalR_SPEC
	err := copied.AssignPropertiesToSignalRSPEC(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SignalR_SPEC
	err = actual.AssignPropertiesFromSignalRSPEC(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SignalR_SPEC_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalR_SPEC via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRSPEC, SignalRSPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRSPEC runs a test to see if a specific instance of SignalR_SPEC round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRSPEC(subject SignalR_SPEC) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalR_SPEC
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalR_SPEC instances for property testing - lazily instantiated by SignalRSPECGenerator()
var signalRSPECGenerator gopter.Gen

// SignalRSPECGenerator returns a generator of SignalR_SPEC instances for property testing.
// We first initialize signalRSPECGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SignalRSPECGenerator() gopter.Gen {
	if signalRSPECGenerator != nil {
		return signalRSPECGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRSPEC(generators)
	signalRSPECGenerator = gen.Struct(reflect.TypeOf(SignalR_SPEC{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRSPEC(generators)
	AddRelatedPropertyGeneratorsForSignalRSPEC(generators)
	signalRSPECGenerator = gen.Struct(reflect.TypeOf(SignalR_SPEC{}), generators)

	return signalRSPECGenerator
}

// AddIndependentPropertyGeneratorsForSignalRSPEC is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRSPEC(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["DisableAadAuth"] = gen.PtrOf(gen.Bool())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(ServiceKind_SpecRawWebSockets, ServiceKind_SpecSignalR))
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSignalRSPEC is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSignalRSPEC(gens map[string]gopter.Gen) {
	gens["Cors"] = gen.PtrOf(SignalRCorsSettingsSpecGenerator())
	gens["Features"] = gen.SliceOf(SignalRFeatureSpecGenerator())
	gens["Identity"] = gen.PtrOf(ManagedIdentitySpecGenerator())
	gens["NetworkACLs"] = gen.PtrOf(SignalRNetworkACLsSpecGenerator())
	gens["ResourceLogConfiguration"] = gen.PtrOf(ResourceLogConfigurationSpecGenerator())
	gens["Sku"] = gen.PtrOf(ResourceSkuSpecGenerator())
	gens["Tls"] = gen.PtrOf(SignalRTlsSettingsSpecGenerator())
	gens["Upstream"] = gen.PtrOf(ServerlessUpstreamSettingsSpecGenerator())
}

func Test_ManagedIdentity_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedIdentity_Spec to ManagedIdentity_Spec via AssignPropertiesToManagedIdentitySpec & AssignPropertiesFromManagedIdentitySpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedIdentitySpec, ManagedIdentitySpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedIdentitySpec tests if a specific instance of ManagedIdentity_Spec can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForManagedIdentitySpec(subject ManagedIdentity_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.ManagedIdentity_Spec
	err := copied.AssignPropertiesToManagedIdentitySpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedIdentity_Spec
	err = actual.AssignPropertiesFromManagedIdentitySpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedIdentity_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedIdentity_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedIdentitySpec, ManagedIdentitySpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedIdentitySpec runs a test to see if a specific instance of ManagedIdentity_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedIdentitySpec(subject ManagedIdentity_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedIdentity_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedIdentity_Spec instances for property testing - lazily instantiated by
//ManagedIdentitySpecGenerator()
var managedIdentitySpecGenerator gopter.Gen

// ManagedIdentitySpecGenerator returns a generator of ManagedIdentity_Spec instances for property testing.
func ManagedIdentitySpecGenerator() gopter.Gen {
	if managedIdentitySpecGenerator != nil {
		return managedIdentitySpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedIdentitySpec(generators)
	managedIdentitySpecGenerator = gen.Struct(reflect.TypeOf(ManagedIdentity_Spec{}), generators)

	return managedIdentitySpecGenerator
}

// AddIndependentPropertyGeneratorsForManagedIdentitySpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedIdentitySpec(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ManagedIdentityType_SpecNone, ManagedIdentityType_SpecSystemAssigned, ManagedIdentityType_SpecUserAssigned))
}

func Test_ManagedIdentity_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedIdentity_Status to ManagedIdentity_Status via AssignPropertiesToManagedIdentityStatus & AssignPropertiesFromManagedIdentityStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedIdentityStatus, ManagedIdentityStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedIdentityStatus tests if a specific instance of ManagedIdentity_Status can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForManagedIdentityStatus(subject ManagedIdentity_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.ManagedIdentity_Status
	err := copied.AssignPropertiesToManagedIdentityStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedIdentity_Status
	err = actual.AssignPropertiesFromManagedIdentityStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedIdentity_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedIdentity_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedIdentityStatus, ManagedIdentityStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedIdentityStatus runs a test to see if a specific instance of ManagedIdentity_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedIdentityStatus(subject ManagedIdentity_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedIdentity_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedIdentity_Status instances for property testing - lazily instantiated by
//ManagedIdentityStatusGenerator()
var managedIdentityStatusGenerator gopter.Gen

// ManagedIdentityStatusGenerator returns a generator of ManagedIdentity_Status instances for property testing.
// We first initialize managedIdentityStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedIdentityStatusGenerator() gopter.Gen {
	if managedIdentityStatusGenerator != nil {
		return managedIdentityStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedIdentityStatus(generators)
	managedIdentityStatusGenerator = gen.Struct(reflect.TypeOf(ManagedIdentity_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedIdentityStatus(generators)
	AddRelatedPropertyGeneratorsForManagedIdentityStatus(generators)
	managedIdentityStatusGenerator = gen.Struct(reflect.TypeOf(ManagedIdentity_Status{}), generators)

	return managedIdentityStatusGenerator
}

// AddIndependentPropertyGeneratorsForManagedIdentityStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedIdentityStatus(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ManagedIdentityType_StatusNone, ManagedIdentityType_StatusSystemAssigned, ManagedIdentityType_StatusUserAssigned))
}

// AddRelatedPropertyGeneratorsForManagedIdentityStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedIdentityStatus(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), UserAssignedIdentityPropertyStatusGenerator())
}

func Test_PrivateEndpointConnection_Status_SignalR_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PrivateEndpointConnection_Status_SignalR_SubResourceEmbedded to PrivateEndpointConnection_Status_SignalR_SubResourceEmbedded via AssignPropertiesToPrivateEndpointConnectionStatusSignalRSubResourceEmbedded & AssignPropertiesFromPrivateEndpointConnectionStatusSignalRSubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForPrivateEndpointConnectionStatusSignalRSubResourceEmbedded, PrivateEndpointConnectionStatusSignalRSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPrivateEndpointConnectionStatusSignalRSubResourceEmbedded tests if a specific instance of PrivateEndpointConnection_Status_SignalR_SubResourceEmbedded can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForPrivateEndpointConnectionStatusSignalRSubResourceEmbedded(subject PrivateEndpointConnection_Status_SignalR_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.PrivateEndpointConnection_Status_SignalR_SubResourceEmbedded
	err := copied.AssignPropertiesToPrivateEndpointConnectionStatusSignalRSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PrivateEndpointConnection_Status_SignalR_SubResourceEmbedded
	err = actual.AssignPropertiesFromPrivateEndpointConnectionStatusSignalRSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PrivateEndpointConnection_Status_SignalR_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointConnection_Status_SignalR_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointConnectionStatusSignalRSubResourceEmbedded, PrivateEndpointConnectionStatusSignalRSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointConnectionStatusSignalRSubResourceEmbedded runs a test to see if a specific instance of PrivateEndpointConnection_Status_SignalR_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointConnectionStatusSignalRSubResourceEmbedded(subject PrivateEndpointConnection_Status_SignalR_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointConnection_Status_SignalR_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointConnection_Status_SignalR_SubResourceEmbedded instances for property testing - lazily
//instantiated by PrivateEndpointConnectionStatusSignalRSubResourceEmbeddedGenerator()
var privateEndpointConnectionStatusSignalRSubResourceEmbeddedGenerator gopter.Gen

// PrivateEndpointConnectionStatusSignalRSubResourceEmbeddedGenerator returns a generator of PrivateEndpointConnection_Status_SignalR_SubResourceEmbedded instances for property testing.
// We first initialize privateEndpointConnectionStatusSignalRSubResourceEmbeddedGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateEndpointConnectionStatusSignalRSubResourceEmbeddedGenerator() gopter.Gen {
	if privateEndpointConnectionStatusSignalRSubResourceEmbeddedGenerator != nil {
		return privateEndpointConnectionStatusSignalRSubResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnectionStatusSignalRSubResourceEmbedded(generators)
	privateEndpointConnectionStatusSignalRSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnection_Status_SignalR_SubResourceEmbedded{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnectionStatusSignalRSubResourceEmbedded(generators)
	AddRelatedPropertyGeneratorsForPrivateEndpointConnectionStatusSignalRSubResourceEmbedded(generators)
	privateEndpointConnectionStatusSignalRSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnection_Status_SignalR_SubResourceEmbedded{}), generators)

	return privateEndpointConnectionStatusSignalRSubResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointConnectionStatusSignalRSubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointConnectionStatusSignalRSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPrivateEndpointConnectionStatusSignalRSubResourceEmbedded is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateEndpointConnectionStatusSignalRSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["SystemData"] = gen.PtrOf(SystemDataStatusGenerator())
}

func Test_ResourceLogConfiguration_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResourceLogConfiguration_Spec to ResourceLogConfiguration_Spec via AssignPropertiesToResourceLogConfigurationSpec & AssignPropertiesFromResourceLogConfigurationSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForResourceLogConfigurationSpec, ResourceLogConfigurationSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResourceLogConfigurationSpec tests if a specific instance of ResourceLogConfiguration_Spec can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForResourceLogConfigurationSpec(subject ResourceLogConfiguration_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.ResourceLogConfiguration_Spec
	err := copied.AssignPropertiesToResourceLogConfigurationSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResourceLogConfiguration_Spec
	err = actual.AssignPropertiesFromResourceLogConfigurationSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResourceLogConfiguration_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceLogConfiguration_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceLogConfigurationSpec, ResourceLogConfigurationSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceLogConfigurationSpec runs a test to see if a specific instance of ResourceLogConfiguration_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceLogConfigurationSpec(subject ResourceLogConfiguration_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceLogConfiguration_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceLogConfiguration_Spec instances for property testing - lazily instantiated by
//ResourceLogConfigurationSpecGenerator()
var resourceLogConfigurationSpecGenerator gopter.Gen

// ResourceLogConfigurationSpecGenerator returns a generator of ResourceLogConfiguration_Spec instances for property testing.
func ResourceLogConfigurationSpecGenerator() gopter.Gen {
	if resourceLogConfigurationSpecGenerator != nil {
		return resourceLogConfigurationSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForResourceLogConfigurationSpec(generators)
	resourceLogConfigurationSpecGenerator = gen.Struct(reflect.TypeOf(ResourceLogConfiguration_Spec{}), generators)

	return resourceLogConfigurationSpecGenerator
}

// AddRelatedPropertyGeneratorsForResourceLogConfigurationSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResourceLogConfigurationSpec(gens map[string]gopter.Gen) {
	gens["Categories"] = gen.SliceOf(ResourceLogCategorySpecGenerator())
}

func Test_ResourceLogConfiguration_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResourceLogConfiguration_Status to ResourceLogConfiguration_Status via AssignPropertiesToResourceLogConfigurationStatus & AssignPropertiesFromResourceLogConfigurationStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForResourceLogConfigurationStatus, ResourceLogConfigurationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResourceLogConfigurationStatus tests if a specific instance of ResourceLogConfiguration_Status can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForResourceLogConfigurationStatus(subject ResourceLogConfiguration_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.ResourceLogConfiguration_Status
	err := copied.AssignPropertiesToResourceLogConfigurationStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResourceLogConfiguration_Status
	err = actual.AssignPropertiesFromResourceLogConfigurationStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResourceLogConfiguration_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceLogConfiguration_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceLogConfigurationStatus, ResourceLogConfigurationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceLogConfigurationStatus runs a test to see if a specific instance of ResourceLogConfiguration_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceLogConfigurationStatus(subject ResourceLogConfiguration_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceLogConfiguration_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceLogConfiguration_Status instances for property testing - lazily instantiated by
//ResourceLogConfigurationStatusGenerator()
var resourceLogConfigurationStatusGenerator gopter.Gen

// ResourceLogConfigurationStatusGenerator returns a generator of ResourceLogConfiguration_Status instances for property testing.
func ResourceLogConfigurationStatusGenerator() gopter.Gen {
	if resourceLogConfigurationStatusGenerator != nil {
		return resourceLogConfigurationStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForResourceLogConfigurationStatus(generators)
	resourceLogConfigurationStatusGenerator = gen.Struct(reflect.TypeOf(ResourceLogConfiguration_Status{}), generators)

	return resourceLogConfigurationStatusGenerator
}

// AddRelatedPropertyGeneratorsForResourceLogConfigurationStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResourceLogConfigurationStatus(gens map[string]gopter.Gen) {
	gens["Categories"] = gen.SliceOf(ResourceLogCategoryStatusGenerator())
}

func Test_ResourceSku_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResourceSku_Spec to ResourceSku_Spec via AssignPropertiesToResourceSkuSpec & AssignPropertiesFromResourceSkuSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForResourceSkuSpec, ResourceSkuSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResourceSkuSpec tests if a specific instance of ResourceSku_Spec can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForResourceSkuSpec(subject ResourceSku_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.ResourceSku_Spec
	err := copied.AssignPropertiesToResourceSkuSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResourceSku_Spec
	err = actual.AssignPropertiesFromResourceSkuSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResourceSku_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceSku_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceSkuSpec, ResourceSkuSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceSkuSpec runs a test to see if a specific instance of ResourceSku_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceSkuSpec(subject ResourceSku_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceSku_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceSku_Spec instances for property testing - lazily instantiated by ResourceSkuSpecGenerator()
var resourceSkuSpecGenerator gopter.Gen

// ResourceSkuSpecGenerator returns a generator of ResourceSku_Spec instances for property testing.
func ResourceSkuSpecGenerator() gopter.Gen {
	if resourceSkuSpecGenerator != nil {
		return resourceSkuSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceSkuSpec(generators)
	resourceSkuSpecGenerator = gen.Struct(reflect.TypeOf(ResourceSku_Spec{}), generators)

	return resourceSkuSpecGenerator
}

// AddIndependentPropertyGeneratorsForResourceSkuSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceSkuSpec(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.AlphaString()
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(
		SignalRSkuTier_SpecBasic,
		SignalRSkuTier_SpecFree,
		SignalRSkuTier_SpecPremium,
		SignalRSkuTier_SpecStandard))
}

func Test_ResourceSku_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResourceSku_Status to ResourceSku_Status via AssignPropertiesToResourceSkuStatus & AssignPropertiesFromResourceSkuStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForResourceSkuStatus, ResourceSkuStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResourceSkuStatus tests if a specific instance of ResourceSku_Status can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForResourceSkuStatus(subject ResourceSku_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.ResourceSku_Status
	err := copied.AssignPropertiesToResourceSkuStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResourceSku_Status
	err = actual.AssignPropertiesFromResourceSkuStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResourceSku_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceSku_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceSkuStatus, ResourceSkuStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceSkuStatus runs a test to see if a specific instance of ResourceSku_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceSkuStatus(subject ResourceSku_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceSku_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceSku_Status instances for property testing - lazily instantiated by ResourceSkuStatusGenerator()
var resourceSkuStatusGenerator gopter.Gen

// ResourceSkuStatusGenerator returns a generator of ResourceSku_Status instances for property testing.
func ResourceSkuStatusGenerator() gopter.Gen {
	if resourceSkuStatusGenerator != nil {
		return resourceSkuStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceSkuStatus(generators)
	resourceSkuStatusGenerator = gen.Struct(reflect.TypeOf(ResourceSku_Status{}), generators)

	return resourceSkuStatusGenerator
}

// AddIndependentPropertyGeneratorsForResourceSkuStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceSkuStatus(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Family"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Size"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(
		SignalRSkuTier_StatusBasic,
		SignalRSkuTier_StatusFree,
		SignalRSkuTier_StatusPremium,
		SignalRSkuTier_StatusStandard))
}

func Test_ServerlessUpstreamSettings_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ServerlessUpstreamSettings_Spec to ServerlessUpstreamSettings_Spec via AssignPropertiesToServerlessUpstreamSettingsSpec & AssignPropertiesFromServerlessUpstreamSettingsSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForServerlessUpstreamSettingsSpec, ServerlessUpstreamSettingsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForServerlessUpstreamSettingsSpec tests if a specific instance of ServerlessUpstreamSettings_Spec can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForServerlessUpstreamSettingsSpec(subject ServerlessUpstreamSettings_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.ServerlessUpstreamSettings_Spec
	err := copied.AssignPropertiesToServerlessUpstreamSettingsSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ServerlessUpstreamSettings_Spec
	err = actual.AssignPropertiesFromServerlessUpstreamSettingsSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ServerlessUpstreamSettings_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServerlessUpstreamSettings_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServerlessUpstreamSettingsSpec, ServerlessUpstreamSettingsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServerlessUpstreamSettingsSpec runs a test to see if a specific instance of ServerlessUpstreamSettings_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForServerlessUpstreamSettingsSpec(subject ServerlessUpstreamSettings_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServerlessUpstreamSettings_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServerlessUpstreamSettings_Spec instances for property testing - lazily instantiated by
//ServerlessUpstreamSettingsSpecGenerator()
var serverlessUpstreamSettingsSpecGenerator gopter.Gen

// ServerlessUpstreamSettingsSpecGenerator returns a generator of ServerlessUpstreamSettings_Spec instances for property testing.
func ServerlessUpstreamSettingsSpecGenerator() gopter.Gen {
	if serverlessUpstreamSettingsSpecGenerator != nil {
		return serverlessUpstreamSettingsSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForServerlessUpstreamSettingsSpec(generators)
	serverlessUpstreamSettingsSpecGenerator = gen.Struct(reflect.TypeOf(ServerlessUpstreamSettings_Spec{}), generators)

	return serverlessUpstreamSettingsSpecGenerator
}

// AddRelatedPropertyGeneratorsForServerlessUpstreamSettingsSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForServerlessUpstreamSettingsSpec(gens map[string]gopter.Gen) {
	gens["Templates"] = gen.SliceOf(UpstreamTemplateSpecGenerator())
}

func Test_ServerlessUpstreamSettings_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ServerlessUpstreamSettings_Status to ServerlessUpstreamSettings_Status via AssignPropertiesToServerlessUpstreamSettingsStatus & AssignPropertiesFromServerlessUpstreamSettingsStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForServerlessUpstreamSettingsStatus, ServerlessUpstreamSettingsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForServerlessUpstreamSettingsStatus tests if a specific instance of ServerlessUpstreamSettings_Status can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForServerlessUpstreamSettingsStatus(subject ServerlessUpstreamSettings_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.ServerlessUpstreamSettings_Status
	err := copied.AssignPropertiesToServerlessUpstreamSettingsStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ServerlessUpstreamSettings_Status
	err = actual.AssignPropertiesFromServerlessUpstreamSettingsStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ServerlessUpstreamSettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServerlessUpstreamSettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServerlessUpstreamSettingsStatus, ServerlessUpstreamSettingsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServerlessUpstreamSettingsStatus runs a test to see if a specific instance of ServerlessUpstreamSettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForServerlessUpstreamSettingsStatus(subject ServerlessUpstreamSettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServerlessUpstreamSettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServerlessUpstreamSettings_Status instances for property testing - lazily instantiated by
//ServerlessUpstreamSettingsStatusGenerator()
var serverlessUpstreamSettingsStatusGenerator gopter.Gen

// ServerlessUpstreamSettingsStatusGenerator returns a generator of ServerlessUpstreamSettings_Status instances for property testing.
func ServerlessUpstreamSettingsStatusGenerator() gopter.Gen {
	if serverlessUpstreamSettingsStatusGenerator != nil {
		return serverlessUpstreamSettingsStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForServerlessUpstreamSettingsStatus(generators)
	serverlessUpstreamSettingsStatusGenerator = gen.Struct(reflect.TypeOf(ServerlessUpstreamSettings_Status{}), generators)

	return serverlessUpstreamSettingsStatusGenerator
}

// AddRelatedPropertyGeneratorsForServerlessUpstreamSettingsStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForServerlessUpstreamSettingsStatus(gens map[string]gopter.Gen) {
	gens["Templates"] = gen.SliceOf(UpstreamTemplateStatusGenerator())
}

func Test_SharedPrivateLinkResource_Status_SignalR_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SharedPrivateLinkResource_Status_SignalR_SubResourceEmbedded to SharedPrivateLinkResource_Status_SignalR_SubResourceEmbedded via AssignPropertiesToSharedPrivateLinkResourceStatusSignalRSubResourceEmbedded & AssignPropertiesFromSharedPrivateLinkResourceStatusSignalRSubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForSharedPrivateLinkResourceStatusSignalRSubResourceEmbedded, SharedPrivateLinkResourceStatusSignalRSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSharedPrivateLinkResourceStatusSignalRSubResourceEmbedded tests if a specific instance of SharedPrivateLinkResource_Status_SignalR_SubResourceEmbedded can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForSharedPrivateLinkResourceStatusSignalRSubResourceEmbedded(subject SharedPrivateLinkResource_Status_SignalR_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.SharedPrivateLinkResource_Status_SignalR_SubResourceEmbedded
	err := copied.AssignPropertiesToSharedPrivateLinkResourceStatusSignalRSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SharedPrivateLinkResource_Status_SignalR_SubResourceEmbedded
	err = actual.AssignPropertiesFromSharedPrivateLinkResourceStatusSignalRSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SharedPrivateLinkResource_Status_SignalR_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SharedPrivateLinkResource_Status_SignalR_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSharedPrivateLinkResourceStatusSignalRSubResourceEmbedded, SharedPrivateLinkResourceStatusSignalRSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSharedPrivateLinkResourceStatusSignalRSubResourceEmbedded runs a test to see if a specific instance of SharedPrivateLinkResource_Status_SignalR_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForSharedPrivateLinkResourceStatusSignalRSubResourceEmbedded(subject SharedPrivateLinkResource_Status_SignalR_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SharedPrivateLinkResource_Status_SignalR_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SharedPrivateLinkResource_Status_SignalR_SubResourceEmbedded instances for property testing - lazily
//instantiated by SharedPrivateLinkResourceStatusSignalRSubResourceEmbeddedGenerator()
var sharedPrivateLinkResourceStatusSignalRSubResourceEmbeddedGenerator gopter.Gen

// SharedPrivateLinkResourceStatusSignalRSubResourceEmbeddedGenerator returns a generator of SharedPrivateLinkResource_Status_SignalR_SubResourceEmbedded instances for property testing.
// We first initialize sharedPrivateLinkResourceStatusSignalRSubResourceEmbeddedGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SharedPrivateLinkResourceStatusSignalRSubResourceEmbeddedGenerator() gopter.Gen {
	if sharedPrivateLinkResourceStatusSignalRSubResourceEmbeddedGenerator != nil {
		return sharedPrivateLinkResourceStatusSignalRSubResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSharedPrivateLinkResourceStatusSignalRSubResourceEmbedded(generators)
	sharedPrivateLinkResourceStatusSignalRSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(SharedPrivateLinkResource_Status_SignalR_SubResourceEmbedded{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSharedPrivateLinkResourceStatusSignalRSubResourceEmbedded(generators)
	AddRelatedPropertyGeneratorsForSharedPrivateLinkResourceStatusSignalRSubResourceEmbedded(generators)
	sharedPrivateLinkResourceStatusSignalRSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(SharedPrivateLinkResource_Status_SignalR_SubResourceEmbedded{}), generators)

	return sharedPrivateLinkResourceStatusSignalRSubResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForSharedPrivateLinkResourceStatusSignalRSubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSharedPrivateLinkResourceStatusSignalRSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSharedPrivateLinkResourceStatusSignalRSubResourceEmbedded is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSharedPrivateLinkResourceStatusSignalRSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["SystemData"] = gen.PtrOf(SystemDataStatusGenerator())
}

func Test_SignalRCorsSettings_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SignalRCorsSettings_Spec to SignalRCorsSettings_Spec via AssignPropertiesToSignalRCorsSettingsSpec & AssignPropertiesFromSignalRCorsSettingsSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForSignalRCorsSettingsSpec, SignalRCorsSettingsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSignalRCorsSettingsSpec tests if a specific instance of SignalRCorsSettings_Spec can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForSignalRCorsSettingsSpec(subject SignalRCorsSettings_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.SignalRCorsSettings_Spec
	err := copied.AssignPropertiesToSignalRCorsSettingsSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SignalRCorsSettings_Spec
	err = actual.AssignPropertiesFromSignalRCorsSettingsSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SignalRCorsSettings_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRCorsSettings_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRCorsSettingsSpec, SignalRCorsSettingsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRCorsSettingsSpec runs a test to see if a specific instance of SignalRCorsSettings_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRCorsSettingsSpec(subject SignalRCorsSettings_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRCorsSettings_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRCorsSettings_Spec instances for property testing - lazily instantiated by
//SignalRCorsSettingsSpecGenerator()
var signalRCorsSettingsSpecGenerator gopter.Gen

// SignalRCorsSettingsSpecGenerator returns a generator of SignalRCorsSettings_Spec instances for property testing.
func SignalRCorsSettingsSpecGenerator() gopter.Gen {
	if signalRCorsSettingsSpecGenerator != nil {
		return signalRCorsSettingsSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRCorsSettingsSpec(generators)
	signalRCorsSettingsSpecGenerator = gen.Struct(reflect.TypeOf(SignalRCorsSettings_Spec{}), generators)

	return signalRCorsSettingsSpecGenerator
}

// AddIndependentPropertyGeneratorsForSignalRCorsSettingsSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRCorsSettingsSpec(gens map[string]gopter.Gen) {
	gens["AllowedOrigins"] = gen.SliceOf(gen.AlphaString())
}

func Test_SignalRCorsSettings_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SignalRCorsSettings_Status to SignalRCorsSettings_Status via AssignPropertiesToSignalRCorsSettingsStatus & AssignPropertiesFromSignalRCorsSettingsStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForSignalRCorsSettingsStatus, SignalRCorsSettingsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSignalRCorsSettingsStatus tests if a specific instance of SignalRCorsSettings_Status can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForSignalRCorsSettingsStatus(subject SignalRCorsSettings_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.SignalRCorsSettings_Status
	err := copied.AssignPropertiesToSignalRCorsSettingsStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SignalRCorsSettings_Status
	err = actual.AssignPropertiesFromSignalRCorsSettingsStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SignalRCorsSettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRCorsSettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRCorsSettingsStatus, SignalRCorsSettingsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRCorsSettingsStatus runs a test to see if a specific instance of SignalRCorsSettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRCorsSettingsStatus(subject SignalRCorsSettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRCorsSettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRCorsSettings_Status instances for property testing - lazily instantiated by
//SignalRCorsSettingsStatusGenerator()
var signalRCorsSettingsStatusGenerator gopter.Gen

// SignalRCorsSettingsStatusGenerator returns a generator of SignalRCorsSettings_Status instances for property testing.
func SignalRCorsSettingsStatusGenerator() gopter.Gen {
	if signalRCorsSettingsStatusGenerator != nil {
		return signalRCorsSettingsStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRCorsSettingsStatus(generators)
	signalRCorsSettingsStatusGenerator = gen.Struct(reflect.TypeOf(SignalRCorsSettings_Status{}), generators)

	return signalRCorsSettingsStatusGenerator
}

// AddIndependentPropertyGeneratorsForSignalRCorsSettingsStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRCorsSettingsStatus(gens map[string]gopter.Gen) {
	gens["AllowedOrigins"] = gen.SliceOf(gen.AlphaString())
}

func Test_SignalRFeature_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SignalRFeature_Spec to SignalRFeature_Spec via AssignPropertiesToSignalRFeatureSpec & AssignPropertiesFromSignalRFeatureSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForSignalRFeatureSpec, SignalRFeatureSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSignalRFeatureSpec tests if a specific instance of SignalRFeature_Spec can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForSignalRFeatureSpec(subject SignalRFeature_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.SignalRFeature_Spec
	err := copied.AssignPropertiesToSignalRFeatureSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SignalRFeature_Spec
	err = actual.AssignPropertiesFromSignalRFeatureSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SignalRFeature_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRFeature_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRFeatureSpec, SignalRFeatureSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRFeatureSpec runs a test to see if a specific instance of SignalRFeature_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRFeatureSpec(subject SignalRFeature_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRFeature_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRFeature_Spec instances for property testing - lazily instantiated by SignalRFeatureSpecGenerator()
var signalRFeatureSpecGenerator gopter.Gen

// SignalRFeatureSpecGenerator returns a generator of SignalRFeature_Spec instances for property testing.
func SignalRFeatureSpecGenerator() gopter.Gen {
	if signalRFeatureSpecGenerator != nil {
		return signalRFeatureSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRFeatureSpec(generators)
	signalRFeatureSpecGenerator = gen.Struct(reflect.TypeOf(SignalRFeature_Spec{}), generators)

	return signalRFeatureSpecGenerator
}

// AddIndependentPropertyGeneratorsForSignalRFeatureSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRFeatureSpec(gens map[string]gopter.Gen) {
	gens["Flag"] = gen.OneConstOf(
		FeatureFlags_SpecEnableConnectivityLogs,
		FeatureFlags_SpecEnableLiveTrace,
		FeatureFlags_SpecEnableMessagingLogs,
		FeatureFlags_SpecServiceMode)
	gens["Properties"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Value"] = gen.AlphaString()
}

func Test_SignalRFeature_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SignalRFeature_Status to SignalRFeature_Status via AssignPropertiesToSignalRFeatureStatus & AssignPropertiesFromSignalRFeatureStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForSignalRFeatureStatus, SignalRFeatureStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSignalRFeatureStatus tests if a specific instance of SignalRFeature_Status can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForSignalRFeatureStatus(subject SignalRFeature_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.SignalRFeature_Status
	err := copied.AssignPropertiesToSignalRFeatureStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SignalRFeature_Status
	err = actual.AssignPropertiesFromSignalRFeatureStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SignalRFeature_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRFeature_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRFeatureStatus, SignalRFeatureStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRFeatureStatus runs a test to see if a specific instance of SignalRFeature_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRFeatureStatus(subject SignalRFeature_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRFeature_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRFeature_Status instances for property testing - lazily instantiated by
//SignalRFeatureStatusGenerator()
var signalRFeatureStatusGenerator gopter.Gen

// SignalRFeatureStatusGenerator returns a generator of SignalRFeature_Status instances for property testing.
func SignalRFeatureStatusGenerator() gopter.Gen {
	if signalRFeatureStatusGenerator != nil {
		return signalRFeatureStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRFeatureStatus(generators)
	signalRFeatureStatusGenerator = gen.Struct(reflect.TypeOf(SignalRFeature_Status{}), generators)

	return signalRFeatureStatusGenerator
}

// AddIndependentPropertyGeneratorsForSignalRFeatureStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRFeatureStatus(gens map[string]gopter.Gen) {
	gens["Flag"] = gen.OneConstOf(
		FeatureFlags_StatusEnableConnectivityLogs,
		FeatureFlags_StatusEnableLiveTrace,
		FeatureFlags_StatusEnableMessagingLogs,
		FeatureFlags_StatusServiceMode)
	gens["Properties"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Value"] = gen.AlphaString()
}

func Test_SignalRNetworkACLs_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SignalRNetworkACLs_Spec to SignalRNetworkACLs_Spec via AssignPropertiesToSignalRNetworkACLsSpec & AssignPropertiesFromSignalRNetworkACLsSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForSignalRNetworkACLsSpec, SignalRNetworkACLsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSignalRNetworkACLsSpec tests if a specific instance of SignalRNetworkACLs_Spec can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForSignalRNetworkACLsSpec(subject SignalRNetworkACLs_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.SignalRNetworkACLs_Spec
	err := copied.AssignPropertiesToSignalRNetworkACLsSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SignalRNetworkACLs_Spec
	err = actual.AssignPropertiesFromSignalRNetworkACLsSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SignalRNetworkACLs_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRNetworkACLs_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRNetworkACLsSpec, SignalRNetworkACLsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRNetworkACLsSpec runs a test to see if a specific instance of SignalRNetworkACLs_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRNetworkACLsSpec(subject SignalRNetworkACLs_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRNetworkACLs_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRNetworkACLs_Spec instances for property testing - lazily instantiated by
//SignalRNetworkACLsSpecGenerator()
var signalRNetworkACLsSpecGenerator gopter.Gen

// SignalRNetworkACLsSpecGenerator returns a generator of SignalRNetworkACLs_Spec instances for property testing.
// We first initialize signalRNetworkACLsSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SignalRNetworkACLsSpecGenerator() gopter.Gen {
	if signalRNetworkACLsSpecGenerator != nil {
		return signalRNetworkACLsSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRNetworkACLsSpec(generators)
	signalRNetworkACLsSpecGenerator = gen.Struct(reflect.TypeOf(SignalRNetworkACLs_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRNetworkACLsSpec(generators)
	AddRelatedPropertyGeneratorsForSignalRNetworkACLsSpec(generators)
	signalRNetworkACLsSpecGenerator = gen.Struct(reflect.TypeOf(SignalRNetworkACLs_Spec{}), generators)

	return signalRNetworkACLsSpecGenerator
}

// AddIndependentPropertyGeneratorsForSignalRNetworkACLsSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRNetworkACLsSpec(gens map[string]gopter.Gen) {
	gens["DefaultAction"] = gen.PtrOf(gen.OneConstOf(ACLAction_SpecAllow, ACLAction_SpecDeny))
}

// AddRelatedPropertyGeneratorsForSignalRNetworkACLsSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSignalRNetworkACLsSpec(gens map[string]gopter.Gen) {
	gens["PrivateEndpoints"] = gen.SliceOf(PrivateEndpointACLSpecGenerator())
	gens["PublicNetwork"] = gen.PtrOf(NetworkACLSpecGenerator())
}

func Test_SignalRNetworkACLs_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SignalRNetworkACLs_Status to SignalRNetworkACLs_Status via AssignPropertiesToSignalRNetworkACLsStatus & AssignPropertiesFromSignalRNetworkACLsStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForSignalRNetworkACLsStatus, SignalRNetworkACLsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSignalRNetworkACLsStatus tests if a specific instance of SignalRNetworkACLs_Status can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForSignalRNetworkACLsStatus(subject SignalRNetworkACLs_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.SignalRNetworkACLs_Status
	err := copied.AssignPropertiesToSignalRNetworkACLsStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SignalRNetworkACLs_Status
	err = actual.AssignPropertiesFromSignalRNetworkACLsStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SignalRNetworkACLs_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRNetworkACLs_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRNetworkACLsStatus, SignalRNetworkACLsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRNetworkACLsStatus runs a test to see if a specific instance of SignalRNetworkACLs_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRNetworkACLsStatus(subject SignalRNetworkACLs_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRNetworkACLs_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRNetworkACLs_Status instances for property testing - lazily instantiated by
//SignalRNetworkACLsStatusGenerator()
var signalRNetworkACLsStatusGenerator gopter.Gen

// SignalRNetworkACLsStatusGenerator returns a generator of SignalRNetworkACLs_Status instances for property testing.
// We first initialize signalRNetworkACLsStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SignalRNetworkACLsStatusGenerator() gopter.Gen {
	if signalRNetworkACLsStatusGenerator != nil {
		return signalRNetworkACLsStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRNetworkACLsStatus(generators)
	signalRNetworkACLsStatusGenerator = gen.Struct(reflect.TypeOf(SignalRNetworkACLs_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRNetworkACLsStatus(generators)
	AddRelatedPropertyGeneratorsForSignalRNetworkACLsStatus(generators)
	signalRNetworkACLsStatusGenerator = gen.Struct(reflect.TypeOf(SignalRNetworkACLs_Status{}), generators)

	return signalRNetworkACLsStatusGenerator
}

// AddIndependentPropertyGeneratorsForSignalRNetworkACLsStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRNetworkACLsStatus(gens map[string]gopter.Gen) {
	gens["DefaultAction"] = gen.PtrOf(gen.OneConstOf(ACLAction_StatusAllow, ACLAction_StatusDeny))
}

// AddRelatedPropertyGeneratorsForSignalRNetworkACLsStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSignalRNetworkACLsStatus(gens map[string]gopter.Gen) {
	gens["PrivateEndpoints"] = gen.SliceOf(PrivateEndpointACLStatusGenerator())
	gens["PublicNetwork"] = gen.PtrOf(NetworkACLStatusGenerator())
}

func Test_SignalRTlsSettings_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SignalRTlsSettings_Spec to SignalRTlsSettings_Spec via AssignPropertiesToSignalRTlsSettingsSpec & AssignPropertiesFromSignalRTlsSettingsSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForSignalRTlsSettingsSpec, SignalRTlsSettingsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSignalRTlsSettingsSpec tests if a specific instance of SignalRTlsSettings_Spec can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForSignalRTlsSettingsSpec(subject SignalRTlsSettings_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.SignalRTlsSettings_Spec
	err := copied.AssignPropertiesToSignalRTlsSettingsSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SignalRTlsSettings_Spec
	err = actual.AssignPropertiesFromSignalRTlsSettingsSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SignalRTlsSettings_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRTlsSettings_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRTlsSettingsSpec, SignalRTlsSettingsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRTlsSettingsSpec runs a test to see if a specific instance of SignalRTlsSettings_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRTlsSettingsSpec(subject SignalRTlsSettings_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRTlsSettings_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRTlsSettings_Spec instances for property testing - lazily instantiated by
//SignalRTlsSettingsSpecGenerator()
var signalRTlsSettingsSpecGenerator gopter.Gen

// SignalRTlsSettingsSpecGenerator returns a generator of SignalRTlsSettings_Spec instances for property testing.
func SignalRTlsSettingsSpecGenerator() gopter.Gen {
	if signalRTlsSettingsSpecGenerator != nil {
		return signalRTlsSettingsSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRTlsSettingsSpec(generators)
	signalRTlsSettingsSpecGenerator = gen.Struct(reflect.TypeOf(SignalRTlsSettings_Spec{}), generators)

	return signalRTlsSettingsSpecGenerator
}

// AddIndependentPropertyGeneratorsForSignalRTlsSettingsSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRTlsSettingsSpec(gens map[string]gopter.Gen) {
	gens["ClientCertEnabled"] = gen.PtrOf(gen.Bool())
}

func Test_SignalRTlsSettings_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SignalRTlsSettings_Status to SignalRTlsSettings_Status via AssignPropertiesToSignalRTlsSettingsStatus & AssignPropertiesFromSignalRTlsSettingsStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForSignalRTlsSettingsStatus, SignalRTlsSettingsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSignalRTlsSettingsStatus tests if a specific instance of SignalRTlsSettings_Status can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForSignalRTlsSettingsStatus(subject SignalRTlsSettings_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.SignalRTlsSettings_Status
	err := copied.AssignPropertiesToSignalRTlsSettingsStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SignalRTlsSettings_Status
	err = actual.AssignPropertiesFromSignalRTlsSettingsStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SignalRTlsSettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRTlsSettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRTlsSettingsStatus, SignalRTlsSettingsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRTlsSettingsStatus runs a test to see if a specific instance of SignalRTlsSettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRTlsSettingsStatus(subject SignalRTlsSettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRTlsSettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRTlsSettings_Status instances for property testing - lazily instantiated by
//SignalRTlsSettingsStatusGenerator()
var signalRTlsSettingsStatusGenerator gopter.Gen

// SignalRTlsSettingsStatusGenerator returns a generator of SignalRTlsSettings_Status instances for property testing.
func SignalRTlsSettingsStatusGenerator() gopter.Gen {
	if signalRTlsSettingsStatusGenerator != nil {
		return signalRTlsSettingsStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRTlsSettingsStatus(generators)
	signalRTlsSettingsStatusGenerator = gen.Struct(reflect.TypeOf(SignalRTlsSettings_Status{}), generators)

	return signalRTlsSettingsStatusGenerator
}

// AddIndependentPropertyGeneratorsForSignalRTlsSettingsStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRTlsSettingsStatus(gens map[string]gopter.Gen) {
	gens["ClientCertEnabled"] = gen.PtrOf(gen.Bool())
}

func Test_SystemData_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SystemData_Status to SystemData_Status via AssignPropertiesToSystemDataStatus & AssignPropertiesFromSystemDataStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForSystemDataStatus, SystemDataStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSystemDataStatus tests if a specific instance of SystemData_Status can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForSystemDataStatus(subject SystemData_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.SystemData_Status
	err := copied.AssignPropertiesToSystemDataStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SystemData_Status
	err = actual.AssignPropertiesFromSystemDataStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SystemData_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SystemData_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSystemDataStatus, SystemDataStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSystemDataStatus runs a test to see if a specific instance of SystemData_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSystemDataStatus(subject SystemData_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SystemData_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SystemData_Status instances for property testing - lazily instantiated by SystemDataStatusGenerator()
var systemDataStatusGenerator gopter.Gen

// SystemDataStatusGenerator returns a generator of SystemData_Status instances for property testing.
func SystemDataStatusGenerator() gopter.Gen {
	if systemDataStatusGenerator != nil {
		return systemDataStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSystemDataStatus(generators)
	systemDataStatusGenerator = gen.Struct(reflect.TypeOf(SystemData_Status{}), generators)

	return systemDataStatusGenerator
}

// AddIndependentPropertyGeneratorsForSystemDataStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSystemDataStatus(gens map[string]gopter.Gen) {
	gens["CreatedAt"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedBy"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemDataStatusCreatedByTypeApplication,
		SystemDataStatusCreatedByTypeKey,
		SystemDataStatusCreatedByTypeManagedIdentity,
		SystemDataStatusCreatedByTypeUser))
	gens["LastModifiedAt"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedBy"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemDataStatusLastModifiedByTypeApplication,
		SystemDataStatusLastModifiedByTypeKey,
		SystemDataStatusLastModifiedByTypeManagedIdentity,
		SystemDataStatusLastModifiedByTypeUser))
}

func Test_NetworkACL_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NetworkACL_Spec to NetworkACL_Spec via AssignPropertiesToNetworkACLSpec & AssignPropertiesFromNetworkACLSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForNetworkACLSpec, NetworkACLSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNetworkACLSpec tests if a specific instance of NetworkACL_Spec can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForNetworkACLSpec(subject NetworkACL_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.NetworkACL_Spec
	err := copied.AssignPropertiesToNetworkACLSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NetworkACL_Spec
	err = actual.AssignPropertiesFromNetworkACLSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NetworkACL_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkACL_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkACLSpec, NetworkACLSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkACLSpec runs a test to see if a specific instance of NetworkACL_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkACLSpec(subject NetworkACL_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkACL_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkACL_Spec instances for property testing - lazily instantiated by NetworkACLSpecGenerator()
var networkACLSpecGenerator gopter.Gen

// NetworkACLSpecGenerator returns a generator of NetworkACL_Spec instances for property testing.
func NetworkACLSpecGenerator() gopter.Gen {
	if networkACLSpecGenerator != nil {
		return networkACLSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkACLSpec(generators)
	networkACLSpecGenerator = gen.Struct(reflect.TypeOf(NetworkACL_Spec{}), generators)

	return networkACLSpecGenerator
}

// AddIndependentPropertyGeneratorsForNetworkACLSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkACLSpec(gens map[string]gopter.Gen) {
	gens["Allow"] = gen.SliceOf(gen.OneConstOf(
		SignalRRequestType_SpecClientConnection,
		SignalRRequestType_SpecRESTAPI,
		SignalRRequestType_SpecServerConnection,
		SignalRRequestType_SpecTrace))
	gens["Deny"] = gen.SliceOf(gen.OneConstOf(
		SignalRRequestType_SpecClientConnection,
		SignalRRequestType_SpecRESTAPI,
		SignalRRequestType_SpecServerConnection,
		SignalRRequestType_SpecTrace))
}

func Test_NetworkACL_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NetworkACL_Status to NetworkACL_Status via AssignPropertiesToNetworkACLStatus & AssignPropertiesFromNetworkACLStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForNetworkACLStatus, NetworkACLStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNetworkACLStatus tests if a specific instance of NetworkACL_Status can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForNetworkACLStatus(subject NetworkACL_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.NetworkACL_Status
	err := copied.AssignPropertiesToNetworkACLStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NetworkACL_Status
	err = actual.AssignPropertiesFromNetworkACLStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NetworkACL_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkACL_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkACLStatus, NetworkACLStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkACLStatus runs a test to see if a specific instance of NetworkACL_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkACLStatus(subject NetworkACL_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkACL_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkACL_Status instances for property testing - lazily instantiated by NetworkACLStatusGenerator()
var networkACLStatusGenerator gopter.Gen

// NetworkACLStatusGenerator returns a generator of NetworkACL_Status instances for property testing.
func NetworkACLStatusGenerator() gopter.Gen {
	if networkACLStatusGenerator != nil {
		return networkACLStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkACLStatus(generators)
	networkACLStatusGenerator = gen.Struct(reflect.TypeOf(NetworkACL_Status{}), generators)

	return networkACLStatusGenerator
}

// AddIndependentPropertyGeneratorsForNetworkACLStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkACLStatus(gens map[string]gopter.Gen) {
	gens["Allow"] = gen.SliceOf(gen.OneConstOf(
		SignalRRequestType_StatusClientConnection,
		SignalRRequestType_StatusRESTAPI,
		SignalRRequestType_StatusServerConnection,
		SignalRRequestType_StatusTrace))
	gens["Deny"] = gen.SliceOf(gen.OneConstOf(
		SignalRRequestType_StatusClientConnection,
		SignalRRequestType_StatusRESTAPI,
		SignalRRequestType_StatusServerConnection,
		SignalRRequestType_StatusTrace))
}

func Test_PrivateEndpointACL_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PrivateEndpointACL_Spec to PrivateEndpointACL_Spec via AssignPropertiesToPrivateEndpointACLSpec & AssignPropertiesFromPrivateEndpointACLSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForPrivateEndpointACLSpec, PrivateEndpointACLSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPrivateEndpointACLSpec tests if a specific instance of PrivateEndpointACL_Spec can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForPrivateEndpointACLSpec(subject PrivateEndpointACL_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.PrivateEndpointACL_Spec
	err := copied.AssignPropertiesToPrivateEndpointACLSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PrivateEndpointACL_Spec
	err = actual.AssignPropertiesFromPrivateEndpointACLSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PrivateEndpointACL_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointACL_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointACLSpec, PrivateEndpointACLSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointACLSpec runs a test to see if a specific instance of PrivateEndpointACL_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointACLSpec(subject PrivateEndpointACL_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointACL_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointACL_Spec instances for property testing - lazily instantiated by
//PrivateEndpointACLSpecGenerator()
var privateEndpointACLSpecGenerator gopter.Gen

// PrivateEndpointACLSpecGenerator returns a generator of PrivateEndpointACL_Spec instances for property testing.
func PrivateEndpointACLSpecGenerator() gopter.Gen {
	if privateEndpointACLSpecGenerator != nil {
		return privateEndpointACLSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointACLSpec(generators)
	privateEndpointACLSpecGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointACL_Spec{}), generators)

	return privateEndpointACLSpecGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointACLSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointACLSpec(gens map[string]gopter.Gen) {
	gens["Allow"] = gen.SliceOf(gen.OneConstOf(
		SignalRRequestType_SpecClientConnection,
		SignalRRequestType_SpecRESTAPI,
		SignalRRequestType_SpecServerConnection,
		SignalRRequestType_SpecTrace))
	gens["Deny"] = gen.SliceOf(gen.OneConstOf(
		SignalRRequestType_SpecClientConnection,
		SignalRRequestType_SpecRESTAPI,
		SignalRRequestType_SpecServerConnection,
		SignalRRequestType_SpecTrace))
	gens["Name"] = gen.AlphaString()
}

func Test_PrivateEndpointACL_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PrivateEndpointACL_Status to PrivateEndpointACL_Status via AssignPropertiesToPrivateEndpointACLStatus & AssignPropertiesFromPrivateEndpointACLStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForPrivateEndpointACLStatus, PrivateEndpointACLStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPrivateEndpointACLStatus tests if a specific instance of PrivateEndpointACL_Status can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForPrivateEndpointACLStatus(subject PrivateEndpointACL_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.PrivateEndpointACL_Status
	err := copied.AssignPropertiesToPrivateEndpointACLStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PrivateEndpointACL_Status
	err = actual.AssignPropertiesFromPrivateEndpointACLStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PrivateEndpointACL_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointACL_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointACLStatus, PrivateEndpointACLStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointACLStatus runs a test to see if a specific instance of PrivateEndpointACL_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointACLStatus(subject PrivateEndpointACL_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointACL_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointACL_Status instances for property testing - lazily instantiated by
//PrivateEndpointACLStatusGenerator()
var privateEndpointACLStatusGenerator gopter.Gen

// PrivateEndpointACLStatusGenerator returns a generator of PrivateEndpointACL_Status instances for property testing.
func PrivateEndpointACLStatusGenerator() gopter.Gen {
	if privateEndpointACLStatusGenerator != nil {
		return privateEndpointACLStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointACLStatus(generators)
	privateEndpointACLStatusGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointACL_Status{}), generators)

	return privateEndpointACLStatusGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointACLStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointACLStatus(gens map[string]gopter.Gen) {
	gens["Allow"] = gen.SliceOf(gen.OneConstOf(
		SignalRRequestType_StatusClientConnection,
		SignalRRequestType_StatusRESTAPI,
		SignalRRequestType_StatusServerConnection,
		SignalRRequestType_StatusTrace))
	gens["Deny"] = gen.SliceOf(gen.OneConstOf(
		SignalRRequestType_StatusClientConnection,
		SignalRRequestType_StatusRESTAPI,
		SignalRRequestType_StatusServerConnection,
		SignalRRequestType_StatusTrace))
	gens["Name"] = gen.AlphaString()
}

func Test_ResourceLogCategory_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResourceLogCategory_Spec to ResourceLogCategory_Spec via AssignPropertiesToResourceLogCategorySpec & AssignPropertiesFromResourceLogCategorySpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForResourceLogCategorySpec, ResourceLogCategorySpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResourceLogCategorySpec tests if a specific instance of ResourceLogCategory_Spec can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForResourceLogCategorySpec(subject ResourceLogCategory_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.ResourceLogCategory_Spec
	err := copied.AssignPropertiesToResourceLogCategorySpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResourceLogCategory_Spec
	err = actual.AssignPropertiesFromResourceLogCategorySpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResourceLogCategory_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceLogCategory_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceLogCategorySpec, ResourceLogCategorySpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceLogCategorySpec runs a test to see if a specific instance of ResourceLogCategory_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceLogCategorySpec(subject ResourceLogCategory_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceLogCategory_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceLogCategory_Spec instances for property testing - lazily instantiated by
//ResourceLogCategorySpecGenerator()
var resourceLogCategorySpecGenerator gopter.Gen

// ResourceLogCategorySpecGenerator returns a generator of ResourceLogCategory_Spec instances for property testing.
func ResourceLogCategorySpecGenerator() gopter.Gen {
	if resourceLogCategorySpecGenerator != nil {
		return resourceLogCategorySpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceLogCategorySpec(generators)
	resourceLogCategorySpecGenerator = gen.Struct(reflect.TypeOf(ResourceLogCategory_Spec{}), generators)

	return resourceLogCategorySpecGenerator
}

// AddIndependentPropertyGeneratorsForResourceLogCategorySpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceLogCategorySpec(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_ResourceLogCategory_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResourceLogCategory_Status to ResourceLogCategory_Status via AssignPropertiesToResourceLogCategoryStatus & AssignPropertiesFromResourceLogCategoryStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForResourceLogCategoryStatus, ResourceLogCategoryStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResourceLogCategoryStatus tests if a specific instance of ResourceLogCategory_Status can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForResourceLogCategoryStatus(subject ResourceLogCategory_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.ResourceLogCategory_Status
	err := copied.AssignPropertiesToResourceLogCategoryStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResourceLogCategory_Status
	err = actual.AssignPropertiesFromResourceLogCategoryStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResourceLogCategory_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceLogCategory_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceLogCategoryStatus, ResourceLogCategoryStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceLogCategoryStatus runs a test to see if a specific instance of ResourceLogCategory_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceLogCategoryStatus(subject ResourceLogCategory_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceLogCategory_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceLogCategory_Status instances for property testing - lazily instantiated by
//ResourceLogCategoryStatusGenerator()
var resourceLogCategoryStatusGenerator gopter.Gen

// ResourceLogCategoryStatusGenerator returns a generator of ResourceLogCategory_Status instances for property testing.
func ResourceLogCategoryStatusGenerator() gopter.Gen {
	if resourceLogCategoryStatusGenerator != nil {
		return resourceLogCategoryStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceLogCategoryStatus(generators)
	resourceLogCategoryStatusGenerator = gen.Struct(reflect.TypeOf(ResourceLogCategory_Status{}), generators)

	return resourceLogCategoryStatusGenerator
}

// AddIndependentPropertyGeneratorsForResourceLogCategoryStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceLogCategoryStatus(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_UpstreamTemplate_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UpstreamTemplate_Spec to UpstreamTemplate_Spec via AssignPropertiesToUpstreamTemplateSpec & AssignPropertiesFromUpstreamTemplateSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForUpstreamTemplateSpec, UpstreamTemplateSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUpstreamTemplateSpec tests if a specific instance of UpstreamTemplate_Spec can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForUpstreamTemplateSpec(subject UpstreamTemplate_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.UpstreamTemplate_Spec
	err := copied.AssignPropertiesToUpstreamTemplateSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UpstreamTemplate_Spec
	err = actual.AssignPropertiesFromUpstreamTemplateSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UpstreamTemplate_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UpstreamTemplate_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUpstreamTemplateSpec, UpstreamTemplateSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUpstreamTemplateSpec runs a test to see if a specific instance of UpstreamTemplate_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForUpstreamTemplateSpec(subject UpstreamTemplate_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UpstreamTemplate_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UpstreamTemplate_Spec instances for property testing - lazily instantiated by
//UpstreamTemplateSpecGenerator()
var upstreamTemplateSpecGenerator gopter.Gen

// UpstreamTemplateSpecGenerator returns a generator of UpstreamTemplate_Spec instances for property testing.
// We first initialize upstreamTemplateSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UpstreamTemplateSpecGenerator() gopter.Gen {
	if upstreamTemplateSpecGenerator != nil {
		return upstreamTemplateSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpstreamTemplateSpec(generators)
	upstreamTemplateSpecGenerator = gen.Struct(reflect.TypeOf(UpstreamTemplate_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpstreamTemplateSpec(generators)
	AddRelatedPropertyGeneratorsForUpstreamTemplateSpec(generators)
	upstreamTemplateSpecGenerator = gen.Struct(reflect.TypeOf(UpstreamTemplate_Spec{}), generators)

	return upstreamTemplateSpecGenerator
}

// AddIndependentPropertyGeneratorsForUpstreamTemplateSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUpstreamTemplateSpec(gens map[string]gopter.Gen) {
	gens["CategoryPattern"] = gen.PtrOf(gen.AlphaString())
	gens["EventPattern"] = gen.PtrOf(gen.AlphaString())
	gens["HubPattern"] = gen.PtrOf(gen.AlphaString())
	gens["UrlTemplate"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForUpstreamTemplateSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUpstreamTemplateSpec(gens map[string]gopter.Gen) {
	gens["Auth"] = gen.PtrOf(UpstreamAuthSettingsSpecGenerator())
}

func Test_UpstreamTemplate_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UpstreamTemplate_Status to UpstreamTemplate_Status via AssignPropertiesToUpstreamTemplateStatus & AssignPropertiesFromUpstreamTemplateStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForUpstreamTemplateStatus, UpstreamTemplateStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUpstreamTemplateStatus tests if a specific instance of UpstreamTemplate_Status can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForUpstreamTemplateStatus(subject UpstreamTemplate_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.UpstreamTemplate_Status
	err := copied.AssignPropertiesToUpstreamTemplateStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UpstreamTemplate_Status
	err = actual.AssignPropertiesFromUpstreamTemplateStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UpstreamTemplate_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UpstreamTemplate_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUpstreamTemplateStatus, UpstreamTemplateStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUpstreamTemplateStatus runs a test to see if a specific instance of UpstreamTemplate_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForUpstreamTemplateStatus(subject UpstreamTemplate_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UpstreamTemplate_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UpstreamTemplate_Status instances for property testing - lazily instantiated by
//UpstreamTemplateStatusGenerator()
var upstreamTemplateStatusGenerator gopter.Gen

// UpstreamTemplateStatusGenerator returns a generator of UpstreamTemplate_Status instances for property testing.
// We first initialize upstreamTemplateStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UpstreamTemplateStatusGenerator() gopter.Gen {
	if upstreamTemplateStatusGenerator != nil {
		return upstreamTemplateStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpstreamTemplateStatus(generators)
	upstreamTemplateStatusGenerator = gen.Struct(reflect.TypeOf(UpstreamTemplate_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpstreamTemplateStatus(generators)
	AddRelatedPropertyGeneratorsForUpstreamTemplateStatus(generators)
	upstreamTemplateStatusGenerator = gen.Struct(reflect.TypeOf(UpstreamTemplate_Status{}), generators)

	return upstreamTemplateStatusGenerator
}

// AddIndependentPropertyGeneratorsForUpstreamTemplateStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUpstreamTemplateStatus(gens map[string]gopter.Gen) {
	gens["CategoryPattern"] = gen.PtrOf(gen.AlphaString())
	gens["EventPattern"] = gen.PtrOf(gen.AlphaString())
	gens["HubPattern"] = gen.PtrOf(gen.AlphaString())
	gens["UrlTemplate"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForUpstreamTemplateStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUpstreamTemplateStatus(gens map[string]gopter.Gen) {
	gens["Auth"] = gen.PtrOf(UpstreamAuthSettingsStatusGenerator())
}

func Test_UserAssignedIdentityProperty_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UserAssignedIdentityProperty_Status to UserAssignedIdentityProperty_Status via AssignPropertiesToUserAssignedIdentityPropertyStatus & AssignPropertiesFromUserAssignedIdentityPropertyStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForUserAssignedIdentityPropertyStatus, UserAssignedIdentityPropertyStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUserAssignedIdentityPropertyStatus tests if a specific instance of UserAssignedIdentityProperty_Status can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForUserAssignedIdentityPropertyStatus(subject UserAssignedIdentityProperty_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.UserAssignedIdentityProperty_Status
	err := copied.AssignPropertiesToUserAssignedIdentityPropertyStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UserAssignedIdentityProperty_Status
	err = actual.AssignPropertiesFromUserAssignedIdentityPropertyStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UserAssignedIdentityProperty_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentityProperty_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentityPropertyStatus, UserAssignedIdentityPropertyStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentityPropertyStatus runs a test to see if a specific instance of UserAssignedIdentityProperty_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentityPropertyStatus(subject UserAssignedIdentityProperty_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentityProperty_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentityProperty_Status instances for property testing - lazily instantiated by
//UserAssignedIdentityPropertyStatusGenerator()
var userAssignedIdentityPropertyStatusGenerator gopter.Gen

// UserAssignedIdentityPropertyStatusGenerator returns a generator of UserAssignedIdentityProperty_Status instances for property testing.
func UserAssignedIdentityPropertyStatusGenerator() gopter.Gen {
	if userAssignedIdentityPropertyStatusGenerator != nil {
		return userAssignedIdentityPropertyStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserAssignedIdentityPropertyStatus(generators)
	userAssignedIdentityPropertyStatusGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentityProperty_Status{}), generators)

	return userAssignedIdentityPropertyStatusGenerator
}

// AddIndependentPropertyGeneratorsForUserAssignedIdentityPropertyStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserAssignedIdentityPropertyStatus(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_UpstreamAuthSettings_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UpstreamAuthSettings_Spec to UpstreamAuthSettings_Spec via AssignPropertiesToUpstreamAuthSettingsSpec & AssignPropertiesFromUpstreamAuthSettingsSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForUpstreamAuthSettingsSpec, UpstreamAuthSettingsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUpstreamAuthSettingsSpec tests if a specific instance of UpstreamAuthSettings_Spec can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForUpstreamAuthSettingsSpec(subject UpstreamAuthSettings_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.UpstreamAuthSettings_Spec
	err := copied.AssignPropertiesToUpstreamAuthSettingsSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UpstreamAuthSettings_Spec
	err = actual.AssignPropertiesFromUpstreamAuthSettingsSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UpstreamAuthSettings_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UpstreamAuthSettings_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUpstreamAuthSettingsSpec, UpstreamAuthSettingsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUpstreamAuthSettingsSpec runs a test to see if a specific instance of UpstreamAuthSettings_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForUpstreamAuthSettingsSpec(subject UpstreamAuthSettings_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UpstreamAuthSettings_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UpstreamAuthSettings_Spec instances for property testing - lazily instantiated by
//UpstreamAuthSettingsSpecGenerator()
var upstreamAuthSettingsSpecGenerator gopter.Gen

// UpstreamAuthSettingsSpecGenerator returns a generator of UpstreamAuthSettings_Spec instances for property testing.
// We first initialize upstreamAuthSettingsSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UpstreamAuthSettingsSpecGenerator() gopter.Gen {
	if upstreamAuthSettingsSpecGenerator != nil {
		return upstreamAuthSettingsSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpstreamAuthSettingsSpec(generators)
	upstreamAuthSettingsSpecGenerator = gen.Struct(reflect.TypeOf(UpstreamAuthSettings_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpstreamAuthSettingsSpec(generators)
	AddRelatedPropertyGeneratorsForUpstreamAuthSettingsSpec(generators)
	upstreamAuthSettingsSpecGenerator = gen.Struct(reflect.TypeOf(UpstreamAuthSettings_Spec{}), generators)

	return upstreamAuthSettingsSpecGenerator
}

// AddIndependentPropertyGeneratorsForUpstreamAuthSettingsSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUpstreamAuthSettingsSpec(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(UpstreamAuthType_SpecManagedIdentity, UpstreamAuthType_SpecNone))
}

// AddRelatedPropertyGeneratorsForUpstreamAuthSettingsSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUpstreamAuthSettingsSpec(gens map[string]gopter.Gen) {
	gens["ManagedIdentity"] = gen.PtrOf(ManagedIdentitySettingsSpecGenerator())
}

func Test_UpstreamAuthSettings_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UpstreamAuthSettings_Status to UpstreamAuthSettings_Status via AssignPropertiesToUpstreamAuthSettingsStatus & AssignPropertiesFromUpstreamAuthSettingsStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForUpstreamAuthSettingsStatus, UpstreamAuthSettingsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUpstreamAuthSettingsStatus tests if a specific instance of UpstreamAuthSettings_Status can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForUpstreamAuthSettingsStatus(subject UpstreamAuthSettings_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.UpstreamAuthSettings_Status
	err := copied.AssignPropertiesToUpstreamAuthSettingsStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UpstreamAuthSettings_Status
	err = actual.AssignPropertiesFromUpstreamAuthSettingsStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UpstreamAuthSettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UpstreamAuthSettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUpstreamAuthSettingsStatus, UpstreamAuthSettingsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUpstreamAuthSettingsStatus runs a test to see if a specific instance of UpstreamAuthSettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForUpstreamAuthSettingsStatus(subject UpstreamAuthSettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UpstreamAuthSettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UpstreamAuthSettings_Status instances for property testing - lazily instantiated by
//UpstreamAuthSettingsStatusGenerator()
var upstreamAuthSettingsStatusGenerator gopter.Gen

// UpstreamAuthSettingsStatusGenerator returns a generator of UpstreamAuthSettings_Status instances for property testing.
// We first initialize upstreamAuthSettingsStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UpstreamAuthSettingsStatusGenerator() gopter.Gen {
	if upstreamAuthSettingsStatusGenerator != nil {
		return upstreamAuthSettingsStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpstreamAuthSettingsStatus(generators)
	upstreamAuthSettingsStatusGenerator = gen.Struct(reflect.TypeOf(UpstreamAuthSettings_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpstreamAuthSettingsStatus(generators)
	AddRelatedPropertyGeneratorsForUpstreamAuthSettingsStatus(generators)
	upstreamAuthSettingsStatusGenerator = gen.Struct(reflect.TypeOf(UpstreamAuthSettings_Status{}), generators)

	return upstreamAuthSettingsStatusGenerator
}

// AddIndependentPropertyGeneratorsForUpstreamAuthSettingsStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUpstreamAuthSettingsStatus(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(UpstreamAuthType_StatusManagedIdentity, UpstreamAuthType_StatusNone))
}

// AddRelatedPropertyGeneratorsForUpstreamAuthSettingsStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUpstreamAuthSettingsStatus(gens map[string]gopter.Gen) {
	gens["ManagedIdentity"] = gen.PtrOf(ManagedIdentitySettingsStatusGenerator())
}

func Test_ManagedIdentitySettings_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedIdentitySettings_Spec to ManagedIdentitySettings_Spec via AssignPropertiesToManagedIdentitySettingsSpec & AssignPropertiesFromManagedIdentitySettingsSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedIdentitySettingsSpec, ManagedIdentitySettingsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedIdentitySettingsSpec tests if a specific instance of ManagedIdentitySettings_Spec can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForManagedIdentitySettingsSpec(subject ManagedIdentitySettings_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.ManagedIdentitySettings_Spec
	err := copied.AssignPropertiesToManagedIdentitySettingsSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedIdentitySettings_Spec
	err = actual.AssignPropertiesFromManagedIdentitySettingsSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedIdentitySettings_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedIdentitySettings_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedIdentitySettingsSpec, ManagedIdentitySettingsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedIdentitySettingsSpec runs a test to see if a specific instance of ManagedIdentitySettings_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedIdentitySettingsSpec(subject ManagedIdentitySettings_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedIdentitySettings_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedIdentitySettings_Spec instances for property testing - lazily instantiated by
//ManagedIdentitySettingsSpecGenerator()
var managedIdentitySettingsSpecGenerator gopter.Gen

// ManagedIdentitySettingsSpecGenerator returns a generator of ManagedIdentitySettings_Spec instances for property testing.
func ManagedIdentitySettingsSpecGenerator() gopter.Gen {
	if managedIdentitySettingsSpecGenerator != nil {
		return managedIdentitySettingsSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedIdentitySettingsSpec(generators)
	managedIdentitySettingsSpecGenerator = gen.Struct(reflect.TypeOf(ManagedIdentitySettings_Spec{}), generators)

	return managedIdentitySettingsSpecGenerator
}

// AddIndependentPropertyGeneratorsForManagedIdentitySettingsSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedIdentitySettingsSpec(gens map[string]gopter.Gen) {
	gens["Resource"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedIdentitySettings_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedIdentitySettings_Status to ManagedIdentitySettings_Status via AssignPropertiesToManagedIdentitySettingsStatus & AssignPropertiesFromManagedIdentitySettingsStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedIdentitySettingsStatus, ManagedIdentitySettingsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedIdentitySettingsStatus tests if a specific instance of ManagedIdentitySettings_Status can be assigned to v1alpha1api20211001storage and back losslessly
func RunPropertyAssignmentTestForManagedIdentitySettingsStatus(subject ManagedIdentitySettings_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20211001storage.ManagedIdentitySettings_Status
	err := copied.AssignPropertiesToManagedIdentitySettingsStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedIdentitySettings_Status
	err = actual.AssignPropertiesFromManagedIdentitySettingsStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedIdentitySettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedIdentitySettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedIdentitySettingsStatus, ManagedIdentitySettingsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedIdentitySettingsStatus runs a test to see if a specific instance of ManagedIdentitySettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedIdentitySettingsStatus(subject ManagedIdentitySettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedIdentitySettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedIdentitySettings_Status instances for property testing - lazily instantiated by
//ManagedIdentitySettingsStatusGenerator()
var managedIdentitySettingsStatusGenerator gopter.Gen

// ManagedIdentitySettingsStatusGenerator returns a generator of ManagedIdentitySettings_Status instances for property testing.
func ManagedIdentitySettingsStatusGenerator() gopter.Gen {
	if managedIdentitySettingsStatusGenerator != nil {
		return managedIdentitySettingsStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedIdentitySettingsStatus(generators)
	managedIdentitySettingsStatusGenerator = gen.Struct(reflect.TypeOf(ManagedIdentitySettings_Status{}), generators)

	return managedIdentitySettingsStatusGenerator
}

// AddIndependentPropertyGeneratorsForManagedIdentitySettingsStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedIdentitySettingsStatus(gens map[string]gopter.Gen) {
	gens["Resource"] = gen.PtrOf(gen.AlphaString())
}
