// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20211001

import (
	"encoding/json"
	v20211001s "github.com/Azure/azure-service-operator/v2/api/signalrservice/v1beta20211001storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_SignalR_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	parameters.MinSuccessfulTests = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SignalR to hub returns original",
		prop.ForAll(RunResourceConversionTestForSignalR, SignalRGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForSignalR tests if a specific instance of SignalR round trips to the hub storage version and back losslessly
func RunResourceConversionTestForSignalR(subject SignalR) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v20211001s.SignalR
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual SignalR
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SignalR_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SignalR to SignalR via AssignPropertiesToSignalR & AssignPropertiesFromSignalR returns original",
		prop.ForAll(RunPropertyAssignmentTestForSignalR, SignalRGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSignalR tests if a specific instance of SignalR can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForSignalR(subject SignalR) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.SignalR
	err := copied.AssignPropertiesToSignalR(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SignalR
	err = actual.AssignPropertiesFromSignalR(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SignalR_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalR via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalR, SignalRGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalR runs a test to see if a specific instance of SignalR round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalR(subject SignalR) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalR
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalR instances for property testing - lazily instantiated by SignalRGenerator()
var signalRGenerator gopter.Gen

// SignalRGenerator returns a generator of SignalR instances for property testing.
func SignalRGenerator() gopter.Gen {
	if signalRGenerator != nil {
		return signalRGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForSignalR(generators)
	signalRGenerator = gen.Struct(reflect.TypeOf(SignalR{}), generators)

	return signalRGenerator
}

// AddRelatedPropertyGeneratorsForSignalR is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSignalR(gens map[string]gopter.Gen) {
	gens["Spec"] = SignalRSpecGenerator()
	gens["Status"] = SignalRResourceSTATUSGenerator()
}

func Test_SignalR_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SignalR_Spec to SignalR_Spec via AssignPropertiesToSignalRSpec & AssignPropertiesFromSignalRSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForSignalRSpec, SignalRSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSignalRSpec tests if a specific instance of SignalR_Spec can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForSignalRSpec(subject SignalR_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.SignalR_Spec
	err := copied.AssignPropertiesToSignalRSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SignalR_Spec
	err = actual.AssignPropertiesFromSignalRSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SignalR_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalR_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRSpec, SignalRSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRSpec runs a test to see if a specific instance of SignalR_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRSpec(subject SignalR_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalR_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalR_Spec instances for property testing - lazily instantiated by SignalRSpecGenerator()
var signalRSpecGenerator gopter.Gen

// SignalRSpecGenerator returns a generator of SignalR_Spec instances for property testing.
// We first initialize signalRSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SignalRSpecGenerator() gopter.Gen {
	if signalRSpecGenerator != nil {
		return signalRSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRSpec(generators)
	signalRSpecGenerator = gen.Struct(reflect.TypeOf(SignalR_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRSpec(generators)
	AddRelatedPropertyGeneratorsForSignalRSpec(generators)
	signalRSpecGenerator = gen.Struct(reflect.TypeOf(SignalR_Spec{}), generators)

	return signalRSpecGenerator
}

// AddIndependentPropertyGeneratorsForSignalRSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRSpec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["DisableAadAuth"] = gen.PtrOf(gen.Bool())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(SignalRSpecKind_RawWebSockets, SignalRSpecKind_SignalR))
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSignalRSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSignalRSpec(gens map[string]gopter.Gen) {
	gens["Cors"] = gen.PtrOf(SignalRCorsSettingsGenerator())
	gens["Features"] = gen.SliceOf(SignalRFeatureGenerator())
	gens["Identity"] = gen.PtrOf(ManagedIdentityGenerator())
	gens["NetworkACLs"] = gen.PtrOf(SignalRNetworkACLsGenerator())
	gens["ResourceLogConfiguration"] = gen.PtrOf(ResourceLogConfigurationGenerator())
	gens["Sku"] = gen.PtrOf(ResourceSkuGenerator())
	gens["Tls"] = gen.PtrOf(SignalRTlsSettingsGenerator())
	gens["Upstream"] = gen.PtrOf(ServerlessUpstreamSettingsGenerator())
}

func Test_SignalRResource_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SignalRResource_STATUS to SignalRResource_STATUS via AssignPropertiesToSignalRResourceSTATUS & AssignPropertiesFromSignalRResourceSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSignalRResourceSTATUS, SignalRResourceSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSignalRResourceSTATUS tests if a specific instance of SignalRResource_STATUS can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForSignalRResourceSTATUS(subject SignalRResource_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.SignalRResource_STATUS
	err := copied.AssignPropertiesToSignalRResourceSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SignalRResource_STATUS
	err = actual.AssignPropertiesFromSignalRResourceSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SignalRResource_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRResource_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRResourceSTATUS, SignalRResourceSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRResourceSTATUS runs a test to see if a specific instance of SignalRResource_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRResourceSTATUS(subject SignalRResource_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRResource_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRResource_STATUS instances for property testing - lazily instantiated by
// SignalRResourceSTATUSGenerator()
var signalRResourceSTATUSGenerator gopter.Gen

// SignalRResourceSTATUSGenerator returns a generator of SignalRResource_STATUS instances for property testing.
// We first initialize signalRResourceSTATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SignalRResourceSTATUSGenerator() gopter.Gen {
	if signalRResourceSTATUSGenerator != nil {
		return signalRResourceSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRResourceSTATUS(generators)
	signalRResourceSTATUSGenerator = gen.Struct(reflect.TypeOf(SignalRResource_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRResourceSTATUS(generators)
	AddRelatedPropertyGeneratorsForSignalRResourceSTATUS(generators)
	signalRResourceSTATUSGenerator = gen.Struct(reflect.TypeOf(SignalRResource_STATUS{}), generators)

	return signalRResourceSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForSignalRResourceSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRResourceSTATUS(gens map[string]gopter.Gen) {
	gens["DisableAadAuth"] = gen.PtrOf(gen.Bool())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["ExternalIP"] = gen.PtrOf(gen.AlphaString())
	gens["HostName"] = gen.PtrOf(gen.AlphaString())
	gens["HostNamePrefix"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(ServiceKind_STATUS_RawWebSockets, ServiceKind_STATUS_SignalR))
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_STATUS_Canceled,
		ProvisioningState_STATUS_Creating,
		ProvisioningState_STATUS_Deleting,
		ProvisioningState_STATUS_Failed,
		ProvisioningState_STATUS_Moving,
		ProvisioningState_STATUS_Running,
		ProvisioningState_STATUS_Succeeded,
		ProvisioningState_STATUS_Unknown,
		ProvisioningState_STATUS_Updating))
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.AlphaString())
	gens["PublicPort"] = gen.PtrOf(gen.Int())
	gens["ServerPort"] = gen.PtrOf(gen.Int())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["Version"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSignalRResourceSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSignalRResourceSTATUS(gens map[string]gopter.Gen) {
	gens["Cors"] = gen.PtrOf(SignalRCorsSettingsSTATUSGenerator())
	gens["Features"] = gen.SliceOf(SignalRFeatureSTATUSGenerator())
	gens["Identity"] = gen.PtrOf(ManagedIdentitySTATUSGenerator())
	gens["NetworkACLs"] = gen.PtrOf(SignalRNetworkACLsSTATUSGenerator())
	gens["PrivateEndpointConnections"] = gen.SliceOf(PrivateEndpointConnectionSTATUSSignalRSubResourceEmbeddedGenerator())
	gens["ResourceLogConfiguration"] = gen.PtrOf(ResourceLogConfigurationSTATUSGenerator())
	gens["SharedPrivateLinkResources"] = gen.SliceOf(SharedPrivateLinkResourceSTATUSSignalRSubResourceEmbeddedGenerator())
	gens["Sku"] = gen.PtrOf(ResourceSkuSTATUSGenerator())
	gens["SystemData"] = gen.PtrOf(SystemDataSTATUSGenerator())
	gens["Tls"] = gen.PtrOf(SignalRTlsSettingsSTATUSGenerator())
	gens["Upstream"] = gen.PtrOf(ServerlessUpstreamSettingsSTATUSGenerator())
}

func Test_ManagedIdentity_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedIdentity to ManagedIdentity via AssignPropertiesToManagedIdentity & AssignPropertiesFromManagedIdentity returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedIdentity, ManagedIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedIdentity tests if a specific instance of ManagedIdentity can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForManagedIdentity(subject ManagedIdentity) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ManagedIdentity
	err := copied.AssignPropertiesToManagedIdentity(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedIdentity
	err = actual.AssignPropertiesFromManagedIdentity(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedIdentity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedIdentity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedIdentity, ManagedIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedIdentity runs a test to see if a specific instance of ManagedIdentity round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedIdentity(subject ManagedIdentity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedIdentity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedIdentity instances for property testing - lazily instantiated by ManagedIdentityGenerator()
var managedIdentityGenerator gopter.Gen

// ManagedIdentityGenerator returns a generator of ManagedIdentity instances for property testing.
func ManagedIdentityGenerator() gopter.Gen {
	if managedIdentityGenerator != nil {
		return managedIdentityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedIdentity(generators)
	managedIdentityGenerator = gen.Struct(reflect.TypeOf(ManagedIdentity{}), generators)

	return managedIdentityGenerator
}

// AddIndependentPropertyGeneratorsForManagedIdentity is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedIdentity(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ManagedIdentityType_None, ManagedIdentityType_SystemAssigned, ManagedIdentityType_UserAssigned))
}

func Test_ManagedIdentity_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedIdentity_STATUS to ManagedIdentity_STATUS via AssignPropertiesToManagedIdentitySTATUS & AssignPropertiesFromManagedIdentitySTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedIdentitySTATUS, ManagedIdentitySTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedIdentitySTATUS tests if a specific instance of ManagedIdentity_STATUS can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForManagedIdentitySTATUS(subject ManagedIdentity_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ManagedIdentity_STATUS
	err := copied.AssignPropertiesToManagedIdentitySTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedIdentity_STATUS
	err = actual.AssignPropertiesFromManagedIdentitySTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedIdentity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedIdentity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedIdentitySTATUS, ManagedIdentitySTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedIdentitySTATUS runs a test to see if a specific instance of ManagedIdentity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedIdentitySTATUS(subject ManagedIdentity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedIdentity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedIdentity_STATUS instances for property testing - lazily instantiated by
// ManagedIdentitySTATUSGenerator()
var managedIdentitySTATUSGenerator gopter.Gen

// ManagedIdentitySTATUSGenerator returns a generator of ManagedIdentity_STATUS instances for property testing.
// We first initialize managedIdentitySTATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedIdentitySTATUSGenerator() gopter.Gen {
	if managedIdentitySTATUSGenerator != nil {
		return managedIdentitySTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedIdentitySTATUS(generators)
	managedIdentitySTATUSGenerator = gen.Struct(reflect.TypeOf(ManagedIdentity_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedIdentitySTATUS(generators)
	AddRelatedPropertyGeneratorsForManagedIdentitySTATUS(generators)
	managedIdentitySTATUSGenerator = gen.Struct(reflect.TypeOf(ManagedIdentity_STATUS{}), generators)

	return managedIdentitySTATUSGenerator
}

// AddIndependentPropertyGeneratorsForManagedIdentitySTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedIdentitySTATUS(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ManagedIdentityType_STATUS_None, ManagedIdentityType_STATUS_SystemAssigned, ManagedIdentityType_STATUS_UserAssigned))
}

// AddRelatedPropertyGeneratorsForManagedIdentitySTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedIdentitySTATUS(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), UserAssignedIdentityPropertySTATUSGenerator())
}

func Test_PrivateEndpointConnection_STATUS_SignalR_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PrivateEndpointConnection_STATUS_SignalR_SubResourceEmbedded to PrivateEndpointConnection_STATUS_SignalR_SubResourceEmbedded via AssignPropertiesToPrivateEndpointConnectionSTATUSSignalRSubResourceEmbedded & AssignPropertiesFromPrivateEndpointConnectionSTATUSSignalRSubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForPrivateEndpointConnectionSTATUSSignalRSubResourceEmbedded, PrivateEndpointConnectionSTATUSSignalRSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPrivateEndpointConnectionSTATUSSignalRSubResourceEmbedded tests if a specific instance of PrivateEndpointConnection_STATUS_SignalR_SubResourceEmbedded can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForPrivateEndpointConnectionSTATUSSignalRSubResourceEmbedded(subject PrivateEndpointConnection_STATUS_SignalR_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.PrivateEndpointConnection_STATUS_SignalR_SubResourceEmbedded
	err := copied.AssignPropertiesToPrivateEndpointConnectionSTATUSSignalRSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PrivateEndpointConnection_STATUS_SignalR_SubResourceEmbedded
	err = actual.AssignPropertiesFromPrivateEndpointConnectionSTATUSSignalRSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PrivateEndpointConnection_STATUS_SignalR_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointConnection_STATUS_SignalR_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointConnectionSTATUSSignalRSubResourceEmbedded, PrivateEndpointConnectionSTATUSSignalRSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointConnectionSTATUSSignalRSubResourceEmbedded runs a test to see if a specific instance of PrivateEndpointConnection_STATUS_SignalR_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointConnectionSTATUSSignalRSubResourceEmbedded(subject PrivateEndpointConnection_STATUS_SignalR_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointConnection_STATUS_SignalR_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointConnection_STATUS_SignalR_SubResourceEmbedded instances for property testing - lazily
// instantiated by PrivateEndpointConnectionSTATUSSignalRSubResourceEmbeddedGenerator()
var privateEndpointConnectionSTATUSSignalRSubResourceEmbeddedGenerator gopter.Gen

// PrivateEndpointConnectionSTATUSSignalRSubResourceEmbeddedGenerator returns a generator of PrivateEndpointConnection_STATUS_SignalR_SubResourceEmbedded instances for property testing.
// We first initialize privateEndpointConnectionSTATUSSignalRSubResourceEmbeddedGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateEndpointConnectionSTATUSSignalRSubResourceEmbeddedGenerator() gopter.Gen {
	if privateEndpointConnectionSTATUSSignalRSubResourceEmbeddedGenerator != nil {
		return privateEndpointConnectionSTATUSSignalRSubResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnectionSTATUSSignalRSubResourceEmbedded(generators)
	privateEndpointConnectionSTATUSSignalRSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnection_STATUS_SignalR_SubResourceEmbedded{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnectionSTATUSSignalRSubResourceEmbedded(generators)
	AddRelatedPropertyGeneratorsForPrivateEndpointConnectionSTATUSSignalRSubResourceEmbedded(generators)
	privateEndpointConnectionSTATUSSignalRSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnection_STATUS_SignalR_SubResourceEmbedded{}), generators)

	return privateEndpointConnectionSTATUSSignalRSubResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointConnectionSTATUSSignalRSubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointConnectionSTATUSSignalRSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPrivateEndpointConnectionSTATUSSignalRSubResourceEmbedded is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateEndpointConnectionSTATUSSignalRSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["SystemData"] = gen.PtrOf(SystemDataSTATUSGenerator())
}

func Test_ResourceLogConfiguration_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResourceLogConfiguration to ResourceLogConfiguration via AssignPropertiesToResourceLogConfiguration & AssignPropertiesFromResourceLogConfiguration returns original",
		prop.ForAll(RunPropertyAssignmentTestForResourceLogConfiguration, ResourceLogConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResourceLogConfiguration tests if a specific instance of ResourceLogConfiguration can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForResourceLogConfiguration(subject ResourceLogConfiguration) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ResourceLogConfiguration
	err := copied.AssignPropertiesToResourceLogConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResourceLogConfiguration
	err = actual.AssignPropertiesFromResourceLogConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResourceLogConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceLogConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceLogConfiguration, ResourceLogConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceLogConfiguration runs a test to see if a specific instance of ResourceLogConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceLogConfiguration(subject ResourceLogConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceLogConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceLogConfiguration instances for property testing - lazily instantiated by
// ResourceLogConfigurationGenerator()
var resourceLogConfigurationGenerator gopter.Gen

// ResourceLogConfigurationGenerator returns a generator of ResourceLogConfiguration instances for property testing.
func ResourceLogConfigurationGenerator() gopter.Gen {
	if resourceLogConfigurationGenerator != nil {
		return resourceLogConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForResourceLogConfiguration(generators)
	resourceLogConfigurationGenerator = gen.Struct(reflect.TypeOf(ResourceLogConfiguration{}), generators)

	return resourceLogConfigurationGenerator
}

// AddRelatedPropertyGeneratorsForResourceLogConfiguration is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResourceLogConfiguration(gens map[string]gopter.Gen) {
	gens["Categories"] = gen.SliceOf(ResourceLogCategoryGenerator())
}

func Test_ResourceLogConfiguration_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResourceLogConfiguration_STATUS to ResourceLogConfiguration_STATUS via AssignPropertiesToResourceLogConfigurationSTATUS & AssignPropertiesFromResourceLogConfigurationSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForResourceLogConfigurationSTATUS, ResourceLogConfigurationSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResourceLogConfigurationSTATUS tests if a specific instance of ResourceLogConfiguration_STATUS can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForResourceLogConfigurationSTATUS(subject ResourceLogConfiguration_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ResourceLogConfiguration_STATUS
	err := copied.AssignPropertiesToResourceLogConfigurationSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResourceLogConfiguration_STATUS
	err = actual.AssignPropertiesFromResourceLogConfigurationSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResourceLogConfiguration_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceLogConfiguration_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceLogConfigurationSTATUS, ResourceLogConfigurationSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceLogConfigurationSTATUS runs a test to see if a specific instance of ResourceLogConfiguration_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceLogConfigurationSTATUS(subject ResourceLogConfiguration_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceLogConfiguration_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceLogConfiguration_STATUS instances for property testing - lazily instantiated by
// ResourceLogConfigurationSTATUSGenerator()
var resourceLogConfigurationSTATUSGenerator gopter.Gen

// ResourceLogConfigurationSTATUSGenerator returns a generator of ResourceLogConfiguration_STATUS instances for property testing.
func ResourceLogConfigurationSTATUSGenerator() gopter.Gen {
	if resourceLogConfigurationSTATUSGenerator != nil {
		return resourceLogConfigurationSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForResourceLogConfigurationSTATUS(generators)
	resourceLogConfigurationSTATUSGenerator = gen.Struct(reflect.TypeOf(ResourceLogConfiguration_STATUS{}), generators)

	return resourceLogConfigurationSTATUSGenerator
}

// AddRelatedPropertyGeneratorsForResourceLogConfigurationSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResourceLogConfigurationSTATUS(gens map[string]gopter.Gen) {
	gens["Categories"] = gen.SliceOf(ResourceLogCategorySTATUSGenerator())
}

func Test_ResourceSku_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResourceSku to ResourceSku via AssignPropertiesToResourceSku & AssignPropertiesFromResourceSku returns original",
		prop.ForAll(RunPropertyAssignmentTestForResourceSku, ResourceSkuGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResourceSku tests if a specific instance of ResourceSku can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForResourceSku(subject ResourceSku) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ResourceSku
	err := copied.AssignPropertiesToResourceSku(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResourceSku
	err = actual.AssignPropertiesFromResourceSku(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResourceSku_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceSku via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceSku, ResourceSkuGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceSku runs a test to see if a specific instance of ResourceSku round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceSku(subject ResourceSku) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceSku
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceSku instances for property testing - lazily instantiated by ResourceSkuGenerator()
var resourceSkuGenerator gopter.Gen

// ResourceSkuGenerator returns a generator of ResourceSku instances for property testing.
func ResourceSkuGenerator() gopter.Gen {
	if resourceSkuGenerator != nil {
		return resourceSkuGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceSku(generators)
	resourceSkuGenerator = gen.Struct(reflect.TypeOf(ResourceSku{}), generators)

	return resourceSkuGenerator
}

// AddIndependentPropertyGeneratorsForResourceSku is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceSku(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(
		ResourceSkuTier_Basic,
		ResourceSkuTier_Free,
		ResourceSkuTier_Premium,
		ResourceSkuTier_Standard))
}

func Test_ResourceSku_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResourceSku_STATUS to ResourceSku_STATUS via AssignPropertiesToResourceSkuSTATUS & AssignPropertiesFromResourceSkuSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForResourceSkuSTATUS, ResourceSkuSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResourceSkuSTATUS tests if a specific instance of ResourceSku_STATUS can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForResourceSkuSTATUS(subject ResourceSku_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ResourceSku_STATUS
	err := copied.AssignPropertiesToResourceSkuSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResourceSku_STATUS
	err = actual.AssignPropertiesFromResourceSkuSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResourceSku_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceSku_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceSkuSTATUS, ResourceSkuSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceSkuSTATUS runs a test to see if a specific instance of ResourceSku_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceSkuSTATUS(subject ResourceSku_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceSku_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceSku_STATUS instances for property testing - lazily instantiated by ResourceSkuSTATUSGenerator()
var resourceSkuSTATUSGenerator gopter.Gen

// ResourceSkuSTATUSGenerator returns a generator of ResourceSku_STATUS instances for property testing.
func ResourceSkuSTATUSGenerator() gopter.Gen {
	if resourceSkuSTATUSGenerator != nil {
		return resourceSkuSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceSkuSTATUS(generators)
	resourceSkuSTATUSGenerator = gen.Struct(reflect.TypeOf(ResourceSku_STATUS{}), generators)

	return resourceSkuSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForResourceSkuSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceSkuSTATUS(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Family"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Size"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(
		SignalRSkuTier_STATUS_Basic,
		SignalRSkuTier_STATUS_Free,
		SignalRSkuTier_STATUS_Premium,
		SignalRSkuTier_STATUS_Standard))
}

func Test_ServerlessUpstreamSettings_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ServerlessUpstreamSettings to ServerlessUpstreamSettings via AssignPropertiesToServerlessUpstreamSettings & AssignPropertiesFromServerlessUpstreamSettings returns original",
		prop.ForAll(RunPropertyAssignmentTestForServerlessUpstreamSettings, ServerlessUpstreamSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForServerlessUpstreamSettings tests if a specific instance of ServerlessUpstreamSettings can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForServerlessUpstreamSettings(subject ServerlessUpstreamSettings) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ServerlessUpstreamSettings
	err := copied.AssignPropertiesToServerlessUpstreamSettings(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ServerlessUpstreamSettings
	err = actual.AssignPropertiesFromServerlessUpstreamSettings(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ServerlessUpstreamSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServerlessUpstreamSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServerlessUpstreamSettings, ServerlessUpstreamSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServerlessUpstreamSettings runs a test to see if a specific instance of ServerlessUpstreamSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForServerlessUpstreamSettings(subject ServerlessUpstreamSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServerlessUpstreamSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServerlessUpstreamSettings instances for property testing - lazily instantiated by
// ServerlessUpstreamSettingsGenerator()
var serverlessUpstreamSettingsGenerator gopter.Gen

// ServerlessUpstreamSettingsGenerator returns a generator of ServerlessUpstreamSettings instances for property testing.
func ServerlessUpstreamSettingsGenerator() gopter.Gen {
	if serverlessUpstreamSettingsGenerator != nil {
		return serverlessUpstreamSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForServerlessUpstreamSettings(generators)
	serverlessUpstreamSettingsGenerator = gen.Struct(reflect.TypeOf(ServerlessUpstreamSettings{}), generators)

	return serverlessUpstreamSettingsGenerator
}

// AddRelatedPropertyGeneratorsForServerlessUpstreamSettings is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForServerlessUpstreamSettings(gens map[string]gopter.Gen) {
	gens["Templates"] = gen.SliceOf(UpstreamTemplateGenerator())
}

func Test_ServerlessUpstreamSettings_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ServerlessUpstreamSettings_STATUS to ServerlessUpstreamSettings_STATUS via AssignPropertiesToServerlessUpstreamSettingsSTATUS & AssignPropertiesFromServerlessUpstreamSettingsSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForServerlessUpstreamSettingsSTATUS, ServerlessUpstreamSettingsSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForServerlessUpstreamSettingsSTATUS tests if a specific instance of ServerlessUpstreamSettings_STATUS can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForServerlessUpstreamSettingsSTATUS(subject ServerlessUpstreamSettings_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ServerlessUpstreamSettings_STATUS
	err := copied.AssignPropertiesToServerlessUpstreamSettingsSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ServerlessUpstreamSettings_STATUS
	err = actual.AssignPropertiesFromServerlessUpstreamSettingsSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ServerlessUpstreamSettings_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServerlessUpstreamSettings_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServerlessUpstreamSettingsSTATUS, ServerlessUpstreamSettingsSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServerlessUpstreamSettingsSTATUS runs a test to see if a specific instance of ServerlessUpstreamSettings_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForServerlessUpstreamSettingsSTATUS(subject ServerlessUpstreamSettings_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServerlessUpstreamSettings_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServerlessUpstreamSettings_STATUS instances for property testing - lazily instantiated by
// ServerlessUpstreamSettingsSTATUSGenerator()
var serverlessUpstreamSettingsSTATUSGenerator gopter.Gen

// ServerlessUpstreamSettingsSTATUSGenerator returns a generator of ServerlessUpstreamSettings_STATUS instances for property testing.
func ServerlessUpstreamSettingsSTATUSGenerator() gopter.Gen {
	if serverlessUpstreamSettingsSTATUSGenerator != nil {
		return serverlessUpstreamSettingsSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForServerlessUpstreamSettingsSTATUS(generators)
	serverlessUpstreamSettingsSTATUSGenerator = gen.Struct(reflect.TypeOf(ServerlessUpstreamSettings_STATUS{}), generators)

	return serverlessUpstreamSettingsSTATUSGenerator
}

// AddRelatedPropertyGeneratorsForServerlessUpstreamSettingsSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForServerlessUpstreamSettingsSTATUS(gens map[string]gopter.Gen) {
	gens["Templates"] = gen.SliceOf(UpstreamTemplateSTATUSGenerator())
}

func Test_SharedPrivateLinkResource_STATUS_SignalR_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SharedPrivateLinkResource_STATUS_SignalR_SubResourceEmbedded to SharedPrivateLinkResource_STATUS_SignalR_SubResourceEmbedded via AssignPropertiesToSharedPrivateLinkResourceSTATUSSignalRSubResourceEmbedded & AssignPropertiesFromSharedPrivateLinkResourceSTATUSSignalRSubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForSharedPrivateLinkResourceSTATUSSignalRSubResourceEmbedded, SharedPrivateLinkResourceSTATUSSignalRSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSharedPrivateLinkResourceSTATUSSignalRSubResourceEmbedded tests if a specific instance of SharedPrivateLinkResource_STATUS_SignalR_SubResourceEmbedded can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForSharedPrivateLinkResourceSTATUSSignalRSubResourceEmbedded(subject SharedPrivateLinkResource_STATUS_SignalR_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.SharedPrivateLinkResource_STATUS_SignalR_SubResourceEmbedded
	err := copied.AssignPropertiesToSharedPrivateLinkResourceSTATUSSignalRSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SharedPrivateLinkResource_STATUS_SignalR_SubResourceEmbedded
	err = actual.AssignPropertiesFromSharedPrivateLinkResourceSTATUSSignalRSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SharedPrivateLinkResource_STATUS_SignalR_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SharedPrivateLinkResource_STATUS_SignalR_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSharedPrivateLinkResourceSTATUSSignalRSubResourceEmbedded, SharedPrivateLinkResourceSTATUSSignalRSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSharedPrivateLinkResourceSTATUSSignalRSubResourceEmbedded runs a test to see if a specific instance of SharedPrivateLinkResource_STATUS_SignalR_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForSharedPrivateLinkResourceSTATUSSignalRSubResourceEmbedded(subject SharedPrivateLinkResource_STATUS_SignalR_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SharedPrivateLinkResource_STATUS_SignalR_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SharedPrivateLinkResource_STATUS_SignalR_SubResourceEmbedded instances for property testing - lazily
// instantiated by SharedPrivateLinkResourceSTATUSSignalRSubResourceEmbeddedGenerator()
var sharedPrivateLinkResourceSTATUSSignalRSubResourceEmbeddedGenerator gopter.Gen

// SharedPrivateLinkResourceSTATUSSignalRSubResourceEmbeddedGenerator returns a generator of SharedPrivateLinkResource_STATUS_SignalR_SubResourceEmbedded instances for property testing.
// We first initialize sharedPrivateLinkResourceSTATUSSignalRSubResourceEmbeddedGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SharedPrivateLinkResourceSTATUSSignalRSubResourceEmbeddedGenerator() gopter.Gen {
	if sharedPrivateLinkResourceSTATUSSignalRSubResourceEmbeddedGenerator != nil {
		return sharedPrivateLinkResourceSTATUSSignalRSubResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSharedPrivateLinkResourceSTATUSSignalRSubResourceEmbedded(generators)
	sharedPrivateLinkResourceSTATUSSignalRSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(SharedPrivateLinkResource_STATUS_SignalR_SubResourceEmbedded{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSharedPrivateLinkResourceSTATUSSignalRSubResourceEmbedded(generators)
	AddRelatedPropertyGeneratorsForSharedPrivateLinkResourceSTATUSSignalRSubResourceEmbedded(generators)
	sharedPrivateLinkResourceSTATUSSignalRSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(SharedPrivateLinkResource_STATUS_SignalR_SubResourceEmbedded{}), generators)

	return sharedPrivateLinkResourceSTATUSSignalRSubResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForSharedPrivateLinkResourceSTATUSSignalRSubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSharedPrivateLinkResourceSTATUSSignalRSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSharedPrivateLinkResourceSTATUSSignalRSubResourceEmbedded is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSharedPrivateLinkResourceSTATUSSignalRSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["SystemData"] = gen.PtrOf(SystemDataSTATUSGenerator())
}

func Test_SignalRCorsSettings_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SignalRCorsSettings to SignalRCorsSettings via AssignPropertiesToSignalRCorsSettings & AssignPropertiesFromSignalRCorsSettings returns original",
		prop.ForAll(RunPropertyAssignmentTestForSignalRCorsSettings, SignalRCorsSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSignalRCorsSettings tests if a specific instance of SignalRCorsSettings can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForSignalRCorsSettings(subject SignalRCorsSettings) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.SignalRCorsSettings
	err := copied.AssignPropertiesToSignalRCorsSettings(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SignalRCorsSettings
	err = actual.AssignPropertiesFromSignalRCorsSettings(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SignalRCorsSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRCorsSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRCorsSettings, SignalRCorsSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRCorsSettings runs a test to see if a specific instance of SignalRCorsSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRCorsSettings(subject SignalRCorsSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRCorsSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRCorsSettings instances for property testing - lazily instantiated by
// SignalRCorsSettingsGenerator()
var signalRCorsSettingsGenerator gopter.Gen

// SignalRCorsSettingsGenerator returns a generator of SignalRCorsSettings instances for property testing.
func SignalRCorsSettingsGenerator() gopter.Gen {
	if signalRCorsSettingsGenerator != nil {
		return signalRCorsSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRCorsSettings(generators)
	signalRCorsSettingsGenerator = gen.Struct(reflect.TypeOf(SignalRCorsSettings{}), generators)

	return signalRCorsSettingsGenerator
}

// AddIndependentPropertyGeneratorsForSignalRCorsSettings is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRCorsSettings(gens map[string]gopter.Gen) {
	gens["AllowedOrigins"] = gen.SliceOf(gen.AlphaString())
}

func Test_SignalRCorsSettings_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SignalRCorsSettings_STATUS to SignalRCorsSettings_STATUS via AssignPropertiesToSignalRCorsSettingsSTATUS & AssignPropertiesFromSignalRCorsSettingsSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSignalRCorsSettingsSTATUS, SignalRCorsSettingsSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSignalRCorsSettingsSTATUS tests if a specific instance of SignalRCorsSettings_STATUS can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForSignalRCorsSettingsSTATUS(subject SignalRCorsSettings_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.SignalRCorsSettings_STATUS
	err := copied.AssignPropertiesToSignalRCorsSettingsSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SignalRCorsSettings_STATUS
	err = actual.AssignPropertiesFromSignalRCorsSettingsSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SignalRCorsSettings_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRCorsSettings_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRCorsSettingsSTATUS, SignalRCorsSettingsSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRCorsSettingsSTATUS runs a test to see if a specific instance of SignalRCorsSettings_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRCorsSettingsSTATUS(subject SignalRCorsSettings_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRCorsSettings_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRCorsSettings_STATUS instances for property testing - lazily instantiated by
// SignalRCorsSettingsSTATUSGenerator()
var signalRCorsSettingsSTATUSGenerator gopter.Gen

// SignalRCorsSettingsSTATUSGenerator returns a generator of SignalRCorsSettings_STATUS instances for property testing.
func SignalRCorsSettingsSTATUSGenerator() gopter.Gen {
	if signalRCorsSettingsSTATUSGenerator != nil {
		return signalRCorsSettingsSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRCorsSettingsSTATUS(generators)
	signalRCorsSettingsSTATUSGenerator = gen.Struct(reflect.TypeOf(SignalRCorsSettings_STATUS{}), generators)

	return signalRCorsSettingsSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForSignalRCorsSettingsSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRCorsSettingsSTATUS(gens map[string]gopter.Gen) {
	gens["AllowedOrigins"] = gen.SliceOf(gen.AlphaString())
}

func Test_SignalRFeature_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SignalRFeature to SignalRFeature via AssignPropertiesToSignalRFeature & AssignPropertiesFromSignalRFeature returns original",
		prop.ForAll(RunPropertyAssignmentTestForSignalRFeature, SignalRFeatureGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSignalRFeature tests if a specific instance of SignalRFeature can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForSignalRFeature(subject SignalRFeature) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.SignalRFeature
	err := copied.AssignPropertiesToSignalRFeature(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SignalRFeature
	err = actual.AssignPropertiesFromSignalRFeature(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SignalRFeature_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRFeature via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRFeature, SignalRFeatureGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRFeature runs a test to see if a specific instance of SignalRFeature round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRFeature(subject SignalRFeature) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRFeature
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRFeature instances for property testing - lazily instantiated by SignalRFeatureGenerator()
var signalRFeatureGenerator gopter.Gen

// SignalRFeatureGenerator returns a generator of SignalRFeature instances for property testing.
func SignalRFeatureGenerator() gopter.Gen {
	if signalRFeatureGenerator != nil {
		return signalRFeatureGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRFeature(generators)
	signalRFeatureGenerator = gen.Struct(reflect.TypeOf(SignalRFeature{}), generators)

	return signalRFeatureGenerator
}

// AddIndependentPropertyGeneratorsForSignalRFeature is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRFeature(gens map[string]gopter.Gen) {
	gens["Flag"] = gen.PtrOf(gen.OneConstOf(
		SignalRFeatureFlag_EnableConnectivityLogs,
		SignalRFeatureFlag_EnableLiveTrace,
		SignalRFeatureFlag_EnableMessagingLogs,
		SignalRFeatureFlag_ServiceMode))
	gens["Properties"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_SignalRFeature_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SignalRFeature_STATUS to SignalRFeature_STATUS via AssignPropertiesToSignalRFeatureSTATUS & AssignPropertiesFromSignalRFeatureSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSignalRFeatureSTATUS, SignalRFeatureSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSignalRFeatureSTATUS tests if a specific instance of SignalRFeature_STATUS can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForSignalRFeatureSTATUS(subject SignalRFeature_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.SignalRFeature_STATUS
	err := copied.AssignPropertiesToSignalRFeatureSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SignalRFeature_STATUS
	err = actual.AssignPropertiesFromSignalRFeatureSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SignalRFeature_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRFeature_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRFeatureSTATUS, SignalRFeatureSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRFeatureSTATUS runs a test to see if a specific instance of SignalRFeature_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRFeatureSTATUS(subject SignalRFeature_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRFeature_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRFeature_STATUS instances for property testing - lazily instantiated by
// SignalRFeatureSTATUSGenerator()
var signalRFeatureSTATUSGenerator gopter.Gen

// SignalRFeatureSTATUSGenerator returns a generator of SignalRFeature_STATUS instances for property testing.
func SignalRFeatureSTATUSGenerator() gopter.Gen {
	if signalRFeatureSTATUSGenerator != nil {
		return signalRFeatureSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRFeatureSTATUS(generators)
	signalRFeatureSTATUSGenerator = gen.Struct(reflect.TypeOf(SignalRFeature_STATUS{}), generators)

	return signalRFeatureSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForSignalRFeatureSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRFeatureSTATUS(gens map[string]gopter.Gen) {
	gens["Flag"] = gen.PtrOf(gen.OneConstOf(
		FeatureFlags_STATUS_EnableConnectivityLogs,
		FeatureFlags_STATUS_EnableLiveTrace,
		FeatureFlags_STATUS_EnableMessagingLogs,
		FeatureFlags_STATUS_ServiceMode))
	gens["Properties"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_SignalRNetworkACLs_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SignalRNetworkACLs to SignalRNetworkACLs via AssignPropertiesToSignalRNetworkACLs & AssignPropertiesFromSignalRNetworkACLs returns original",
		prop.ForAll(RunPropertyAssignmentTestForSignalRNetworkACLs, SignalRNetworkACLsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSignalRNetworkACLs tests if a specific instance of SignalRNetworkACLs can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForSignalRNetworkACLs(subject SignalRNetworkACLs) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.SignalRNetworkACLs
	err := copied.AssignPropertiesToSignalRNetworkACLs(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SignalRNetworkACLs
	err = actual.AssignPropertiesFromSignalRNetworkACLs(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SignalRNetworkACLs_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRNetworkACLs via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRNetworkACLs, SignalRNetworkACLsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRNetworkACLs runs a test to see if a specific instance of SignalRNetworkACLs round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRNetworkACLs(subject SignalRNetworkACLs) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRNetworkACLs
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRNetworkACLs instances for property testing - lazily instantiated by SignalRNetworkACLsGenerator()
var signalRNetworkACLsGenerator gopter.Gen

// SignalRNetworkACLsGenerator returns a generator of SignalRNetworkACLs instances for property testing.
// We first initialize signalRNetworkACLsGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SignalRNetworkACLsGenerator() gopter.Gen {
	if signalRNetworkACLsGenerator != nil {
		return signalRNetworkACLsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRNetworkACLs(generators)
	signalRNetworkACLsGenerator = gen.Struct(reflect.TypeOf(SignalRNetworkACLs{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRNetworkACLs(generators)
	AddRelatedPropertyGeneratorsForSignalRNetworkACLs(generators)
	signalRNetworkACLsGenerator = gen.Struct(reflect.TypeOf(SignalRNetworkACLs{}), generators)

	return signalRNetworkACLsGenerator
}

// AddIndependentPropertyGeneratorsForSignalRNetworkACLs is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRNetworkACLs(gens map[string]gopter.Gen) {
	gens["DefaultAction"] = gen.PtrOf(gen.OneConstOf(SignalRNetworkACLsDefaultAction_Allow, SignalRNetworkACLsDefaultAction_Deny))
}

// AddRelatedPropertyGeneratorsForSignalRNetworkACLs is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSignalRNetworkACLs(gens map[string]gopter.Gen) {
	gens["PrivateEndpoints"] = gen.SliceOf(PrivateEndpointACLGenerator())
	gens["PublicNetwork"] = gen.PtrOf(NetworkACLGenerator())
}

func Test_SignalRNetworkACLs_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SignalRNetworkACLs_STATUS to SignalRNetworkACLs_STATUS via AssignPropertiesToSignalRNetworkACLsSTATUS & AssignPropertiesFromSignalRNetworkACLsSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSignalRNetworkACLsSTATUS, SignalRNetworkACLsSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSignalRNetworkACLsSTATUS tests if a specific instance of SignalRNetworkACLs_STATUS can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForSignalRNetworkACLsSTATUS(subject SignalRNetworkACLs_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.SignalRNetworkACLs_STATUS
	err := copied.AssignPropertiesToSignalRNetworkACLsSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SignalRNetworkACLs_STATUS
	err = actual.AssignPropertiesFromSignalRNetworkACLsSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SignalRNetworkACLs_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRNetworkACLs_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRNetworkACLsSTATUS, SignalRNetworkACLsSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRNetworkACLsSTATUS runs a test to see if a specific instance of SignalRNetworkACLs_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRNetworkACLsSTATUS(subject SignalRNetworkACLs_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRNetworkACLs_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRNetworkACLs_STATUS instances for property testing - lazily instantiated by
// SignalRNetworkACLsSTATUSGenerator()
var signalRNetworkACLsSTATUSGenerator gopter.Gen

// SignalRNetworkACLsSTATUSGenerator returns a generator of SignalRNetworkACLs_STATUS instances for property testing.
// We first initialize signalRNetworkACLsSTATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SignalRNetworkACLsSTATUSGenerator() gopter.Gen {
	if signalRNetworkACLsSTATUSGenerator != nil {
		return signalRNetworkACLsSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRNetworkACLsSTATUS(generators)
	signalRNetworkACLsSTATUSGenerator = gen.Struct(reflect.TypeOf(SignalRNetworkACLs_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRNetworkACLsSTATUS(generators)
	AddRelatedPropertyGeneratorsForSignalRNetworkACLsSTATUS(generators)
	signalRNetworkACLsSTATUSGenerator = gen.Struct(reflect.TypeOf(SignalRNetworkACLs_STATUS{}), generators)

	return signalRNetworkACLsSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForSignalRNetworkACLsSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRNetworkACLsSTATUS(gens map[string]gopter.Gen) {
	gens["DefaultAction"] = gen.PtrOf(gen.OneConstOf(ACLAction_STATUS_Allow, ACLAction_STATUS_Deny))
}

// AddRelatedPropertyGeneratorsForSignalRNetworkACLsSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSignalRNetworkACLsSTATUS(gens map[string]gopter.Gen) {
	gens["PrivateEndpoints"] = gen.SliceOf(PrivateEndpointACLSTATUSGenerator())
	gens["PublicNetwork"] = gen.PtrOf(NetworkACLSTATUSGenerator())
}

func Test_SignalRTlsSettings_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SignalRTlsSettings to SignalRTlsSettings via AssignPropertiesToSignalRTlsSettings & AssignPropertiesFromSignalRTlsSettings returns original",
		prop.ForAll(RunPropertyAssignmentTestForSignalRTlsSettings, SignalRTlsSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSignalRTlsSettings tests if a specific instance of SignalRTlsSettings can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForSignalRTlsSettings(subject SignalRTlsSettings) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.SignalRTlsSettings
	err := copied.AssignPropertiesToSignalRTlsSettings(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SignalRTlsSettings
	err = actual.AssignPropertiesFromSignalRTlsSettings(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SignalRTlsSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRTlsSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRTlsSettings, SignalRTlsSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRTlsSettings runs a test to see if a specific instance of SignalRTlsSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRTlsSettings(subject SignalRTlsSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRTlsSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRTlsSettings instances for property testing - lazily instantiated by SignalRTlsSettingsGenerator()
var signalRTlsSettingsGenerator gopter.Gen

// SignalRTlsSettingsGenerator returns a generator of SignalRTlsSettings instances for property testing.
func SignalRTlsSettingsGenerator() gopter.Gen {
	if signalRTlsSettingsGenerator != nil {
		return signalRTlsSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRTlsSettings(generators)
	signalRTlsSettingsGenerator = gen.Struct(reflect.TypeOf(SignalRTlsSettings{}), generators)

	return signalRTlsSettingsGenerator
}

// AddIndependentPropertyGeneratorsForSignalRTlsSettings is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRTlsSettings(gens map[string]gopter.Gen) {
	gens["ClientCertEnabled"] = gen.PtrOf(gen.Bool())
}

func Test_SignalRTlsSettings_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SignalRTlsSettings_STATUS to SignalRTlsSettings_STATUS via AssignPropertiesToSignalRTlsSettingsSTATUS & AssignPropertiesFromSignalRTlsSettingsSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSignalRTlsSettingsSTATUS, SignalRTlsSettingsSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSignalRTlsSettingsSTATUS tests if a specific instance of SignalRTlsSettings_STATUS can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForSignalRTlsSettingsSTATUS(subject SignalRTlsSettings_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.SignalRTlsSettings_STATUS
	err := copied.AssignPropertiesToSignalRTlsSettingsSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SignalRTlsSettings_STATUS
	err = actual.AssignPropertiesFromSignalRTlsSettingsSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SignalRTlsSettings_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRTlsSettings_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRTlsSettingsSTATUS, SignalRTlsSettingsSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRTlsSettingsSTATUS runs a test to see if a specific instance of SignalRTlsSettings_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRTlsSettingsSTATUS(subject SignalRTlsSettings_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRTlsSettings_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRTlsSettings_STATUS instances for property testing - lazily instantiated by
// SignalRTlsSettingsSTATUSGenerator()
var signalRTlsSettingsSTATUSGenerator gopter.Gen

// SignalRTlsSettingsSTATUSGenerator returns a generator of SignalRTlsSettings_STATUS instances for property testing.
func SignalRTlsSettingsSTATUSGenerator() gopter.Gen {
	if signalRTlsSettingsSTATUSGenerator != nil {
		return signalRTlsSettingsSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRTlsSettingsSTATUS(generators)
	signalRTlsSettingsSTATUSGenerator = gen.Struct(reflect.TypeOf(SignalRTlsSettings_STATUS{}), generators)

	return signalRTlsSettingsSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForSignalRTlsSettingsSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRTlsSettingsSTATUS(gens map[string]gopter.Gen) {
	gens["ClientCertEnabled"] = gen.PtrOf(gen.Bool())
}

func Test_SystemData_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SystemData_STATUS to SystemData_STATUS via AssignPropertiesToSystemDataSTATUS & AssignPropertiesFromSystemDataSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSystemDataSTATUS, SystemDataSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSystemDataSTATUS tests if a specific instance of SystemData_STATUS can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForSystemDataSTATUS(subject SystemData_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.SystemData_STATUS
	err := copied.AssignPropertiesToSystemDataSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SystemData_STATUS
	err = actual.AssignPropertiesFromSystemDataSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SystemData_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SystemData_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSystemDataSTATUS, SystemDataSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSystemDataSTATUS runs a test to see if a specific instance of SystemData_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSystemDataSTATUS(subject SystemData_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SystemData_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SystemData_STATUS instances for property testing - lazily instantiated by SystemDataSTATUSGenerator()
var systemDataSTATUSGenerator gopter.Gen

// SystemDataSTATUSGenerator returns a generator of SystemData_STATUS instances for property testing.
func SystemDataSTATUSGenerator() gopter.Gen {
	if systemDataSTATUSGenerator != nil {
		return systemDataSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSystemDataSTATUS(generators)
	systemDataSTATUSGenerator = gen.Struct(reflect.TypeOf(SystemData_STATUS{}), generators)

	return systemDataSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForSystemDataSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSystemDataSTATUS(gens map[string]gopter.Gen) {
	gens["CreatedAt"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedBy"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemDataSTATUSCreatedByType_Application,
		SystemDataSTATUSCreatedByType_Key,
		SystemDataSTATUSCreatedByType_ManagedIdentity,
		SystemDataSTATUSCreatedByType_User))
	gens["LastModifiedAt"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedBy"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemDataSTATUSLastModifiedByType_Application,
		SystemDataSTATUSLastModifiedByType_Key,
		SystemDataSTATUSLastModifiedByType_ManagedIdentity,
		SystemDataSTATUSLastModifiedByType_User))
}

func Test_NetworkACL_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NetworkACL to NetworkACL via AssignPropertiesToNetworkACL & AssignPropertiesFromNetworkACL returns original",
		prop.ForAll(RunPropertyAssignmentTestForNetworkACL, NetworkACLGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNetworkACL tests if a specific instance of NetworkACL can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForNetworkACL(subject NetworkACL) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.NetworkACL
	err := copied.AssignPropertiesToNetworkACL(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NetworkACL
	err = actual.AssignPropertiesFromNetworkACL(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NetworkACL_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkACL via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkACL, NetworkACLGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkACL runs a test to see if a specific instance of NetworkACL round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkACL(subject NetworkACL) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkACL
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkACL instances for property testing - lazily instantiated by NetworkACLGenerator()
var networkACLGenerator gopter.Gen

// NetworkACLGenerator returns a generator of NetworkACL instances for property testing.
func NetworkACLGenerator() gopter.Gen {
	if networkACLGenerator != nil {
		return networkACLGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkACL(generators)
	networkACLGenerator = gen.Struct(reflect.TypeOf(NetworkACL{}), generators)

	return networkACLGenerator
}

// AddIndependentPropertyGeneratorsForNetworkACL is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkACL(gens map[string]gopter.Gen) {
	gens["Allow"] = gen.SliceOf(gen.OneConstOf(
		NetworkACLAllow_ClientConnection,
		NetworkACLAllow_RESTAPI,
		NetworkACLAllow_ServerConnection,
		NetworkACLAllow_Trace))
	gens["Deny"] = gen.SliceOf(gen.OneConstOf(
		NetworkACLDeny_ClientConnection,
		NetworkACLDeny_RESTAPI,
		NetworkACLDeny_ServerConnection,
		NetworkACLDeny_Trace))
}

func Test_NetworkACL_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NetworkACL_STATUS to NetworkACL_STATUS via AssignPropertiesToNetworkACLSTATUS & AssignPropertiesFromNetworkACLSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForNetworkACLSTATUS, NetworkACLSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNetworkACLSTATUS tests if a specific instance of NetworkACL_STATUS can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForNetworkACLSTATUS(subject NetworkACL_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.NetworkACL_STATUS
	err := copied.AssignPropertiesToNetworkACLSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NetworkACL_STATUS
	err = actual.AssignPropertiesFromNetworkACLSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NetworkACL_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkACL_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkACLSTATUS, NetworkACLSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkACLSTATUS runs a test to see if a specific instance of NetworkACL_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkACLSTATUS(subject NetworkACL_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkACL_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkACL_STATUS instances for property testing - lazily instantiated by NetworkACLSTATUSGenerator()
var networkACLSTATUSGenerator gopter.Gen

// NetworkACLSTATUSGenerator returns a generator of NetworkACL_STATUS instances for property testing.
func NetworkACLSTATUSGenerator() gopter.Gen {
	if networkACLSTATUSGenerator != nil {
		return networkACLSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkACLSTATUS(generators)
	networkACLSTATUSGenerator = gen.Struct(reflect.TypeOf(NetworkACL_STATUS{}), generators)

	return networkACLSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForNetworkACLSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkACLSTATUS(gens map[string]gopter.Gen) {
	gens["Allow"] = gen.SliceOf(gen.OneConstOf(
		SignalRRequestType_STATUS_ClientConnection,
		SignalRRequestType_STATUS_RESTAPI,
		SignalRRequestType_STATUS_ServerConnection,
		SignalRRequestType_STATUS_Trace))
	gens["Deny"] = gen.SliceOf(gen.OneConstOf(
		SignalRRequestType_STATUS_ClientConnection,
		SignalRRequestType_STATUS_RESTAPI,
		SignalRRequestType_STATUS_ServerConnection,
		SignalRRequestType_STATUS_Trace))
}

func Test_PrivateEndpointACL_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PrivateEndpointACL to PrivateEndpointACL via AssignPropertiesToPrivateEndpointACL & AssignPropertiesFromPrivateEndpointACL returns original",
		prop.ForAll(RunPropertyAssignmentTestForPrivateEndpointACL, PrivateEndpointACLGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPrivateEndpointACL tests if a specific instance of PrivateEndpointACL can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForPrivateEndpointACL(subject PrivateEndpointACL) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.PrivateEndpointACL
	err := copied.AssignPropertiesToPrivateEndpointACL(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PrivateEndpointACL
	err = actual.AssignPropertiesFromPrivateEndpointACL(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PrivateEndpointACL_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointACL via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointACL, PrivateEndpointACLGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointACL runs a test to see if a specific instance of PrivateEndpointACL round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointACL(subject PrivateEndpointACL) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointACL
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointACL instances for property testing - lazily instantiated by PrivateEndpointACLGenerator()
var privateEndpointACLGenerator gopter.Gen

// PrivateEndpointACLGenerator returns a generator of PrivateEndpointACL instances for property testing.
func PrivateEndpointACLGenerator() gopter.Gen {
	if privateEndpointACLGenerator != nil {
		return privateEndpointACLGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointACL(generators)
	privateEndpointACLGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointACL{}), generators)

	return privateEndpointACLGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointACL is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointACL(gens map[string]gopter.Gen) {
	gens["Allow"] = gen.SliceOf(gen.OneConstOf(
		PrivateEndpointACLAllow_ClientConnection,
		PrivateEndpointACLAllow_RESTAPI,
		PrivateEndpointACLAllow_ServerConnection,
		PrivateEndpointACLAllow_Trace))
	gens["Deny"] = gen.SliceOf(gen.OneConstOf(
		PrivateEndpointACLDeny_ClientConnection,
		PrivateEndpointACLDeny_RESTAPI,
		PrivateEndpointACLDeny_ServerConnection,
		PrivateEndpointACLDeny_Trace))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_PrivateEndpointACL_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PrivateEndpointACL_STATUS to PrivateEndpointACL_STATUS via AssignPropertiesToPrivateEndpointACLSTATUS & AssignPropertiesFromPrivateEndpointACLSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForPrivateEndpointACLSTATUS, PrivateEndpointACLSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPrivateEndpointACLSTATUS tests if a specific instance of PrivateEndpointACL_STATUS can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForPrivateEndpointACLSTATUS(subject PrivateEndpointACL_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.PrivateEndpointACL_STATUS
	err := copied.AssignPropertiesToPrivateEndpointACLSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PrivateEndpointACL_STATUS
	err = actual.AssignPropertiesFromPrivateEndpointACLSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PrivateEndpointACL_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointACL_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointACLSTATUS, PrivateEndpointACLSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointACLSTATUS runs a test to see if a specific instance of PrivateEndpointACL_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointACLSTATUS(subject PrivateEndpointACL_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointACL_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointACL_STATUS instances for property testing - lazily instantiated by
// PrivateEndpointACLSTATUSGenerator()
var privateEndpointACLSTATUSGenerator gopter.Gen

// PrivateEndpointACLSTATUSGenerator returns a generator of PrivateEndpointACL_STATUS instances for property testing.
func PrivateEndpointACLSTATUSGenerator() gopter.Gen {
	if privateEndpointACLSTATUSGenerator != nil {
		return privateEndpointACLSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointACLSTATUS(generators)
	privateEndpointACLSTATUSGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointACL_STATUS{}), generators)

	return privateEndpointACLSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointACLSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointACLSTATUS(gens map[string]gopter.Gen) {
	gens["Allow"] = gen.SliceOf(gen.OneConstOf(
		SignalRRequestType_STATUS_ClientConnection,
		SignalRRequestType_STATUS_RESTAPI,
		SignalRRequestType_STATUS_ServerConnection,
		SignalRRequestType_STATUS_Trace))
	gens["Deny"] = gen.SliceOf(gen.OneConstOf(
		SignalRRequestType_STATUS_ClientConnection,
		SignalRRequestType_STATUS_RESTAPI,
		SignalRRequestType_STATUS_ServerConnection,
		SignalRRequestType_STATUS_Trace))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_ResourceLogCategory_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResourceLogCategory to ResourceLogCategory via AssignPropertiesToResourceLogCategory & AssignPropertiesFromResourceLogCategory returns original",
		prop.ForAll(RunPropertyAssignmentTestForResourceLogCategory, ResourceLogCategoryGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResourceLogCategory tests if a specific instance of ResourceLogCategory can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForResourceLogCategory(subject ResourceLogCategory) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ResourceLogCategory
	err := copied.AssignPropertiesToResourceLogCategory(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResourceLogCategory
	err = actual.AssignPropertiesFromResourceLogCategory(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResourceLogCategory_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceLogCategory via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceLogCategory, ResourceLogCategoryGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceLogCategory runs a test to see if a specific instance of ResourceLogCategory round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceLogCategory(subject ResourceLogCategory) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceLogCategory
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceLogCategory instances for property testing - lazily instantiated by
// ResourceLogCategoryGenerator()
var resourceLogCategoryGenerator gopter.Gen

// ResourceLogCategoryGenerator returns a generator of ResourceLogCategory instances for property testing.
func ResourceLogCategoryGenerator() gopter.Gen {
	if resourceLogCategoryGenerator != nil {
		return resourceLogCategoryGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceLogCategory(generators)
	resourceLogCategoryGenerator = gen.Struct(reflect.TypeOf(ResourceLogCategory{}), generators)

	return resourceLogCategoryGenerator
}

// AddIndependentPropertyGeneratorsForResourceLogCategory is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceLogCategory(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_ResourceLogCategory_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResourceLogCategory_STATUS to ResourceLogCategory_STATUS via AssignPropertiesToResourceLogCategorySTATUS & AssignPropertiesFromResourceLogCategorySTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForResourceLogCategorySTATUS, ResourceLogCategorySTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResourceLogCategorySTATUS tests if a specific instance of ResourceLogCategory_STATUS can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForResourceLogCategorySTATUS(subject ResourceLogCategory_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ResourceLogCategory_STATUS
	err := copied.AssignPropertiesToResourceLogCategorySTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResourceLogCategory_STATUS
	err = actual.AssignPropertiesFromResourceLogCategorySTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResourceLogCategory_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceLogCategory_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceLogCategorySTATUS, ResourceLogCategorySTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceLogCategorySTATUS runs a test to see if a specific instance of ResourceLogCategory_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceLogCategorySTATUS(subject ResourceLogCategory_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceLogCategory_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceLogCategory_STATUS instances for property testing - lazily instantiated by
// ResourceLogCategorySTATUSGenerator()
var resourceLogCategorySTATUSGenerator gopter.Gen

// ResourceLogCategorySTATUSGenerator returns a generator of ResourceLogCategory_STATUS instances for property testing.
func ResourceLogCategorySTATUSGenerator() gopter.Gen {
	if resourceLogCategorySTATUSGenerator != nil {
		return resourceLogCategorySTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceLogCategorySTATUS(generators)
	resourceLogCategorySTATUSGenerator = gen.Struct(reflect.TypeOf(ResourceLogCategory_STATUS{}), generators)

	return resourceLogCategorySTATUSGenerator
}

// AddIndependentPropertyGeneratorsForResourceLogCategorySTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceLogCategorySTATUS(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_UpstreamTemplate_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UpstreamTemplate to UpstreamTemplate via AssignPropertiesToUpstreamTemplate & AssignPropertiesFromUpstreamTemplate returns original",
		prop.ForAll(RunPropertyAssignmentTestForUpstreamTemplate, UpstreamTemplateGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUpstreamTemplate tests if a specific instance of UpstreamTemplate can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForUpstreamTemplate(subject UpstreamTemplate) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.UpstreamTemplate
	err := copied.AssignPropertiesToUpstreamTemplate(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UpstreamTemplate
	err = actual.AssignPropertiesFromUpstreamTemplate(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UpstreamTemplate_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UpstreamTemplate via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUpstreamTemplate, UpstreamTemplateGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUpstreamTemplate runs a test to see if a specific instance of UpstreamTemplate round trips to JSON and back losslessly
func RunJSONSerializationTestForUpstreamTemplate(subject UpstreamTemplate) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UpstreamTemplate
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UpstreamTemplate instances for property testing - lazily instantiated by UpstreamTemplateGenerator()
var upstreamTemplateGenerator gopter.Gen

// UpstreamTemplateGenerator returns a generator of UpstreamTemplate instances for property testing.
// We first initialize upstreamTemplateGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UpstreamTemplateGenerator() gopter.Gen {
	if upstreamTemplateGenerator != nil {
		return upstreamTemplateGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpstreamTemplate(generators)
	upstreamTemplateGenerator = gen.Struct(reflect.TypeOf(UpstreamTemplate{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpstreamTemplate(generators)
	AddRelatedPropertyGeneratorsForUpstreamTemplate(generators)
	upstreamTemplateGenerator = gen.Struct(reflect.TypeOf(UpstreamTemplate{}), generators)

	return upstreamTemplateGenerator
}

// AddIndependentPropertyGeneratorsForUpstreamTemplate is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUpstreamTemplate(gens map[string]gopter.Gen) {
	gens["CategoryPattern"] = gen.PtrOf(gen.AlphaString())
	gens["EventPattern"] = gen.PtrOf(gen.AlphaString())
	gens["HubPattern"] = gen.PtrOf(gen.AlphaString())
	gens["UrlTemplate"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForUpstreamTemplate is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUpstreamTemplate(gens map[string]gopter.Gen) {
	gens["Auth"] = gen.PtrOf(UpstreamAuthSettingsGenerator())
}

func Test_UpstreamTemplate_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UpstreamTemplate_STATUS to UpstreamTemplate_STATUS via AssignPropertiesToUpstreamTemplateSTATUS & AssignPropertiesFromUpstreamTemplateSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForUpstreamTemplateSTATUS, UpstreamTemplateSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUpstreamTemplateSTATUS tests if a specific instance of UpstreamTemplate_STATUS can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForUpstreamTemplateSTATUS(subject UpstreamTemplate_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.UpstreamTemplate_STATUS
	err := copied.AssignPropertiesToUpstreamTemplateSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UpstreamTemplate_STATUS
	err = actual.AssignPropertiesFromUpstreamTemplateSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UpstreamTemplate_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UpstreamTemplate_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUpstreamTemplateSTATUS, UpstreamTemplateSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUpstreamTemplateSTATUS runs a test to see if a specific instance of UpstreamTemplate_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUpstreamTemplateSTATUS(subject UpstreamTemplate_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UpstreamTemplate_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UpstreamTemplate_STATUS instances for property testing - lazily instantiated by
// UpstreamTemplateSTATUSGenerator()
var upstreamTemplateSTATUSGenerator gopter.Gen

// UpstreamTemplateSTATUSGenerator returns a generator of UpstreamTemplate_STATUS instances for property testing.
// We first initialize upstreamTemplateSTATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UpstreamTemplateSTATUSGenerator() gopter.Gen {
	if upstreamTemplateSTATUSGenerator != nil {
		return upstreamTemplateSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpstreamTemplateSTATUS(generators)
	upstreamTemplateSTATUSGenerator = gen.Struct(reflect.TypeOf(UpstreamTemplate_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpstreamTemplateSTATUS(generators)
	AddRelatedPropertyGeneratorsForUpstreamTemplateSTATUS(generators)
	upstreamTemplateSTATUSGenerator = gen.Struct(reflect.TypeOf(UpstreamTemplate_STATUS{}), generators)

	return upstreamTemplateSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForUpstreamTemplateSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUpstreamTemplateSTATUS(gens map[string]gopter.Gen) {
	gens["CategoryPattern"] = gen.PtrOf(gen.AlphaString())
	gens["EventPattern"] = gen.PtrOf(gen.AlphaString())
	gens["HubPattern"] = gen.PtrOf(gen.AlphaString())
	gens["UrlTemplate"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForUpstreamTemplateSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUpstreamTemplateSTATUS(gens map[string]gopter.Gen) {
	gens["Auth"] = gen.PtrOf(UpstreamAuthSettingsSTATUSGenerator())
}

func Test_UserAssignedIdentityProperty_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UserAssignedIdentityProperty_STATUS to UserAssignedIdentityProperty_STATUS via AssignPropertiesToUserAssignedIdentityPropertySTATUS & AssignPropertiesFromUserAssignedIdentityPropertySTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForUserAssignedIdentityPropertySTATUS, UserAssignedIdentityPropertySTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUserAssignedIdentityPropertySTATUS tests if a specific instance of UserAssignedIdentityProperty_STATUS can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForUserAssignedIdentityPropertySTATUS(subject UserAssignedIdentityProperty_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.UserAssignedIdentityProperty_STATUS
	err := copied.AssignPropertiesToUserAssignedIdentityPropertySTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UserAssignedIdentityProperty_STATUS
	err = actual.AssignPropertiesFromUserAssignedIdentityPropertySTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UserAssignedIdentityProperty_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentityProperty_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentityPropertySTATUS, UserAssignedIdentityPropertySTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentityPropertySTATUS runs a test to see if a specific instance of UserAssignedIdentityProperty_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentityPropertySTATUS(subject UserAssignedIdentityProperty_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentityProperty_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentityProperty_STATUS instances for property testing - lazily instantiated by
// UserAssignedIdentityPropertySTATUSGenerator()
var userAssignedIdentityPropertySTATUSGenerator gopter.Gen

// UserAssignedIdentityPropertySTATUSGenerator returns a generator of UserAssignedIdentityProperty_STATUS instances for property testing.
func UserAssignedIdentityPropertySTATUSGenerator() gopter.Gen {
	if userAssignedIdentityPropertySTATUSGenerator != nil {
		return userAssignedIdentityPropertySTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserAssignedIdentityPropertySTATUS(generators)
	userAssignedIdentityPropertySTATUSGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentityProperty_STATUS{}), generators)

	return userAssignedIdentityPropertySTATUSGenerator
}

// AddIndependentPropertyGeneratorsForUserAssignedIdentityPropertySTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserAssignedIdentityPropertySTATUS(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_UpstreamAuthSettings_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UpstreamAuthSettings to UpstreamAuthSettings via AssignPropertiesToUpstreamAuthSettings & AssignPropertiesFromUpstreamAuthSettings returns original",
		prop.ForAll(RunPropertyAssignmentTestForUpstreamAuthSettings, UpstreamAuthSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUpstreamAuthSettings tests if a specific instance of UpstreamAuthSettings can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForUpstreamAuthSettings(subject UpstreamAuthSettings) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.UpstreamAuthSettings
	err := copied.AssignPropertiesToUpstreamAuthSettings(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UpstreamAuthSettings
	err = actual.AssignPropertiesFromUpstreamAuthSettings(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UpstreamAuthSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UpstreamAuthSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUpstreamAuthSettings, UpstreamAuthSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUpstreamAuthSettings runs a test to see if a specific instance of UpstreamAuthSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForUpstreamAuthSettings(subject UpstreamAuthSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UpstreamAuthSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UpstreamAuthSettings instances for property testing - lazily instantiated by
// UpstreamAuthSettingsGenerator()
var upstreamAuthSettingsGenerator gopter.Gen

// UpstreamAuthSettingsGenerator returns a generator of UpstreamAuthSettings instances for property testing.
// We first initialize upstreamAuthSettingsGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UpstreamAuthSettingsGenerator() gopter.Gen {
	if upstreamAuthSettingsGenerator != nil {
		return upstreamAuthSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpstreamAuthSettings(generators)
	upstreamAuthSettingsGenerator = gen.Struct(reflect.TypeOf(UpstreamAuthSettings{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpstreamAuthSettings(generators)
	AddRelatedPropertyGeneratorsForUpstreamAuthSettings(generators)
	upstreamAuthSettingsGenerator = gen.Struct(reflect.TypeOf(UpstreamAuthSettings{}), generators)

	return upstreamAuthSettingsGenerator
}

// AddIndependentPropertyGeneratorsForUpstreamAuthSettings is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUpstreamAuthSettings(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(UpstreamAuthSettingsType_ManagedIdentity, UpstreamAuthSettingsType_None))
}

// AddRelatedPropertyGeneratorsForUpstreamAuthSettings is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUpstreamAuthSettings(gens map[string]gopter.Gen) {
	gens["ManagedIdentity"] = gen.PtrOf(ManagedIdentitySettingsGenerator())
}

func Test_UpstreamAuthSettings_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UpstreamAuthSettings_STATUS to UpstreamAuthSettings_STATUS via AssignPropertiesToUpstreamAuthSettingsSTATUS & AssignPropertiesFromUpstreamAuthSettingsSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForUpstreamAuthSettingsSTATUS, UpstreamAuthSettingsSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUpstreamAuthSettingsSTATUS tests if a specific instance of UpstreamAuthSettings_STATUS can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForUpstreamAuthSettingsSTATUS(subject UpstreamAuthSettings_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.UpstreamAuthSettings_STATUS
	err := copied.AssignPropertiesToUpstreamAuthSettingsSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UpstreamAuthSettings_STATUS
	err = actual.AssignPropertiesFromUpstreamAuthSettingsSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UpstreamAuthSettings_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UpstreamAuthSettings_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUpstreamAuthSettingsSTATUS, UpstreamAuthSettingsSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUpstreamAuthSettingsSTATUS runs a test to see if a specific instance of UpstreamAuthSettings_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUpstreamAuthSettingsSTATUS(subject UpstreamAuthSettings_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UpstreamAuthSettings_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UpstreamAuthSettings_STATUS instances for property testing - lazily instantiated by
// UpstreamAuthSettingsSTATUSGenerator()
var upstreamAuthSettingsSTATUSGenerator gopter.Gen

// UpstreamAuthSettingsSTATUSGenerator returns a generator of UpstreamAuthSettings_STATUS instances for property testing.
// We first initialize upstreamAuthSettingsSTATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UpstreamAuthSettingsSTATUSGenerator() gopter.Gen {
	if upstreamAuthSettingsSTATUSGenerator != nil {
		return upstreamAuthSettingsSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpstreamAuthSettingsSTATUS(generators)
	upstreamAuthSettingsSTATUSGenerator = gen.Struct(reflect.TypeOf(UpstreamAuthSettings_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpstreamAuthSettingsSTATUS(generators)
	AddRelatedPropertyGeneratorsForUpstreamAuthSettingsSTATUS(generators)
	upstreamAuthSettingsSTATUSGenerator = gen.Struct(reflect.TypeOf(UpstreamAuthSettings_STATUS{}), generators)

	return upstreamAuthSettingsSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForUpstreamAuthSettingsSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUpstreamAuthSettingsSTATUS(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(UpstreamAuthType_STATUS_ManagedIdentity, UpstreamAuthType_STATUS_None))
}

// AddRelatedPropertyGeneratorsForUpstreamAuthSettingsSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUpstreamAuthSettingsSTATUS(gens map[string]gopter.Gen) {
	gens["ManagedIdentity"] = gen.PtrOf(ManagedIdentitySettingsSTATUSGenerator())
}

func Test_ManagedIdentitySettings_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedIdentitySettings to ManagedIdentitySettings via AssignPropertiesToManagedIdentitySettings & AssignPropertiesFromManagedIdentitySettings returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedIdentitySettings, ManagedIdentitySettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedIdentitySettings tests if a specific instance of ManagedIdentitySettings can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForManagedIdentitySettings(subject ManagedIdentitySettings) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ManagedIdentitySettings
	err := copied.AssignPropertiesToManagedIdentitySettings(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedIdentitySettings
	err = actual.AssignPropertiesFromManagedIdentitySettings(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedIdentitySettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedIdentitySettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedIdentitySettings, ManagedIdentitySettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedIdentitySettings runs a test to see if a specific instance of ManagedIdentitySettings round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedIdentitySettings(subject ManagedIdentitySettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedIdentitySettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedIdentitySettings instances for property testing - lazily instantiated by
// ManagedIdentitySettingsGenerator()
var managedIdentitySettingsGenerator gopter.Gen

// ManagedIdentitySettingsGenerator returns a generator of ManagedIdentitySettings instances for property testing.
func ManagedIdentitySettingsGenerator() gopter.Gen {
	if managedIdentitySettingsGenerator != nil {
		return managedIdentitySettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedIdentitySettings(generators)
	managedIdentitySettingsGenerator = gen.Struct(reflect.TypeOf(ManagedIdentitySettings{}), generators)

	return managedIdentitySettingsGenerator
}

// AddIndependentPropertyGeneratorsForManagedIdentitySettings is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedIdentitySettings(gens map[string]gopter.Gen) {
	gens["Resource"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedIdentitySettings_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedIdentitySettings_STATUS to ManagedIdentitySettings_STATUS via AssignPropertiesToManagedIdentitySettingsSTATUS & AssignPropertiesFromManagedIdentitySettingsSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedIdentitySettingsSTATUS, ManagedIdentitySettingsSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedIdentitySettingsSTATUS tests if a specific instance of ManagedIdentitySettings_STATUS can be assigned to v1beta20211001storage and back losslessly
func RunPropertyAssignmentTestForManagedIdentitySettingsSTATUS(subject ManagedIdentitySettings_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20211001s.ManagedIdentitySettings_STATUS
	err := copied.AssignPropertiesToManagedIdentitySettingsSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedIdentitySettings_STATUS
	err = actual.AssignPropertiesFromManagedIdentitySettingsSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedIdentitySettings_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedIdentitySettings_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedIdentitySettingsSTATUS, ManagedIdentitySettingsSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedIdentitySettingsSTATUS runs a test to see if a specific instance of ManagedIdentitySettings_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedIdentitySettingsSTATUS(subject ManagedIdentitySettings_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedIdentitySettings_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedIdentitySettings_STATUS instances for property testing - lazily instantiated by
// ManagedIdentitySettingsSTATUSGenerator()
var managedIdentitySettingsSTATUSGenerator gopter.Gen

// ManagedIdentitySettingsSTATUSGenerator returns a generator of ManagedIdentitySettings_STATUS instances for property testing.
func ManagedIdentitySettingsSTATUSGenerator() gopter.Gen {
	if managedIdentitySettingsSTATUSGenerator != nil {
		return managedIdentitySettingsSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedIdentitySettingsSTATUS(generators)
	managedIdentitySettingsSTATUSGenerator = gen.Struct(reflect.TypeOf(ManagedIdentitySettings_STATUS{}), generators)

	return managedIdentitySettingsSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForManagedIdentitySettingsSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedIdentitySettingsSTATUS(gens map[string]gopter.Gen) {
	gens["Resource"] = gen.PtrOf(gen.AlphaString())
}
