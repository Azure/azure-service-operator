// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20211001

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_SignalR_Spec_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalR_Spec_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalR_Spec_ARM, SignalR_Spec_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalR_Spec_ARM runs a test to see if a specific instance of SignalR_Spec_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalR_Spec_ARM(subject SignalR_Spec_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalR_Spec_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalR_Spec_ARM instances for property testing - lazily instantiated by SignalR_Spec_ARMGenerator()
var signalR_Spec_ARMGenerator gopter.Gen

// SignalR_Spec_ARMGenerator returns a generator of SignalR_Spec_ARM instances for property testing.
// We first initialize signalR_Spec_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SignalR_Spec_ARMGenerator() gopter.Gen {
	if signalR_Spec_ARMGenerator != nil {
		return signalR_Spec_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalR_Spec_ARM(generators)
	signalR_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(SignalR_Spec_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalR_Spec_ARM(generators)
	AddRelatedPropertyGeneratorsForSignalR_Spec_ARM(generators)
	signalR_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(SignalR_Spec_ARM{}), generators)

	return signalR_Spec_ARMGenerator
}

// AddIndependentPropertyGeneratorsForSignalR_Spec_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalR_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(ServiceKind_RawWebSockets, ServiceKind_SignalR))
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSignalR_Spec_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSignalR_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedIdentity_ARMGenerator())
	gens["Properties"] = gen.PtrOf(SignalRProperties_ARMGenerator())
	gens["Sku"] = gen.PtrOf(ResourceSku_ARMGenerator())
}

func Test_ManagedIdentity_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedIdentity_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedIdentity_ARM, ManagedIdentity_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedIdentity_ARM runs a test to see if a specific instance of ManagedIdentity_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedIdentity_ARM(subject ManagedIdentity_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedIdentity_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedIdentity_ARM instances for property testing - lazily instantiated by
// ManagedIdentity_ARMGenerator()
var managedIdentity_ARMGenerator gopter.Gen

// ManagedIdentity_ARMGenerator returns a generator of ManagedIdentity_ARM instances for property testing.
func ManagedIdentity_ARMGenerator() gopter.Gen {
	if managedIdentity_ARMGenerator != nil {
		return managedIdentity_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedIdentity_ARM(generators)
	managedIdentity_ARMGenerator = gen.Struct(reflect.TypeOf(ManagedIdentity_ARM{}), generators)

	return managedIdentity_ARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedIdentity_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedIdentity_ARM(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ManagedIdentityType_None, ManagedIdentityType_SystemAssigned, ManagedIdentityType_UserAssigned))
}

func Test_ResourceSku_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceSku_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceSku_ARM, ResourceSku_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceSku_ARM runs a test to see if a specific instance of ResourceSku_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceSku_ARM(subject ResourceSku_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceSku_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceSku_ARM instances for property testing - lazily instantiated by ResourceSku_ARMGenerator()
var resourceSku_ARMGenerator gopter.Gen

// ResourceSku_ARMGenerator returns a generator of ResourceSku_ARM instances for property testing.
func ResourceSku_ARMGenerator() gopter.Gen {
	if resourceSku_ARMGenerator != nil {
		return resourceSku_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceSku_ARM(generators)
	resourceSku_ARMGenerator = gen.Struct(reflect.TypeOf(ResourceSku_ARM{}), generators)

	return resourceSku_ARMGenerator
}

// AddIndependentPropertyGeneratorsForResourceSku_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceSku_ARM(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(
		SignalRSkuTier_Basic,
		SignalRSkuTier_Free,
		SignalRSkuTier_Premium,
		SignalRSkuTier_Standard))
}

func Test_SignalRProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRProperties_ARM, SignalRProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRProperties_ARM runs a test to see if a specific instance of SignalRProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRProperties_ARM(subject SignalRProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRProperties_ARM instances for property testing - lazily instantiated by
// SignalRProperties_ARMGenerator()
var signalRProperties_ARMGenerator gopter.Gen

// SignalRProperties_ARMGenerator returns a generator of SignalRProperties_ARM instances for property testing.
// We first initialize signalRProperties_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SignalRProperties_ARMGenerator() gopter.Gen {
	if signalRProperties_ARMGenerator != nil {
		return signalRProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRProperties_ARM(generators)
	signalRProperties_ARMGenerator = gen.Struct(reflect.TypeOf(SignalRProperties_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRProperties_ARM(generators)
	AddRelatedPropertyGeneratorsForSignalRProperties_ARM(generators)
	signalRProperties_ARMGenerator = gen.Struct(reflect.TypeOf(SignalRProperties_ARM{}), generators)

	return signalRProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForSignalRProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRProperties_ARM(gens map[string]gopter.Gen) {
	gens["DisableAadAuth"] = gen.PtrOf(gen.Bool())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSignalRProperties_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSignalRProperties_ARM(gens map[string]gopter.Gen) {
	gens["Cors"] = gen.PtrOf(SignalRCorsSettings_ARMGenerator())
	gens["Features"] = gen.SliceOf(SignalRFeature_ARMGenerator())
	gens["NetworkACLs"] = gen.PtrOf(SignalRNetworkACLs_ARMGenerator())
	gens["ResourceLogConfiguration"] = gen.PtrOf(ResourceLogConfiguration_ARMGenerator())
	gens["Tls"] = gen.PtrOf(SignalRTlsSettings_ARMGenerator())
	gens["Upstream"] = gen.PtrOf(ServerlessUpstreamSettings_ARMGenerator())
}

func Test_ResourceLogConfiguration_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceLogConfiguration_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceLogConfiguration_ARM, ResourceLogConfiguration_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceLogConfiguration_ARM runs a test to see if a specific instance of ResourceLogConfiguration_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceLogConfiguration_ARM(subject ResourceLogConfiguration_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceLogConfiguration_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceLogConfiguration_ARM instances for property testing - lazily instantiated by
// ResourceLogConfiguration_ARMGenerator()
var resourceLogConfiguration_ARMGenerator gopter.Gen

// ResourceLogConfiguration_ARMGenerator returns a generator of ResourceLogConfiguration_ARM instances for property testing.
func ResourceLogConfiguration_ARMGenerator() gopter.Gen {
	if resourceLogConfiguration_ARMGenerator != nil {
		return resourceLogConfiguration_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForResourceLogConfiguration_ARM(generators)
	resourceLogConfiguration_ARMGenerator = gen.Struct(reflect.TypeOf(ResourceLogConfiguration_ARM{}), generators)

	return resourceLogConfiguration_ARMGenerator
}

// AddRelatedPropertyGeneratorsForResourceLogConfiguration_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResourceLogConfiguration_ARM(gens map[string]gopter.Gen) {
	gens["Categories"] = gen.SliceOf(ResourceLogCategory_ARMGenerator())
}

func Test_ServerlessUpstreamSettings_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServerlessUpstreamSettings_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServerlessUpstreamSettings_ARM, ServerlessUpstreamSettings_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServerlessUpstreamSettings_ARM runs a test to see if a specific instance of ServerlessUpstreamSettings_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForServerlessUpstreamSettings_ARM(subject ServerlessUpstreamSettings_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServerlessUpstreamSettings_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServerlessUpstreamSettings_ARM instances for property testing - lazily instantiated by
// ServerlessUpstreamSettings_ARMGenerator()
var serverlessUpstreamSettings_ARMGenerator gopter.Gen

// ServerlessUpstreamSettings_ARMGenerator returns a generator of ServerlessUpstreamSettings_ARM instances for property testing.
func ServerlessUpstreamSettings_ARMGenerator() gopter.Gen {
	if serverlessUpstreamSettings_ARMGenerator != nil {
		return serverlessUpstreamSettings_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForServerlessUpstreamSettings_ARM(generators)
	serverlessUpstreamSettings_ARMGenerator = gen.Struct(reflect.TypeOf(ServerlessUpstreamSettings_ARM{}), generators)

	return serverlessUpstreamSettings_ARMGenerator
}

// AddRelatedPropertyGeneratorsForServerlessUpstreamSettings_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForServerlessUpstreamSettings_ARM(gens map[string]gopter.Gen) {
	gens["Templates"] = gen.SliceOf(UpstreamTemplate_ARMGenerator())
}

func Test_SignalRCorsSettings_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRCorsSettings_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRCorsSettings_ARM, SignalRCorsSettings_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRCorsSettings_ARM runs a test to see if a specific instance of SignalRCorsSettings_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRCorsSettings_ARM(subject SignalRCorsSettings_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRCorsSettings_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRCorsSettings_ARM instances for property testing - lazily instantiated by
// SignalRCorsSettings_ARMGenerator()
var signalRCorsSettings_ARMGenerator gopter.Gen

// SignalRCorsSettings_ARMGenerator returns a generator of SignalRCorsSettings_ARM instances for property testing.
func SignalRCorsSettings_ARMGenerator() gopter.Gen {
	if signalRCorsSettings_ARMGenerator != nil {
		return signalRCorsSettings_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRCorsSettings_ARM(generators)
	signalRCorsSettings_ARMGenerator = gen.Struct(reflect.TypeOf(SignalRCorsSettings_ARM{}), generators)

	return signalRCorsSettings_ARMGenerator
}

// AddIndependentPropertyGeneratorsForSignalRCorsSettings_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRCorsSettings_ARM(gens map[string]gopter.Gen) {
	gens["AllowedOrigins"] = gen.SliceOf(gen.AlphaString())
}

func Test_SignalRFeature_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRFeature_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRFeature_ARM, SignalRFeature_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRFeature_ARM runs a test to see if a specific instance of SignalRFeature_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRFeature_ARM(subject SignalRFeature_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRFeature_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRFeature_ARM instances for property testing - lazily instantiated by SignalRFeature_ARMGenerator()
var signalRFeature_ARMGenerator gopter.Gen

// SignalRFeature_ARMGenerator returns a generator of SignalRFeature_ARM instances for property testing.
func SignalRFeature_ARMGenerator() gopter.Gen {
	if signalRFeature_ARMGenerator != nil {
		return signalRFeature_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRFeature_ARM(generators)
	signalRFeature_ARMGenerator = gen.Struct(reflect.TypeOf(SignalRFeature_ARM{}), generators)

	return signalRFeature_ARMGenerator
}

// AddIndependentPropertyGeneratorsForSignalRFeature_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRFeature_ARM(gens map[string]gopter.Gen) {
	gens["Flag"] = gen.PtrOf(gen.OneConstOf(
		FeatureFlags_EnableConnectivityLogs,
		FeatureFlags_EnableLiveTrace,
		FeatureFlags_EnableMessagingLogs,
		FeatureFlags_ServiceMode))
	gens["Properties"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_SignalRNetworkACLs_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRNetworkACLs_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRNetworkACLs_ARM, SignalRNetworkACLs_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRNetworkACLs_ARM runs a test to see if a specific instance of SignalRNetworkACLs_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRNetworkACLs_ARM(subject SignalRNetworkACLs_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRNetworkACLs_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRNetworkACLs_ARM instances for property testing - lazily instantiated by
// SignalRNetworkACLs_ARMGenerator()
var signalRNetworkACLs_ARMGenerator gopter.Gen

// SignalRNetworkACLs_ARMGenerator returns a generator of SignalRNetworkACLs_ARM instances for property testing.
// We first initialize signalRNetworkACLs_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SignalRNetworkACLs_ARMGenerator() gopter.Gen {
	if signalRNetworkACLs_ARMGenerator != nil {
		return signalRNetworkACLs_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRNetworkACLs_ARM(generators)
	signalRNetworkACLs_ARMGenerator = gen.Struct(reflect.TypeOf(SignalRNetworkACLs_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRNetworkACLs_ARM(generators)
	AddRelatedPropertyGeneratorsForSignalRNetworkACLs_ARM(generators)
	signalRNetworkACLs_ARMGenerator = gen.Struct(reflect.TypeOf(SignalRNetworkACLs_ARM{}), generators)

	return signalRNetworkACLs_ARMGenerator
}

// AddIndependentPropertyGeneratorsForSignalRNetworkACLs_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRNetworkACLs_ARM(gens map[string]gopter.Gen) {
	gens["DefaultAction"] = gen.PtrOf(gen.OneConstOf(ACLAction_Allow, ACLAction_Deny))
}

// AddRelatedPropertyGeneratorsForSignalRNetworkACLs_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSignalRNetworkACLs_ARM(gens map[string]gopter.Gen) {
	gens["PrivateEndpoints"] = gen.SliceOf(PrivateEndpointACL_ARMGenerator())
	gens["PublicNetwork"] = gen.PtrOf(NetworkACL_ARMGenerator())
}

func Test_SignalRTlsSettings_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRTlsSettings_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRTlsSettings_ARM, SignalRTlsSettings_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRTlsSettings_ARM runs a test to see if a specific instance of SignalRTlsSettings_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRTlsSettings_ARM(subject SignalRTlsSettings_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRTlsSettings_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRTlsSettings_ARM instances for property testing - lazily instantiated by
// SignalRTlsSettings_ARMGenerator()
var signalRTlsSettings_ARMGenerator gopter.Gen

// SignalRTlsSettings_ARMGenerator returns a generator of SignalRTlsSettings_ARM instances for property testing.
func SignalRTlsSettings_ARMGenerator() gopter.Gen {
	if signalRTlsSettings_ARMGenerator != nil {
		return signalRTlsSettings_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRTlsSettings_ARM(generators)
	signalRTlsSettings_ARMGenerator = gen.Struct(reflect.TypeOf(SignalRTlsSettings_ARM{}), generators)

	return signalRTlsSettings_ARMGenerator
}

// AddIndependentPropertyGeneratorsForSignalRTlsSettings_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRTlsSettings_ARM(gens map[string]gopter.Gen) {
	gens["ClientCertEnabled"] = gen.PtrOf(gen.Bool())
}

func Test_NetworkACL_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkACL_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkACL_ARM, NetworkACL_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkACL_ARM runs a test to see if a specific instance of NetworkACL_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkACL_ARM(subject NetworkACL_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkACL_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkACL_ARM instances for property testing - lazily instantiated by NetworkACL_ARMGenerator()
var networkACL_ARMGenerator gopter.Gen

// NetworkACL_ARMGenerator returns a generator of NetworkACL_ARM instances for property testing.
func NetworkACL_ARMGenerator() gopter.Gen {
	if networkACL_ARMGenerator != nil {
		return networkACL_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkACL_ARM(generators)
	networkACL_ARMGenerator = gen.Struct(reflect.TypeOf(NetworkACL_ARM{}), generators)

	return networkACL_ARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkACL_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkACL_ARM(gens map[string]gopter.Gen) {
	gens["Allow"] = gen.SliceOf(gen.OneConstOf(
		SignalRRequestType_ClientConnection,
		SignalRRequestType_RESTAPI,
		SignalRRequestType_ServerConnection,
		SignalRRequestType_Trace))
	gens["Deny"] = gen.SliceOf(gen.OneConstOf(
		SignalRRequestType_ClientConnection,
		SignalRRequestType_RESTAPI,
		SignalRRequestType_ServerConnection,
		SignalRRequestType_Trace))
}

func Test_PrivateEndpointACL_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointACL_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointACL_ARM, PrivateEndpointACL_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointACL_ARM runs a test to see if a specific instance of PrivateEndpointACL_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointACL_ARM(subject PrivateEndpointACL_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointACL_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointACL_ARM instances for property testing - lazily instantiated by
// PrivateEndpointACL_ARMGenerator()
var privateEndpointACL_ARMGenerator gopter.Gen

// PrivateEndpointACL_ARMGenerator returns a generator of PrivateEndpointACL_ARM instances for property testing.
func PrivateEndpointACL_ARMGenerator() gopter.Gen {
	if privateEndpointACL_ARMGenerator != nil {
		return privateEndpointACL_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointACL_ARM(generators)
	privateEndpointACL_ARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointACL_ARM{}), generators)

	return privateEndpointACL_ARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointACL_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointACL_ARM(gens map[string]gopter.Gen) {
	gens["Allow"] = gen.SliceOf(gen.OneConstOf(
		SignalRRequestType_ClientConnection,
		SignalRRequestType_RESTAPI,
		SignalRRequestType_ServerConnection,
		SignalRRequestType_Trace))
	gens["Deny"] = gen.SliceOf(gen.OneConstOf(
		SignalRRequestType_ClientConnection,
		SignalRRequestType_RESTAPI,
		SignalRRequestType_ServerConnection,
		SignalRRequestType_Trace))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_ResourceLogCategory_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceLogCategory_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceLogCategory_ARM, ResourceLogCategory_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceLogCategory_ARM runs a test to see if a specific instance of ResourceLogCategory_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceLogCategory_ARM(subject ResourceLogCategory_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceLogCategory_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceLogCategory_ARM instances for property testing - lazily instantiated by
// ResourceLogCategory_ARMGenerator()
var resourceLogCategory_ARMGenerator gopter.Gen

// ResourceLogCategory_ARMGenerator returns a generator of ResourceLogCategory_ARM instances for property testing.
func ResourceLogCategory_ARMGenerator() gopter.Gen {
	if resourceLogCategory_ARMGenerator != nil {
		return resourceLogCategory_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceLogCategory_ARM(generators)
	resourceLogCategory_ARMGenerator = gen.Struct(reflect.TypeOf(ResourceLogCategory_ARM{}), generators)

	return resourceLogCategory_ARMGenerator
}

// AddIndependentPropertyGeneratorsForResourceLogCategory_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceLogCategory_ARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_UpstreamTemplate_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UpstreamTemplate_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUpstreamTemplate_ARM, UpstreamTemplate_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUpstreamTemplate_ARM runs a test to see if a specific instance of UpstreamTemplate_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUpstreamTemplate_ARM(subject UpstreamTemplate_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UpstreamTemplate_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UpstreamTemplate_ARM instances for property testing - lazily instantiated by
// UpstreamTemplate_ARMGenerator()
var upstreamTemplate_ARMGenerator gopter.Gen

// UpstreamTemplate_ARMGenerator returns a generator of UpstreamTemplate_ARM instances for property testing.
// We first initialize upstreamTemplate_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UpstreamTemplate_ARMGenerator() gopter.Gen {
	if upstreamTemplate_ARMGenerator != nil {
		return upstreamTemplate_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpstreamTemplate_ARM(generators)
	upstreamTemplate_ARMGenerator = gen.Struct(reflect.TypeOf(UpstreamTemplate_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpstreamTemplate_ARM(generators)
	AddRelatedPropertyGeneratorsForUpstreamTemplate_ARM(generators)
	upstreamTemplate_ARMGenerator = gen.Struct(reflect.TypeOf(UpstreamTemplate_ARM{}), generators)

	return upstreamTemplate_ARMGenerator
}

// AddIndependentPropertyGeneratorsForUpstreamTemplate_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUpstreamTemplate_ARM(gens map[string]gopter.Gen) {
	gens["CategoryPattern"] = gen.PtrOf(gen.AlphaString())
	gens["EventPattern"] = gen.PtrOf(gen.AlphaString())
	gens["HubPattern"] = gen.PtrOf(gen.AlphaString())
	gens["UrlTemplate"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForUpstreamTemplate_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUpstreamTemplate_ARM(gens map[string]gopter.Gen) {
	gens["Auth"] = gen.PtrOf(UpstreamAuthSettings_ARMGenerator())
}

func Test_UpstreamAuthSettings_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UpstreamAuthSettings_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUpstreamAuthSettings_ARM, UpstreamAuthSettings_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUpstreamAuthSettings_ARM runs a test to see if a specific instance of UpstreamAuthSettings_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUpstreamAuthSettings_ARM(subject UpstreamAuthSettings_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UpstreamAuthSettings_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UpstreamAuthSettings_ARM instances for property testing - lazily instantiated by
// UpstreamAuthSettings_ARMGenerator()
var upstreamAuthSettings_ARMGenerator gopter.Gen

// UpstreamAuthSettings_ARMGenerator returns a generator of UpstreamAuthSettings_ARM instances for property testing.
// We first initialize upstreamAuthSettings_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UpstreamAuthSettings_ARMGenerator() gopter.Gen {
	if upstreamAuthSettings_ARMGenerator != nil {
		return upstreamAuthSettings_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpstreamAuthSettings_ARM(generators)
	upstreamAuthSettings_ARMGenerator = gen.Struct(reflect.TypeOf(UpstreamAuthSettings_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpstreamAuthSettings_ARM(generators)
	AddRelatedPropertyGeneratorsForUpstreamAuthSettings_ARM(generators)
	upstreamAuthSettings_ARMGenerator = gen.Struct(reflect.TypeOf(UpstreamAuthSettings_ARM{}), generators)

	return upstreamAuthSettings_ARMGenerator
}

// AddIndependentPropertyGeneratorsForUpstreamAuthSettings_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUpstreamAuthSettings_ARM(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(UpstreamAuthType_ManagedIdentity, UpstreamAuthType_None))
}

// AddRelatedPropertyGeneratorsForUpstreamAuthSettings_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUpstreamAuthSettings_ARM(gens map[string]gopter.Gen) {
	gens["ManagedIdentity"] = gen.PtrOf(ManagedIdentitySettings_ARMGenerator())
}

func Test_ManagedIdentitySettings_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedIdentitySettings_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedIdentitySettings_ARM, ManagedIdentitySettings_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedIdentitySettings_ARM runs a test to see if a specific instance of ManagedIdentitySettings_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedIdentitySettings_ARM(subject ManagedIdentitySettings_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedIdentitySettings_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedIdentitySettings_ARM instances for property testing - lazily instantiated by
// ManagedIdentitySettings_ARMGenerator()
var managedIdentitySettings_ARMGenerator gopter.Gen

// ManagedIdentitySettings_ARMGenerator returns a generator of ManagedIdentitySettings_ARM instances for property testing.
func ManagedIdentitySettings_ARMGenerator() gopter.Gen {
	if managedIdentitySettings_ARMGenerator != nil {
		return managedIdentitySettings_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedIdentitySettings_ARM(generators)
	managedIdentitySettings_ARMGenerator = gen.Struct(reflect.TypeOf(ManagedIdentitySettings_ARM{}), generators)

	return managedIdentitySettings_ARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedIdentitySettings_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedIdentitySettings_ARM(gens map[string]gopter.Gen) {
	gens["Resource"] = gen.PtrOf(gen.AlphaString())
}
