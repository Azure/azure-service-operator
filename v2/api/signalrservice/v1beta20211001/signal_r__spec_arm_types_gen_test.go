// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20211001

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_SignalR_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalR_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRSpecARM, SignalRSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRSpecARM runs a test to see if a specific instance of SignalR_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRSpecARM(subject SignalR_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalR_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalR_SpecARM instances for property testing - lazily instantiated by SignalRSpecARMGenerator()
var signalRSpecARMGenerator gopter.Gen

// SignalRSpecARMGenerator returns a generator of SignalR_SpecARM instances for property testing.
// We first initialize signalRSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SignalRSpecARMGenerator() gopter.Gen {
	if signalRSpecARMGenerator != nil {
		return signalRSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRSpecARM(generators)
	signalRSpecARMGenerator = gen.Struct(reflect.TypeOf(SignalR_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRSpecARM(generators)
	AddRelatedPropertyGeneratorsForSignalRSpecARM(generators)
	signalRSpecARMGenerator = gen.Struct(reflect.TypeOf(SignalR_SpecARM{}), generators)

	return signalRSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForSignalRSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRSpecARM(gens map[string]gopter.Gen) {
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(SignalRSpecKind_RawWebSockets, SignalRSpecKind_SignalR))
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSignalRSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSignalRSpecARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedIdentityARMGenerator())
	gens["Properties"] = gen.PtrOf(SignalRPropertiesARMGenerator())
	gens["Sku"] = gen.PtrOf(ResourceSkuARMGenerator())
}

func Test_ManagedIdentityARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedIdentityARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedIdentityARM, ManagedIdentityARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedIdentityARM runs a test to see if a specific instance of ManagedIdentityARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedIdentityARM(subject ManagedIdentityARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedIdentityARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedIdentityARM instances for property testing - lazily instantiated by ManagedIdentityARMGenerator()
var managedIdentityARMGenerator gopter.Gen

// ManagedIdentityARMGenerator returns a generator of ManagedIdentityARM instances for property testing.
func ManagedIdentityARMGenerator() gopter.Gen {
	if managedIdentityARMGenerator != nil {
		return managedIdentityARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedIdentityARM(generators)
	managedIdentityARMGenerator = gen.Struct(reflect.TypeOf(ManagedIdentityARM{}), generators)

	return managedIdentityARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedIdentityARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedIdentityARM(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ManagedIdentityType_None, ManagedIdentityType_SystemAssigned, ManagedIdentityType_UserAssigned))
}

func Test_ResourceSkuARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceSkuARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceSkuARM, ResourceSkuARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceSkuARM runs a test to see if a specific instance of ResourceSkuARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceSkuARM(subject ResourceSkuARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceSkuARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceSkuARM instances for property testing - lazily instantiated by ResourceSkuARMGenerator()
var resourceSkuARMGenerator gopter.Gen

// ResourceSkuARMGenerator returns a generator of ResourceSkuARM instances for property testing.
func ResourceSkuARMGenerator() gopter.Gen {
	if resourceSkuARMGenerator != nil {
		return resourceSkuARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceSkuARM(generators)
	resourceSkuARMGenerator = gen.Struct(reflect.TypeOf(ResourceSkuARM{}), generators)

	return resourceSkuARMGenerator
}

// AddIndependentPropertyGeneratorsForResourceSkuARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceSkuARM(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(
		ResourceSkuTier_Basic,
		ResourceSkuTier_Free,
		ResourceSkuTier_Premium,
		ResourceSkuTier_Standard))
}

func Test_SignalRPropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRPropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRPropertiesARM, SignalRPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRPropertiesARM runs a test to see if a specific instance of SignalRPropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRPropertiesARM(subject SignalRPropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRPropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRPropertiesARM instances for property testing - lazily instantiated by
// SignalRPropertiesARMGenerator()
var signalRPropertiesARMGenerator gopter.Gen

// SignalRPropertiesARMGenerator returns a generator of SignalRPropertiesARM instances for property testing.
// We first initialize signalRPropertiesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SignalRPropertiesARMGenerator() gopter.Gen {
	if signalRPropertiesARMGenerator != nil {
		return signalRPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRPropertiesARM(generators)
	signalRPropertiesARMGenerator = gen.Struct(reflect.TypeOf(SignalRPropertiesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRPropertiesARM(generators)
	AddRelatedPropertyGeneratorsForSignalRPropertiesARM(generators)
	signalRPropertiesARMGenerator = gen.Struct(reflect.TypeOf(SignalRPropertiesARM{}), generators)

	return signalRPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForSignalRPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRPropertiesARM(gens map[string]gopter.Gen) {
	gens["DisableAadAuth"] = gen.PtrOf(gen.Bool())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSignalRPropertiesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSignalRPropertiesARM(gens map[string]gopter.Gen) {
	gens["Cors"] = gen.PtrOf(SignalRCorsSettingsARMGenerator())
	gens["Features"] = gen.SliceOf(SignalRFeatureARMGenerator())
	gens["NetworkACLs"] = gen.PtrOf(SignalRNetworkACLsARMGenerator())
	gens["ResourceLogConfiguration"] = gen.PtrOf(ResourceLogConfigurationARMGenerator())
	gens["Tls"] = gen.PtrOf(SignalRTlsSettingsARMGenerator())
	gens["Upstream"] = gen.PtrOf(ServerlessUpstreamSettingsARMGenerator())
}

func Test_ResourceLogConfigurationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceLogConfigurationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceLogConfigurationARM, ResourceLogConfigurationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceLogConfigurationARM runs a test to see if a specific instance of ResourceLogConfigurationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceLogConfigurationARM(subject ResourceLogConfigurationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceLogConfigurationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceLogConfigurationARM instances for property testing - lazily instantiated by
// ResourceLogConfigurationARMGenerator()
var resourceLogConfigurationARMGenerator gopter.Gen

// ResourceLogConfigurationARMGenerator returns a generator of ResourceLogConfigurationARM instances for property testing.
func ResourceLogConfigurationARMGenerator() gopter.Gen {
	if resourceLogConfigurationARMGenerator != nil {
		return resourceLogConfigurationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForResourceLogConfigurationARM(generators)
	resourceLogConfigurationARMGenerator = gen.Struct(reflect.TypeOf(ResourceLogConfigurationARM{}), generators)

	return resourceLogConfigurationARMGenerator
}

// AddRelatedPropertyGeneratorsForResourceLogConfigurationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResourceLogConfigurationARM(gens map[string]gopter.Gen) {
	gens["Categories"] = gen.SliceOf(ResourceLogCategoryARMGenerator())
}

func Test_ServerlessUpstreamSettingsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServerlessUpstreamSettingsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServerlessUpstreamSettingsARM, ServerlessUpstreamSettingsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServerlessUpstreamSettingsARM runs a test to see if a specific instance of ServerlessUpstreamSettingsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForServerlessUpstreamSettingsARM(subject ServerlessUpstreamSettingsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServerlessUpstreamSettingsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServerlessUpstreamSettingsARM instances for property testing - lazily instantiated by
// ServerlessUpstreamSettingsARMGenerator()
var serverlessUpstreamSettingsARMGenerator gopter.Gen

// ServerlessUpstreamSettingsARMGenerator returns a generator of ServerlessUpstreamSettingsARM instances for property testing.
func ServerlessUpstreamSettingsARMGenerator() gopter.Gen {
	if serverlessUpstreamSettingsARMGenerator != nil {
		return serverlessUpstreamSettingsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForServerlessUpstreamSettingsARM(generators)
	serverlessUpstreamSettingsARMGenerator = gen.Struct(reflect.TypeOf(ServerlessUpstreamSettingsARM{}), generators)

	return serverlessUpstreamSettingsARMGenerator
}

// AddRelatedPropertyGeneratorsForServerlessUpstreamSettingsARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForServerlessUpstreamSettingsARM(gens map[string]gopter.Gen) {
	gens["Templates"] = gen.SliceOf(UpstreamTemplateARMGenerator())
}

func Test_SignalRCorsSettingsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRCorsSettingsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRCorsSettingsARM, SignalRCorsSettingsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRCorsSettingsARM runs a test to see if a specific instance of SignalRCorsSettingsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRCorsSettingsARM(subject SignalRCorsSettingsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRCorsSettingsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRCorsSettingsARM instances for property testing - lazily instantiated by
// SignalRCorsSettingsARMGenerator()
var signalRCorsSettingsARMGenerator gopter.Gen

// SignalRCorsSettingsARMGenerator returns a generator of SignalRCorsSettingsARM instances for property testing.
func SignalRCorsSettingsARMGenerator() gopter.Gen {
	if signalRCorsSettingsARMGenerator != nil {
		return signalRCorsSettingsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRCorsSettingsARM(generators)
	signalRCorsSettingsARMGenerator = gen.Struct(reflect.TypeOf(SignalRCorsSettingsARM{}), generators)

	return signalRCorsSettingsARMGenerator
}

// AddIndependentPropertyGeneratorsForSignalRCorsSettingsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRCorsSettingsARM(gens map[string]gopter.Gen) {
	gens["AllowedOrigins"] = gen.SliceOf(gen.AlphaString())
}

func Test_SignalRFeatureARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRFeatureARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRFeatureARM, SignalRFeatureARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRFeatureARM runs a test to see if a specific instance of SignalRFeatureARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRFeatureARM(subject SignalRFeatureARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRFeatureARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRFeatureARM instances for property testing - lazily instantiated by SignalRFeatureARMGenerator()
var signalRFeatureARMGenerator gopter.Gen

// SignalRFeatureARMGenerator returns a generator of SignalRFeatureARM instances for property testing.
func SignalRFeatureARMGenerator() gopter.Gen {
	if signalRFeatureARMGenerator != nil {
		return signalRFeatureARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRFeatureARM(generators)
	signalRFeatureARMGenerator = gen.Struct(reflect.TypeOf(SignalRFeatureARM{}), generators)

	return signalRFeatureARMGenerator
}

// AddIndependentPropertyGeneratorsForSignalRFeatureARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRFeatureARM(gens map[string]gopter.Gen) {
	gens["Flag"] = gen.PtrOf(gen.OneConstOf(
		SignalRFeatureFlag_EnableConnectivityLogs,
		SignalRFeatureFlag_EnableLiveTrace,
		SignalRFeatureFlag_EnableMessagingLogs,
		SignalRFeatureFlag_ServiceMode))
	gens["Properties"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_SignalRNetworkACLsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRNetworkACLsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRNetworkACLsARM, SignalRNetworkACLsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRNetworkACLsARM runs a test to see if a specific instance of SignalRNetworkACLsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRNetworkACLsARM(subject SignalRNetworkACLsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRNetworkACLsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRNetworkACLsARM instances for property testing - lazily instantiated by
// SignalRNetworkACLsARMGenerator()
var signalRNetworkACLsARMGenerator gopter.Gen

// SignalRNetworkACLsARMGenerator returns a generator of SignalRNetworkACLsARM instances for property testing.
// We first initialize signalRNetworkACLsARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SignalRNetworkACLsARMGenerator() gopter.Gen {
	if signalRNetworkACLsARMGenerator != nil {
		return signalRNetworkACLsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRNetworkACLsARM(generators)
	signalRNetworkACLsARMGenerator = gen.Struct(reflect.TypeOf(SignalRNetworkACLsARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRNetworkACLsARM(generators)
	AddRelatedPropertyGeneratorsForSignalRNetworkACLsARM(generators)
	signalRNetworkACLsARMGenerator = gen.Struct(reflect.TypeOf(SignalRNetworkACLsARM{}), generators)

	return signalRNetworkACLsARMGenerator
}

// AddIndependentPropertyGeneratorsForSignalRNetworkACLsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRNetworkACLsARM(gens map[string]gopter.Gen) {
	gens["DefaultAction"] = gen.PtrOf(gen.OneConstOf(SignalRNetworkACLsDefaultAction_Allow, SignalRNetworkACLsDefaultAction_Deny))
}

// AddRelatedPropertyGeneratorsForSignalRNetworkACLsARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSignalRNetworkACLsARM(gens map[string]gopter.Gen) {
	gens["PrivateEndpoints"] = gen.SliceOf(PrivateEndpointACLARMGenerator())
	gens["PublicNetwork"] = gen.PtrOf(NetworkACLARMGenerator())
}

func Test_SignalRTlsSettingsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SignalRTlsSettingsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSignalRTlsSettingsARM, SignalRTlsSettingsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSignalRTlsSettingsARM runs a test to see if a specific instance of SignalRTlsSettingsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSignalRTlsSettingsARM(subject SignalRTlsSettingsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SignalRTlsSettingsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SignalRTlsSettingsARM instances for property testing - lazily instantiated by
// SignalRTlsSettingsARMGenerator()
var signalRTlsSettingsARMGenerator gopter.Gen

// SignalRTlsSettingsARMGenerator returns a generator of SignalRTlsSettingsARM instances for property testing.
func SignalRTlsSettingsARMGenerator() gopter.Gen {
	if signalRTlsSettingsARMGenerator != nil {
		return signalRTlsSettingsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSignalRTlsSettingsARM(generators)
	signalRTlsSettingsARMGenerator = gen.Struct(reflect.TypeOf(SignalRTlsSettingsARM{}), generators)

	return signalRTlsSettingsARMGenerator
}

// AddIndependentPropertyGeneratorsForSignalRTlsSettingsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSignalRTlsSettingsARM(gens map[string]gopter.Gen) {
	gens["ClientCertEnabled"] = gen.PtrOf(gen.Bool())
}

func Test_NetworkACLARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkACLARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkACLARM, NetworkACLARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkACLARM runs a test to see if a specific instance of NetworkACLARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkACLARM(subject NetworkACLARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkACLARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkACLARM instances for property testing - lazily instantiated by NetworkACLARMGenerator()
var networkACLARMGenerator gopter.Gen

// NetworkACLARMGenerator returns a generator of NetworkACLARM instances for property testing.
func NetworkACLARMGenerator() gopter.Gen {
	if networkACLARMGenerator != nil {
		return networkACLARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkACLARM(generators)
	networkACLARMGenerator = gen.Struct(reflect.TypeOf(NetworkACLARM{}), generators)

	return networkACLARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkACLARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkACLARM(gens map[string]gopter.Gen) {
	gens["Allow"] = gen.SliceOf(gen.OneConstOf(
		NetworkACLAllow_ClientConnection,
		NetworkACLAllow_RESTAPI,
		NetworkACLAllow_ServerConnection,
		NetworkACLAllow_Trace))
	gens["Deny"] = gen.SliceOf(gen.OneConstOf(
		NetworkACLDeny_ClientConnection,
		NetworkACLDeny_RESTAPI,
		NetworkACLDeny_ServerConnection,
		NetworkACLDeny_Trace))
}

func Test_PrivateEndpointACLARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointACLARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointACLARM, PrivateEndpointACLARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointACLARM runs a test to see if a specific instance of PrivateEndpointACLARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointACLARM(subject PrivateEndpointACLARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointACLARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointACLARM instances for property testing - lazily instantiated by
// PrivateEndpointACLARMGenerator()
var privateEndpointACLARMGenerator gopter.Gen

// PrivateEndpointACLARMGenerator returns a generator of PrivateEndpointACLARM instances for property testing.
func PrivateEndpointACLARMGenerator() gopter.Gen {
	if privateEndpointACLARMGenerator != nil {
		return privateEndpointACLARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointACLARM(generators)
	privateEndpointACLARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointACLARM{}), generators)

	return privateEndpointACLARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointACLARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointACLARM(gens map[string]gopter.Gen) {
	gens["Allow"] = gen.SliceOf(gen.OneConstOf(
		PrivateEndpointACLAllow_ClientConnection,
		PrivateEndpointACLAllow_RESTAPI,
		PrivateEndpointACLAllow_ServerConnection,
		PrivateEndpointACLAllow_Trace))
	gens["Deny"] = gen.SliceOf(gen.OneConstOf(
		PrivateEndpointACLDeny_ClientConnection,
		PrivateEndpointACLDeny_RESTAPI,
		PrivateEndpointACLDeny_ServerConnection,
		PrivateEndpointACLDeny_Trace))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_ResourceLogCategoryARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceLogCategoryARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceLogCategoryARM, ResourceLogCategoryARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceLogCategoryARM runs a test to see if a specific instance of ResourceLogCategoryARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceLogCategoryARM(subject ResourceLogCategoryARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceLogCategoryARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceLogCategoryARM instances for property testing - lazily instantiated by
// ResourceLogCategoryARMGenerator()
var resourceLogCategoryARMGenerator gopter.Gen

// ResourceLogCategoryARMGenerator returns a generator of ResourceLogCategoryARM instances for property testing.
func ResourceLogCategoryARMGenerator() gopter.Gen {
	if resourceLogCategoryARMGenerator != nil {
		return resourceLogCategoryARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceLogCategoryARM(generators)
	resourceLogCategoryARMGenerator = gen.Struct(reflect.TypeOf(ResourceLogCategoryARM{}), generators)

	return resourceLogCategoryARMGenerator
}

// AddIndependentPropertyGeneratorsForResourceLogCategoryARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceLogCategoryARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_UpstreamTemplateARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UpstreamTemplateARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUpstreamTemplateARM, UpstreamTemplateARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUpstreamTemplateARM runs a test to see if a specific instance of UpstreamTemplateARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUpstreamTemplateARM(subject UpstreamTemplateARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UpstreamTemplateARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UpstreamTemplateARM instances for property testing - lazily instantiated by
// UpstreamTemplateARMGenerator()
var upstreamTemplateARMGenerator gopter.Gen

// UpstreamTemplateARMGenerator returns a generator of UpstreamTemplateARM instances for property testing.
// We first initialize upstreamTemplateARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UpstreamTemplateARMGenerator() gopter.Gen {
	if upstreamTemplateARMGenerator != nil {
		return upstreamTemplateARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpstreamTemplateARM(generators)
	upstreamTemplateARMGenerator = gen.Struct(reflect.TypeOf(UpstreamTemplateARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpstreamTemplateARM(generators)
	AddRelatedPropertyGeneratorsForUpstreamTemplateARM(generators)
	upstreamTemplateARMGenerator = gen.Struct(reflect.TypeOf(UpstreamTemplateARM{}), generators)

	return upstreamTemplateARMGenerator
}

// AddIndependentPropertyGeneratorsForUpstreamTemplateARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUpstreamTemplateARM(gens map[string]gopter.Gen) {
	gens["CategoryPattern"] = gen.PtrOf(gen.AlphaString())
	gens["EventPattern"] = gen.PtrOf(gen.AlphaString())
	gens["HubPattern"] = gen.PtrOf(gen.AlphaString())
	gens["UrlTemplate"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForUpstreamTemplateARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUpstreamTemplateARM(gens map[string]gopter.Gen) {
	gens["Auth"] = gen.PtrOf(UpstreamAuthSettingsARMGenerator())
}

func Test_UpstreamAuthSettingsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UpstreamAuthSettingsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUpstreamAuthSettingsARM, UpstreamAuthSettingsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUpstreamAuthSettingsARM runs a test to see if a specific instance of UpstreamAuthSettingsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUpstreamAuthSettingsARM(subject UpstreamAuthSettingsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UpstreamAuthSettingsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UpstreamAuthSettingsARM instances for property testing - lazily instantiated by
// UpstreamAuthSettingsARMGenerator()
var upstreamAuthSettingsARMGenerator gopter.Gen

// UpstreamAuthSettingsARMGenerator returns a generator of UpstreamAuthSettingsARM instances for property testing.
// We first initialize upstreamAuthSettingsARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UpstreamAuthSettingsARMGenerator() gopter.Gen {
	if upstreamAuthSettingsARMGenerator != nil {
		return upstreamAuthSettingsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpstreamAuthSettingsARM(generators)
	upstreamAuthSettingsARMGenerator = gen.Struct(reflect.TypeOf(UpstreamAuthSettingsARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpstreamAuthSettingsARM(generators)
	AddRelatedPropertyGeneratorsForUpstreamAuthSettingsARM(generators)
	upstreamAuthSettingsARMGenerator = gen.Struct(reflect.TypeOf(UpstreamAuthSettingsARM{}), generators)

	return upstreamAuthSettingsARMGenerator
}

// AddIndependentPropertyGeneratorsForUpstreamAuthSettingsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUpstreamAuthSettingsARM(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(UpstreamAuthSettingsType_ManagedIdentity, UpstreamAuthSettingsType_None))
}

// AddRelatedPropertyGeneratorsForUpstreamAuthSettingsARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUpstreamAuthSettingsARM(gens map[string]gopter.Gen) {
	gens["ManagedIdentity"] = gen.PtrOf(ManagedIdentitySettingsARMGenerator())
}

func Test_ManagedIdentitySettingsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedIdentitySettingsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedIdentitySettingsARM, ManagedIdentitySettingsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedIdentitySettingsARM runs a test to see if a specific instance of ManagedIdentitySettingsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedIdentitySettingsARM(subject ManagedIdentitySettingsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedIdentitySettingsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedIdentitySettingsARM instances for property testing - lazily instantiated by
// ManagedIdentitySettingsARMGenerator()
var managedIdentitySettingsARMGenerator gopter.Gen

// ManagedIdentitySettingsARMGenerator returns a generator of ManagedIdentitySettingsARM instances for property testing.
func ManagedIdentitySettingsARMGenerator() gopter.Gen {
	if managedIdentitySettingsARMGenerator != nil {
		return managedIdentitySettingsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedIdentitySettingsARM(generators)
	managedIdentitySettingsARMGenerator = gen.Struct(reflect.TypeOf(ManagedIdentitySettingsARM{}), generators)

	return managedIdentitySettingsARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedIdentitySettingsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedIdentitySettingsARM(gens map[string]gopter.Gen) {
	gens["Resource"] = gen.PtrOf(gen.AlphaString())
}
