// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20220301

import (
	"encoding/json"
	v20220301s "github.com/Azure/azure-service-operator/v2/api/web/v1api20220301/storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_Site_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	parameters.MinSuccessfulTests = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Site to hub returns original",
		prop.ForAll(RunResourceConversionTestForSite, SiteGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForSite tests if a specific instance of Site round trips to the hub storage version and back losslessly
func RunResourceConversionTestForSite(subject Site) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v20220301s.Site
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual Site
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Site_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Site to Site via AssignProperties_To_Site & AssignProperties_From_Site returns original",
		prop.ForAll(RunPropertyAssignmentTestForSite, SiteGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSite tests if a specific instance of Site can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSite(subject Site) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.Site
	err := copied.AssignProperties_To_Site(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Site
	err = actual.AssignProperties_From_Site(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Site_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Site via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSite, SiteGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSite runs a test to see if a specific instance of Site round trips to JSON and back losslessly
func RunJSONSerializationTestForSite(subject Site) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Site
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Site instances for property testing - lazily instantiated by SiteGenerator()
var siteGenerator gopter.Gen

// SiteGenerator returns a generator of Site instances for property testing.
func SiteGenerator() gopter.Gen {
	if siteGenerator != nil {
		return siteGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForSite(generators)
	siteGenerator = gen.Struct(reflect.TypeOf(Site{}), generators)

	return siteGenerator
}

// AddRelatedPropertyGeneratorsForSite is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSite(gens map[string]gopter.Gen) {
	gens["Spec"] = Site_SpecGenerator()
	gens["Status"] = Site_STATUSGenerator()
}

func Test_Site_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Site_Spec to Site_Spec via AssignProperties_To_Site_Spec & AssignProperties_From_Site_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForSite_Spec, Site_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSite_Spec tests if a specific instance of Site_Spec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSite_Spec(subject Site_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.Site_Spec
	err := copied.AssignProperties_To_Site_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Site_Spec
	err = actual.AssignProperties_From_Site_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Site_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Site_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSite_Spec, Site_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSite_Spec runs a test to see if a specific instance of Site_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForSite_Spec(subject Site_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Site_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Site_Spec instances for property testing - lazily instantiated by Site_SpecGenerator()
var site_SpecGenerator gopter.Gen

// Site_SpecGenerator returns a generator of Site_Spec instances for property testing.
// We first initialize site_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Site_SpecGenerator() gopter.Gen {
	if site_SpecGenerator != nil {
		return site_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSite_Spec(generators)
	site_SpecGenerator = gen.Struct(reflect.TypeOf(Site_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSite_Spec(generators)
	AddRelatedPropertyGeneratorsForSite_Spec(generators)
	site_SpecGenerator = gen.Struct(reflect.TypeOf(Site_Spec{}), generators)

	return site_SpecGenerator
}

// AddIndependentPropertyGeneratorsForSite_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSite_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["ClientAffinityEnabled"] = gen.PtrOf(gen.Bool())
	gens["ClientCertEnabled"] = gen.PtrOf(gen.Bool())
	gens["ClientCertExclusionPaths"] = gen.PtrOf(gen.AlphaString())
	gens["ClientCertMode"] = gen.PtrOf(gen.OneConstOf(Site_Properties_ClientCertMode_Spec_Optional, Site_Properties_ClientCertMode_Spec_OptionalInteractiveUser, Site_Properties_ClientCertMode_Spec_Required))
	gens["ContainerSize"] = gen.PtrOf(gen.Int())
	gens["CustomDomainVerificationId"] = gen.PtrOf(gen.AlphaString())
	gens["DailyMemoryTimeQuota"] = gen.PtrOf(gen.Int())
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["HostNamesDisabled"] = gen.PtrOf(gen.Bool())
	gens["HttpsOnly"] = gen.PtrOf(gen.Bool())
	gens["HyperV"] = gen.PtrOf(gen.Bool())
	gens["IsXenon"] = gen.PtrOf(gen.Bool())
	gens["KeyVaultReferenceIdentity"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.AlphaString())
	gens["RedundancyMode"] = gen.PtrOf(gen.OneConstOf(
		Site_Properties_RedundancyMode_Spec_ActiveActive,
		Site_Properties_RedundancyMode_Spec_Failover,
		Site_Properties_RedundancyMode_Spec_GeoRedundant,
		Site_Properties_RedundancyMode_Spec_Manual,
		Site_Properties_RedundancyMode_Spec_None))
	gens["Reserved"] = gen.PtrOf(gen.Bool())
	gens["ScmSiteAlsoStopped"] = gen.PtrOf(gen.Bool())
	gens["StorageAccountRequired"] = gen.PtrOf(gen.Bool())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["VnetContentShareEnabled"] = gen.PtrOf(gen.Bool())
	gens["VnetImagePullEnabled"] = gen.PtrOf(gen.Bool())
	gens["VnetRouteAllEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForSite_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSite_Spec(gens map[string]gopter.Gen) {
	gens["CloningInfo"] = gen.PtrOf(CloningInfoGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationGenerator())
	gens["HostNameSslStates"] = gen.SliceOf(HostNameSslStateGenerator())
	gens["HostingEnvironmentProfile"] = gen.PtrOf(HostingEnvironmentProfileGenerator())
	gens["Identity"] = gen.PtrOf(ManagedServiceIdentityGenerator())
	gens["SiteConfig"] = gen.PtrOf(SiteConfigGenerator())
}

func Test_Site_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Site_STATUS to Site_STATUS via AssignProperties_To_Site_STATUS & AssignProperties_From_Site_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSite_STATUS, Site_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSite_STATUS tests if a specific instance of Site_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSite_STATUS(subject Site_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.Site_STATUS
	err := copied.AssignProperties_To_Site_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Site_STATUS
	err = actual.AssignProperties_From_Site_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Site_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Site_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSite_STATUS, Site_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSite_STATUS runs a test to see if a specific instance of Site_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSite_STATUS(subject Site_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Site_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Site_STATUS instances for property testing - lazily instantiated by Site_STATUSGenerator()
var site_STATUSGenerator gopter.Gen

// Site_STATUSGenerator returns a generator of Site_STATUS instances for property testing.
func Site_STATUSGenerator() gopter.Gen {
	if site_STATUSGenerator != nil {
		return site_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForSite_STATUS(generators)
	site_STATUSGenerator = gen.Struct(reflect.TypeOf(Site_STATUS{}), generators)

	return site_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForSite_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSite_STATUS(gens map[string]gopter.Gen) {
	gens["CloningInfo"] = gen.PtrOf(CloningInfo_STATUSGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_STATUSGenerator())
	gens["HostNameSslStates"] = gen.SliceOf(HostNameSslState_STATUSGenerator())
	gens["HostingEnvironmentProfile"] = gen.PtrOf(HostingEnvironmentProfile_STATUSGenerator())
	gens["Identity"] = gen.PtrOf(ManagedServiceIdentity_STATUSGenerator())
	gens["SiteConfig"] = gen.PtrOf(SiteConfig_STATUSGenerator())
	gens["SlotSwapStatus"] = gen.PtrOf(SlotSwapStatus_STATUSGenerator())
}

func Test_CloningInfo_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CloningInfo to CloningInfo via AssignProperties_To_CloningInfo & AssignProperties_From_CloningInfo returns original",
		prop.ForAll(RunPropertyAssignmentTestForCloningInfo, CloningInfoGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCloningInfo tests if a specific instance of CloningInfo can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForCloningInfo(subject CloningInfo) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.CloningInfo
	err := copied.AssignProperties_To_CloningInfo(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CloningInfo
	err = actual.AssignProperties_From_CloningInfo(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CloningInfo_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CloningInfo via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCloningInfo, CloningInfoGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCloningInfo runs a test to see if a specific instance of CloningInfo round trips to JSON and back losslessly
func RunJSONSerializationTestForCloningInfo(subject CloningInfo) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CloningInfo
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CloningInfo instances for property testing - lazily instantiated by CloningInfoGenerator()
var cloningInfoGenerator gopter.Gen

// CloningInfoGenerator returns a generator of CloningInfo instances for property testing.
func CloningInfoGenerator() gopter.Gen {
	if cloningInfoGenerator != nil {
		return cloningInfoGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCloningInfo(generators)
	cloningInfoGenerator = gen.Struct(reflect.TypeOf(CloningInfo{}), generators)

	return cloningInfoGenerator
}

// AddIndependentPropertyGeneratorsForCloningInfo is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCloningInfo(gens map[string]gopter.Gen) {
	gens["AppSettingsOverrides"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["CloneCustomHostNames"] = gen.PtrOf(gen.Bool())
	gens["CloneSourceControl"] = gen.PtrOf(gen.Bool())
	gens["ConfigureLoadBalancing"] = gen.PtrOf(gen.Bool())
	gens["CorrelationId"] = gen.PtrOf(gen.AlphaString())
	gens["HostingEnvironment"] = gen.PtrOf(gen.AlphaString())
	gens["Overwrite"] = gen.PtrOf(gen.Bool())
	gens["SourceWebAppLocation"] = gen.PtrOf(gen.AlphaString())
	gens["TrafficManagerProfileName"] = gen.PtrOf(gen.AlphaString())
}

func Test_CloningInfo_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CloningInfo_STATUS to CloningInfo_STATUS via AssignProperties_To_CloningInfo_STATUS & AssignProperties_From_CloningInfo_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForCloningInfo_STATUS, CloningInfo_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCloningInfo_STATUS tests if a specific instance of CloningInfo_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForCloningInfo_STATUS(subject CloningInfo_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.CloningInfo_STATUS
	err := copied.AssignProperties_To_CloningInfo_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CloningInfo_STATUS
	err = actual.AssignProperties_From_CloningInfo_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CloningInfo_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CloningInfo_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCloningInfo_STATUS, CloningInfo_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCloningInfo_STATUS runs a test to see if a specific instance of CloningInfo_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForCloningInfo_STATUS(subject CloningInfo_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CloningInfo_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CloningInfo_STATUS instances for property testing - lazily instantiated by CloningInfo_STATUSGenerator()
var cloningInfo_STATUSGenerator gopter.Gen

// CloningInfo_STATUSGenerator returns a generator of CloningInfo_STATUS instances for property testing.
func CloningInfo_STATUSGenerator() gopter.Gen {
	if cloningInfo_STATUSGenerator != nil {
		return cloningInfo_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCloningInfo_STATUS(generators)
	cloningInfo_STATUSGenerator = gen.Struct(reflect.TypeOf(CloningInfo_STATUS{}), generators)

	return cloningInfo_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForCloningInfo_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCloningInfo_STATUS(gens map[string]gopter.Gen) {
	gens["AppSettingsOverrides"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["CloneCustomHostNames"] = gen.PtrOf(gen.Bool())
	gens["CloneSourceControl"] = gen.PtrOf(gen.Bool())
	gens["ConfigureLoadBalancing"] = gen.PtrOf(gen.Bool())
	gens["CorrelationId"] = gen.PtrOf(gen.AlphaString())
	gens["HostingEnvironment"] = gen.PtrOf(gen.AlphaString())
	gens["Overwrite"] = gen.PtrOf(gen.Bool())
	gens["SourceWebAppId"] = gen.PtrOf(gen.AlphaString())
	gens["SourceWebAppLocation"] = gen.PtrOf(gen.AlphaString())
	gens["TrafficManagerProfileId"] = gen.PtrOf(gen.AlphaString())
	gens["TrafficManagerProfileName"] = gen.PtrOf(gen.AlphaString())
}

func Test_HostNameSslState_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HostNameSslState to HostNameSslState via AssignProperties_To_HostNameSslState & AssignProperties_From_HostNameSslState returns original",
		prop.ForAll(RunPropertyAssignmentTestForHostNameSslState, HostNameSslStateGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHostNameSslState tests if a specific instance of HostNameSslState can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForHostNameSslState(subject HostNameSslState) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.HostNameSslState
	err := copied.AssignProperties_To_HostNameSslState(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HostNameSslState
	err = actual.AssignProperties_From_HostNameSslState(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HostNameSslState_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HostNameSslState via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHostNameSslState, HostNameSslStateGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHostNameSslState runs a test to see if a specific instance of HostNameSslState round trips to JSON and back losslessly
func RunJSONSerializationTestForHostNameSslState(subject HostNameSslState) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HostNameSslState
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HostNameSslState instances for property testing - lazily instantiated by HostNameSslStateGenerator()
var hostNameSslStateGenerator gopter.Gen

// HostNameSslStateGenerator returns a generator of HostNameSslState instances for property testing.
func HostNameSslStateGenerator() gopter.Gen {
	if hostNameSslStateGenerator != nil {
		return hostNameSslStateGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHostNameSslState(generators)
	hostNameSslStateGenerator = gen.Struct(reflect.TypeOf(HostNameSslState{}), generators)

	return hostNameSslStateGenerator
}

// AddIndependentPropertyGeneratorsForHostNameSslState is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHostNameSslState(gens map[string]gopter.Gen) {
	gens["HostType"] = gen.PtrOf(gen.OneConstOf(HostNameSslState_HostType_Repository, HostNameSslState_HostType_Standard))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["SslState"] = gen.PtrOf(gen.OneConstOf(HostNameSslState_SslState_Disabled, HostNameSslState_SslState_IpBasedEnabled, HostNameSslState_SslState_SniEnabled))
	gens["Thumbprint"] = gen.PtrOf(gen.AlphaString())
	gens["ToUpdate"] = gen.PtrOf(gen.Bool())
	gens["VirtualIP"] = gen.PtrOf(gen.AlphaString())
}

func Test_HostNameSslState_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HostNameSslState_STATUS to HostNameSslState_STATUS via AssignProperties_To_HostNameSslState_STATUS & AssignProperties_From_HostNameSslState_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForHostNameSslState_STATUS, HostNameSslState_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHostNameSslState_STATUS tests if a specific instance of HostNameSslState_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForHostNameSslState_STATUS(subject HostNameSslState_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.HostNameSslState_STATUS
	err := copied.AssignProperties_To_HostNameSslState_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HostNameSslState_STATUS
	err = actual.AssignProperties_From_HostNameSslState_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HostNameSslState_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HostNameSslState_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHostNameSslState_STATUS, HostNameSslState_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHostNameSslState_STATUS runs a test to see if a specific instance of HostNameSslState_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForHostNameSslState_STATUS(subject HostNameSslState_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HostNameSslState_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HostNameSslState_STATUS instances for property testing - lazily instantiated by
// HostNameSslState_STATUSGenerator()
var hostNameSslState_STATUSGenerator gopter.Gen

// HostNameSslState_STATUSGenerator returns a generator of HostNameSslState_STATUS instances for property testing.
func HostNameSslState_STATUSGenerator() gopter.Gen {
	if hostNameSslState_STATUSGenerator != nil {
		return hostNameSslState_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHostNameSslState_STATUS(generators)
	hostNameSslState_STATUSGenerator = gen.Struct(reflect.TypeOf(HostNameSslState_STATUS{}), generators)

	return hostNameSslState_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForHostNameSslState_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHostNameSslState_STATUS(gens map[string]gopter.Gen) {
	gens["HostType"] = gen.PtrOf(gen.OneConstOf(HostNameSslState_HostType_STATUS_Repository, HostNameSslState_HostType_STATUS_Standard))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["SslState"] = gen.PtrOf(gen.OneConstOf(HostNameSslState_SslState_STATUS_Disabled, HostNameSslState_SslState_STATUS_IpBasedEnabled, HostNameSslState_SslState_STATUS_SniEnabled))
	gens["Thumbprint"] = gen.PtrOf(gen.AlphaString())
	gens["ToUpdate"] = gen.PtrOf(gen.Bool())
	gens["VirtualIP"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedServiceIdentity_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedServiceIdentity to ManagedServiceIdentity via AssignProperties_To_ManagedServiceIdentity & AssignProperties_From_ManagedServiceIdentity returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedServiceIdentity, ManagedServiceIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedServiceIdentity tests if a specific instance of ManagedServiceIdentity can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedServiceIdentity(subject ManagedServiceIdentity) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.ManagedServiceIdentity
	err := copied.AssignProperties_To_ManagedServiceIdentity(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedServiceIdentity
	err = actual.AssignProperties_From_ManagedServiceIdentity(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedServiceIdentity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentity, ManagedServiceIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentity runs a test to see if a specific instance of ManagedServiceIdentity round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentity(subject ManagedServiceIdentity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity instances for property testing - lazily instantiated by
// ManagedServiceIdentityGenerator()
var managedServiceIdentityGenerator gopter.Gen

// ManagedServiceIdentityGenerator returns a generator of ManagedServiceIdentity instances for property testing.
// We first initialize managedServiceIdentityGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedServiceIdentityGenerator() gopter.Gen {
	if managedServiceIdentityGenerator != nil {
		return managedServiceIdentityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity(generators)
	managedServiceIdentityGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity(generators)
	AddRelatedPropertyGeneratorsForManagedServiceIdentity(generators)
	managedServiceIdentityGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity{}), generators)

	return managedServiceIdentityGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentity is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentity(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ManagedServiceIdentity_Type_None,
		ManagedServiceIdentity_Type_SystemAssigned,
		ManagedServiceIdentity_Type_SystemAssignedUserAssigned,
		ManagedServiceIdentity_Type_UserAssigned))
}

// AddRelatedPropertyGeneratorsForManagedServiceIdentity is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedServiceIdentity(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.SliceOf(UserAssignedIdentityDetailsGenerator())
}

func Test_ManagedServiceIdentity_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedServiceIdentity_STATUS to ManagedServiceIdentity_STATUS via AssignProperties_To_ManagedServiceIdentity_STATUS & AssignProperties_From_ManagedServiceIdentity_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedServiceIdentity_STATUS, ManagedServiceIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedServiceIdentity_STATUS tests if a specific instance of ManagedServiceIdentity_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedServiceIdentity_STATUS(subject ManagedServiceIdentity_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.ManagedServiceIdentity_STATUS
	err := copied.AssignProperties_To_ManagedServiceIdentity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedServiceIdentity_STATUS
	err = actual.AssignProperties_From_ManagedServiceIdentity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedServiceIdentity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentity_STATUS, ManagedServiceIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentity_STATUS runs a test to see if a specific instance of ManagedServiceIdentity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentity_STATUS(subject ManagedServiceIdentity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity_STATUS instances for property testing - lazily instantiated by
// ManagedServiceIdentity_STATUSGenerator()
var managedServiceIdentity_STATUSGenerator gopter.Gen

// ManagedServiceIdentity_STATUSGenerator returns a generator of ManagedServiceIdentity_STATUS instances for property testing.
// We first initialize managedServiceIdentity_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedServiceIdentity_STATUSGenerator() gopter.Gen {
	if managedServiceIdentity_STATUSGenerator != nil {
		return managedServiceIdentity_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity_STATUS(generators)
	managedServiceIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity_STATUS(generators)
	AddRelatedPropertyGeneratorsForManagedServiceIdentity_STATUS(generators)
	managedServiceIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_STATUS{}), generators)

	return managedServiceIdentity_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentity_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ManagedServiceIdentity_Type_STATUS_None,
		ManagedServiceIdentity_Type_STATUS_SystemAssigned,
		ManagedServiceIdentity_Type_STATUS_SystemAssignedUserAssigned,
		ManagedServiceIdentity_Type_STATUS_UserAssigned))
}

// AddRelatedPropertyGeneratorsForManagedServiceIdentity_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedServiceIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), UserAssignedIdentity_STATUSGenerator())
}

func Test_SiteConfig_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SiteConfig to SiteConfig via AssignProperties_To_SiteConfig & AssignProperties_From_SiteConfig returns original",
		prop.ForAll(RunPropertyAssignmentTestForSiteConfig, SiteConfigGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSiteConfig tests if a specific instance of SiteConfig can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSiteConfig(subject SiteConfig) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.SiteConfig
	err := copied.AssignProperties_To_SiteConfig(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SiteConfig
	err = actual.AssignProperties_From_SiteConfig(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SiteConfig_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SiteConfig via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSiteConfig, SiteConfigGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSiteConfig runs a test to see if a specific instance of SiteConfig round trips to JSON and back losslessly
func RunJSONSerializationTestForSiteConfig(subject SiteConfig) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SiteConfig
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SiteConfig instances for property testing - lazily instantiated by SiteConfigGenerator()
var siteConfigGenerator gopter.Gen

// SiteConfigGenerator returns a generator of SiteConfig instances for property testing.
func SiteConfigGenerator() gopter.Gen {
	if siteConfigGenerator != nil {
		return siteConfigGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForSiteConfig(generators)
	siteConfigGenerator = gen.Struct(reflect.TypeOf(SiteConfig{}), generators)

	return siteConfigGenerator
}

// AddRelatedPropertyGeneratorsForSiteConfig is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSiteConfig(gens map[string]gopter.Gen) {
	gens["ApiDefinition"] = gen.PtrOf(ApiDefinitionInfoGenerator())
	gens["ApiManagementConfig"] = gen.PtrOf(ApiManagementConfigGenerator())
	gens["AppSettings"] = gen.SliceOf(NameValuePairGenerator())
	gens["AutoHealRules"] = gen.PtrOf(AutoHealRulesGenerator())
	gens["AzureStorageAccounts"] = gen.MapOf(gen.AlphaString(), AzureStorageInfoValueGenerator())
	gens["ConnectionStrings"] = gen.SliceOf(ConnStringInfoGenerator())
	gens["Cors"] = gen.PtrOf(CorsSettingsGenerator())
	gens["Experiments"] = gen.PtrOf(ExperimentsGenerator())
	gens["HandlerMappings"] = gen.SliceOf(HandlerMappingGenerator())
	gens["IpSecurityRestrictions"] = gen.SliceOf(IpSecurityRestrictionGenerator())
	gens["Limits"] = gen.PtrOf(SiteLimitsGenerator())
	gens["Push"] = gen.PtrOf(PushSettingsGenerator())
	gens["ScmIpSecurityRestrictions"] = gen.SliceOf(IpSecurityRestrictionGenerator())
	gens["VirtualApplications"] = gen.SliceOf(VirtualApplicationGenerator())
}

func Test_SiteConfig_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SiteConfig_STATUS to SiteConfig_STATUS via AssignProperties_To_SiteConfig_STATUS & AssignProperties_From_SiteConfig_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSiteConfig_STATUS, SiteConfig_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSiteConfig_STATUS tests if a specific instance of SiteConfig_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSiteConfig_STATUS(subject SiteConfig_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.SiteConfig_STATUS
	err := copied.AssignProperties_To_SiteConfig_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SiteConfig_STATUS
	err = actual.AssignProperties_From_SiteConfig_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SiteConfig_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SiteConfig_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSiteConfig_STATUS, SiteConfig_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSiteConfig_STATUS runs a test to see if a specific instance of SiteConfig_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSiteConfig_STATUS(subject SiteConfig_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SiteConfig_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SiteConfig_STATUS instances for property testing - lazily instantiated by SiteConfig_STATUSGenerator()
var siteConfig_STATUSGenerator gopter.Gen

// SiteConfig_STATUSGenerator returns a generator of SiteConfig_STATUS instances for property testing.
func SiteConfig_STATUSGenerator() gopter.Gen {
	if siteConfig_STATUSGenerator != nil {
		return siteConfig_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForSiteConfig_STATUS(generators)
	siteConfig_STATUSGenerator = gen.Struct(reflect.TypeOf(SiteConfig_STATUS{}), generators)

	return siteConfig_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForSiteConfig_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSiteConfig_STATUS(gens map[string]gopter.Gen) {
	gens["ApiDefinition"] = gen.PtrOf(ApiDefinitionInfo_STATUSGenerator())
	gens["ApiManagementConfig"] = gen.PtrOf(ApiManagementConfig_STATUSGenerator())
	gens["AppSettings"] = gen.SliceOf(NameValuePair_STATUSGenerator())
	gens["AutoHealRules"] = gen.PtrOf(AutoHealRules_STATUSGenerator())
	gens["AzureStorageAccounts"] = gen.MapOf(gen.AlphaString(), AzureStorageInfoValue_STATUSGenerator())
	gens["ConnectionStrings"] = gen.SliceOf(ConnStringInfo_STATUSGenerator())
	gens["Cors"] = gen.PtrOf(CorsSettings_STATUSGenerator())
	gens["Experiments"] = gen.PtrOf(Experiments_STATUSGenerator())
	gens["HandlerMappings"] = gen.SliceOf(HandlerMapping_STATUSGenerator())
	gens["IpSecurityRestrictions"] = gen.SliceOf(IpSecurityRestriction_STATUSGenerator())
	gens["Limits"] = gen.PtrOf(SiteLimits_STATUSGenerator())
	gens["MachineKey"] = gen.PtrOf(SiteMachineKey_STATUSGenerator())
	gens["Push"] = gen.PtrOf(PushSettings_STATUSGenerator())
	gens["ScmIpSecurityRestrictions"] = gen.SliceOf(IpSecurityRestriction_STATUSGenerator())
	gens["VirtualApplications"] = gen.SliceOf(VirtualApplication_STATUSGenerator())
}

func Test_SlotSwapStatus_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SlotSwapStatus_STATUS to SlotSwapStatus_STATUS via AssignProperties_To_SlotSwapStatus_STATUS & AssignProperties_From_SlotSwapStatus_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSlotSwapStatus_STATUS, SlotSwapStatus_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSlotSwapStatus_STATUS tests if a specific instance of SlotSwapStatus_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSlotSwapStatus_STATUS(subject SlotSwapStatus_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.SlotSwapStatus_STATUS
	err := copied.AssignProperties_To_SlotSwapStatus_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SlotSwapStatus_STATUS
	err = actual.AssignProperties_From_SlotSwapStatus_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SlotSwapStatus_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SlotSwapStatus_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSlotSwapStatus_STATUS, SlotSwapStatus_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSlotSwapStatus_STATUS runs a test to see if a specific instance of SlotSwapStatus_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSlotSwapStatus_STATUS(subject SlotSwapStatus_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SlotSwapStatus_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SlotSwapStatus_STATUS instances for property testing - lazily instantiated by
// SlotSwapStatus_STATUSGenerator()
var slotSwapStatus_STATUSGenerator gopter.Gen

// SlotSwapStatus_STATUSGenerator returns a generator of SlotSwapStatus_STATUS instances for property testing.
func SlotSwapStatus_STATUSGenerator() gopter.Gen {
	if slotSwapStatus_STATUSGenerator != nil {
		return slotSwapStatus_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSlotSwapStatus_STATUS(generators)
	slotSwapStatus_STATUSGenerator = gen.Struct(reflect.TypeOf(SlotSwapStatus_STATUS{}), generators)

	return slotSwapStatus_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSlotSwapStatus_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSlotSwapStatus_STATUS(gens map[string]gopter.Gen) {
	gens["DestinationSlotName"] = gen.PtrOf(gen.AlphaString())
	gens["SourceSlotName"] = gen.PtrOf(gen.AlphaString())
	gens["TimestampUtc"] = gen.PtrOf(gen.AlphaString())
}

func Test_ApiDefinitionInfo_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ApiDefinitionInfo to ApiDefinitionInfo via AssignProperties_To_ApiDefinitionInfo & AssignProperties_From_ApiDefinitionInfo returns original",
		prop.ForAll(RunPropertyAssignmentTestForApiDefinitionInfo, ApiDefinitionInfoGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForApiDefinitionInfo tests if a specific instance of ApiDefinitionInfo can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForApiDefinitionInfo(subject ApiDefinitionInfo) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.ApiDefinitionInfo
	err := copied.AssignProperties_To_ApiDefinitionInfo(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ApiDefinitionInfo
	err = actual.AssignProperties_From_ApiDefinitionInfo(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ApiDefinitionInfo_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiDefinitionInfo via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiDefinitionInfo, ApiDefinitionInfoGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiDefinitionInfo runs a test to see if a specific instance of ApiDefinitionInfo round trips to JSON and back losslessly
func RunJSONSerializationTestForApiDefinitionInfo(subject ApiDefinitionInfo) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiDefinitionInfo
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiDefinitionInfo instances for property testing - lazily instantiated by ApiDefinitionInfoGenerator()
var apiDefinitionInfoGenerator gopter.Gen

// ApiDefinitionInfoGenerator returns a generator of ApiDefinitionInfo instances for property testing.
func ApiDefinitionInfoGenerator() gopter.Gen {
	if apiDefinitionInfoGenerator != nil {
		return apiDefinitionInfoGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiDefinitionInfo(generators)
	apiDefinitionInfoGenerator = gen.Struct(reflect.TypeOf(ApiDefinitionInfo{}), generators)

	return apiDefinitionInfoGenerator
}

// AddIndependentPropertyGeneratorsForApiDefinitionInfo is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiDefinitionInfo(gens map[string]gopter.Gen) {
	gens["Url"] = gen.PtrOf(gen.AlphaString())
}

func Test_ApiDefinitionInfo_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ApiDefinitionInfo_STATUS to ApiDefinitionInfo_STATUS via AssignProperties_To_ApiDefinitionInfo_STATUS & AssignProperties_From_ApiDefinitionInfo_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForApiDefinitionInfo_STATUS, ApiDefinitionInfo_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForApiDefinitionInfo_STATUS tests if a specific instance of ApiDefinitionInfo_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForApiDefinitionInfo_STATUS(subject ApiDefinitionInfo_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.ApiDefinitionInfo_STATUS
	err := copied.AssignProperties_To_ApiDefinitionInfo_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ApiDefinitionInfo_STATUS
	err = actual.AssignProperties_From_ApiDefinitionInfo_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ApiDefinitionInfo_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiDefinitionInfo_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiDefinitionInfo_STATUS, ApiDefinitionInfo_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiDefinitionInfo_STATUS runs a test to see if a specific instance of ApiDefinitionInfo_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForApiDefinitionInfo_STATUS(subject ApiDefinitionInfo_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiDefinitionInfo_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiDefinitionInfo_STATUS instances for property testing - lazily instantiated by
// ApiDefinitionInfo_STATUSGenerator()
var apiDefinitionInfo_STATUSGenerator gopter.Gen

// ApiDefinitionInfo_STATUSGenerator returns a generator of ApiDefinitionInfo_STATUS instances for property testing.
func ApiDefinitionInfo_STATUSGenerator() gopter.Gen {
	if apiDefinitionInfo_STATUSGenerator != nil {
		return apiDefinitionInfo_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiDefinitionInfo_STATUS(generators)
	apiDefinitionInfo_STATUSGenerator = gen.Struct(reflect.TypeOf(ApiDefinitionInfo_STATUS{}), generators)

	return apiDefinitionInfo_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForApiDefinitionInfo_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiDefinitionInfo_STATUS(gens map[string]gopter.Gen) {
	gens["Url"] = gen.PtrOf(gen.AlphaString())
}

func Test_ApiManagementConfig_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ApiManagementConfig to ApiManagementConfig via AssignProperties_To_ApiManagementConfig & AssignProperties_From_ApiManagementConfig returns original",
		prop.ForAll(RunPropertyAssignmentTestForApiManagementConfig, ApiManagementConfigGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForApiManagementConfig tests if a specific instance of ApiManagementConfig can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForApiManagementConfig(subject ApiManagementConfig) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.ApiManagementConfig
	err := copied.AssignProperties_To_ApiManagementConfig(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ApiManagementConfig
	err = actual.AssignProperties_From_ApiManagementConfig(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ApiManagementConfig_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiManagementConfig via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiManagementConfig, ApiManagementConfigGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiManagementConfig runs a test to see if a specific instance of ApiManagementConfig round trips to JSON and back losslessly
func RunJSONSerializationTestForApiManagementConfig(subject ApiManagementConfig) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiManagementConfig
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiManagementConfig instances for property testing - lazily instantiated by
// ApiManagementConfigGenerator()
var apiManagementConfigGenerator gopter.Gen

// ApiManagementConfigGenerator returns a generator of ApiManagementConfig instances for property testing.
func ApiManagementConfigGenerator() gopter.Gen {
	if apiManagementConfigGenerator != nil {
		return apiManagementConfigGenerator
	}

	generators := make(map[string]gopter.Gen)
	apiManagementConfigGenerator = gen.Struct(reflect.TypeOf(ApiManagementConfig{}), generators)

	return apiManagementConfigGenerator
}

func Test_ApiManagementConfig_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ApiManagementConfig_STATUS to ApiManagementConfig_STATUS via AssignProperties_To_ApiManagementConfig_STATUS & AssignProperties_From_ApiManagementConfig_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForApiManagementConfig_STATUS, ApiManagementConfig_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForApiManagementConfig_STATUS tests if a specific instance of ApiManagementConfig_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForApiManagementConfig_STATUS(subject ApiManagementConfig_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.ApiManagementConfig_STATUS
	err := copied.AssignProperties_To_ApiManagementConfig_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ApiManagementConfig_STATUS
	err = actual.AssignProperties_From_ApiManagementConfig_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ApiManagementConfig_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiManagementConfig_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiManagementConfig_STATUS, ApiManagementConfig_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiManagementConfig_STATUS runs a test to see if a specific instance of ApiManagementConfig_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForApiManagementConfig_STATUS(subject ApiManagementConfig_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiManagementConfig_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiManagementConfig_STATUS instances for property testing - lazily instantiated by
// ApiManagementConfig_STATUSGenerator()
var apiManagementConfig_STATUSGenerator gopter.Gen

// ApiManagementConfig_STATUSGenerator returns a generator of ApiManagementConfig_STATUS instances for property testing.
func ApiManagementConfig_STATUSGenerator() gopter.Gen {
	if apiManagementConfig_STATUSGenerator != nil {
		return apiManagementConfig_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiManagementConfig_STATUS(generators)
	apiManagementConfig_STATUSGenerator = gen.Struct(reflect.TypeOf(ApiManagementConfig_STATUS{}), generators)

	return apiManagementConfig_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForApiManagementConfig_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiManagementConfig_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_AutoHealRules_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AutoHealRules to AutoHealRules via AssignProperties_To_AutoHealRules & AssignProperties_From_AutoHealRules returns original",
		prop.ForAll(RunPropertyAssignmentTestForAutoHealRules, AutoHealRulesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAutoHealRules tests if a specific instance of AutoHealRules can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAutoHealRules(subject AutoHealRules) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.AutoHealRules
	err := copied.AssignProperties_To_AutoHealRules(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AutoHealRules
	err = actual.AssignProperties_From_AutoHealRules(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AutoHealRules_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoHealRules via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoHealRules, AutoHealRulesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoHealRules runs a test to see if a specific instance of AutoHealRules round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoHealRules(subject AutoHealRules) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoHealRules
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoHealRules instances for property testing - lazily instantiated by AutoHealRulesGenerator()
var autoHealRulesGenerator gopter.Gen

// AutoHealRulesGenerator returns a generator of AutoHealRules instances for property testing.
func AutoHealRulesGenerator() gopter.Gen {
	if autoHealRulesGenerator != nil {
		return autoHealRulesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForAutoHealRules(generators)
	autoHealRulesGenerator = gen.Struct(reflect.TypeOf(AutoHealRules{}), generators)

	return autoHealRulesGenerator
}

// AddRelatedPropertyGeneratorsForAutoHealRules is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoHealRules(gens map[string]gopter.Gen) {
	gens["Actions"] = gen.PtrOf(AutoHealActionsGenerator())
	gens["Triggers"] = gen.PtrOf(AutoHealTriggersGenerator())
}

func Test_AutoHealRules_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AutoHealRules_STATUS to AutoHealRules_STATUS via AssignProperties_To_AutoHealRules_STATUS & AssignProperties_From_AutoHealRules_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAutoHealRules_STATUS, AutoHealRules_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAutoHealRules_STATUS tests if a specific instance of AutoHealRules_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAutoHealRules_STATUS(subject AutoHealRules_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.AutoHealRules_STATUS
	err := copied.AssignProperties_To_AutoHealRules_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AutoHealRules_STATUS
	err = actual.AssignProperties_From_AutoHealRules_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AutoHealRules_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoHealRules_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoHealRules_STATUS, AutoHealRules_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoHealRules_STATUS runs a test to see if a specific instance of AutoHealRules_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoHealRules_STATUS(subject AutoHealRules_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoHealRules_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoHealRules_STATUS instances for property testing - lazily instantiated by
// AutoHealRules_STATUSGenerator()
var autoHealRules_STATUSGenerator gopter.Gen

// AutoHealRules_STATUSGenerator returns a generator of AutoHealRules_STATUS instances for property testing.
func AutoHealRules_STATUSGenerator() gopter.Gen {
	if autoHealRules_STATUSGenerator != nil {
		return autoHealRules_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForAutoHealRules_STATUS(generators)
	autoHealRules_STATUSGenerator = gen.Struct(reflect.TypeOf(AutoHealRules_STATUS{}), generators)

	return autoHealRules_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForAutoHealRules_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoHealRules_STATUS(gens map[string]gopter.Gen) {
	gens["Actions"] = gen.PtrOf(AutoHealActions_STATUSGenerator())
	gens["Triggers"] = gen.PtrOf(AutoHealTriggers_STATUSGenerator())
}

func Test_AzureStorageInfoValue_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AzureStorageInfoValue to AzureStorageInfoValue via AssignProperties_To_AzureStorageInfoValue & AssignProperties_From_AzureStorageInfoValue returns original",
		prop.ForAll(RunPropertyAssignmentTestForAzureStorageInfoValue, AzureStorageInfoValueGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAzureStorageInfoValue tests if a specific instance of AzureStorageInfoValue can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAzureStorageInfoValue(subject AzureStorageInfoValue) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.AzureStorageInfoValue
	err := copied.AssignProperties_To_AzureStorageInfoValue(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AzureStorageInfoValue
	err = actual.AssignProperties_From_AzureStorageInfoValue(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AzureStorageInfoValue_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureStorageInfoValue via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureStorageInfoValue, AzureStorageInfoValueGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureStorageInfoValue runs a test to see if a specific instance of AzureStorageInfoValue round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureStorageInfoValue(subject AzureStorageInfoValue) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureStorageInfoValue
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureStorageInfoValue instances for property testing - lazily instantiated by
// AzureStorageInfoValueGenerator()
var azureStorageInfoValueGenerator gopter.Gen

// AzureStorageInfoValueGenerator returns a generator of AzureStorageInfoValue instances for property testing.
func AzureStorageInfoValueGenerator() gopter.Gen {
	if azureStorageInfoValueGenerator != nil {
		return azureStorageInfoValueGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureStorageInfoValue(generators)
	azureStorageInfoValueGenerator = gen.Struct(reflect.TypeOf(AzureStorageInfoValue{}), generators)

	return azureStorageInfoValueGenerator
}

// AddIndependentPropertyGeneratorsForAzureStorageInfoValue is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureStorageInfoValue(gens map[string]gopter.Gen) {
	gens["AccountName"] = gen.PtrOf(gen.AlphaString())
	gens["MountPath"] = gen.PtrOf(gen.AlphaString())
	gens["ShareName"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(AzureStorageInfoValue_Type_AzureBlob, AzureStorageInfoValue_Type_AzureFiles))
}

func Test_AzureStorageInfoValue_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AzureStorageInfoValue_STATUS to AzureStorageInfoValue_STATUS via AssignProperties_To_AzureStorageInfoValue_STATUS & AssignProperties_From_AzureStorageInfoValue_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAzureStorageInfoValue_STATUS, AzureStorageInfoValue_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAzureStorageInfoValue_STATUS tests if a specific instance of AzureStorageInfoValue_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAzureStorageInfoValue_STATUS(subject AzureStorageInfoValue_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.AzureStorageInfoValue_STATUS
	err := copied.AssignProperties_To_AzureStorageInfoValue_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AzureStorageInfoValue_STATUS
	err = actual.AssignProperties_From_AzureStorageInfoValue_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AzureStorageInfoValue_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureStorageInfoValue_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureStorageInfoValue_STATUS, AzureStorageInfoValue_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureStorageInfoValue_STATUS runs a test to see if a specific instance of AzureStorageInfoValue_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureStorageInfoValue_STATUS(subject AzureStorageInfoValue_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureStorageInfoValue_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureStorageInfoValue_STATUS instances for property testing - lazily instantiated by
// AzureStorageInfoValue_STATUSGenerator()
var azureStorageInfoValue_STATUSGenerator gopter.Gen

// AzureStorageInfoValue_STATUSGenerator returns a generator of AzureStorageInfoValue_STATUS instances for property testing.
func AzureStorageInfoValue_STATUSGenerator() gopter.Gen {
	if azureStorageInfoValue_STATUSGenerator != nil {
		return azureStorageInfoValue_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureStorageInfoValue_STATUS(generators)
	azureStorageInfoValue_STATUSGenerator = gen.Struct(reflect.TypeOf(AzureStorageInfoValue_STATUS{}), generators)

	return azureStorageInfoValue_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAzureStorageInfoValue_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureStorageInfoValue_STATUS(gens map[string]gopter.Gen) {
	gens["AccountName"] = gen.PtrOf(gen.AlphaString())
	gens["MountPath"] = gen.PtrOf(gen.AlphaString())
	gens["ShareName"] = gen.PtrOf(gen.AlphaString())
	gens["State"] = gen.PtrOf(gen.OneConstOf(
		AzureStorageInfoValue_State_STATUS_InvalidCredentials,
		AzureStorageInfoValue_State_STATUS_InvalidShare,
		AzureStorageInfoValue_State_STATUS_NotValidated,
		AzureStorageInfoValue_State_STATUS_Ok))
	gens["Type"] = gen.PtrOf(gen.OneConstOf(AzureStorageInfoValue_Type_STATUS_AzureBlob, AzureStorageInfoValue_Type_STATUS_AzureFiles))
}

func Test_ConnStringInfo_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ConnStringInfo to ConnStringInfo via AssignProperties_To_ConnStringInfo & AssignProperties_From_ConnStringInfo returns original",
		prop.ForAll(RunPropertyAssignmentTestForConnStringInfo, ConnStringInfoGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForConnStringInfo tests if a specific instance of ConnStringInfo can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForConnStringInfo(subject ConnStringInfo) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.ConnStringInfo
	err := copied.AssignProperties_To_ConnStringInfo(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ConnStringInfo
	err = actual.AssignProperties_From_ConnStringInfo(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ConnStringInfo_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ConnStringInfo via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForConnStringInfo, ConnStringInfoGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForConnStringInfo runs a test to see if a specific instance of ConnStringInfo round trips to JSON and back losslessly
func RunJSONSerializationTestForConnStringInfo(subject ConnStringInfo) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ConnStringInfo
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ConnStringInfo instances for property testing - lazily instantiated by ConnStringInfoGenerator()
var connStringInfoGenerator gopter.Gen

// ConnStringInfoGenerator returns a generator of ConnStringInfo instances for property testing.
func ConnStringInfoGenerator() gopter.Gen {
	if connStringInfoGenerator != nil {
		return connStringInfoGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForConnStringInfo(generators)
	connStringInfoGenerator = gen.Struct(reflect.TypeOf(ConnStringInfo{}), generators)

	return connStringInfoGenerator
}

// AddIndependentPropertyGeneratorsForConnStringInfo is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForConnStringInfo(gens map[string]gopter.Gen) {
	gens["ConnectionString"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ConnStringInfo_Type_ApiHub,
		ConnStringInfo_Type_Custom,
		ConnStringInfo_Type_DocDb,
		ConnStringInfo_Type_EventHub,
		ConnStringInfo_Type_MySql,
		ConnStringInfo_Type_NotificationHub,
		ConnStringInfo_Type_PostgreSQL,
		ConnStringInfo_Type_RedisCache,
		ConnStringInfo_Type_SQLAzure,
		ConnStringInfo_Type_SQLServer,
		ConnStringInfo_Type_ServiceBus))
}

func Test_ConnStringInfo_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ConnStringInfo_STATUS to ConnStringInfo_STATUS via AssignProperties_To_ConnStringInfo_STATUS & AssignProperties_From_ConnStringInfo_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForConnStringInfo_STATUS, ConnStringInfo_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForConnStringInfo_STATUS tests if a specific instance of ConnStringInfo_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForConnStringInfo_STATUS(subject ConnStringInfo_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.ConnStringInfo_STATUS
	err := copied.AssignProperties_To_ConnStringInfo_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ConnStringInfo_STATUS
	err = actual.AssignProperties_From_ConnStringInfo_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ConnStringInfo_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ConnStringInfo_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForConnStringInfo_STATUS, ConnStringInfo_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForConnStringInfo_STATUS runs a test to see if a specific instance of ConnStringInfo_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForConnStringInfo_STATUS(subject ConnStringInfo_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ConnStringInfo_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ConnStringInfo_STATUS instances for property testing - lazily instantiated by
// ConnStringInfo_STATUSGenerator()
var connStringInfo_STATUSGenerator gopter.Gen

// ConnStringInfo_STATUSGenerator returns a generator of ConnStringInfo_STATUS instances for property testing.
func ConnStringInfo_STATUSGenerator() gopter.Gen {
	if connStringInfo_STATUSGenerator != nil {
		return connStringInfo_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForConnStringInfo_STATUS(generators)
	connStringInfo_STATUSGenerator = gen.Struct(reflect.TypeOf(ConnStringInfo_STATUS{}), generators)

	return connStringInfo_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForConnStringInfo_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForConnStringInfo_STATUS(gens map[string]gopter.Gen) {
	gens["ConnectionString"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ConnStringInfo_Type_STATUS_ApiHub,
		ConnStringInfo_Type_STATUS_Custom,
		ConnStringInfo_Type_STATUS_DocDb,
		ConnStringInfo_Type_STATUS_EventHub,
		ConnStringInfo_Type_STATUS_MySql,
		ConnStringInfo_Type_STATUS_NotificationHub,
		ConnStringInfo_Type_STATUS_PostgreSQL,
		ConnStringInfo_Type_STATUS_RedisCache,
		ConnStringInfo_Type_STATUS_SQLAzure,
		ConnStringInfo_Type_STATUS_SQLServer,
		ConnStringInfo_Type_STATUS_ServiceBus))
}

func Test_CorsSettings_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CorsSettings to CorsSettings via AssignProperties_To_CorsSettings & AssignProperties_From_CorsSettings returns original",
		prop.ForAll(RunPropertyAssignmentTestForCorsSettings, CorsSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCorsSettings tests if a specific instance of CorsSettings can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForCorsSettings(subject CorsSettings) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.CorsSettings
	err := copied.AssignProperties_To_CorsSettings(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CorsSettings
	err = actual.AssignProperties_From_CorsSettings(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CorsSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CorsSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCorsSettings, CorsSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCorsSettings runs a test to see if a specific instance of CorsSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForCorsSettings(subject CorsSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CorsSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CorsSettings instances for property testing - lazily instantiated by CorsSettingsGenerator()
var corsSettingsGenerator gopter.Gen

// CorsSettingsGenerator returns a generator of CorsSettings instances for property testing.
func CorsSettingsGenerator() gopter.Gen {
	if corsSettingsGenerator != nil {
		return corsSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCorsSettings(generators)
	corsSettingsGenerator = gen.Struct(reflect.TypeOf(CorsSettings{}), generators)

	return corsSettingsGenerator
}

// AddIndependentPropertyGeneratorsForCorsSettings is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCorsSettings(gens map[string]gopter.Gen) {
	gens["AllowedOrigins"] = gen.SliceOf(gen.AlphaString())
	gens["SupportCredentials"] = gen.PtrOf(gen.Bool())
}

func Test_CorsSettings_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CorsSettings_STATUS to CorsSettings_STATUS via AssignProperties_To_CorsSettings_STATUS & AssignProperties_From_CorsSettings_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForCorsSettings_STATUS, CorsSettings_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCorsSettings_STATUS tests if a specific instance of CorsSettings_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForCorsSettings_STATUS(subject CorsSettings_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.CorsSettings_STATUS
	err := copied.AssignProperties_To_CorsSettings_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CorsSettings_STATUS
	err = actual.AssignProperties_From_CorsSettings_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CorsSettings_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CorsSettings_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCorsSettings_STATUS, CorsSettings_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCorsSettings_STATUS runs a test to see if a specific instance of CorsSettings_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForCorsSettings_STATUS(subject CorsSettings_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CorsSettings_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CorsSettings_STATUS instances for property testing - lazily instantiated by
// CorsSettings_STATUSGenerator()
var corsSettings_STATUSGenerator gopter.Gen

// CorsSettings_STATUSGenerator returns a generator of CorsSettings_STATUS instances for property testing.
func CorsSettings_STATUSGenerator() gopter.Gen {
	if corsSettings_STATUSGenerator != nil {
		return corsSettings_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCorsSettings_STATUS(generators)
	corsSettings_STATUSGenerator = gen.Struct(reflect.TypeOf(CorsSettings_STATUS{}), generators)

	return corsSettings_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForCorsSettings_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCorsSettings_STATUS(gens map[string]gopter.Gen) {
	gens["AllowedOrigins"] = gen.SliceOf(gen.AlphaString())
	gens["SupportCredentials"] = gen.PtrOf(gen.Bool())
}

func Test_Experiments_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Experiments to Experiments via AssignProperties_To_Experiments & AssignProperties_From_Experiments returns original",
		prop.ForAll(RunPropertyAssignmentTestForExperiments, ExperimentsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExperiments tests if a specific instance of Experiments can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForExperiments(subject Experiments) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.Experiments
	err := copied.AssignProperties_To_Experiments(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Experiments
	err = actual.AssignProperties_From_Experiments(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Experiments_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Experiments via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExperiments, ExperimentsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExperiments runs a test to see if a specific instance of Experiments round trips to JSON and back losslessly
func RunJSONSerializationTestForExperiments(subject Experiments) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Experiments
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Experiments instances for property testing - lazily instantiated by ExperimentsGenerator()
var experimentsGenerator gopter.Gen

// ExperimentsGenerator returns a generator of Experiments instances for property testing.
func ExperimentsGenerator() gopter.Gen {
	if experimentsGenerator != nil {
		return experimentsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForExperiments(generators)
	experimentsGenerator = gen.Struct(reflect.TypeOf(Experiments{}), generators)

	return experimentsGenerator
}

// AddRelatedPropertyGeneratorsForExperiments is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForExperiments(gens map[string]gopter.Gen) {
	gens["RampUpRules"] = gen.SliceOf(RampUpRuleGenerator())
}

func Test_Experiments_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Experiments_STATUS to Experiments_STATUS via AssignProperties_To_Experiments_STATUS & AssignProperties_From_Experiments_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForExperiments_STATUS, Experiments_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExperiments_STATUS tests if a specific instance of Experiments_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForExperiments_STATUS(subject Experiments_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.Experiments_STATUS
	err := copied.AssignProperties_To_Experiments_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Experiments_STATUS
	err = actual.AssignProperties_From_Experiments_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Experiments_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Experiments_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExperiments_STATUS, Experiments_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExperiments_STATUS runs a test to see if a specific instance of Experiments_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForExperiments_STATUS(subject Experiments_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Experiments_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Experiments_STATUS instances for property testing - lazily instantiated by Experiments_STATUSGenerator()
var experiments_STATUSGenerator gopter.Gen

// Experiments_STATUSGenerator returns a generator of Experiments_STATUS instances for property testing.
func Experiments_STATUSGenerator() gopter.Gen {
	if experiments_STATUSGenerator != nil {
		return experiments_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForExperiments_STATUS(generators)
	experiments_STATUSGenerator = gen.Struct(reflect.TypeOf(Experiments_STATUS{}), generators)

	return experiments_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForExperiments_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForExperiments_STATUS(gens map[string]gopter.Gen) {
	gens["RampUpRules"] = gen.SliceOf(RampUpRule_STATUSGenerator())
}

func Test_HandlerMapping_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HandlerMapping to HandlerMapping via AssignProperties_To_HandlerMapping & AssignProperties_From_HandlerMapping returns original",
		prop.ForAll(RunPropertyAssignmentTestForHandlerMapping, HandlerMappingGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHandlerMapping tests if a specific instance of HandlerMapping can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForHandlerMapping(subject HandlerMapping) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.HandlerMapping
	err := copied.AssignProperties_To_HandlerMapping(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HandlerMapping
	err = actual.AssignProperties_From_HandlerMapping(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HandlerMapping_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HandlerMapping via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHandlerMapping, HandlerMappingGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHandlerMapping runs a test to see if a specific instance of HandlerMapping round trips to JSON and back losslessly
func RunJSONSerializationTestForHandlerMapping(subject HandlerMapping) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HandlerMapping
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HandlerMapping instances for property testing - lazily instantiated by HandlerMappingGenerator()
var handlerMappingGenerator gopter.Gen

// HandlerMappingGenerator returns a generator of HandlerMapping instances for property testing.
func HandlerMappingGenerator() gopter.Gen {
	if handlerMappingGenerator != nil {
		return handlerMappingGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHandlerMapping(generators)
	handlerMappingGenerator = gen.Struct(reflect.TypeOf(HandlerMapping{}), generators)

	return handlerMappingGenerator
}

// AddIndependentPropertyGeneratorsForHandlerMapping is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHandlerMapping(gens map[string]gopter.Gen) {
	gens["Arguments"] = gen.PtrOf(gen.AlphaString())
	gens["Extension"] = gen.PtrOf(gen.AlphaString())
	gens["ScriptProcessor"] = gen.PtrOf(gen.AlphaString())
}

func Test_HandlerMapping_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HandlerMapping_STATUS to HandlerMapping_STATUS via AssignProperties_To_HandlerMapping_STATUS & AssignProperties_From_HandlerMapping_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForHandlerMapping_STATUS, HandlerMapping_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHandlerMapping_STATUS tests if a specific instance of HandlerMapping_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForHandlerMapping_STATUS(subject HandlerMapping_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.HandlerMapping_STATUS
	err := copied.AssignProperties_To_HandlerMapping_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HandlerMapping_STATUS
	err = actual.AssignProperties_From_HandlerMapping_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HandlerMapping_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HandlerMapping_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHandlerMapping_STATUS, HandlerMapping_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHandlerMapping_STATUS runs a test to see if a specific instance of HandlerMapping_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForHandlerMapping_STATUS(subject HandlerMapping_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HandlerMapping_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HandlerMapping_STATUS instances for property testing - lazily instantiated by
// HandlerMapping_STATUSGenerator()
var handlerMapping_STATUSGenerator gopter.Gen

// HandlerMapping_STATUSGenerator returns a generator of HandlerMapping_STATUS instances for property testing.
func HandlerMapping_STATUSGenerator() gopter.Gen {
	if handlerMapping_STATUSGenerator != nil {
		return handlerMapping_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHandlerMapping_STATUS(generators)
	handlerMapping_STATUSGenerator = gen.Struct(reflect.TypeOf(HandlerMapping_STATUS{}), generators)

	return handlerMapping_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForHandlerMapping_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHandlerMapping_STATUS(gens map[string]gopter.Gen) {
	gens["Arguments"] = gen.PtrOf(gen.AlphaString())
	gens["Extension"] = gen.PtrOf(gen.AlphaString())
	gens["ScriptProcessor"] = gen.PtrOf(gen.AlphaString())
}

func Test_IpSecurityRestriction_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IpSecurityRestriction to IpSecurityRestriction via AssignProperties_To_IpSecurityRestriction & AssignProperties_From_IpSecurityRestriction returns original",
		prop.ForAll(RunPropertyAssignmentTestForIpSecurityRestriction, IpSecurityRestrictionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIpSecurityRestriction tests if a specific instance of IpSecurityRestriction can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForIpSecurityRestriction(subject IpSecurityRestriction) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.IpSecurityRestriction
	err := copied.AssignProperties_To_IpSecurityRestriction(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IpSecurityRestriction
	err = actual.AssignProperties_From_IpSecurityRestriction(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IpSecurityRestriction_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpSecurityRestriction via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpSecurityRestriction, IpSecurityRestrictionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpSecurityRestriction runs a test to see if a specific instance of IpSecurityRestriction round trips to JSON and back losslessly
func RunJSONSerializationTestForIpSecurityRestriction(subject IpSecurityRestriction) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpSecurityRestriction
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpSecurityRestriction instances for property testing - lazily instantiated by
// IpSecurityRestrictionGenerator()
var ipSecurityRestrictionGenerator gopter.Gen

// IpSecurityRestrictionGenerator returns a generator of IpSecurityRestriction instances for property testing.
func IpSecurityRestrictionGenerator() gopter.Gen {
	if ipSecurityRestrictionGenerator != nil {
		return ipSecurityRestrictionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpSecurityRestriction(generators)
	ipSecurityRestrictionGenerator = gen.Struct(reflect.TypeOf(IpSecurityRestriction{}), generators)

	return ipSecurityRestrictionGenerator
}

// AddIndependentPropertyGeneratorsForIpSecurityRestriction is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpSecurityRestriction(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.AlphaString())
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["Headers"] = gen.MapOf(gen.AlphaString(), gen.SliceOf(gen.AlphaString()))
	gens["IpAddress"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Priority"] = gen.PtrOf(gen.Int())
	gens["SubnetMask"] = gen.PtrOf(gen.AlphaString())
	gens["SubnetTrafficTag"] = gen.PtrOf(gen.Int())
	gens["Tag"] = gen.PtrOf(gen.OneConstOf(IpSecurityRestriction_Tag_Default, IpSecurityRestriction_Tag_ServiceTag, IpSecurityRestriction_Tag_XffProxy))
	gens["VnetTrafficTag"] = gen.PtrOf(gen.Int())
}

func Test_IpSecurityRestriction_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IpSecurityRestriction_STATUS to IpSecurityRestriction_STATUS via AssignProperties_To_IpSecurityRestriction_STATUS & AssignProperties_From_IpSecurityRestriction_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForIpSecurityRestriction_STATUS, IpSecurityRestriction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIpSecurityRestriction_STATUS tests if a specific instance of IpSecurityRestriction_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForIpSecurityRestriction_STATUS(subject IpSecurityRestriction_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.IpSecurityRestriction_STATUS
	err := copied.AssignProperties_To_IpSecurityRestriction_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IpSecurityRestriction_STATUS
	err = actual.AssignProperties_From_IpSecurityRestriction_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IpSecurityRestriction_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpSecurityRestriction_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpSecurityRestriction_STATUS, IpSecurityRestriction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpSecurityRestriction_STATUS runs a test to see if a specific instance of IpSecurityRestriction_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForIpSecurityRestriction_STATUS(subject IpSecurityRestriction_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpSecurityRestriction_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpSecurityRestriction_STATUS instances for property testing - lazily instantiated by
// IpSecurityRestriction_STATUSGenerator()
var ipSecurityRestriction_STATUSGenerator gopter.Gen

// IpSecurityRestriction_STATUSGenerator returns a generator of IpSecurityRestriction_STATUS instances for property testing.
func IpSecurityRestriction_STATUSGenerator() gopter.Gen {
	if ipSecurityRestriction_STATUSGenerator != nil {
		return ipSecurityRestriction_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpSecurityRestriction_STATUS(generators)
	ipSecurityRestriction_STATUSGenerator = gen.Struct(reflect.TypeOf(IpSecurityRestriction_STATUS{}), generators)

	return ipSecurityRestriction_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForIpSecurityRestriction_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpSecurityRestriction_STATUS(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.AlphaString())
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["Headers"] = gen.MapOf(gen.AlphaString(), gen.SliceOf(gen.AlphaString()))
	gens["IpAddress"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Priority"] = gen.PtrOf(gen.Int())
	gens["SubnetMask"] = gen.PtrOf(gen.AlphaString())
	gens["SubnetTrafficTag"] = gen.PtrOf(gen.Int())
	gens["Tag"] = gen.PtrOf(gen.OneConstOf(IpSecurityRestriction_Tag_STATUS_Default, IpSecurityRestriction_Tag_STATUS_ServiceTag, IpSecurityRestriction_Tag_STATUS_XffProxy))
	gens["VnetSubnetResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["VnetTrafficTag"] = gen.PtrOf(gen.Int())
}

func Test_NameValuePair_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NameValuePair to NameValuePair via AssignProperties_To_NameValuePair & AssignProperties_From_NameValuePair returns original",
		prop.ForAll(RunPropertyAssignmentTestForNameValuePair, NameValuePairGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNameValuePair tests if a specific instance of NameValuePair can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForNameValuePair(subject NameValuePair) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.NameValuePair
	err := copied.AssignProperties_To_NameValuePair(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NameValuePair
	err = actual.AssignProperties_From_NameValuePair(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NameValuePair_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NameValuePair via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNameValuePair, NameValuePairGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNameValuePair runs a test to see if a specific instance of NameValuePair round trips to JSON and back losslessly
func RunJSONSerializationTestForNameValuePair(subject NameValuePair) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NameValuePair
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NameValuePair instances for property testing - lazily instantiated by NameValuePairGenerator()
var nameValuePairGenerator gopter.Gen

// NameValuePairGenerator returns a generator of NameValuePair instances for property testing.
func NameValuePairGenerator() gopter.Gen {
	if nameValuePairGenerator != nil {
		return nameValuePairGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNameValuePair(generators)
	nameValuePairGenerator = gen.Struct(reflect.TypeOf(NameValuePair{}), generators)

	return nameValuePairGenerator
}

// AddIndependentPropertyGeneratorsForNameValuePair is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNameValuePair(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_NameValuePair_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NameValuePair_STATUS to NameValuePair_STATUS via AssignProperties_To_NameValuePair_STATUS & AssignProperties_From_NameValuePair_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForNameValuePair_STATUS, NameValuePair_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNameValuePair_STATUS tests if a specific instance of NameValuePair_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForNameValuePair_STATUS(subject NameValuePair_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.NameValuePair_STATUS
	err := copied.AssignProperties_To_NameValuePair_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NameValuePair_STATUS
	err = actual.AssignProperties_From_NameValuePair_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NameValuePair_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NameValuePair_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNameValuePair_STATUS, NameValuePair_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNameValuePair_STATUS runs a test to see if a specific instance of NameValuePair_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForNameValuePair_STATUS(subject NameValuePair_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NameValuePair_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NameValuePair_STATUS instances for property testing - lazily instantiated by
// NameValuePair_STATUSGenerator()
var nameValuePair_STATUSGenerator gopter.Gen

// NameValuePair_STATUSGenerator returns a generator of NameValuePair_STATUS instances for property testing.
func NameValuePair_STATUSGenerator() gopter.Gen {
	if nameValuePair_STATUSGenerator != nil {
		return nameValuePair_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNameValuePair_STATUS(generators)
	nameValuePair_STATUSGenerator = gen.Struct(reflect.TypeOf(NameValuePair_STATUS{}), generators)

	return nameValuePair_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForNameValuePair_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNameValuePair_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_PushSettings_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PushSettings to PushSettings via AssignProperties_To_PushSettings & AssignProperties_From_PushSettings returns original",
		prop.ForAll(RunPropertyAssignmentTestForPushSettings, PushSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPushSettings tests if a specific instance of PushSettings can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForPushSettings(subject PushSettings) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.PushSettings
	err := copied.AssignProperties_To_PushSettings(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PushSettings
	err = actual.AssignProperties_From_PushSettings(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PushSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PushSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPushSettings, PushSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPushSettings runs a test to see if a specific instance of PushSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForPushSettings(subject PushSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PushSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PushSettings instances for property testing - lazily instantiated by PushSettingsGenerator()
var pushSettingsGenerator gopter.Gen

// PushSettingsGenerator returns a generator of PushSettings instances for property testing.
func PushSettingsGenerator() gopter.Gen {
	if pushSettingsGenerator != nil {
		return pushSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPushSettings(generators)
	pushSettingsGenerator = gen.Struct(reflect.TypeOf(PushSettings{}), generators)

	return pushSettingsGenerator
}

// AddIndependentPropertyGeneratorsForPushSettings is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPushSettings(gens map[string]gopter.Gen) {
	gens["DynamicTagsJson"] = gen.PtrOf(gen.AlphaString())
	gens["IsPushEnabled"] = gen.PtrOf(gen.Bool())
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["TagWhitelistJson"] = gen.PtrOf(gen.AlphaString())
	gens["TagsRequiringAuth"] = gen.PtrOf(gen.AlphaString())
}

func Test_PushSettings_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PushSettings_STATUS to PushSettings_STATUS via AssignProperties_To_PushSettings_STATUS & AssignProperties_From_PushSettings_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForPushSettings_STATUS, PushSettings_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPushSettings_STATUS tests if a specific instance of PushSettings_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForPushSettings_STATUS(subject PushSettings_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.PushSettings_STATUS
	err := copied.AssignProperties_To_PushSettings_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PushSettings_STATUS
	err = actual.AssignProperties_From_PushSettings_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PushSettings_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PushSettings_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPushSettings_STATUS, PushSettings_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPushSettings_STATUS runs a test to see if a specific instance of PushSettings_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPushSettings_STATUS(subject PushSettings_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PushSettings_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PushSettings_STATUS instances for property testing - lazily instantiated by
// PushSettings_STATUSGenerator()
var pushSettings_STATUSGenerator gopter.Gen

// PushSettings_STATUSGenerator returns a generator of PushSettings_STATUS instances for property testing.
func PushSettings_STATUSGenerator() gopter.Gen {
	if pushSettings_STATUSGenerator != nil {
		return pushSettings_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPushSettings_STATUS(generators)
	pushSettings_STATUSGenerator = gen.Struct(reflect.TypeOf(PushSettings_STATUS{}), generators)

	return pushSettings_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForPushSettings_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPushSettings_STATUS(gens map[string]gopter.Gen) {
	gens["DynamicTagsJson"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IsPushEnabled"] = gen.PtrOf(gen.Bool())
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["TagWhitelistJson"] = gen.PtrOf(gen.AlphaString())
	gens["TagsRequiringAuth"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_SiteLimits_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SiteLimits to SiteLimits via AssignProperties_To_SiteLimits & AssignProperties_From_SiteLimits returns original",
		prop.ForAll(RunPropertyAssignmentTestForSiteLimits, SiteLimitsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSiteLimits tests if a specific instance of SiteLimits can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSiteLimits(subject SiteLimits) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.SiteLimits
	err := copied.AssignProperties_To_SiteLimits(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SiteLimits
	err = actual.AssignProperties_From_SiteLimits(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SiteLimits_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SiteLimits via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSiteLimits, SiteLimitsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSiteLimits runs a test to see if a specific instance of SiteLimits round trips to JSON and back losslessly
func RunJSONSerializationTestForSiteLimits(subject SiteLimits) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SiteLimits
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SiteLimits instances for property testing - lazily instantiated by SiteLimitsGenerator()
var siteLimitsGenerator gopter.Gen

// SiteLimitsGenerator returns a generator of SiteLimits instances for property testing.
func SiteLimitsGenerator() gopter.Gen {
	if siteLimitsGenerator != nil {
		return siteLimitsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSiteLimits(generators)
	siteLimitsGenerator = gen.Struct(reflect.TypeOf(SiteLimits{}), generators)

	return siteLimitsGenerator
}

// AddIndependentPropertyGeneratorsForSiteLimits is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSiteLimits(gens map[string]gopter.Gen) {
	gens["MaxDiskSizeInMb"] = gen.PtrOf(gen.Int())
	gens["MaxMemoryInMb"] = gen.PtrOf(gen.Int())
	gens["MaxPercentageCpu"] = gen.PtrOf(gen.Float64())
}

func Test_SiteLimits_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SiteLimits_STATUS to SiteLimits_STATUS via AssignProperties_To_SiteLimits_STATUS & AssignProperties_From_SiteLimits_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSiteLimits_STATUS, SiteLimits_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSiteLimits_STATUS tests if a specific instance of SiteLimits_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSiteLimits_STATUS(subject SiteLimits_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.SiteLimits_STATUS
	err := copied.AssignProperties_To_SiteLimits_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SiteLimits_STATUS
	err = actual.AssignProperties_From_SiteLimits_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SiteLimits_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SiteLimits_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSiteLimits_STATUS, SiteLimits_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSiteLimits_STATUS runs a test to see if a specific instance of SiteLimits_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSiteLimits_STATUS(subject SiteLimits_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SiteLimits_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SiteLimits_STATUS instances for property testing - lazily instantiated by SiteLimits_STATUSGenerator()
var siteLimits_STATUSGenerator gopter.Gen

// SiteLimits_STATUSGenerator returns a generator of SiteLimits_STATUS instances for property testing.
func SiteLimits_STATUSGenerator() gopter.Gen {
	if siteLimits_STATUSGenerator != nil {
		return siteLimits_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSiteLimits_STATUS(generators)
	siteLimits_STATUSGenerator = gen.Struct(reflect.TypeOf(SiteLimits_STATUS{}), generators)

	return siteLimits_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSiteLimits_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSiteLimits_STATUS(gens map[string]gopter.Gen) {
	gens["MaxDiskSizeInMb"] = gen.PtrOf(gen.Int())
	gens["MaxMemoryInMb"] = gen.PtrOf(gen.Int())
	gens["MaxPercentageCpu"] = gen.PtrOf(gen.Float64())
}

func Test_SiteMachineKey_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SiteMachineKey_STATUS to SiteMachineKey_STATUS via AssignProperties_To_SiteMachineKey_STATUS & AssignProperties_From_SiteMachineKey_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSiteMachineKey_STATUS, SiteMachineKey_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSiteMachineKey_STATUS tests if a specific instance of SiteMachineKey_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSiteMachineKey_STATUS(subject SiteMachineKey_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.SiteMachineKey_STATUS
	err := copied.AssignProperties_To_SiteMachineKey_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SiteMachineKey_STATUS
	err = actual.AssignProperties_From_SiteMachineKey_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SiteMachineKey_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SiteMachineKey_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSiteMachineKey_STATUS, SiteMachineKey_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSiteMachineKey_STATUS runs a test to see if a specific instance of SiteMachineKey_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSiteMachineKey_STATUS(subject SiteMachineKey_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SiteMachineKey_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SiteMachineKey_STATUS instances for property testing - lazily instantiated by
// SiteMachineKey_STATUSGenerator()
var siteMachineKey_STATUSGenerator gopter.Gen

// SiteMachineKey_STATUSGenerator returns a generator of SiteMachineKey_STATUS instances for property testing.
func SiteMachineKey_STATUSGenerator() gopter.Gen {
	if siteMachineKey_STATUSGenerator != nil {
		return siteMachineKey_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSiteMachineKey_STATUS(generators)
	siteMachineKey_STATUSGenerator = gen.Struct(reflect.TypeOf(SiteMachineKey_STATUS{}), generators)

	return siteMachineKey_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSiteMachineKey_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSiteMachineKey_STATUS(gens map[string]gopter.Gen) {
	gens["Decryption"] = gen.PtrOf(gen.AlphaString())
	gens["DecryptionKey"] = gen.PtrOf(gen.AlphaString())
	gens["Validation"] = gen.PtrOf(gen.AlphaString())
	gens["ValidationKey"] = gen.PtrOf(gen.AlphaString())
}

func Test_UserAssignedIdentity_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UserAssignedIdentity_STATUS to UserAssignedIdentity_STATUS via AssignProperties_To_UserAssignedIdentity_STATUS & AssignProperties_From_UserAssignedIdentity_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForUserAssignedIdentity_STATUS, UserAssignedIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUserAssignedIdentity_STATUS tests if a specific instance of UserAssignedIdentity_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForUserAssignedIdentity_STATUS(subject UserAssignedIdentity_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.UserAssignedIdentity_STATUS
	err := copied.AssignProperties_To_UserAssignedIdentity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UserAssignedIdentity_STATUS
	err = actual.AssignProperties_From_UserAssignedIdentity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UserAssignedIdentity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentity_STATUS, UserAssignedIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentity_STATUS runs a test to see if a specific instance of UserAssignedIdentity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentity_STATUS(subject UserAssignedIdentity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentity_STATUS instances for property testing - lazily instantiated by
// UserAssignedIdentity_STATUSGenerator()
var userAssignedIdentity_STATUSGenerator gopter.Gen

// UserAssignedIdentity_STATUSGenerator returns a generator of UserAssignedIdentity_STATUS instances for property testing.
func UserAssignedIdentity_STATUSGenerator() gopter.Gen {
	if userAssignedIdentity_STATUSGenerator != nil {
		return userAssignedIdentity_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserAssignedIdentity_STATUS(generators)
	userAssignedIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentity_STATUS{}), generators)

	return userAssignedIdentity_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForUserAssignedIdentity_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserAssignedIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_UserAssignedIdentityDetails_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UserAssignedIdentityDetails to UserAssignedIdentityDetails via AssignProperties_To_UserAssignedIdentityDetails & AssignProperties_From_UserAssignedIdentityDetails returns original",
		prop.ForAll(RunPropertyAssignmentTestForUserAssignedIdentityDetails, UserAssignedIdentityDetailsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUserAssignedIdentityDetails tests if a specific instance of UserAssignedIdentityDetails can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForUserAssignedIdentityDetails(subject UserAssignedIdentityDetails) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.UserAssignedIdentityDetails
	err := copied.AssignProperties_To_UserAssignedIdentityDetails(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UserAssignedIdentityDetails
	err = actual.AssignProperties_From_UserAssignedIdentityDetails(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UserAssignedIdentityDetails_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentityDetails via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentityDetails, UserAssignedIdentityDetailsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentityDetails runs a test to see if a specific instance of UserAssignedIdentityDetails round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentityDetails(subject UserAssignedIdentityDetails) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentityDetails
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentityDetails instances for property testing - lazily instantiated by
// UserAssignedIdentityDetailsGenerator()
var userAssignedIdentityDetailsGenerator gopter.Gen

// UserAssignedIdentityDetailsGenerator returns a generator of UserAssignedIdentityDetails instances for property testing.
func UserAssignedIdentityDetailsGenerator() gopter.Gen {
	if userAssignedIdentityDetailsGenerator != nil {
		return userAssignedIdentityDetailsGenerator
	}

	generators := make(map[string]gopter.Gen)
	userAssignedIdentityDetailsGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentityDetails{}), generators)

	return userAssignedIdentityDetailsGenerator
}

func Test_VirtualApplication_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualApplication to VirtualApplication via AssignProperties_To_VirtualApplication & AssignProperties_From_VirtualApplication returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualApplication, VirtualApplicationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualApplication tests if a specific instance of VirtualApplication can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForVirtualApplication(subject VirtualApplication) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.VirtualApplication
	err := copied.AssignProperties_To_VirtualApplication(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualApplication
	err = actual.AssignProperties_From_VirtualApplication(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualApplication_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualApplication via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualApplication, VirtualApplicationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualApplication runs a test to see if a specific instance of VirtualApplication round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualApplication(subject VirtualApplication) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualApplication
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualApplication instances for property testing - lazily instantiated by VirtualApplicationGenerator()
var virtualApplicationGenerator gopter.Gen

// VirtualApplicationGenerator returns a generator of VirtualApplication instances for property testing.
// We first initialize virtualApplicationGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualApplicationGenerator() gopter.Gen {
	if virtualApplicationGenerator != nil {
		return virtualApplicationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualApplication(generators)
	virtualApplicationGenerator = gen.Struct(reflect.TypeOf(VirtualApplication{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualApplication(generators)
	AddRelatedPropertyGeneratorsForVirtualApplication(generators)
	virtualApplicationGenerator = gen.Struct(reflect.TypeOf(VirtualApplication{}), generators)

	return virtualApplicationGenerator
}

// AddIndependentPropertyGeneratorsForVirtualApplication is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualApplication(gens map[string]gopter.Gen) {
	gens["PhysicalPath"] = gen.PtrOf(gen.AlphaString())
	gens["PreloadEnabled"] = gen.PtrOf(gen.Bool())
	gens["VirtualPath"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualApplication is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualApplication(gens map[string]gopter.Gen) {
	gens["VirtualDirectories"] = gen.SliceOf(VirtualDirectoryGenerator())
}

func Test_VirtualApplication_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualApplication_STATUS to VirtualApplication_STATUS via AssignProperties_To_VirtualApplication_STATUS & AssignProperties_From_VirtualApplication_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualApplication_STATUS, VirtualApplication_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualApplication_STATUS tests if a specific instance of VirtualApplication_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForVirtualApplication_STATUS(subject VirtualApplication_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.VirtualApplication_STATUS
	err := copied.AssignProperties_To_VirtualApplication_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualApplication_STATUS
	err = actual.AssignProperties_From_VirtualApplication_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualApplication_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualApplication_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualApplication_STATUS, VirtualApplication_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualApplication_STATUS runs a test to see if a specific instance of VirtualApplication_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualApplication_STATUS(subject VirtualApplication_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualApplication_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualApplication_STATUS instances for property testing - lazily instantiated by
// VirtualApplication_STATUSGenerator()
var virtualApplication_STATUSGenerator gopter.Gen

// VirtualApplication_STATUSGenerator returns a generator of VirtualApplication_STATUS instances for property testing.
// We first initialize virtualApplication_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualApplication_STATUSGenerator() gopter.Gen {
	if virtualApplication_STATUSGenerator != nil {
		return virtualApplication_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualApplication_STATUS(generators)
	virtualApplication_STATUSGenerator = gen.Struct(reflect.TypeOf(VirtualApplication_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualApplication_STATUS(generators)
	AddRelatedPropertyGeneratorsForVirtualApplication_STATUS(generators)
	virtualApplication_STATUSGenerator = gen.Struct(reflect.TypeOf(VirtualApplication_STATUS{}), generators)

	return virtualApplication_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForVirtualApplication_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualApplication_STATUS(gens map[string]gopter.Gen) {
	gens["PhysicalPath"] = gen.PtrOf(gen.AlphaString())
	gens["PreloadEnabled"] = gen.PtrOf(gen.Bool())
	gens["VirtualPath"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualApplication_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualApplication_STATUS(gens map[string]gopter.Gen) {
	gens["VirtualDirectories"] = gen.SliceOf(VirtualDirectory_STATUSGenerator())
}

func Test_AutoHealActions_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AutoHealActions to AutoHealActions via AssignProperties_To_AutoHealActions & AssignProperties_From_AutoHealActions returns original",
		prop.ForAll(RunPropertyAssignmentTestForAutoHealActions, AutoHealActionsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAutoHealActions tests if a specific instance of AutoHealActions can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAutoHealActions(subject AutoHealActions) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.AutoHealActions
	err := copied.AssignProperties_To_AutoHealActions(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AutoHealActions
	err = actual.AssignProperties_From_AutoHealActions(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AutoHealActions_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoHealActions via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoHealActions, AutoHealActionsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoHealActions runs a test to see if a specific instance of AutoHealActions round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoHealActions(subject AutoHealActions) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoHealActions
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoHealActions instances for property testing - lazily instantiated by AutoHealActionsGenerator()
var autoHealActionsGenerator gopter.Gen

// AutoHealActionsGenerator returns a generator of AutoHealActions instances for property testing.
// We first initialize autoHealActionsGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AutoHealActionsGenerator() gopter.Gen {
	if autoHealActionsGenerator != nil {
		return autoHealActionsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoHealActions(generators)
	autoHealActionsGenerator = gen.Struct(reflect.TypeOf(AutoHealActions{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoHealActions(generators)
	AddRelatedPropertyGeneratorsForAutoHealActions(generators)
	autoHealActionsGenerator = gen.Struct(reflect.TypeOf(AutoHealActions{}), generators)

	return autoHealActionsGenerator
}

// AddIndependentPropertyGeneratorsForAutoHealActions is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoHealActions(gens map[string]gopter.Gen) {
	gens["ActionType"] = gen.PtrOf(gen.OneConstOf(AutoHealActions_ActionType_CustomAction, AutoHealActions_ActionType_LogEvent, AutoHealActions_ActionType_Recycle))
	gens["MinProcessExecutionTime"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAutoHealActions is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoHealActions(gens map[string]gopter.Gen) {
	gens["CustomAction"] = gen.PtrOf(AutoHealCustomActionGenerator())
}

func Test_AutoHealActions_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AutoHealActions_STATUS to AutoHealActions_STATUS via AssignProperties_To_AutoHealActions_STATUS & AssignProperties_From_AutoHealActions_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAutoHealActions_STATUS, AutoHealActions_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAutoHealActions_STATUS tests if a specific instance of AutoHealActions_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAutoHealActions_STATUS(subject AutoHealActions_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.AutoHealActions_STATUS
	err := copied.AssignProperties_To_AutoHealActions_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AutoHealActions_STATUS
	err = actual.AssignProperties_From_AutoHealActions_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AutoHealActions_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoHealActions_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoHealActions_STATUS, AutoHealActions_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoHealActions_STATUS runs a test to see if a specific instance of AutoHealActions_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoHealActions_STATUS(subject AutoHealActions_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoHealActions_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoHealActions_STATUS instances for property testing - lazily instantiated by
// AutoHealActions_STATUSGenerator()
var autoHealActions_STATUSGenerator gopter.Gen

// AutoHealActions_STATUSGenerator returns a generator of AutoHealActions_STATUS instances for property testing.
// We first initialize autoHealActions_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AutoHealActions_STATUSGenerator() gopter.Gen {
	if autoHealActions_STATUSGenerator != nil {
		return autoHealActions_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoHealActions_STATUS(generators)
	autoHealActions_STATUSGenerator = gen.Struct(reflect.TypeOf(AutoHealActions_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoHealActions_STATUS(generators)
	AddRelatedPropertyGeneratorsForAutoHealActions_STATUS(generators)
	autoHealActions_STATUSGenerator = gen.Struct(reflect.TypeOf(AutoHealActions_STATUS{}), generators)

	return autoHealActions_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAutoHealActions_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoHealActions_STATUS(gens map[string]gopter.Gen) {
	gens["ActionType"] = gen.PtrOf(gen.OneConstOf(AutoHealActions_ActionType_STATUS_CustomAction, AutoHealActions_ActionType_STATUS_LogEvent, AutoHealActions_ActionType_STATUS_Recycle))
	gens["MinProcessExecutionTime"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAutoHealActions_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoHealActions_STATUS(gens map[string]gopter.Gen) {
	gens["CustomAction"] = gen.PtrOf(AutoHealCustomAction_STATUSGenerator())
}

func Test_AutoHealTriggers_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AutoHealTriggers to AutoHealTriggers via AssignProperties_To_AutoHealTriggers & AssignProperties_From_AutoHealTriggers returns original",
		prop.ForAll(RunPropertyAssignmentTestForAutoHealTriggers, AutoHealTriggersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAutoHealTriggers tests if a specific instance of AutoHealTriggers can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAutoHealTriggers(subject AutoHealTriggers) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.AutoHealTriggers
	err := copied.AssignProperties_To_AutoHealTriggers(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AutoHealTriggers
	err = actual.AssignProperties_From_AutoHealTriggers(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AutoHealTriggers_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoHealTriggers via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoHealTriggers, AutoHealTriggersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoHealTriggers runs a test to see if a specific instance of AutoHealTriggers round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoHealTriggers(subject AutoHealTriggers) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoHealTriggers
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoHealTriggers instances for property testing - lazily instantiated by AutoHealTriggersGenerator()
var autoHealTriggersGenerator gopter.Gen

// AutoHealTriggersGenerator returns a generator of AutoHealTriggers instances for property testing.
// We first initialize autoHealTriggersGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AutoHealTriggersGenerator() gopter.Gen {
	if autoHealTriggersGenerator != nil {
		return autoHealTriggersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoHealTriggers(generators)
	autoHealTriggersGenerator = gen.Struct(reflect.TypeOf(AutoHealTriggers{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoHealTriggers(generators)
	AddRelatedPropertyGeneratorsForAutoHealTriggers(generators)
	autoHealTriggersGenerator = gen.Struct(reflect.TypeOf(AutoHealTriggers{}), generators)

	return autoHealTriggersGenerator
}

// AddIndependentPropertyGeneratorsForAutoHealTriggers is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoHealTriggers(gens map[string]gopter.Gen) {
	gens["PrivateBytesInKB"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForAutoHealTriggers is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoHealTriggers(gens map[string]gopter.Gen) {
	gens["Requests"] = gen.PtrOf(RequestsBasedTriggerGenerator())
	gens["SlowRequests"] = gen.PtrOf(SlowRequestsBasedTriggerGenerator())
	gens["SlowRequestsWithPath"] = gen.SliceOf(SlowRequestsBasedTriggerGenerator())
	gens["StatusCodes"] = gen.SliceOf(StatusCodesBasedTriggerGenerator())
	gens["StatusCodesRange"] = gen.SliceOf(StatusCodesRangeBasedTriggerGenerator())
}

func Test_AutoHealTriggers_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AutoHealTriggers_STATUS to AutoHealTriggers_STATUS via AssignProperties_To_AutoHealTriggers_STATUS & AssignProperties_From_AutoHealTriggers_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAutoHealTriggers_STATUS, AutoHealTriggers_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAutoHealTriggers_STATUS tests if a specific instance of AutoHealTriggers_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAutoHealTriggers_STATUS(subject AutoHealTriggers_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.AutoHealTriggers_STATUS
	err := copied.AssignProperties_To_AutoHealTriggers_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AutoHealTriggers_STATUS
	err = actual.AssignProperties_From_AutoHealTriggers_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AutoHealTriggers_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoHealTriggers_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoHealTriggers_STATUS, AutoHealTriggers_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoHealTriggers_STATUS runs a test to see if a specific instance of AutoHealTriggers_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoHealTriggers_STATUS(subject AutoHealTriggers_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoHealTriggers_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoHealTriggers_STATUS instances for property testing - lazily instantiated by
// AutoHealTriggers_STATUSGenerator()
var autoHealTriggers_STATUSGenerator gopter.Gen

// AutoHealTriggers_STATUSGenerator returns a generator of AutoHealTriggers_STATUS instances for property testing.
// We first initialize autoHealTriggers_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AutoHealTriggers_STATUSGenerator() gopter.Gen {
	if autoHealTriggers_STATUSGenerator != nil {
		return autoHealTriggers_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoHealTriggers_STATUS(generators)
	autoHealTriggers_STATUSGenerator = gen.Struct(reflect.TypeOf(AutoHealTriggers_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoHealTriggers_STATUS(generators)
	AddRelatedPropertyGeneratorsForAutoHealTriggers_STATUS(generators)
	autoHealTriggers_STATUSGenerator = gen.Struct(reflect.TypeOf(AutoHealTriggers_STATUS{}), generators)

	return autoHealTriggers_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAutoHealTriggers_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoHealTriggers_STATUS(gens map[string]gopter.Gen) {
	gens["PrivateBytesInKB"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForAutoHealTriggers_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoHealTriggers_STATUS(gens map[string]gopter.Gen) {
	gens["Requests"] = gen.PtrOf(RequestsBasedTrigger_STATUSGenerator())
	gens["SlowRequests"] = gen.PtrOf(SlowRequestsBasedTrigger_STATUSGenerator())
	gens["SlowRequestsWithPath"] = gen.SliceOf(SlowRequestsBasedTrigger_STATUSGenerator())
	gens["StatusCodes"] = gen.SliceOf(StatusCodesBasedTrigger_STATUSGenerator())
	gens["StatusCodesRange"] = gen.SliceOf(StatusCodesRangeBasedTrigger_STATUSGenerator())
}

func Test_RampUpRule_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RampUpRule to RampUpRule via AssignProperties_To_RampUpRule & AssignProperties_From_RampUpRule returns original",
		prop.ForAll(RunPropertyAssignmentTestForRampUpRule, RampUpRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRampUpRule tests if a specific instance of RampUpRule can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForRampUpRule(subject RampUpRule) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.RampUpRule
	err := copied.AssignProperties_To_RampUpRule(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RampUpRule
	err = actual.AssignProperties_From_RampUpRule(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RampUpRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RampUpRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRampUpRule, RampUpRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRampUpRule runs a test to see if a specific instance of RampUpRule round trips to JSON and back losslessly
func RunJSONSerializationTestForRampUpRule(subject RampUpRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RampUpRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RampUpRule instances for property testing - lazily instantiated by RampUpRuleGenerator()
var rampUpRuleGenerator gopter.Gen

// RampUpRuleGenerator returns a generator of RampUpRule instances for property testing.
func RampUpRuleGenerator() gopter.Gen {
	if rampUpRuleGenerator != nil {
		return rampUpRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRampUpRule(generators)
	rampUpRuleGenerator = gen.Struct(reflect.TypeOf(RampUpRule{}), generators)

	return rampUpRuleGenerator
}

// AddIndependentPropertyGeneratorsForRampUpRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRampUpRule(gens map[string]gopter.Gen) {
	gens["ActionHostName"] = gen.PtrOf(gen.AlphaString())
	gens["ChangeDecisionCallbackUrl"] = gen.PtrOf(gen.AlphaString())
	gens["ChangeIntervalInMinutes"] = gen.PtrOf(gen.Int())
	gens["ChangeStep"] = gen.PtrOf(gen.Float64())
	gens["MaxReroutePercentage"] = gen.PtrOf(gen.Float64())
	gens["MinReroutePercentage"] = gen.PtrOf(gen.Float64())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ReroutePercentage"] = gen.PtrOf(gen.Float64())
}

func Test_RampUpRule_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RampUpRule_STATUS to RampUpRule_STATUS via AssignProperties_To_RampUpRule_STATUS & AssignProperties_From_RampUpRule_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForRampUpRule_STATUS, RampUpRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRampUpRule_STATUS tests if a specific instance of RampUpRule_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForRampUpRule_STATUS(subject RampUpRule_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.RampUpRule_STATUS
	err := copied.AssignProperties_To_RampUpRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RampUpRule_STATUS
	err = actual.AssignProperties_From_RampUpRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RampUpRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RampUpRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRampUpRule_STATUS, RampUpRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRampUpRule_STATUS runs a test to see if a specific instance of RampUpRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRampUpRule_STATUS(subject RampUpRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RampUpRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RampUpRule_STATUS instances for property testing - lazily instantiated by RampUpRule_STATUSGenerator()
var rampUpRule_STATUSGenerator gopter.Gen

// RampUpRule_STATUSGenerator returns a generator of RampUpRule_STATUS instances for property testing.
func RampUpRule_STATUSGenerator() gopter.Gen {
	if rampUpRule_STATUSGenerator != nil {
		return rampUpRule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRampUpRule_STATUS(generators)
	rampUpRule_STATUSGenerator = gen.Struct(reflect.TypeOf(RampUpRule_STATUS{}), generators)

	return rampUpRule_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForRampUpRule_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRampUpRule_STATUS(gens map[string]gopter.Gen) {
	gens["ActionHostName"] = gen.PtrOf(gen.AlphaString())
	gens["ChangeDecisionCallbackUrl"] = gen.PtrOf(gen.AlphaString())
	gens["ChangeIntervalInMinutes"] = gen.PtrOf(gen.Int())
	gens["ChangeStep"] = gen.PtrOf(gen.Float64())
	gens["MaxReroutePercentage"] = gen.PtrOf(gen.Float64())
	gens["MinReroutePercentage"] = gen.PtrOf(gen.Float64())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ReroutePercentage"] = gen.PtrOf(gen.Float64())
}

func Test_VirtualDirectory_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualDirectory to VirtualDirectory via AssignProperties_To_VirtualDirectory & AssignProperties_From_VirtualDirectory returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualDirectory, VirtualDirectoryGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualDirectory tests if a specific instance of VirtualDirectory can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForVirtualDirectory(subject VirtualDirectory) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.VirtualDirectory
	err := copied.AssignProperties_To_VirtualDirectory(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualDirectory
	err = actual.AssignProperties_From_VirtualDirectory(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualDirectory_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualDirectory via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualDirectory, VirtualDirectoryGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualDirectory runs a test to see if a specific instance of VirtualDirectory round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualDirectory(subject VirtualDirectory) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualDirectory
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualDirectory instances for property testing - lazily instantiated by VirtualDirectoryGenerator()
var virtualDirectoryGenerator gopter.Gen

// VirtualDirectoryGenerator returns a generator of VirtualDirectory instances for property testing.
func VirtualDirectoryGenerator() gopter.Gen {
	if virtualDirectoryGenerator != nil {
		return virtualDirectoryGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualDirectory(generators)
	virtualDirectoryGenerator = gen.Struct(reflect.TypeOf(VirtualDirectory{}), generators)

	return virtualDirectoryGenerator
}

// AddIndependentPropertyGeneratorsForVirtualDirectory is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualDirectory(gens map[string]gopter.Gen) {
	gens["PhysicalPath"] = gen.PtrOf(gen.AlphaString())
	gens["VirtualPath"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualDirectory_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualDirectory_STATUS to VirtualDirectory_STATUS via AssignProperties_To_VirtualDirectory_STATUS & AssignProperties_From_VirtualDirectory_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualDirectory_STATUS, VirtualDirectory_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualDirectory_STATUS tests if a specific instance of VirtualDirectory_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForVirtualDirectory_STATUS(subject VirtualDirectory_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.VirtualDirectory_STATUS
	err := copied.AssignProperties_To_VirtualDirectory_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualDirectory_STATUS
	err = actual.AssignProperties_From_VirtualDirectory_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualDirectory_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualDirectory_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualDirectory_STATUS, VirtualDirectory_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualDirectory_STATUS runs a test to see if a specific instance of VirtualDirectory_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualDirectory_STATUS(subject VirtualDirectory_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualDirectory_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualDirectory_STATUS instances for property testing - lazily instantiated by
// VirtualDirectory_STATUSGenerator()
var virtualDirectory_STATUSGenerator gopter.Gen

// VirtualDirectory_STATUSGenerator returns a generator of VirtualDirectory_STATUS instances for property testing.
func VirtualDirectory_STATUSGenerator() gopter.Gen {
	if virtualDirectory_STATUSGenerator != nil {
		return virtualDirectory_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualDirectory_STATUS(generators)
	virtualDirectory_STATUSGenerator = gen.Struct(reflect.TypeOf(VirtualDirectory_STATUS{}), generators)

	return virtualDirectory_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForVirtualDirectory_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualDirectory_STATUS(gens map[string]gopter.Gen) {
	gens["PhysicalPath"] = gen.PtrOf(gen.AlphaString())
	gens["VirtualPath"] = gen.PtrOf(gen.AlphaString())
}

func Test_AutoHealCustomAction_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AutoHealCustomAction to AutoHealCustomAction via AssignProperties_To_AutoHealCustomAction & AssignProperties_From_AutoHealCustomAction returns original",
		prop.ForAll(RunPropertyAssignmentTestForAutoHealCustomAction, AutoHealCustomActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAutoHealCustomAction tests if a specific instance of AutoHealCustomAction can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAutoHealCustomAction(subject AutoHealCustomAction) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.AutoHealCustomAction
	err := copied.AssignProperties_To_AutoHealCustomAction(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AutoHealCustomAction
	err = actual.AssignProperties_From_AutoHealCustomAction(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AutoHealCustomAction_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoHealCustomAction via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoHealCustomAction, AutoHealCustomActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoHealCustomAction runs a test to see if a specific instance of AutoHealCustomAction round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoHealCustomAction(subject AutoHealCustomAction) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoHealCustomAction
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoHealCustomAction instances for property testing - lazily instantiated by
// AutoHealCustomActionGenerator()
var autoHealCustomActionGenerator gopter.Gen

// AutoHealCustomActionGenerator returns a generator of AutoHealCustomAction instances for property testing.
func AutoHealCustomActionGenerator() gopter.Gen {
	if autoHealCustomActionGenerator != nil {
		return autoHealCustomActionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoHealCustomAction(generators)
	autoHealCustomActionGenerator = gen.Struct(reflect.TypeOf(AutoHealCustomAction{}), generators)

	return autoHealCustomActionGenerator
}

// AddIndependentPropertyGeneratorsForAutoHealCustomAction is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoHealCustomAction(gens map[string]gopter.Gen) {
	gens["Exe"] = gen.PtrOf(gen.AlphaString())
	gens["Parameters"] = gen.PtrOf(gen.AlphaString())
}

func Test_AutoHealCustomAction_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AutoHealCustomAction_STATUS to AutoHealCustomAction_STATUS via AssignProperties_To_AutoHealCustomAction_STATUS & AssignProperties_From_AutoHealCustomAction_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAutoHealCustomAction_STATUS, AutoHealCustomAction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAutoHealCustomAction_STATUS tests if a specific instance of AutoHealCustomAction_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAutoHealCustomAction_STATUS(subject AutoHealCustomAction_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.AutoHealCustomAction_STATUS
	err := copied.AssignProperties_To_AutoHealCustomAction_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AutoHealCustomAction_STATUS
	err = actual.AssignProperties_From_AutoHealCustomAction_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AutoHealCustomAction_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoHealCustomAction_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoHealCustomAction_STATUS, AutoHealCustomAction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoHealCustomAction_STATUS runs a test to see if a specific instance of AutoHealCustomAction_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoHealCustomAction_STATUS(subject AutoHealCustomAction_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoHealCustomAction_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoHealCustomAction_STATUS instances for property testing - lazily instantiated by
// AutoHealCustomAction_STATUSGenerator()
var autoHealCustomAction_STATUSGenerator gopter.Gen

// AutoHealCustomAction_STATUSGenerator returns a generator of AutoHealCustomAction_STATUS instances for property testing.
func AutoHealCustomAction_STATUSGenerator() gopter.Gen {
	if autoHealCustomAction_STATUSGenerator != nil {
		return autoHealCustomAction_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoHealCustomAction_STATUS(generators)
	autoHealCustomAction_STATUSGenerator = gen.Struct(reflect.TypeOf(AutoHealCustomAction_STATUS{}), generators)

	return autoHealCustomAction_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAutoHealCustomAction_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoHealCustomAction_STATUS(gens map[string]gopter.Gen) {
	gens["Exe"] = gen.PtrOf(gen.AlphaString())
	gens["Parameters"] = gen.PtrOf(gen.AlphaString())
}

func Test_RequestsBasedTrigger_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RequestsBasedTrigger to RequestsBasedTrigger via AssignProperties_To_RequestsBasedTrigger & AssignProperties_From_RequestsBasedTrigger returns original",
		prop.ForAll(RunPropertyAssignmentTestForRequestsBasedTrigger, RequestsBasedTriggerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRequestsBasedTrigger tests if a specific instance of RequestsBasedTrigger can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForRequestsBasedTrigger(subject RequestsBasedTrigger) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.RequestsBasedTrigger
	err := copied.AssignProperties_To_RequestsBasedTrigger(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RequestsBasedTrigger
	err = actual.AssignProperties_From_RequestsBasedTrigger(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RequestsBasedTrigger_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RequestsBasedTrigger via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRequestsBasedTrigger, RequestsBasedTriggerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRequestsBasedTrigger runs a test to see if a specific instance of RequestsBasedTrigger round trips to JSON and back losslessly
func RunJSONSerializationTestForRequestsBasedTrigger(subject RequestsBasedTrigger) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RequestsBasedTrigger
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RequestsBasedTrigger instances for property testing - lazily instantiated by
// RequestsBasedTriggerGenerator()
var requestsBasedTriggerGenerator gopter.Gen

// RequestsBasedTriggerGenerator returns a generator of RequestsBasedTrigger instances for property testing.
func RequestsBasedTriggerGenerator() gopter.Gen {
	if requestsBasedTriggerGenerator != nil {
		return requestsBasedTriggerGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRequestsBasedTrigger(generators)
	requestsBasedTriggerGenerator = gen.Struct(reflect.TypeOf(RequestsBasedTrigger{}), generators)

	return requestsBasedTriggerGenerator
}

// AddIndependentPropertyGeneratorsForRequestsBasedTrigger is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRequestsBasedTrigger(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["TimeInterval"] = gen.PtrOf(gen.AlphaString())
}

func Test_RequestsBasedTrigger_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RequestsBasedTrigger_STATUS to RequestsBasedTrigger_STATUS via AssignProperties_To_RequestsBasedTrigger_STATUS & AssignProperties_From_RequestsBasedTrigger_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForRequestsBasedTrigger_STATUS, RequestsBasedTrigger_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRequestsBasedTrigger_STATUS tests if a specific instance of RequestsBasedTrigger_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForRequestsBasedTrigger_STATUS(subject RequestsBasedTrigger_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.RequestsBasedTrigger_STATUS
	err := copied.AssignProperties_To_RequestsBasedTrigger_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RequestsBasedTrigger_STATUS
	err = actual.AssignProperties_From_RequestsBasedTrigger_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RequestsBasedTrigger_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RequestsBasedTrigger_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRequestsBasedTrigger_STATUS, RequestsBasedTrigger_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRequestsBasedTrigger_STATUS runs a test to see if a specific instance of RequestsBasedTrigger_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRequestsBasedTrigger_STATUS(subject RequestsBasedTrigger_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RequestsBasedTrigger_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RequestsBasedTrigger_STATUS instances for property testing - lazily instantiated by
// RequestsBasedTrigger_STATUSGenerator()
var requestsBasedTrigger_STATUSGenerator gopter.Gen

// RequestsBasedTrigger_STATUSGenerator returns a generator of RequestsBasedTrigger_STATUS instances for property testing.
func RequestsBasedTrigger_STATUSGenerator() gopter.Gen {
	if requestsBasedTrigger_STATUSGenerator != nil {
		return requestsBasedTrigger_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRequestsBasedTrigger_STATUS(generators)
	requestsBasedTrigger_STATUSGenerator = gen.Struct(reflect.TypeOf(RequestsBasedTrigger_STATUS{}), generators)

	return requestsBasedTrigger_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForRequestsBasedTrigger_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRequestsBasedTrigger_STATUS(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["TimeInterval"] = gen.PtrOf(gen.AlphaString())
}

func Test_SlowRequestsBasedTrigger_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SlowRequestsBasedTrigger to SlowRequestsBasedTrigger via AssignProperties_To_SlowRequestsBasedTrigger & AssignProperties_From_SlowRequestsBasedTrigger returns original",
		prop.ForAll(RunPropertyAssignmentTestForSlowRequestsBasedTrigger, SlowRequestsBasedTriggerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSlowRequestsBasedTrigger tests if a specific instance of SlowRequestsBasedTrigger can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSlowRequestsBasedTrigger(subject SlowRequestsBasedTrigger) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.SlowRequestsBasedTrigger
	err := copied.AssignProperties_To_SlowRequestsBasedTrigger(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SlowRequestsBasedTrigger
	err = actual.AssignProperties_From_SlowRequestsBasedTrigger(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SlowRequestsBasedTrigger_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SlowRequestsBasedTrigger via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSlowRequestsBasedTrigger, SlowRequestsBasedTriggerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSlowRequestsBasedTrigger runs a test to see if a specific instance of SlowRequestsBasedTrigger round trips to JSON and back losslessly
func RunJSONSerializationTestForSlowRequestsBasedTrigger(subject SlowRequestsBasedTrigger) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SlowRequestsBasedTrigger
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SlowRequestsBasedTrigger instances for property testing - lazily instantiated by
// SlowRequestsBasedTriggerGenerator()
var slowRequestsBasedTriggerGenerator gopter.Gen

// SlowRequestsBasedTriggerGenerator returns a generator of SlowRequestsBasedTrigger instances for property testing.
func SlowRequestsBasedTriggerGenerator() gopter.Gen {
	if slowRequestsBasedTriggerGenerator != nil {
		return slowRequestsBasedTriggerGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSlowRequestsBasedTrigger(generators)
	slowRequestsBasedTriggerGenerator = gen.Struct(reflect.TypeOf(SlowRequestsBasedTrigger{}), generators)

	return slowRequestsBasedTriggerGenerator
}

// AddIndependentPropertyGeneratorsForSlowRequestsBasedTrigger is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSlowRequestsBasedTrigger(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["TimeInterval"] = gen.PtrOf(gen.AlphaString())
	gens["TimeTaken"] = gen.PtrOf(gen.AlphaString())
}

func Test_SlowRequestsBasedTrigger_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SlowRequestsBasedTrigger_STATUS to SlowRequestsBasedTrigger_STATUS via AssignProperties_To_SlowRequestsBasedTrigger_STATUS & AssignProperties_From_SlowRequestsBasedTrigger_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSlowRequestsBasedTrigger_STATUS, SlowRequestsBasedTrigger_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSlowRequestsBasedTrigger_STATUS tests if a specific instance of SlowRequestsBasedTrigger_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSlowRequestsBasedTrigger_STATUS(subject SlowRequestsBasedTrigger_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.SlowRequestsBasedTrigger_STATUS
	err := copied.AssignProperties_To_SlowRequestsBasedTrigger_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SlowRequestsBasedTrigger_STATUS
	err = actual.AssignProperties_From_SlowRequestsBasedTrigger_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SlowRequestsBasedTrigger_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SlowRequestsBasedTrigger_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSlowRequestsBasedTrigger_STATUS, SlowRequestsBasedTrigger_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSlowRequestsBasedTrigger_STATUS runs a test to see if a specific instance of SlowRequestsBasedTrigger_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSlowRequestsBasedTrigger_STATUS(subject SlowRequestsBasedTrigger_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SlowRequestsBasedTrigger_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SlowRequestsBasedTrigger_STATUS instances for property testing - lazily instantiated by
// SlowRequestsBasedTrigger_STATUSGenerator()
var slowRequestsBasedTrigger_STATUSGenerator gopter.Gen

// SlowRequestsBasedTrigger_STATUSGenerator returns a generator of SlowRequestsBasedTrigger_STATUS instances for property testing.
func SlowRequestsBasedTrigger_STATUSGenerator() gopter.Gen {
	if slowRequestsBasedTrigger_STATUSGenerator != nil {
		return slowRequestsBasedTrigger_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSlowRequestsBasedTrigger_STATUS(generators)
	slowRequestsBasedTrigger_STATUSGenerator = gen.Struct(reflect.TypeOf(SlowRequestsBasedTrigger_STATUS{}), generators)

	return slowRequestsBasedTrigger_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSlowRequestsBasedTrigger_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSlowRequestsBasedTrigger_STATUS(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["TimeInterval"] = gen.PtrOf(gen.AlphaString())
	gens["TimeTaken"] = gen.PtrOf(gen.AlphaString())
}

func Test_StatusCodesBasedTrigger_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from StatusCodesBasedTrigger to StatusCodesBasedTrigger via AssignProperties_To_StatusCodesBasedTrigger & AssignProperties_From_StatusCodesBasedTrigger returns original",
		prop.ForAll(RunPropertyAssignmentTestForStatusCodesBasedTrigger, StatusCodesBasedTriggerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForStatusCodesBasedTrigger tests if a specific instance of StatusCodesBasedTrigger can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForStatusCodesBasedTrigger(subject StatusCodesBasedTrigger) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.StatusCodesBasedTrigger
	err := copied.AssignProperties_To_StatusCodesBasedTrigger(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual StatusCodesBasedTrigger
	err = actual.AssignProperties_From_StatusCodesBasedTrigger(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_StatusCodesBasedTrigger_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StatusCodesBasedTrigger via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStatusCodesBasedTrigger, StatusCodesBasedTriggerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStatusCodesBasedTrigger runs a test to see if a specific instance of StatusCodesBasedTrigger round trips to JSON and back losslessly
func RunJSONSerializationTestForStatusCodesBasedTrigger(subject StatusCodesBasedTrigger) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StatusCodesBasedTrigger
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StatusCodesBasedTrigger instances for property testing - lazily instantiated by
// StatusCodesBasedTriggerGenerator()
var statusCodesBasedTriggerGenerator gopter.Gen

// StatusCodesBasedTriggerGenerator returns a generator of StatusCodesBasedTrigger instances for property testing.
func StatusCodesBasedTriggerGenerator() gopter.Gen {
	if statusCodesBasedTriggerGenerator != nil {
		return statusCodesBasedTriggerGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStatusCodesBasedTrigger(generators)
	statusCodesBasedTriggerGenerator = gen.Struct(reflect.TypeOf(StatusCodesBasedTrigger{}), generators)

	return statusCodesBasedTriggerGenerator
}

// AddIndependentPropertyGeneratorsForStatusCodesBasedTrigger is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStatusCodesBasedTrigger(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.Int())
	gens["SubStatus"] = gen.PtrOf(gen.Int())
	gens["TimeInterval"] = gen.PtrOf(gen.AlphaString())
	gens["Win32Status"] = gen.PtrOf(gen.Int())
}

func Test_StatusCodesBasedTrigger_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from StatusCodesBasedTrigger_STATUS to StatusCodesBasedTrigger_STATUS via AssignProperties_To_StatusCodesBasedTrigger_STATUS & AssignProperties_From_StatusCodesBasedTrigger_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForStatusCodesBasedTrigger_STATUS, StatusCodesBasedTrigger_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForStatusCodesBasedTrigger_STATUS tests if a specific instance of StatusCodesBasedTrigger_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForStatusCodesBasedTrigger_STATUS(subject StatusCodesBasedTrigger_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.StatusCodesBasedTrigger_STATUS
	err := copied.AssignProperties_To_StatusCodesBasedTrigger_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual StatusCodesBasedTrigger_STATUS
	err = actual.AssignProperties_From_StatusCodesBasedTrigger_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_StatusCodesBasedTrigger_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StatusCodesBasedTrigger_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStatusCodesBasedTrigger_STATUS, StatusCodesBasedTrigger_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStatusCodesBasedTrigger_STATUS runs a test to see if a specific instance of StatusCodesBasedTrigger_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForStatusCodesBasedTrigger_STATUS(subject StatusCodesBasedTrigger_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StatusCodesBasedTrigger_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StatusCodesBasedTrigger_STATUS instances for property testing - lazily instantiated by
// StatusCodesBasedTrigger_STATUSGenerator()
var statusCodesBasedTrigger_STATUSGenerator gopter.Gen

// StatusCodesBasedTrigger_STATUSGenerator returns a generator of StatusCodesBasedTrigger_STATUS instances for property testing.
func StatusCodesBasedTrigger_STATUSGenerator() gopter.Gen {
	if statusCodesBasedTrigger_STATUSGenerator != nil {
		return statusCodesBasedTrigger_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStatusCodesBasedTrigger_STATUS(generators)
	statusCodesBasedTrigger_STATUSGenerator = gen.Struct(reflect.TypeOf(StatusCodesBasedTrigger_STATUS{}), generators)

	return statusCodesBasedTrigger_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForStatusCodesBasedTrigger_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStatusCodesBasedTrigger_STATUS(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.Int())
	gens["SubStatus"] = gen.PtrOf(gen.Int())
	gens["TimeInterval"] = gen.PtrOf(gen.AlphaString())
	gens["Win32Status"] = gen.PtrOf(gen.Int())
}

func Test_StatusCodesRangeBasedTrigger_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from StatusCodesRangeBasedTrigger to StatusCodesRangeBasedTrigger via AssignProperties_To_StatusCodesRangeBasedTrigger & AssignProperties_From_StatusCodesRangeBasedTrigger returns original",
		prop.ForAll(RunPropertyAssignmentTestForStatusCodesRangeBasedTrigger, StatusCodesRangeBasedTriggerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForStatusCodesRangeBasedTrigger tests if a specific instance of StatusCodesRangeBasedTrigger can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForStatusCodesRangeBasedTrigger(subject StatusCodesRangeBasedTrigger) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.StatusCodesRangeBasedTrigger
	err := copied.AssignProperties_To_StatusCodesRangeBasedTrigger(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual StatusCodesRangeBasedTrigger
	err = actual.AssignProperties_From_StatusCodesRangeBasedTrigger(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_StatusCodesRangeBasedTrigger_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StatusCodesRangeBasedTrigger via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStatusCodesRangeBasedTrigger, StatusCodesRangeBasedTriggerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStatusCodesRangeBasedTrigger runs a test to see if a specific instance of StatusCodesRangeBasedTrigger round trips to JSON and back losslessly
func RunJSONSerializationTestForStatusCodesRangeBasedTrigger(subject StatusCodesRangeBasedTrigger) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StatusCodesRangeBasedTrigger
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StatusCodesRangeBasedTrigger instances for property testing - lazily instantiated by
// StatusCodesRangeBasedTriggerGenerator()
var statusCodesRangeBasedTriggerGenerator gopter.Gen

// StatusCodesRangeBasedTriggerGenerator returns a generator of StatusCodesRangeBasedTrigger instances for property testing.
func StatusCodesRangeBasedTriggerGenerator() gopter.Gen {
	if statusCodesRangeBasedTriggerGenerator != nil {
		return statusCodesRangeBasedTriggerGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStatusCodesRangeBasedTrigger(generators)
	statusCodesRangeBasedTriggerGenerator = gen.Struct(reflect.TypeOf(StatusCodesRangeBasedTrigger{}), generators)

	return statusCodesRangeBasedTriggerGenerator
}

// AddIndependentPropertyGeneratorsForStatusCodesRangeBasedTrigger is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStatusCodesRangeBasedTrigger(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["StatusCodes"] = gen.PtrOf(gen.AlphaString())
	gens["TimeInterval"] = gen.PtrOf(gen.AlphaString())
}

func Test_StatusCodesRangeBasedTrigger_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from StatusCodesRangeBasedTrigger_STATUS to StatusCodesRangeBasedTrigger_STATUS via AssignProperties_To_StatusCodesRangeBasedTrigger_STATUS & AssignProperties_From_StatusCodesRangeBasedTrigger_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForStatusCodesRangeBasedTrigger_STATUS, StatusCodesRangeBasedTrigger_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForStatusCodesRangeBasedTrigger_STATUS tests if a specific instance of StatusCodesRangeBasedTrigger_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForStatusCodesRangeBasedTrigger_STATUS(subject StatusCodesRangeBasedTrigger_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.StatusCodesRangeBasedTrigger_STATUS
	err := copied.AssignProperties_To_StatusCodesRangeBasedTrigger_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual StatusCodesRangeBasedTrigger_STATUS
	err = actual.AssignProperties_From_StatusCodesRangeBasedTrigger_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_StatusCodesRangeBasedTrigger_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StatusCodesRangeBasedTrigger_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStatusCodesRangeBasedTrigger_STATUS, StatusCodesRangeBasedTrigger_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStatusCodesRangeBasedTrigger_STATUS runs a test to see if a specific instance of StatusCodesRangeBasedTrigger_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForStatusCodesRangeBasedTrigger_STATUS(subject StatusCodesRangeBasedTrigger_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StatusCodesRangeBasedTrigger_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StatusCodesRangeBasedTrigger_STATUS instances for property testing - lazily instantiated by
// StatusCodesRangeBasedTrigger_STATUSGenerator()
var statusCodesRangeBasedTrigger_STATUSGenerator gopter.Gen

// StatusCodesRangeBasedTrigger_STATUSGenerator returns a generator of StatusCodesRangeBasedTrigger_STATUS instances for property testing.
func StatusCodesRangeBasedTrigger_STATUSGenerator() gopter.Gen {
	if statusCodesRangeBasedTrigger_STATUSGenerator != nil {
		return statusCodesRangeBasedTrigger_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStatusCodesRangeBasedTrigger_STATUS(generators)
	statusCodesRangeBasedTrigger_STATUSGenerator = gen.Struct(reflect.TypeOf(StatusCodesRangeBasedTrigger_STATUS{}), generators)

	return statusCodesRangeBasedTrigger_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForStatusCodesRangeBasedTrigger_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStatusCodesRangeBasedTrigger_STATUS(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["StatusCodes"] = gen.PtrOf(gen.AlphaString())
	gens["TimeInterval"] = gen.PtrOf(gen.AlphaString())
}
