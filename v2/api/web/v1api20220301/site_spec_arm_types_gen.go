// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20220301

import "github.com/Azure/azure-service-operator/v2/pkg/genruntime"

type Site_Spec_ARM struct {
	// ExtendedLocation: Extended Location.
	ExtendedLocation *ExtendedLocation_ARM `json:"extendedLocation,omitempty"`

	// Identity: Managed service identity.
	Identity *ManagedServiceIdentity_ARM `json:"identity,omitempty"`

	// Kind: Kind of resource.
	Kind *string `json:"kind,omitempty"`

	// Location: Resource Location.
	Location *string `json:"location,omitempty"`
	Name     string  `json:"name,omitempty"`

	// Properties: Site resource specific properties
	Properties *Site_Properties_Spec_ARM `json:"properties,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`
}

var _ genruntime.ARMResourceSpec = &Site_Spec_ARM{}

// GetAPIVersion returns the ARM API version of the resource. This is always "2022-03-01"
func (site Site_Spec_ARM) GetAPIVersion() string {
	return "2022-03-01"
}

// GetName returns the Name of the resource
func (site *Site_Spec_ARM) GetName() string {
	return site.Name
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Web/sites"
func (site *Site_Spec_ARM) GetType() string {
	return "Microsoft.Web/sites"
}

// Managed service identity.
type ManagedServiceIdentity_ARM struct {
	// Type: Type of managed service identity.
	Type                   *ManagedServiceIdentity_Type_ARM           `json:"type,omitempty"`
	UserAssignedIdentities map[string]UserAssignedIdentityDetails_ARM `json:"userAssignedIdentities,omitempty"`
}

type Site_Properties_Spec_ARM struct {
	// ClientAffinityEnabled: <code>true</code> to enable client affinity; <code>false</code> to stop sending session affinity
	// cookies, which route client requests in the same session to the same instance. Default is <code>true</code>.
	ClientAffinityEnabled *bool `json:"clientAffinityEnabled,omitempty"`

	// ClientCertEnabled: <code>true</code> to enable client certificate authentication (TLS mutual authentication); otherwise,
	// <code>false</code>. Default is <code>false</code>.
	ClientCertEnabled *bool `json:"clientCertEnabled,omitempty"`

	// ClientCertExclusionPaths: client certificate authentication comma-separated exclusion paths
	ClientCertExclusionPaths *string `json:"clientCertExclusionPaths,omitempty"`

	// ClientCertMode: This composes with ClientCertEnabled setting.
	// - ClientCertEnabled: false means ClientCert is ignored.
	// - ClientCertEnabled: true and ClientCertMode: Required means ClientCert is required.
	// - ClientCertEnabled: true and ClientCertMode: Optional means ClientCert is optional or accepted.
	ClientCertMode *Site_Properties_ClientCertMode_Spec_ARM `json:"clientCertMode,omitempty"`

	// CloningInfo: If specified during app creation, the app is cloned from a source app.
	CloningInfo *CloningInfo_ARM `json:"cloningInfo,omitempty"`

	// ContainerSize: Size of the function container.
	ContainerSize *int `json:"containerSize,omitempty"`

	// CustomDomainVerificationId: Unique identifier that verifies the custom domains assigned to the app. Customer will add
	// this id to a txt record for verification.
	CustomDomainVerificationId *string `json:"customDomainVerificationId,omitempty"`

	// DailyMemoryTimeQuota: Maximum allowed daily memory-time quota (applicable on dynamic apps only).
	DailyMemoryTimeQuota *int `json:"dailyMemoryTimeQuota,omitempty"`

	// Enabled: <code>true</code> if the app is enabled; otherwise, <code>false</code>. Setting this value to false disables
	// the app (takes the app offline).
	Enabled *bool `json:"enabled,omitempty"`

	// HostNameSslStates: Hostname SSL states are used to manage the SSL bindings for app's hostnames.
	HostNameSslStates []HostNameSslState_ARM `json:"hostNameSslStates,omitempty"`

	// HostNamesDisabled: <code>true</code> to disable the public hostnames of the app; otherwise, <code>false</code>.
	// If <code>true</code>, the app is only accessible via API management process.
	HostNamesDisabled *bool `json:"hostNamesDisabled,omitempty"`

	// HostingEnvironmentProfile: App Service Environment to use for the app.
	HostingEnvironmentProfile *HostingEnvironmentProfile_ARM `json:"hostingEnvironmentProfile,omitempty"`

	// HttpsOnly: HttpsOnly: configures a web site to accept only https requests. Issues redirect for
	// http requests
	HttpsOnly *bool `json:"httpsOnly,omitempty"`

	// HyperV: Hyper-V sandbox.
	HyperV *bool `json:"hyperV,omitempty"`

	// IsXenon: Obsolete: Hyper-V sandbox.
	IsXenon *bool `json:"isXenon,omitempty"`

	// KeyVaultReferenceIdentity: Identity to use for Key Vault Reference authentication.
	KeyVaultReferenceIdentity *string `json:"keyVaultReferenceIdentity,omitempty"`

	// PublicNetworkAccess: Property to allow or block all public traffic. Allowed Values: 'Enabled', 'Disabled' or an empty
	// string.
	PublicNetworkAccess *string `json:"publicNetworkAccess,omitempty"`

	// RedundancyMode: Site redundancy mode
	RedundancyMode *Site_Properties_RedundancyMode_Spec_ARM `json:"redundancyMode,omitempty"`

	// Reserved: <code>true</code> if reserved; otherwise, <code>false</code>.
	Reserved *bool `json:"reserved,omitempty"`

	// ScmSiteAlsoStopped: <code>true</code> to stop SCM (KUDU) site when the app is stopped; otherwise, <code>false</code>.
	// The default is <code>false</code>.
	ScmSiteAlsoStopped *bool   `json:"scmSiteAlsoStopped,omitempty"`
	ServerFarmId       *string `json:"serverFarmId,omitempty"`

	// SiteConfig: Configuration of the app.
	SiteConfig *SiteConfig_ARM `json:"siteConfig,omitempty"`

	// StorageAccountRequired: Checks if Customer provided storage account is required
	StorageAccountRequired *bool   `json:"storageAccountRequired,omitempty"`
	VirtualNetworkSubnetId *string `json:"virtualNetworkSubnetId,omitempty"`

	// VnetContentShareEnabled: To enable accessing content over virtual network
	VnetContentShareEnabled *bool `json:"vnetContentShareEnabled,omitempty"`

	// VnetImagePullEnabled: To enable pulling image over Virtual Network
	VnetImagePullEnabled *bool `json:"vnetImagePullEnabled,omitempty"`

	// VnetRouteAllEnabled: Virtual Network Route All enabled. This causes all outbound traffic to have Virtual Network
	// Security Groups and User Defined Routes applied.
	VnetRouteAllEnabled *bool `json:"vnetRouteAllEnabled,omitempty"`
}

// Information needed for cloning operation.
type CloningInfo_ARM struct {
	// AppSettingsOverrides: Application setting overrides for cloned app. If specified, these settings override the settings
	// cloned
	// from source app. Otherwise, application settings from source app are retained.
	AppSettingsOverrides map[string]string `json:"appSettingsOverrides,omitempty"`

	// CloneCustomHostNames: <code>true</code> to clone custom hostnames from source app; otherwise, <code>false</code>.
	CloneCustomHostNames *bool `json:"cloneCustomHostNames,omitempty"`

	// CloneSourceControl: <code>true</code> to clone source control from source app; otherwise, <code>false</code>.
	CloneSourceControl *bool `json:"cloneSourceControl,omitempty"`

	// ConfigureLoadBalancing: <code>true</code> to configure load balancing for source and destination app.
	ConfigureLoadBalancing *bool `json:"configureLoadBalancing,omitempty"`

	// CorrelationId: Correlation ID of cloning operation. This ID ties multiple cloning operations
	// together to use the same snapshot.
	CorrelationId *string `json:"correlationId,omitempty"`

	// HostingEnvironment: App Service Environment.
	HostingEnvironment *string `json:"hostingEnvironment,omitempty"`

	// Overwrite: <code>true</code> to overwrite destination app; otherwise, <code>false</code>.
	Overwrite      *bool   `json:"overwrite,omitempty"`
	SourceWebAppId *string `json:"sourceWebAppId,omitempty"`

	// SourceWebAppLocation: Location of source app ex: West US or North Europe
	SourceWebAppLocation    *string `json:"sourceWebAppLocation,omitempty"`
	TrafficManagerProfileId *string `json:"trafficManagerProfileId,omitempty"`

	// TrafficManagerProfileName: Name of Traffic Manager profile to create. This is only needed if Traffic Manager profile
	// does not already exist.
	TrafficManagerProfileName *string `json:"trafficManagerProfileName,omitempty"`
}

// SSL-enabled hostname.
type HostNameSslState_ARM struct {
	// HostType: Indicates whether the hostname is a standard or repository hostname.
	HostType *HostNameSslState_HostType_ARM `json:"hostType,omitempty"`

	// Name: Hostname.
	Name *string `json:"name,omitempty"`

	// SslState: SSL type.
	SslState *HostNameSslState_SslState_ARM `json:"sslState,omitempty"`

	// Thumbprint: SSL certificate thumbprint.
	Thumbprint *string `json:"thumbprint,omitempty"`

	// ToUpdate: Set to <code>true</code> to update existing hostname.
	ToUpdate *bool `json:"toUpdate,omitempty"`

	// VirtualIP: Virtual IP address assigned to the hostname if IP based SSL is enabled.
	VirtualIP *string `json:"virtualIP,omitempty"`
}

// +kubebuilder:validation:Enum={"None","SystemAssigned","SystemAssigned, UserAssigned","UserAssigned"}
type ManagedServiceIdentity_Type_ARM string

const (
	ManagedServiceIdentity_Type_ARM_None                       = ManagedServiceIdentity_Type_ARM("None")
	ManagedServiceIdentity_Type_ARM_SystemAssigned             = ManagedServiceIdentity_Type_ARM("SystemAssigned")
	ManagedServiceIdentity_Type_ARM_SystemAssignedUserAssigned = ManagedServiceIdentity_Type_ARM("SystemAssigned, UserAssigned")
	ManagedServiceIdentity_Type_ARM_UserAssigned               = ManagedServiceIdentity_Type_ARM("UserAssigned")
)

// Mapping from string to ManagedServiceIdentity_Type_ARM
var managedServiceIdentity_Type_ARM_Values = map[string]ManagedServiceIdentity_Type_ARM{
	"none":                         ManagedServiceIdentity_Type_ARM_None,
	"systemassigned":               ManagedServiceIdentity_Type_ARM_SystemAssigned,
	"systemassigned, userassigned": ManagedServiceIdentity_Type_ARM_SystemAssignedUserAssigned,
	"userassigned":                 ManagedServiceIdentity_Type_ARM_UserAssigned,
}

// +kubebuilder:validation:Enum={"Optional","OptionalInteractiveUser","Required"}
type Site_Properties_ClientCertMode_Spec_ARM string

const (
	Site_Properties_ClientCertMode_Spec_ARM_Optional                = Site_Properties_ClientCertMode_Spec_ARM("Optional")
	Site_Properties_ClientCertMode_Spec_ARM_OptionalInteractiveUser = Site_Properties_ClientCertMode_Spec_ARM("OptionalInteractiveUser")
	Site_Properties_ClientCertMode_Spec_ARM_Required                = Site_Properties_ClientCertMode_Spec_ARM("Required")
)

// Mapping from string to Site_Properties_ClientCertMode_Spec_ARM
var site_Properties_ClientCertMode_Spec_ARM_Values = map[string]Site_Properties_ClientCertMode_Spec_ARM{
	"optional":                Site_Properties_ClientCertMode_Spec_ARM_Optional,
	"optionalinteractiveuser": Site_Properties_ClientCertMode_Spec_ARM_OptionalInteractiveUser,
	"required":                Site_Properties_ClientCertMode_Spec_ARM_Required,
}

// +kubebuilder:validation:Enum={"ActiveActive","Failover","GeoRedundant","Manual","None"}
type Site_Properties_RedundancyMode_Spec_ARM string

const (
	Site_Properties_RedundancyMode_Spec_ARM_ActiveActive = Site_Properties_RedundancyMode_Spec_ARM("ActiveActive")
	Site_Properties_RedundancyMode_Spec_ARM_Failover     = Site_Properties_RedundancyMode_Spec_ARM("Failover")
	Site_Properties_RedundancyMode_Spec_ARM_GeoRedundant = Site_Properties_RedundancyMode_Spec_ARM("GeoRedundant")
	Site_Properties_RedundancyMode_Spec_ARM_Manual       = Site_Properties_RedundancyMode_Spec_ARM("Manual")
	Site_Properties_RedundancyMode_Spec_ARM_None         = Site_Properties_RedundancyMode_Spec_ARM("None")
)

// Mapping from string to Site_Properties_RedundancyMode_Spec_ARM
var site_Properties_RedundancyMode_Spec_ARM_Values = map[string]Site_Properties_RedundancyMode_Spec_ARM{
	"activeactive": Site_Properties_RedundancyMode_Spec_ARM_ActiveActive,
	"failover":     Site_Properties_RedundancyMode_Spec_ARM_Failover,
	"georedundant": Site_Properties_RedundancyMode_Spec_ARM_GeoRedundant,
	"manual":       Site_Properties_RedundancyMode_Spec_ARM_Manual,
	"none":         Site_Properties_RedundancyMode_Spec_ARM_None,
}

// Configuration of an App Service app.
type SiteConfig_ARM struct {
	// AcrUseManagedIdentityCreds: Flag to use Managed Identity Creds for ACR pull
	AcrUseManagedIdentityCreds *bool `json:"acrUseManagedIdentityCreds,omitempty"`

	// AcrUserManagedIdentityID: If using user managed identity, the user managed identity ClientId
	AcrUserManagedIdentityID *string `json:"acrUserManagedIdentityID,omitempty"`

	// AlwaysOn: <code>true</code> if Always On is enabled; otherwise, <code>false</code>.
	AlwaysOn *bool `json:"alwaysOn,omitempty"`

	// ApiDefinition: Information about the formal API definition for the app.
	ApiDefinition *ApiDefinitionInfo_ARM `json:"apiDefinition,omitempty"`

	// ApiManagementConfig: Azure API management settings linked to the app.
	ApiManagementConfig *ApiManagementConfig_ARM `json:"apiManagementConfig,omitempty"`

	// AppCommandLine: App command line to launch.
	AppCommandLine *string `json:"appCommandLine,omitempty"`

	// AppSettings: Application settings.
	AppSettings []NameValuePair_ARM `json:"appSettings,omitempty"`

	// AutoHealEnabled: <code>true</code> if Auto Heal is enabled; otherwise, <code>false</code>.
	AutoHealEnabled *bool `json:"autoHealEnabled,omitempty"`

	// AutoHealRules: Auto Heal rules.
	AutoHealRules *AutoHealRules_ARM `json:"autoHealRules,omitempty"`

	// AutoSwapSlotName: Auto-swap slot name.
	AutoSwapSlotName *string `json:"autoSwapSlotName,omitempty"`

	// AzureStorageAccounts: List of Azure Storage Accounts.
	AzureStorageAccounts map[string]AzureStorageInfoValue_ARM `json:"azureStorageAccounts,omitempty"`

	// ConnectionStrings: Connection strings.
	ConnectionStrings []ConnStringInfo_ARM `json:"connectionStrings,omitempty"`

	// Cors: Cross-Origin Resource Sharing (CORS) settings.
	Cors *CorsSettings_ARM `json:"cors,omitempty"`

	// DefaultDocuments: Default documents.
	DefaultDocuments []string `json:"defaultDocuments,omitempty"`

	// DetailedErrorLoggingEnabled: <code>true</code> if detailed error logging is enabled; otherwise, <code>false</code>.
	DetailedErrorLoggingEnabled *bool `json:"detailedErrorLoggingEnabled,omitempty"`

	// DocumentRoot: Document root.
	DocumentRoot *string `json:"documentRoot,omitempty"`

	// Experiments: This is work around for polymorphic types.
	Experiments *Experiments_ARM `json:"experiments,omitempty"`

	// FtpsState: State of FTP / FTPS service
	FtpsState *SiteConfig_FtpsState_ARM `json:"ftpsState,omitempty"`

	// FunctionAppScaleLimit: Maximum number of workers that a site can scale out to.
	// This setting only applies to the Consumption and Elastic Premium Plans
	FunctionAppScaleLimit *int `json:"functionAppScaleLimit,omitempty"`

	// FunctionsRuntimeScaleMonitoringEnabled: Gets or sets a value indicating whether functions runtime scale monitoring is
	// enabled. When enabled,
	// the ScaleController will not monitor event sources directly, but will instead call to the
	// runtime to get scale status.
	FunctionsRuntimeScaleMonitoringEnabled *bool `json:"functionsRuntimeScaleMonitoringEnabled,omitempty"`

	// HandlerMappings: Handler mappings.
	HandlerMappings []HandlerMapping_ARM `json:"handlerMappings,omitempty"`

	// HealthCheckPath: Health check path
	HealthCheckPath *string `json:"healthCheckPath,omitempty"`

	// Http20Enabled: Http20Enabled: configures a web site to allow clients to connect over http2.0
	Http20Enabled *bool `json:"http20Enabled,omitempty"`

	// HttpLoggingEnabled: <code>true</code> if HTTP logging is enabled; otherwise, <code>false</code>.
	HttpLoggingEnabled *bool `json:"httpLoggingEnabled,omitempty"`

	// IpSecurityRestrictions: IP security restrictions for main.
	IpSecurityRestrictions []IpSecurityRestriction_ARM `json:"ipSecurityRestrictions,omitempty"`

	// JavaContainer: Java container.
	JavaContainer *string `json:"javaContainer,omitempty"`

	// JavaContainerVersion: Java container version.
	JavaContainerVersion *string `json:"javaContainerVersion,omitempty"`

	// JavaVersion: Java version.
	JavaVersion *string `json:"javaVersion,omitempty"`

	// KeyVaultReferenceIdentity: Identity to use for Key Vault Reference authentication.
	KeyVaultReferenceIdentity *string `json:"keyVaultReferenceIdentity,omitempty"`

	// Limits: Site limits.
	Limits *SiteLimits_ARM `json:"limits,omitempty"`

	// LinuxFxVersion: Linux App Framework and version
	LinuxFxVersion *string `json:"linuxFxVersion,omitempty"`

	// LoadBalancing: Site load balancing.
	LoadBalancing *SiteConfig_LoadBalancing_ARM `json:"loadBalancing,omitempty"`

	// LocalMySqlEnabled: <code>true</code> to enable local MySQL; otherwise, <code>false</code>.
	LocalMySqlEnabled *bool `json:"localMySqlEnabled,omitempty"`

	// LogsDirectorySizeLimit: HTTP logs directory size limit.
	LogsDirectorySizeLimit *int `json:"logsDirectorySizeLimit,omitempty"`

	// ManagedPipelineMode: Managed pipeline mode.
	ManagedPipelineMode *SiteConfig_ManagedPipelineMode_ARM `json:"managedPipelineMode,omitempty"`

	// ManagedServiceIdentityId: Managed Service Identity Id
	ManagedServiceIdentityId *int `json:"managedServiceIdentityId,omitempty"`

	// MinTlsVersion: MinTlsVersion: configures the minimum version of TLS required for SSL requests
	MinTlsVersion *SiteConfig_MinTlsVersion_ARM `json:"minTlsVersion,omitempty"`

	// MinimumElasticInstanceCount: Number of minimum instance count for a site
	// This setting only applies to the Elastic Plans
	MinimumElasticInstanceCount *int `json:"minimumElasticInstanceCount,omitempty"`

	// NetFrameworkVersion: .NET Framework version.
	NetFrameworkVersion *string `json:"netFrameworkVersion,omitempty"`

	// NodeVersion: Version of Node.js.
	NodeVersion *string `json:"nodeVersion,omitempty"`

	// NumberOfWorkers: Number of workers.
	NumberOfWorkers *int `json:"numberOfWorkers,omitempty"`

	// PhpVersion: Version of PHP.
	PhpVersion *string `json:"phpVersion,omitempty"`

	// PowerShellVersion: Version of PowerShell.
	PowerShellVersion *string `json:"powerShellVersion,omitempty"`

	// PreWarmedInstanceCount: Number of preWarmed instances.
	// This setting only applies to the Consumption and Elastic Plans
	PreWarmedInstanceCount *int `json:"preWarmedInstanceCount,omitempty"`

	// PublicNetworkAccess: Property to allow or block all public traffic.
	PublicNetworkAccess *string `json:"publicNetworkAccess,omitempty"`

	// PublishingUsername: Publishing user name.
	PublishingUsername *string `json:"publishingUsername,omitempty"`

	// Push: Push endpoint settings.
	Push *PushSettings_ARM `json:"push,omitempty"`

	// PythonVersion: Version of Python.
	PythonVersion *string `json:"pythonVersion,omitempty"`

	// RemoteDebuggingEnabled: <code>true</code> if remote debugging is enabled; otherwise, <code>false</code>.
	RemoteDebuggingEnabled *bool `json:"remoteDebuggingEnabled,omitempty"`

	// RemoteDebuggingVersion: Remote debugging version.
	RemoteDebuggingVersion *string `json:"remoteDebuggingVersion,omitempty"`

	// RequestTracingEnabled: <code>true</code> if request tracing is enabled; otherwise, <code>false</code>.
	RequestTracingEnabled *bool `json:"requestTracingEnabled,omitempty"`

	// RequestTracingExpirationTime: Request tracing expiration time.
	RequestTracingExpirationTime *string `json:"requestTracingExpirationTime,omitempty"`

	// ScmIpSecurityRestrictions: IP security restrictions for scm.
	ScmIpSecurityRestrictions []IpSecurityRestriction_ARM `json:"scmIpSecurityRestrictions,omitempty"`

	// ScmIpSecurityRestrictionsUseMain: IP security restrictions for scm to use main.
	ScmIpSecurityRestrictionsUseMain *bool `json:"scmIpSecurityRestrictionsUseMain,omitempty"`

	// ScmMinTlsVersion: ScmMinTlsVersion: configures the minimum version of TLS required for SSL requests for SCM site
	ScmMinTlsVersion *SiteConfig_ScmMinTlsVersion_ARM `json:"scmMinTlsVersion,omitempty"`

	// ScmType: SCM type.
	ScmType *SiteConfig_ScmType_ARM `json:"scmType,omitempty"`

	// TracingOptions: Tracing options.
	TracingOptions *string `json:"tracingOptions,omitempty"`

	// Use32BitWorkerProcess: <code>true</code> to use 32-bit worker process; otherwise, <code>false</code>.
	Use32BitWorkerProcess *bool `json:"use32BitWorkerProcess,omitempty"`

	// VirtualApplications: Virtual applications.
	VirtualApplications []VirtualApplication_ARM `json:"virtualApplications,omitempty"`

	// VnetName: Virtual Network name.
	VnetName *string `json:"vnetName,omitempty"`

	// VnetPrivatePortsCount: The number of private ports assigned to this app. These will be assigned dynamically on runtime.
	VnetPrivatePortsCount *int `json:"vnetPrivatePortsCount,omitempty"`

	// VnetRouteAllEnabled: Virtual Network Route All enabled. This causes all outbound traffic to have Virtual Network
	// Security Groups and User Defined Routes applied.
	VnetRouteAllEnabled *bool `json:"vnetRouteAllEnabled,omitempty"`

	// WebSocketsEnabled: <code>true</code> if WebSocket is enabled; otherwise, <code>false</code>.
	WebSocketsEnabled *bool `json:"webSocketsEnabled,omitempty"`

	// WebsiteTimeZone: Sets the time zone a site uses for generating timestamps. Compatible with Linux and Windows App
	// Service. Setting the WEBSITE_TIME_ZONE app setting takes precedence over this config. For Linux, expects tz database
	// values https://www.iana.org/time-zones (for a quick reference see
	// https://en.wikipedia.org/wiki/List_of_tz_database_time_zones). For Windows, expects one of the time zones listed under
	// HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Time Zones
	WebsiteTimeZone *string `json:"websiteTimeZone,omitempty"`

	// WindowsFxVersion: Xenon App Framework and version
	WindowsFxVersion *string `json:"windowsFxVersion,omitempty"`

	// XManagedServiceIdentityId: Explicit Managed Service Identity Id
	XManagedServiceIdentityId *int `json:"xManagedServiceIdentityId,omitempty"`
}

// Information about the user assigned identity for the resource
type UserAssignedIdentityDetails_ARM struct {
}

// Information about the formal API definition for the app.
type ApiDefinitionInfo_ARM struct {
	// Url: The URL of the API definition.
	Url *string `json:"url,omitempty"`
}

// Azure API management (APIM) configuration linked to the app.
type ApiManagementConfig_ARM struct {
	Id *string `json:"id,omitempty"`
}

// Rules that can be defined for auto-heal.
type AutoHealRules_ARM struct {
	// Actions: Actions to be executed when a rule is triggered.
	Actions *AutoHealActions_ARM `json:"actions,omitempty"`

	// Triggers: Conditions that describe when to execute the auto-heal actions.
	Triggers *AutoHealTriggers_ARM `json:"triggers,omitempty"`
}

// Azure Files or Blob Storage access information value for dictionary storage.
type AzureStorageInfoValue_ARM struct {
	// AccessKey: Access key for the storage account.
	AccessKey *string `json:"accessKey,omitempty"`

	// AccountName: Name of the storage account.
	AccountName *string `json:"accountName,omitempty"`

	// MountPath: Path to mount the storage within the site's runtime environment.
	MountPath *string `json:"mountPath,omitempty"`

	// ShareName: Name of the file share (container name, for Blob storage).
	ShareName *string `json:"shareName,omitempty"`

	// Type: Type of storage.
	Type *AzureStorageInfoValue_Type_ARM `json:"type,omitempty"`
}

// Database connection string information.
type ConnStringInfo_ARM struct {
	// ConnectionString: Connection string value.
	ConnectionString *string `json:"connectionString,omitempty"`

	// Name: Name of connection string.
	Name *string `json:"name,omitempty"`

	// Type: Type of database.
	Type *ConnStringInfo_Type_ARM `json:"type,omitempty"`
}

// Cross-Origin Resource Sharing (CORS) settings for the app.
type CorsSettings_ARM struct {
	// AllowedOrigins: Gets or sets the list of origins that should be allowed to make cross-origin
	// calls (for example: http://example.com:12345). Use "*" to allow all.
	AllowedOrigins []string `json:"allowedOrigins,omitempty"`

	// SupportCredentials: Gets or sets whether CORS requests with credentials are allowed. See
	// https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Requests_with_credentials
	// for more details.
	SupportCredentials *bool `json:"supportCredentials,omitempty"`
}

// Routing rules in production experiments.
type Experiments_ARM struct {
	// RampUpRules: List of ramp-up rules.
	RampUpRules []RampUpRule_ARM `json:"rampUpRules,omitempty"`
}

// The IIS handler mappings used to define which handler processes HTTP requests with certain extension.
// For example, it
// is used to configure php-cgi.exe process to handle all HTTP requests with *.php extension.
type HandlerMapping_ARM struct {
	// Arguments: Command-line arguments to be passed to the script processor.
	Arguments *string `json:"arguments,omitempty"`

	// Extension: Requests with this extension will be handled using the specified FastCGI application.
	Extension *string `json:"extension,omitempty"`

	// ScriptProcessor: The absolute path to the FastCGI application.
	ScriptProcessor *string `json:"scriptProcessor,omitempty"`
}

// +kubebuilder:validation:Enum={"Repository","Standard"}
type HostNameSslState_HostType_ARM string

const (
	HostNameSslState_HostType_ARM_Repository = HostNameSslState_HostType_ARM("Repository")
	HostNameSslState_HostType_ARM_Standard   = HostNameSslState_HostType_ARM("Standard")
)

// Mapping from string to HostNameSslState_HostType_ARM
var hostNameSslState_HostType_ARM_Values = map[string]HostNameSslState_HostType_ARM{
	"repository": HostNameSslState_HostType_ARM_Repository,
	"standard":   HostNameSslState_HostType_ARM_Standard,
}

// +kubebuilder:validation:Enum={"Disabled","IpBasedEnabled","SniEnabled"}
type HostNameSslState_SslState_ARM string

const (
	HostNameSslState_SslState_ARM_Disabled       = HostNameSslState_SslState_ARM("Disabled")
	HostNameSslState_SslState_ARM_IpBasedEnabled = HostNameSslState_SslState_ARM("IpBasedEnabled")
	HostNameSslState_SslState_ARM_SniEnabled     = HostNameSslState_SslState_ARM("SniEnabled")
)

// Mapping from string to HostNameSslState_SslState_ARM
var hostNameSslState_SslState_ARM_Values = map[string]HostNameSslState_SslState_ARM{
	"disabled":       HostNameSslState_SslState_ARM_Disabled,
	"ipbasedenabled": HostNameSslState_SslState_ARM_IpBasedEnabled,
	"snienabled":     HostNameSslState_SslState_ARM_SniEnabled,
}

// IP security restriction on an app.
type IpSecurityRestriction_ARM struct {
	// Action: Allow or Deny access for this IP range.
	Action *string `json:"action,omitempty"`

	// Description: IP restriction rule description.
	Description *string `json:"description,omitempty"`

	// Headers: IP restriction rule headers.
	// X-Forwarded-Host (https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Host#Examples).
	// The matching logic is ..
	// - If the property is null or empty (default), all hosts(or lack of) are allowed.
	// - A value is compared using ordinal-ignore-case (excluding port number).
	// - Subdomain wildcards are permitted but don't match the root domain. For example, *.contoso.com matches the subdomain
	// foo.contoso.com
	// but not the root domain contoso.com or multi-level foo.bar.contoso.com
	// - Unicode host names are allowed but are converted to Punycode for matching.
	// X-Forwarded-For (https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For#Examples).
	// The matching logic is ..
	// - If the property is null or empty (default), any forwarded-for chains (or lack of) are allowed.
	// - If any address (excluding port number) in the chain (comma separated) matches the CIDR defined by the property.
	// X-Azure-FDID and X-FD-HealthProbe.
	// The matching logic is exact match.
	Headers map[string][]string `json:"headers,omitempty"`

	// IpAddress: IP address the security restriction is valid for.
	// It can be in form of pure ipv4 address (required SubnetMask property) or
	// CIDR notation such as ipv4/mask (leading bit match). For CIDR,
	// SubnetMask property must not be specified.
	IpAddress *string `json:"ipAddress,omitempty"`

	// Name: IP restriction rule name.
	Name *string `json:"name,omitempty"`

	// Priority: Priority of IP restriction rule.
	Priority *int `json:"priority,omitempty"`

	// SubnetMask: Subnet mask for the range of IP addresses the restriction is valid for.
	SubnetMask *string `json:"subnetMask,omitempty"`

	// SubnetTrafficTag: (internal) Subnet traffic tag
	SubnetTrafficTag *int `json:"subnetTrafficTag,omitempty"`

	// Tag: Defines what this IP filter will be used for. This is to support IP filtering on proxies.
	Tag                  *IpSecurityRestriction_Tag_ARM `json:"tag,omitempty"`
	VnetSubnetResourceId *string                        `json:"vnetSubnetResourceId,omitempty"`

	// VnetTrafficTag: (internal) Vnet traffic tag
	VnetTrafficTag *int `json:"vnetTrafficTag,omitempty"`
}

// Name value pair.
type NameValuePair_ARM struct {
	// Name: Pair name.
	Name *string `json:"name,omitempty"`

	// Value: Pair value.
	Value *string `json:"value,omitempty"`
}

// Push settings for the App.
type PushSettings_ARM struct {
	// Kind: Kind of resource.
	Kind *string `json:"kind,omitempty"`

	// Properties: PushSettings resource specific properties
	Properties *PushSettings_Properties_ARM `json:"properties,omitempty"`
}

// +kubebuilder:validation:Enum={"AllAllowed","Disabled","FtpsOnly"}
type SiteConfig_FtpsState_ARM string

const (
	SiteConfig_FtpsState_ARM_AllAllowed = SiteConfig_FtpsState_ARM("AllAllowed")
	SiteConfig_FtpsState_ARM_Disabled   = SiteConfig_FtpsState_ARM("Disabled")
	SiteConfig_FtpsState_ARM_FtpsOnly   = SiteConfig_FtpsState_ARM("FtpsOnly")
)

// Mapping from string to SiteConfig_FtpsState_ARM
var siteConfig_FtpsState_ARM_Values = map[string]SiteConfig_FtpsState_ARM{
	"allallowed": SiteConfig_FtpsState_ARM_AllAllowed,
	"disabled":   SiteConfig_FtpsState_ARM_Disabled,
	"ftpsonly":   SiteConfig_FtpsState_ARM_FtpsOnly,
}

// +kubebuilder:validation:Enum={"LeastRequests","LeastResponseTime","PerSiteRoundRobin","RequestHash","WeightedRoundRobin","WeightedTotalTraffic"}
type SiteConfig_LoadBalancing_ARM string

const (
	SiteConfig_LoadBalancing_ARM_LeastRequests        = SiteConfig_LoadBalancing_ARM("LeastRequests")
	SiteConfig_LoadBalancing_ARM_LeastResponseTime    = SiteConfig_LoadBalancing_ARM("LeastResponseTime")
	SiteConfig_LoadBalancing_ARM_PerSiteRoundRobin    = SiteConfig_LoadBalancing_ARM("PerSiteRoundRobin")
	SiteConfig_LoadBalancing_ARM_RequestHash          = SiteConfig_LoadBalancing_ARM("RequestHash")
	SiteConfig_LoadBalancing_ARM_WeightedRoundRobin   = SiteConfig_LoadBalancing_ARM("WeightedRoundRobin")
	SiteConfig_LoadBalancing_ARM_WeightedTotalTraffic = SiteConfig_LoadBalancing_ARM("WeightedTotalTraffic")
)

// Mapping from string to SiteConfig_LoadBalancing_ARM
var siteConfig_LoadBalancing_ARM_Values = map[string]SiteConfig_LoadBalancing_ARM{
	"leastrequests":        SiteConfig_LoadBalancing_ARM_LeastRequests,
	"leastresponsetime":    SiteConfig_LoadBalancing_ARM_LeastResponseTime,
	"persiteroundrobin":    SiteConfig_LoadBalancing_ARM_PerSiteRoundRobin,
	"requesthash":          SiteConfig_LoadBalancing_ARM_RequestHash,
	"weightedroundrobin":   SiteConfig_LoadBalancing_ARM_WeightedRoundRobin,
	"weightedtotaltraffic": SiteConfig_LoadBalancing_ARM_WeightedTotalTraffic,
}

// +kubebuilder:validation:Enum={"Classic","Integrated"}
type SiteConfig_ManagedPipelineMode_ARM string

const (
	SiteConfig_ManagedPipelineMode_ARM_Classic    = SiteConfig_ManagedPipelineMode_ARM("Classic")
	SiteConfig_ManagedPipelineMode_ARM_Integrated = SiteConfig_ManagedPipelineMode_ARM("Integrated")
)

// Mapping from string to SiteConfig_ManagedPipelineMode_ARM
var siteConfig_ManagedPipelineMode_ARM_Values = map[string]SiteConfig_ManagedPipelineMode_ARM{
	"classic":    SiteConfig_ManagedPipelineMode_ARM_Classic,
	"integrated": SiteConfig_ManagedPipelineMode_ARM_Integrated,
}

// +kubebuilder:validation:Enum={"1.0","1.1","1.2"}
type SiteConfig_MinTlsVersion_ARM string

const (
	SiteConfig_MinTlsVersion_ARM_10 = SiteConfig_MinTlsVersion_ARM("1.0")
	SiteConfig_MinTlsVersion_ARM_11 = SiteConfig_MinTlsVersion_ARM("1.1")
	SiteConfig_MinTlsVersion_ARM_12 = SiteConfig_MinTlsVersion_ARM("1.2")
)

// Mapping from string to SiteConfig_MinTlsVersion_ARM
var siteConfig_MinTlsVersion_ARM_Values = map[string]SiteConfig_MinTlsVersion_ARM{
	"1.0": SiteConfig_MinTlsVersion_ARM_10,
	"1.1": SiteConfig_MinTlsVersion_ARM_11,
	"1.2": SiteConfig_MinTlsVersion_ARM_12,
}

// +kubebuilder:validation:Enum={"1.0","1.1","1.2"}
type SiteConfig_ScmMinTlsVersion_ARM string

const (
	SiteConfig_ScmMinTlsVersion_ARM_10 = SiteConfig_ScmMinTlsVersion_ARM("1.0")
	SiteConfig_ScmMinTlsVersion_ARM_11 = SiteConfig_ScmMinTlsVersion_ARM("1.1")
	SiteConfig_ScmMinTlsVersion_ARM_12 = SiteConfig_ScmMinTlsVersion_ARM("1.2")
)

// Mapping from string to SiteConfig_ScmMinTlsVersion_ARM
var siteConfig_ScmMinTlsVersion_ARM_Values = map[string]SiteConfig_ScmMinTlsVersion_ARM{
	"1.0": SiteConfig_ScmMinTlsVersion_ARM_10,
	"1.1": SiteConfig_ScmMinTlsVersion_ARM_11,
	"1.2": SiteConfig_ScmMinTlsVersion_ARM_12,
}

// +kubebuilder:validation:Enum={"BitbucketGit","BitbucketHg","CodePlexGit","CodePlexHg","Dropbox","ExternalGit","ExternalHg","GitHub","LocalGit","None","OneDrive","Tfs","VSO","VSTSRM"}
type SiteConfig_ScmType_ARM string

const (
	SiteConfig_ScmType_ARM_BitbucketGit = SiteConfig_ScmType_ARM("BitbucketGit")
	SiteConfig_ScmType_ARM_BitbucketHg  = SiteConfig_ScmType_ARM("BitbucketHg")
	SiteConfig_ScmType_ARM_CodePlexGit  = SiteConfig_ScmType_ARM("CodePlexGit")
	SiteConfig_ScmType_ARM_CodePlexHg   = SiteConfig_ScmType_ARM("CodePlexHg")
	SiteConfig_ScmType_ARM_Dropbox      = SiteConfig_ScmType_ARM("Dropbox")
	SiteConfig_ScmType_ARM_ExternalGit  = SiteConfig_ScmType_ARM("ExternalGit")
	SiteConfig_ScmType_ARM_ExternalHg   = SiteConfig_ScmType_ARM("ExternalHg")
	SiteConfig_ScmType_ARM_GitHub       = SiteConfig_ScmType_ARM("GitHub")
	SiteConfig_ScmType_ARM_LocalGit     = SiteConfig_ScmType_ARM("LocalGit")
	SiteConfig_ScmType_ARM_None         = SiteConfig_ScmType_ARM("None")
	SiteConfig_ScmType_ARM_OneDrive     = SiteConfig_ScmType_ARM("OneDrive")
	SiteConfig_ScmType_ARM_Tfs          = SiteConfig_ScmType_ARM("Tfs")
	SiteConfig_ScmType_ARM_VSO          = SiteConfig_ScmType_ARM("VSO")
	SiteConfig_ScmType_ARM_VSTSRM       = SiteConfig_ScmType_ARM("VSTSRM")
)

// Mapping from string to SiteConfig_ScmType_ARM
var siteConfig_ScmType_ARM_Values = map[string]SiteConfig_ScmType_ARM{
	"bitbucketgit": SiteConfig_ScmType_ARM_BitbucketGit,
	"bitbuckethg":  SiteConfig_ScmType_ARM_BitbucketHg,
	"codeplexgit":  SiteConfig_ScmType_ARM_CodePlexGit,
	"codeplexhg":   SiteConfig_ScmType_ARM_CodePlexHg,
	"dropbox":      SiteConfig_ScmType_ARM_Dropbox,
	"externalgit":  SiteConfig_ScmType_ARM_ExternalGit,
	"externalhg":   SiteConfig_ScmType_ARM_ExternalHg,
	"github":       SiteConfig_ScmType_ARM_GitHub,
	"localgit":     SiteConfig_ScmType_ARM_LocalGit,
	"none":         SiteConfig_ScmType_ARM_None,
	"onedrive":     SiteConfig_ScmType_ARM_OneDrive,
	"tfs":          SiteConfig_ScmType_ARM_Tfs,
	"vso":          SiteConfig_ScmType_ARM_VSO,
	"vstsrm":       SiteConfig_ScmType_ARM_VSTSRM,
}

// Metric limits set on an app.
type SiteLimits_ARM struct {
	// MaxDiskSizeInMb: Maximum allowed disk size usage in MB.
	MaxDiskSizeInMb *int `json:"maxDiskSizeInMb,omitempty"`

	// MaxMemoryInMb: Maximum allowed memory usage in MB.
	MaxMemoryInMb *int `json:"maxMemoryInMb,omitempty"`

	// MaxPercentageCpu: Maximum allowed CPU usage percentage.
	MaxPercentageCpu *float64 `json:"maxPercentageCpu,omitempty"`
}

// Virtual application in an app.
type VirtualApplication_ARM struct {
	// PhysicalPath: Physical path.
	PhysicalPath *string `json:"physicalPath,omitempty"`

	// PreloadEnabled: <code>true</code> if preloading is enabled; otherwise, <code>false</code>.
	PreloadEnabled *bool `json:"preloadEnabled,omitempty"`

	// VirtualDirectories: Virtual directories for virtual application.
	VirtualDirectories []VirtualDirectory_ARM `json:"virtualDirectories,omitempty"`

	// VirtualPath: Virtual path.
	VirtualPath *string `json:"virtualPath,omitempty"`
}

// Actions which to take by the auto-heal module when a rule is triggered.
type AutoHealActions_ARM struct {
	// ActionType: Predefined action to be taken.
	ActionType *AutoHealActions_ActionType_ARM `json:"actionType,omitempty"`

	// CustomAction: Custom action to be taken.
	CustomAction *AutoHealCustomAction_ARM `json:"customAction,omitempty"`

	// MinProcessExecutionTime: Minimum time the process must execute
	// before taking the action
	MinProcessExecutionTime *string `json:"minProcessExecutionTime,omitempty"`
}

// Triggers for auto-heal.
type AutoHealTriggers_ARM struct {
	// PrivateBytesInKB: A rule based on private bytes.
	PrivateBytesInKB *int `json:"privateBytesInKB,omitempty"`

	// Requests: A rule based on total requests.
	Requests *RequestsBasedTrigger_ARM `json:"requests,omitempty"`

	// SlowRequests: A rule based on request execution time.
	SlowRequests *SlowRequestsBasedTrigger_ARM `json:"slowRequests,omitempty"`

	// SlowRequestsWithPath: A rule based on multiple Slow Requests Rule with path
	SlowRequestsWithPath []SlowRequestsBasedTrigger_ARM `json:"slowRequestsWithPath,omitempty"`

	// StatusCodes: A rule based on status codes.
	StatusCodes []StatusCodesBasedTrigger_ARM `json:"statusCodes,omitempty"`

	// StatusCodesRange: A rule based on status codes ranges.
	StatusCodesRange []StatusCodesRangeBasedTrigger_ARM `json:"statusCodesRange,omitempty"`
}

// +kubebuilder:validation:Enum={"AzureBlob","AzureFiles"}
type AzureStorageInfoValue_Type_ARM string

const (
	AzureStorageInfoValue_Type_ARM_AzureBlob  = AzureStorageInfoValue_Type_ARM("AzureBlob")
	AzureStorageInfoValue_Type_ARM_AzureFiles = AzureStorageInfoValue_Type_ARM("AzureFiles")
)

// Mapping from string to AzureStorageInfoValue_Type_ARM
var azureStorageInfoValue_Type_ARM_Values = map[string]AzureStorageInfoValue_Type_ARM{
	"azureblob":  AzureStorageInfoValue_Type_ARM_AzureBlob,
	"azurefiles": AzureStorageInfoValue_Type_ARM_AzureFiles,
}

// +kubebuilder:validation:Enum={"ApiHub","Custom","DocDb","EventHub","MySql","NotificationHub","PostgreSQL","RedisCache","SQLAzure","SQLServer","ServiceBus"}
type ConnStringInfo_Type_ARM string

const (
	ConnStringInfo_Type_ARM_ApiHub          = ConnStringInfo_Type_ARM("ApiHub")
	ConnStringInfo_Type_ARM_Custom          = ConnStringInfo_Type_ARM("Custom")
	ConnStringInfo_Type_ARM_DocDb           = ConnStringInfo_Type_ARM("DocDb")
	ConnStringInfo_Type_ARM_EventHub        = ConnStringInfo_Type_ARM("EventHub")
	ConnStringInfo_Type_ARM_MySql           = ConnStringInfo_Type_ARM("MySql")
	ConnStringInfo_Type_ARM_NotificationHub = ConnStringInfo_Type_ARM("NotificationHub")
	ConnStringInfo_Type_ARM_PostgreSQL      = ConnStringInfo_Type_ARM("PostgreSQL")
	ConnStringInfo_Type_ARM_RedisCache      = ConnStringInfo_Type_ARM("RedisCache")
	ConnStringInfo_Type_ARM_SQLAzure        = ConnStringInfo_Type_ARM("SQLAzure")
	ConnStringInfo_Type_ARM_SQLServer       = ConnStringInfo_Type_ARM("SQLServer")
	ConnStringInfo_Type_ARM_ServiceBus      = ConnStringInfo_Type_ARM("ServiceBus")
)

// Mapping from string to ConnStringInfo_Type_ARM
var connStringInfo_Type_ARM_Values = map[string]ConnStringInfo_Type_ARM{
	"apihub":          ConnStringInfo_Type_ARM_ApiHub,
	"custom":          ConnStringInfo_Type_ARM_Custom,
	"docdb":           ConnStringInfo_Type_ARM_DocDb,
	"eventhub":        ConnStringInfo_Type_ARM_EventHub,
	"mysql":           ConnStringInfo_Type_ARM_MySql,
	"notificationhub": ConnStringInfo_Type_ARM_NotificationHub,
	"postgresql":      ConnStringInfo_Type_ARM_PostgreSQL,
	"rediscache":      ConnStringInfo_Type_ARM_RedisCache,
	"sqlazure":        ConnStringInfo_Type_ARM_SQLAzure,
	"sqlserver":       ConnStringInfo_Type_ARM_SQLServer,
	"servicebus":      ConnStringInfo_Type_ARM_ServiceBus,
}

// +kubebuilder:validation:Enum={"Default","ServiceTag","XffProxy"}
type IpSecurityRestriction_Tag_ARM string

const (
	IpSecurityRestriction_Tag_ARM_Default    = IpSecurityRestriction_Tag_ARM("Default")
	IpSecurityRestriction_Tag_ARM_ServiceTag = IpSecurityRestriction_Tag_ARM("ServiceTag")
	IpSecurityRestriction_Tag_ARM_XffProxy   = IpSecurityRestriction_Tag_ARM("XffProxy")
)

// Mapping from string to IpSecurityRestriction_Tag_ARM
var ipSecurityRestriction_Tag_ARM_Values = map[string]IpSecurityRestriction_Tag_ARM{
	"default":    IpSecurityRestriction_Tag_ARM_Default,
	"servicetag": IpSecurityRestriction_Tag_ARM_ServiceTag,
	"xffproxy":   IpSecurityRestriction_Tag_ARM_XffProxy,
}

type PushSettings_Properties_ARM struct {
	// DynamicTagsJson: Gets or sets a JSON string containing a list of dynamic tags that will be evaluated from user claims in
	// the push registration endpoint.
	DynamicTagsJson *string `json:"dynamicTagsJson,omitempty"`

	// IsPushEnabled: Gets or sets a flag indicating whether the Push endpoint is enabled.
	IsPushEnabled *bool `json:"isPushEnabled,omitempty"`

	// TagWhitelistJson: Gets or sets a JSON string containing a list of tags that are in the allowed list for use by the push
	// registration endpoint.
	TagWhitelistJson *string `json:"tagWhitelistJson,omitempty"`

	// TagsRequiringAuth: Gets or sets a JSON string containing a list of tags that require user authentication to be used in
	// the push registration endpoint.
	// Tags can consist of alphanumeric characters and the following:
	// '_', '@', '#', '.', ':', '-'.
	// Validation should be performed at the PushRequestHandler.
	TagsRequiringAuth *string `json:"tagsRequiringAuth,omitempty"`
}

// Routing rules for ramp up testing. This rule allows to redirect static traffic % to a slot or to gradually change
// routing % based on performance.
type RampUpRule_ARM struct {
	// ActionHostName: Hostname of a slot to which the traffic will be redirected if decided to. E.g.
	// myapp-stage.azurewebsites.net.
	ActionHostName *string `json:"actionHostName,omitempty"`

	// ChangeDecisionCallbackUrl: Custom decision algorithm can be provided in TiPCallback site extension which URL can be
	// specified. See TiPCallback site extension for the scaffold and contracts.
	// https://www.siteextensions.net/packages/TiPCallback/
	ChangeDecisionCallbackUrl *string `json:"changeDecisionCallbackUrl,omitempty"`

	// ChangeIntervalInMinutes: Specifies interval in minutes to reevaluate ReroutePercentage.
	ChangeIntervalInMinutes *int `json:"changeIntervalInMinutes,omitempty"`

	// ChangeStep: In auto ramp up scenario this is the step to add/remove from <code>ReroutePercentage</code> until it reaches
	// \n<code>MinReroutePercentage</code> or
	// <code>MaxReroutePercentage</code>. Site metrics are checked every N minutes specified in
	// <code>ChangeIntervalInMinutes</code>.\nCustom decision algorithm
	// can be provided in TiPCallback site extension which URL can be specified in <code>ChangeDecisionCallbackUrl</code>.
	ChangeStep *float64 `json:"changeStep,omitempty"`

	// MaxReroutePercentage: Specifies upper boundary below which ReroutePercentage will stay.
	MaxReroutePercentage *float64 `json:"maxReroutePercentage,omitempty"`

	// MinReroutePercentage: Specifies lower boundary above which ReroutePercentage will stay.
	MinReroutePercentage *float64 `json:"minReroutePercentage,omitempty"`

	// Name: Name of the routing rule. The recommended name would be to point to the slot which will receive the traffic in the
	// experiment.
	Name *string `json:"name,omitempty"`

	// ReroutePercentage: Percentage of the traffic which will be redirected to <code>ActionHostName</code>.
	ReroutePercentage *float64 `json:"reroutePercentage,omitempty"`
}

// Directory for virtual application.
type VirtualDirectory_ARM struct {
	// PhysicalPath: Physical path.
	PhysicalPath *string `json:"physicalPath,omitempty"`

	// VirtualPath: Path to virtual application.
	VirtualPath *string `json:"virtualPath,omitempty"`
}

// +kubebuilder:validation:Enum={"CustomAction","LogEvent","Recycle"}
type AutoHealActions_ActionType_ARM string

const (
	AutoHealActions_ActionType_ARM_CustomAction = AutoHealActions_ActionType_ARM("CustomAction")
	AutoHealActions_ActionType_ARM_LogEvent     = AutoHealActions_ActionType_ARM("LogEvent")
	AutoHealActions_ActionType_ARM_Recycle      = AutoHealActions_ActionType_ARM("Recycle")
)

// Mapping from string to AutoHealActions_ActionType_ARM
var autoHealActions_ActionType_ARM_Values = map[string]AutoHealActions_ActionType_ARM{
	"customaction": AutoHealActions_ActionType_ARM_CustomAction,
	"logevent":     AutoHealActions_ActionType_ARM_LogEvent,
	"recycle":      AutoHealActions_ActionType_ARM_Recycle,
}

// Custom action to be executed
// when an auto heal rule is triggered.
type AutoHealCustomAction_ARM struct {
	// Exe: Executable to be run.
	Exe *string `json:"exe,omitempty"`

	// Parameters: Parameters for the executable.
	Parameters *string `json:"parameters,omitempty"`
}

// Trigger based on total requests.
type RequestsBasedTrigger_ARM struct {
	// Count: Request Count.
	Count *int `json:"count,omitempty"`

	// TimeInterval: Time interval.
	TimeInterval *string `json:"timeInterval,omitempty"`
}

// Trigger based on request execution time.
type SlowRequestsBasedTrigger_ARM struct {
	// Count: Request Count.
	Count *int `json:"count,omitempty"`

	// Path: Request Path.
	Path *string `json:"path,omitempty"`

	// TimeInterval: Time interval.
	TimeInterval *string `json:"timeInterval,omitempty"`

	// TimeTaken: Time taken.
	TimeTaken *string `json:"timeTaken,omitempty"`
}

// Trigger based on status code.
type StatusCodesBasedTrigger_ARM struct {
	// Count: Request Count.
	Count *int `json:"count,omitempty"`

	// Path: Request Path
	Path *string `json:"path,omitempty"`

	// Status: HTTP status code.
	Status *int `json:"status,omitempty"`

	// SubStatus: Request Sub Status.
	SubStatus *int `json:"subStatus,omitempty"`

	// TimeInterval: Time interval.
	TimeInterval *string `json:"timeInterval,omitempty"`

	// Win32Status: Win32 error code.
	Win32Status *int `json:"win32Status,omitempty"`
}

// Trigger based on range of status codes.
type StatusCodesRangeBasedTrigger_ARM struct {
	// Count: Request Count.
	Count *int    `json:"count,omitempty"`
	Path  *string `json:"path,omitempty"`

	// StatusCodes: HTTP status code.
	StatusCodes *string `json:"statusCodes,omitempty"`

	// TimeInterval: Time interval.
	TimeInterval *string `json:"timeInterval,omitempty"`
}
