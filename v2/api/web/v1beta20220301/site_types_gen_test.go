// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20220301

import (
	"encoding/json"
	v20220301s "github.com/Azure/azure-service-operator/v2/api/web/v1beta20220301storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_Site_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	parameters.MinSuccessfulTests = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Site to hub returns original",
		prop.ForAll(RunResourceConversionTestForSite, SiteGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForSite tests if a specific instance of Site round trips to the hub storage version and back losslessly
func RunResourceConversionTestForSite(subject Site) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v20220301s.Site
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual Site
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Site_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Site to Site via AssignPropertiesToSite & AssignPropertiesFromSite returns original",
		prop.ForAll(RunPropertyAssignmentTestForSite, SiteGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSite tests if a specific instance of Site can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForSite(subject Site) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.Site
	err := copied.AssignPropertiesToSite(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Site
	err = actual.AssignPropertiesFromSite(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Site_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Site via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSite, SiteGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSite runs a test to see if a specific instance of Site round trips to JSON and back losslessly
func RunJSONSerializationTestForSite(subject Site) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Site
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Site instances for property testing - lazily instantiated by SiteGenerator()
var siteGenerator gopter.Gen

// SiteGenerator returns a generator of Site instances for property testing.
func SiteGenerator() gopter.Gen {
	if siteGenerator != nil {
		return siteGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForSite(generators)
	siteGenerator = gen.Struct(reflect.TypeOf(Site{}), generators)

	return siteGenerator
}

// AddRelatedPropertyGeneratorsForSite is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSite(gens map[string]gopter.Gen) {
	gens["Spec"] = SitesSpecGenerator()
	gens["Status"] = SiteSTATUSGenerator()
}

func Test_Site_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Site_STATUS to Site_STATUS via AssignPropertiesToSiteSTATUS & AssignPropertiesFromSiteSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSiteSTATUS, SiteSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSiteSTATUS tests if a specific instance of Site_STATUS can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForSiteSTATUS(subject Site_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.Site_STATUS
	err := copied.AssignPropertiesToSiteSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Site_STATUS
	err = actual.AssignPropertiesFromSiteSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Site_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Site_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSiteSTATUS, SiteSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSiteSTATUS runs a test to see if a specific instance of Site_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSiteSTATUS(subject Site_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Site_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Site_STATUS instances for property testing - lazily instantiated by SiteSTATUSGenerator()
var siteSTATUSGenerator gopter.Gen

// SiteSTATUSGenerator returns a generator of Site_STATUS instances for property testing.
// We first initialize siteSTATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SiteSTATUSGenerator() gopter.Gen {
	if siteSTATUSGenerator != nil {
		return siteSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSiteSTATUS(generators)
	siteSTATUSGenerator = gen.Struct(reflect.TypeOf(Site_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSiteSTATUS(generators)
	AddRelatedPropertyGeneratorsForSiteSTATUS(generators)
	siteSTATUSGenerator = gen.Struct(reflect.TypeOf(Site_STATUS{}), generators)

	return siteSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForSiteSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSiteSTATUS(gens map[string]gopter.Gen) {
	gens["AvailabilityState"] = gen.PtrOf(gen.OneConstOf(SiteSTATUSPropertiesAvailabilityState_DisasterRecoveryMode, SiteSTATUSPropertiesAvailabilityState_Limited, SiteSTATUSPropertiesAvailabilityState_Normal))
	gens["ClientAffinityEnabled"] = gen.PtrOf(gen.Bool())
	gens["ClientCertEnabled"] = gen.PtrOf(gen.Bool())
	gens["ClientCertExclusionPaths"] = gen.PtrOf(gen.AlphaString())
	gens["ClientCertMode"] = gen.PtrOf(gen.OneConstOf(SiteSTATUSPropertiesClientCertMode_Optional, SiteSTATUSPropertiesClientCertMode_OptionalInteractiveUser, SiteSTATUSPropertiesClientCertMode_Required))
	gens["ContainerSize"] = gen.PtrOf(gen.Int())
	gens["CustomDomainVerificationId"] = gen.PtrOf(gen.AlphaString())
	gens["DailyMemoryTimeQuota"] = gen.PtrOf(gen.Int())
	gens["DefaultHostName"] = gen.PtrOf(gen.AlphaString())
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["EnabledHostNames"] = gen.SliceOf(gen.AlphaString())
	gens["HostNames"] = gen.SliceOf(gen.AlphaString())
	gens["HostNamesDisabled"] = gen.PtrOf(gen.Bool())
	gens["HttpsOnly"] = gen.PtrOf(gen.Bool())
	gens["HyperV"] = gen.PtrOf(gen.Bool())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["InProgressOperationId"] = gen.PtrOf(gen.AlphaString())
	gens["IsDefaultContainer"] = gen.PtrOf(gen.Bool())
	gens["IsXenon"] = gen.PtrOf(gen.Bool())
	gens["KeyVaultReferenceIdentity"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedTimeUtc"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["MaxNumberOfWorkers"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["OutboundIpAddresses"] = gen.PtrOf(gen.AlphaString())
	gens["PossibleOutboundIpAddresses"] = gen.PtrOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.AlphaString())
	gens["RedundancyMode"] = gen.PtrOf(gen.OneConstOf(
		SiteSTATUSPropertiesRedundancyMode_ActiveActive,
		SiteSTATUSPropertiesRedundancyMode_Failover,
		SiteSTATUSPropertiesRedundancyMode_GeoRedundant,
		SiteSTATUSPropertiesRedundancyMode_Manual,
		SiteSTATUSPropertiesRedundancyMode_None))
	gens["RepositorySiteName"] = gen.PtrOf(gen.AlphaString())
	gens["Reserved"] = gen.PtrOf(gen.Bool())
	gens["ResourceGroup"] = gen.PtrOf(gen.AlphaString())
	gens["ScmSiteAlsoStopped"] = gen.PtrOf(gen.Bool())
	gens["ServerFarmId"] = gen.PtrOf(gen.AlphaString())
	gens["State"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountRequired"] = gen.PtrOf(gen.Bool())
	gens["SuspendedTill"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["TargetSwapSlot"] = gen.PtrOf(gen.AlphaString())
	gens["TrafficManagerHostNames"] = gen.SliceOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["UsageState"] = gen.PtrOf(gen.OneConstOf(SiteSTATUSPropertiesUsageState_Exceeded, SiteSTATUSPropertiesUsageState_Normal))
	gens["VirtualNetworkSubnetId"] = gen.PtrOf(gen.AlphaString())
	gens["VnetContentShareEnabled"] = gen.PtrOf(gen.Bool())
	gens["VnetImagePullEnabled"] = gen.PtrOf(gen.Bool())
	gens["VnetRouteAllEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForSiteSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSiteSTATUS(gens map[string]gopter.Gen) {
	gens["CloningInfo"] = gen.PtrOf(CloningInfoSTATUSGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationSTATUSGenerator())
	gens["HostNameSslStates"] = gen.SliceOf(HostNameSslStateSTATUSGenerator())
	gens["HostingEnvironmentProfile"] = gen.PtrOf(HostingEnvironmentProfileSTATUSGenerator())
	gens["Identity"] = gen.PtrOf(ManagedServiceIdentitySTATUSGenerator())
	gens["SiteConfig"] = gen.PtrOf(SiteConfigSTATUSGenerator())
	gens["SlotSwapStatus"] = gen.PtrOf(SlotSwapStatusSTATUSGenerator())
}

func Test_Sites_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Sites_Spec to Sites_Spec via AssignPropertiesToSitesSpec & AssignPropertiesFromSitesSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForSitesSpec, SitesSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSitesSpec tests if a specific instance of Sites_Spec can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForSitesSpec(subject Sites_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.Sites_Spec
	err := copied.AssignPropertiesToSitesSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Sites_Spec
	err = actual.AssignPropertiesFromSitesSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Sites_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sites_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSitesSpec, SitesSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSitesSpec runs a test to see if a specific instance of Sites_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForSitesSpec(subject Sites_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sites_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sites_Spec instances for property testing - lazily instantiated by SitesSpecGenerator()
var sitesSpecGenerator gopter.Gen

// SitesSpecGenerator returns a generator of Sites_Spec instances for property testing.
// We first initialize sitesSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SitesSpecGenerator() gopter.Gen {
	if sitesSpecGenerator != nil {
		return sitesSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSitesSpec(generators)
	sitesSpecGenerator = gen.Struct(reflect.TypeOf(Sites_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSitesSpec(generators)
	AddRelatedPropertyGeneratorsForSitesSpec(generators)
	sitesSpecGenerator = gen.Struct(reflect.TypeOf(Sites_Spec{}), generators)

	return sitesSpecGenerator
}

// AddIndependentPropertyGeneratorsForSitesSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSitesSpec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["ClientAffinityEnabled"] = gen.PtrOf(gen.Bool())
	gens["ClientCertEnabled"] = gen.PtrOf(gen.Bool())
	gens["ClientCertExclusionPaths"] = gen.PtrOf(gen.AlphaString())
	gens["ClientCertMode"] = gen.PtrOf(gen.OneConstOf(SitesSpecPropertiesClientCertMode_Optional, SitesSpecPropertiesClientCertMode_OptionalInteractiveUser, SitesSpecPropertiesClientCertMode_Required))
	gens["ContainerSize"] = gen.PtrOf(gen.Int())
	gens["CustomDomainVerificationId"] = gen.PtrOf(gen.AlphaString())
	gens["DailyMemoryTimeQuota"] = gen.PtrOf(gen.Int())
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["HostNamesDisabled"] = gen.PtrOf(gen.Bool())
	gens["HttpsOnly"] = gen.PtrOf(gen.Bool())
	gens["HyperV"] = gen.PtrOf(gen.Bool())
	gens["IsXenon"] = gen.PtrOf(gen.Bool())
	gens["KeyVaultReferenceIdentity"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.AlphaString())
	gens["RedundancyMode"] = gen.PtrOf(gen.OneConstOf(
		SitesSpecPropertiesRedundancyMode_ActiveActive,
		SitesSpecPropertiesRedundancyMode_Failover,
		SitesSpecPropertiesRedundancyMode_GeoRedundant,
		SitesSpecPropertiesRedundancyMode_Manual,
		SitesSpecPropertiesRedundancyMode_None))
	gens["Reserved"] = gen.PtrOf(gen.Bool())
	gens["ScmSiteAlsoStopped"] = gen.PtrOf(gen.Bool())
	gens["StorageAccountRequired"] = gen.PtrOf(gen.Bool())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["VnetContentShareEnabled"] = gen.PtrOf(gen.Bool())
	gens["VnetImagePullEnabled"] = gen.PtrOf(gen.Bool())
	gens["VnetRouteAllEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForSitesSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSitesSpec(gens map[string]gopter.Gen) {
	gens["CloningInfo"] = gen.PtrOf(CloningInfoGenerator())
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationGenerator())
	gens["HostNameSslStates"] = gen.SliceOf(HostNameSslStateGenerator())
	gens["HostingEnvironmentProfile"] = gen.PtrOf(HostingEnvironmentProfileGenerator())
	gens["Identity"] = gen.PtrOf(ManagedServiceIdentityGenerator())
	gens["SiteConfig"] = gen.PtrOf(SitesSpecPropertiesSiteConfigGenerator())
}

func Test_CloningInfo_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CloningInfo to CloningInfo via AssignPropertiesToCloningInfo & AssignPropertiesFromCloningInfo returns original",
		prop.ForAll(RunPropertyAssignmentTestForCloningInfo, CloningInfoGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCloningInfo tests if a specific instance of CloningInfo can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForCloningInfo(subject CloningInfo) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.CloningInfo
	err := copied.AssignPropertiesToCloningInfo(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CloningInfo
	err = actual.AssignPropertiesFromCloningInfo(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CloningInfo_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CloningInfo via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCloningInfo, CloningInfoGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCloningInfo runs a test to see if a specific instance of CloningInfo round trips to JSON and back losslessly
func RunJSONSerializationTestForCloningInfo(subject CloningInfo) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CloningInfo
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CloningInfo instances for property testing - lazily instantiated by CloningInfoGenerator()
var cloningInfoGenerator gopter.Gen

// CloningInfoGenerator returns a generator of CloningInfo instances for property testing.
func CloningInfoGenerator() gopter.Gen {
	if cloningInfoGenerator != nil {
		return cloningInfoGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCloningInfo(generators)
	cloningInfoGenerator = gen.Struct(reflect.TypeOf(CloningInfo{}), generators)

	return cloningInfoGenerator
}

// AddIndependentPropertyGeneratorsForCloningInfo is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCloningInfo(gens map[string]gopter.Gen) {
	gens["AppSettingsOverrides"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["CloneCustomHostNames"] = gen.PtrOf(gen.Bool())
	gens["CloneSourceControl"] = gen.PtrOf(gen.Bool())
	gens["ConfigureLoadBalancing"] = gen.PtrOf(gen.Bool())
	gens["CorrelationId"] = gen.PtrOf(gen.AlphaString())
	gens["HostingEnvironment"] = gen.PtrOf(gen.AlphaString())
	gens["Overwrite"] = gen.PtrOf(gen.Bool())
	gens["SourceWebAppLocation"] = gen.PtrOf(gen.AlphaString())
	gens["TrafficManagerProfileName"] = gen.PtrOf(gen.AlphaString())
}

func Test_CloningInfo_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CloningInfo_STATUS to CloningInfo_STATUS via AssignPropertiesToCloningInfoSTATUS & AssignPropertiesFromCloningInfoSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForCloningInfoSTATUS, CloningInfoSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCloningInfoSTATUS tests if a specific instance of CloningInfo_STATUS can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForCloningInfoSTATUS(subject CloningInfo_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.CloningInfo_STATUS
	err := copied.AssignPropertiesToCloningInfoSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CloningInfo_STATUS
	err = actual.AssignPropertiesFromCloningInfoSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CloningInfo_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CloningInfo_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCloningInfoSTATUS, CloningInfoSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCloningInfoSTATUS runs a test to see if a specific instance of CloningInfo_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForCloningInfoSTATUS(subject CloningInfo_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CloningInfo_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CloningInfo_STATUS instances for property testing - lazily instantiated by CloningInfoSTATUSGenerator()
var cloningInfoSTATUSGenerator gopter.Gen

// CloningInfoSTATUSGenerator returns a generator of CloningInfo_STATUS instances for property testing.
func CloningInfoSTATUSGenerator() gopter.Gen {
	if cloningInfoSTATUSGenerator != nil {
		return cloningInfoSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCloningInfoSTATUS(generators)
	cloningInfoSTATUSGenerator = gen.Struct(reflect.TypeOf(CloningInfo_STATUS{}), generators)

	return cloningInfoSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForCloningInfoSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCloningInfoSTATUS(gens map[string]gopter.Gen) {
	gens["AppSettingsOverrides"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["CloneCustomHostNames"] = gen.PtrOf(gen.Bool())
	gens["CloneSourceControl"] = gen.PtrOf(gen.Bool())
	gens["ConfigureLoadBalancing"] = gen.PtrOf(gen.Bool())
	gens["CorrelationId"] = gen.PtrOf(gen.AlphaString())
	gens["HostingEnvironment"] = gen.PtrOf(gen.AlphaString())
	gens["Overwrite"] = gen.PtrOf(gen.Bool())
	gens["SourceWebAppId"] = gen.PtrOf(gen.AlphaString())
	gens["SourceWebAppLocation"] = gen.PtrOf(gen.AlphaString())
	gens["TrafficManagerProfileId"] = gen.PtrOf(gen.AlphaString())
	gens["TrafficManagerProfileName"] = gen.PtrOf(gen.AlphaString())
}

func Test_HostNameSslState_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HostNameSslState to HostNameSslState via AssignPropertiesToHostNameSslState & AssignPropertiesFromHostNameSslState returns original",
		prop.ForAll(RunPropertyAssignmentTestForHostNameSslState, HostNameSslStateGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHostNameSslState tests if a specific instance of HostNameSslState can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForHostNameSslState(subject HostNameSslState) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.HostNameSslState
	err := copied.AssignPropertiesToHostNameSslState(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HostNameSslState
	err = actual.AssignPropertiesFromHostNameSslState(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HostNameSslState_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HostNameSslState via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHostNameSslState, HostNameSslStateGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHostNameSslState runs a test to see if a specific instance of HostNameSslState round trips to JSON and back losslessly
func RunJSONSerializationTestForHostNameSslState(subject HostNameSslState) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HostNameSslState
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HostNameSslState instances for property testing - lazily instantiated by HostNameSslStateGenerator()
var hostNameSslStateGenerator gopter.Gen

// HostNameSslStateGenerator returns a generator of HostNameSslState instances for property testing.
func HostNameSslStateGenerator() gopter.Gen {
	if hostNameSslStateGenerator != nil {
		return hostNameSslStateGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHostNameSslState(generators)
	hostNameSslStateGenerator = gen.Struct(reflect.TypeOf(HostNameSslState{}), generators)

	return hostNameSslStateGenerator
}

// AddIndependentPropertyGeneratorsForHostNameSslState is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHostNameSslState(gens map[string]gopter.Gen) {
	gens["HostType"] = gen.PtrOf(gen.OneConstOf(HostNameSslStateHostType_Repository, HostNameSslStateHostType_Standard))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["SslState"] = gen.PtrOf(gen.OneConstOf(HostNameSslStateSslState_Disabled, HostNameSslStateSslState_IpBasedEnabled, HostNameSslStateSslState_SniEnabled))
	gens["Thumbprint"] = gen.PtrOf(gen.AlphaString())
	gens["ToUpdate"] = gen.PtrOf(gen.Bool())
	gens["VirtualIP"] = gen.PtrOf(gen.AlphaString())
}

func Test_HostNameSslState_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HostNameSslState_STATUS to HostNameSslState_STATUS via AssignPropertiesToHostNameSslStateSTATUS & AssignPropertiesFromHostNameSslStateSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForHostNameSslStateSTATUS, HostNameSslStateSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHostNameSslStateSTATUS tests if a specific instance of HostNameSslState_STATUS can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForHostNameSslStateSTATUS(subject HostNameSslState_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.HostNameSslState_STATUS
	err := copied.AssignPropertiesToHostNameSslStateSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HostNameSslState_STATUS
	err = actual.AssignPropertiesFromHostNameSslStateSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HostNameSslState_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HostNameSslState_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHostNameSslStateSTATUS, HostNameSslStateSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHostNameSslStateSTATUS runs a test to see if a specific instance of HostNameSslState_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForHostNameSslStateSTATUS(subject HostNameSslState_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HostNameSslState_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HostNameSslState_STATUS instances for property testing - lazily instantiated by
// HostNameSslStateSTATUSGenerator()
var hostNameSslStateSTATUSGenerator gopter.Gen

// HostNameSslStateSTATUSGenerator returns a generator of HostNameSslState_STATUS instances for property testing.
func HostNameSslStateSTATUSGenerator() gopter.Gen {
	if hostNameSslStateSTATUSGenerator != nil {
		return hostNameSslStateSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHostNameSslStateSTATUS(generators)
	hostNameSslStateSTATUSGenerator = gen.Struct(reflect.TypeOf(HostNameSslState_STATUS{}), generators)

	return hostNameSslStateSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForHostNameSslStateSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHostNameSslStateSTATUS(gens map[string]gopter.Gen) {
	gens["HostType"] = gen.PtrOf(gen.OneConstOf(HostNameSslStateSTATUSHostType_Repository, HostNameSslStateSTATUSHostType_Standard))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["SslState"] = gen.PtrOf(gen.OneConstOf(HostNameSslStateSTATUSSslState_Disabled, HostNameSslStateSTATUSSslState_IpBasedEnabled, HostNameSslStateSTATUSSslState_SniEnabled))
	gens["Thumbprint"] = gen.PtrOf(gen.AlphaString())
	gens["ToUpdate"] = gen.PtrOf(gen.Bool())
	gens["VirtualIP"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedServiceIdentity_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedServiceIdentity to ManagedServiceIdentity via AssignPropertiesToManagedServiceIdentity & AssignPropertiesFromManagedServiceIdentity returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedServiceIdentity, ManagedServiceIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedServiceIdentity tests if a specific instance of ManagedServiceIdentity can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForManagedServiceIdentity(subject ManagedServiceIdentity) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.ManagedServiceIdentity
	err := copied.AssignPropertiesToManagedServiceIdentity(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedServiceIdentity
	err = actual.AssignPropertiesFromManagedServiceIdentity(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedServiceIdentity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentity, ManagedServiceIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentity runs a test to see if a specific instance of ManagedServiceIdentity round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentity(subject ManagedServiceIdentity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity instances for property testing - lazily instantiated by
// ManagedServiceIdentityGenerator()
var managedServiceIdentityGenerator gopter.Gen

// ManagedServiceIdentityGenerator returns a generator of ManagedServiceIdentity instances for property testing.
func ManagedServiceIdentityGenerator() gopter.Gen {
	if managedServiceIdentityGenerator != nil {
		return managedServiceIdentityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity(generators)
	managedServiceIdentityGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity{}), generators)

	return managedServiceIdentityGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentity is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentity(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ManagedServiceIdentityType_None,
		ManagedServiceIdentityType_SystemAssigned,
		ManagedServiceIdentityType_SystemAssignedUserAssigned,
		ManagedServiceIdentityType_UserAssigned))
}

func Test_ManagedServiceIdentity_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedServiceIdentity_STATUS to ManagedServiceIdentity_STATUS via AssignPropertiesToManagedServiceIdentitySTATUS & AssignPropertiesFromManagedServiceIdentitySTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedServiceIdentitySTATUS, ManagedServiceIdentitySTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedServiceIdentitySTATUS tests if a specific instance of ManagedServiceIdentity_STATUS can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForManagedServiceIdentitySTATUS(subject ManagedServiceIdentity_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.ManagedServiceIdentity_STATUS
	err := copied.AssignPropertiesToManagedServiceIdentitySTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedServiceIdentity_STATUS
	err = actual.AssignPropertiesFromManagedServiceIdentitySTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedServiceIdentity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentitySTATUS, ManagedServiceIdentitySTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentitySTATUS runs a test to see if a specific instance of ManagedServiceIdentity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentitySTATUS(subject ManagedServiceIdentity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity_STATUS instances for property testing - lazily instantiated by
// ManagedServiceIdentitySTATUSGenerator()
var managedServiceIdentitySTATUSGenerator gopter.Gen

// ManagedServiceIdentitySTATUSGenerator returns a generator of ManagedServiceIdentity_STATUS instances for property testing.
// We first initialize managedServiceIdentitySTATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedServiceIdentitySTATUSGenerator() gopter.Gen {
	if managedServiceIdentitySTATUSGenerator != nil {
		return managedServiceIdentitySTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentitySTATUS(generators)
	managedServiceIdentitySTATUSGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentitySTATUS(generators)
	AddRelatedPropertyGeneratorsForManagedServiceIdentitySTATUS(generators)
	managedServiceIdentitySTATUSGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_STATUS{}), generators)

	return managedServiceIdentitySTATUSGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentitySTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentitySTATUS(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ManagedServiceIdentitySTATUSType_None,
		ManagedServiceIdentitySTATUSType_SystemAssigned,
		ManagedServiceIdentitySTATUSType_SystemAssignedUserAssigned,
		ManagedServiceIdentitySTATUSType_UserAssigned))
}

// AddRelatedPropertyGeneratorsForManagedServiceIdentitySTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedServiceIdentitySTATUS(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), UserAssignedIdentitySTATUSGenerator())
}

func Test_SiteConfig_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SiteConfig_STATUS to SiteConfig_STATUS via AssignPropertiesToSiteConfigSTATUS & AssignPropertiesFromSiteConfigSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSiteConfigSTATUS, SiteConfigSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSiteConfigSTATUS tests if a specific instance of SiteConfig_STATUS can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForSiteConfigSTATUS(subject SiteConfig_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.SiteConfig_STATUS
	err := copied.AssignPropertiesToSiteConfigSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SiteConfig_STATUS
	err = actual.AssignPropertiesFromSiteConfigSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SiteConfig_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SiteConfig_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSiteConfigSTATUS, SiteConfigSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSiteConfigSTATUS runs a test to see if a specific instance of SiteConfig_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSiteConfigSTATUS(subject SiteConfig_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SiteConfig_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SiteConfig_STATUS instances for property testing - lazily instantiated by SiteConfigSTATUSGenerator()
var siteConfigSTATUSGenerator gopter.Gen

// SiteConfigSTATUSGenerator returns a generator of SiteConfig_STATUS instances for property testing.
// We first initialize siteConfigSTATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SiteConfigSTATUSGenerator() gopter.Gen {
	if siteConfigSTATUSGenerator != nil {
		return siteConfigSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSiteConfigSTATUS(generators)
	siteConfigSTATUSGenerator = gen.Struct(reflect.TypeOf(SiteConfig_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSiteConfigSTATUS(generators)
	AddRelatedPropertyGeneratorsForSiteConfigSTATUS(generators)
	siteConfigSTATUSGenerator = gen.Struct(reflect.TypeOf(SiteConfig_STATUS{}), generators)

	return siteConfigSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForSiteConfigSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSiteConfigSTATUS(gens map[string]gopter.Gen) {
	gens["AcrUseManagedIdentityCreds"] = gen.PtrOf(gen.Bool())
	gens["AcrUserManagedIdentityID"] = gen.PtrOf(gen.AlphaString())
	gens["AlwaysOn"] = gen.PtrOf(gen.Bool())
	gens["AppCommandLine"] = gen.PtrOf(gen.AlphaString())
	gens["AutoHealEnabled"] = gen.PtrOf(gen.Bool())
	gens["AutoSwapSlotName"] = gen.PtrOf(gen.AlphaString())
	gens["DefaultDocuments"] = gen.SliceOf(gen.AlphaString())
	gens["DetailedErrorLoggingEnabled"] = gen.PtrOf(gen.Bool())
	gens["DocumentRoot"] = gen.PtrOf(gen.AlphaString())
	gens["FtpsState"] = gen.PtrOf(gen.OneConstOf(SiteConfigSTATUSFtpsState_AllAllowed, SiteConfigSTATUSFtpsState_Disabled, SiteConfigSTATUSFtpsState_FtpsOnly))
	gens["FunctionAppScaleLimit"] = gen.PtrOf(gen.Int())
	gens["FunctionsRuntimeScaleMonitoringEnabled"] = gen.PtrOf(gen.Bool())
	gens["HealthCheckPath"] = gen.PtrOf(gen.AlphaString())
	gens["Http20Enabled"] = gen.PtrOf(gen.Bool())
	gens["HttpLoggingEnabled"] = gen.PtrOf(gen.Bool())
	gens["JavaContainer"] = gen.PtrOf(gen.AlphaString())
	gens["JavaContainerVersion"] = gen.PtrOf(gen.AlphaString())
	gens["JavaVersion"] = gen.PtrOf(gen.AlphaString())
	gens["KeyVaultReferenceIdentity"] = gen.PtrOf(gen.AlphaString())
	gens["LinuxFxVersion"] = gen.PtrOf(gen.AlphaString())
	gens["LoadBalancing"] = gen.PtrOf(gen.OneConstOf(
		SiteConfigSTATUSLoadBalancing_LeastRequests,
		SiteConfigSTATUSLoadBalancing_LeastResponseTime,
		SiteConfigSTATUSLoadBalancing_PerSiteRoundRobin,
		SiteConfigSTATUSLoadBalancing_RequestHash,
		SiteConfigSTATUSLoadBalancing_WeightedRoundRobin,
		SiteConfigSTATUSLoadBalancing_WeightedTotalTraffic))
	gens["LocalMySqlEnabled"] = gen.PtrOf(gen.Bool())
	gens["LogsDirectorySizeLimit"] = gen.PtrOf(gen.Int())
	gens["ManagedPipelineMode"] = gen.PtrOf(gen.OneConstOf(SiteConfigSTATUSManagedPipelineMode_Classic, SiteConfigSTATUSManagedPipelineMode_Integrated))
	gens["ManagedServiceIdentityId"] = gen.PtrOf(gen.Int())
	gens["MinTlsVersion"] = gen.PtrOf(gen.OneConstOf(SiteConfigSTATUSMinTlsVersion_10, SiteConfigSTATUSMinTlsVersion_11, SiteConfigSTATUSMinTlsVersion_12))
	gens["MinimumElasticInstanceCount"] = gen.PtrOf(gen.Int())
	gens["NetFrameworkVersion"] = gen.PtrOf(gen.AlphaString())
	gens["NodeVersion"] = gen.PtrOf(gen.AlphaString())
	gens["NumberOfWorkers"] = gen.PtrOf(gen.Int())
	gens["PhpVersion"] = gen.PtrOf(gen.AlphaString())
	gens["PowerShellVersion"] = gen.PtrOf(gen.AlphaString())
	gens["PreWarmedInstanceCount"] = gen.PtrOf(gen.Int())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.AlphaString())
	gens["PublishingUsername"] = gen.PtrOf(gen.AlphaString())
	gens["PythonVersion"] = gen.PtrOf(gen.AlphaString())
	gens["RemoteDebuggingEnabled"] = gen.PtrOf(gen.Bool())
	gens["RemoteDebuggingVersion"] = gen.PtrOf(gen.AlphaString())
	gens["RequestTracingEnabled"] = gen.PtrOf(gen.Bool())
	gens["RequestTracingExpirationTime"] = gen.PtrOf(gen.AlphaString())
	gens["ScmIpSecurityRestrictionsUseMain"] = gen.PtrOf(gen.Bool())
	gens["ScmMinTlsVersion"] = gen.PtrOf(gen.OneConstOf(SiteConfigSTATUSScmMinTlsVersion_10, SiteConfigSTATUSScmMinTlsVersion_11, SiteConfigSTATUSScmMinTlsVersion_12))
	gens["ScmType"] = gen.PtrOf(gen.OneConstOf(
		SiteConfigSTATUSScmType_BitbucketGit,
		SiteConfigSTATUSScmType_BitbucketHg,
		SiteConfigSTATUSScmType_CodePlexGit,
		SiteConfigSTATUSScmType_CodePlexHg,
		SiteConfigSTATUSScmType_Dropbox,
		SiteConfigSTATUSScmType_ExternalGit,
		SiteConfigSTATUSScmType_ExternalHg,
		SiteConfigSTATUSScmType_GitHub,
		SiteConfigSTATUSScmType_LocalGit,
		SiteConfigSTATUSScmType_None,
		SiteConfigSTATUSScmType_OneDrive,
		SiteConfigSTATUSScmType_Tfs,
		SiteConfigSTATUSScmType_VSO,
		SiteConfigSTATUSScmType_VSTSRM))
	gens["TracingOptions"] = gen.PtrOf(gen.AlphaString())
	gens["Use32BitWorkerProcess"] = gen.PtrOf(gen.Bool())
	gens["VnetName"] = gen.PtrOf(gen.AlphaString())
	gens["VnetPrivatePortsCount"] = gen.PtrOf(gen.Int())
	gens["VnetRouteAllEnabled"] = gen.PtrOf(gen.Bool())
	gens["WebSocketsEnabled"] = gen.PtrOf(gen.Bool())
	gens["WebsiteTimeZone"] = gen.PtrOf(gen.AlphaString())
	gens["WindowsFxVersion"] = gen.PtrOf(gen.AlphaString())
	gens["XManagedServiceIdentityId"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForSiteConfigSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSiteConfigSTATUS(gens map[string]gopter.Gen) {
	gens["ApiDefinition"] = gen.PtrOf(ApiDefinitionInfoSTATUSGenerator())
	gens["ApiManagementConfig"] = gen.PtrOf(ApiManagementConfigSTATUSGenerator())
	gens["AppSettings"] = gen.SliceOf(NameValuePairSTATUSGenerator())
	gens["AutoHealRules"] = gen.PtrOf(AutoHealRulesSTATUSGenerator())
	gens["AzureStorageAccounts"] = gen.MapOf(gen.AlphaString(), AzureStorageInfoValueSTATUSGenerator())
	gens["ConnectionStrings"] = gen.SliceOf(ConnStringInfoSTATUSGenerator())
	gens["Cors"] = gen.PtrOf(CorsSettingsSTATUSGenerator())
	gens["Experiments"] = gen.PtrOf(ExperimentsSTATUSGenerator())
	gens["HandlerMappings"] = gen.SliceOf(HandlerMappingSTATUSGenerator())
	gens["IpSecurityRestrictions"] = gen.SliceOf(IpSecurityRestrictionSTATUSGenerator())
	gens["Limits"] = gen.PtrOf(SiteLimitsSTATUSGenerator())
	gens["MachineKey"] = gen.PtrOf(SiteMachineKeySTATUSGenerator())
	gens["Push"] = gen.PtrOf(PushSettingsSTATUSGenerator())
	gens["ScmIpSecurityRestrictions"] = gen.SliceOf(IpSecurityRestrictionSTATUSGenerator())
	gens["VirtualApplications"] = gen.SliceOf(VirtualApplicationSTATUSGenerator())
}

func Test_Sites_Spec_Properties_SiteConfig_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Sites_Spec_Properties_SiteConfig to Sites_Spec_Properties_SiteConfig via AssignPropertiesToSitesSpecPropertiesSiteConfig & AssignPropertiesFromSitesSpecPropertiesSiteConfig returns original",
		prop.ForAll(RunPropertyAssignmentTestForSitesSpecPropertiesSiteConfig, SitesSpecPropertiesSiteConfigGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSitesSpecPropertiesSiteConfig tests if a specific instance of Sites_Spec_Properties_SiteConfig can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForSitesSpecPropertiesSiteConfig(subject Sites_Spec_Properties_SiteConfig) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.Sites_Spec_Properties_SiteConfig
	err := copied.AssignPropertiesToSitesSpecPropertiesSiteConfig(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Sites_Spec_Properties_SiteConfig
	err = actual.AssignPropertiesFromSitesSpecPropertiesSiteConfig(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Sites_Spec_Properties_SiteConfig_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sites_Spec_Properties_SiteConfig via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSitesSpecPropertiesSiteConfig, SitesSpecPropertiesSiteConfigGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSitesSpecPropertiesSiteConfig runs a test to see if a specific instance of Sites_Spec_Properties_SiteConfig round trips to JSON and back losslessly
func RunJSONSerializationTestForSitesSpecPropertiesSiteConfig(subject Sites_Spec_Properties_SiteConfig) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sites_Spec_Properties_SiteConfig
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sites_Spec_Properties_SiteConfig instances for property testing - lazily instantiated by
// SitesSpecPropertiesSiteConfigGenerator()
var sitesSpecPropertiesSiteConfigGenerator gopter.Gen

// SitesSpecPropertiesSiteConfigGenerator returns a generator of Sites_Spec_Properties_SiteConfig instances for property testing.
// We first initialize sitesSpecPropertiesSiteConfigGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SitesSpecPropertiesSiteConfigGenerator() gopter.Gen {
	if sitesSpecPropertiesSiteConfigGenerator != nil {
		return sitesSpecPropertiesSiteConfigGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSitesSpecPropertiesSiteConfig(generators)
	sitesSpecPropertiesSiteConfigGenerator = gen.Struct(reflect.TypeOf(Sites_Spec_Properties_SiteConfig{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSitesSpecPropertiesSiteConfig(generators)
	AddRelatedPropertyGeneratorsForSitesSpecPropertiesSiteConfig(generators)
	sitesSpecPropertiesSiteConfigGenerator = gen.Struct(reflect.TypeOf(Sites_Spec_Properties_SiteConfig{}), generators)

	return sitesSpecPropertiesSiteConfigGenerator
}

// AddIndependentPropertyGeneratorsForSitesSpecPropertiesSiteConfig is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSitesSpecPropertiesSiteConfig(gens map[string]gopter.Gen) {
	gens["AcrUseManagedIdentityCreds"] = gen.PtrOf(gen.Bool())
	gens["AcrUserManagedIdentityID"] = gen.PtrOf(gen.AlphaString())
	gens["AlwaysOn"] = gen.PtrOf(gen.Bool())
	gens["AppCommandLine"] = gen.PtrOf(gen.AlphaString())
	gens["AutoHealEnabled"] = gen.PtrOf(gen.Bool())
	gens["AutoSwapSlotName"] = gen.PtrOf(gen.AlphaString())
	gens["DefaultDocuments"] = gen.SliceOf(gen.AlphaString())
	gens["DetailedErrorLoggingEnabled"] = gen.PtrOf(gen.Bool())
	gens["DocumentRoot"] = gen.PtrOf(gen.AlphaString())
	gens["FtpsState"] = gen.PtrOf(gen.OneConstOf(SitesSpecPropertiesSiteConfigFtpsState_AllAllowed, SitesSpecPropertiesSiteConfigFtpsState_Disabled, SitesSpecPropertiesSiteConfigFtpsState_FtpsOnly))
	gens["FunctionAppScaleLimit"] = gen.PtrOf(gen.Int())
	gens["FunctionsRuntimeScaleMonitoringEnabled"] = gen.PtrOf(gen.Bool())
	gens["HealthCheckPath"] = gen.PtrOf(gen.AlphaString())
	gens["Http20Enabled"] = gen.PtrOf(gen.Bool())
	gens["HttpLoggingEnabled"] = gen.PtrOf(gen.Bool())
	gens["JavaContainer"] = gen.PtrOf(gen.AlphaString())
	gens["JavaContainerVersion"] = gen.PtrOf(gen.AlphaString())
	gens["JavaVersion"] = gen.PtrOf(gen.AlphaString())
	gens["KeyVaultReferenceIdentity"] = gen.PtrOf(gen.AlphaString())
	gens["LinuxFxVersion"] = gen.PtrOf(gen.AlphaString())
	gens["LoadBalancing"] = gen.PtrOf(gen.OneConstOf(
		SitesSpecPropertiesSiteConfigLoadBalancing_LeastRequests,
		SitesSpecPropertiesSiteConfigLoadBalancing_LeastResponseTime,
		SitesSpecPropertiesSiteConfigLoadBalancing_PerSiteRoundRobin,
		SitesSpecPropertiesSiteConfigLoadBalancing_RequestHash,
		SitesSpecPropertiesSiteConfigLoadBalancing_WeightedRoundRobin,
		SitesSpecPropertiesSiteConfigLoadBalancing_WeightedTotalTraffic))
	gens["LocalMySqlEnabled"] = gen.PtrOf(gen.Bool())
	gens["LogsDirectorySizeLimit"] = gen.PtrOf(gen.Int())
	gens["ManagedPipelineMode"] = gen.PtrOf(gen.OneConstOf(SitesSpecPropertiesSiteConfigManagedPipelineMode_Classic, SitesSpecPropertiesSiteConfigManagedPipelineMode_Integrated))
	gens["ManagedServiceIdentityId"] = gen.PtrOf(gen.Int())
	gens["MinTlsVersion"] = gen.PtrOf(gen.OneConstOf(SitesSpecPropertiesSiteConfigMinTlsVersion_10, SitesSpecPropertiesSiteConfigMinTlsVersion_11, SitesSpecPropertiesSiteConfigMinTlsVersion_12))
	gens["MinimumElasticInstanceCount"] = gen.PtrOf(gen.Int())
	gens["NetFrameworkVersion"] = gen.PtrOf(gen.AlphaString())
	gens["NodeVersion"] = gen.PtrOf(gen.AlphaString())
	gens["NumberOfWorkers"] = gen.PtrOf(gen.Int())
	gens["PhpVersion"] = gen.PtrOf(gen.AlphaString())
	gens["PowerShellVersion"] = gen.PtrOf(gen.AlphaString())
	gens["PreWarmedInstanceCount"] = gen.PtrOf(gen.Int())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.AlphaString())
	gens["PublishingUsername"] = gen.PtrOf(gen.AlphaString())
	gens["PythonVersion"] = gen.PtrOf(gen.AlphaString())
	gens["RemoteDebuggingEnabled"] = gen.PtrOf(gen.Bool())
	gens["RemoteDebuggingVersion"] = gen.PtrOf(gen.AlphaString())
	gens["RequestTracingEnabled"] = gen.PtrOf(gen.Bool())
	gens["RequestTracingExpirationTime"] = gen.PtrOf(gen.AlphaString())
	gens["ScmIpSecurityRestrictionsUseMain"] = gen.PtrOf(gen.Bool())
	gens["ScmMinTlsVersion"] = gen.PtrOf(gen.OneConstOf(SitesSpecPropertiesSiteConfigScmMinTlsVersion_10, SitesSpecPropertiesSiteConfigScmMinTlsVersion_11, SitesSpecPropertiesSiteConfigScmMinTlsVersion_12))
	gens["ScmType"] = gen.PtrOf(gen.OneConstOf(
		SitesSpecPropertiesSiteConfigScmType_BitbucketGit,
		SitesSpecPropertiesSiteConfigScmType_BitbucketHg,
		SitesSpecPropertiesSiteConfigScmType_CodePlexGit,
		SitesSpecPropertiesSiteConfigScmType_CodePlexHg,
		SitesSpecPropertiesSiteConfigScmType_Dropbox,
		SitesSpecPropertiesSiteConfigScmType_ExternalGit,
		SitesSpecPropertiesSiteConfigScmType_ExternalHg,
		SitesSpecPropertiesSiteConfigScmType_GitHub,
		SitesSpecPropertiesSiteConfigScmType_LocalGit,
		SitesSpecPropertiesSiteConfigScmType_None,
		SitesSpecPropertiesSiteConfigScmType_OneDrive,
		SitesSpecPropertiesSiteConfigScmType_Tfs,
		SitesSpecPropertiesSiteConfigScmType_VSO,
		SitesSpecPropertiesSiteConfigScmType_VSTSRM))
	gens["TracingOptions"] = gen.PtrOf(gen.AlphaString())
	gens["Use32BitWorkerProcess"] = gen.PtrOf(gen.Bool())
	gens["VnetName"] = gen.PtrOf(gen.AlphaString())
	gens["VnetPrivatePortsCount"] = gen.PtrOf(gen.Int())
	gens["VnetRouteAllEnabled"] = gen.PtrOf(gen.Bool())
	gens["WebSocketsEnabled"] = gen.PtrOf(gen.Bool())
	gens["WebsiteTimeZone"] = gen.PtrOf(gen.AlphaString())
	gens["WindowsFxVersion"] = gen.PtrOf(gen.AlphaString())
	gens["XManagedServiceIdentityId"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForSitesSpecPropertiesSiteConfig is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSitesSpecPropertiesSiteConfig(gens map[string]gopter.Gen) {
	gens["ApiDefinition"] = gen.PtrOf(ApiDefinitionInfoGenerator())
	gens["ApiManagementConfig"] = gen.PtrOf(ApiManagementConfigGenerator())
	gens["AppSettings"] = gen.SliceOf(NameValuePairGenerator())
	gens["AutoHealRules"] = gen.PtrOf(AutoHealRulesGenerator())
	gens["AzureStorageAccounts"] = gen.MapOf(gen.AlphaString(), SitesSpecPropertiesSiteConfigAzureStorageAccountsGenerator())
	gens["ConnectionStrings"] = gen.SliceOf(ConnStringInfoGenerator())
	gens["Cors"] = gen.PtrOf(CorsSettingsGenerator())
	gens["Experiments"] = gen.PtrOf(ExperimentsGenerator())
	gens["HandlerMappings"] = gen.SliceOf(HandlerMappingGenerator())
	gens["IpSecurityRestrictions"] = gen.SliceOf(IpSecurityRestrictionGenerator())
	gens["Limits"] = gen.PtrOf(SiteLimitsGenerator())
	gens["Push"] = gen.PtrOf(SitesSpecPropertiesSiteConfigPushGenerator())
	gens["ScmIpSecurityRestrictions"] = gen.SliceOf(IpSecurityRestrictionGenerator())
	gens["VirtualApplications"] = gen.SliceOf(VirtualApplicationGenerator())
}

func Test_SlotSwapStatus_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SlotSwapStatus_STATUS to SlotSwapStatus_STATUS via AssignPropertiesToSlotSwapStatusSTATUS & AssignPropertiesFromSlotSwapStatusSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSlotSwapStatusSTATUS, SlotSwapStatusSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSlotSwapStatusSTATUS tests if a specific instance of SlotSwapStatus_STATUS can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForSlotSwapStatusSTATUS(subject SlotSwapStatus_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.SlotSwapStatus_STATUS
	err := copied.AssignPropertiesToSlotSwapStatusSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SlotSwapStatus_STATUS
	err = actual.AssignPropertiesFromSlotSwapStatusSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SlotSwapStatus_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SlotSwapStatus_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSlotSwapStatusSTATUS, SlotSwapStatusSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSlotSwapStatusSTATUS runs a test to see if a specific instance of SlotSwapStatus_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSlotSwapStatusSTATUS(subject SlotSwapStatus_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SlotSwapStatus_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SlotSwapStatus_STATUS instances for property testing - lazily instantiated by
// SlotSwapStatusSTATUSGenerator()
var slotSwapStatusSTATUSGenerator gopter.Gen

// SlotSwapStatusSTATUSGenerator returns a generator of SlotSwapStatus_STATUS instances for property testing.
func SlotSwapStatusSTATUSGenerator() gopter.Gen {
	if slotSwapStatusSTATUSGenerator != nil {
		return slotSwapStatusSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSlotSwapStatusSTATUS(generators)
	slotSwapStatusSTATUSGenerator = gen.Struct(reflect.TypeOf(SlotSwapStatus_STATUS{}), generators)

	return slotSwapStatusSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForSlotSwapStatusSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSlotSwapStatusSTATUS(gens map[string]gopter.Gen) {
	gens["DestinationSlotName"] = gen.PtrOf(gen.AlphaString())
	gens["SourceSlotName"] = gen.PtrOf(gen.AlphaString())
	gens["TimestampUtc"] = gen.PtrOf(gen.AlphaString())
}

func Test_ApiDefinitionInfo_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ApiDefinitionInfo to ApiDefinitionInfo via AssignPropertiesToApiDefinitionInfo & AssignPropertiesFromApiDefinitionInfo returns original",
		prop.ForAll(RunPropertyAssignmentTestForApiDefinitionInfo, ApiDefinitionInfoGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForApiDefinitionInfo tests if a specific instance of ApiDefinitionInfo can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForApiDefinitionInfo(subject ApiDefinitionInfo) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.ApiDefinitionInfo
	err := copied.AssignPropertiesToApiDefinitionInfo(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ApiDefinitionInfo
	err = actual.AssignPropertiesFromApiDefinitionInfo(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ApiDefinitionInfo_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiDefinitionInfo via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiDefinitionInfo, ApiDefinitionInfoGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiDefinitionInfo runs a test to see if a specific instance of ApiDefinitionInfo round trips to JSON and back losslessly
func RunJSONSerializationTestForApiDefinitionInfo(subject ApiDefinitionInfo) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiDefinitionInfo
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiDefinitionInfo instances for property testing - lazily instantiated by ApiDefinitionInfoGenerator()
var apiDefinitionInfoGenerator gopter.Gen

// ApiDefinitionInfoGenerator returns a generator of ApiDefinitionInfo instances for property testing.
func ApiDefinitionInfoGenerator() gopter.Gen {
	if apiDefinitionInfoGenerator != nil {
		return apiDefinitionInfoGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiDefinitionInfo(generators)
	apiDefinitionInfoGenerator = gen.Struct(reflect.TypeOf(ApiDefinitionInfo{}), generators)

	return apiDefinitionInfoGenerator
}

// AddIndependentPropertyGeneratorsForApiDefinitionInfo is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiDefinitionInfo(gens map[string]gopter.Gen) {
	gens["Url"] = gen.PtrOf(gen.AlphaString())
}

func Test_ApiDefinitionInfo_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ApiDefinitionInfo_STATUS to ApiDefinitionInfo_STATUS via AssignPropertiesToApiDefinitionInfoSTATUS & AssignPropertiesFromApiDefinitionInfoSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForApiDefinitionInfoSTATUS, ApiDefinitionInfoSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForApiDefinitionInfoSTATUS tests if a specific instance of ApiDefinitionInfo_STATUS can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForApiDefinitionInfoSTATUS(subject ApiDefinitionInfo_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.ApiDefinitionInfo_STATUS
	err := copied.AssignPropertiesToApiDefinitionInfoSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ApiDefinitionInfo_STATUS
	err = actual.AssignPropertiesFromApiDefinitionInfoSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ApiDefinitionInfo_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiDefinitionInfo_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiDefinitionInfoSTATUS, ApiDefinitionInfoSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiDefinitionInfoSTATUS runs a test to see if a specific instance of ApiDefinitionInfo_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForApiDefinitionInfoSTATUS(subject ApiDefinitionInfo_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiDefinitionInfo_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiDefinitionInfo_STATUS instances for property testing - lazily instantiated by
// ApiDefinitionInfoSTATUSGenerator()
var apiDefinitionInfoSTATUSGenerator gopter.Gen

// ApiDefinitionInfoSTATUSGenerator returns a generator of ApiDefinitionInfo_STATUS instances for property testing.
func ApiDefinitionInfoSTATUSGenerator() gopter.Gen {
	if apiDefinitionInfoSTATUSGenerator != nil {
		return apiDefinitionInfoSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiDefinitionInfoSTATUS(generators)
	apiDefinitionInfoSTATUSGenerator = gen.Struct(reflect.TypeOf(ApiDefinitionInfo_STATUS{}), generators)

	return apiDefinitionInfoSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForApiDefinitionInfoSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiDefinitionInfoSTATUS(gens map[string]gopter.Gen) {
	gens["Url"] = gen.PtrOf(gen.AlphaString())
}

func Test_ApiManagementConfig_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ApiManagementConfig to ApiManagementConfig via AssignPropertiesToApiManagementConfig & AssignPropertiesFromApiManagementConfig returns original",
		prop.ForAll(RunPropertyAssignmentTestForApiManagementConfig, ApiManagementConfigGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForApiManagementConfig tests if a specific instance of ApiManagementConfig can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForApiManagementConfig(subject ApiManagementConfig) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.ApiManagementConfig
	err := copied.AssignPropertiesToApiManagementConfig(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ApiManagementConfig
	err = actual.AssignPropertiesFromApiManagementConfig(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ApiManagementConfig_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiManagementConfig via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiManagementConfig, ApiManagementConfigGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiManagementConfig runs a test to see if a specific instance of ApiManagementConfig round trips to JSON and back losslessly
func RunJSONSerializationTestForApiManagementConfig(subject ApiManagementConfig) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiManagementConfig
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiManagementConfig instances for property testing - lazily instantiated by
// ApiManagementConfigGenerator()
var apiManagementConfigGenerator gopter.Gen

// ApiManagementConfigGenerator returns a generator of ApiManagementConfig instances for property testing.
func ApiManagementConfigGenerator() gopter.Gen {
	if apiManagementConfigGenerator != nil {
		return apiManagementConfigGenerator
	}

	generators := make(map[string]gopter.Gen)
	apiManagementConfigGenerator = gen.Struct(reflect.TypeOf(ApiManagementConfig{}), generators)

	return apiManagementConfigGenerator
}

func Test_ApiManagementConfig_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ApiManagementConfig_STATUS to ApiManagementConfig_STATUS via AssignPropertiesToApiManagementConfigSTATUS & AssignPropertiesFromApiManagementConfigSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForApiManagementConfigSTATUS, ApiManagementConfigSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForApiManagementConfigSTATUS tests if a specific instance of ApiManagementConfig_STATUS can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForApiManagementConfigSTATUS(subject ApiManagementConfig_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.ApiManagementConfig_STATUS
	err := copied.AssignPropertiesToApiManagementConfigSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ApiManagementConfig_STATUS
	err = actual.AssignPropertiesFromApiManagementConfigSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ApiManagementConfig_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiManagementConfig_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiManagementConfigSTATUS, ApiManagementConfigSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiManagementConfigSTATUS runs a test to see if a specific instance of ApiManagementConfig_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForApiManagementConfigSTATUS(subject ApiManagementConfig_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiManagementConfig_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiManagementConfig_STATUS instances for property testing - lazily instantiated by
// ApiManagementConfigSTATUSGenerator()
var apiManagementConfigSTATUSGenerator gopter.Gen

// ApiManagementConfigSTATUSGenerator returns a generator of ApiManagementConfig_STATUS instances for property testing.
func ApiManagementConfigSTATUSGenerator() gopter.Gen {
	if apiManagementConfigSTATUSGenerator != nil {
		return apiManagementConfigSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiManagementConfigSTATUS(generators)
	apiManagementConfigSTATUSGenerator = gen.Struct(reflect.TypeOf(ApiManagementConfig_STATUS{}), generators)

	return apiManagementConfigSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForApiManagementConfigSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiManagementConfigSTATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_AutoHealRules_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AutoHealRules to AutoHealRules via AssignPropertiesToAutoHealRules & AssignPropertiesFromAutoHealRules returns original",
		prop.ForAll(RunPropertyAssignmentTestForAutoHealRules, AutoHealRulesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAutoHealRules tests if a specific instance of AutoHealRules can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForAutoHealRules(subject AutoHealRules) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.AutoHealRules
	err := copied.AssignPropertiesToAutoHealRules(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AutoHealRules
	err = actual.AssignPropertiesFromAutoHealRules(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AutoHealRules_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoHealRules via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoHealRules, AutoHealRulesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoHealRules runs a test to see if a specific instance of AutoHealRules round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoHealRules(subject AutoHealRules) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoHealRules
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoHealRules instances for property testing - lazily instantiated by AutoHealRulesGenerator()
var autoHealRulesGenerator gopter.Gen

// AutoHealRulesGenerator returns a generator of AutoHealRules instances for property testing.
func AutoHealRulesGenerator() gopter.Gen {
	if autoHealRulesGenerator != nil {
		return autoHealRulesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForAutoHealRules(generators)
	autoHealRulesGenerator = gen.Struct(reflect.TypeOf(AutoHealRules{}), generators)

	return autoHealRulesGenerator
}

// AddRelatedPropertyGeneratorsForAutoHealRules is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoHealRules(gens map[string]gopter.Gen) {
	gens["Actions"] = gen.PtrOf(AutoHealActionsGenerator())
	gens["Triggers"] = gen.PtrOf(AutoHealTriggersGenerator())
}

func Test_AutoHealRules_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AutoHealRules_STATUS to AutoHealRules_STATUS via AssignPropertiesToAutoHealRulesSTATUS & AssignPropertiesFromAutoHealRulesSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAutoHealRulesSTATUS, AutoHealRulesSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAutoHealRulesSTATUS tests if a specific instance of AutoHealRules_STATUS can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForAutoHealRulesSTATUS(subject AutoHealRules_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.AutoHealRules_STATUS
	err := copied.AssignPropertiesToAutoHealRulesSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AutoHealRules_STATUS
	err = actual.AssignPropertiesFromAutoHealRulesSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AutoHealRules_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoHealRules_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoHealRulesSTATUS, AutoHealRulesSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoHealRulesSTATUS runs a test to see if a specific instance of AutoHealRules_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoHealRulesSTATUS(subject AutoHealRules_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoHealRules_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoHealRules_STATUS instances for property testing - lazily instantiated by
// AutoHealRulesSTATUSGenerator()
var autoHealRulesSTATUSGenerator gopter.Gen

// AutoHealRulesSTATUSGenerator returns a generator of AutoHealRules_STATUS instances for property testing.
func AutoHealRulesSTATUSGenerator() gopter.Gen {
	if autoHealRulesSTATUSGenerator != nil {
		return autoHealRulesSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForAutoHealRulesSTATUS(generators)
	autoHealRulesSTATUSGenerator = gen.Struct(reflect.TypeOf(AutoHealRules_STATUS{}), generators)

	return autoHealRulesSTATUSGenerator
}

// AddRelatedPropertyGeneratorsForAutoHealRulesSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoHealRulesSTATUS(gens map[string]gopter.Gen) {
	gens["Actions"] = gen.PtrOf(AutoHealActionsSTATUSGenerator())
	gens["Triggers"] = gen.PtrOf(AutoHealTriggersSTATUSGenerator())
}

func Test_AzureStorageInfoValue_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AzureStorageInfoValue_STATUS to AzureStorageInfoValue_STATUS via AssignPropertiesToAzureStorageInfoValueSTATUS & AssignPropertiesFromAzureStorageInfoValueSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAzureStorageInfoValueSTATUS, AzureStorageInfoValueSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAzureStorageInfoValueSTATUS tests if a specific instance of AzureStorageInfoValue_STATUS can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForAzureStorageInfoValueSTATUS(subject AzureStorageInfoValue_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.AzureStorageInfoValue_STATUS
	err := copied.AssignPropertiesToAzureStorageInfoValueSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AzureStorageInfoValue_STATUS
	err = actual.AssignPropertiesFromAzureStorageInfoValueSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AzureStorageInfoValue_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureStorageInfoValue_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureStorageInfoValueSTATUS, AzureStorageInfoValueSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureStorageInfoValueSTATUS runs a test to see if a specific instance of AzureStorageInfoValue_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureStorageInfoValueSTATUS(subject AzureStorageInfoValue_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureStorageInfoValue_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureStorageInfoValue_STATUS instances for property testing - lazily instantiated by
// AzureStorageInfoValueSTATUSGenerator()
var azureStorageInfoValueSTATUSGenerator gopter.Gen

// AzureStorageInfoValueSTATUSGenerator returns a generator of AzureStorageInfoValue_STATUS instances for property testing.
func AzureStorageInfoValueSTATUSGenerator() gopter.Gen {
	if azureStorageInfoValueSTATUSGenerator != nil {
		return azureStorageInfoValueSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureStorageInfoValueSTATUS(generators)
	azureStorageInfoValueSTATUSGenerator = gen.Struct(reflect.TypeOf(AzureStorageInfoValue_STATUS{}), generators)

	return azureStorageInfoValueSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForAzureStorageInfoValueSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureStorageInfoValueSTATUS(gens map[string]gopter.Gen) {
	gens["AccountName"] = gen.PtrOf(gen.AlphaString())
	gens["MountPath"] = gen.PtrOf(gen.AlphaString())
	gens["ShareName"] = gen.PtrOf(gen.AlphaString())
	gens["State"] = gen.PtrOf(gen.OneConstOf(
		AzureStorageInfoValueSTATUSState_InvalidCredentials,
		AzureStorageInfoValueSTATUSState_InvalidShare,
		AzureStorageInfoValueSTATUSState_NotValidated,
		AzureStorageInfoValueSTATUSState_Ok))
	gens["Type"] = gen.PtrOf(gen.OneConstOf(AzureStorageInfoValueSTATUSType_AzureBlob, AzureStorageInfoValueSTATUSType_AzureFiles))
}

func Test_ConnStringInfo_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ConnStringInfo to ConnStringInfo via AssignPropertiesToConnStringInfo & AssignPropertiesFromConnStringInfo returns original",
		prop.ForAll(RunPropertyAssignmentTestForConnStringInfo, ConnStringInfoGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForConnStringInfo tests if a specific instance of ConnStringInfo can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForConnStringInfo(subject ConnStringInfo) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.ConnStringInfo
	err := copied.AssignPropertiesToConnStringInfo(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ConnStringInfo
	err = actual.AssignPropertiesFromConnStringInfo(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ConnStringInfo_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ConnStringInfo via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForConnStringInfo, ConnStringInfoGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForConnStringInfo runs a test to see if a specific instance of ConnStringInfo round trips to JSON and back losslessly
func RunJSONSerializationTestForConnStringInfo(subject ConnStringInfo) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ConnStringInfo
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ConnStringInfo instances for property testing - lazily instantiated by ConnStringInfoGenerator()
var connStringInfoGenerator gopter.Gen

// ConnStringInfoGenerator returns a generator of ConnStringInfo instances for property testing.
func ConnStringInfoGenerator() gopter.Gen {
	if connStringInfoGenerator != nil {
		return connStringInfoGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForConnStringInfo(generators)
	connStringInfoGenerator = gen.Struct(reflect.TypeOf(ConnStringInfo{}), generators)

	return connStringInfoGenerator
}

// AddIndependentPropertyGeneratorsForConnStringInfo is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForConnStringInfo(gens map[string]gopter.Gen) {
	gens["ConnectionString"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ConnStringInfoType_ApiHub,
		ConnStringInfoType_Custom,
		ConnStringInfoType_DocDb,
		ConnStringInfoType_EventHub,
		ConnStringInfoType_MySql,
		ConnStringInfoType_NotificationHub,
		ConnStringInfoType_PostgreSQL,
		ConnStringInfoType_RedisCache,
		ConnStringInfoType_SQLAzure,
		ConnStringInfoType_SQLServer,
		ConnStringInfoType_ServiceBus))
}

func Test_ConnStringInfo_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ConnStringInfo_STATUS to ConnStringInfo_STATUS via AssignPropertiesToConnStringInfoSTATUS & AssignPropertiesFromConnStringInfoSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForConnStringInfoSTATUS, ConnStringInfoSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForConnStringInfoSTATUS tests if a specific instance of ConnStringInfo_STATUS can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForConnStringInfoSTATUS(subject ConnStringInfo_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.ConnStringInfo_STATUS
	err := copied.AssignPropertiesToConnStringInfoSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ConnStringInfo_STATUS
	err = actual.AssignPropertiesFromConnStringInfoSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ConnStringInfo_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ConnStringInfo_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForConnStringInfoSTATUS, ConnStringInfoSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForConnStringInfoSTATUS runs a test to see if a specific instance of ConnStringInfo_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForConnStringInfoSTATUS(subject ConnStringInfo_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ConnStringInfo_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ConnStringInfo_STATUS instances for property testing - lazily instantiated by
// ConnStringInfoSTATUSGenerator()
var connStringInfoSTATUSGenerator gopter.Gen

// ConnStringInfoSTATUSGenerator returns a generator of ConnStringInfo_STATUS instances for property testing.
func ConnStringInfoSTATUSGenerator() gopter.Gen {
	if connStringInfoSTATUSGenerator != nil {
		return connStringInfoSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForConnStringInfoSTATUS(generators)
	connStringInfoSTATUSGenerator = gen.Struct(reflect.TypeOf(ConnStringInfo_STATUS{}), generators)

	return connStringInfoSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForConnStringInfoSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForConnStringInfoSTATUS(gens map[string]gopter.Gen) {
	gens["ConnectionString"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ConnStringInfoSTATUSType_ApiHub,
		ConnStringInfoSTATUSType_Custom,
		ConnStringInfoSTATUSType_DocDb,
		ConnStringInfoSTATUSType_EventHub,
		ConnStringInfoSTATUSType_MySql,
		ConnStringInfoSTATUSType_NotificationHub,
		ConnStringInfoSTATUSType_PostgreSQL,
		ConnStringInfoSTATUSType_RedisCache,
		ConnStringInfoSTATUSType_SQLAzure,
		ConnStringInfoSTATUSType_SQLServer,
		ConnStringInfoSTATUSType_ServiceBus))
}

func Test_CorsSettings_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CorsSettings to CorsSettings via AssignPropertiesToCorsSettings & AssignPropertiesFromCorsSettings returns original",
		prop.ForAll(RunPropertyAssignmentTestForCorsSettings, CorsSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCorsSettings tests if a specific instance of CorsSettings can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForCorsSettings(subject CorsSettings) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.CorsSettings
	err := copied.AssignPropertiesToCorsSettings(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CorsSettings
	err = actual.AssignPropertiesFromCorsSettings(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CorsSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CorsSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCorsSettings, CorsSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCorsSettings runs a test to see if a specific instance of CorsSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForCorsSettings(subject CorsSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CorsSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CorsSettings instances for property testing - lazily instantiated by CorsSettingsGenerator()
var corsSettingsGenerator gopter.Gen

// CorsSettingsGenerator returns a generator of CorsSettings instances for property testing.
func CorsSettingsGenerator() gopter.Gen {
	if corsSettingsGenerator != nil {
		return corsSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCorsSettings(generators)
	corsSettingsGenerator = gen.Struct(reflect.TypeOf(CorsSettings{}), generators)

	return corsSettingsGenerator
}

// AddIndependentPropertyGeneratorsForCorsSettings is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCorsSettings(gens map[string]gopter.Gen) {
	gens["AllowedOrigins"] = gen.SliceOf(gen.AlphaString())
	gens["SupportCredentials"] = gen.PtrOf(gen.Bool())
}

func Test_CorsSettings_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CorsSettings_STATUS to CorsSettings_STATUS via AssignPropertiesToCorsSettingsSTATUS & AssignPropertiesFromCorsSettingsSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForCorsSettingsSTATUS, CorsSettingsSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCorsSettingsSTATUS tests if a specific instance of CorsSettings_STATUS can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForCorsSettingsSTATUS(subject CorsSettings_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.CorsSettings_STATUS
	err := copied.AssignPropertiesToCorsSettingsSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CorsSettings_STATUS
	err = actual.AssignPropertiesFromCorsSettingsSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CorsSettings_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CorsSettings_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCorsSettingsSTATUS, CorsSettingsSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCorsSettingsSTATUS runs a test to see if a specific instance of CorsSettings_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForCorsSettingsSTATUS(subject CorsSettings_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CorsSettings_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CorsSettings_STATUS instances for property testing - lazily instantiated by CorsSettingsSTATUSGenerator()
var corsSettingsSTATUSGenerator gopter.Gen

// CorsSettingsSTATUSGenerator returns a generator of CorsSettings_STATUS instances for property testing.
func CorsSettingsSTATUSGenerator() gopter.Gen {
	if corsSettingsSTATUSGenerator != nil {
		return corsSettingsSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCorsSettingsSTATUS(generators)
	corsSettingsSTATUSGenerator = gen.Struct(reflect.TypeOf(CorsSettings_STATUS{}), generators)

	return corsSettingsSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForCorsSettingsSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCorsSettingsSTATUS(gens map[string]gopter.Gen) {
	gens["AllowedOrigins"] = gen.SliceOf(gen.AlphaString())
	gens["SupportCredentials"] = gen.PtrOf(gen.Bool())
}

func Test_Experiments_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Experiments to Experiments via AssignPropertiesToExperiments & AssignPropertiesFromExperiments returns original",
		prop.ForAll(RunPropertyAssignmentTestForExperiments, ExperimentsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExperiments tests if a specific instance of Experiments can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForExperiments(subject Experiments) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.Experiments
	err := copied.AssignPropertiesToExperiments(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Experiments
	err = actual.AssignPropertiesFromExperiments(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Experiments_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Experiments via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExperiments, ExperimentsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExperiments runs a test to see if a specific instance of Experiments round trips to JSON and back losslessly
func RunJSONSerializationTestForExperiments(subject Experiments) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Experiments
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Experiments instances for property testing - lazily instantiated by ExperimentsGenerator()
var experimentsGenerator gopter.Gen

// ExperimentsGenerator returns a generator of Experiments instances for property testing.
func ExperimentsGenerator() gopter.Gen {
	if experimentsGenerator != nil {
		return experimentsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForExperiments(generators)
	experimentsGenerator = gen.Struct(reflect.TypeOf(Experiments{}), generators)

	return experimentsGenerator
}

// AddRelatedPropertyGeneratorsForExperiments is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForExperiments(gens map[string]gopter.Gen) {
	gens["RampUpRules"] = gen.SliceOf(RampUpRuleGenerator())
}

func Test_Experiments_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Experiments_STATUS to Experiments_STATUS via AssignPropertiesToExperimentsSTATUS & AssignPropertiesFromExperimentsSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForExperimentsSTATUS, ExperimentsSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExperimentsSTATUS tests if a specific instance of Experiments_STATUS can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForExperimentsSTATUS(subject Experiments_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.Experiments_STATUS
	err := copied.AssignPropertiesToExperimentsSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Experiments_STATUS
	err = actual.AssignPropertiesFromExperimentsSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Experiments_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Experiments_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExperimentsSTATUS, ExperimentsSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExperimentsSTATUS runs a test to see if a specific instance of Experiments_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForExperimentsSTATUS(subject Experiments_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Experiments_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Experiments_STATUS instances for property testing - lazily instantiated by ExperimentsSTATUSGenerator()
var experimentsSTATUSGenerator gopter.Gen

// ExperimentsSTATUSGenerator returns a generator of Experiments_STATUS instances for property testing.
func ExperimentsSTATUSGenerator() gopter.Gen {
	if experimentsSTATUSGenerator != nil {
		return experimentsSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForExperimentsSTATUS(generators)
	experimentsSTATUSGenerator = gen.Struct(reflect.TypeOf(Experiments_STATUS{}), generators)

	return experimentsSTATUSGenerator
}

// AddRelatedPropertyGeneratorsForExperimentsSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForExperimentsSTATUS(gens map[string]gopter.Gen) {
	gens["RampUpRules"] = gen.SliceOf(RampUpRuleSTATUSGenerator())
}

func Test_HandlerMapping_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HandlerMapping to HandlerMapping via AssignPropertiesToHandlerMapping & AssignPropertiesFromHandlerMapping returns original",
		prop.ForAll(RunPropertyAssignmentTestForHandlerMapping, HandlerMappingGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHandlerMapping tests if a specific instance of HandlerMapping can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForHandlerMapping(subject HandlerMapping) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.HandlerMapping
	err := copied.AssignPropertiesToHandlerMapping(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HandlerMapping
	err = actual.AssignPropertiesFromHandlerMapping(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HandlerMapping_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HandlerMapping via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHandlerMapping, HandlerMappingGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHandlerMapping runs a test to see if a specific instance of HandlerMapping round trips to JSON and back losslessly
func RunJSONSerializationTestForHandlerMapping(subject HandlerMapping) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HandlerMapping
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HandlerMapping instances for property testing - lazily instantiated by HandlerMappingGenerator()
var handlerMappingGenerator gopter.Gen

// HandlerMappingGenerator returns a generator of HandlerMapping instances for property testing.
func HandlerMappingGenerator() gopter.Gen {
	if handlerMappingGenerator != nil {
		return handlerMappingGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHandlerMapping(generators)
	handlerMappingGenerator = gen.Struct(reflect.TypeOf(HandlerMapping{}), generators)

	return handlerMappingGenerator
}

// AddIndependentPropertyGeneratorsForHandlerMapping is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHandlerMapping(gens map[string]gopter.Gen) {
	gens["Arguments"] = gen.PtrOf(gen.AlphaString())
	gens["Extension"] = gen.PtrOf(gen.AlphaString())
	gens["ScriptProcessor"] = gen.PtrOf(gen.AlphaString())
}

func Test_HandlerMapping_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HandlerMapping_STATUS to HandlerMapping_STATUS via AssignPropertiesToHandlerMappingSTATUS & AssignPropertiesFromHandlerMappingSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForHandlerMappingSTATUS, HandlerMappingSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHandlerMappingSTATUS tests if a specific instance of HandlerMapping_STATUS can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForHandlerMappingSTATUS(subject HandlerMapping_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.HandlerMapping_STATUS
	err := copied.AssignPropertiesToHandlerMappingSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HandlerMapping_STATUS
	err = actual.AssignPropertiesFromHandlerMappingSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HandlerMapping_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HandlerMapping_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHandlerMappingSTATUS, HandlerMappingSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHandlerMappingSTATUS runs a test to see if a specific instance of HandlerMapping_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForHandlerMappingSTATUS(subject HandlerMapping_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HandlerMapping_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HandlerMapping_STATUS instances for property testing - lazily instantiated by
// HandlerMappingSTATUSGenerator()
var handlerMappingSTATUSGenerator gopter.Gen

// HandlerMappingSTATUSGenerator returns a generator of HandlerMapping_STATUS instances for property testing.
func HandlerMappingSTATUSGenerator() gopter.Gen {
	if handlerMappingSTATUSGenerator != nil {
		return handlerMappingSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHandlerMappingSTATUS(generators)
	handlerMappingSTATUSGenerator = gen.Struct(reflect.TypeOf(HandlerMapping_STATUS{}), generators)

	return handlerMappingSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForHandlerMappingSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHandlerMappingSTATUS(gens map[string]gopter.Gen) {
	gens["Arguments"] = gen.PtrOf(gen.AlphaString())
	gens["Extension"] = gen.PtrOf(gen.AlphaString())
	gens["ScriptProcessor"] = gen.PtrOf(gen.AlphaString())
}

func Test_IpSecurityRestriction_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IpSecurityRestriction to IpSecurityRestriction via AssignPropertiesToIpSecurityRestriction & AssignPropertiesFromIpSecurityRestriction returns original",
		prop.ForAll(RunPropertyAssignmentTestForIpSecurityRestriction, IpSecurityRestrictionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIpSecurityRestriction tests if a specific instance of IpSecurityRestriction can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForIpSecurityRestriction(subject IpSecurityRestriction) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.IpSecurityRestriction
	err := copied.AssignPropertiesToIpSecurityRestriction(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IpSecurityRestriction
	err = actual.AssignPropertiesFromIpSecurityRestriction(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IpSecurityRestriction_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpSecurityRestriction via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpSecurityRestriction, IpSecurityRestrictionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpSecurityRestriction runs a test to see if a specific instance of IpSecurityRestriction round trips to JSON and back losslessly
func RunJSONSerializationTestForIpSecurityRestriction(subject IpSecurityRestriction) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpSecurityRestriction
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpSecurityRestriction instances for property testing - lazily instantiated by
// IpSecurityRestrictionGenerator()
var ipSecurityRestrictionGenerator gopter.Gen

// IpSecurityRestrictionGenerator returns a generator of IpSecurityRestriction instances for property testing.
func IpSecurityRestrictionGenerator() gopter.Gen {
	if ipSecurityRestrictionGenerator != nil {
		return ipSecurityRestrictionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpSecurityRestriction(generators)
	ipSecurityRestrictionGenerator = gen.Struct(reflect.TypeOf(IpSecurityRestriction{}), generators)

	return ipSecurityRestrictionGenerator
}

// AddIndependentPropertyGeneratorsForIpSecurityRestriction is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpSecurityRestriction(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.AlphaString())
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["Headers"] = gen.MapOf(gen.AlphaString(), gen.SliceOf(gen.AlphaString()))
	gens["IpAddress"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Priority"] = gen.PtrOf(gen.Int())
	gens["SubnetMask"] = gen.PtrOf(gen.AlphaString())
	gens["SubnetTrafficTag"] = gen.PtrOf(gen.Int())
	gens["Tag"] = gen.PtrOf(gen.OneConstOf(IpSecurityRestrictionTag_Default, IpSecurityRestrictionTag_ServiceTag, IpSecurityRestrictionTag_XffProxy))
	gens["VnetTrafficTag"] = gen.PtrOf(gen.Int())
}

func Test_IpSecurityRestriction_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IpSecurityRestriction_STATUS to IpSecurityRestriction_STATUS via AssignPropertiesToIpSecurityRestrictionSTATUS & AssignPropertiesFromIpSecurityRestrictionSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForIpSecurityRestrictionSTATUS, IpSecurityRestrictionSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIpSecurityRestrictionSTATUS tests if a specific instance of IpSecurityRestriction_STATUS can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForIpSecurityRestrictionSTATUS(subject IpSecurityRestriction_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.IpSecurityRestriction_STATUS
	err := copied.AssignPropertiesToIpSecurityRestrictionSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IpSecurityRestriction_STATUS
	err = actual.AssignPropertiesFromIpSecurityRestrictionSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IpSecurityRestriction_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpSecurityRestriction_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpSecurityRestrictionSTATUS, IpSecurityRestrictionSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpSecurityRestrictionSTATUS runs a test to see if a specific instance of IpSecurityRestriction_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForIpSecurityRestrictionSTATUS(subject IpSecurityRestriction_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpSecurityRestriction_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpSecurityRestriction_STATUS instances for property testing - lazily instantiated by
// IpSecurityRestrictionSTATUSGenerator()
var ipSecurityRestrictionSTATUSGenerator gopter.Gen

// IpSecurityRestrictionSTATUSGenerator returns a generator of IpSecurityRestriction_STATUS instances for property testing.
func IpSecurityRestrictionSTATUSGenerator() gopter.Gen {
	if ipSecurityRestrictionSTATUSGenerator != nil {
		return ipSecurityRestrictionSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpSecurityRestrictionSTATUS(generators)
	ipSecurityRestrictionSTATUSGenerator = gen.Struct(reflect.TypeOf(IpSecurityRestriction_STATUS{}), generators)

	return ipSecurityRestrictionSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForIpSecurityRestrictionSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpSecurityRestrictionSTATUS(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.AlphaString())
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["Headers"] = gen.MapOf(gen.AlphaString(), gen.SliceOf(gen.AlphaString()))
	gens["IpAddress"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Priority"] = gen.PtrOf(gen.Int())
	gens["SubnetMask"] = gen.PtrOf(gen.AlphaString())
	gens["SubnetTrafficTag"] = gen.PtrOf(gen.Int())
	gens["Tag"] = gen.PtrOf(gen.OneConstOf(IpSecurityRestrictionSTATUSTag_Default, IpSecurityRestrictionSTATUSTag_ServiceTag, IpSecurityRestrictionSTATUSTag_XffProxy))
	gens["VnetSubnetResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["VnetTrafficTag"] = gen.PtrOf(gen.Int())
}

func Test_NameValuePair_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NameValuePair to NameValuePair via AssignPropertiesToNameValuePair & AssignPropertiesFromNameValuePair returns original",
		prop.ForAll(RunPropertyAssignmentTestForNameValuePair, NameValuePairGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNameValuePair tests if a specific instance of NameValuePair can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForNameValuePair(subject NameValuePair) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.NameValuePair
	err := copied.AssignPropertiesToNameValuePair(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NameValuePair
	err = actual.AssignPropertiesFromNameValuePair(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NameValuePair_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NameValuePair via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNameValuePair, NameValuePairGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNameValuePair runs a test to see if a specific instance of NameValuePair round trips to JSON and back losslessly
func RunJSONSerializationTestForNameValuePair(subject NameValuePair) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NameValuePair
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NameValuePair instances for property testing - lazily instantiated by NameValuePairGenerator()
var nameValuePairGenerator gopter.Gen

// NameValuePairGenerator returns a generator of NameValuePair instances for property testing.
func NameValuePairGenerator() gopter.Gen {
	if nameValuePairGenerator != nil {
		return nameValuePairGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNameValuePair(generators)
	nameValuePairGenerator = gen.Struct(reflect.TypeOf(NameValuePair{}), generators)

	return nameValuePairGenerator
}

// AddIndependentPropertyGeneratorsForNameValuePair is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNameValuePair(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_NameValuePair_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NameValuePair_STATUS to NameValuePair_STATUS via AssignPropertiesToNameValuePairSTATUS & AssignPropertiesFromNameValuePairSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForNameValuePairSTATUS, NameValuePairSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNameValuePairSTATUS tests if a specific instance of NameValuePair_STATUS can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForNameValuePairSTATUS(subject NameValuePair_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.NameValuePair_STATUS
	err := copied.AssignPropertiesToNameValuePairSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NameValuePair_STATUS
	err = actual.AssignPropertiesFromNameValuePairSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NameValuePair_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NameValuePair_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNameValuePairSTATUS, NameValuePairSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNameValuePairSTATUS runs a test to see if a specific instance of NameValuePair_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForNameValuePairSTATUS(subject NameValuePair_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NameValuePair_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NameValuePair_STATUS instances for property testing - lazily instantiated by
// NameValuePairSTATUSGenerator()
var nameValuePairSTATUSGenerator gopter.Gen

// NameValuePairSTATUSGenerator returns a generator of NameValuePair_STATUS instances for property testing.
func NameValuePairSTATUSGenerator() gopter.Gen {
	if nameValuePairSTATUSGenerator != nil {
		return nameValuePairSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNameValuePairSTATUS(generators)
	nameValuePairSTATUSGenerator = gen.Struct(reflect.TypeOf(NameValuePair_STATUS{}), generators)

	return nameValuePairSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForNameValuePairSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNameValuePairSTATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_PushSettings_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PushSettings_STATUS to PushSettings_STATUS via AssignPropertiesToPushSettingsSTATUS & AssignPropertiesFromPushSettingsSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForPushSettingsSTATUS, PushSettingsSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPushSettingsSTATUS tests if a specific instance of PushSettings_STATUS can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForPushSettingsSTATUS(subject PushSettings_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.PushSettings_STATUS
	err := copied.AssignPropertiesToPushSettingsSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PushSettings_STATUS
	err = actual.AssignPropertiesFromPushSettingsSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PushSettings_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PushSettings_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPushSettingsSTATUS, PushSettingsSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPushSettingsSTATUS runs a test to see if a specific instance of PushSettings_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPushSettingsSTATUS(subject PushSettings_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PushSettings_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PushSettings_STATUS instances for property testing - lazily instantiated by PushSettingsSTATUSGenerator()
var pushSettingsSTATUSGenerator gopter.Gen

// PushSettingsSTATUSGenerator returns a generator of PushSettings_STATUS instances for property testing.
func PushSettingsSTATUSGenerator() gopter.Gen {
	if pushSettingsSTATUSGenerator != nil {
		return pushSettingsSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPushSettingsSTATUS(generators)
	pushSettingsSTATUSGenerator = gen.Struct(reflect.TypeOf(PushSettings_STATUS{}), generators)

	return pushSettingsSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForPushSettingsSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPushSettingsSTATUS(gens map[string]gopter.Gen) {
	gens["DynamicTagsJson"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IsPushEnabled"] = gen.PtrOf(gen.Bool())
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["TagWhitelistJson"] = gen.PtrOf(gen.AlphaString())
	gens["TagsRequiringAuth"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_SiteLimits_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SiteLimits to SiteLimits via AssignPropertiesToSiteLimits & AssignPropertiesFromSiteLimits returns original",
		prop.ForAll(RunPropertyAssignmentTestForSiteLimits, SiteLimitsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSiteLimits tests if a specific instance of SiteLimits can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForSiteLimits(subject SiteLimits) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.SiteLimits
	err := copied.AssignPropertiesToSiteLimits(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SiteLimits
	err = actual.AssignPropertiesFromSiteLimits(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SiteLimits_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SiteLimits via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSiteLimits, SiteLimitsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSiteLimits runs a test to see if a specific instance of SiteLimits round trips to JSON and back losslessly
func RunJSONSerializationTestForSiteLimits(subject SiteLimits) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SiteLimits
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SiteLimits instances for property testing - lazily instantiated by SiteLimitsGenerator()
var siteLimitsGenerator gopter.Gen

// SiteLimitsGenerator returns a generator of SiteLimits instances for property testing.
func SiteLimitsGenerator() gopter.Gen {
	if siteLimitsGenerator != nil {
		return siteLimitsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSiteLimits(generators)
	siteLimitsGenerator = gen.Struct(reflect.TypeOf(SiteLimits{}), generators)

	return siteLimitsGenerator
}

// AddIndependentPropertyGeneratorsForSiteLimits is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSiteLimits(gens map[string]gopter.Gen) {
	gens["MaxDiskSizeInMb"] = gen.PtrOf(gen.Int())
	gens["MaxMemoryInMb"] = gen.PtrOf(gen.Int())
	gens["MaxPercentageCpu"] = gen.PtrOf(gen.Float64())
}

func Test_SiteLimits_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SiteLimits_STATUS to SiteLimits_STATUS via AssignPropertiesToSiteLimitsSTATUS & AssignPropertiesFromSiteLimitsSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSiteLimitsSTATUS, SiteLimitsSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSiteLimitsSTATUS tests if a specific instance of SiteLimits_STATUS can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForSiteLimitsSTATUS(subject SiteLimits_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.SiteLimits_STATUS
	err := copied.AssignPropertiesToSiteLimitsSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SiteLimits_STATUS
	err = actual.AssignPropertiesFromSiteLimitsSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SiteLimits_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SiteLimits_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSiteLimitsSTATUS, SiteLimitsSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSiteLimitsSTATUS runs a test to see if a specific instance of SiteLimits_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSiteLimitsSTATUS(subject SiteLimits_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SiteLimits_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SiteLimits_STATUS instances for property testing - lazily instantiated by SiteLimitsSTATUSGenerator()
var siteLimitsSTATUSGenerator gopter.Gen

// SiteLimitsSTATUSGenerator returns a generator of SiteLimits_STATUS instances for property testing.
func SiteLimitsSTATUSGenerator() gopter.Gen {
	if siteLimitsSTATUSGenerator != nil {
		return siteLimitsSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSiteLimitsSTATUS(generators)
	siteLimitsSTATUSGenerator = gen.Struct(reflect.TypeOf(SiteLimits_STATUS{}), generators)

	return siteLimitsSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForSiteLimitsSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSiteLimitsSTATUS(gens map[string]gopter.Gen) {
	gens["MaxDiskSizeInMb"] = gen.PtrOf(gen.Int())
	gens["MaxMemoryInMb"] = gen.PtrOf(gen.Int())
	gens["MaxPercentageCpu"] = gen.PtrOf(gen.Float64())
}

func Test_SiteMachineKey_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SiteMachineKey_STATUS to SiteMachineKey_STATUS via AssignPropertiesToSiteMachineKeySTATUS & AssignPropertiesFromSiteMachineKeySTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSiteMachineKeySTATUS, SiteMachineKeySTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSiteMachineKeySTATUS tests if a specific instance of SiteMachineKey_STATUS can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForSiteMachineKeySTATUS(subject SiteMachineKey_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.SiteMachineKey_STATUS
	err := copied.AssignPropertiesToSiteMachineKeySTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SiteMachineKey_STATUS
	err = actual.AssignPropertiesFromSiteMachineKeySTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SiteMachineKey_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SiteMachineKey_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSiteMachineKeySTATUS, SiteMachineKeySTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSiteMachineKeySTATUS runs a test to see if a specific instance of SiteMachineKey_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSiteMachineKeySTATUS(subject SiteMachineKey_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SiteMachineKey_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SiteMachineKey_STATUS instances for property testing - lazily instantiated by
// SiteMachineKeySTATUSGenerator()
var siteMachineKeySTATUSGenerator gopter.Gen

// SiteMachineKeySTATUSGenerator returns a generator of SiteMachineKey_STATUS instances for property testing.
func SiteMachineKeySTATUSGenerator() gopter.Gen {
	if siteMachineKeySTATUSGenerator != nil {
		return siteMachineKeySTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSiteMachineKeySTATUS(generators)
	siteMachineKeySTATUSGenerator = gen.Struct(reflect.TypeOf(SiteMachineKey_STATUS{}), generators)

	return siteMachineKeySTATUSGenerator
}

// AddIndependentPropertyGeneratorsForSiteMachineKeySTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSiteMachineKeySTATUS(gens map[string]gopter.Gen) {
	gens["Decryption"] = gen.PtrOf(gen.AlphaString())
	gens["DecryptionKey"] = gen.PtrOf(gen.AlphaString())
	gens["Validation"] = gen.PtrOf(gen.AlphaString())
	gens["ValidationKey"] = gen.PtrOf(gen.AlphaString())
}

func Test_Sites_Spec_Properties_SiteConfig_AzureStorageAccounts_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Sites_Spec_Properties_SiteConfig_AzureStorageAccounts to Sites_Spec_Properties_SiteConfig_AzureStorageAccounts via AssignPropertiesToSitesSpecPropertiesSiteConfigAzureStorageAccounts & AssignPropertiesFromSitesSpecPropertiesSiteConfigAzureStorageAccounts returns original",
		prop.ForAll(RunPropertyAssignmentTestForSitesSpecPropertiesSiteConfigAzureStorageAccounts, SitesSpecPropertiesSiteConfigAzureStorageAccountsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSitesSpecPropertiesSiteConfigAzureStorageAccounts tests if a specific instance of Sites_Spec_Properties_SiteConfig_AzureStorageAccounts can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForSitesSpecPropertiesSiteConfigAzureStorageAccounts(subject Sites_Spec_Properties_SiteConfig_AzureStorageAccounts) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.Sites_Spec_Properties_SiteConfig_AzureStorageAccounts
	err := copied.AssignPropertiesToSitesSpecPropertiesSiteConfigAzureStorageAccounts(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Sites_Spec_Properties_SiteConfig_AzureStorageAccounts
	err = actual.AssignPropertiesFromSitesSpecPropertiesSiteConfigAzureStorageAccounts(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Sites_Spec_Properties_SiteConfig_AzureStorageAccounts_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sites_Spec_Properties_SiteConfig_AzureStorageAccounts via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSitesSpecPropertiesSiteConfigAzureStorageAccounts, SitesSpecPropertiesSiteConfigAzureStorageAccountsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSitesSpecPropertiesSiteConfigAzureStorageAccounts runs a test to see if a specific instance of Sites_Spec_Properties_SiteConfig_AzureStorageAccounts round trips to JSON and back losslessly
func RunJSONSerializationTestForSitesSpecPropertiesSiteConfigAzureStorageAccounts(subject Sites_Spec_Properties_SiteConfig_AzureStorageAccounts) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sites_Spec_Properties_SiteConfig_AzureStorageAccounts
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sites_Spec_Properties_SiteConfig_AzureStorageAccounts instances for property testing - lazily
// instantiated by SitesSpecPropertiesSiteConfigAzureStorageAccountsGenerator()
var sitesSpecPropertiesSiteConfigAzureStorageAccountsGenerator gopter.Gen

// SitesSpecPropertiesSiteConfigAzureStorageAccountsGenerator returns a generator of Sites_Spec_Properties_SiteConfig_AzureStorageAccounts instances for property testing.
func SitesSpecPropertiesSiteConfigAzureStorageAccountsGenerator() gopter.Gen {
	if sitesSpecPropertiesSiteConfigAzureStorageAccountsGenerator != nil {
		return sitesSpecPropertiesSiteConfigAzureStorageAccountsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSitesSpecPropertiesSiteConfigAzureStorageAccounts(generators)
	sitesSpecPropertiesSiteConfigAzureStorageAccountsGenerator = gen.Struct(reflect.TypeOf(Sites_Spec_Properties_SiteConfig_AzureStorageAccounts{}), generators)

	return sitesSpecPropertiesSiteConfigAzureStorageAccountsGenerator
}

// AddIndependentPropertyGeneratorsForSitesSpecPropertiesSiteConfigAzureStorageAccounts is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSitesSpecPropertiesSiteConfigAzureStorageAccounts(gens map[string]gopter.Gen) {
	gens["AccountName"] = gen.PtrOf(gen.AlphaString())
	gens["MountPath"] = gen.PtrOf(gen.AlphaString())
	gens["ShareName"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(SitesSpecPropertiesSiteConfigAzureStorageAccountsType_AzureBlob, SitesSpecPropertiesSiteConfigAzureStorageAccountsType_AzureFiles))
}

func Test_Sites_Spec_Properties_SiteConfig_Push_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Sites_Spec_Properties_SiteConfig_Push to Sites_Spec_Properties_SiteConfig_Push via AssignPropertiesToSitesSpecPropertiesSiteConfigPush & AssignPropertiesFromSitesSpecPropertiesSiteConfigPush returns original",
		prop.ForAll(RunPropertyAssignmentTestForSitesSpecPropertiesSiteConfigPush, SitesSpecPropertiesSiteConfigPushGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSitesSpecPropertiesSiteConfigPush tests if a specific instance of Sites_Spec_Properties_SiteConfig_Push can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForSitesSpecPropertiesSiteConfigPush(subject Sites_Spec_Properties_SiteConfig_Push) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.Sites_Spec_Properties_SiteConfig_Push
	err := copied.AssignPropertiesToSitesSpecPropertiesSiteConfigPush(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Sites_Spec_Properties_SiteConfig_Push
	err = actual.AssignPropertiesFromSitesSpecPropertiesSiteConfigPush(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Sites_Spec_Properties_SiteConfig_Push_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sites_Spec_Properties_SiteConfig_Push via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSitesSpecPropertiesSiteConfigPush, SitesSpecPropertiesSiteConfigPushGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSitesSpecPropertiesSiteConfigPush runs a test to see if a specific instance of Sites_Spec_Properties_SiteConfig_Push round trips to JSON and back losslessly
func RunJSONSerializationTestForSitesSpecPropertiesSiteConfigPush(subject Sites_Spec_Properties_SiteConfig_Push) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sites_Spec_Properties_SiteConfig_Push
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sites_Spec_Properties_SiteConfig_Push instances for property testing - lazily instantiated by
// SitesSpecPropertiesSiteConfigPushGenerator()
var sitesSpecPropertiesSiteConfigPushGenerator gopter.Gen

// SitesSpecPropertiesSiteConfigPushGenerator returns a generator of Sites_Spec_Properties_SiteConfig_Push instances for property testing.
func SitesSpecPropertiesSiteConfigPushGenerator() gopter.Gen {
	if sitesSpecPropertiesSiteConfigPushGenerator != nil {
		return sitesSpecPropertiesSiteConfigPushGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSitesSpecPropertiesSiteConfigPush(generators)
	sitesSpecPropertiesSiteConfigPushGenerator = gen.Struct(reflect.TypeOf(Sites_Spec_Properties_SiteConfig_Push{}), generators)

	return sitesSpecPropertiesSiteConfigPushGenerator
}

// AddIndependentPropertyGeneratorsForSitesSpecPropertiesSiteConfigPush is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSitesSpecPropertiesSiteConfigPush(gens map[string]gopter.Gen) {
	gens["DynamicTagsJson"] = gen.PtrOf(gen.AlphaString())
	gens["IsPushEnabled"] = gen.PtrOf(gen.Bool())
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["TagWhitelistJson"] = gen.PtrOf(gen.AlphaString())
	gens["TagsRequiringAuth"] = gen.PtrOf(gen.AlphaString())
}

func Test_UserAssignedIdentity_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UserAssignedIdentity_STATUS to UserAssignedIdentity_STATUS via AssignPropertiesToUserAssignedIdentitySTATUS & AssignPropertiesFromUserAssignedIdentitySTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForUserAssignedIdentitySTATUS, UserAssignedIdentitySTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUserAssignedIdentitySTATUS tests if a specific instance of UserAssignedIdentity_STATUS can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForUserAssignedIdentitySTATUS(subject UserAssignedIdentity_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.UserAssignedIdentity_STATUS
	err := copied.AssignPropertiesToUserAssignedIdentitySTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UserAssignedIdentity_STATUS
	err = actual.AssignPropertiesFromUserAssignedIdentitySTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UserAssignedIdentity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentitySTATUS, UserAssignedIdentitySTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentitySTATUS runs a test to see if a specific instance of UserAssignedIdentity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentitySTATUS(subject UserAssignedIdentity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentity_STATUS instances for property testing - lazily instantiated by
// UserAssignedIdentitySTATUSGenerator()
var userAssignedIdentitySTATUSGenerator gopter.Gen

// UserAssignedIdentitySTATUSGenerator returns a generator of UserAssignedIdentity_STATUS instances for property testing.
func UserAssignedIdentitySTATUSGenerator() gopter.Gen {
	if userAssignedIdentitySTATUSGenerator != nil {
		return userAssignedIdentitySTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserAssignedIdentitySTATUS(generators)
	userAssignedIdentitySTATUSGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentity_STATUS{}), generators)

	return userAssignedIdentitySTATUSGenerator
}

// AddIndependentPropertyGeneratorsForUserAssignedIdentitySTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserAssignedIdentitySTATUS(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualApplication_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualApplication to VirtualApplication via AssignPropertiesToVirtualApplication & AssignPropertiesFromVirtualApplication returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualApplication, VirtualApplicationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualApplication tests if a specific instance of VirtualApplication can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForVirtualApplication(subject VirtualApplication) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.VirtualApplication
	err := copied.AssignPropertiesToVirtualApplication(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualApplication
	err = actual.AssignPropertiesFromVirtualApplication(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualApplication_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualApplication via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualApplication, VirtualApplicationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualApplication runs a test to see if a specific instance of VirtualApplication round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualApplication(subject VirtualApplication) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualApplication
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualApplication instances for property testing - lazily instantiated by VirtualApplicationGenerator()
var virtualApplicationGenerator gopter.Gen

// VirtualApplicationGenerator returns a generator of VirtualApplication instances for property testing.
// We first initialize virtualApplicationGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualApplicationGenerator() gopter.Gen {
	if virtualApplicationGenerator != nil {
		return virtualApplicationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualApplication(generators)
	virtualApplicationGenerator = gen.Struct(reflect.TypeOf(VirtualApplication{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualApplication(generators)
	AddRelatedPropertyGeneratorsForVirtualApplication(generators)
	virtualApplicationGenerator = gen.Struct(reflect.TypeOf(VirtualApplication{}), generators)

	return virtualApplicationGenerator
}

// AddIndependentPropertyGeneratorsForVirtualApplication is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualApplication(gens map[string]gopter.Gen) {
	gens["PhysicalPath"] = gen.PtrOf(gen.AlphaString())
	gens["PreloadEnabled"] = gen.PtrOf(gen.Bool())
	gens["VirtualPath"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualApplication is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualApplication(gens map[string]gopter.Gen) {
	gens["VirtualDirectories"] = gen.SliceOf(VirtualDirectoryGenerator())
}

func Test_VirtualApplication_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualApplication_STATUS to VirtualApplication_STATUS via AssignPropertiesToVirtualApplicationSTATUS & AssignPropertiesFromVirtualApplicationSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualApplicationSTATUS, VirtualApplicationSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualApplicationSTATUS tests if a specific instance of VirtualApplication_STATUS can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForVirtualApplicationSTATUS(subject VirtualApplication_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.VirtualApplication_STATUS
	err := copied.AssignPropertiesToVirtualApplicationSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualApplication_STATUS
	err = actual.AssignPropertiesFromVirtualApplicationSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualApplication_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualApplication_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualApplicationSTATUS, VirtualApplicationSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualApplicationSTATUS runs a test to see if a specific instance of VirtualApplication_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualApplicationSTATUS(subject VirtualApplication_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualApplication_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualApplication_STATUS instances for property testing - lazily instantiated by
// VirtualApplicationSTATUSGenerator()
var virtualApplicationSTATUSGenerator gopter.Gen

// VirtualApplicationSTATUSGenerator returns a generator of VirtualApplication_STATUS instances for property testing.
// We first initialize virtualApplicationSTATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualApplicationSTATUSGenerator() gopter.Gen {
	if virtualApplicationSTATUSGenerator != nil {
		return virtualApplicationSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualApplicationSTATUS(generators)
	virtualApplicationSTATUSGenerator = gen.Struct(reflect.TypeOf(VirtualApplication_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualApplicationSTATUS(generators)
	AddRelatedPropertyGeneratorsForVirtualApplicationSTATUS(generators)
	virtualApplicationSTATUSGenerator = gen.Struct(reflect.TypeOf(VirtualApplication_STATUS{}), generators)

	return virtualApplicationSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForVirtualApplicationSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualApplicationSTATUS(gens map[string]gopter.Gen) {
	gens["PhysicalPath"] = gen.PtrOf(gen.AlphaString())
	gens["PreloadEnabled"] = gen.PtrOf(gen.Bool())
	gens["VirtualPath"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualApplicationSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualApplicationSTATUS(gens map[string]gopter.Gen) {
	gens["VirtualDirectories"] = gen.SliceOf(VirtualDirectorySTATUSGenerator())
}

func Test_AutoHealActions_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AutoHealActions to AutoHealActions via AssignPropertiesToAutoHealActions & AssignPropertiesFromAutoHealActions returns original",
		prop.ForAll(RunPropertyAssignmentTestForAutoHealActions, AutoHealActionsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAutoHealActions tests if a specific instance of AutoHealActions can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForAutoHealActions(subject AutoHealActions) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.AutoHealActions
	err := copied.AssignPropertiesToAutoHealActions(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AutoHealActions
	err = actual.AssignPropertiesFromAutoHealActions(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AutoHealActions_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoHealActions via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoHealActions, AutoHealActionsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoHealActions runs a test to see if a specific instance of AutoHealActions round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoHealActions(subject AutoHealActions) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoHealActions
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoHealActions instances for property testing - lazily instantiated by AutoHealActionsGenerator()
var autoHealActionsGenerator gopter.Gen

// AutoHealActionsGenerator returns a generator of AutoHealActions instances for property testing.
// We first initialize autoHealActionsGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AutoHealActionsGenerator() gopter.Gen {
	if autoHealActionsGenerator != nil {
		return autoHealActionsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoHealActions(generators)
	autoHealActionsGenerator = gen.Struct(reflect.TypeOf(AutoHealActions{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoHealActions(generators)
	AddRelatedPropertyGeneratorsForAutoHealActions(generators)
	autoHealActionsGenerator = gen.Struct(reflect.TypeOf(AutoHealActions{}), generators)

	return autoHealActionsGenerator
}

// AddIndependentPropertyGeneratorsForAutoHealActions is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoHealActions(gens map[string]gopter.Gen) {
	gens["ActionType"] = gen.PtrOf(gen.OneConstOf(AutoHealActionsActionType_CustomAction, AutoHealActionsActionType_LogEvent, AutoHealActionsActionType_Recycle))
	gens["MinProcessExecutionTime"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAutoHealActions is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoHealActions(gens map[string]gopter.Gen) {
	gens["CustomAction"] = gen.PtrOf(AutoHealCustomActionGenerator())
}

func Test_AutoHealActions_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AutoHealActions_STATUS to AutoHealActions_STATUS via AssignPropertiesToAutoHealActionsSTATUS & AssignPropertiesFromAutoHealActionsSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAutoHealActionsSTATUS, AutoHealActionsSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAutoHealActionsSTATUS tests if a specific instance of AutoHealActions_STATUS can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForAutoHealActionsSTATUS(subject AutoHealActions_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.AutoHealActions_STATUS
	err := copied.AssignPropertiesToAutoHealActionsSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AutoHealActions_STATUS
	err = actual.AssignPropertiesFromAutoHealActionsSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AutoHealActions_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoHealActions_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoHealActionsSTATUS, AutoHealActionsSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoHealActionsSTATUS runs a test to see if a specific instance of AutoHealActions_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoHealActionsSTATUS(subject AutoHealActions_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoHealActions_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoHealActions_STATUS instances for property testing - lazily instantiated by
// AutoHealActionsSTATUSGenerator()
var autoHealActionsSTATUSGenerator gopter.Gen

// AutoHealActionsSTATUSGenerator returns a generator of AutoHealActions_STATUS instances for property testing.
// We first initialize autoHealActionsSTATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AutoHealActionsSTATUSGenerator() gopter.Gen {
	if autoHealActionsSTATUSGenerator != nil {
		return autoHealActionsSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoHealActionsSTATUS(generators)
	autoHealActionsSTATUSGenerator = gen.Struct(reflect.TypeOf(AutoHealActions_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoHealActionsSTATUS(generators)
	AddRelatedPropertyGeneratorsForAutoHealActionsSTATUS(generators)
	autoHealActionsSTATUSGenerator = gen.Struct(reflect.TypeOf(AutoHealActions_STATUS{}), generators)

	return autoHealActionsSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForAutoHealActionsSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoHealActionsSTATUS(gens map[string]gopter.Gen) {
	gens["ActionType"] = gen.PtrOf(gen.OneConstOf(AutoHealActionsSTATUSActionType_CustomAction, AutoHealActionsSTATUSActionType_LogEvent, AutoHealActionsSTATUSActionType_Recycle))
	gens["MinProcessExecutionTime"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAutoHealActionsSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoHealActionsSTATUS(gens map[string]gopter.Gen) {
	gens["CustomAction"] = gen.PtrOf(AutoHealCustomActionSTATUSGenerator())
}

func Test_AutoHealTriggers_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AutoHealTriggers to AutoHealTriggers via AssignPropertiesToAutoHealTriggers & AssignPropertiesFromAutoHealTriggers returns original",
		prop.ForAll(RunPropertyAssignmentTestForAutoHealTriggers, AutoHealTriggersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAutoHealTriggers tests if a specific instance of AutoHealTriggers can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForAutoHealTriggers(subject AutoHealTriggers) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.AutoHealTriggers
	err := copied.AssignPropertiesToAutoHealTriggers(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AutoHealTriggers
	err = actual.AssignPropertiesFromAutoHealTriggers(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AutoHealTriggers_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoHealTriggers via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoHealTriggers, AutoHealTriggersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoHealTriggers runs a test to see if a specific instance of AutoHealTriggers round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoHealTriggers(subject AutoHealTriggers) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoHealTriggers
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoHealTriggers instances for property testing - lazily instantiated by AutoHealTriggersGenerator()
var autoHealTriggersGenerator gopter.Gen

// AutoHealTriggersGenerator returns a generator of AutoHealTriggers instances for property testing.
// We first initialize autoHealTriggersGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AutoHealTriggersGenerator() gopter.Gen {
	if autoHealTriggersGenerator != nil {
		return autoHealTriggersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoHealTriggers(generators)
	autoHealTriggersGenerator = gen.Struct(reflect.TypeOf(AutoHealTriggers{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoHealTriggers(generators)
	AddRelatedPropertyGeneratorsForAutoHealTriggers(generators)
	autoHealTriggersGenerator = gen.Struct(reflect.TypeOf(AutoHealTriggers{}), generators)

	return autoHealTriggersGenerator
}

// AddIndependentPropertyGeneratorsForAutoHealTriggers is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoHealTriggers(gens map[string]gopter.Gen) {
	gens["PrivateBytesInKB"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForAutoHealTriggers is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoHealTriggers(gens map[string]gopter.Gen) {
	gens["Requests"] = gen.PtrOf(RequestsBasedTriggerGenerator())
	gens["SlowRequests"] = gen.PtrOf(SlowRequestsBasedTriggerGenerator())
	gens["SlowRequestsWithPath"] = gen.SliceOf(SlowRequestsBasedTriggerGenerator())
	gens["StatusCodes"] = gen.SliceOf(StatusCodesBasedTriggerGenerator())
	gens["StatusCodesRange"] = gen.SliceOf(StatusCodesRangeBasedTriggerGenerator())
}

func Test_AutoHealTriggers_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AutoHealTriggers_STATUS to AutoHealTriggers_STATUS via AssignPropertiesToAutoHealTriggersSTATUS & AssignPropertiesFromAutoHealTriggersSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAutoHealTriggersSTATUS, AutoHealTriggersSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAutoHealTriggersSTATUS tests if a specific instance of AutoHealTriggers_STATUS can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForAutoHealTriggersSTATUS(subject AutoHealTriggers_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.AutoHealTriggers_STATUS
	err := copied.AssignPropertiesToAutoHealTriggersSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AutoHealTriggers_STATUS
	err = actual.AssignPropertiesFromAutoHealTriggersSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AutoHealTriggers_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoHealTriggers_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoHealTriggersSTATUS, AutoHealTriggersSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoHealTriggersSTATUS runs a test to see if a specific instance of AutoHealTriggers_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoHealTriggersSTATUS(subject AutoHealTriggers_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoHealTriggers_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoHealTriggers_STATUS instances for property testing - lazily instantiated by
// AutoHealTriggersSTATUSGenerator()
var autoHealTriggersSTATUSGenerator gopter.Gen

// AutoHealTriggersSTATUSGenerator returns a generator of AutoHealTriggers_STATUS instances for property testing.
// We first initialize autoHealTriggersSTATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AutoHealTriggersSTATUSGenerator() gopter.Gen {
	if autoHealTriggersSTATUSGenerator != nil {
		return autoHealTriggersSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoHealTriggersSTATUS(generators)
	autoHealTriggersSTATUSGenerator = gen.Struct(reflect.TypeOf(AutoHealTriggers_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoHealTriggersSTATUS(generators)
	AddRelatedPropertyGeneratorsForAutoHealTriggersSTATUS(generators)
	autoHealTriggersSTATUSGenerator = gen.Struct(reflect.TypeOf(AutoHealTriggers_STATUS{}), generators)

	return autoHealTriggersSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForAutoHealTriggersSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoHealTriggersSTATUS(gens map[string]gopter.Gen) {
	gens["PrivateBytesInKB"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForAutoHealTriggersSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoHealTriggersSTATUS(gens map[string]gopter.Gen) {
	gens["Requests"] = gen.PtrOf(RequestsBasedTriggerSTATUSGenerator())
	gens["SlowRequests"] = gen.PtrOf(SlowRequestsBasedTriggerSTATUSGenerator())
	gens["SlowRequestsWithPath"] = gen.SliceOf(SlowRequestsBasedTriggerSTATUSGenerator())
	gens["StatusCodes"] = gen.SliceOf(StatusCodesBasedTriggerSTATUSGenerator())
	gens["StatusCodesRange"] = gen.SliceOf(StatusCodesRangeBasedTriggerSTATUSGenerator())
}

func Test_RampUpRule_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RampUpRule to RampUpRule via AssignPropertiesToRampUpRule & AssignPropertiesFromRampUpRule returns original",
		prop.ForAll(RunPropertyAssignmentTestForRampUpRule, RampUpRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRampUpRule tests if a specific instance of RampUpRule can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForRampUpRule(subject RampUpRule) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.RampUpRule
	err := copied.AssignPropertiesToRampUpRule(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RampUpRule
	err = actual.AssignPropertiesFromRampUpRule(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RampUpRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RampUpRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRampUpRule, RampUpRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRampUpRule runs a test to see if a specific instance of RampUpRule round trips to JSON and back losslessly
func RunJSONSerializationTestForRampUpRule(subject RampUpRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RampUpRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RampUpRule instances for property testing - lazily instantiated by RampUpRuleGenerator()
var rampUpRuleGenerator gopter.Gen

// RampUpRuleGenerator returns a generator of RampUpRule instances for property testing.
func RampUpRuleGenerator() gopter.Gen {
	if rampUpRuleGenerator != nil {
		return rampUpRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRampUpRule(generators)
	rampUpRuleGenerator = gen.Struct(reflect.TypeOf(RampUpRule{}), generators)

	return rampUpRuleGenerator
}

// AddIndependentPropertyGeneratorsForRampUpRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRampUpRule(gens map[string]gopter.Gen) {
	gens["ActionHostName"] = gen.PtrOf(gen.AlphaString())
	gens["ChangeDecisionCallbackUrl"] = gen.PtrOf(gen.AlphaString())
	gens["ChangeIntervalInMinutes"] = gen.PtrOf(gen.Int())
	gens["ChangeStep"] = gen.PtrOf(gen.Float64())
	gens["MaxReroutePercentage"] = gen.PtrOf(gen.Float64())
	gens["MinReroutePercentage"] = gen.PtrOf(gen.Float64())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ReroutePercentage"] = gen.PtrOf(gen.Float64())
}

func Test_RampUpRule_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RampUpRule_STATUS to RampUpRule_STATUS via AssignPropertiesToRampUpRuleSTATUS & AssignPropertiesFromRampUpRuleSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForRampUpRuleSTATUS, RampUpRuleSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRampUpRuleSTATUS tests if a specific instance of RampUpRule_STATUS can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForRampUpRuleSTATUS(subject RampUpRule_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.RampUpRule_STATUS
	err := copied.AssignPropertiesToRampUpRuleSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RampUpRule_STATUS
	err = actual.AssignPropertiesFromRampUpRuleSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RampUpRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RampUpRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRampUpRuleSTATUS, RampUpRuleSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRampUpRuleSTATUS runs a test to see if a specific instance of RampUpRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRampUpRuleSTATUS(subject RampUpRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RampUpRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RampUpRule_STATUS instances for property testing - lazily instantiated by RampUpRuleSTATUSGenerator()
var rampUpRuleSTATUSGenerator gopter.Gen

// RampUpRuleSTATUSGenerator returns a generator of RampUpRule_STATUS instances for property testing.
func RampUpRuleSTATUSGenerator() gopter.Gen {
	if rampUpRuleSTATUSGenerator != nil {
		return rampUpRuleSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRampUpRuleSTATUS(generators)
	rampUpRuleSTATUSGenerator = gen.Struct(reflect.TypeOf(RampUpRule_STATUS{}), generators)

	return rampUpRuleSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForRampUpRuleSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRampUpRuleSTATUS(gens map[string]gopter.Gen) {
	gens["ActionHostName"] = gen.PtrOf(gen.AlphaString())
	gens["ChangeDecisionCallbackUrl"] = gen.PtrOf(gen.AlphaString())
	gens["ChangeIntervalInMinutes"] = gen.PtrOf(gen.Int())
	gens["ChangeStep"] = gen.PtrOf(gen.Float64())
	gens["MaxReroutePercentage"] = gen.PtrOf(gen.Float64())
	gens["MinReroutePercentage"] = gen.PtrOf(gen.Float64())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ReroutePercentage"] = gen.PtrOf(gen.Float64())
}

func Test_VirtualDirectory_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualDirectory to VirtualDirectory via AssignPropertiesToVirtualDirectory & AssignPropertiesFromVirtualDirectory returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualDirectory, VirtualDirectoryGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualDirectory tests if a specific instance of VirtualDirectory can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForVirtualDirectory(subject VirtualDirectory) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.VirtualDirectory
	err := copied.AssignPropertiesToVirtualDirectory(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualDirectory
	err = actual.AssignPropertiesFromVirtualDirectory(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualDirectory_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualDirectory via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualDirectory, VirtualDirectoryGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualDirectory runs a test to see if a specific instance of VirtualDirectory round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualDirectory(subject VirtualDirectory) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualDirectory
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualDirectory instances for property testing - lazily instantiated by VirtualDirectoryGenerator()
var virtualDirectoryGenerator gopter.Gen

// VirtualDirectoryGenerator returns a generator of VirtualDirectory instances for property testing.
func VirtualDirectoryGenerator() gopter.Gen {
	if virtualDirectoryGenerator != nil {
		return virtualDirectoryGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualDirectory(generators)
	virtualDirectoryGenerator = gen.Struct(reflect.TypeOf(VirtualDirectory{}), generators)

	return virtualDirectoryGenerator
}

// AddIndependentPropertyGeneratorsForVirtualDirectory is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualDirectory(gens map[string]gopter.Gen) {
	gens["PhysicalPath"] = gen.PtrOf(gen.AlphaString())
	gens["VirtualPath"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualDirectory_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualDirectory_STATUS to VirtualDirectory_STATUS via AssignPropertiesToVirtualDirectorySTATUS & AssignPropertiesFromVirtualDirectorySTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualDirectorySTATUS, VirtualDirectorySTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualDirectorySTATUS tests if a specific instance of VirtualDirectory_STATUS can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForVirtualDirectorySTATUS(subject VirtualDirectory_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.VirtualDirectory_STATUS
	err := copied.AssignPropertiesToVirtualDirectorySTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualDirectory_STATUS
	err = actual.AssignPropertiesFromVirtualDirectorySTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualDirectory_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualDirectory_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualDirectorySTATUS, VirtualDirectorySTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualDirectorySTATUS runs a test to see if a specific instance of VirtualDirectory_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualDirectorySTATUS(subject VirtualDirectory_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualDirectory_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualDirectory_STATUS instances for property testing - lazily instantiated by
// VirtualDirectorySTATUSGenerator()
var virtualDirectorySTATUSGenerator gopter.Gen

// VirtualDirectorySTATUSGenerator returns a generator of VirtualDirectory_STATUS instances for property testing.
func VirtualDirectorySTATUSGenerator() gopter.Gen {
	if virtualDirectorySTATUSGenerator != nil {
		return virtualDirectorySTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualDirectorySTATUS(generators)
	virtualDirectorySTATUSGenerator = gen.Struct(reflect.TypeOf(VirtualDirectory_STATUS{}), generators)

	return virtualDirectorySTATUSGenerator
}

// AddIndependentPropertyGeneratorsForVirtualDirectorySTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualDirectorySTATUS(gens map[string]gopter.Gen) {
	gens["PhysicalPath"] = gen.PtrOf(gen.AlphaString())
	gens["VirtualPath"] = gen.PtrOf(gen.AlphaString())
}

func Test_AutoHealCustomAction_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AutoHealCustomAction to AutoHealCustomAction via AssignPropertiesToAutoHealCustomAction & AssignPropertiesFromAutoHealCustomAction returns original",
		prop.ForAll(RunPropertyAssignmentTestForAutoHealCustomAction, AutoHealCustomActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAutoHealCustomAction tests if a specific instance of AutoHealCustomAction can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForAutoHealCustomAction(subject AutoHealCustomAction) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.AutoHealCustomAction
	err := copied.AssignPropertiesToAutoHealCustomAction(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AutoHealCustomAction
	err = actual.AssignPropertiesFromAutoHealCustomAction(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AutoHealCustomAction_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoHealCustomAction via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoHealCustomAction, AutoHealCustomActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoHealCustomAction runs a test to see if a specific instance of AutoHealCustomAction round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoHealCustomAction(subject AutoHealCustomAction) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoHealCustomAction
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoHealCustomAction instances for property testing - lazily instantiated by
// AutoHealCustomActionGenerator()
var autoHealCustomActionGenerator gopter.Gen

// AutoHealCustomActionGenerator returns a generator of AutoHealCustomAction instances for property testing.
func AutoHealCustomActionGenerator() gopter.Gen {
	if autoHealCustomActionGenerator != nil {
		return autoHealCustomActionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoHealCustomAction(generators)
	autoHealCustomActionGenerator = gen.Struct(reflect.TypeOf(AutoHealCustomAction{}), generators)

	return autoHealCustomActionGenerator
}

// AddIndependentPropertyGeneratorsForAutoHealCustomAction is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoHealCustomAction(gens map[string]gopter.Gen) {
	gens["Exe"] = gen.PtrOf(gen.AlphaString())
	gens["Parameters"] = gen.PtrOf(gen.AlphaString())
}

func Test_AutoHealCustomAction_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AutoHealCustomAction_STATUS to AutoHealCustomAction_STATUS via AssignPropertiesToAutoHealCustomActionSTATUS & AssignPropertiesFromAutoHealCustomActionSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAutoHealCustomActionSTATUS, AutoHealCustomActionSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAutoHealCustomActionSTATUS tests if a specific instance of AutoHealCustomAction_STATUS can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForAutoHealCustomActionSTATUS(subject AutoHealCustomAction_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.AutoHealCustomAction_STATUS
	err := copied.AssignPropertiesToAutoHealCustomActionSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AutoHealCustomAction_STATUS
	err = actual.AssignPropertiesFromAutoHealCustomActionSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AutoHealCustomAction_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoHealCustomAction_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoHealCustomActionSTATUS, AutoHealCustomActionSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoHealCustomActionSTATUS runs a test to see if a specific instance of AutoHealCustomAction_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoHealCustomActionSTATUS(subject AutoHealCustomAction_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoHealCustomAction_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoHealCustomAction_STATUS instances for property testing - lazily instantiated by
// AutoHealCustomActionSTATUSGenerator()
var autoHealCustomActionSTATUSGenerator gopter.Gen

// AutoHealCustomActionSTATUSGenerator returns a generator of AutoHealCustomAction_STATUS instances for property testing.
func AutoHealCustomActionSTATUSGenerator() gopter.Gen {
	if autoHealCustomActionSTATUSGenerator != nil {
		return autoHealCustomActionSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoHealCustomActionSTATUS(generators)
	autoHealCustomActionSTATUSGenerator = gen.Struct(reflect.TypeOf(AutoHealCustomAction_STATUS{}), generators)

	return autoHealCustomActionSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForAutoHealCustomActionSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoHealCustomActionSTATUS(gens map[string]gopter.Gen) {
	gens["Exe"] = gen.PtrOf(gen.AlphaString())
	gens["Parameters"] = gen.PtrOf(gen.AlphaString())
}

func Test_RequestsBasedTrigger_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RequestsBasedTrigger to RequestsBasedTrigger via AssignPropertiesToRequestsBasedTrigger & AssignPropertiesFromRequestsBasedTrigger returns original",
		prop.ForAll(RunPropertyAssignmentTestForRequestsBasedTrigger, RequestsBasedTriggerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRequestsBasedTrigger tests if a specific instance of RequestsBasedTrigger can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForRequestsBasedTrigger(subject RequestsBasedTrigger) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.RequestsBasedTrigger
	err := copied.AssignPropertiesToRequestsBasedTrigger(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RequestsBasedTrigger
	err = actual.AssignPropertiesFromRequestsBasedTrigger(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RequestsBasedTrigger_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RequestsBasedTrigger via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRequestsBasedTrigger, RequestsBasedTriggerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRequestsBasedTrigger runs a test to see if a specific instance of RequestsBasedTrigger round trips to JSON and back losslessly
func RunJSONSerializationTestForRequestsBasedTrigger(subject RequestsBasedTrigger) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RequestsBasedTrigger
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RequestsBasedTrigger instances for property testing - lazily instantiated by
// RequestsBasedTriggerGenerator()
var requestsBasedTriggerGenerator gopter.Gen

// RequestsBasedTriggerGenerator returns a generator of RequestsBasedTrigger instances for property testing.
func RequestsBasedTriggerGenerator() gopter.Gen {
	if requestsBasedTriggerGenerator != nil {
		return requestsBasedTriggerGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRequestsBasedTrigger(generators)
	requestsBasedTriggerGenerator = gen.Struct(reflect.TypeOf(RequestsBasedTrigger{}), generators)

	return requestsBasedTriggerGenerator
}

// AddIndependentPropertyGeneratorsForRequestsBasedTrigger is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRequestsBasedTrigger(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["TimeInterval"] = gen.PtrOf(gen.AlphaString())
}

func Test_RequestsBasedTrigger_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RequestsBasedTrigger_STATUS to RequestsBasedTrigger_STATUS via AssignPropertiesToRequestsBasedTriggerSTATUS & AssignPropertiesFromRequestsBasedTriggerSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForRequestsBasedTriggerSTATUS, RequestsBasedTriggerSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRequestsBasedTriggerSTATUS tests if a specific instance of RequestsBasedTrigger_STATUS can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForRequestsBasedTriggerSTATUS(subject RequestsBasedTrigger_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.RequestsBasedTrigger_STATUS
	err := copied.AssignPropertiesToRequestsBasedTriggerSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RequestsBasedTrigger_STATUS
	err = actual.AssignPropertiesFromRequestsBasedTriggerSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RequestsBasedTrigger_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RequestsBasedTrigger_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRequestsBasedTriggerSTATUS, RequestsBasedTriggerSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRequestsBasedTriggerSTATUS runs a test to see if a specific instance of RequestsBasedTrigger_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRequestsBasedTriggerSTATUS(subject RequestsBasedTrigger_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RequestsBasedTrigger_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RequestsBasedTrigger_STATUS instances for property testing - lazily instantiated by
// RequestsBasedTriggerSTATUSGenerator()
var requestsBasedTriggerSTATUSGenerator gopter.Gen

// RequestsBasedTriggerSTATUSGenerator returns a generator of RequestsBasedTrigger_STATUS instances for property testing.
func RequestsBasedTriggerSTATUSGenerator() gopter.Gen {
	if requestsBasedTriggerSTATUSGenerator != nil {
		return requestsBasedTriggerSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRequestsBasedTriggerSTATUS(generators)
	requestsBasedTriggerSTATUSGenerator = gen.Struct(reflect.TypeOf(RequestsBasedTrigger_STATUS{}), generators)

	return requestsBasedTriggerSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForRequestsBasedTriggerSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRequestsBasedTriggerSTATUS(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["TimeInterval"] = gen.PtrOf(gen.AlphaString())
}

func Test_SlowRequestsBasedTrigger_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SlowRequestsBasedTrigger to SlowRequestsBasedTrigger via AssignPropertiesToSlowRequestsBasedTrigger & AssignPropertiesFromSlowRequestsBasedTrigger returns original",
		prop.ForAll(RunPropertyAssignmentTestForSlowRequestsBasedTrigger, SlowRequestsBasedTriggerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSlowRequestsBasedTrigger tests if a specific instance of SlowRequestsBasedTrigger can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForSlowRequestsBasedTrigger(subject SlowRequestsBasedTrigger) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.SlowRequestsBasedTrigger
	err := copied.AssignPropertiesToSlowRequestsBasedTrigger(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SlowRequestsBasedTrigger
	err = actual.AssignPropertiesFromSlowRequestsBasedTrigger(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SlowRequestsBasedTrigger_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SlowRequestsBasedTrigger via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSlowRequestsBasedTrigger, SlowRequestsBasedTriggerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSlowRequestsBasedTrigger runs a test to see if a specific instance of SlowRequestsBasedTrigger round trips to JSON and back losslessly
func RunJSONSerializationTestForSlowRequestsBasedTrigger(subject SlowRequestsBasedTrigger) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SlowRequestsBasedTrigger
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SlowRequestsBasedTrigger instances for property testing - lazily instantiated by
// SlowRequestsBasedTriggerGenerator()
var slowRequestsBasedTriggerGenerator gopter.Gen

// SlowRequestsBasedTriggerGenerator returns a generator of SlowRequestsBasedTrigger instances for property testing.
func SlowRequestsBasedTriggerGenerator() gopter.Gen {
	if slowRequestsBasedTriggerGenerator != nil {
		return slowRequestsBasedTriggerGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSlowRequestsBasedTrigger(generators)
	slowRequestsBasedTriggerGenerator = gen.Struct(reflect.TypeOf(SlowRequestsBasedTrigger{}), generators)

	return slowRequestsBasedTriggerGenerator
}

// AddIndependentPropertyGeneratorsForSlowRequestsBasedTrigger is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSlowRequestsBasedTrigger(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["TimeInterval"] = gen.PtrOf(gen.AlphaString())
	gens["TimeTaken"] = gen.PtrOf(gen.AlphaString())
}

func Test_SlowRequestsBasedTrigger_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SlowRequestsBasedTrigger_STATUS to SlowRequestsBasedTrigger_STATUS via AssignPropertiesToSlowRequestsBasedTriggerSTATUS & AssignPropertiesFromSlowRequestsBasedTriggerSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSlowRequestsBasedTriggerSTATUS, SlowRequestsBasedTriggerSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSlowRequestsBasedTriggerSTATUS tests if a specific instance of SlowRequestsBasedTrigger_STATUS can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForSlowRequestsBasedTriggerSTATUS(subject SlowRequestsBasedTrigger_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.SlowRequestsBasedTrigger_STATUS
	err := copied.AssignPropertiesToSlowRequestsBasedTriggerSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SlowRequestsBasedTrigger_STATUS
	err = actual.AssignPropertiesFromSlowRequestsBasedTriggerSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SlowRequestsBasedTrigger_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SlowRequestsBasedTrigger_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSlowRequestsBasedTriggerSTATUS, SlowRequestsBasedTriggerSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSlowRequestsBasedTriggerSTATUS runs a test to see if a specific instance of SlowRequestsBasedTrigger_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSlowRequestsBasedTriggerSTATUS(subject SlowRequestsBasedTrigger_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SlowRequestsBasedTrigger_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SlowRequestsBasedTrigger_STATUS instances for property testing - lazily instantiated by
// SlowRequestsBasedTriggerSTATUSGenerator()
var slowRequestsBasedTriggerSTATUSGenerator gopter.Gen

// SlowRequestsBasedTriggerSTATUSGenerator returns a generator of SlowRequestsBasedTrigger_STATUS instances for property testing.
func SlowRequestsBasedTriggerSTATUSGenerator() gopter.Gen {
	if slowRequestsBasedTriggerSTATUSGenerator != nil {
		return slowRequestsBasedTriggerSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSlowRequestsBasedTriggerSTATUS(generators)
	slowRequestsBasedTriggerSTATUSGenerator = gen.Struct(reflect.TypeOf(SlowRequestsBasedTrigger_STATUS{}), generators)

	return slowRequestsBasedTriggerSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForSlowRequestsBasedTriggerSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSlowRequestsBasedTriggerSTATUS(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["TimeInterval"] = gen.PtrOf(gen.AlphaString())
	gens["TimeTaken"] = gen.PtrOf(gen.AlphaString())
}

func Test_StatusCodesBasedTrigger_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from StatusCodesBasedTrigger to StatusCodesBasedTrigger via AssignPropertiesToStatusCodesBasedTrigger & AssignPropertiesFromStatusCodesBasedTrigger returns original",
		prop.ForAll(RunPropertyAssignmentTestForStatusCodesBasedTrigger, StatusCodesBasedTriggerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForStatusCodesBasedTrigger tests if a specific instance of StatusCodesBasedTrigger can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForStatusCodesBasedTrigger(subject StatusCodesBasedTrigger) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.StatusCodesBasedTrigger
	err := copied.AssignPropertiesToStatusCodesBasedTrigger(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual StatusCodesBasedTrigger
	err = actual.AssignPropertiesFromStatusCodesBasedTrigger(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_StatusCodesBasedTrigger_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StatusCodesBasedTrigger via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStatusCodesBasedTrigger, StatusCodesBasedTriggerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStatusCodesBasedTrigger runs a test to see if a specific instance of StatusCodesBasedTrigger round trips to JSON and back losslessly
func RunJSONSerializationTestForStatusCodesBasedTrigger(subject StatusCodesBasedTrigger) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StatusCodesBasedTrigger
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StatusCodesBasedTrigger instances for property testing - lazily instantiated by
// StatusCodesBasedTriggerGenerator()
var statusCodesBasedTriggerGenerator gopter.Gen

// StatusCodesBasedTriggerGenerator returns a generator of StatusCodesBasedTrigger instances for property testing.
func StatusCodesBasedTriggerGenerator() gopter.Gen {
	if statusCodesBasedTriggerGenerator != nil {
		return statusCodesBasedTriggerGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStatusCodesBasedTrigger(generators)
	statusCodesBasedTriggerGenerator = gen.Struct(reflect.TypeOf(StatusCodesBasedTrigger{}), generators)

	return statusCodesBasedTriggerGenerator
}

// AddIndependentPropertyGeneratorsForStatusCodesBasedTrigger is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStatusCodesBasedTrigger(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.Int())
	gens["SubStatus"] = gen.PtrOf(gen.Int())
	gens["TimeInterval"] = gen.PtrOf(gen.AlphaString())
	gens["Win32Status"] = gen.PtrOf(gen.Int())
}

func Test_StatusCodesBasedTrigger_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from StatusCodesBasedTrigger_STATUS to StatusCodesBasedTrigger_STATUS via AssignPropertiesToStatusCodesBasedTriggerSTATUS & AssignPropertiesFromStatusCodesBasedTriggerSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForStatusCodesBasedTriggerSTATUS, StatusCodesBasedTriggerSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForStatusCodesBasedTriggerSTATUS tests if a specific instance of StatusCodesBasedTrigger_STATUS can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForStatusCodesBasedTriggerSTATUS(subject StatusCodesBasedTrigger_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.StatusCodesBasedTrigger_STATUS
	err := copied.AssignPropertiesToStatusCodesBasedTriggerSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual StatusCodesBasedTrigger_STATUS
	err = actual.AssignPropertiesFromStatusCodesBasedTriggerSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_StatusCodesBasedTrigger_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StatusCodesBasedTrigger_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStatusCodesBasedTriggerSTATUS, StatusCodesBasedTriggerSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStatusCodesBasedTriggerSTATUS runs a test to see if a specific instance of StatusCodesBasedTrigger_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForStatusCodesBasedTriggerSTATUS(subject StatusCodesBasedTrigger_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StatusCodesBasedTrigger_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StatusCodesBasedTrigger_STATUS instances for property testing - lazily instantiated by
// StatusCodesBasedTriggerSTATUSGenerator()
var statusCodesBasedTriggerSTATUSGenerator gopter.Gen

// StatusCodesBasedTriggerSTATUSGenerator returns a generator of StatusCodesBasedTrigger_STATUS instances for property testing.
func StatusCodesBasedTriggerSTATUSGenerator() gopter.Gen {
	if statusCodesBasedTriggerSTATUSGenerator != nil {
		return statusCodesBasedTriggerSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStatusCodesBasedTriggerSTATUS(generators)
	statusCodesBasedTriggerSTATUSGenerator = gen.Struct(reflect.TypeOf(StatusCodesBasedTrigger_STATUS{}), generators)

	return statusCodesBasedTriggerSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForStatusCodesBasedTriggerSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStatusCodesBasedTriggerSTATUS(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.Int())
	gens["SubStatus"] = gen.PtrOf(gen.Int())
	gens["TimeInterval"] = gen.PtrOf(gen.AlphaString())
	gens["Win32Status"] = gen.PtrOf(gen.Int())
}

func Test_StatusCodesRangeBasedTrigger_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from StatusCodesRangeBasedTrigger to StatusCodesRangeBasedTrigger via AssignPropertiesToStatusCodesRangeBasedTrigger & AssignPropertiesFromStatusCodesRangeBasedTrigger returns original",
		prop.ForAll(RunPropertyAssignmentTestForStatusCodesRangeBasedTrigger, StatusCodesRangeBasedTriggerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForStatusCodesRangeBasedTrigger tests if a specific instance of StatusCodesRangeBasedTrigger can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForStatusCodesRangeBasedTrigger(subject StatusCodesRangeBasedTrigger) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.StatusCodesRangeBasedTrigger
	err := copied.AssignPropertiesToStatusCodesRangeBasedTrigger(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual StatusCodesRangeBasedTrigger
	err = actual.AssignPropertiesFromStatusCodesRangeBasedTrigger(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_StatusCodesRangeBasedTrigger_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StatusCodesRangeBasedTrigger via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStatusCodesRangeBasedTrigger, StatusCodesRangeBasedTriggerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStatusCodesRangeBasedTrigger runs a test to see if a specific instance of StatusCodesRangeBasedTrigger round trips to JSON and back losslessly
func RunJSONSerializationTestForStatusCodesRangeBasedTrigger(subject StatusCodesRangeBasedTrigger) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StatusCodesRangeBasedTrigger
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StatusCodesRangeBasedTrigger instances for property testing - lazily instantiated by
// StatusCodesRangeBasedTriggerGenerator()
var statusCodesRangeBasedTriggerGenerator gopter.Gen

// StatusCodesRangeBasedTriggerGenerator returns a generator of StatusCodesRangeBasedTrigger instances for property testing.
func StatusCodesRangeBasedTriggerGenerator() gopter.Gen {
	if statusCodesRangeBasedTriggerGenerator != nil {
		return statusCodesRangeBasedTriggerGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStatusCodesRangeBasedTrigger(generators)
	statusCodesRangeBasedTriggerGenerator = gen.Struct(reflect.TypeOf(StatusCodesRangeBasedTrigger{}), generators)

	return statusCodesRangeBasedTriggerGenerator
}

// AddIndependentPropertyGeneratorsForStatusCodesRangeBasedTrigger is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStatusCodesRangeBasedTrigger(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["StatusCodes"] = gen.PtrOf(gen.AlphaString())
	gens["TimeInterval"] = gen.PtrOf(gen.AlphaString())
}

func Test_StatusCodesRangeBasedTrigger_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from StatusCodesRangeBasedTrigger_STATUS to StatusCodesRangeBasedTrigger_STATUS via AssignPropertiesToStatusCodesRangeBasedTriggerSTATUS & AssignPropertiesFromStatusCodesRangeBasedTriggerSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForStatusCodesRangeBasedTriggerSTATUS, StatusCodesRangeBasedTriggerSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForStatusCodesRangeBasedTriggerSTATUS tests if a specific instance of StatusCodesRangeBasedTrigger_STATUS can be assigned to v1beta20220301storage and back losslessly
func RunPropertyAssignmentTestForStatusCodesRangeBasedTriggerSTATUS(subject StatusCodesRangeBasedTrigger_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20220301s.StatusCodesRangeBasedTrigger_STATUS
	err := copied.AssignPropertiesToStatusCodesRangeBasedTriggerSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual StatusCodesRangeBasedTrigger_STATUS
	err = actual.AssignPropertiesFromStatusCodesRangeBasedTriggerSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_StatusCodesRangeBasedTrigger_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StatusCodesRangeBasedTrigger_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStatusCodesRangeBasedTriggerSTATUS, StatusCodesRangeBasedTriggerSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStatusCodesRangeBasedTriggerSTATUS runs a test to see if a specific instance of StatusCodesRangeBasedTrigger_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForStatusCodesRangeBasedTriggerSTATUS(subject StatusCodesRangeBasedTrigger_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StatusCodesRangeBasedTrigger_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StatusCodesRangeBasedTrigger_STATUS instances for property testing - lazily instantiated by
// StatusCodesRangeBasedTriggerSTATUSGenerator()
var statusCodesRangeBasedTriggerSTATUSGenerator gopter.Gen

// StatusCodesRangeBasedTriggerSTATUSGenerator returns a generator of StatusCodesRangeBasedTrigger_STATUS instances for property testing.
func StatusCodesRangeBasedTriggerSTATUSGenerator() gopter.Gen {
	if statusCodesRangeBasedTriggerSTATUSGenerator != nil {
		return statusCodesRangeBasedTriggerSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStatusCodesRangeBasedTriggerSTATUS(generators)
	statusCodesRangeBasedTriggerSTATUSGenerator = gen.Struct(reflect.TypeOf(StatusCodesRangeBasedTrigger_STATUS{}), generators)

	return statusCodesRangeBasedTriggerSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForStatusCodesRangeBasedTriggerSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStatusCodesRangeBasedTriggerSTATUS(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["StatusCodes"] = gen.PtrOf(gen.AlphaString())
	gens["TimeInterval"] = gen.PtrOf(gen.AlphaString())
}
