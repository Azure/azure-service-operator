// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20220301

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_Sites_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sites_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSites_SpecARM, Sites_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSites_SpecARM runs a test to see if a specific instance of Sites_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSites_SpecARM(subject Sites_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sites_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sites_SpecARM instances for property testing - lazily instantiated by Sites_SpecARMGenerator()
var sites_SpecARMGenerator gopter.Gen

// Sites_SpecARMGenerator returns a generator of Sites_SpecARM instances for property testing.
// We first initialize sites_SpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Sites_SpecARMGenerator() gopter.Gen {
	if sites_SpecARMGenerator != nil {
		return sites_SpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSites_SpecARM(generators)
	sites_SpecARMGenerator = gen.Struct(reflect.TypeOf(Sites_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSites_SpecARM(generators)
	AddRelatedPropertyGeneratorsForSites_SpecARM(generators)
	sites_SpecARMGenerator = gen.Struct(reflect.TypeOf(Sites_SpecARM{}), generators)

	return sites_SpecARMGenerator
}

// AddIndependentPropertyGeneratorsForSites_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSites_SpecARM(gens map[string]gopter.Gen) {
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSites_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSites_SpecARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationARMGenerator())
	gens["Identity"] = gen.PtrOf(ManagedServiceIdentityARMGenerator())
	gens["Properties"] = gen.PtrOf(Sites_Spec_PropertiesARMGenerator())
}

func Test_ManagedServiceIdentityARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentityARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentityARM, ManagedServiceIdentityARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentityARM runs a test to see if a specific instance of ManagedServiceIdentityARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentityARM(subject ManagedServiceIdentityARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentityARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentityARM instances for property testing - lazily instantiated by
// ManagedServiceIdentityARMGenerator()
var managedServiceIdentityARMGenerator gopter.Gen

// ManagedServiceIdentityARMGenerator returns a generator of ManagedServiceIdentityARM instances for property testing.
func ManagedServiceIdentityARMGenerator() gopter.Gen {
	if managedServiceIdentityARMGenerator != nil {
		return managedServiceIdentityARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentityARM(generators)
	managedServiceIdentityARMGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentityARM{}), generators)

	return managedServiceIdentityARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentityARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentityARM(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ManagedServiceIdentity_Type_None,
		ManagedServiceIdentity_Type_SystemAssigned,
		ManagedServiceIdentity_Type_SystemAssignedUserAssigned,
		ManagedServiceIdentity_Type_UserAssigned))
}

func Test_Sites_Spec_PropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sites_Spec_PropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSites_Spec_PropertiesARM, Sites_Spec_PropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSites_Spec_PropertiesARM runs a test to see if a specific instance of Sites_Spec_PropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSites_Spec_PropertiesARM(subject Sites_Spec_PropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sites_Spec_PropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sites_Spec_PropertiesARM instances for property testing - lazily instantiated by
// Sites_Spec_PropertiesARMGenerator()
var sites_Spec_PropertiesARMGenerator gopter.Gen

// Sites_Spec_PropertiesARMGenerator returns a generator of Sites_Spec_PropertiesARM instances for property testing.
// We first initialize sites_Spec_PropertiesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Sites_Spec_PropertiesARMGenerator() gopter.Gen {
	if sites_Spec_PropertiesARMGenerator != nil {
		return sites_Spec_PropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSites_Spec_PropertiesARM(generators)
	sites_Spec_PropertiesARMGenerator = gen.Struct(reflect.TypeOf(Sites_Spec_PropertiesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSites_Spec_PropertiesARM(generators)
	AddRelatedPropertyGeneratorsForSites_Spec_PropertiesARM(generators)
	sites_Spec_PropertiesARMGenerator = gen.Struct(reflect.TypeOf(Sites_Spec_PropertiesARM{}), generators)

	return sites_Spec_PropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForSites_Spec_PropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSites_Spec_PropertiesARM(gens map[string]gopter.Gen) {
	gens["ClientAffinityEnabled"] = gen.PtrOf(gen.Bool())
	gens["ClientCertEnabled"] = gen.PtrOf(gen.Bool())
	gens["ClientCertExclusionPaths"] = gen.PtrOf(gen.AlphaString())
	gens["ClientCertMode"] = gen.PtrOf(gen.OneConstOf(Sites_Spec_Properties_ClientCertMode_Optional, Sites_Spec_Properties_ClientCertMode_OptionalInteractiveUser, Sites_Spec_Properties_ClientCertMode_Required))
	gens["ContainerSize"] = gen.PtrOf(gen.Int())
	gens["CustomDomainVerificationId"] = gen.PtrOf(gen.AlphaString())
	gens["DailyMemoryTimeQuota"] = gen.PtrOf(gen.Int())
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["HostNamesDisabled"] = gen.PtrOf(gen.Bool())
	gens["HttpsOnly"] = gen.PtrOf(gen.Bool())
	gens["HyperV"] = gen.PtrOf(gen.Bool())
	gens["IsXenon"] = gen.PtrOf(gen.Bool())
	gens["KeyVaultReferenceIdentity"] = gen.PtrOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.AlphaString())
	gens["RedundancyMode"] = gen.PtrOf(gen.OneConstOf(
		Sites_Spec_Properties_RedundancyMode_ActiveActive,
		Sites_Spec_Properties_RedundancyMode_Failover,
		Sites_Spec_Properties_RedundancyMode_GeoRedundant,
		Sites_Spec_Properties_RedundancyMode_Manual,
		Sites_Spec_Properties_RedundancyMode_None))
	gens["Reserved"] = gen.PtrOf(gen.Bool())
	gens["ScmSiteAlsoStopped"] = gen.PtrOf(gen.Bool())
	gens["ServerFarmId"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountRequired"] = gen.PtrOf(gen.Bool())
	gens["VirtualNetworkSubnetId"] = gen.PtrOf(gen.AlphaString())
	gens["VnetContentShareEnabled"] = gen.PtrOf(gen.Bool())
	gens["VnetImagePullEnabled"] = gen.PtrOf(gen.Bool())
	gens["VnetRouteAllEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForSites_Spec_PropertiesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSites_Spec_PropertiesARM(gens map[string]gopter.Gen) {
	gens["CloningInfo"] = gen.PtrOf(CloningInfoARMGenerator())
	gens["HostNameSslStates"] = gen.SliceOf(HostNameSslStateARMGenerator())
	gens["HostingEnvironmentProfile"] = gen.PtrOf(HostingEnvironmentProfileARMGenerator())
	gens["SiteConfig"] = gen.PtrOf(Sites_Spec_Properties_SiteConfigARMGenerator())
}

func Test_CloningInfoARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CloningInfoARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCloningInfoARM, CloningInfoARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCloningInfoARM runs a test to see if a specific instance of CloningInfoARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCloningInfoARM(subject CloningInfoARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CloningInfoARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CloningInfoARM instances for property testing - lazily instantiated by CloningInfoARMGenerator()
var cloningInfoARMGenerator gopter.Gen

// CloningInfoARMGenerator returns a generator of CloningInfoARM instances for property testing.
func CloningInfoARMGenerator() gopter.Gen {
	if cloningInfoARMGenerator != nil {
		return cloningInfoARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCloningInfoARM(generators)
	cloningInfoARMGenerator = gen.Struct(reflect.TypeOf(CloningInfoARM{}), generators)

	return cloningInfoARMGenerator
}

// AddIndependentPropertyGeneratorsForCloningInfoARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCloningInfoARM(gens map[string]gopter.Gen) {
	gens["AppSettingsOverrides"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["CloneCustomHostNames"] = gen.PtrOf(gen.Bool())
	gens["CloneSourceControl"] = gen.PtrOf(gen.Bool())
	gens["ConfigureLoadBalancing"] = gen.PtrOf(gen.Bool())
	gens["CorrelationId"] = gen.PtrOf(gen.AlphaString())
	gens["HostingEnvironment"] = gen.PtrOf(gen.AlphaString())
	gens["Overwrite"] = gen.PtrOf(gen.Bool())
	gens["SourceWebAppId"] = gen.PtrOf(gen.AlphaString())
	gens["SourceWebAppLocation"] = gen.PtrOf(gen.AlphaString())
	gens["TrafficManagerProfileId"] = gen.PtrOf(gen.AlphaString())
	gens["TrafficManagerProfileName"] = gen.PtrOf(gen.AlphaString())
}

func Test_HostNameSslStateARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HostNameSslStateARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHostNameSslStateARM, HostNameSslStateARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHostNameSslStateARM runs a test to see if a specific instance of HostNameSslStateARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHostNameSslStateARM(subject HostNameSslStateARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HostNameSslStateARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HostNameSslStateARM instances for property testing - lazily instantiated by
// HostNameSslStateARMGenerator()
var hostNameSslStateARMGenerator gopter.Gen

// HostNameSslStateARMGenerator returns a generator of HostNameSslStateARM instances for property testing.
func HostNameSslStateARMGenerator() gopter.Gen {
	if hostNameSslStateARMGenerator != nil {
		return hostNameSslStateARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHostNameSslStateARM(generators)
	hostNameSslStateARMGenerator = gen.Struct(reflect.TypeOf(HostNameSslStateARM{}), generators)

	return hostNameSslStateARMGenerator
}

// AddIndependentPropertyGeneratorsForHostNameSslStateARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHostNameSslStateARM(gens map[string]gopter.Gen) {
	gens["HostType"] = gen.PtrOf(gen.OneConstOf(HostNameSslState_HostType_Repository, HostNameSslState_HostType_Standard))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["SslState"] = gen.PtrOf(gen.OneConstOf(HostNameSslState_SslState_Disabled, HostNameSslState_SslState_IpBasedEnabled, HostNameSslState_SslState_SniEnabled))
	gens["Thumbprint"] = gen.PtrOf(gen.AlphaString())
	gens["ToUpdate"] = gen.PtrOf(gen.Bool())
	gens["VirtualIP"] = gen.PtrOf(gen.AlphaString())
}

func Test_Sites_Spec_Properties_SiteConfigARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sites_Spec_Properties_SiteConfigARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSites_Spec_Properties_SiteConfigARM, Sites_Spec_Properties_SiteConfigARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSites_Spec_Properties_SiteConfigARM runs a test to see if a specific instance of Sites_Spec_Properties_SiteConfigARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSites_Spec_Properties_SiteConfigARM(subject Sites_Spec_Properties_SiteConfigARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sites_Spec_Properties_SiteConfigARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sites_Spec_Properties_SiteConfigARM instances for property testing - lazily instantiated by
// Sites_Spec_Properties_SiteConfigARMGenerator()
var sites_Spec_Properties_SiteConfigARMGenerator gopter.Gen

// Sites_Spec_Properties_SiteConfigARMGenerator returns a generator of Sites_Spec_Properties_SiteConfigARM instances for property testing.
func Sites_Spec_Properties_SiteConfigARMGenerator() gopter.Gen {
	if sites_Spec_Properties_SiteConfigARMGenerator != nil {
		return sites_Spec_Properties_SiteConfigARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForSites_Spec_Properties_SiteConfigARM(generators)
	sites_Spec_Properties_SiteConfigARMGenerator = gen.Struct(reflect.TypeOf(Sites_Spec_Properties_SiteConfigARM{}), generators)

	return sites_Spec_Properties_SiteConfigARMGenerator
}

// AddRelatedPropertyGeneratorsForSites_Spec_Properties_SiteConfigARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSites_Spec_Properties_SiteConfigARM(gens map[string]gopter.Gen) {
	gens["ApiDefinition"] = gen.PtrOf(ApiDefinitionInfoARMGenerator())
	gens["ApiManagementConfig"] = gen.PtrOf(ApiManagementConfigARMGenerator())
	gens["AppSettings"] = gen.SliceOf(NameValuePairARMGenerator())
	gens["AutoHealRules"] = gen.PtrOf(AutoHealRulesARMGenerator())
	gens["AzureStorageAccounts"] = gen.MapOf(gen.AlphaString(), Sites_Spec_Properties_SiteConfig_AzureStorageAccountsARMGenerator())
	gens["ConnectionStrings"] = gen.SliceOf(ConnStringInfoARMGenerator())
	gens["Cors"] = gen.PtrOf(CorsSettingsARMGenerator())
	gens["Experiments"] = gen.PtrOf(ExperimentsARMGenerator())
	gens["HandlerMappings"] = gen.SliceOf(HandlerMappingARMGenerator())
	gens["IpSecurityRestrictions"] = gen.SliceOf(IpSecurityRestrictionARMGenerator())
	gens["Limits"] = gen.PtrOf(SiteLimitsARMGenerator())
	gens["Push"] = gen.PtrOf(Sites_Spec_Properties_SiteConfig_PushARMGenerator())
	gens["ScmIpSecurityRestrictions"] = gen.SliceOf(IpSecurityRestrictionARMGenerator())
	gens["VirtualApplications"] = gen.SliceOf(VirtualApplicationARMGenerator())
}

func Test_ApiDefinitionInfoARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiDefinitionInfoARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiDefinitionInfoARM, ApiDefinitionInfoARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiDefinitionInfoARM runs a test to see if a specific instance of ApiDefinitionInfoARM round trips to JSON and back losslessly
func RunJSONSerializationTestForApiDefinitionInfoARM(subject ApiDefinitionInfoARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiDefinitionInfoARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiDefinitionInfoARM instances for property testing - lazily instantiated by
// ApiDefinitionInfoARMGenerator()
var apiDefinitionInfoARMGenerator gopter.Gen

// ApiDefinitionInfoARMGenerator returns a generator of ApiDefinitionInfoARM instances for property testing.
func ApiDefinitionInfoARMGenerator() gopter.Gen {
	if apiDefinitionInfoARMGenerator != nil {
		return apiDefinitionInfoARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiDefinitionInfoARM(generators)
	apiDefinitionInfoARMGenerator = gen.Struct(reflect.TypeOf(ApiDefinitionInfoARM{}), generators)

	return apiDefinitionInfoARMGenerator
}

// AddIndependentPropertyGeneratorsForApiDefinitionInfoARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiDefinitionInfoARM(gens map[string]gopter.Gen) {
	gens["Url"] = gen.PtrOf(gen.AlphaString())
}

func Test_ApiManagementConfigARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiManagementConfigARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiManagementConfigARM, ApiManagementConfigARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiManagementConfigARM runs a test to see if a specific instance of ApiManagementConfigARM round trips to JSON and back losslessly
func RunJSONSerializationTestForApiManagementConfigARM(subject ApiManagementConfigARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiManagementConfigARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiManagementConfigARM instances for property testing - lazily instantiated by
// ApiManagementConfigARMGenerator()
var apiManagementConfigARMGenerator gopter.Gen

// ApiManagementConfigARMGenerator returns a generator of ApiManagementConfigARM instances for property testing.
func ApiManagementConfigARMGenerator() gopter.Gen {
	if apiManagementConfigARMGenerator != nil {
		return apiManagementConfigARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiManagementConfigARM(generators)
	apiManagementConfigARMGenerator = gen.Struct(reflect.TypeOf(ApiManagementConfigARM{}), generators)

	return apiManagementConfigARMGenerator
}

// AddIndependentPropertyGeneratorsForApiManagementConfigARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiManagementConfigARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_AutoHealRulesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoHealRulesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoHealRulesARM, AutoHealRulesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoHealRulesARM runs a test to see if a specific instance of AutoHealRulesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoHealRulesARM(subject AutoHealRulesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoHealRulesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoHealRulesARM instances for property testing - lazily instantiated by AutoHealRulesARMGenerator()
var autoHealRulesARMGenerator gopter.Gen

// AutoHealRulesARMGenerator returns a generator of AutoHealRulesARM instances for property testing.
func AutoHealRulesARMGenerator() gopter.Gen {
	if autoHealRulesARMGenerator != nil {
		return autoHealRulesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForAutoHealRulesARM(generators)
	autoHealRulesARMGenerator = gen.Struct(reflect.TypeOf(AutoHealRulesARM{}), generators)

	return autoHealRulesARMGenerator
}

// AddRelatedPropertyGeneratorsForAutoHealRulesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoHealRulesARM(gens map[string]gopter.Gen) {
	gens["Actions"] = gen.PtrOf(AutoHealActionsARMGenerator())
	gens["Triggers"] = gen.PtrOf(AutoHealTriggersARMGenerator())
}

func Test_ConnStringInfoARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ConnStringInfoARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForConnStringInfoARM, ConnStringInfoARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForConnStringInfoARM runs a test to see if a specific instance of ConnStringInfoARM round trips to JSON and back losslessly
func RunJSONSerializationTestForConnStringInfoARM(subject ConnStringInfoARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ConnStringInfoARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ConnStringInfoARM instances for property testing - lazily instantiated by ConnStringInfoARMGenerator()
var connStringInfoARMGenerator gopter.Gen

// ConnStringInfoARMGenerator returns a generator of ConnStringInfoARM instances for property testing.
func ConnStringInfoARMGenerator() gopter.Gen {
	if connStringInfoARMGenerator != nil {
		return connStringInfoARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForConnStringInfoARM(generators)
	connStringInfoARMGenerator = gen.Struct(reflect.TypeOf(ConnStringInfoARM{}), generators)

	return connStringInfoARMGenerator
}

// AddIndependentPropertyGeneratorsForConnStringInfoARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForConnStringInfoARM(gens map[string]gopter.Gen) {
	gens["ConnectionString"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ConnStringInfo_Type_ApiHub,
		ConnStringInfo_Type_Custom,
		ConnStringInfo_Type_DocDb,
		ConnStringInfo_Type_EventHub,
		ConnStringInfo_Type_MySql,
		ConnStringInfo_Type_NotificationHub,
		ConnStringInfo_Type_PostgreSQL,
		ConnStringInfo_Type_RedisCache,
		ConnStringInfo_Type_SQLAzure,
		ConnStringInfo_Type_SQLServer,
		ConnStringInfo_Type_ServiceBus))
}

func Test_CorsSettingsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CorsSettingsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCorsSettingsARM, CorsSettingsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCorsSettingsARM runs a test to see if a specific instance of CorsSettingsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCorsSettingsARM(subject CorsSettingsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CorsSettingsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CorsSettingsARM instances for property testing - lazily instantiated by CorsSettingsARMGenerator()
var corsSettingsARMGenerator gopter.Gen

// CorsSettingsARMGenerator returns a generator of CorsSettingsARM instances for property testing.
func CorsSettingsARMGenerator() gopter.Gen {
	if corsSettingsARMGenerator != nil {
		return corsSettingsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCorsSettingsARM(generators)
	corsSettingsARMGenerator = gen.Struct(reflect.TypeOf(CorsSettingsARM{}), generators)

	return corsSettingsARMGenerator
}

// AddIndependentPropertyGeneratorsForCorsSettingsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCorsSettingsARM(gens map[string]gopter.Gen) {
	gens["AllowedOrigins"] = gen.SliceOf(gen.AlphaString())
	gens["SupportCredentials"] = gen.PtrOf(gen.Bool())
}

func Test_ExperimentsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExperimentsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExperimentsARM, ExperimentsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExperimentsARM runs a test to see if a specific instance of ExperimentsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForExperimentsARM(subject ExperimentsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExperimentsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExperimentsARM instances for property testing - lazily instantiated by ExperimentsARMGenerator()
var experimentsARMGenerator gopter.Gen

// ExperimentsARMGenerator returns a generator of ExperimentsARM instances for property testing.
func ExperimentsARMGenerator() gopter.Gen {
	if experimentsARMGenerator != nil {
		return experimentsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForExperimentsARM(generators)
	experimentsARMGenerator = gen.Struct(reflect.TypeOf(ExperimentsARM{}), generators)

	return experimentsARMGenerator
}

// AddRelatedPropertyGeneratorsForExperimentsARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForExperimentsARM(gens map[string]gopter.Gen) {
	gens["RampUpRules"] = gen.SliceOf(RampUpRuleARMGenerator())
}

func Test_HandlerMappingARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HandlerMappingARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHandlerMappingARM, HandlerMappingARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHandlerMappingARM runs a test to see if a specific instance of HandlerMappingARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHandlerMappingARM(subject HandlerMappingARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HandlerMappingARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HandlerMappingARM instances for property testing - lazily instantiated by HandlerMappingARMGenerator()
var handlerMappingARMGenerator gopter.Gen

// HandlerMappingARMGenerator returns a generator of HandlerMappingARM instances for property testing.
func HandlerMappingARMGenerator() gopter.Gen {
	if handlerMappingARMGenerator != nil {
		return handlerMappingARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHandlerMappingARM(generators)
	handlerMappingARMGenerator = gen.Struct(reflect.TypeOf(HandlerMappingARM{}), generators)

	return handlerMappingARMGenerator
}

// AddIndependentPropertyGeneratorsForHandlerMappingARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHandlerMappingARM(gens map[string]gopter.Gen) {
	gens["Arguments"] = gen.PtrOf(gen.AlphaString())
	gens["Extension"] = gen.PtrOf(gen.AlphaString())
	gens["ScriptProcessor"] = gen.PtrOf(gen.AlphaString())
}

func Test_IpSecurityRestrictionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpSecurityRestrictionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpSecurityRestrictionARM, IpSecurityRestrictionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpSecurityRestrictionARM runs a test to see if a specific instance of IpSecurityRestrictionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIpSecurityRestrictionARM(subject IpSecurityRestrictionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpSecurityRestrictionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpSecurityRestrictionARM instances for property testing - lazily instantiated by
// IpSecurityRestrictionARMGenerator()
var ipSecurityRestrictionARMGenerator gopter.Gen

// IpSecurityRestrictionARMGenerator returns a generator of IpSecurityRestrictionARM instances for property testing.
func IpSecurityRestrictionARMGenerator() gopter.Gen {
	if ipSecurityRestrictionARMGenerator != nil {
		return ipSecurityRestrictionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpSecurityRestrictionARM(generators)
	ipSecurityRestrictionARMGenerator = gen.Struct(reflect.TypeOf(IpSecurityRestrictionARM{}), generators)

	return ipSecurityRestrictionARMGenerator
}

// AddIndependentPropertyGeneratorsForIpSecurityRestrictionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpSecurityRestrictionARM(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.AlphaString())
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["Headers"] = gen.MapOf(gen.AlphaString(), gen.SliceOf(gen.AlphaString()))
	gens["IpAddress"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Priority"] = gen.PtrOf(gen.Int())
	gens["SubnetMask"] = gen.PtrOf(gen.AlphaString())
	gens["SubnetTrafficTag"] = gen.PtrOf(gen.Int())
	gens["Tag"] = gen.PtrOf(gen.OneConstOf(IpSecurityRestriction_Tag_Default, IpSecurityRestriction_Tag_ServiceTag, IpSecurityRestriction_Tag_XffProxy))
	gens["VnetSubnetResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["VnetTrafficTag"] = gen.PtrOf(gen.Int())
}

func Test_NameValuePairARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NameValuePairARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNameValuePairARM, NameValuePairARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNameValuePairARM runs a test to see if a specific instance of NameValuePairARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNameValuePairARM(subject NameValuePairARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NameValuePairARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NameValuePairARM instances for property testing - lazily instantiated by NameValuePairARMGenerator()
var nameValuePairARMGenerator gopter.Gen

// NameValuePairARMGenerator returns a generator of NameValuePairARM instances for property testing.
func NameValuePairARMGenerator() gopter.Gen {
	if nameValuePairARMGenerator != nil {
		return nameValuePairARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNameValuePairARM(generators)
	nameValuePairARMGenerator = gen.Struct(reflect.TypeOf(NameValuePairARM{}), generators)

	return nameValuePairARMGenerator
}

// AddIndependentPropertyGeneratorsForNameValuePairARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNameValuePairARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_SiteLimitsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SiteLimitsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSiteLimitsARM, SiteLimitsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSiteLimitsARM runs a test to see if a specific instance of SiteLimitsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSiteLimitsARM(subject SiteLimitsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SiteLimitsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SiteLimitsARM instances for property testing - lazily instantiated by SiteLimitsARMGenerator()
var siteLimitsARMGenerator gopter.Gen

// SiteLimitsARMGenerator returns a generator of SiteLimitsARM instances for property testing.
func SiteLimitsARMGenerator() gopter.Gen {
	if siteLimitsARMGenerator != nil {
		return siteLimitsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSiteLimitsARM(generators)
	siteLimitsARMGenerator = gen.Struct(reflect.TypeOf(SiteLimitsARM{}), generators)

	return siteLimitsARMGenerator
}

// AddIndependentPropertyGeneratorsForSiteLimitsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSiteLimitsARM(gens map[string]gopter.Gen) {
	gens["MaxDiskSizeInMb"] = gen.PtrOf(gen.Int())
	gens["MaxMemoryInMb"] = gen.PtrOf(gen.Int())
	gens["MaxPercentageCpu"] = gen.PtrOf(gen.Float64())
}

func Test_Sites_Spec_Properties_SiteConfig_AzureStorageAccountsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sites_Spec_Properties_SiteConfig_AzureStorageAccountsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSites_Spec_Properties_SiteConfig_AzureStorageAccountsARM, Sites_Spec_Properties_SiteConfig_AzureStorageAccountsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSites_Spec_Properties_SiteConfig_AzureStorageAccountsARM runs a test to see if a specific instance of Sites_Spec_Properties_SiteConfig_AzureStorageAccountsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSites_Spec_Properties_SiteConfig_AzureStorageAccountsARM(subject Sites_Spec_Properties_SiteConfig_AzureStorageAccountsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sites_Spec_Properties_SiteConfig_AzureStorageAccountsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sites_Spec_Properties_SiteConfig_AzureStorageAccountsARM instances for property testing - lazily
// instantiated by Sites_Spec_Properties_SiteConfig_AzureStorageAccountsARMGenerator()
var sites_Spec_Properties_SiteConfig_AzureStorageAccountsARMGenerator gopter.Gen

// Sites_Spec_Properties_SiteConfig_AzureStorageAccountsARMGenerator returns a generator of Sites_Spec_Properties_SiteConfig_AzureStorageAccountsARM instances for property testing.
func Sites_Spec_Properties_SiteConfig_AzureStorageAccountsARMGenerator() gopter.Gen {
	if sites_Spec_Properties_SiteConfig_AzureStorageAccountsARMGenerator != nil {
		return sites_Spec_Properties_SiteConfig_AzureStorageAccountsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSites_Spec_Properties_SiteConfig_AzureStorageAccountsARM(generators)
	sites_Spec_Properties_SiteConfig_AzureStorageAccountsARMGenerator = gen.Struct(reflect.TypeOf(Sites_Spec_Properties_SiteConfig_AzureStorageAccountsARM{}), generators)

	return sites_Spec_Properties_SiteConfig_AzureStorageAccountsARMGenerator
}

// AddIndependentPropertyGeneratorsForSites_Spec_Properties_SiteConfig_AzureStorageAccountsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSites_Spec_Properties_SiteConfig_AzureStorageAccountsARM(gens map[string]gopter.Gen) {
	gens["AccessKey"] = gen.PtrOf(gen.AlphaString())
	gens["AccountName"] = gen.PtrOf(gen.AlphaString())
	gens["MountPath"] = gen.PtrOf(gen.AlphaString())
	gens["ShareName"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(Sites_Spec_Properties_SiteConfig_AzureStorageAccounts_Type_AzureBlob, Sites_Spec_Properties_SiteConfig_AzureStorageAccounts_Type_AzureFiles))
}

func Test_Sites_Spec_Properties_SiteConfig_PushARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sites_Spec_Properties_SiteConfig_PushARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSites_Spec_Properties_SiteConfig_PushARM, Sites_Spec_Properties_SiteConfig_PushARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSites_Spec_Properties_SiteConfig_PushARM runs a test to see if a specific instance of Sites_Spec_Properties_SiteConfig_PushARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSites_Spec_Properties_SiteConfig_PushARM(subject Sites_Spec_Properties_SiteConfig_PushARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sites_Spec_Properties_SiteConfig_PushARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sites_Spec_Properties_SiteConfig_PushARM instances for property testing - lazily instantiated by
// Sites_Spec_Properties_SiteConfig_PushARMGenerator()
var sites_Spec_Properties_SiteConfig_PushARMGenerator gopter.Gen

// Sites_Spec_Properties_SiteConfig_PushARMGenerator returns a generator of Sites_Spec_Properties_SiteConfig_PushARM instances for property testing.
// We first initialize sites_Spec_Properties_SiteConfig_PushARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Sites_Spec_Properties_SiteConfig_PushARMGenerator() gopter.Gen {
	if sites_Spec_Properties_SiteConfig_PushARMGenerator != nil {
		return sites_Spec_Properties_SiteConfig_PushARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSites_Spec_Properties_SiteConfig_PushARM(generators)
	sites_Spec_Properties_SiteConfig_PushARMGenerator = gen.Struct(reflect.TypeOf(Sites_Spec_Properties_SiteConfig_PushARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSites_Spec_Properties_SiteConfig_PushARM(generators)
	AddRelatedPropertyGeneratorsForSites_Spec_Properties_SiteConfig_PushARM(generators)
	sites_Spec_Properties_SiteConfig_PushARMGenerator = gen.Struct(reflect.TypeOf(Sites_Spec_Properties_SiteConfig_PushARM{}), generators)

	return sites_Spec_Properties_SiteConfig_PushARMGenerator
}

// AddIndependentPropertyGeneratorsForSites_Spec_Properties_SiteConfig_PushARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSites_Spec_Properties_SiteConfig_PushARM(gens map[string]gopter.Gen) {
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSites_Spec_Properties_SiteConfig_PushARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSites_Spec_Properties_SiteConfig_PushARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(PushSettingsPropertiesARMGenerator())
}

func Test_VirtualApplicationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualApplicationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualApplicationARM, VirtualApplicationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualApplicationARM runs a test to see if a specific instance of VirtualApplicationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualApplicationARM(subject VirtualApplicationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualApplicationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualApplicationARM instances for property testing - lazily instantiated by
// VirtualApplicationARMGenerator()
var virtualApplicationARMGenerator gopter.Gen

// VirtualApplicationARMGenerator returns a generator of VirtualApplicationARM instances for property testing.
// We first initialize virtualApplicationARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualApplicationARMGenerator() gopter.Gen {
	if virtualApplicationARMGenerator != nil {
		return virtualApplicationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualApplicationARM(generators)
	virtualApplicationARMGenerator = gen.Struct(reflect.TypeOf(VirtualApplicationARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualApplicationARM(generators)
	AddRelatedPropertyGeneratorsForVirtualApplicationARM(generators)
	virtualApplicationARMGenerator = gen.Struct(reflect.TypeOf(VirtualApplicationARM{}), generators)

	return virtualApplicationARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualApplicationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualApplicationARM(gens map[string]gopter.Gen) {
	gens["PhysicalPath"] = gen.PtrOf(gen.AlphaString())
	gens["PreloadEnabled"] = gen.PtrOf(gen.Bool())
	gens["VirtualPath"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualApplicationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualApplicationARM(gens map[string]gopter.Gen) {
	gens["VirtualDirectories"] = gen.SliceOf(VirtualDirectoryARMGenerator())
}

func Test_AutoHealActionsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoHealActionsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoHealActionsARM, AutoHealActionsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoHealActionsARM runs a test to see if a specific instance of AutoHealActionsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoHealActionsARM(subject AutoHealActionsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoHealActionsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoHealActionsARM instances for property testing - lazily instantiated by AutoHealActionsARMGenerator()
var autoHealActionsARMGenerator gopter.Gen

// AutoHealActionsARMGenerator returns a generator of AutoHealActionsARM instances for property testing.
// We first initialize autoHealActionsARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AutoHealActionsARMGenerator() gopter.Gen {
	if autoHealActionsARMGenerator != nil {
		return autoHealActionsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoHealActionsARM(generators)
	autoHealActionsARMGenerator = gen.Struct(reflect.TypeOf(AutoHealActionsARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoHealActionsARM(generators)
	AddRelatedPropertyGeneratorsForAutoHealActionsARM(generators)
	autoHealActionsARMGenerator = gen.Struct(reflect.TypeOf(AutoHealActionsARM{}), generators)

	return autoHealActionsARMGenerator
}

// AddIndependentPropertyGeneratorsForAutoHealActionsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoHealActionsARM(gens map[string]gopter.Gen) {
	gens["ActionType"] = gen.PtrOf(gen.OneConstOf(AutoHealActions_ActionType_CustomAction, AutoHealActions_ActionType_LogEvent, AutoHealActions_ActionType_Recycle))
	gens["MinProcessExecutionTime"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAutoHealActionsARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoHealActionsARM(gens map[string]gopter.Gen) {
	gens["CustomAction"] = gen.PtrOf(AutoHealCustomActionARMGenerator())
}

func Test_AutoHealTriggersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoHealTriggersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoHealTriggersARM, AutoHealTriggersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoHealTriggersARM runs a test to see if a specific instance of AutoHealTriggersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoHealTriggersARM(subject AutoHealTriggersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoHealTriggersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoHealTriggersARM instances for property testing - lazily instantiated by
// AutoHealTriggersARMGenerator()
var autoHealTriggersARMGenerator gopter.Gen

// AutoHealTriggersARMGenerator returns a generator of AutoHealTriggersARM instances for property testing.
// We first initialize autoHealTriggersARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AutoHealTriggersARMGenerator() gopter.Gen {
	if autoHealTriggersARMGenerator != nil {
		return autoHealTriggersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoHealTriggersARM(generators)
	autoHealTriggersARMGenerator = gen.Struct(reflect.TypeOf(AutoHealTriggersARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoHealTriggersARM(generators)
	AddRelatedPropertyGeneratorsForAutoHealTriggersARM(generators)
	autoHealTriggersARMGenerator = gen.Struct(reflect.TypeOf(AutoHealTriggersARM{}), generators)

	return autoHealTriggersARMGenerator
}

// AddIndependentPropertyGeneratorsForAutoHealTriggersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoHealTriggersARM(gens map[string]gopter.Gen) {
	gens["PrivateBytesInKB"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForAutoHealTriggersARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoHealTriggersARM(gens map[string]gopter.Gen) {
	gens["Requests"] = gen.PtrOf(RequestsBasedTriggerARMGenerator())
	gens["SlowRequests"] = gen.PtrOf(SlowRequestsBasedTriggerARMGenerator())
	gens["SlowRequestsWithPath"] = gen.SliceOf(SlowRequestsBasedTriggerARMGenerator())
	gens["StatusCodes"] = gen.SliceOf(StatusCodesBasedTriggerARMGenerator())
	gens["StatusCodesRange"] = gen.SliceOf(StatusCodesRangeBasedTriggerARMGenerator())
}

func Test_PushSettingsPropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PushSettingsPropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPushSettingsPropertiesARM, PushSettingsPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPushSettingsPropertiesARM runs a test to see if a specific instance of PushSettingsPropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPushSettingsPropertiesARM(subject PushSettingsPropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PushSettingsPropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PushSettingsPropertiesARM instances for property testing - lazily instantiated by
// PushSettingsPropertiesARMGenerator()
var pushSettingsPropertiesARMGenerator gopter.Gen

// PushSettingsPropertiesARMGenerator returns a generator of PushSettingsPropertiesARM instances for property testing.
func PushSettingsPropertiesARMGenerator() gopter.Gen {
	if pushSettingsPropertiesARMGenerator != nil {
		return pushSettingsPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPushSettingsPropertiesARM(generators)
	pushSettingsPropertiesARMGenerator = gen.Struct(reflect.TypeOf(PushSettingsPropertiesARM{}), generators)

	return pushSettingsPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForPushSettingsPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPushSettingsPropertiesARM(gens map[string]gopter.Gen) {
	gens["DynamicTagsJson"] = gen.PtrOf(gen.AlphaString())
	gens["IsPushEnabled"] = gen.PtrOf(gen.Bool())
	gens["TagWhitelistJson"] = gen.PtrOf(gen.AlphaString())
	gens["TagsRequiringAuth"] = gen.PtrOf(gen.AlphaString())
}

func Test_RampUpRuleARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RampUpRuleARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRampUpRuleARM, RampUpRuleARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRampUpRuleARM runs a test to see if a specific instance of RampUpRuleARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRampUpRuleARM(subject RampUpRuleARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RampUpRuleARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RampUpRuleARM instances for property testing - lazily instantiated by RampUpRuleARMGenerator()
var rampUpRuleARMGenerator gopter.Gen

// RampUpRuleARMGenerator returns a generator of RampUpRuleARM instances for property testing.
func RampUpRuleARMGenerator() gopter.Gen {
	if rampUpRuleARMGenerator != nil {
		return rampUpRuleARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRampUpRuleARM(generators)
	rampUpRuleARMGenerator = gen.Struct(reflect.TypeOf(RampUpRuleARM{}), generators)

	return rampUpRuleARMGenerator
}

// AddIndependentPropertyGeneratorsForRampUpRuleARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRampUpRuleARM(gens map[string]gopter.Gen) {
	gens["ActionHostName"] = gen.PtrOf(gen.AlphaString())
	gens["ChangeDecisionCallbackUrl"] = gen.PtrOf(gen.AlphaString())
	gens["ChangeIntervalInMinutes"] = gen.PtrOf(gen.Int())
	gens["ChangeStep"] = gen.PtrOf(gen.Float64())
	gens["MaxReroutePercentage"] = gen.PtrOf(gen.Float64())
	gens["MinReroutePercentage"] = gen.PtrOf(gen.Float64())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ReroutePercentage"] = gen.PtrOf(gen.Float64())
}

func Test_VirtualDirectoryARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualDirectoryARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualDirectoryARM, VirtualDirectoryARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualDirectoryARM runs a test to see if a specific instance of VirtualDirectoryARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualDirectoryARM(subject VirtualDirectoryARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualDirectoryARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualDirectoryARM instances for property testing - lazily instantiated by
// VirtualDirectoryARMGenerator()
var virtualDirectoryARMGenerator gopter.Gen

// VirtualDirectoryARMGenerator returns a generator of VirtualDirectoryARM instances for property testing.
func VirtualDirectoryARMGenerator() gopter.Gen {
	if virtualDirectoryARMGenerator != nil {
		return virtualDirectoryARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualDirectoryARM(generators)
	virtualDirectoryARMGenerator = gen.Struct(reflect.TypeOf(VirtualDirectoryARM{}), generators)

	return virtualDirectoryARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualDirectoryARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualDirectoryARM(gens map[string]gopter.Gen) {
	gens["PhysicalPath"] = gen.PtrOf(gen.AlphaString())
	gens["VirtualPath"] = gen.PtrOf(gen.AlphaString())
}

func Test_AutoHealCustomActionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoHealCustomActionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoHealCustomActionARM, AutoHealCustomActionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoHealCustomActionARM runs a test to see if a specific instance of AutoHealCustomActionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoHealCustomActionARM(subject AutoHealCustomActionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoHealCustomActionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoHealCustomActionARM instances for property testing - lazily instantiated by
// AutoHealCustomActionARMGenerator()
var autoHealCustomActionARMGenerator gopter.Gen

// AutoHealCustomActionARMGenerator returns a generator of AutoHealCustomActionARM instances for property testing.
func AutoHealCustomActionARMGenerator() gopter.Gen {
	if autoHealCustomActionARMGenerator != nil {
		return autoHealCustomActionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoHealCustomActionARM(generators)
	autoHealCustomActionARMGenerator = gen.Struct(reflect.TypeOf(AutoHealCustomActionARM{}), generators)

	return autoHealCustomActionARMGenerator
}

// AddIndependentPropertyGeneratorsForAutoHealCustomActionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoHealCustomActionARM(gens map[string]gopter.Gen) {
	gens["Exe"] = gen.PtrOf(gen.AlphaString())
	gens["Parameters"] = gen.PtrOf(gen.AlphaString())
}

func Test_RequestsBasedTriggerARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RequestsBasedTriggerARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRequestsBasedTriggerARM, RequestsBasedTriggerARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRequestsBasedTriggerARM runs a test to see if a specific instance of RequestsBasedTriggerARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRequestsBasedTriggerARM(subject RequestsBasedTriggerARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RequestsBasedTriggerARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RequestsBasedTriggerARM instances for property testing - lazily instantiated by
// RequestsBasedTriggerARMGenerator()
var requestsBasedTriggerARMGenerator gopter.Gen

// RequestsBasedTriggerARMGenerator returns a generator of RequestsBasedTriggerARM instances for property testing.
func RequestsBasedTriggerARMGenerator() gopter.Gen {
	if requestsBasedTriggerARMGenerator != nil {
		return requestsBasedTriggerARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRequestsBasedTriggerARM(generators)
	requestsBasedTriggerARMGenerator = gen.Struct(reflect.TypeOf(RequestsBasedTriggerARM{}), generators)

	return requestsBasedTriggerARMGenerator
}

// AddIndependentPropertyGeneratorsForRequestsBasedTriggerARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRequestsBasedTriggerARM(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["TimeInterval"] = gen.PtrOf(gen.AlphaString())
}

func Test_SlowRequestsBasedTriggerARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SlowRequestsBasedTriggerARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSlowRequestsBasedTriggerARM, SlowRequestsBasedTriggerARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSlowRequestsBasedTriggerARM runs a test to see if a specific instance of SlowRequestsBasedTriggerARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSlowRequestsBasedTriggerARM(subject SlowRequestsBasedTriggerARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SlowRequestsBasedTriggerARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SlowRequestsBasedTriggerARM instances for property testing - lazily instantiated by
// SlowRequestsBasedTriggerARMGenerator()
var slowRequestsBasedTriggerARMGenerator gopter.Gen

// SlowRequestsBasedTriggerARMGenerator returns a generator of SlowRequestsBasedTriggerARM instances for property testing.
func SlowRequestsBasedTriggerARMGenerator() gopter.Gen {
	if slowRequestsBasedTriggerARMGenerator != nil {
		return slowRequestsBasedTriggerARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSlowRequestsBasedTriggerARM(generators)
	slowRequestsBasedTriggerARMGenerator = gen.Struct(reflect.TypeOf(SlowRequestsBasedTriggerARM{}), generators)

	return slowRequestsBasedTriggerARMGenerator
}

// AddIndependentPropertyGeneratorsForSlowRequestsBasedTriggerARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSlowRequestsBasedTriggerARM(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["TimeInterval"] = gen.PtrOf(gen.AlphaString())
	gens["TimeTaken"] = gen.PtrOf(gen.AlphaString())
}

func Test_StatusCodesBasedTriggerARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StatusCodesBasedTriggerARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStatusCodesBasedTriggerARM, StatusCodesBasedTriggerARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStatusCodesBasedTriggerARM runs a test to see if a specific instance of StatusCodesBasedTriggerARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStatusCodesBasedTriggerARM(subject StatusCodesBasedTriggerARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StatusCodesBasedTriggerARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StatusCodesBasedTriggerARM instances for property testing - lazily instantiated by
// StatusCodesBasedTriggerARMGenerator()
var statusCodesBasedTriggerARMGenerator gopter.Gen

// StatusCodesBasedTriggerARMGenerator returns a generator of StatusCodesBasedTriggerARM instances for property testing.
func StatusCodesBasedTriggerARMGenerator() gopter.Gen {
	if statusCodesBasedTriggerARMGenerator != nil {
		return statusCodesBasedTriggerARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStatusCodesBasedTriggerARM(generators)
	statusCodesBasedTriggerARMGenerator = gen.Struct(reflect.TypeOf(StatusCodesBasedTriggerARM{}), generators)

	return statusCodesBasedTriggerARMGenerator
}

// AddIndependentPropertyGeneratorsForStatusCodesBasedTriggerARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStatusCodesBasedTriggerARM(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.Int())
	gens["SubStatus"] = gen.PtrOf(gen.Int())
	gens["TimeInterval"] = gen.PtrOf(gen.AlphaString())
	gens["Win32Status"] = gen.PtrOf(gen.Int())
}

func Test_StatusCodesRangeBasedTriggerARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StatusCodesRangeBasedTriggerARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStatusCodesRangeBasedTriggerARM, StatusCodesRangeBasedTriggerARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStatusCodesRangeBasedTriggerARM runs a test to see if a specific instance of StatusCodesRangeBasedTriggerARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStatusCodesRangeBasedTriggerARM(subject StatusCodesRangeBasedTriggerARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StatusCodesRangeBasedTriggerARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StatusCodesRangeBasedTriggerARM instances for property testing - lazily instantiated by
// StatusCodesRangeBasedTriggerARMGenerator()
var statusCodesRangeBasedTriggerARMGenerator gopter.Gen

// StatusCodesRangeBasedTriggerARMGenerator returns a generator of StatusCodesRangeBasedTriggerARM instances for property testing.
func StatusCodesRangeBasedTriggerARMGenerator() gopter.Gen {
	if statusCodesRangeBasedTriggerARMGenerator != nil {
		return statusCodesRangeBasedTriggerARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStatusCodesRangeBasedTriggerARM(generators)
	statusCodesRangeBasedTriggerARMGenerator = gen.Struct(reflect.TypeOf(StatusCodesRangeBasedTriggerARM{}), generators)

	return statusCodesRangeBasedTriggerARMGenerator
}

// AddIndependentPropertyGeneratorsForStatusCodesRangeBasedTriggerARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStatusCodesRangeBasedTriggerARM(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["StatusCodes"] = gen.PtrOf(gen.AlphaString())
	gens["TimeInterval"] = gen.PtrOf(gen.AlphaString())
}
