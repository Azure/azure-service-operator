// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20220301

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_Site_Spec_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Site_Spec_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSite_Spec_ARM, Site_Spec_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSite_Spec_ARM runs a test to see if a specific instance of Site_Spec_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSite_Spec_ARM(subject Site_Spec_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Site_Spec_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Site_Spec_ARM instances for property testing - lazily instantiated by Site_Spec_ARMGenerator()
var site_Spec_ARMGenerator gopter.Gen

// Site_Spec_ARMGenerator returns a generator of Site_Spec_ARM instances for property testing.
// We first initialize site_Spec_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Site_Spec_ARMGenerator() gopter.Gen {
	if site_Spec_ARMGenerator != nil {
		return site_Spec_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSite_Spec_ARM(generators)
	site_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(Site_Spec_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSite_Spec_ARM(generators)
	AddRelatedPropertyGeneratorsForSite_Spec_ARM(generators)
	site_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(Site_Spec_ARM{}), generators)

	return site_Spec_ARMGenerator
}

// AddIndependentPropertyGeneratorsForSite_Spec_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSite_Spec_ARM(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSite_Spec_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSite_Spec_ARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_ARMGenerator())
	gens["Identity"] = gen.PtrOf(ManagedServiceIdentity_ARMGenerator())
	gens["Properties"] = gen.PtrOf(Site_Properties_Spec_ARMGenerator())
}

func Test_ManagedServiceIdentity_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentity_ARM, ManagedServiceIdentity_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentity_ARM runs a test to see if a specific instance of ManagedServiceIdentity_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentity_ARM(subject ManagedServiceIdentity_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity_ARM instances for property testing - lazily instantiated by
// ManagedServiceIdentity_ARMGenerator()
var managedServiceIdentity_ARMGenerator gopter.Gen

// ManagedServiceIdentity_ARMGenerator returns a generator of ManagedServiceIdentity_ARM instances for property testing.
func ManagedServiceIdentity_ARMGenerator() gopter.Gen {
	if managedServiceIdentity_ARMGenerator != nil {
		return managedServiceIdentity_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity_ARM(generators)
	managedServiceIdentity_ARMGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_ARM{}), generators)

	return managedServiceIdentity_ARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentity_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentity_ARM(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ManagedServiceIdentity_Type_None,
		ManagedServiceIdentity_Type_SystemAssigned,
		ManagedServiceIdentity_Type_SystemAssignedUserAssigned,
		ManagedServiceIdentity_Type_UserAssigned))
}

func Test_Site_Properties_Spec_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Site_Properties_Spec_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSite_Properties_Spec_ARM, Site_Properties_Spec_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSite_Properties_Spec_ARM runs a test to see if a specific instance of Site_Properties_Spec_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSite_Properties_Spec_ARM(subject Site_Properties_Spec_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Site_Properties_Spec_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Site_Properties_Spec_ARM instances for property testing - lazily instantiated by
// Site_Properties_Spec_ARMGenerator()
var site_Properties_Spec_ARMGenerator gopter.Gen

// Site_Properties_Spec_ARMGenerator returns a generator of Site_Properties_Spec_ARM instances for property testing.
// We first initialize site_Properties_Spec_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Site_Properties_Spec_ARMGenerator() gopter.Gen {
	if site_Properties_Spec_ARMGenerator != nil {
		return site_Properties_Spec_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSite_Properties_Spec_ARM(generators)
	site_Properties_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(Site_Properties_Spec_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSite_Properties_Spec_ARM(generators)
	AddRelatedPropertyGeneratorsForSite_Properties_Spec_ARM(generators)
	site_Properties_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(Site_Properties_Spec_ARM{}), generators)

	return site_Properties_Spec_ARMGenerator
}

// AddIndependentPropertyGeneratorsForSite_Properties_Spec_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSite_Properties_Spec_ARM(gens map[string]gopter.Gen) {
	gens["ClientAffinityEnabled"] = gen.PtrOf(gen.Bool())
	gens["ClientCertEnabled"] = gen.PtrOf(gen.Bool())
	gens["ClientCertExclusionPaths"] = gen.PtrOf(gen.AlphaString())
	gens["ClientCertMode"] = gen.PtrOf(gen.OneConstOf(Site_Properties_ClientCertMode_Spec_Optional, Site_Properties_ClientCertMode_Spec_OptionalInteractiveUser, Site_Properties_ClientCertMode_Spec_Required))
	gens["ContainerSize"] = gen.PtrOf(gen.Int())
	gens["CustomDomainVerificationId"] = gen.PtrOf(gen.AlphaString())
	gens["DailyMemoryTimeQuota"] = gen.PtrOf(gen.Int())
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["HostNamesDisabled"] = gen.PtrOf(gen.Bool())
	gens["HttpsOnly"] = gen.PtrOf(gen.Bool())
	gens["HyperV"] = gen.PtrOf(gen.Bool())
	gens["IsXenon"] = gen.PtrOf(gen.Bool())
	gens["KeyVaultReferenceIdentity"] = gen.PtrOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.AlphaString())
	gens["RedundancyMode"] = gen.PtrOf(gen.OneConstOf(
		Site_Properties_RedundancyMode_Spec_ActiveActive,
		Site_Properties_RedundancyMode_Spec_Failover,
		Site_Properties_RedundancyMode_Spec_GeoRedundant,
		Site_Properties_RedundancyMode_Spec_Manual,
		Site_Properties_RedundancyMode_Spec_None))
	gens["Reserved"] = gen.PtrOf(gen.Bool())
	gens["ScmSiteAlsoStopped"] = gen.PtrOf(gen.Bool())
	gens["ServerFarmId"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountRequired"] = gen.PtrOf(gen.Bool())
	gens["VirtualNetworkSubnetId"] = gen.PtrOf(gen.AlphaString())
	gens["VnetContentShareEnabled"] = gen.PtrOf(gen.Bool())
	gens["VnetImagePullEnabled"] = gen.PtrOf(gen.Bool())
	gens["VnetRouteAllEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForSite_Properties_Spec_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSite_Properties_Spec_ARM(gens map[string]gopter.Gen) {
	gens["CloningInfo"] = gen.PtrOf(CloningInfo_ARMGenerator())
	gens["HostNameSslStates"] = gen.SliceOf(HostNameSslState_ARMGenerator())
	gens["HostingEnvironmentProfile"] = gen.PtrOf(HostingEnvironmentProfile_ARMGenerator())
	gens["SiteConfig"] = gen.PtrOf(SiteConfig_ARMGenerator())
}

func Test_CloningInfo_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CloningInfo_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCloningInfo_ARM, CloningInfo_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCloningInfo_ARM runs a test to see if a specific instance of CloningInfo_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCloningInfo_ARM(subject CloningInfo_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CloningInfo_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CloningInfo_ARM instances for property testing - lazily instantiated by CloningInfo_ARMGenerator()
var cloningInfo_ARMGenerator gopter.Gen

// CloningInfo_ARMGenerator returns a generator of CloningInfo_ARM instances for property testing.
func CloningInfo_ARMGenerator() gopter.Gen {
	if cloningInfo_ARMGenerator != nil {
		return cloningInfo_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCloningInfo_ARM(generators)
	cloningInfo_ARMGenerator = gen.Struct(reflect.TypeOf(CloningInfo_ARM{}), generators)

	return cloningInfo_ARMGenerator
}

// AddIndependentPropertyGeneratorsForCloningInfo_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCloningInfo_ARM(gens map[string]gopter.Gen) {
	gens["AppSettingsOverrides"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["CloneCustomHostNames"] = gen.PtrOf(gen.Bool())
	gens["CloneSourceControl"] = gen.PtrOf(gen.Bool())
	gens["ConfigureLoadBalancing"] = gen.PtrOf(gen.Bool())
	gens["CorrelationId"] = gen.PtrOf(gen.AlphaString())
	gens["HostingEnvironment"] = gen.PtrOf(gen.AlphaString())
	gens["Overwrite"] = gen.PtrOf(gen.Bool())
	gens["SourceWebAppId"] = gen.PtrOf(gen.AlphaString())
	gens["SourceWebAppLocation"] = gen.PtrOf(gen.AlphaString())
	gens["TrafficManagerProfileId"] = gen.PtrOf(gen.AlphaString())
	gens["TrafficManagerProfileName"] = gen.PtrOf(gen.AlphaString())
}

func Test_HostNameSslState_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HostNameSslState_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHostNameSslState_ARM, HostNameSslState_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHostNameSslState_ARM runs a test to see if a specific instance of HostNameSslState_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHostNameSslState_ARM(subject HostNameSslState_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HostNameSslState_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HostNameSslState_ARM instances for property testing - lazily instantiated by
// HostNameSslState_ARMGenerator()
var hostNameSslState_ARMGenerator gopter.Gen

// HostNameSslState_ARMGenerator returns a generator of HostNameSslState_ARM instances for property testing.
func HostNameSslState_ARMGenerator() gopter.Gen {
	if hostNameSslState_ARMGenerator != nil {
		return hostNameSslState_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHostNameSslState_ARM(generators)
	hostNameSslState_ARMGenerator = gen.Struct(reflect.TypeOf(HostNameSslState_ARM{}), generators)

	return hostNameSslState_ARMGenerator
}

// AddIndependentPropertyGeneratorsForHostNameSslState_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHostNameSslState_ARM(gens map[string]gopter.Gen) {
	gens["HostType"] = gen.PtrOf(gen.OneConstOf(HostNameSslState_HostType_Repository, HostNameSslState_HostType_Standard))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["SslState"] = gen.PtrOf(gen.OneConstOf(HostNameSslState_SslState_Disabled, HostNameSslState_SslState_IpBasedEnabled, HostNameSslState_SslState_SniEnabled))
	gens["Thumbprint"] = gen.PtrOf(gen.AlphaString())
	gens["ToUpdate"] = gen.PtrOf(gen.Bool())
	gens["VirtualIP"] = gen.PtrOf(gen.AlphaString())
}

func Test_SiteConfig_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SiteConfig_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSiteConfig_ARM, SiteConfig_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSiteConfig_ARM runs a test to see if a specific instance of SiteConfig_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSiteConfig_ARM(subject SiteConfig_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SiteConfig_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SiteConfig_ARM instances for property testing - lazily instantiated by SiteConfig_ARMGenerator()
var siteConfig_ARMGenerator gopter.Gen

// SiteConfig_ARMGenerator returns a generator of SiteConfig_ARM instances for property testing.
func SiteConfig_ARMGenerator() gopter.Gen {
	if siteConfig_ARMGenerator != nil {
		return siteConfig_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForSiteConfig_ARM(generators)
	siteConfig_ARMGenerator = gen.Struct(reflect.TypeOf(SiteConfig_ARM{}), generators)

	return siteConfig_ARMGenerator
}

// AddRelatedPropertyGeneratorsForSiteConfig_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSiteConfig_ARM(gens map[string]gopter.Gen) {
	gens["ApiDefinition"] = gen.PtrOf(ApiDefinitionInfo_ARMGenerator())
	gens["ApiManagementConfig"] = gen.PtrOf(ApiManagementConfig_ARMGenerator())
	gens["AppSettings"] = gen.SliceOf(NameValuePair_ARMGenerator())
	gens["AutoHealRules"] = gen.PtrOf(AutoHealRules_ARMGenerator())
	gens["AzureStorageAccounts"] = gen.MapOf(gen.AlphaString(), AzureStorageInfoValue_ARMGenerator())
	gens["ConnectionStrings"] = gen.SliceOf(ConnStringInfo_ARMGenerator())
	gens["Cors"] = gen.PtrOf(CorsSettings_ARMGenerator())
	gens["Experiments"] = gen.PtrOf(Experiments_ARMGenerator())
	gens["HandlerMappings"] = gen.SliceOf(HandlerMapping_ARMGenerator())
	gens["IpSecurityRestrictions"] = gen.SliceOf(IpSecurityRestriction_ARMGenerator())
	gens["Limits"] = gen.PtrOf(SiteLimits_ARMGenerator())
	gens["Push"] = gen.PtrOf(PushSettings_ARMGenerator())
	gens["ScmIpSecurityRestrictions"] = gen.SliceOf(IpSecurityRestriction_ARMGenerator())
	gens["VirtualApplications"] = gen.SliceOf(VirtualApplication_ARMGenerator())
}

func Test_ApiDefinitionInfo_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiDefinitionInfo_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiDefinitionInfo_ARM, ApiDefinitionInfo_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiDefinitionInfo_ARM runs a test to see if a specific instance of ApiDefinitionInfo_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForApiDefinitionInfo_ARM(subject ApiDefinitionInfo_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiDefinitionInfo_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiDefinitionInfo_ARM instances for property testing - lazily instantiated by
// ApiDefinitionInfo_ARMGenerator()
var apiDefinitionInfo_ARMGenerator gopter.Gen

// ApiDefinitionInfo_ARMGenerator returns a generator of ApiDefinitionInfo_ARM instances for property testing.
func ApiDefinitionInfo_ARMGenerator() gopter.Gen {
	if apiDefinitionInfo_ARMGenerator != nil {
		return apiDefinitionInfo_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiDefinitionInfo_ARM(generators)
	apiDefinitionInfo_ARMGenerator = gen.Struct(reflect.TypeOf(ApiDefinitionInfo_ARM{}), generators)

	return apiDefinitionInfo_ARMGenerator
}

// AddIndependentPropertyGeneratorsForApiDefinitionInfo_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiDefinitionInfo_ARM(gens map[string]gopter.Gen) {
	gens["Url"] = gen.PtrOf(gen.AlphaString())
}

func Test_ApiManagementConfig_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiManagementConfig_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiManagementConfig_ARM, ApiManagementConfig_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiManagementConfig_ARM runs a test to see if a specific instance of ApiManagementConfig_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForApiManagementConfig_ARM(subject ApiManagementConfig_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiManagementConfig_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiManagementConfig_ARM instances for property testing - lazily instantiated by
// ApiManagementConfig_ARMGenerator()
var apiManagementConfig_ARMGenerator gopter.Gen

// ApiManagementConfig_ARMGenerator returns a generator of ApiManagementConfig_ARM instances for property testing.
func ApiManagementConfig_ARMGenerator() gopter.Gen {
	if apiManagementConfig_ARMGenerator != nil {
		return apiManagementConfig_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiManagementConfig_ARM(generators)
	apiManagementConfig_ARMGenerator = gen.Struct(reflect.TypeOf(ApiManagementConfig_ARM{}), generators)

	return apiManagementConfig_ARMGenerator
}

// AddIndependentPropertyGeneratorsForApiManagementConfig_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiManagementConfig_ARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_AutoHealRules_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoHealRules_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoHealRules_ARM, AutoHealRules_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoHealRules_ARM runs a test to see if a specific instance of AutoHealRules_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoHealRules_ARM(subject AutoHealRules_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoHealRules_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoHealRules_ARM instances for property testing - lazily instantiated by AutoHealRules_ARMGenerator()
var autoHealRules_ARMGenerator gopter.Gen

// AutoHealRules_ARMGenerator returns a generator of AutoHealRules_ARM instances for property testing.
func AutoHealRules_ARMGenerator() gopter.Gen {
	if autoHealRules_ARMGenerator != nil {
		return autoHealRules_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForAutoHealRules_ARM(generators)
	autoHealRules_ARMGenerator = gen.Struct(reflect.TypeOf(AutoHealRules_ARM{}), generators)

	return autoHealRules_ARMGenerator
}

// AddRelatedPropertyGeneratorsForAutoHealRules_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoHealRules_ARM(gens map[string]gopter.Gen) {
	gens["Actions"] = gen.PtrOf(AutoHealActions_ARMGenerator())
	gens["Triggers"] = gen.PtrOf(AutoHealTriggers_ARMGenerator())
}

func Test_AzureStorageInfoValue_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureStorageInfoValue_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureStorageInfoValue_ARM, AzureStorageInfoValue_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureStorageInfoValue_ARM runs a test to see if a specific instance of AzureStorageInfoValue_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureStorageInfoValue_ARM(subject AzureStorageInfoValue_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureStorageInfoValue_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureStorageInfoValue_ARM instances for property testing - lazily instantiated by
// AzureStorageInfoValue_ARMGenerator()
var azureStorageInfoValue_ARMGenerator gopter.Gen

// AzureStorageInfoValue_ARMGenerator returns a generator of AzureStorageInfoValue_ARM instances for property testing.
func AzureStorageInfoValue_ARMGenerator() gopter.Gen {
	if azureStorageInfoValue_ARMGenerator != nil {
		return azureStorageInfoValue_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureStorageInfoValue_ARM(generators)
	azureStorageInfoValue_ARMGenerator = gen.Struct(reflect.TypeOf(AzureStorageInfoValue_ARM{}), generators)

	return azureStorageInfoValue_ARMGenerator
}

// AddIndependentPropertyGeneratorsForAzureStorageInfoValue_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureStorageInfoValue_ARM(gens map[string]gopter.Gen) {
	gens["AccessKey"] = gen.PtrOf(gen.AlphaString())
	gens["AccountName"] = gen.PtrOf(gen.AlphaString())
	gens["MountPath"] = gen.PtrOf(gen.AlphaString())
	gens["ShareName"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(AzureStorageInfoValue_Type_AzureBlob, AzureStorageInfoValue_Type_AzureFiles))
}

func Test_ConnStringInfo_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ConnStringInfo_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForConnStringInfo_ARM, ConnStringInfo_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForConnStringInfo_ARM runs a test to see if a specific instance of ConnStringInfo_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForConnStringInfo_ARM(subject ConnStringInfo_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ConnStringInfo_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ConnStringInfo_ARM instances for property testing - lazily instantiated by ConnStringInfo_ARMGenerator()
var connStringInfo_ARMGenerator gopter.Gen

// ConnStringInfo_ARMGenerator returns a generator of ConnStringInfo_ARM instances for property testing.
func ConnStringInfo_ARMGenerator() gopter.Gen {
	if connStringInfo_ARMGenerator != nil {
		return connStringInfo_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForConnStringInfo_ARM(generators)
	connStringInfo_ARMGenerator = gen.Struct(reflect.TypeOf(ConnStringInfo_ARM{}), generators)

	return connStringInfo_ARMGenerator
}

// AddIndependentPropertyGeneratorsForConnStringInfo_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForConnStringInfo_ARM(gens map[string]gopter.Gen) {
	gens["ConnectionString"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ConnStringInfo_Type_ApiHub,
		ConnStringInfo_Type_Custom,
		ConnStringInfo_Type_DocDb,
		ConnStringInfo_Type_EventHub,
		ConnStringInfo_Type_MySql,
		ConnStringInfo_Type_NotificationHub,
		ConnStringInfo_Type_PostgreSQL,
		ConnStringInfo_Type_RedisCache,
		ConnStringInfo_Type_SQLAzure,
		ConnStringInfo_Type_SQLServer,
		ConnStringInfo_Type_ServiceBus))
}

func Test_CorsSettings_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CorsSettings_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCorsSettings_ARM, CorsSettings_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCorsSettings_ARM runs a test to see if a specific instance of CorsSettings_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCorsSettings_ARM(subject CorsSettings_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CorsSettings_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CorsSettings_ARM instances for property testing - lazily instantiated by CorsSettings_ARMGenerator()
var corsSettings_ARMGenerator gopter.Gen

// CorsSettings_ARMGenerator returns a generator of CorsSettings_ARM instances for property testing.
func CorsSettings_ARMGenerator() gopter.Gen {
	if corsSettings_ARMGenerator != nil {
		return corsSettings_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCorsSettings_ARM(generators)
	corsSettings_ARMGenerator = gen.Struct(reflect.TypeOf(CorsSettings_ARM{}), generators)

	return corsSettings_ARMGenerator
}

// AddIndependentPropertyGeneratorsForCorsSettings_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCorsSettings_ARM(gens map[string]gopter.Gen) {
	gens["AllowedOrigins"] = gen.SliceOf(gen.AlphaString())
	gens["SupportCredentials"] = gen.PtrOf(gen.Bool())
}

func Test_Experiments_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Experiments_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExperiments_ARM, Experiments_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExperiments_ARM runs a test to see if a specific instance of Experiments_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForExperiments_ARM(subject Experiments_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Experiments_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Experiments_ARM instances for property testing - lazily instantiated by Experiments_ARMGenerator()
var experiments_ARMGenerator gopter.Gen

// Experiments_ARMGenerator returns a generator of Experiments_ARM instances for property testing.
func Experiments_ARMGenerator() gopter.Gen {
	if experiments_ARMGenerator != nil {
		return experiments_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForExperiments_ARM(generators)
	experiments_ARMGenerator = gen.Struct(reflect.TypeOf(Experiments_ARM{}), generators)

	return experiments_ARMGenerator
}

// AddRelatedPropertyGeneratorsForExperiments_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForExperiments_ARM(gens map[string]gopter.Gen) {
	gens["RampUpRules"] = gen.SliceOf(RampUpRule_ARMGenerator())
}

func Test_HandlerMapping_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HandlerMapping_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHandlerMapping_ARM, HandlerMapping_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHandlerMapping_ARM runs a test to see if a specific instance of HandlerMapping_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHandlerMapping_ARM(subject HandlerMapping_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HandlerMapping_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HandlerMapping_ARM instances for property testing - lazily instantiated by HandlerMapping_ARMGenerator()
var handlerMapping_ARMGenerator gopter.Gen

// HandlerMapping_ARMGenerator returns a generator of HandlerMapping_ARM instances for property testing.
func HandlerMapping_ARMGenerator() gopter.Gen {
	if handlerMapping_ARMGenerator != nil {
		return handlerMapping_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHandlerMapping_ARM(generators)
	handlerMapping_ARMGenerator = gen.Struct(reflect.TypeOf(HandlerMapping_ARM{}), generators)

	return handlerMapping_ARMGenerator
}

// AddIndependentPropertyGeneratorsForHandlerMapping_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHandlerMapping_ARM(gens map[string]gopter.Gen) {
	gens["Arguments"] = gen.PtrOf(gen.AlphaString())
	gens["Extension"] = gen.PtrOf(gen.AlphaString())
	gens["ScriptProcessor"] = gen.PtrOf(gen.AlphaString())
}

func Test_IpSecurityRestriction_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpSecurityRestriction_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpSecurityRestriction_ARM, IpSecurityRestriction_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpSecurityRestriction_ARM runs a test to see if a specific instance of IpSecurityRestriction_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIpSecurityRestriction_ARM(subject IpSecurityRestriction_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpSecurityRestriction_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpSecurityRestriction_ARM instances for property testing - lazily instantiated by
// IpSecurityRestriction_ARMGenerator()
var ipSecurityRestriction_ARMGenerator gopter.Gen

// IpSecurityRestriction_ARMGenerator returns a generator of IpSecurityRestriction_ARM instances for property testing.
func IpSecurityRestriction_ARMGenerator() gopter.Gen {
	if ipSecurityRestriction_ARMGenerator != nil {
		return ipSecurityRestriction_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpSecurityRestriction_ARM(generators)
	ipSecurityRestriction_ARMGenerator = gen.Struct(reflect.TypeOf(IpSecurityRestriction_ARM{}), generators)

	return ipSecurityRestriction_ARMGenerator
}

// AddIndependentPropertyGeneratorsForIpSecurityRestriction_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpSecurityRestriction_ARM(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.AlphaString())
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["Headers"] = gen.MapOf(gen.AlphaString(), gen.SliceOf(gen.AlphaString()))
	gens["IpAddress"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Priority"] = gen.PtrOf(gen.Int())
	gens["SubnetMask"] = gen.PtrOf(gen.AlphaString())
	gens["SubnetTrafficTag"] = gen.PtrOf(gen.Int())
	gens["Tag"] = gen.PtrOf(gen.OneConstOf(IpSecurityRestriction_Tag_Default, IpSecurityRestriction_Tag_ServiceTag, IpSecurityRestriction_Tag_XffProxy))
	gens["VnetSubnetResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["VnetTrafficTag"] = gen.PtrOf(gen.Int())
}

func Test_NameValuePair_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NameValuePair_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNameValuePair_ARM, NameValuePair_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNameValuePair_ARM runs a test to see if a specific instance of NameValuePair_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNameValuePair_ARM(subject NameValuePair_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NameValuePair_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NameValuePair_ARM instances for property testing - lazily instantiated by NameValuePair_ARMGenerator()
var nameValuePair_ARMGenerator gopter.Gen

// NameValuePair_ARMGenerator returns a generator of NameValuePair_ARM instances for property testing.
func NameValuePair_ARMGenerator() gopter.Gen {
	if nameValuePair_ARMGenerator != nil {
		return nameValuePair_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNameValuePair_ARM(generators)
	nameValuePair_ARMGenerator = gen.Struct(reflect.TypeOf(NameValuePair_ARM{}), generators)

	return nameValuePair_ARMGenerator
}

// AddIndependentPropertyGeneratorsForNameValuePair_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNameValuePair_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_PushSettings_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PushSettings_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPushSettings_ARM, PushSettings_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPushSettings_ARM runs a test to see if a specific instance of PushSettings_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPushSettings_ARM(subject PushSettings_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PushSettings_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PushSettings_ARM instances for property testing - lazily instantiated by PushSettings_ARMGenerator()
var pushSettings_ARMGenerator gopter.Gen

// PushSettings_ARMGenerator returns a generator of PushSettings_ARM instances for property testing.
// We first initialize pushSettings_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PushSettings_ARMGenerator() gopter.Gen {
	if pushSettings_ARMGenerator != nil {
		return pushSettings_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPushSettings_ARM(generators)
	pushSettings_ARMGenerator = gen.Struct(reflect.TypeOf(PushSettings_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPushSettings_ARM(generators)
	AddRelatedPropertyGeneratorsForPushSettings_ARM(generators)
	pushSettings_ARMGenerator = gen.Struct(reflect.TypeOf(PushSettings_ARM{}), generators)

	return pushSettings_ARMGenerator
}

// AddIndependentPropertyGeneratorsForPushSettings_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPushSettings_ARM(gens map[string]gopter.Gen) {
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPushSettings_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPushSettings_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(PushSettings_Properties_ARMGenerator())
}

func Test_SiteLimits_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SiteLimits_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSiteLimits_ARM, SiteLimits_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSiteLimits_ARM runs a test to see if a specific instance of SiteLimits_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSiteLimits_ARM(subject SiteLimits_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SiteLimits_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SiteLimits_ARM instances for property testing - lazily instantiated by SiteLimits_ARMGenerator()
var siteLimits_ARMGenerator gopter.Gen

// SiteLimits_ARMGenerator returns a generator of SiteLimits_ARM instances for property testing.
func SiteLimits_ARMGenerator() gopter.Gen {
	if siteLimits_ARMGenerator != nil {
		return siteLimits_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSiteLimits_ARM(generators)
	siteLimits_ARMGenerator = gen.Struct(reflect.TypeOf(SiteLimits_ARM{}), generators)

	return siteLimits_ARMGenerator
}

// AddIndependentPropertyGeneratorsForSiteLimits_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSiteLimits_ARM(gens map[string]gopter.Gen) {
	gens["MaxDiskSizeInMb"] = gen.PtrOf(gen.Int())
	gens["MaxMemoryInMb"] = gen.PtrOf(gen.Int())
	gens["MaxPercentageCpu"] = gen.PtrOf(gen.Float64())
}

func Test_VirtualApplication_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualApplication_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualApplication_ARM, VirtualApplication_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualApplication_ARM runs a test to see if a specific instance of VirtualApplication_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualApplication_ARM(subject VirtualApplication_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualApplication_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualApplication_ARM instances for property testing - lazily instantiated by
// VirtualApplication_ARMGenerator()
var virtualApplication_ARMGenerator gopter.Gen

// VirtualApplication_ARMGenerator returns a generator of VirtualApplication_ARM instances for property testing.
// We first initialize virtualApplication_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualApplication_ARMGenerator() gopter.Gen {
	if virtualApplication_ARMGenerator != nil {
		return virtualApplication_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualApplication_ARM(generators)
	virtualApplication_ARMGenerator = gen.Struct(reflect.TypeOf(VirtualApplication_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualApplication_ARM(generators)
	AddRelatedPropertyGeneratorsForVirtualApplication_ARM(generators)
	virtualApplication_ARMGenerator = gen.Struct(reflect.TypeOf(VirtualApplication_ARM{}), generators)

	return virtualApplication_ARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualApplication_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualApplication_ARM(gens map[string]gopter.Gen) {
	gens["PhysicalPath"] = gen.PtrOf(gen.AlphaString())
	gens["PreloadEnabled"] = gen.PtrOf(gen.Bool())
	gens["VirtualPath"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualApplication_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualApplication_ARM(gens map[string]gopter.Gen) {
	gens["VirtualDirectories"] = gen.SliceOf(VirtualDirectory_ARMGenerator())
}

func Test_AutoHealActions_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoHealActions_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoHealActions_ARM, AutoHealActions_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoHealActions_ARM runs a test to see if a specific instance of AutoHealActions_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoHealActions_ARM(subject AutoHealActions_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoHealActions_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoHealActions_ARM instances for property testing - lazily instantiated by
// AutoHealActions_ARMGenerator()
var autoHealActions_ARMGenerator gopter.Gen

// AutoHealActions_ARMGenerator returns a generator of AutoHealActions_ARM instances for property testing.
// We first initialize autoHealActions_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AutoHealActions_ARMGenerator() gopter.Gen {
	if autoHealActions_ARMGenerator != nil {
		return autoHealActions_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoHealActions_ARM(generators)
	autoHealActions_ARMGenerator = gen.Struct(reflect.TypeOf(AutoHealActions_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoHealActions_ARM(generators)
	AddRelatedPropertyGeneratorsForAutoHealActions_ARM(generators)
	autoHealActions_ARMGenerator = gen.Struct(reflect.TypeOf(AutoHealActions_ARM{}), generators)

	return autoHealActions_ARMGenerator
}

// AddIndependentPropertyGeneratorsForAutoHealActions_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoHealActions_ARM(gens map[string]gopter.Gen) {
	gens["ActionType"] = gen.PtrOf(gen.OneConstOf(AutoHealActions_ActionType_CustomAction, AutoHealActions_ActionType_LogEvent, AutoHealActions_ActionType_Recycle))
	gens["MinProcessExecutionTime"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAutoHealActions_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoHealActions_ARM(gens map[string]gopter.Gen) {
	gens["CustomAction"] = gen.PtrOf(AutoHealCustomAction_ARMGenerator())
}

func Test_AutoHealTriggers_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoHealTriggers_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoHealTriggers_ARM, AutoHealTriggers_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoHealTriggers_ARM runs a test to see if a specific instance of AutoHealTriggers_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoHealTriggers_ARM(subject AutoHealTriggers_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoHealTriggers_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoHealTriggers_ARM instances for property testing - lazily instantiated by
// AutoHealTriggers_ARMGenerator()
var autoHealTriggers_ARMGenerator gopter.Gen

// AutoHealTriggers_ARMGenerator returns a generator of AutoHealTriggers_ARM instances for property testing.
// We first initialize autoHealTriggers_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AutoHealTriggers_ARMGenerator() gopter.Gen {
	if autoHealTriggers_ARMGenerator != nil {
		return autoHealTriggers_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoHealTriggers_ARM(generators)
	autoHealTriggers_ARMGenerator = gen.Struct(reflect.TypeOf(AutoHealTriggers_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoHealTriggers_ARM(generators)
	AddRelatedPropertyGeneratorsForAutoHealTriggers_ARM(generators)
	autoHealTriggers_ARMGenerator = gen.Struct(reflect.TypeOf(AutoHealTriggers_ARM{}), generators)

	return autoHealTriggers_ARMGenerator
}

// AddIndependentPropertyGeneratorsForAutoHealTriggers_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoHealTriggers_ARM(gens map[string]gopter.Gen) {
	gens["PrivateBytesInKB"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForAutoHealTriggers_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoHealTriggers_ARM(gens map[string]gopter.Gen) {
	gens["Requests"] = gen.PtrOf(RequestsBasedTrigger_ARMGenerator())
	gens["SlowRequests"] = gen.PtrOf(SlowRequestsBasedTrigger_ARMGenerator())
	gens["SlowRequestsWithPath"] = gen.SliceOf(SlowRequestsBasedTrigger_ARMGenerator())
	gens["StatusCodes"] = gen.SliceOf(StatusCodesBasedTrigger_ARMGenerator())
	gens["StatusCodesRange"] = gen.SliceOf(StatusCodesRangeBasedTrigger_ARMGenerator())
}

func Test_PushSettings_Properties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PushSettings_Properties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPushSettings_Properties_ARM, PushSettings_Properties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPushSettings_Properties_ARM runs a test to see if a specific instance of PushSettings_Properties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPushSettings_Properties_ARM(subject PushSettings_Properties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PushSettings_Properties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PushSettings_Properties_ARM instances for property testing - lazily instantiated by
// PushSettings_Properties_ARMGenerator()
var pushSettings_Properties_ARMGenerator gopter.Gen

// PushSettings_Properties_ARMGenerator returns a generator of PushSettings_Properties_ARM instances for property testing.
func PushSettings_Properties_ARMGenerator() gopter.Gen {
	if pushSettings_Properties_ARMGenerator != nil {
		return pushSettings_Properties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPushSettings_Properties_ARM(generators)
	pushSettings_Properties_ARMGenerator = gen.Struct(reflect.TypeOf(PushSettings_Properties_ARM{}), generators)

	return pushSettings_Properties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForPushSettings_Properties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPushSettings_Properties_ARM(gens map[string]gopter.Gen) {
	gens["DynamicTagsJson"] = gen.PtrOf(gen.AlphaString())
	gens["IsPushEnabled"] = gen.PtrOf(gen.Bool())
	gens["TagWhitelistJson"] = gen.PtrOf(gen.AlphaString())
	gens["TagsRequiringAuth"] = gen.PtrOf(gen.AlphaString())
}

func Test_RampUpRule_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RampUpRule_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRampUpRule_ARM, RampUpRule_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRampUpRule_ARM runs a test to see if a specific instance of RampUpRule_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRampUpRule_ARM(subject RampUpRule_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RampUpRule_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RampUpRule_ARM instances for property testing - lazily instantiated by RampUpRule_ARMGenerator()
var rampUpRule_ARMGenerator gopter.Gen

// RampUpRule_ARMGenerator returns a generator of RampUpRule_ARM instances for property testing.
func RampUpRule_ARMGenerator() gopter.Gen {
	if rampUpRule_ARMGenerator != nil {
		return rampUpRule_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRampUpRule_ARM(generators)
	rampUpRule_ARMGenerator = gen.Struct(reflect.TypeOf(RampUpRule_ARM{}), generators)

	return rampUpRule_ARMGenerator
}

// AddIndependentPropertyGeneratorsForRampUpRule_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRampUpRule_ARM(gens map[string]gopter.Gen) {
	gens["ActionHostName"] = gen.PtrOf(gen.AlphaString())
	gens["ChangeDecisionCallbackUrl"] = gen.PtrOf(gen.AlphaString())
	gens["ChangeIntervalInMinutes"] = gen.PtrOf(gen.Int())
	gens["ChangeStep"] = gen.PtrOf(gen.Float64())
	gens["MaxReroutePercentage"] = gen.PtrOf(gen.Float64())
	gens["MinReroutePercentage"] = gen.PtrOf(gen.Float64())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ReroutePercentage"] = gen.PtrOf(gen.Float64())
}

func Test_VirtualDirectory_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualDirectory_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualDirectory_ARM, VirtualDirectory_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualDirectory_ARM runs a test to see if a specific instance of VirtualDirectory_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualDirectory_ARM(subject VirtualDirectory_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualDirectory_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualDirectory_ARM instances for property testing - lazily instantiated by
// VirtualDirectory_ARMGenerator()
var virtualDirectory_ARMGenerator gopter.Gen

// VirtualDirectory_ARMGenerator returns a generator of VirtualDirectory_ARM instances for property testing.
func VirtualDirectory_ARMGenerator() gopter.Gen {
	if virtualDirectory_ARMGenerator != nil {
		return virtualDirectory_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualDirectory_ARM(generators)
	virtualDirectory_ARMGenerator = gen.Struct(reflect.TypeOf(VirtualDirectory_ARM{}), generators)

	return virtualDirectory_ARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualDirectory_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualDirectory_ARM(gens map[string]gopter.Gen) {
	gens["PhysicalPath"] = gen.PtrOf(gen.AlphaString())
	gens["VirtualPath"] = gen.PtrOf(gen.AlphaString())
}

func Test_AutoHealCustomAction_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoHealCustomAction_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoHealCustomAction_ARM, AutoHealCustomAction_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoHealCustomAction_ARM runs a test to see if a specific instance of AutoHealCustomAction_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoHealCustomAction_ARM(subject AutoHealCustomAction_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoHealCustomAction_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoHealCustomAction_ARM instances for property testing - lazily instantiated by
// AutoHealCustomAction_ARMGenerator()
var autoHealCustomAction_ARMGenerator gopter.Gen

// AutoHealCustomAction_ARMGenerator returns a generator of AutoHealCustomAction_ARM instances for property testing.
func AutoHealCustomAction_ARMGenerator() gopter.Gen {
	if autoHealCustomAction_ARMGenerator != nil {
		return autoHealCustomAction_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoHealCustomAction_ARM(generators)
	autoHealCustomAction_ARMGenerator = gen.Struct(reflect.TypeOf(AutoHealCustomAction_ARM{}), generators)

	return autoHealCustomAction_ARMGenerator
}

// AddIndependentPropertyGeneratorsForAutoHealCustomAction_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoHealCustomAction_ARM(gens map[string]gopter.Gen) {
	gens["Exe"] = gen.PtrOf(gen.AlphaString())
	gens["Parameters"] = gen.PtrOf(gen.AlphaString())
}

func Test_RequestsBasedTrigger_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RequestsBasedTrigger_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRequestsBasedTrigger_ARM, RequestsBasedTrigger_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRequestsBasedTrigger_ARM runs a test to see if a specific instance of RequestsBasedTrigger_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRequestsBasedTrigger_ARM(subject RequestsBasedTrigger_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RequestsBasedTrigger_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RequestsBasedTrigger_ARM instances for property testing - lazily instantiated by
// RequestsBasedTrigger_ARMGenerator()
var requestsBasedTrigger_ARMGenerator gopter.Gen

// RequestsBasedTrigger_ARMGenerator returns a generator of RequestsBasedTrigger_ARM instances for property testing.
func RequestsBasedTrigger_ARMGenerator() gopter.Gen {
	if requestsBasedTrigger_ARMGenerator != nil {
		return requestsBasedTrigger_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRequestsBasedTrigger_ARM(generators)
	requestsBasedTrigger_ARMGenerator = gen.Struct(reflect.TypeOf(RequestsBasedTrigger_ARM{}), generators)

	return requestsBasedTrigger_ARMGenerator
}

// AddIndependentPropertyGeneratorsForRequestsBasedTrigger_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRequestsBasedTrigger_ARM(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["TimeInterval"] = gen.PtrOf(gen.AlphaString())
}

func Test_SlowRequestsBasedTrigger_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SlowRequestsBasedTrigger_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSlowRequestsBasedTrigger_ARM, SlowRequestsBasedTrigger_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSlowRequestsBasedTrigger_ARM runs a test to see if a specific instance of SlowRequestsBasedTrigger_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSlowRequestsBasedTrigger_ARM(subject SlowRequestsBasedTrigger_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SlowRequestsBasedTrigger_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SlowRequestsBasedTrigger_ARM instances for property testing - lazily instantiated by
// SlowRequestsBasedTrigger_ARMGenerator()
var slowRequestsBasedTrigger_ARMGenerator gopter.Gen

// SlowRequestsBasedTrigger_ARMGenerator returns a generator of SlowRequestsBasedTrigger_ARM instances for property testing.
func SlowRequestsBasedTrigger_ARMGenerator() gopter.Gen {
	if slowRequestsBasedTrigger_ARMGenerator != nil {
		return slowRequestsBasedTrigger_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSlowRequestsBasedTrigger_ARM(generators)
	slowRequestsBasedTrigger_ARMGenerator = gen.Struct(reflect.TypeOf(SlowRequestsBasedTrigger_ARM{}), generators)

	return slowRequestsBasedTrigger_ARMGenerator
}

// AddIndependentPropertyGeneratorsForSlowRequestsBasedTrigger_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSlowRequestsBasedTrigger_ARM(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["TimeInterval"] = gen.PtrOf(gen.AlphaString())
	gens["TimeTaken"] = gen.PtrOf(gen.AlphaString())
}

func Test_StatusCodesBasedTrigger_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StatusCodesBasedTrigger_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStatusCodesBasedTrigger_ARM, StatusCodesBasedTrigger_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStatusCodesBasedTrigger_ARM runs a test to see if a specific instance of StatusCodesBasedTrigger_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStatusCodesBasedTrigger_ARM(subject StatusCodesBasedTrigger_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StatusCodesBasedTrigger_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StatusCodesBasedTrigger_ARM instances for property testing - lazily instantiated by
// StatusCodesBasedTrigger_ARMGenerator()
var statusCodesBasedTrigger_ARMGenerator gopter.Gen

// StatusCodesBasedTrigger_ARMGenerator returns a generator of StatusCodesBasedTrigger_ARM instances for property testing.
func StatusCodesBasedTrigger_ARMGenerator() gopter.Gen {
	if statusCodesBasedTrigger_ARMGenerator != nil {
		return statusCodesBasedTrigger_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStatusCodesBasedTrigger_ARM(generators)
	statusCodesBasedTrigger_ARMGenerator = gen.Struct(reflect.TypeOf(StatusCodesBasedTrigger_ARM{}), generators)

	return statusCodesBasedTrigger_ARMGenerator
}

// AddIndependentPropertyGeneratorsForStatusCodesBasedTrigger_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStatusCodesBasedTrigger_ARM(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.Int())
	gens["SubStatus"] = gen.PtrOf(gen.Int())
	gens["TimeInterval"] = gen.PtrOf(gen.AlphaString())
	gens["Win32Status"] = gen.PtrOf(gen.Int())
}

func Test_StatusCodesRangeBasedTrigger_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StatusCodesRangeBasedTrigger_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStatusCodesRangeBasedTrigger_ARM, StatusCodesRangeBasedTrigger_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStatusCodesRangeBasedTrigger_ARM runs a test to see if a specific instance of StatusCodesRangeBasedTrigger_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStatusCodesRangeBasedTrigger_ARM(subject StatusCodesRangeBasedTrigger_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StatusCodesRangeBasedTrigger_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StatusCodesRangeBasedTrigger_ARM instances for property testing - lazily instantiated by
// StatusCodesRangeBasedTrigger_ARMGenerator()
var statusCodesRangeBasedTrigger_ARMGenerator gopter.Gen

// StatusCodesRangeBasedTrigger_ARMGenerator returns a generator of StatusCodesRangeBasedTrigger_ARM instances for property testing.
func StatusCodesRangeBasedTrigger_ARMGenerator() gopter.Gen {
	if statusCodesRangeBasedTrigger_ARMGenerator != nil {
		return statusCodesRangeBasedTrigger_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStatusCodesRangeBasedTrigger_ARM(generators)
	statusCodesRangeBasedTrigger_ARMGenerator = gen.Struct(reflect.TypeOf(StatusCodesRangeBasedTrigger_ARM{}), generators)

	return statusCodesRangeBasedTrigger_ARMGenerator
}

// AddIndependentPropertyGeneratorsForStatusCodesRangeBasedTrigger_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStatusCodesRangeBasedTrigger_ARM(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["StatusCodes"] = gen.PtrOf(gen.AlphaString())
	gens["TimeInterval"] = gen.PtrOf(gen.AlphaString())
}
