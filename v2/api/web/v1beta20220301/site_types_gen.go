// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20220301

import (
	"fmt"
	v20220301s "github.com/Azure/azure-service-operator/v2/api/web/v1beta20220301storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/pkg/errors"
	"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	kerrors "k8s.io/apimachinery/pkg/util/errors"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generated from: https://schema.management.azure.com/schemas/2022-03-01/Microsoft.Web.json#/resourceDefinitions/sites
type Site struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              Sites_Spec  `json:"spec,omitempty"`
	Status            Site_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &Site{}

// GetConditions returns the conditions of the resource
func (site *Site) GetConditions() conditions.Conditions {
	return site.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (site *Site) SetConditions(conditions conditions.Conditions) {
	site.Status.Conditions = conditions
}

var _ conversion.Convertible = &Site{}

// ConvertFrom populates our Site from the provided hub Site
func (site *Site) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*v20220301s.Site)
	if !ok {
		return fmt.Errorf("expected web/v1beta20220301storage/Site but received %T instead", hub)
	}

	return site.AssignPropertiesFromSite(source)
}

// ConvertTo populates the provided hub Site from our Site
func (site *Site) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*v20220301s.Site)
	if !ok {
		return fmt.Errorf("expected web/v1beta20220301storage/Site but received %T instead", hub)
	}

	return site.AssignPropertiesToSite(destination)
}

// +kubebuilder:webhook:path=/mutate-web-azure-com-v1beta20220301-site,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=web.azure.com,resources=sites,verbs=create;update,versions=v1beta20220301,name=default.v1beta20220301.sites.web.azure.com,admissionReviewVersions=v1

var _ admission.Defaulter = &Site{}

// Default applies defaults to the Site resource
func (site *Site) Default() {
	site.defaultImpl()
	var temp interface{} = site
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (site *Site) defaultAzureName() {
	if site.Spec.AzureName == "" {
		site.Spec.AzureName = site.Name
	}
}

// defaultImpl applies the code generated defaults to the Site resource
func (site *Site) defaultImpl() { site.defaultAzureName() }

var _ genruntime.KubernetesResource = &Site{}

// AzureName returns the Azure name of the resource
func (site *Site) AzureName() string {
	return site.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2022-03-01"
func (site Site) GetAPIVersion() string {
	return string(APIVersion_Value)
}

// GetResourceScope returns the scope of the resource
func (site *Site) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (site *Site) GetSpec() genruntime.ConvertibleSpec {
	return &site.Spec
}

// GetStatus returns the status of this resource
func (site *Site) GetStatus() genruntime.ConvertibleStatus {
	return &site.Status
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Web/sites"
func (site *Site) GetType() string {
	return "Microsoft.Web/sites"
}

// NewEmptyStatus returns a new empty (blank) status
func (site *Site) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &Site_STATUS{}
}

// Owner returns the ResourceReference of the owner, or nil if there is no owner
func (site *Site) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(site.Spec)
	return &genruntime.ResourceReference{
		Group: group,
		Kind:  kind,
		Name:  site.Spec.Owner.Name,
	}
}

// SetStatus sets the status of this resource
func (site *Site) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*Site_STATUS); ok {
		site.Status = *st
		return nil
	}

	// Convert status to required version
	var st Site_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	site.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-web-azure-com-v1beta20220301-site,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=web.azure.com,resources=sites,verbs=create;update,versions=v1beta20220301,name=validate.v1beta20220301.sites.web.azure.com,admissionReviewVersions=v1

var _ admission.Validator = &Site{}

// ValidateCreate validates the creation of the resource
func (site *Site) ValidateCreate() error {
	validations := site.createValidations()
	var temp interface{} = site
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateDelete validates the deletion of the resource
func (site *Site) ValidateDelete() error {
	validations := site.deleteValidations()
	var temp interface{} = site
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateUpdate validates an update of the resource
func (site *Site) ValidateUpdate(old runtime.Object) error {
	validations := site.updateValidations()
	var temp interface{} = site
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation(old)
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// createValidations validates the creation of the resource
func (site *Site) createValidations() []func() error {
	return []func() error{site.validateResourceReferences}
}

// deleteValidations validates the deletion of the resource
func (site *Site) deleteValidations() []func() error {
	return nil
}

// updateValidations validates the update of the resource
func (site *Site) updateValidations() []func(old runtime.Object) error {
	return []func(old runtime.Object) error{
		func(old runtime.Object) error {
			return site.validateResourceReferences()
		},
		site.validateWriteOnceProperties}
}

// validateResourceReferences validates all resource references
func (site *Site) validateResourceReferences() error {
	refs, err := reflecthelpers.FindResourceReferences(&site.Spec)
	if err != nil {
		return err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// validateWriteOnceProperties validates all WriteOnce properties
func (site *Site) validateWriteOnceProperties(old runtime.Object) error {
	oldObj, ok := old.(*Site)
	if !ok {
		return nil
	}

	return genruntime.ValidateWriteOnceProperties(oldObj, site)
}

// AssignPropertiesFromSite populates our Site from the provided source Site
func (site *Site) AssignPropertiesFromSite(source *v20220301s.Site) error {

	// ObjectMeta
	site.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec Sites_Spec
	err := spec.AssignPropertiesFromSitesSpec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesFromSitesSpec() to populate field Spec")
	}
	site.Spec = spec

	// Status
	var status Site_STATUS
	err = status.AssignPropertiesFromSiteSTATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesFromSiteSTATUS() to populate field Status")
	}
	site.Status = status

	// No error
	return nil
}

// AssignPropertiesToSite populates the provided destination Site from our Site
func (site *Site) AssignPropertiesToSite(destination *v20220301s.Site) error {

	// ObjectMeta
	destination.ObjectMeta = *site.ObjectMeta.DeepCopy()

	// Spec
	var spec v20220301s.Sites_Spec
	err := site.Spec.AssignPropertiesToSitesSpec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesToSitesSpec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status v20220301s.Site_STATUS
	err = site.Status.AssignPropertiesToSiteSTATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesToSiteSTATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (site *Site) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: site.Spec.OriginalVersion(),
		Kind:    "Site",
	}
}

// +kubebuilder:object:root=true
// Generated from: https://schema.management.azure.com/schemas/2022-03-01/Microsoft.Web.json#/resourceDefinitions/sites
type SiteList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Site `json:"items"`
}

type Site_STATUS struct {
	// AvailabilityState: Management information availability state for the app.
	AvailabilityState *SiteSTATUSPropertiesAvailabilityState `json:"availabilityState,omitempty"`

	// ClientAffinityEnabled: <code>true</code> to enable client affinity; <code>false</code> to stop sending session affinity
	// cookies, which route client requests in the same session to the same instance. Default is <code>true</code>.
	ClientAffinityEnabled *bool `json:"clientAffinityEnabled,omitempty"`

	// ClientCertEnabled: <code>true</code> to enable client certificate authentication (TLS mutual authentication); otherwise,
	// <code>false</code>. Default is <code>false</code>.
	ClientCertEnabled *bool `json:"clientCertEnabled,omitempty"`

	// ClientCertExclusionPaths: client certificate authentication comma-separated exclusion paths
	ClientCertExclusionPaths *string `json:"clientCertExclusionPaths,omitempty"`

	// ClientCertMode: This composes with ClientCertEnabled setting.
	// - ClientCertEnabled: false means ClientCert is ignored.
	// - ClientCertEnabled: true and ClientCertMode: Required means ClientCert is required.
	// - ClientCertEnabled: true and ClientCertMode: Optional means ClientCert is optional or accepted.
	ClientCertMode *SiteSTATUSPropertiesClientCertMode `json:"clientCertMode,omitempty"`

	// CloningInfo: If specified during app creation, the app is cloned from a source app.
	CloningInfo *CloningInfo_STATUS `json:"cloningInfo,omitempty"`

	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// ContainerSize: Size of the function container.
	ContainerSize *int `json:"containerSize,omitempty"`

	// CustomDomainVerificationId: Unique identifier that verifies the custom domains assigned to the app. Customer will add
	// this id to a txt record for verification.
	CustomDomainVerificationId *string `json:"customDomainVerificationId,omitempty"`

	// DailyMemoryTimeQuota: Maximum allowed daily memory-time quota (applicable on dynamic apps only).
	DailyMemoryTimeQuota *int `json:"dailyMemoryTimeQuota,omitempty"`

	// DefaultHostName: Default hostname of the app. Read-only.
	DefaultHostName *string `json:"defaultHostName,omitempty"`

	// Enabled: <code>true</code> if the app is enabled; otherwise, <code>false</code>. Setting this value to false disables
	// the app (takes the app offline).
	Enabled *bool `json:"enabled,omitempty"`

	// EnabledHostNames: Enabled hostnames for the app.Hostnames need to be assigned (see HostNames) AND enabled. Otherwise,
	// the app is not served on those hostnames.
	EnabledHostNames []string                 `json:"enabledHostNames,omitempty"`
	ExtendedLocation *ExtendedLocation_STATUS `json:"extendedLocation,omitempty"`

	// HostNameSslStates: Hostname SSL states are used to manage the SSL bindings for app's hostnames.
	HostNameSslStates []HostNameSslState_STATUS `json:"hostNameSslStates,omitempty"`

	// HostNames: Hostnames associated with the app.
	HostNames []string `json:"hostNames,omitempty"`

	// HostNamesDisabled: <code>true</code> to disable the public hostnames of the app; otherwise, <code>false</code>.
	// If <code>true</code>, the app is only accessible via API management process.
	HostNamesDisabled *bool `json:"hostNamesDisabled,omitempty"`

	// HostingEnvironmentProfile: App Service Environment to use for the app.
	HostingEnvironmentProfile *HostingEnvironmentProfile_STATUS `json:"hostingEnvironmentProfile,omitempty"`

	// HttpsOnly: HttpsOnly: configures a web site to accept only https requests. Issues redirect for
	// http requests
	HttpsOnly *bool `json:"httpsOnly,omitempty"`

	// HyperV: Hyper-V sandbox.
	HyperV *bool `json:"hyperV,omitempty"`

	// Id: Resource Id.
	Id       *string                        `json:"id,omitempty"`
	Identity *ManagedServiceIdentity_STATUS `json:"identity,omitempty"`

	// InProgressOperationId: Specifies an operation id if this site has a pending operation.
	InProgressOperationId *string `json:"inProgressOperationId,omitempty"`

	// IsDefaultContainer: <code>true</code> if the app is a default container; otherwise, <code>false</code>.
	IsDefaultContainer *bool `json:"isDefaultContainer,omitempty"`

	// IsXenon: Obsolete: Hyper-V sandbox.
	IsXenon *bool `json:"isXenon,omitempty"`

	// KeyVaultReferenceIdentity: Identity to use for Key Vault Reference authentication.
	KeyVaultReferenceIdentity *string `json:"keyVaultReferenceIdentity,omitempty"`

	// Kind: Kind of resource.
	Kind *string `json:"kind,omitempty"`

	// LastModifiedTimeUtc: Last time the app was modified, in UTC. Read-only.
	LastModifiedTimeUtc *string `json:"lastModifiedTimeUtc,omitempty"`

	// Location: Resource Location.
	Location *string `json:"location,omitempty"`

	// MaxNumberOfWorkers: Maximum number of workers.
	// This only applies to Functions container.
	MaxNumberOfWorkers *int `json:"maxNumberOfWorkers,omitempty"`

	// Name: Resource Name.
	Name *string `json:"name,omitempty"`

	// OutboundIpAddresses: List of IP addresses that the app uses for outbound connections (e.g. database access). Includes
	// VIPs from tenants that site can be hosted with current settings. Read-only.
	OutboundIpAddresses *string `json:"outboundIpAddresses,omitempty"`

	// PossibleOutboundIpAddresses: List of IP addresses that the app uses for outbound connections (e.g. database access).
	// Includes VIPs from all tenants except dataComponent. Read-only.
	PossibleOutboundIpAddresses *string `json:"possibleOutboundIpAddresses,omitempty"`

	// PublicNetworkAccess: Property to allow or block all public traffic. Allowed Values: 'Enabled', 'Disabled' or an empty
	// string.
	PublicNetworkAccess *string `json:"publicNetworkAccess,omitempty"`

	// RedundancyMode: Site redundancy mode
	RedundancyMode *SiteSTATUSPropertiesRedundancyMode `json:"redundancyMode,omitempty"`

	// RepositorySiteName: Name of the repository site.
	RepositorySiteName *string `json:"repositorySiteName,omitempty"`

	// Reserved: <code>true</code> if reserved; otherwise, <code>false</code>.
	Reserved *bool `json:"reserved,omitempty"`

	// ResourceGroup: Name of the resource group the app belongs to. Read-only.
	ResourceGroup *string `json:"resourceGroup,omitempty"`

	// ScmSiteAlsoStopped: <code>true</code> to stop SCM (KUDU) site when the app is stopped; otherwise, <code>false</code>.
	// The default is <code>false</code>.
	ScmSiteAlsoStopped *bool `json:"scmSiteAlsoStopped,omitempty"`

	// ServerFarmId: Resource ID of the associated App Service plan, formatted as:
	// "/subscriptions/{subscriptionID}/resourceGroups/{groupName}/providers/Microsoft.Web/serverfarms/{appServicePlanName}".
	ServerFarmId *string `json:"serverFarmId,omitempty"`

	// SiteConfig: Configuration of the app.
	SiteConfig *SiteConfig_STATUS `json:"siteConfig,omitempty"`

	// SlotSwapStatus: Status of the last deployment slot swap operation.
	SlotSwapStatus *SlotSwapStatus_STATUS `json:"slotSwapStatus,omitempty"`

	// State: Current state of the app.
	State *string `json:"state,omitempty"`

	// StorageAccountRequired: Checks if Customer provided storage account is required
	StorageAccountRequired *bool `json:"storageAccountRequired,omitempty"`

	// SuspendedTill: App suspended till in case memory-time quota is exceeded.
	SuspendedTill *string `json:"suspendedTill,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// TargetSwapSlot: Specifies which deployment slot this app will swap into. Read-only.
	TargetSwapSlot *string `json:"targetSwapSlot,omitempty"`

	// TrafficManagerHostNames: Azure Traffic Manager hostnames associated with the app. Read-only.
	TrafficManagerHostNames []string `json:"trafficManagerHostNames,omitempty"`

	// Type: Resource type.
	Type *string `json:"type,omitempty"`

	// UsageState: State indicating whether the app has exceeded its quota usage. Read-only.
	UsageState *SiteSTATUSPropertiesUsageState `json:"usageState,omitempty"`

	// VirtualNetworkSubnetId: Azure Resource Manager ID of the Virtual network and subnet to be joined by Regional VNET
	// Integration.
	// This must be of the form
	// /subscriptions/{subscriptionName}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{vnetName}/subnets/{subnetName}
	VirtualNetworkSubnetId *string `json:"virtualNetworkSubnetId,omitempty"`

	// VnetContentShareEnabled: To enable accessing content over virtual network
	VnetContentShareEnabled *bool `json:"vnetContentShareEnabled,omitempty"`

	// VnetImagePullEnabled: To enable pulling image over Virtual Network
	VnetImagePullEnabled *bool `json:"vnetImagePullEnabled,omitempty"`

	// VnetRouteAllEnabled: Virtual Network Route All enabled. This causes all outbound traffic to have Virtual Network
	// Security Groups and User Defined Routes applied.
	VnetRouteAllEnabled *bool `json:"vnetRouteAllEnabled,omitempty"`
}

var _ genruntime.ConvertibleStatus = &Site_STATUS{}

// ConvertStatusFrom populates our Site_STATUS from the provided source
func (site *Site_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v20220301s.Site_STATUS)
	if ok {
		// Populate our instance from source
		return site.AssignPropertiesFromSiteSTATUS(src)
	}

	// Convert to an intermediate form
	src = &v20220301s.Site_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = site.AssignPropertiesFromSiteSTATUS(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our Site_STATUS
func (site *Site_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v20220301s.Site_STATUS)
	if ok {
		// Populate destination from our instance
		return site.AssignPropertiesToSiteSTATUS(dst)
	}

	// Convert to an intermediate form
	dst = &v20220301s.Site_STATUS{}
	err := site.AssignPropertiesToSiteSTATUS(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &Site_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (site *Site_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Site_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (site *Site_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Site_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Site_STATUSARM, got %T", armInput)
	}

	// Set property ‘AvailabilityState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AvailabilityState != nil {
			availabilityState := *typedInput.Properties.AvailabilityState
			site.AvailabilityState = &availabilityState
		}
	}

	// Set property ‘ClientAffinityEnabled’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ClientAffinityEnabled != nil {
			clientAffinityEnabled := *typedInput.Properties.ClientAffinityEnabled
			site.ClientAffinityEnabled = &clientAffinityEnabled
		}
	}

	// Set property ‘ClientCertEnabled’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ClientCertEnabled != nil {
			clientCertEnabled := *typedInput.Properties.ClientCertEnabled
			site.ClientCertEnabled = &clientCertEnabled
		}
	}

	// Set property ‘ClientCertExclusionPaths’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ClientCertExclusionPaths != nil {
			clientCertExclusionPaths := *typedInput.Properties.ClientCertExclusionPaths
			site.ClientCertExclusionPaths = &clientCertExclusionPaths
		}
	}

	// Set property ‘ClientCertMode’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ClientCertMode != nil {
			clientCertMode := *typedInput.Properties.ClientCertMode
			site.ClientCertMode = &clientCertMode
		}
	}

	// Set property ‘CloningInfo’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CloningInfo != nil {
			var cloningInfo1 CloningInfo_STATUS
			err := cloningInfo1.PopulateFromARM(owner, *typedInput.Properties.CloningInfo)
			if err != nil {
				return err
			}
			cloningInfo := cloningInfo1
			site.CloningInfo = &cloningInfo
		}
	}

	// no assignment for property ‘Conditions’

	// Set property ‘ContainerSize’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ContainerSize != nil {
			containerSize := *typedInput.Properties.ContainerSize
			site.ContainerSize = &containerSize
		}
	}

	// Set property ‘CustomDomainVerificationId’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CustomDomainVerificationId != nil {
			customDomainVerificationId := *typedInput.Properties.CustomDomainVerificationId
			site.CustomDomainVerificationId = &customDomainVerificationId
		}
	}

	// Set property ‘DailyMemoryTimeQuota’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DailyMemoryTimeQuota != nil {
			dailyMemoryTimeQuota := *typedInput.Properties.DailyMemoryTimeQuota
			site.DailyMemoryTimeQuota = &dailyMemoryTimeQuota
		}
	}

	// Set property ‘DefaultHostName’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DefaultHostName != nil {
			defaultHostName := *typedInput.Properties.DefaultHostName
			site.DefaultHostName = &defaultHostName
		}
	}

	// Set property ‘Enabled’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Enabled != nil {
			enabled := *typedInput.Properties.Enabled
			site.Enabled = &enabled
		}
	}

	// Set property ‘EnabledHostNames’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.EnabledHostNames {
			site.EnabledHostNames = append(site.EnabledHostNames, item)
		}
	}

	// Set property ‘ExtendedLocation’:
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation_STATUS
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		site.ExtendedLocation = &extendedLocation
	}

	// Set property ‘HostNameSslStates’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.HostNameSslStates {
			var item1 HostNameSslState_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			site.HostNameSslStates = append(site.HostNameSslStates, item1)
		}
	}

	// Set property ‘HostNames’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.HostNames {
			site.HostNames = append(site.HostNames, item)
		}
	}

	// Set property ‘HostNamesDisabled’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HostNamesDisabled != nil {
			hostNamesDisabled := *typedInput.Properties.HostNamesDisabled
			site.HostNamesDisabled = &hostNamesDisabled
		}
	}

	// Set property ‘HostingEnvironmentProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HostingEnvironmentProfile != nil {
			var hostingEnvironmentProfile1 HostingEnvironmentProfile_STATUS
			err := hostingEnvironmentProfile1.PopulateFromARM(owner, *typedInput.Properties.HostingEnvironmentProfile)
			if err != nil {
				return err
			}
			hostingEnvironmentProfile := hostingEnvironmentProfile1
			site.HostingEnvironmentProfile = &hostingEnvironmentProfile
		}
	}

	// Set property ‘HttpsOnly’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HttpsOnly != nil {
			httpsOnly := *typedInput.Properties.HttpsOnly
			site.HttpsOnly = &httpsOnly
		}
	}

	// Set property ‘HyperV’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HyperV != nil {
			hyperV := *typedInput.Properties.HyperV
			site.HyperV = &hyperV
		}
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		site.Id = &id
	}

	// Set property ‘Identity’:
	if typedInput.Identity != nil {
		var identity1 ManagedServiceIdentity_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		site.Identity = &identity
	}

	// Set property ‘InProgressOperationId’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.InProgressOperationId != nil {
			inProgressOperationId := *typedInput.Properties.InProgressOperationId
			site.InProgressOperationId = &inProgressOperationId
		}
	}

	// Set property ‘IsDefaultContainer’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IsDefaultContainer != nil {
			isDefaultContainer := *typedInput.Properties.IsDefaultContainer
			site.IsDefaultContainer = &isDefaultContainer
		}
	}

	// Set property ‘IsXenon’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IsXenon != nil {
			isXenon := *typedInput.Properties.IsXenon
			site.IsXenon = &isXenon
		}
	}

	// Set property ‘KeyVaultReferenceIdentity’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.KeyVaultReferenceIdentity != nil {
			keyVaultReferenceIdentity := *typedInput.Properties.KeyVaultReferenceIdentity
			site.KeyVaultReferenceIdentity = &keyVaultReferenceIdentity
		}
	}

	// Set property ‘Kind’:
	if typedInput.Kind != nil {
		kind := *typedInput.Kind
		site.Kind = &kind
	}

	// Set property ‘LastModifiedTimeUtc’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LastModifiedTimeUtc != nil {
			lastModifiedTimeUtc := *typedInput.Properties.LastModifiedTimeUtc
			site.LastModifiedTimeUtc = &lastModifiedTimeUtc
		}
	}

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		site.Location = &location
	}

	// Set property ‘MaxNumberOfWorkers’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MaxNumberOfWorkers != nil {
			maxNumberOfWorkers := *typedInput.Properties.MaxNumberOfWorkers
			site.MaxNumberOfWorkers = &maxNumberOfWorkers
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		site.Name = &name
	}

	// Set property ‘OutboundIpAddresses’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.OutboundIpAddresses != nil {
			outboundIpAddresses := *typedInput.Properties.OutboundIpAddresses
			site.OutboundIpAddresses = &outboundIpAddresses
		}
	}

	// Set property ‘PossibleOutboundIpAddresses’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PossibleOutboundIpAddresses != nil {
			possibleOutboundIpAddresses := *typedInput.Properties.PossibleOutboundIpAddresses
			site.PossibleOutboundIpAddresses = &possibleOutboundIpAddresses
		}
	}

	// Set property ‘PublicNetworkAccess’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicNetworkAccess != nil {
			publicNetworkAccess := *typedInput.Properties.PublicNetworkAccess
			site.PublicNetworkAccess = &publicNetworkAccess
		}
	}

	// Set property ‘RedundancyMode’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RedundancyMode != nil {
			redundancyMode := *typedInput.Properties.RedundancyMode
			site.RedundancyMode = &redundancyMode
		}
	}

	// Set property ‘RepositorySiteName’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RepositorySiteName != nil {
			repositorySiteName := *typedInput.Properties.RepositorySiteName
			site.RepositorySiteName = &repositorySiteName
		}
	}

	// Set property ‘Reserved’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Reserved != nil {
			reserved := *typedInput.Properties.Reserved
			site.Reserved = &reserved
		}
	}

	// Set property ‘ResourceGroup’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ResourceGroup != nil {
			resourceGroup := *typedInput.Properties.ResourceGroup
			site.ResourceGroup = &resourceGroup
		}
	}

	// Set property ‘ScmSiteAlsoStopped’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ScmSiteAlsoStopped != nil {
			scmSiteAlsoStopped := *typedInput.Properties.ScmSiteAlsoStopped
			site.ScmSiteAlsoStopped = &scmSiteAlsoStopped
		}
	}

	// Set property ‘ServerFarmId’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ServerFarmId != nil {
			serverFarmId := *typedInput.Properties.ServerFarmId
			site.ServerFarmId = &serverFarmId
		}
	}

	// Set property ‘SiteConfig’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SiteConfig != nil {
			var siteConfig1 SiteConfig_STATUS
			err := siteConfig1.PopulateFromARM(owner, *typedInput.Properties.SiteConfig)
			if err != nil {
				return err
			}
			siteConfig := siteConfig1
			site.SiteConfig = &siteConfig
		}
	}

	// Set property ‘SlotSwapStatus’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SlotSwapStatus != nil {
			var slotSwapStatus1 SlotSwapStatus_STATUS
			err := slotSwapStatus1.PopulateFromARM(owner, *typedInput.Properties.SlotSwapStatus)
			if err != nil {
				return err
			}
			slotSwapStatus := slotSwapStatus1
			site.SlotSwapStatus = &slotSwapStatus
		}
	}

	// Set property ‘State’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.State != nil {
			state := *typedInput.Properties.State
			site.State = &state
		}
	}

	// Set property ‘StorageAccountRequired’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.StorageAccountRequired != nil {
			storageAccountRequired := *typedInput.Properties.StorageAccountRequired
			site.StorageAccountRequired = &storageAccountRequired
		}
	}

	// Set property ‘SuspendedTill’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SuspendedTill != nil {
			suspendedTill := *typedInput.Properties.SuspendedTill
			site.SuspendedTill = &suspendedTill
		}
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		site.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			site.Tags[key] = value
		}
	}

	// Set property ‘TargetSwapSlot’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TargetSwapSlot != nil {
			targetSwapSlot := *typedInput.Properties.TargetSwapSlot
			site.TargetSwapSlot = &targetSwapSlot
		}
	}

	// Set property ‘TrafficManagerHostNames’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.TrafficManagerHostNames {
			site.TrafficManagerHostNames = append(site.TrafficManagerHostNames, item)
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		site.Type = &typeVar
	}

	// Set property ‘UsageState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.UsageState != nil {
			usageState := *typedInput.Properties.UsageState
			site.UsageState = &usageState
		}
	}

	// Set property ‘VirtualNetworkSubnetId’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VirtualNetworkSubnetId != nil {
			virtualNetworkSubnetId := *typedInput.Properties.VirtualNetworkSubnetId
			site.VirtualNetworkSubnetId = &virtualNetworkSubnetId
		}
	}

	// Set property ‘VnetContentShareEnabled’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VnetContentShareEnabled != nil {
			vnetContentShareEnabled := *typedInput.Properties.VnetContentShareEnabled
			site.VnetContentShareEnabled = &vnetContentShareEnabled
		}
	}

	// Set property ‘VnetImagePullEnabled’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VnetImagePullEnabled != nil {
			vnetImagePullEnabled := *typedInput.Properties.VnetImagePullEnabled
			site.VnetImagePullEnabled = &vnetImagePullEnabled
		}
	}

	// Set property ‘VnetRouteAllEnabled’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VnetRouteAllEnabled != nil {
			vnetRouteAllEnabled := *typedInput.Properties.VnetRouteAllEnabled
			site.VnetRouteAllEnabled = &vnetRouteAllEnabled
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromSiteSTATUS populates our Site_STATUS from the provided source Site_STATUS
func (site *Site_STATUS) AssignPropertiesFromSiteSTATUS(source *v20220301s.Site_STATUS) error {

	// AvailabilityState
	if source.AvailabilityState != nil {
		availabilityState := SiteSTATUSPropertiesAvailabilityState(*source.AvailabilityState)
		site.AvailabilityState = &availabilityState
	} else {
		site.AvailabilityState = nil
	}

	// ClientAffinityEnabled
	if source.ClientAffinityEnabled != nil {
		clientAffinityEnabled := *source.ClientAffinityEnabled
		site.ClientAffinityEnabled = &clientAffinityEnabled
	} else {
		site.ClientAffinityEnabled = nil
	}

	// ClientCertEnabled
	if source.ClientCertEnabled != nil {
		clientCertEnabled := *source.ClientCertEnabled
		site.ClientCertEnabled = &clientCertEnabled
	} else {
		site.ClientCertEnabled = nil
	}

	// ClientCertExclusionPaths
	site.ClientCertExclusionPaths = genruntime.ClonePointerToString(source.ClientCertExclusionPaths)

	// ClientCertMode
	if source.ClientCertMode != nil {
		clientCertMode := SiteSTATUSPropertiesClientCertMode(*source.ClientCertMode)
		site.ClientCertMode = &clientCertMode
	} else {
		site.ClientCertMode = nil
	}

	// CloningInfo
	if source.CloningInfo != nil {
		var cloningInfo CloningInfo_STATUS
		err := cloningInfo.AssignPropertiesFromCloningInfoSTATUS(source.CloningInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromCloningInfoSTATUS() to populate field CloningInfo")
		}
		site.CloningInfo = &cloningInfo
	} else {
		site.CloningInfo = nil
	}

	// Conditions
	site.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// ContainerSize
	site.ContainerSize = genruntime.ClonePointerToInt(source.ContainerSize)

	// CustomDomainVerificationId
	site.CustomDomainVerificationId = genruntime.ClonePointerToString(source.CustomDomainVerificationId)

	// DailyMemoryTimeQuota
	site.DailyMemoryTimeQuota = genruntime.ClonePointerToInt(source.DailyMemoryTimeQuota)

	// DefaultHostName
	site.DefaultHostName = genruntime.ClonePointerToString(source.DefaultHostName)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		site.Enabled = &enabled
	} else {
		site.Enabled = nil
	}

	// EnabledHostNames
	site.EnabledHostNames = genruntime.CloneSliceOfString(source.EnabledHostNames)

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation_STATUS
		err := extendedLocation.AssignPropertiesFromExtendedLocationSTATUS(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromExtendedLocationSTATUS() to populate field ExtendedLocation")
		}
		site.ExtendedLocation = &extendedLocation
	} else {
		site.ExtendedLocation = nil
	}

	// HostNameSslStates
	if source.HostNameSslStates != nil {
		hostNameSslStateList := make([]HostNameSslState_STATUS, len(source.HostNameSslStates))
		for hostNameSslStateIndex, hostNameSslStateItem := range source.HostNameSslStates {
			// Shadow the loop variable to avoid aliasing
			hostNameSslStateItem := hostNameSslStateItem
			var hostNameSslState HostNameSslState_STATUS
			err := hostNameSslState.AssignPropertiesFromHostNameSslStateSTATUS(&hostNameSslStateItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromHostNameSslStateSTATUS() to populate field HostNameSslStates")
			}
			hostNameSslStateList[hostNameSslStateIndex] = hostNameSslState
		}
		site.HostNameSslStates = hostNameSslStateList
	} else {
		site.HostNameSslStates = nil
	}

	// HostNames
	site.HostNames = genruntime.CloneSliceOfString(source.HostNames)

	// HostNamesDisabled
	if source.HostNamesDisabled != nil {
		hostNamesDisabled := *source.HostNamesDisabled
		site.HostNamesDisabled = &hostNamesDisabled
	} else {
		site.HostNamesDisabled = nil
	}

	// HostingEnvironmentProfile
	if source.HostingEnvironmentProfile != nil {
		var hostingEnvironmentProfile HostingEnvironmentProfile_STATUS
		err := hostingEnvironmentProfile.AssignPropertiesFromHostingEnvironmentProfileSTATUS(source.HostingEnvironmentProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromHostingEnvironmentProfileSTATUS() to populate field HostingEnvironmentProfile")
		}
		site.HostingEnvironmentProfile = &hostingEnvironmentProfile
	} else {
		site.HostingEnvironmentProfile = nil
	}

	// HttpsOnly
	if source.HttpsOnly != nil {
		httpsOnly := *source.HttpsOnly
		site.HttpsOnly = &httpsOnly
	} else {
		site.HttpsOnly = nil
	}

	// HyperV
	if source.HyperV != nil {
		hyperV := *source.HyperV
		site.HyperV = &hyperV
	} else {
		site.HyperV = nil
	}

	// Id
	site.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity ManagedServiceIdentity_STATUS
		err := identity.AssignPropertiesFromManagedServiceIdentitySTATUS(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedServiceIdentitySTATUS() to populate field Identity")
		}
		site.Identity = &identity
	} else {
		site.Identity = nil
	}

	// InProgressOperationId
	site.InProgressOperationId = genruntime.ClonePointerToString(source.InProgressOperationId)

	// IsDefaultContainer
	if source.IsDefaultContainer != nil {
		isDefaultContainer := *source.IsDefaultContainer
		site.IsDefaultContainer = &isDefaultContainer
	} else {
		site.IsDefaultContainer = nil
	}

	// IsXenon
	if source.IsXenon != nil {
		isXenon := *source.IsXenon
		site.IsXenon = &isXenon
	} else {
		site.IsXenon = nil
	}

	// KeyVaultReferenceIdentity
	site.KeyVaultReferenceIdentity = genruntime.ClonePointerToString(source.KeyVaultReferenceIdentity)

	// Kind
	site.Kind = genruntime.ClonePointerToString(source.Kind)

	// LastModifiedTimeUtc
	site.LastModifiedTimeUtc = genruntime.ClonePointerToString(source.LastModifiedTimeUtc)

	// Location
	site.Location = genruntime.ClonePointerToString(source.Location)

	// MaxNumberOfWorkers
	site.MaxNumberOfWorkers = genruntime.ClonePointerToInt(source.MaxNumberOfWorkers)

	// Name
	site.Name = genruntime.ClonePointerToString(source.Name)

	// OutboundIpAddresses
	site.OutboundIpAddresses = genruntime.ClonePointerToString(source.OutboundIpAddresses)

	// PossibleOutboundIpAddresses
	site.PossibleOutboundIpAddresses = genruntime.ClonePointerToString(source.PossibleOutboundIpAddresses)

	// PublicNetworkAccess
	site.PublicNetworkAccess = genruntime.ClonePointerToString(source.PublicNetworkAccess)

	// RedundancyMode
	if source.RedundancyMode != nil {
		redundancyMode := SiteSTATUSPropertiesRedundancyMode(*source.RedundancyMode)
		site.RedundancyMode = &redundancyMode
	} else {
		site.RedundancyMode = nil
	}

	// RepositorySiteName
	site.RepositorySiteName = genruntime.ClonePointerToString(source.RepositorySiteName)

	// Reserved
	if source.Reserved != nil {
		reserved := *source.Reserved
		site.Reserved = &reserved
	} else {
		site.Reserved = nil
	}

	// ResourceGroup
	site.ResourceGroup = genruntime.ClonePointerToString(source.ResourceGroup)

	// ScmSiteAlsoStopped
	if source.ScmSiteAlsoStopped != nil {
		scmSiteAlsoStopped := *source.ScmSiteAlsoStopped
		site.ScmSiteAlsoStopped = &scmSiteAlsoStopped
	} else {
		site.ScmSiteAlsoStopped = nil
	}

	// ServerFarmId
	site.ServerFarmId = genruntime.ClonePointerToString(source.ServerFarmId)

	// SiteConfig
	if source.SiteConfig != nil {
		var siteConfig SiteConfig_STATUS
		err := siteConfig.AssignPropertiesFromSiteConfigSTATUS(source.SiteConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSiteConfigSTATUS() to populate field SiteConfig")
		}
		site.SiteConfig = &siteConfig
	} else {
		site.SiteConfig = nil
	}

	// SlotSwapStatus
	if source.SlotSwapStatus != nil {
		var slotSwapStatus SlotSwapStatus_STATUS
		err := slotSwapStatus.AssignPropertiesFromSlotSwapStatusSTATUS(source.SlotSwapStatus)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSlotSwapStatusSTATUS() to populate field SlotSwapStatus")
		}
		site.SlotSwapStatus = &slotSwapStatus
	} else {
		site.SlotSwapStatus = nil
	}

	// State
	site.State = genruntime.ClonePointerToString(source.State)

	// StorageAccountRequired
	if source.StorageAccountRequired != nil {
		storageAccountRequired := *source.StorageAccountRequired
		site.StorageAccountRequired = &storageAccountRequired
	} else {
		site.StorageAccountRequired = nil
	}

	// SuspendedTill
	site.SuspendedTill = genruntime.ClonePointerToString(source.SuspendedTill)

	// Tags
	site.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// TargetSwapSlot
	site.TargetSwapSlot = genruntime.ClonePointerToString(source.TargetSwapSlot)

	// TrafficManagerHostNames
	site.TrafficManagerHostNames = genruntime.CloneSliceOfString(source.TrafficManagerHostNames)

	// Type
	site.Type = genruntime.ClonePointerToString(source.Type)

	// UsageState
	if source.UsageState != nil {
		usageState := SiteSTATUSPropertiesUsageState(*source.UsageState)
		site.UsageState = &usageState
	} else {
		site.UsageState = nil
	}

	// VirtualNetworkSubnetId
	site.VirtualNetworkSubnetId = genruntime.ClonePointerToString(source.VirtualNetworkSubnetId)

	// VnetContentShareEnabled
	if source.VnetContentShareEnabled != nil {
		vnetContentShareEnabled := *source.VnetContentShareEnabled
		site.VnetContentShareEnabled = &vnetContentShareEnabled
	} else {
		site.VnetContentShareEnabled = nil
	}

	// VnetImagePullEnabled
	if source.VnetImagePullEnabled != nil {
		vnetImagePullEnabled := *source.VnetImagePullEnabled
		site.VnetImagePullEnabled = &vnetImagePullEnabled
	} else {
		site.VnetImagePullEnabled = nil
	}

	// VnetRouteAllEnabled
	if source.VnetRouteAllEnabled != nil {
		vnetRouteAllEnabled := *source.VnetRouteAllEnabled
		site.VnetRouteAllEnabled = &vnetRouteAllEnabled
	} else {
		site.VnetRouteAllEnabled = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSiteSTATUS populates the provided destination Site_STATUS from our Site_STATUS
func (site *Site_STATUS) AssignPropertiesToSiteSTATUS(destination *v20220301s.Site_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AvailabilityState
	if site.AvailabilityState != nil {
		availabilityState := string(*site.AvailabilityState)
		destination.AvailabilityState = &availabilityState
	} else {
		destination.AvailabilityState = nil
	}

	// ClientAffinityEnabled
	if site.ClientAffinityEnabled != nil {
		clientAffinityEnabled := *site.ClientAffinityEnabled
		destination.ClientAffinityEnabled = &clientAffinityEnabled
	} else {
		destination.ClientAffinityEnabled = nil
	}

	// ClientCertEnabled
	if site.ClientCertEnabled != nil {
		clientCertEnabled := *site.ClientCertEnabled
		destination.ClientCertEnabled = &clientCertEnabled
	} else {
		destination.ClientCertEnabled = nil
	}

	// ClientCertExclusionPaths
	destination.ClientCertExclusionPaths = genruntime.ClonePointerToString(site.ClientCertExclusionPaths)

	// ClientCertMode
	if site.ClientCertMode != nil {
		clientCertMode := string(*site.ClientCertMode)
		destination.ClientCertMode = &clientCertMode
	} else {
		destination.ClientCertMode = nil
	}

	// CloningInfo
	if site.CloningInfo != nil {
		var cloningInfo v20220301s.CloningInfo_STATUS
		err := site.CloningInfo.AssignPropertiesToCloningInfoSTATUS(&cloningInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToCloningInfoSTATUS() to populate field CloningInfo")
		}
		destination.CloningInfo = &cloningInfo
	} else {
		destination.CloningInfo = nil
	}

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(site.Conditions)

	// ContainerSize
	destination.ContainerSize = genruntime.ClonePointerToInt(site.ContainerSize)

	// CustomDomainVerificationId
	destination.CustomDomainVerificationId = genruntime.ClonePointerToString(site.CustomDomainVerificationId)

	// DailyMemoryTimeQuota
	destination.DailyMemoryTimeQuota = genruntime.ClonePointerToInt(site.DailyMemoryTimeQuota)

	// DefaultHostName
	destination.DefaultHostName = genruntime.ClonePointerToString(site.DefaultHostName)

	// Enabled
	if site.Enabled != nil {
		enabled := *site.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// EnabledHostNames
	destination.EnabledHostNames = genruntime.CloneSliceOfString(site.EnabledHostNames)

	// ExtendedLocation
	if site.ExtendedLocation != nil {
		var extendedLocation v20220301s.ExtendedLocation_STATUS
		err := site.ExtendedLocation.AssignPropertiesToExtendedLocationSTATUS(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToExtendedLocationSTATUS() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// HostNameSslStates
	if site.HostNameSslStates != nil {
		hostNameSslStateList := make([]v20220301s.HostNameSslState_STATUS, len(site.HostNameSslStates))
		for hostNameSslStateIndex, hostNameSslStateItem := range site.HostNameSslStates {
			// Shadow the loop variable to avoid aliasing
			hostNameSslStateItem := hostNameSslStateItem
			var hostNameSslState v20220301s.HostNameSslState_STATUS
			err := hostNameSslStateItem.AssignPropertiesToHostNameSslStateSTATUS(&hostNameSslState)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToHostNameSslStateSTATUS() to populate field HostNameSslStates")
			}
			hostNameSslStateList[hostNameSslStateIndex] = hostNameSslState
		}
		destination.HostNameSslStates = hostNameSslStateList
	} else {
		destination.HostNameSslStates = nil
	}

	// HostNames
	destination.HostNames = genruntime.CloneSliceOfString(site.HostNames)

	// HostNamesDisabled
	if site.HostNamesDisabled != nil {
		hostNamesDisabled := *site.HostNamesDisabled
		destination.HostNamesDisabled = &hostNamesDisabled
	} else {
		destination.HostNamesDisabled = nil
	}

	// HostingEnvironmentProfile
	if site.HostingEnvironmentProfile != nil {
		var hostingEnvironmentProfile v20220301s.HostingEnvironmentProfile_STATUS
		err := site.HostingEnvironmentProfile.AssignPropertiesToHostingEnvironmentProfileSTATUS(&hostingEnvironmentProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToHostingEnvironmentProfileSTATUS() to populate field HostingEnvironmentProfile")
		}
		destination.HostingEnvironmentProfile = &hostingEnvironmentProfile
	} else {
		destination.HostingEnvironmentProfile = nil
	}

	// HttpsOnly
	if site.HttpsOnly != nil {
		httpsOnly := *site.HttpsOnly
		destination.HttpsOnly = &httpsOnly
	} else {
		destination.HttpsOnly = nil
	}

	// HyperV
	if site.HyperV != nil {
		hyperV := *site.HyperV
		destination.HyperV = &hyperV
	} else {
		destination.HyperV = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(site.Id)

	// Identity
	if site.Identity != nil {
		var identity v20220301s.ManagedServiceIdentity_STATUS
		err := site.Identity.AssignPropertiesToManagedServiceIdentitySTATUS(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedServiceIdentitySTATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// InProgressOperationId
	destination.InProgressOperationId = genruntime.ClonePointerToString(site.InProgressOperationId)

	// IsDefaultContainer
	if site.IsDefaultContainer != nil {
		isDefaultContainer := *site.IsDefaultContainer
		destination.IsDefaultContainer = &isDefaultContainer
	} else {
		destination.IsDefaultContainer = nil
	}

	// IsXenon
	if site.IsXenon != nil {
		isXenon := *site.IsXenon
		destination.IsXenon = &isXenon
	} else {
		destination.IsXenon = nil
	}

	// KeyVaultReferenceIdentity
	destination.KeyVaultReferenceIdentity = genruntime.ClonePointerToString(site.KeyVaultReferenceIdentity)

	// Kind
	destination.Kind = genruntime.ClonePointerToString(site.Kind)

	// LastModifiedTimeUtc
	destination.LastModifiedTimeUtc = genruntime.ClonePointerToString(site.LastModifiedTimeUtc)

	// Location
	destination.Location = genruntime.ClonePointerToString(site.Location)

	// MaxNumberOfWorkers
	destination.MaxNumberOfWorkers = genruntime.ClonePointerToInt(site.MaxNumberOfWorkers)

	// Name
	destination.Name = genruntime.ClonePointerToString(site.Name)

	// OutboundIpAddresses
	destination.OutboundIpAddresses = genruntime.ClonePointerToString(site.OutboundIpAddresses)

	// PossibleOutboundIpAddresses
	destination.PossibleOutboundIpAddresses = genruntime.ClonePointerToString(site.PossibleOutboundIpAddresses)

	// PublicNetworkAccess
	destination.PublicNetworkAccess = genruntime.ClonePointerToString(site.PublicNetworkAccess)

	// RedundancyMode
	if site.RedundancyMode != nil {
		redundancyMode := string(*site.RedundancyMode)
		destination.RedundancyMode = &redundancyMode
	} else {
		destination.RedundancyMode = nil
	}

	// RepositorySiteName
	destination.RepositorySiteName = genruntime.ClonePointerToString(site.RepositorySiteName)

	// Reserved
	if site.Reserved != nil {
		reserved := *site.Reserved
		destination.Reserved = &reserved
	} else {
		destination.Reserved = nil
	}

	// ResourceGroup
	destination.ResourceGroup = genruntime.ClonePointerToString(site.ResourceGroup)

	// ScmSiteAlsoStopped
	if site.ScmSiteAlsoStopped != nil {
		scmSiteAlsoStopped := *site.ScmSiteAlsoStopped
		destination.ScmSiteAlsoStopped = &scmSiteAlsoStopped
	} else {
		destination.ScmSiteAlsoStopped = nil
	}

	// ServerFarmId
	destination.ServerFarmId = genruntime.ClonePointerToString(site.ServerFarmId)

	// SiteConfig
	if site.SiteConfig != nil {
		var siteConfig v20220301s.SiteConfig_STATUS
		err := site.SiteConfig.AssignPropertiesToSiteConfigSTATUS(&siteConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSiteConfigSTATUS() to populate field SiteConfig")
		}
		destination.SiteConfig = &siteConfig
	} else {
		destination.SiteConfig = nil
	}

	// SlotSwapStatus
	if site.SlotSwapStatus != nil {
		var slotSwapStatus v20220301s.SlotSwapStatus_STATUS
		err := site.SlotSwapStatus.AssignPropertiesToSlotSwapStatusSTATUS(&slotSwapStatus)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSlotSwapStatusSTATUS() to populate field SlotSwapStatus")
		}
		destination.SlotSwapStatus = &slotSwapStatus
	} else {
		destination.SlotSwapStatus = nil
	}

	// State
	destination.State = genruntime.ClonePointerToString(site.State)

	// StorageAccountRequired
	if site.StorageAccountRequired != nil {
		storageAccountRequired := *site.StorageAccountRequired
		destination.StorageAccountRequired = &storageAccountRequired
	} else {
		destination.StorageAccountRequired = nil
	}

	// SuspendedTill
	destination.SuspendedTill = genruntime.ClonePointerToString(site.SuspendedTill)

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(site.Tags)

	// TargetSwapSlot
	destination.TargetSwapSlot = genruntime.ClonePointerToString(site.TargetSwapSlot)

	// TrafficManagerHostNames
	destination.TrafficManagerHostNames = genruntime.CloneSliceOfString(site.TrafficManagerHostNames)

	// Type
	destination.Type = genruntime.ClonePointerToString(site.Type)

	// UsageState
	if site.UsageState != nil {
		usageState := string(*site.UsageState)
		destination.UsageState = &usageState
	} else {
		destination.UsageState = nil
	}

	// VirtualNetworkSubnetId
	destination.VirtualNetworkSubnetId = genruntime.ClonePointerToString(site.VirtualNetworkSubnetId)

	// VnetContentShareEnabled
	if site.VnetContentShareEnabled != nil {
		vnetContentShareEnabled := *site.VnetContentShareEnabled
		destination.VnetContentShareEnabled = &vnetContentShareEnabled
	} else {
		destination.VnetContentShareEnabled = nil
	}

	// VnetImagePullEnabled
	if site.VnetImagePullEnabled != nil {
		vnetImagePullEnabled := *site.VnetImagePullEnabled
		destination.VnetImagePullEnabled = &vnetImagePullEnabled
	} else {
		destination.VnetImagePullEnabled = nil
	}

	// VnetRouteAllEnabled
	if site.VnetRouteAllEnabled != nil {
		vnetRouteAllEnabled := *site.VnetRouteAllEnabled
		destination.VnetRouteAllEnabled = &vnetRouteAllEnabled
	} else {
		destination.VnetRouteAllEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Sites_Spec struct {
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// ClientAffinityEnabled: <code>true</code> to enable client affinity; <code>false</code> to stop sending session affinity
	// cookies, which route client requests in the same session to the same instance. Default is <code>true</code>.
	ClientAffinityEnabled *bool `json:"clientAffinityEnabled,omitempty"`

	// ClientCertEnabled: <code>true</code> to enable client certificate authentication (TLS mutual authentication); otherwise,
	// <code>false</code>. Default is <code>false</code>.
	ClientCertEnabled *bool `json:"clientCertEnabled,omitempty"`

	// ClientCertExclusionPaths: client certificate authentication comma-separated exclusion paths
	ClientCertExclusionPaths *string `json:"clientCertExclusionPaths,omitempty"`

	// ClientCertMode: This composes with ClientCertEnabled setting.
	// - ClientCertEnabled: false means ClientCert is ignored.
	// - ClientCertEnabled: true and ClientCertMode: Required means ClientCert is required.
	// - ClientCertEnabled: true and ClientCertMode: Optional means ClientCert is optional or accepted.
	ClientCertMode *SitesSpecPropertiesClientCertMode `json:"clientCertMode,omitempty"`

	// CloningInfo: Information needed for cloning operation.
	CloningInfo *CloningInfo `json:"cloningInfo,omitempty"`

	// ContainerSize: Size of the function container.
	ContainerSize *int `json:"containerSize,omitempty"`

	// CustomDomainVerificationId: Unique identifier that verifies the custom domains assigned to the app. Customer will add
	// this id to a txt record for verification.
	CustomDomainVerificationId *string `json:"customDomainVerificationId,omitempty"`

	// DailyMemoryTimeQuota: Maximum allowed daily memory-time quota (applicable on dynamic apps only).
	DailyMemoryTimeQuota *int `json:"dailyMemoryTimeQuota,omitempty"`

	// Enabled: <code>true</code> if the app is enabled; otherwise, <code>false</code>. Setting this value to false disables
	// the app (takes the app offline).
	Enabled *bool `json:"enabled,omitempty"`

	// ExtendedLocation: Extended Location.
	ExtendedLocation *ExtendedLocation `json:"extendedLocation,omitempty"`

	// HostNameSslStates: Hostname SSL states are used to manage the SSL bindings for app's hostnames.
	HostNameSslStates []HostNameSslState `json:"hostNameSslStates,omitempty"`

	// HostNamesDisabled: <code>true</code> to disable the public hostnames of the app; otherwise, <code>false</code>.
	// If <code>true</code>, the app is only accessible via API management process.
	HostNamesDisabled *bool `json:"hostNamesDisabled,omitempty"`

	// HostingEnvironmentProfile: Specification for an App Service Environment to use for this resource.
	HostingEnvironmentProfile *HostingEnvironmentProfile `json:"hostingEnvironmentProfile,omitempty"`

	// HttpsOnly: HttpsOnly: configures a web site to accept only https requests. Issues redirect for
	// http requests
	HttpsOnly *bool `json:"httpsOnly,omitempty"`

	// HyperV: Hyper-V sandbox.
	HyperV *bool `json:"hyperV,omitempty"`

	// Identity: Managed service identity.
	Identity *ManagedServiceIdentity `json:"identity,omitempty"`

	// IsXenon: Obsolete: Hyper-V sandbox.
	IsXenon *bool `json:"isXenon,omitempty"`

	// KeyVaultReferenceIdentity: Identity to use for Key Vault Reference authentication.
	KeyVaultReferenceIdentity *string `json:"keyVaultReferenceIdentity,omitempty"`

	// Kind: Kind of resource.
	Kind *string `json:"kind,omitempty"`

	// Location: Location to deploy resource to
	Location *string `json:"location,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`

	// PublicNetworkAccess: Property to allow or block all public traffic. Allowed Values: 'Enabled', 'Disabled' or an empty
	// string.
	PublicNetworkAccess *string `json:"publicNetworkAccess,omitempty"`

	// RedundancyMode: Site redundancy mode.
	RedundancyMode *SitesSpecPropertiesRedundancyMode `json:"redundancyMode,omitempty"`

	// Reserved: <code>true</code> if reserved; otherwise, <code>false</code>.
	Reserved *bool `json:"reserved,omitempty"`

	// ScmSiteAlsoStopped: <code>true</code> to stop SCM (KUDU) site when the app is stopped; otherwise, <code>false</code>.
	// The default is <code>false</code>.
	ScmSiteAlsoStopped *bool `json:"scmSiteAlsoStopped,omitempty"`

	// ServerFarmReference: Resource ID of the associated App Service plan, formatted as:
	// "/subscriptions/{subscriptionID}/resourceGroups/{groupName}/providers/Microsoft.Web/serverfarms/{appServicePlanName}".
	ServerFarmReference *genruntime.ResourceReference `armReference:"ServerFarmId" json:"serverFarmReference,omitempty"`

	// SiteConfig: Configuration of an App Service app.
	SiteConfig *Sites_Spec_Properties_SiteConfig `json:"siteConfig,omitempty"`

	// StorageAccountRequired: Checks if Customer provided storage account is required
	StorageAccountRequired *bool `json:"storageAccountRequired,omitempty"`

	// Tags: Name-value pairs to add to the resource
	Tags map[string]string `json:"tags,omitempty"`

	// VirtualNetworkSubnetReference: Azure Resource Manager ID of the Virtual network and subnet to be joined by Regional VNET
	// Integration.
	// This must be of the form
	// /subscriptions/{subscriptionName}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{vnetName}/subnets/{subnetName}
	VirtualNetworkSubnetReference *genruntime.ResourceReference `armReference:"VirtualNetworkSubnetId" json:"virtualNetworkSubnetReference,omitempty"`

	// VnetContentShareEnabled: To enable accessing content over virtual network
	VnetContentShareEnabled *bool `json:"vnetContentShareEnabled,omitempty"`

	// VnetImagePullEnabled: To enable pulling image over Virtual Network
	VnetImagePullEnabled *bool `json:"vnetImagePullEnabled,omitempty"`

	// VnetRouteAllEnabled: Virtual Network Route All enabled. This causes all outbound traffic to have Virtual Network
	// Security Groups and User Defined Routes applied.
	VnetRouteAllEnabled *bool `json:"vnetRouteAllEnabled,omitempty"`
}

var _ genruntime.ARMTransformer = &Sites_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (sites *Sites_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if sites == nil {
		return nil, nil
	}
	result := &Sites_SpecARM{}

	// Set property ‘ExtendedLocation’:
	if sites.ExtendedLocation != nil {
		extendedLocationARM, err := (*sites.ExtendedLocation).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		extendedLocation := *extendedLocationARM.(*ExtendedLocationARM)
		result.ExtendedLocation = &extendedLocation
	}

	// Set property ‘Identity’:
	if sites.Identity != nil {
		identityARM, err := (*sites.Identity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := *identityARM.(*ManagedServiceIdentityARM)
		result.Identity = &identity
	}

	// Set property ‘Kind’:
	if sites.Kind != nil {
		kind := *sites.Kind
		result.Kind = &kind
	}

	// Set property ‘Location’:
	if sites.Location != nil {
		location := *sites.Location
		result.Location = &location
	}

	// Set property ‘Name’:
	result.Name = resolved.Name

	// Set property ‘Properties’:
	if sites.ClientAffinityEnabled != nil ||
		sites.ClientCertEnabled != nil ||
		sites.ClientCertExclusionPaths != nil ||
		sites.ClientCertMode != nil ||
		sites.CloningInfo != nil ||
		sites.ContainerSize != nil ||
		sites.CustomDomainVerificationId != nil ||
		sites.DailyMemoryTimeQuota != nil ||
		sites.Enabled != nil ||
		sites.HostNameSslStates != nil ||
		sites.HostNamesDisabled != nil ||
		sites.HostingEnvironmentProfile != nil ||
		sites.HttpsOnly != nil ||
		sites.HyperV != nil ||
		sites.IsXenon != nil ||
		sites.KeyVaultReferenceIdentity != nil ||
		sites.PublicNetworkAccess != nil ||
		sites.RedundancyMode != nil ||
		sites.Reserved != nil ||
		sites.ScmSiteAlsoStopped != nil ||
		sites.ServerFarmReference != nil ||
		sites.SiteConfig != nil ||
		sites.StorageAccountRequired != nil ||
		sites.VirtualNetworkSubnetReference != nil ||
		sites.VnetContentShareEnabled != nil ||
		sites.VnetImagePullEnabled != nil ||
		sites.VnetRouteAllEnabled != nil {
		result.Properties = &Sites_Spec_PropertiesARM{}
	}
	if sites.ClientAffinityEnabled != nil {
		clientAffinityEnabled := *sites.ClientAffinityEnabled
		result.Properties.ClientAffinityEnabled = &clientAffinityEnabled
	}
	if sites.ClientCertEnabled != nil {
		clientCertEnabled := *sites.ClientCertEnabled
		result.Properties.ClientCertEnabled = &clientCertEnabled
	}
	if sites.ClientCertExclusionPaths != nil {
		clientCertExclusionPaths := *sites.ClientCertExclusionPaths
		result.Properties.ClientCertExclusionPaths = &clientCertExclusionPaths
	}
	if sites.ClientCertMode != nil {
		clientCertMode := *sites.ClientCertMode
		result.Properties.ClientCertMode = &clientCertMode
	}
	if sites.CloningInfo != nil {
		cloningInfoARM, err := (*sites.CloningInfo).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		cloningInfo := *cloningInfoARM.(*CloningInfoARM)
		result.Properties.CloningInfo = &cloningInfo
	}
	if sites.ContainerSize != nil {
		containerSize := *sites.ContainerSize
		result.Properties.ContainerSize = &containerSize
	}
	if sites.CustomDomainVerificationId != nil {
		customDomainVerificationId := *sites.CustomDomainVerificationId
		result.Properties.CustomDomainVerificationId = &customDomainVerificationId
	}
	if sites.DailyMemoryTimeQuota != nil {
		dailyMemoryTimeQuota := *sites.DailyMemoryTimeQuota
		result.Properties.DailyMemoryTimeQuota = &dailyMemoryTimeQuota
	}
	if sites.Enabled != nil {
		enabled := *sites.Enabled
		result.Properties.Enabled = &enabled
	}
	for _, item := range sites.HostNameSslStates {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.HostNameSslStates = append(result.Properties.HostNameSslStates, *itemARM.(*HostNameSslStateARM))
	}
	if sites.HostNamesDisabled != nil {
		hostNamesDisabled := *sites.HostNamesDisabled
		result.Properties.HostNamesDisabled = &hostNamesDisabled
	}
	if sites.HostingEnvironmentProfile != nil {
		hostingEnvironmentProfileARM, err := (*sites.HostingEnvironmentProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		hostingEnvironmentProfile := *hostingEnvironmentProfileARM.(*HostingEnvironmentProfileARM)
		result.Properties.HostingEnvironmentProfile = &hostingEnvironmentProfile
	}
	if sites.HttpsOnly != nil {
		httpsOnly := *sites.HttpsOnly
		result.Properties.HttpsOnly = &httpsOnly
	}
	if sites.HyperV != nil {
		hyperV := *sites.HyperV
		result.Properties.HyperV = &hyperV
	}
	if sites.IsXenon != nil {
		isXenon := *sites.IsXenon
		result.Properties.IsXenon = &isXenon
	}
	if sites.KeyVaultReferenceIdentity != nil {
		keyVaultReferenceIdentity := *sites.KeyVaultReferenceIdentity
		result.Properties.KeyVaultReferenceIdentity = &keyVaultReferenceIdentity
	}
	if sites.PublicNetworkAccess != nil {
		publicNetworkAccess := *sites.PublicNetworkAccess
		result.Properties.PublicNetworkAccess = &publicNetworkAccess
	}
	if sites.RedundancyMode != nil {
		redundancyMode := *sites.RedundancyMode
		result.Properties.RedundancyMode = &redundancyMode
	}
	if sites.Reserved != nil {
		reserved := *sites.Reserved
		result.Properties.Reserved = &reserved
	}
	if sites.ScmSiteAlsoStopped != nil {
		scmSiteAlsoStopped := *sites.ScmSiteAlsoStopped
		result.Properties.ScmSiteAlsoStopped = &scmSiteAlsoStopped
	}
	if sites.ServerFarmReference != nil {
		serverFarmIdARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*sites.ServerFarmReference)
		if err != nil {
			return nil, err
		}
		serverFarmId := serverFarmIdARMID
		result.Properties.ServerFarmId = &serverFarmId
	}
	if sites.SiteConfig != nil {
		siteConfigARM, err := (*sites.SiteConfig).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		siteConfig := *siteConfigARM.(*Sites_Spec_Properties_SiteConfigARM)
		result.Properties.SiteConfig = &siteConfig
	}
	if sites.StorageAccountRequired != nil {
		storageAccountRequired := *sites.StorageAccountRequired
		result.Properties.StorageAccountRequired = &storageAccountRequired
	}
	if sites.VirtualNetworkSubnetReference != nil {
		virtualNetworkSubnetIdARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*sites.VirtualNetworkSubnetReference)
		if err != nil {
			return nil, err
		}
		virtualNetworkSubnetId := virtualNetworkSubnetIdARMID
		result.Properties.VirtualNetworkSubnetId = &virtualNetworkSubnetId
	}
	if sites.VnetContentShareEnabled != nil {
		vnetContentShareEnabled := *sites.VnetContentShareEnabled
		result.Properties.VnetContentShareEnabled = &vnetContentShareEnabled
	}
	if sites.VnetImagePullEnabled != nil {
		vnetImagePullEnabled := *sites.VnetImagePullEnabled
		result.Properties.VnetImagePullEnabled = &vnetImagePullEnabled
	}
	if sites.VnetRouteAllEnabled != nil {
		vnetRouteAllEnabled := *sites.VnetRouteAllEnabled
		result.Properties.VnetRouteAllEnabled = &vnetRouteAllEnabled
	}

	// Set property ‘Tags’:
	if sites.Tags != nil {
		result.Tags = make(map[string]string, len(sites.Tags))
		for key, value := range sites.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sites *Sites_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Sites_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sites *Sites_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Sites_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Sites_SpecARM, got %T", armInput)
	}

	// Set property ‘AzureName’:
	sites.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property ‘ClientAffinityEnabled’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ClientAffinityEnabled != nil {
			clientAffinityEnabled := *typedInput.Properties.ClientAffinityEnabled
			sites.ClientAffinityEnabled = &clientAffinityEnabled
		}
	}

	// Set property ‘ClientCertEnabled’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ClientCertEnabled != nil {
			clientCertEnabled := *typedInput.Properties.ClientCertEnabled
			sites.ClientCertEnabled = &clientCertEnabled
		}
	}

	// Set property ‘ClientCertExclusionPaths’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ClientCertExclusionPaths != nil {
			clientCertExclusionPaths := *typedInput.Properties.ClientCertExclusionPaths
			sites.ClientCertExclusionPaths = &clientCertExclusionPaths
		}
	}

	// Set property ‘ClientCertMode’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ClientCertMode != nil {
			clientCertMode := *typedInput.Properties.ClientCertMode
			sites.ClientCertMode = &clientCertMode
		}
	}

	// Set property ‘CloningInfo’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CloningInfo != nil {
			var cloningInfo1 CloningInfo
			err := cloningInfo1.PopulateFromARM(owner, *typedInput.Properties.CloningInfo)
			if err != nil {
				return err
			}
			cloningInfo := cloningInfo1
			sites.CloningInfo = &cloningInfo
		}
	}

	// Set property ‘ContainerSize’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ContainerSize != nil {
			containerSize := *typedInput.Properties.ContainerSize
			sites.ContainerSize = &containerSize
		}
	}

	// Set property ‘CustomDomainVerificationId’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CustomDomainVerificationId != nil {
			customDomainVerificationId := *typedInput.Properties.CustomDomainVerificationId
			sites.CustomDomainVerificationId = &customDomainVerificationId
		}
	}

	// Set property ‘DailyMemoryTimeQuota’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DailyMemoryTimeQuota != nil {
			dailyMemoryTimeQuota := *typedInput.Properties.DailyMemoryTimeQuota
			sites.DailyMemoryTimeQuota = &dailyMemoryTimeQuota
		}
	}

	// Set property ‘Enabled’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Enabled != nil {
			enabled := *typedInput.Properties.Enabled
			sites.Enabled = &enabled
		}
	}

	// Set property ‘ExtendedLocation’:
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		sites.ExtendedLocation = &extendedLocation
	}

	// Set property ‘HostNameSslStates’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.HostNameSslStates {
			var item1 HostNameSslState
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			sites.HostNameSslStates = append(sites.HostNameSslStates, item1)
		}
	}

	// Set property ‘HostNamesDisabled’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HostNamesDisabled != nil {
			hostNamesDisabled := *typedInput.Properties.HostNamesDisabled
			sites.HostNamesDisabled = &hostNamesDisabled
		}
	}

	// Set property ‘HostingEnvironmentProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HostingEnvironmentProfile != nil {
			var hostingEnvironmentProfile1 HostingEnvironmentProfile
			err := hostingEnvironmentProfile1.PopulateFromARM(owner, *typedInput.Properties.HostingEnvironmentProfile)
			if err != nil {
				return err
			}
			hostingEnvironmentProfile := hostingEnvironmentProfile1
			sites.HostingEnvironmentProfile = &hostingEnvironmentProfile
		}
	}

	// Set property ‘HttpsOnly’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HttpsOnly != nil {
			httpsOnly := *typedInput.Properties.HttpsOnly
			sites.HttpsOnly = &httpsOnly
		}
	}

	// Set property ‘HyperV’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HyperV != nil {
			hyperV := *typedInput.Properties.HyperV
			sites.HyperV = &hyperV
		}
	}

	// Set property ‘Identity’:
	if typedInput.Identity != nil {
		var identity1 ManagedServiceIdentity
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		sites.Identity = &identity
	}

	// Set property ‘IsXenon’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IsXenon != nil {
			isXenon := *typedInput.Properties.IsXenon
			sites.IsXenon = &isXenon
		}
	}

	// Set property ‘KeyVaultReferenceIdentity’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.KeyVaultReferenceIdentity != nil {
			keyVaultReferenceIdentity := *typedInput.Properties.KeyVaultReferenceIdentity
			sites.KeyVaultReferenceIdentity = &keyVaultReferenceIdentity
		}
	}

	// Set property ‘Kind’:
	if typedInput.Kind != nil {
		kind := *typedInput.Kind
		sites.Kind = &kind
	}

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		sites.Location = &location
	}

	// Set property ‘Owner’:
	sites.Owner = &genruntime.KnownResourceReference{
		Name: owner.Name,
	}

	// Set property ‘PublicNetworkAccess’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicNetworkAccess != nil {
			publicNetworkAccess := *typedInput.Properties.PublicNetworkAccess
			sites.PublicNetworkAccess = &publicNetworkAccess
		}
	}

	// Set property ‘RedundancyMode’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RedundancyMode != nil {
			redundancyMode := *typedInput.Properties.RedundancyMode
			sites.RedundancyMode = &redundancyMode
		}
	}

	// Set property ‘Reserved’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Reserved != nil {
			reserved := *typedInput.Properties.Reserved
			sites.Reserved = &reserved
		}
	}

	// Set property ‘ScmSiteAlsoStopped’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ScmSiteAlsoStopped != nil {
			scmSiteAlsoStopped := *typedInput.Properties.ScmSiteAlsoStopped
			sites.ScmSiteAlsoStopped = &scmSiteAlsoStopped
		}
	}

	// no assignment for property ‘ServerFarmReference’

	// Set property ‘SiteConfig’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SiteConfig != nil {
			var siteConfig1 Sites_Spec_Properties_SiteConfig
			err := siteConfig1.PopulateFromARM(owner, *typedInput.Properties.SiteConfig)
			if err != nil {
				return err
			}
			siteConfig := siteConfig1
			sites.SiteConfig = &siteConfig
		}
	}

	// Set property ‘StorageAccountRequired’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.StorageAccountRequired != nil {
			storageAccountRequired := *typedInput.Properties.StorageAccountRequired
			sites.StorageAccountRequired = &storageAccountRequired
		}
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		sites.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			sites.Tags[key] = value
		}
	}

	// no assignment for property ‘VirtualNetworkSubnetReference’

	// Set property ‘VnetContentShareEnabled’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VnetContentShareEnabled != nil {
			vnetContentShareEnabled := *typedInput.Properties.VnetContentShareEnabled
			sites.VnetContentShareEnabled = &vnetContentShareEnabled
		}
	}

	// Set property ‘VnetImagePullEnabled’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VnetImagePullEnabled != nil {
			vnetImagePullEnabled := *typedInput.Properties.VnetImagePullEnabled
			sites.VnetImagePullEnabled = &vnetImagePullEnabled
		}
	}

	// Set property ‘VnetRouteAllEnabled’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VnetRouteAllEnabled != nil {
			vnetRouteAllEnabled := *typedInput.Properties.VnetRouteAllEnabled
			sites.VnetRouteAllEnabled = &vnetRouteAllEnabled
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &Sites_Spec{}

// ConvertSpecFrom populates our Sites_Spec from the provided source
func (sites *Sites_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v20220301s.Sites_Spec)
	if ok {
		// Populate our instance from source
		return sites.AssignPropertiesFromSitesSpec(src)
	}

	// Convert to an intermediate form
	src = &v20220301s.Sites_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = sites.AssignPropertiesFromSitesSpec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our Sites_Spec
func (sites *Sites_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v20220301s.Sites_Spec)
	if ok {
		// Populate destination from our instance
		return sites.AssignPropertiesToSitesSpec(dst)
	}

	// Convert to an intermediate form
	dst = &v20220301s.Sites_Spec{}
	err := sites.AssignPropertiesToSitesSpec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignPropertiesFromSitesSpec populates our Sites_Spec from the provided source Sites_Spec
func (sites *Sites_Spec) AssignPropertiesFromSitesSpec(source *v20220301s.Sites_Spec) error {

	// AzureName
	sites.AzureName = source.AzureName

	// ClientAffinityEnabled
	if source.ClientAffinityEnabled != nil {
		clientAffinityEnabled := *source.ClientAffinityEnabled
		sites.ClientAffinityEnabled = &clientAffinityEnabled
	} else {
		sites.ClientAffinityEnabled = nil
	}

	// ClientCertEnabled
	if source.ClientCertEnabled != nil {
		clientCertEnabled := *source.ClientCertEnabled
		sites.ClientCertEnabled = &clientCertEnabled
	} else {
		sites.ClientCertEnabled = nil
	}

	// ClientCertExclusionPaths
	sites.ClientCertExclusionPaths = genruntime.ClonePointerToString(source.ClientCertExclusionPaths)

	// ClientCertMode
	if source.ClientCertMode != nil {
		clientCertMode := SitesSpecPropertiesClientCertMode(*source.ClientCertMode)
		sites.ClientCertMode = &clientCertMode
	} else {
		sites.ClientCertMode = nil
	}

	// CloningInfo
	if source.CloningInfo != nil {
		var cloningInfo CloningInfo
		err := cloningInfo.AssignPropertiesFromCloningInfo(source.CloningInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromCloningInfo() to populate field CloningInfo")
		}
		sites.CloningInfo = &cloningInfo
	} else {
		sites.CloningInfo = nil
	}

	// ContainerSize
	sites.ContainerSize = genruntime.ClonePointerToInt(source.ContainerSize)

	// CustomDomainVerificationId
	sites.CustomDomainVerificationId = genruntime.ClonePointerToString(source.CustomDomainVerificationId)

	// DailyMemoryTimeQuota
	sites.DailyMemoryTimeQuota = genruntime.ClonePointerToInt(source.DailyMemoryTimeQuota)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		sites.Enabled = &enabled
	} else {
		sites.Enabled = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation
		err := extendedLocation.AssignPropertiesFromExtendedLocation(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromExtendedLocation() to populate field ExtendedLocation")
		}
		sites.ExtendedLocation = &extendedLocation
	} else {
		sites.ExtendedLocation = nil
	}

	// HostNameSslStates
	if source.HostNameSslStates != nil {
		hostNameSslStateList := make([]HostNameSslState, len(source.HostNameSslStates))
		for hostNameSslStateIndex, hostNameSslStateItem := range source.HostNameSslStates {
			// Shadow the loop variable to avoid aliasing
			hostNameSslStateItem := hostNameSslStateItem
			var hostNameSslState HostNameSslState
			err := hostNameSslState.AssignPropertiesFromHostNameSslState(&hostNameSslStateItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromHostNameSslState() to populate field HostNameSslStates")
			}
			hostNameSslStateList[hostNameSslStateIndex] = hostNameSslState
		}
		sites.HostNameSslStates = hostNameSslStateList
	} else {
		sites.HostNameSslStates = nil
	}

	// HostNamesDisabled
	if source.HostNamesDisabled != nil {
		hostNamesDisabled := *source.HostNamesDisabled
		sites.HostNamesDisabled = &hostNamesDisabled
	} else {
		sites.HostNamesDisabled = nil
	}

	// HostingEnvironmentProfile
	if source.HostingEnvironmentProfile != nil {
		var hostingEnvironmentProfile HostingEnvironmentProfile
		err := hostingEnvironmentProfile.AssignPropertiesFromHostingEnvironmentProfile(source.HostingEnvironmentProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromHostingEnvironmentProfile() to populate field HostingEnvironmentProfile")
		}
		sites.HostingEnvironmentProfile = &hostingEnvironmentProfile
	} else {
		sites.HostingEnvironmentProfile = nil
	}

	// HttpsOnly
	if source.HttpsOnly != nil {
		httpsOnly := *source.HttpsOnly
		sites.HttpsOnly = &httpsOnly
	} else {
		sites.HttpsOnly = nil
	}

	// HyperV
	if source.HyperV != nil {
		hyperV := *source.HyperV
		sites.HyperV = &hyperV
	} else {
		sites.HyperV = nil
	}

	// Identity
	if source.Identity != nil {
		var identity ManagedServiceIdentity
		err := identity.AssignPropertiesFromManagedServiceIdentity(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedServiceIdentity() to populate field Identity")
		}
		sites.Identity = &identity
	} else {
		sites.Identity = nil
	}

	// IsXenon
	if source.IsXenon != nil {
		isXenon := *source.IsXenon
		sites.IsXenon = &isXenon
	} else {
		sites.IsXenon = nil
	}

	// KeyVaultReferenceIdentity
	sites.KeyVaultReferenceIdentity = genruntime.ClonePointerToString(source.KeyVaultReferenceIdentity)

	// Kind
	sites.Kind = genruntime.ClonePointerToString(source.Kind)

	// Location
	sites.Location = genruntime.ClonePointerToString(source.Location)

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		sites.Owner = &owner
	} else {
		sites.Owner = nil
	}

	// PublicNetworkAccess
	sites.PublicNetworkAccess = genruntime.ClonePointerToString(source.PublicNetworkAccess)

	// RedundancyMode
	if source.RedundancyMode != nil {
		redundancyMode := SitesSpecPropertiesRedundancyMode(*source.RedundancyMode)
		sites.RedundancyMode = &redundancyMode
	} else {
		sites.RedundancyMode = nil
	}

	// Reserved
	if source.Reserved != nil {
		reserved := *source.Reserved
		sites.Reserved = &reserved
	} else {
		sites.Reserved = nil
	}

	// ScmSiteAlsoStopped
	if source.ScmSiteAlsoStopped != nil {
		scmSiteAlsoStopped := *source.ScmSiteAlsoStopped
		sites.ScmSiteAlsoStopped = &scmSiteAlsoStopped
	} else {
		sites.ScmSiteAlsoStopped = nil
	}

	// ServerFarmReference
	if source.ServerFarmReference != nil {
		serverFarmReference := source.ServerFarmReference.Copy()
		sites.ServerFarmReference = &serverFarmReference
	} else {
		sites.ServerFarmReference = nil
	}

	// SiteConfig
	if source.SiteConfig != nil {
		var siteConfig Sites_Spec_Properties_SiteConfig
		err := siteConfig.AssignPropertiesFromSitesSpecPropertiesSiteConfig(source.SiteConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSitesSpecPropertiesSiteConfig() to populate field SiteConfig")
		}
		sites.SiteConfig = &siteConfig
	} else {
		sites.SiteConfig = nil
	}

	// StorageAccountRequired
	if source.StorageAccountRequired != nil {
		storageAccountRequired := *source.StorageAccountRequired
		sites.StorageAccountRequired = &storageAccountRequired
	} else {
		sites.StorageAccountRequired = nil
	}

	// Tags
	sites.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// VirtualNetworkSubnetReference
	if source.VirtualNetworkSubnetReference != nil {
		virtualNetworkSubnetReference := source.VirtualNetworkSubnetReference.Copy()
		sites.VirtualNetworkSubnetReference = &virtualNetworkSubnetReference
	} else {
		sites.VirtualNetworkSubnetReference = nil
	}

	// VnetContentShareEnabled
	if source.VnetContentShareEnabled != nil {
		vnetContentShareEnabled := *source.VnetContentShareEnabled
		sites.VnetContentShareEnabled = &vnetContentShareEnabled
	} else {
		sites.VnetContentShareEnabled = nil
	}

	// VnetImagePullEnabled
	if source.VnetImagePullEnabled != nil {
		vnetImagePullEnabled := *source.VnetImagePullEnabled
		sites.VnetImagePullEnabled = &vnetImagePullEnabled
	} else {
		sites.VnetImagePullEnabled = nil
	}

	// VnetRouteAllEnabled
	if source.VnetRouteAllEnabled != nil {
		vnetRouteAllEnabled := *source.VnetRouteAllEnabled
		sites.VnetRouteAllEnabled = &vnetRouteAllEnabled
	} else {
		sites.VnetRouteAllEnabled = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSitesSpec populates the provided destination Sites_Spec from our Sites_Spec
func (sites *Sites_Spec) AssignPropertiesToSitesSpec(destination *v20220301s.Sites_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = sites.AzureName

	// ClientAffinityEnabled
	if sites.ClientAffinityEnabled != nil {
		clientAffinityEnabled := *sites.ClientAffinityEnabled
		destination.ClientAffinityEnabled = &clientAffinityEnabled
	} else {
		destination.ClientAffinityEnabled = nil
	}

	// ClientCertEnabled
	if sites.ClientCertEnabled != nil {
		clientCertEnabled := *sites.ClientCertEnabled
		destination.ClientCertEnabled = &clientCertEnabled
	} else {
		destination.ClientCertEnabled = nil
	}

	// ClientCertExclusionPaths
	destination.ClientCertExclusionPaths = genruntime.ClonePointerToString(sites.ClientCertExclusionPaths)

	// ClientCertMode
	if sites.ClientCertMode != nil {
		clientCertMode := string(*sites.ClientCertMode)
		destination.ClientCertMode = &clientCertMode
	} else {
		destination.ClientCertMode = nil
	}

	// CloningInfo
	if sites.CloningInfo != nil {
		var cloningInfo v20220301s.CloningInfo
		err := sites.CloningInfo.AssignPropertiesToCloningInfo(&cloningInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToCloningInfo() to populate field CloningInfo")
		}
		destination.CloningInfo = &cloningInfo
	} else {
		destination.CloningInfo = nil
	}

	// ContainerSize
	destination.ContainerSize = genruntime.ClonePointerToInt(sites.ContainerSize)

	// CustomDomainVerificationId
	destination.CustomDomainVerificationId = genruntime.ClonePointerToString(sites.CustomDomainVerificationId)

	// DailyMemoryTimeQuota
	destination.DailyMemoryTimeQuota = genruntime.ClonePointerToInt(sites.DailyMemoryTimeQuota)

	// Enabled
	if sites.Enabled != nil {
		enabled := *sites.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// ExtendedLocation
	if sites.ExtendedLocation != nil {
		var extendedLocation v20220301s.ExtendedLocation
		err := sites.ExtendedLocation.AssignPropertiesToExtendedLocation(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToExtendedLocation() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// HostNameSslStates
	if sites.HostNameSslStates != nil {
		hostNameSslStateList := make([]v20220301s.HostNameSslState, len(sites.HostNameSslStates))
		for hostNameSslStateIndex, hostNameSslStateItem := range sites.HostNameSslStates {
			// Shadow the loop variable to avoid aliasing
			hostNameSslStateItem := hostNameSslStateItem
			var hostNameSslState v20220301s.HostNameSslState
			err := hostNameSslStateItem.AssignPropertiesToHostNameSslState(&hostNameSslState)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToHostNameSslState() to populate field HostNameSslStates")
			}
			hostNameSslStateList[hostNameSslStateIndex] = hostNameSslState
		}
		destination.HostNameSslStates = hostNameSslStateList
	} else {
		destination.HostNameSslStates = nil
	}

	// HostNamesDisabled
	if sites.HostNamesDisabled != nil {
		hostNamesDisabled := *sites.HostNamesDisabled
		destination.HostNamesDisabled = &hostNamesDisabled
	} else {
		destination.HostNamesDisabled = nil
	}

	// HostingEnvironmentProfile
	if sites.HostingEnvironmentProfile != nil {
		var hostingEnvironmentProfile v20220301s.HostingEnvironmentProfile
		err := sites.HostingEnvironmentProfile.AssignPropertiesToHostingEnvironmentProfile(&hostingEnvironmentProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToHostingEnvironmentProfile() to populate field HostingEnvironmentProfile")
		}
		destination.HostingEnvironmentProfile = &hostingEnvironmentProfile
	} else {
		destination.HostingEnvironmentProfile = nil
	}

	// HttpsOnly
	if sites.HttpsOnly != nil {
		httpsOnly := *sites.HttpsOnly
		destination.HttpsOnly = &httpsOnly
	} else {
		destination.HttpsOnly = nil
	}

	// HyperV
	if sites.HyperV != nil {
		hyperV := *sites.HyperV
		destination.HyperV = &hyperV
	} else {
		destination.HyperV = nil
	}

	// Identity
	if sites.Identity != nil {
		var identity v20220301s.ManagedServiceIdentity
		err := sites.Identity.AssignPropertiesToManagedServiceIdentity(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedServiceIdentity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// IsXenon
	if sites.IsXenon != nil {
		isXenon := *sites.IsXenon
		destination.IsXenon = &isXenon
	} else {
		destination.IsXenon = nil
	}

	// KeyVaultReferenceIdentity
	destination.KeyVaultReferenceIdentity = genruntime.ClonePointerToString(sites.KeyVaultReferenceIdentity)

	// Kind
	destination.Kind = genruntime.ClonePointerToString(sites.Kind)

	// Location
	destination.Location = genruntime.ClonePointerToString(sites.Location)

	// OriginalVersion
	destination.OriginalVersion = sites.OriginalVersion()

	// Owner
	if sites.Owner != nil {
		owner := sites.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// PublicNetworkAccess
	destination.PublicNetworkAccess = genruntime.ClonePointerToString(sites.PublicNetworkAccess)

	// RedundancyMode
	if sites.RedundancyMode != nil {
		redundancyMode := string(*sites.RedundancyMode)
		destination.RedundancyMode = &redundancyMode
	} else {
		destination.RedundancyMode = nil
	}

	// Reserved
	if sites.Reserved != nil {
		reserved := *sites.Reserved
		destination.Reserved = &reserved
	} else {
		destination.Reserved = nil
	}

	// ScmSiteAlsoStopped
	if sites.ScmSiteAlsoStopped != nil {
		scmSiteAlsoStopped := *sites.ScmSiteAlsoStopped
		destination.ScmSiteAlsoStopped = &scmSiteAlsoStopped
	} else {
		destination.ScmSiteAlsoStopped = nil
	}

	// ServerFarmReference
	if sites.ServerFarmReference != nil {
		serverFarmReference := sites.ServerFarmReference.Copy()
		destination.ServerFarmReference = &serverFarmReference
	} else {
		destination.ServerFarmReference = nil
	}

	// SiteConfig
	if sites.SiteConfig != nil {
		var siteConfig v20220301s.Sites_Spec_Properties_SiteConfig
		err := sites.SiteConfig.AssignPropertiesToSitesSpecPropertiesSiteConfig(&siteConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSitesSpecPropertiesSiteConfig() to populate field SiteConfig")
		}
		destination.SiteConfig = &siteConfig
	} else {
		destination.SiteConfig = nil
	}

	// StorageAccountRequired
	if sites.StorageAccountRequired != nil {
		storageAccountRequired := *sites.StorageAccountRequired
		destination.StorageAccountRequired = &storageAccountRequired
	} else {
		destination.StorageAccountRequired = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(sites.Tags)

	// VirtualNetworkSubnetReference
	if sites.VirtualNetworkSubnetReference != nil {
		virtualNetworkSubnetReference := sites.VirtualNetworkSubnetReference.Copy()
		destination.VirtualNetworkSubnetReference = &virtualNetworkSubnetReference
	} else {
		destination.VirtualNetworkSubnetReference = nil
	}

	// VnetContentShareEnabled
	if sites.VnetContentShareEnabled != nil {
		vnetContentShareEnabled := *sites.VnetContentShareEnabled
		destination.VnetContentShareEnabled = &vnetContentShareEnabled
	} else {
		destination.VnetContentShareEnabled = nil
	}

	// VnetImagePullEnabled
	if sites.VnetImagePullEnabled != nil {
		vnetImagePullEnabled := *sites.VnetImagePullEnabled
		destination.VnetImagePullEnabled = &vnetImagePullEnabled
	} else {
		destination.VnetImagePullEnabled = nil
	}

	// VnetRouteAllEnabled
	if sites.VnetRouteAllEnabled != nil {
		vnetRouteAllEnabled := *sites.VnetRouteAllEnabled
		destination.VnetRouteAllEnabled = &vnetRouteAllEnabled
	} else {
		destination.VnetRouteAllEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (sites *Sites_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (sites *Sites_Spec) SetAzureName(azureName string) { sites.AzureName = azureName }

// Generated from: https://schema.management.azure.com/schemas/2022-03-01/Microsoft.Web.json#/definitions/CloningInfo
type CloningInfo struct {
	// AppSettingsOverrides: Application setting overrides for cloned app. If specified, these settings override the settings
	// cloned
	// from source app. Otherwise, application settings from source app are retained.
	AppSettingsOverrides map[string]string `json:"appSettingsOverrides,omitempty"`

	// CloneCustomHostNames: <code>true</code> to clone custom hostnames from source app; otherwise, <code>false</code>.
	CloneCustomHostNames *bool `json:"cloneCustomHostNames,omitempty"`

	// CloneSourceControl: <code>true</code> to clone source control from source app; otherwise, <code>false</code>.
	CloneSourceControl *bool `json:"cloneSourceControl,omitempty"`

	// ConfigureLoadBalancing: <code>true</code> to configure load balancing for source and destination app.
	ConfigureLoadBalancing *bool `json:"configureLoadBalancing,omitempty"`

	// +kubebuilder:validation:Pattern="^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$"
	// CorrelationId: Correlation ID of cloning operation. This ID ties multiple cloning operations
	// together to use the same snapshot.
	CorrelationId *string `json:"correlationId,omitempty"`

	// HostingEnvironment: App Service Environment.
	HostingEnvironment *string `json:"hostingEnvironment,omitempty"`

	// Overwrite: <code>true</code> to overwrite destination app; otherwise, <code>false</code>.
	Overwrite *bool `json:"overwrite,omitempty"`

	// SourceWebAppLocation: Location of source app ex: West US or North Europe
	SourceWebAppLocation *string `json:"sourceWebAppLocation,omitempty"`

	// +kubebuilder:validation:Required
	// SourceWebAppReference: ARM resource ID of the source app. App resource ID is of the form
	// /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName} for production slots
	// and
	// /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slotName} for
	// other slots.
	SourceWebAppReference *genruntime.ResourceReference `armReference:"SourceWebAppId" json:"sourceWebAppReference,omitempty"`

	// TrafficManagerProfileName: Name of Traffic Manager profile to create. This is only needed if Traffic Manager profile
	// does not already exist.
	TrafficManagerProfileName *string `json:"trafficManagerProfileName,omitempty"`

	// TrafficManagerProfileReference: ARM resource ID of the Traffic Manager profile to use, if it exists. Traffic Manager
	// resource ID is of the form
	// /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{profileName}.
	TrafficManagerProfileReference *genruntime.ResourceReference `armReference:"TrafficManagerProfileId" json:"trafficManagerProfileReference,omitempty"`
}

var _ genruntime.ARMTransformer = &CloningInfo{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (info *CloningInfo) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if info == nil {
		return nil, nil
	}
	result := &CloningInfoARM{}

	// Set property ‘AppSettingsOverrides’:
	if info.AppSettingsOverrides != nil {
		result.AppSettingsOverrides = make(map[string]string, len(info.AppSettingsOverrides))
		for key, value := range info.AppSettingsOverrides {
			result.AppSettingsOverrides[key] = value
		}
	}

	// Set property ‘CloneCustomHostNames’:
	if info.CloneCustomHostNames != nil {
		cloneCustomHostNames := *info.CloneCustomHostNames
		result.CloneCustomHostNames = &cloneCustomHostNames
	}

	// Set property ‘CloneSourceControl’:
	if info.CloneSourceControl != nil {
		cloneSourceControl := *info.CloneSourceControl
		result.CloneSourceControl = &cloneSourceControl
	}

	// Set property ‘ConfigureLoadBalancing’:
	if info.ConfigureLoadBalancing != nil {
		configureLoadBalancing := *info.ConfigureLoadBalancing
		result.ConfigureLoadBalancing = &configureLoadBalancing
	}

	// Set property ‘CorrelationId’:
	if info.CorrelationId != nil {
		correlationId := *info.CorrelationId
		result.CorrelationId = &correlationId
	}

	// Set property ‘HostingEnvironment’:
	if info.HostingEnvironment != nil {
		hostingEnvironment := *info.HostingEnvironment
		result.HostingEnvironment = &hostingEnvironment
	}

	// Set property ‘Overwrite’:
	if info.Overwrite != nil {
		overwrite := *info.Overwrite
		result.Overwrite = &overwrite
	}

	// Set property ‘SourceWebAppId’:
	if info.SourceWebAppReference != nil {
		sourceWebAppReferenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*info.SourceWebAppReference)
		if err != nil {
			return nil, err
		}
		sourceWebAppReference := sourceWebAppReferenceARMID
		result.SourceWebAppId = &sourceWebAppReference
	}

	// Set property ‘SourceWebAppLocation’:
	if info.SourceWebAppLocation != nil {
		sourceWebAppLocation := *info.SourceWebAppLocation
		result.SourceWebAppLocation = &sourceWebAppLocation
	}

	// Set property ‘TrafficManagerProfileId’:
	if info.TrafficManagerProfileReference != nil {
		trafficManagerProfileReferenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*info.TrafficManagerProfileReference)
		if err != nil {
			return nil, err
		}
		trafficManagerProfileReference := trafficManagerProfileReferenceARMID
		result.TrafficManagerProfileId = &trafficManagerProfileReference
	}

	// Set property ‘TrafficManagerProfileName’:
	if info.TrafficManagerProfileName != nil {
		trafficManagerProfileName := *info.TrafficManagerProfileName
		result.TrafficManagerProfileName = &trafficManagerProfileName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (info *CloningInfo) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &CloningInfoARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (info *CloningInfo) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(CloningInfoARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CloningInfoARM, got %T", armInput)
	}

	// Set property ‘AppSettingsOverrides’:
	if typedInput.AppSettingsOverrides != nil {
		info.AppSettingsOverrides = make(map[string]string, len(typedInput.AppSettingsOverrides))
		for key, value := range typedInput.AppSettingsOverrides {
			info.AppSettingsOverrides[key] = value
		}
	}

	// Set property ‘CloneCustomHostNames’:
	if typedInput.CloneCustomHostNames != nil {
		cloneCustomHostNames := *typedInput.CloneCustomHostNames
		info.CloneCustomHostNames = &cloneCustomHostNames
	}

	// Set property ‘CloneSourceControl’:
	if typedInput.CloneSourceControl != nil {
		cloneSourceControl := *typedInput.CloneSourceControl
		info.CloneSourceControl = &cloneSourceControl
	}

	// Set property ‘ConfigureLoadBalancing’:
	if typedInput.ConfigureLoadBalancing != nil {
		configureLoadBalancing := *typedInput.ConfigureLoadBalancing
		info.ConfigureLoadBalancing = &configureLoadBalancing
	}

	// Set property ‘CorrelationId’:
	if typedInput.CorrelationId != nil {
		correlationId := *typedInput.CorrelationId
		info.CorrelationId = &correlationId
	}

	// Set property ‘HostingEnvironment’:
	if typedInput.HostingEnvironment != nil {
		hostingEnvironment := *typedInput.HostingEnvironment
		info.HostingEnvironment = &hostingEnvironment
	}

	// Set property ‘Overwrite’:
	if typedInput.Overwrite != nil {
		overwrite := *typedInput.Overwrite
		info.Overwrite = &overwrite
	}

	// Set property ‘SourceWebAppLocation’:
	if typedInput.SourceWebAppLocation != nil {
		sourceWebAppLocation := *typedInput.SourceWebAppLocation
		info.SourceWebAppLocation = &sourceWebAppLocation
	}

	// no assignment for property ‘SourceWebAppReference’

	// Set property ‘TrafficManagerProfileName’:
	if typedInput.TrafficManagerProfileName != nil {
		trafficManagerProfileName := *typedInput.TrafficManagerProfileName
		info.TrafficManagerProfileName = &trafficManagerProfileName
	}

	// no assignment for property ‘TrafficManagerProfileReference’

	// No error
	return nil
}

// AssignPropertiesFromCloningInfo populates our CloningInfo from the provided source CloningInfo
func (info *CloningInfo) AssignPropertiesFromCloningInfo(source *v20220301s.CloningInfo) error {

	// AppSettingsOverrides
	info.AppSettingsOverrides = genruntime.CloneMapOfStringToString(source.AppSettingsOverrides)

	// CloneCustomHostNames
	if source.CloneCustomHostNames != nil {
		cloneCustomHostName := *source.CloneCustomHostNames
		info.CloneCustomHostNames = &cloneCustomHostName
	} else {
		info.CloneCustomHostNames = nil
	}

	// CloneSourceControl
	if source.CloneSourceControl != nil {
		cloneSourceControl := *source.CloneSourceControl
		info.CloneSourceControl = &cloneSourceControl
	} else {
		info.CloneSourceControl = nil
	}

	// ConfigureLoadBalancing
	if source.ConfigureLoadBalancing != nil {
		configureLoadBalancing := *source.ConfigureLoadBalancing
		info.ConfigureLoadBalancing = &configureLoadBalancing
	} else {
		info.ConfigureLoadBalancing = nil
	}

	// CorrelationId
	if source.CorrelationId != nil {
		correlationId := *source.CorrelationId
		info.CorrelationId = &correlationId
	} else {
		info.CorrelationId = nil
	}

	// HostingEnvironment
	info.HostingEnvironment = genruntime.ClonePointerToString(source.HostingEnvironment)

	// Overwrite
	if source.Overwrite != nil {
		overwrite := *source.Overwrite
		info.Overwrite = &overwrite
	} else {
		info.Overwrite = nil
	}

	// SourceWebAppLocation
	info.SourceWebAppLocation = genruntime.ClonePointerToString(source.SourceWebAppLocation)

	// SourceWebAppReference
	if source.SourceWebAppReference != nil {
		sourceWebAppReference := source.SourceWebAppReference.Copy()
		info.SourceWebAppReference = &sourceWebAppReference
	} else {
		info.SourceWebAppReference = nil
	}

	// TrafficManagerProfileName
	info.TrafficManagerProfileName = genruntime.ClonePointerToString(source.TrafficManagerProfileName)

	// TrafficManagerProfileReference
	if source.TrafficManagerProfileReference != nil {
		trafficManagerProfileReference := source.TrafficManagerProfileReference.Copy()
		info.TrafficManagerProfileReference = &trafficManagerProfileReference
	} else {
		info.TrafficManagerProfileReference = nil
	}

	// No error
	return nil
}

// AssignPropertiesToCloningInfo populates the provided destination CloningInfo from our CloningInfo
func (info *CloningInfo) AssignPropertiesToCloningInfo(destination *v20220301s.CloningInfo) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AppSettingsOverrides
	destination.AppSettingsOverrides = genruntime.CloneMapOfStringToString(info.AppSettingsOverrides)

	// CloneCustomHostNames
	if info.CloneCustomHostNames != nil {
		cloneCustomHostName := *info.CloneCustomHostNames
		destination.CloneCustomHostNames = &cloneCustomHostName
	} else {
		destination.CloneCustomHostNames = nil
	}

	// CloneSourceControl
	if info.CloneSourceControl != nil {
		cloneSourceControl := *info.CloneSourceControl
		destination.CloneSourceControl = &cloneSourceControl
	} else {
		destination.CloneSourceControl = nil
	}

	// ConfigureLoadBalancing
	if info.ConfigureLoadBalancing != nil {
		configureLoadBalancing := *info.ConfigureLoadBalancing
		destination.ConfigureLoadBalancing = &configureLoadBalancing
	} else {
		destination.ConfigureLoadBalancing = nil
	}

	// CorrelationId
	if info.CorrelationId != nil {
		correlationId := *info.CorrelationId
		destination.CorrelationId = &correlationId
	} else {
		destination.CorrelationId = nil
	}

	// HostingEnvironment
	destination.HostingEnvironment = genruntime.ClonePointerToString(info.HostingEnvironment)

	// Overwrite
	if info.Overwrite != nil {
		overwrite := *info.Overwrite
		destination.Overwrite = &overwrite
	} else {
		destination.Overwrite = nil
	}

	// SourceWebAppLocation
	destination.SourceWebAppLocation = genruntime.ClonePointerToString(info.SourceWebAppLocation)

	// SourceWebAppReference
	if info.SourceWebAppReference != nil {
		sourceWebAppReference := info.SourceWebAppReference.Copy()
		destination.SourceWebAppReference = &sourceWebAppReference
	} else {
		destination.SourceWebAppReference = nil
	}

	// TrafficManagerProfileName
	destination.TrafficManagerProfileName = genruntime.ClonePointerToString(info.TrafficManagerProfileName)

	// TrafficManagerProfileReference
	if info.TrafficManagerProfileReference != nil {
		trafficManagerProfileReference := info.TrafficManagerProfileReference.Copy()
		destination.TrafficManagerProfileReference = &trafficManagerProfileReference
	} else {
		destination.TrafficManagerProfileReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type CloningInfo_STATUS struct {
	// AppSettingsOverrides: Application setting overrides for cloned app. If specified, these settings override the settings
	// cloned
	// from source app. Otherwise, application settings from source app are retained.
	AppSettingsOverrides map[string]string `json:"appSettingsOverrides,omitempty"`

	// CloneCustomHostNames: <code>true</code> to clone custom hostnames from source app; otherwise, <code>false</code>.
	CloneCustomHostNames *bool `json:"cloneCustomHostNames,omitempty"`

	// CloneSourceControl: <code>true</code> to clone source control from source app; otherwise, <code>false</code>.
	CloneSourceControl *bool `json:"cloneSourceControl,omitempty"`

	// ConfigureLoadBalancing: <code>true</code> to configure load balancing for source and destination app.
	ConfigureLoadBalancing *bool `json:"configureLoadBalancing,omitempty"`

	// CorrelationId: Correlation ID of cloning operation. This ID ties multiple cloning operations
	// together to use the same snapshot.
	CorrelationId *string `json:"correlationId,omitempty"`

	// HostingEnvironment: App Service Environment.
	HostingEnvironment *string `json:"hostingEnvironment,omitempty"`

	// Overwrite: <code>true</code> to overwrite destination app; otherwise, <code>false</code>.
	Overwrite *bool `json:"overwrite,omitempty"`

	// SourceWebAppId: ARM resource ID of the source app. App resource ID is of the form
	// /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName} for production slots
	// and
	// /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slotName} for
	// other slots.
	SourceWebAppId *string `json:"sourceWebAppId,omitempty"`

	// SourceWebAppLocation: Location of source app ex: West US or North Europe
	SourceWebAppLocation *string `json:"sourceWebAppLocation,omitempty"`

	// TrafficManagerProfileId: ARM resource ID of the Traffic Manager profile to use, if it exists. Traffic Manager resource
	// ID is of the form
	// /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{profileName}.
	TrafficManagerProfileId *string `json:"trafficManagerProfileId,omitempty"`

	// TrafficManagerProfileName: Name of Traffic Manager profile to create. This is only needed if Traffic Manager profile
	// does not already exist.
	TrafficManagerProfileName *string `json:"trafficManagerProfileName,omitempty"`
}

var _ genruntime.FromARMConverter = &CloningInfo_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (info *CloningInfo_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &CloningInfo_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (info *CloningInfo_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(CloningInfo_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CloningInfo_STATUSARM, got %T", armInput)
	}

	// Set property ‘AppSettingsOverrides’:
	if typedInput.AppSettingsOverrides != nil {
		info.AppSettingsOverrides = make(map[string]string, len(typedInput.AppSettingsOverrides))
		for key, value := range typedInput.AppSettingsOverrides {
			info.AppSettingsOverrides[key] = value
		}
	}

	// Set property ‘CloneCustomHostNames’:
	if typedInput.CloneCustomHostNames != nil {
		cloneCustomHostNames := *typedInput.CloneCustomHostNames
		info.CloneCustomHostNames = &cloneCustomHostNames
	}

	// Set property ‘CloneSourceControl’:
	if typedInput.CloneSourceControl != nil {
		cloneSourceControl := *typedInput.CloneSourceControl
		info.CloneSourceControl = &cloneSourceControl
	}

	// Set property ‘ConfigureLoadBalancing’:
	if typedInput.ConfigureLoadBalancing != nil {
		configureLoadBalancing := *typedInput.ConfigureLoadBalancing
		info.ConfigureLoadBalancing = &configureLoadBalancing
	}

	// Set property ‘CorrelationId’:
	if typedInput.CorrelationId != nil {
		correlationId := *typedInput.CorrelationId
		info.CorrelationId = &correlationId
	}

	// Set property ‘HostingEnvironment’:
	if typedInput.HostingEnvironment != nil {
		hostingEnvironment := *typedInput.HostingEnvironment
		info.HostingEnvironment = &hostingEnvironment
	}

	// Set property ‘Overwrite’:
	if typedInput.Overwrite != nil {
		overwrite := *typedInput.Overwrite
		info.Overwrite = &overwrite
	}

	// Set property ‘SourceWebAppId’:
	if typedInput.SourceWebAppId != nil {
		sourceWebAppId := *typedInput.SourceWebAppId
		info.SourceWebAppId = &sourceWebAppId
	}

	// Set property ‘SourceWebAppLocation’:
	if typedInput.SourceWebAppLocation != nil {
		sourceWebAppLocation := *typedInput.SourceWebAppLocation
		info.SourceWebAppLocation = &sourceWebAppLocation
	}

	// Set property ‘TrafficManagerProfileId’:
	if typedInput.TrafficManagerProfileId != nil {
		trafficManagerProfileId := *typedInput.TrafficManagerProfileId
		info.TrafficManagerProfileId = &trafficManagerProfileId
	}

	// Set property ‘TrafficManagerProfileName’:
	if typedInput.TrafficManagerProfileName != nil {
		trafficManagerProfileName := *typedInput.TrafficManagerProfileName
		info.TrafficManagerProfileName = &trafficManagerProfileName
	}

	// No error
	return nil
}

// AssignPropertiesFromCloningInfoSTATUS populates our CloningInfo_STATUS from the provided source CloningInfo_STATUS
func (info *CloningInfo_STATUS) AssignPropertiesFromCloningInfoSTATUS(source *v20220301s.CloningInfo_STATUS) error {

	// AppSettingsOverrides
	info.AppSettingsOverrides = genruntime.CloneMapOfStringToString(source.AppSettingsOverrides)

	// CloneCustomHostNames
	if source.CloneCustomHostNames != nil {
		cloneCustomHostName := *source.CloneCustomHostNames
		info.CloneCustomHostNames = &cloneCustomHostName
	} else {
		info.CloneCustomHostNames = nil
	}

	// CloneSourceControl
	if source.CloneSourceControl != nil {
		cloneSourceControl := *source.CloneSourceControl
		info.CloneSourceControl = &cloneSourceControl
	} else {
		info.CloneSourceControl = nil
	}

	// ConfigureLoadBalancing
	if source.ConfigureLoadBalancing != nil {
		configureLoadBalancing := *source.ConfigureLoadBalancing
		info.ConfigureLoadBalancing = &configureLoadBalancing
	} else {
		info.ConfigureLoadBalancing = nil
	}

	// CorrelationId
	info.CorrelationId = genruntime.ClonePointerToString(source.CorrelationId)

	// HostingEnvironment
	info.HostingEnvironment = genruntime.ClonePointerToString(source.HostingEnvironment)

	// Overwrite
	if source.Overwrite != nil {
		overwrite := *source.Overwrite
		info.Overwrite = &overwrite
	} else {
		info.Overwrite = nil
	}

	// SourceWebAppId
	info.SourceWebAppId = genruntime.ClonePointerToString(source.SourceWebAppId)

	// SourceWebAppLocation
	info.SourceWebAppLocation = genruntime.ClonePointerToString(source.SourceWebAppLocation)

	// TrafficManagerProfileId
	info.TrafficManagerProfileId = genruntime.ClonePointerToString(source.TrafficManagerProfileId)

	// TrafficManagerProfileName
	info.TrafficManagerProfileName = genruntime.ClonePointerToString(source.TrafficManagerProfileName)

	// No error
	return nil
}

// AssignPropertiesToCloningInfoSTATUS populates the provided destination CloningInfo_STATUS from our CloningInfo_STATUS
func (info *CloningInfo_STATUS) AssignPropertiesToCloningInfoSTATUS(destination *v20220301s.CloningInfo_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AppSettingsOverrides
	destination.AppSettingsOverrides = genruntime.CloneMapOfStringToString(info.AppSettingsOverrides)

	// CloneCustomHostNames
	if info.CloneCustomHostNames != nil {
		cloneCustomHostName := *info.CloneCustomHostNames
		destination.CloneCustomHostNames = &cloneCustomHostName
	} else {
		destination.CloneCustomHostNames = nil
	}

	// CloneSourceControl
	if info.CloneSourceControl != nil {
		cloneSourceControl := *info.CloneSourceControl
		destination.CloneSourceControl = &cloneSourceControl
	} else {
		destination.CloneSourceControl = nil
	}

	// ConfigureLoadBalancing
	if info.ConfigureLoadBalancing != nil {
		configureLoadBalancing := *info.ConfigureLoadBalancing
		destination.ConfigureLoadBalancing = &configureLoadBalancing
	} else {
		destination.ConfigureLoadBalancing = nil
	}

	// CorrelationId
	destination.CorrelationId = genruntime.ClonePointerToString(info.CorrelationId)

	// HostingEnvironment
	destination.HostingEnvironment = genruntime.ClonePointerToString(info.HostingEnvironment)

	// Overwrite
	if info.Overwrite != nil {
		overwrite := *info.Overwrite
		destination.Overwrite = &overwrite
	} else {
		destination.Overwrite = nil
	}

	// SourceWebAppId
	destination.SourceWebAppId = genruntime.ClonePointerToString(info.SourceWebAppId)

	// SourceWebAppLocation
	destination.SourceWebAppLocation = genruntime.ClonePointerToString(info.SourceWebAppLocation)

	// TrafficManagerProfileId
	destination.TrafficManagerProfileId = genruntime.ClonePointerToString(info.TrafficManagerProfileId)

	// TrafficManagerProfileName
	destination.TrafficManagerProfileName = genruntime.ClonePointerToString(info.TrafficManagerProfileName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2022-03-01/Microsoft.Web.json#/definitions/HostNameSslState
type HostNameSslState struct {
	// HostType: Indicates whether the hostname is a standard or repository hostname.
	HostType *HostNameSslStateHostType `json:"hostType,omitempty"`

	// Name: Hostname.
	Name *string `json:"name,omitempty"`

	// SslState: SSL type.
	SslState *HostNameSslStateSslState `json:"sslState,omitempty"`

	// Thumbprint: SSL certificate thumbprint.
	Thumbprint *string `json:"thumbprint,omitempty"`

	// ToUpdate: Set to <code>true</code> to update existing hostname.
	ToUpdate *bool `json:"toUpdate,omitempty"`

	// VirtualIP: Virtual IP address assigned to the hostname if IP based SSL is enabled.
	VirtualIP *string `json:"virtualIP,omitempty"`
}

var _ genruntime.ARMTransformer = &HostNameSslState{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (state *HostNameSslState) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if state == nil {
		return nil, nil
	}
	result := &HostNameSslStateARM{}

	// Set property ‘HostType’:
	if state.HostType != nil {
		hostType := *state.HostType
		result.HostType = &hostType
	}

	// Set property ‘Name’:
	if state.Name != nil {
		name := *state.Name
		result.Name = &name
	}

	// Set property ‘SslState’:
	if state.SslState != nil {
		sslState := *state.SslState
		result.SslState = &sslState
	}

	// Set property ‘Thumbprint’:
	if state.Thumbprint != nil {
		thumbprint := *state.Thumbprint
		result.Thumbprint = &thumbprint
	}

	// Set property ‘ToUpdate’:
	if state.ToUpdate != nil {
		toUpdate := *state.ToUpdate
		result.ToUpdate = &toUpdate
	}

	// Set property ‘VirtualIP’:
	if state.VirtualIP != nil {
		virtualIP := *state.VirtualIP
		result.VirtualIP = &virtualIP
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (state *HostNameSslState) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &HostNameSslStateARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (state *HostNameSslState) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(HostNameSslStateARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected HostNameSslStateARM, got %T", armInput)
	}

	// Set property ‘HostType’:
	if typedInput.HostType != nil {
		hostType := *typedInput.HostType
		state.HostType = &hostType
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		state.Name = &name
	}

	// Set property ‘SslState’:
	if typedInput.SslState != nil {
		sslState := *typedInput.SslState
		state.SslState = &sslState
	}

	// Set property ‘Thumbprint’:
	if typedInput.Thumbprint != nil {
		thumbprint := *typedInput.Thumbprint
		state.Thumbprint = &thumbprint
	}

	// Set property ‘ToUpdate’:
	if typedInput.ToUpdate != nil {
		toUpdate := *typedInput.ToUpdate
		state.ToUpdate = &toUpdate
	}

	// Set property ‘VirtualIP’:
	if typedInput.VirtualIP != nil {
		virtualIP := *typedInput.VirtualIP
		state.VirtualIP = &virtualIP
	}

	// No error
	return nil
}

// AssignPropertiesFromHostNameSslState populates our HostNameSslState from the provided source HostNameSslState
func (state *HostNameSslState) AssignPropertiesFromHostNameSslState(source *v20220301s.HostNameSslState) error {

	// HostType
	if source.HostType != nil {
		hostType := HostNameSslStateHostType(*source.HostType)
		state.HostType = &hostType
	} else {
		state.HostType = nil
	}

	// Name
	state.Name = genruntime.ClonePointerToString(source.Name)

	// SslState
	if source.SslState != nil {
		sslState := HostNameSslStateSslState(*source.SslState)
		state.SslState = &sslState
	} else {
		state.SslState = nil
	}

	// Thumbprint
	state.Thumbprint = genruntime.ClonePointerToString(source.Thumbprint)

	// ToUpdate
	if source.ToUpdate != nil {
		toUpdate := *source.ToUpdate
		state.ToUpdate = &toUpdate
	} else {
		state.ToUpdate = nil
	}

	// VirtualIP
	state.VirtualIP = genruntime.ClonePointerToString(source.VirtualIP)

	// No error
	return nil
}

// AssignPropertiesToHostNameSslState populates the provided destination HostNameSslState from our HostNameSslState
func (state *HostNameSslState) AssignPropertiesToHostNameSslState(destination *v20220301s.HostNameSslState) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HostType
	if state.HostType != nil {
		hostType := string(*state.HostType)
		destination.HostType = &hostType
	} else {
		destination.HostType = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(state.Name)

	// SslState
	if state.SslState != nil {
		sslState := string(*state.SslState)
		destination.SslState = &sslState
	} else {
		destination.SslState = nil
	}

	// Thumbprint
	destination.Thumbprint = genruntime.ClonePointerToString(state.Thumbprint)

	// ToUpdate
	if state.ToUpdate != nil {
		toUpdate := *state.ToUpdate
		destination.ToUpdate = &toUpdate
	} else {
		destination.ToUpdate = nil
	}

	// VirtualIP
	destination.VirtualIP = genruntime.ClonePointerToString(state.VirtualIP)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type HostNameSslState_STATUS struct {
	// HostType: Indicates whether the hostname is a standard or repository hostname.
	HostType *HostNameSslStateSTATUSHostType `json:"hostType,omitempty"`

	// Name: Hostname.
	Name *string `json:"name,omitempty"`

	// SslState: SSL type.
	SslState *HostNameSslStateSTATUSSslState `json:"sslState,omitempty"`

	// Thumbprint: SSL certificate thumbprint.
	Thumbprint *string `json:"thumbprint,omitempty"`

	// ToUpdate: Set to <code>true</code> to update existing hostname.
	ToUpdate *bool `json:"toUpdate,omitempty"`

	// VirtualIP: Virtual IP address assigned to the hostname if IP based SSL is enabled.
	VirtualIP *string `json:"virtualIP,omitempty"`
}

var _ genruntime.FromARMConverter = &HostNameSslState_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (state *HostNameSslState_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &HostNameSslState_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (state *HostNameSslState_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(HostNameSslState_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected HostNameSslState_STATUSARM, got %T", armInput)
	}

	// Set property ‘HostType’:
	if typedInput.HostType != nil {
		hostType := *typedInput.HostType
		state.HostType = &hostType
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		state.Name = &name
	}

	// Set property ‘SslState’:
	if typedInput.SslState != nil {
		sslState := *typedInput.SslState
		state.SslState = &sslState
	}

	// Set property ‘Thumbprint’:
	if typedInput.Thumbprint != nil {
		thumbprint := *typedInput.Thumbprint
		state.Thumbprint = &thumbprint
	}

	// Set property ‘ToUpdate’:
	if typedInput.ToUpdate != nil {
		toUpdate := *typedInput.ToUpdate
		state.ToUpdate = &toUpdate
	}

	// Set property ‘VirtualIP’:
	if typedInput.VirtualIP != nil {
		virtualIP := *typedInput.VirtualIP
		state.VirtualIP = &virtualIP
	}

	// No error
	return nil
}

// AssignPropertiesFromHostNameSslStateSTATUS populates our HostNameSslState_STATUS from the provided source HostNameSslState_STATUS
func (state *HostNameSslState_STATUS) AssignPropertiesFromHostNameSslStateSTATUS(source *v20220301s.HostNameSslState_STATUS) error {

	// HostType
	if source.HostType != nil {
		hostType := HostNameSslStateSTATUSHostType(*source.HostType)
		state.HostType = &hostType
	} else {
		state.HostType = nil
	}

	// Name
	state.Name = genruntime.ClonePointerToString(source.Name)

	// SslState
	if source.SslState != nil {
		sslState := HostNameSslStateSTATUSSslState(*source.SslState)
		state.SslState = &sslState
	} else {
		state.SslState = nil
	}

	// Thumbprint
	state.Thumbprint = genruntime.ClonePointerToString(source.Thumbprint)

	// ToUpdate
	if source.ToUpdate != nil {
		toUpdate := *source.ToUpdate
		state.ToUpdate = &toUpdate
	} else {
		state.ToUpdate = nil
	}

	// VirtualIP
	state.VirtualIP = genruntime.ClonePointerToString(source.VirtualIP)

	// No error
	return nil
}

// AssignPropertiesToHostNameSslStateSTATUS populates the provided destination HostNameSslState_STATUS from our HostNameSslState_STATUS
func (state *HostNameSslState_STATUS) AssignPropertiesToHostNameSslStateSTATUS(destination *v20220301s.HostNameSslState_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HostType
	if state.HostType != nil {
		hostType := string(*state.HostType)
		destination.HostType = &hostType
	} else {
		destination.HostType = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(state.Name)

	// SslState
	if state.SslState != nil {
		sslState := string(*state.SslState)
		destination.SslState = &sslState
	} else {
		destination.SslState = nil
	}

	// Thumbprint
	destination.Thumbprint = genruntime.ClonePointerToString(state.Thumbprint)

	// ToUpdate
	if state.ToUpdate != nil {
		toUpdate := *state.ToUpdate
		destination.ToUpdate = &toUpdate
	} else {
		destination.ToUpdate = nil
	}

	// VirtualIP
	destination.VirtualIP = genruntime.ClonePointerToString(state.VirtualIP)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2022-03-01/Microsoft.Web.json#/definitions/ManagedServiceIdentity
type ManagedServiceIdentity struct {
	// Type: Type of managed service identity.
	Type *ManagedServiceIdentityType `json:"type,omitempty"`

	// UserAssignedIdentities: The list of user assigned identities associated with the resource. The user identity dictionary
	// key references will be ARM resource ids in the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}
	UserAssignedIdentities map[string]v1.JSON `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedServiceIdentity{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (identity *ManagedServiceIdentity) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if identity == nil {
		return nil, nil
	}
	result := &ManagedServiceIdentityARM{}

	// Set property ‘Type’:
	if identity.Type != nil {
		typeVar := *identity.Type
		result.Type = &typeVar
	}

	// Set property ‘UserAssignedIdentities’:
	if identity.UserAssignedIdentities != nil {
		result.UserAssignedIdentities = make(map[string]v1.JSON, len(identity.UserAssignedIdentities))
		for key, value := range identity.UserAssignedIdentities {
			result.UserAssignedIdentities[key] = *value.DeepCopy()
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ManagedServiceIdentity) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedServiceIdentityARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ManagedServiceIdentity) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedServiceIdentityARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedServiceIdentityARM, got %T", armInput)
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		identity.Type = &typeVar
	}

	// Set property ‘UserAssignedIdentities’:
	if typedInput.UserAssignedIdentities != nil {
		identity.UserAssignedIdentities = make(map[string]v1.JSON, len(typedInput.UserAssignedIdentities))
		for key, value := range typedInput.UserAssignedIdentities {
			identity.UserAssignedIdentities[key] = *value.DeepCopy()
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedServiceIdentity populates our ManagedServiceIdentity from the provided source ManagedServiceIdentity
func (identity *ManagedServiceIdentity) AssignPropertiesFromManagedServiceIdentity(source *v20220301s.ManagedServiceIdentity) error {

	// Type
	if source.Type != nil {
		typeVar := ManagedServiceIdentityType(*source.Type)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]v1.JSON, len(source.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			userAssignedIdentityMap[userAssignedIdentityKey] = *userAssignedIdentityValue.DeepCopy()
		}
		identity.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedServiceIdentity populates the provided destination ManagedServiceIdentity from our ManagedServiceIdentity
func (identity *ManagedServiceIdentity) AssignPropertiesToManagedServiceIdentity(destination *v20220301s.ManagedServiceIdentity) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]v1.JSON, len(identity.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			userAssignedIdentityMap[userAssignedIdentityKey] = *userAssignedIdentityValue.DeepCopy()
		}
		destination.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedServiceIdentity_STATUS struct {
	// PrincipalId: Principal Id of managed service identity.
	PrincipalId *string `json:"principalId,omitempty"`

	// TenantId: Tenant of managed service identity.
	TenantId *string `json:"tenantId,omitempty"`

	// Type: Type of managed service identity.
	Type *ManagedServiceIdentitySTATUSType `json:"type,omitempty"`

	// UserAssignedIdentities: The list of user assigned identities associated with the resource. The user identity dictionary
	// key references will be ARM resource ids in the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}
	UserAssignedIdentities map[string]UserAssignedIdentity_STATUS `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedServiceIdentity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ManagedServiceIdentity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedServiceIdentity_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ManagedServiceIdentity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedServiceIdentity_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedServiceIdentity_STATUSARM, got %T", armInput)
	}

	// Set property ‘PrincipalId’:
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identity.PrincipalId = &principalId
	}

	// Set property ‘TenantId’:
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		identity.TenantId = &tenantId
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		identity.Type = &typeVar
	}

	// Set property ‘UserAssignedIdentities’:
	if typedInput.UserAssignedIdentities != nil {
		identity.UserAssignedIdentities = make(map[string]UserAssignedIdentity_STATUS, len(typedInput.UserAssignedIdentities))
		for key, value := range typedInput.UserAssignedIdentities {
			var value1 UserAssignedIdentity_STATUS
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			identity.UserAssignedIdentities[key] = value1
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromManagedServiceIdentitySTATUS populates our ManagedServiceIdentity_STATUS from the provided source ManagedServiceIdentity_STATUS
func (identity *ManagedServiceIdentity_STATUS) AssignPropertiesFromManagedServiceIdentitySTATUS(source *v20220301s.ManagedServiceIdentity_STATUS) error {

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// TenantId
	identity.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	if source.Type != nil {
		typeVar := ManagedServiceIdentitySTATUSType(*source.Type)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]UserAssignedIdentity_STATUS, len(source.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity UserAssignedIdentity_STATUS
			err := userAssignedIdentity.AssignPropertiesFromUserAssignedIdentitySTATUS(&userAssignedIdentityValue)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromUserAssignedIdentitySTATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedServiceIdentitySTATUS populates the provided destination ManagedServiceIdentity_STATUS from our ManagedServiceIdentity_STATUS
func (identity *ManagedServiceIdentity_STATUS) AssignPropertiesToManagedServiceIdentitySTATUS(destination *v20220301s.ManagedServiceIdentity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(identity.TenantId)

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]v20220301s.UserAssignedIdentity_STATUS, len(identity.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity v20220301s.UserAssignedIdentity_STATUS
			err := userAssignedIdentityValue.AssignPropertiesToUserAssignedIdentitySTATUS(&userAssignedIdentity)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToUserAssignedIdentitySTATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type SiteConfig_STATUS struct {
	// AcrUseManagedIdentityCreds: Flag to use Managed Identity Creds for ACR pull
	AcrUseManagedIdentityCreds *bool `json:"acrUseManagedIdentityCreds,omitempty"`

	// AcrUserManagedIdentityID: If using user managed identity, the user managed identity ClientId
	AcrUserManagedIdentityID *string `json:"acrUserManagedIdentityID,omitempty"`

	// AlwaysOn: <code>true</code> if Always On is enabled; otherwise, <code>false</code>.
	AlwaysOn *bool `json:"alwaysOn,omitempty"`

	// ApiDefinition: Information about the formal API definition for the app.
	ApiDefinition *ApiDefinitionInfo_STATUS `json:"apiDefinition,omitempty"`

	// ApiManagementConfig: Azure API management settings linked to the app.
	ApiManagementConfig *ApiManagementConfig_STATUS `json:"apiManagementConfig,omitempty"`

	// AppCommandLine: App command line to launch.
	AppCommandLine *string `json:"appCommandLine,omitempty"`

	// AppSettings: Application settings.
	AppSettings []NameValuePair_STATUS `json:"appSettings,omitempty"`

	// AutoHealEnabled: <code>true</code> if Auto Heal is enabled; otherwise, <code>false</code>.
	AutoHealEnabled *bool `json:"autoHealEnabled,omitempty"`

	// AutoHealRules: Auto Heal rules.
	AutoHealRules *AutoHealRules_STATUS `json:"autoHealRules,omitempty"`

	// AutoSwapSlotName: Auto-swap slot name.
	AutoSwapSlotName *string `json:"autoSwapSlotName,omitempty"`

	// AzureStorageAccounts: List of Azure Storage Accounts.
	AzureStorageAccounts map[string]AzureStorageInfoValue_STATUS `json:"azureStorageAccounts,omitempty"`

	// ConnectionStrings: Connection strings.
	ConnectionStrings []ConnStringInfo_STATUS `json:"connectionStrings,omitempty"`

	// Cors: Cross-Origin Resource Sharing (CORS) settings.
	Cors *CorsSettings_STATUS `json:"cors,omitempty"`

	// DefaultDocuments: Default documents.
	DefaultDocuments []string `json:"defaultDocuments,omitempty"`

	// DetailedErrorLoggingEnabled: <code>true</code> if detailed error logging is enabled; otherwise, <code>false</code>.
	DetailedErrorLoggingEnabled *bool `json:"detailedErrorLoggingEnabled,omitempty"`

	// DocumentRoot: Document root.
	DocumentRoot *string `json:"documentRoot,omitempty"`

	// Experiments: This is work around for polymorphic types.
	Experiments *Experiments_STATUS `json:"experiments,omitempty"`

	// FtpsState: State of FTP / FTPS service
	FtpsState *SiteConfigSTATUSFtpsState `json:"ftpsState,omitempty"`

	// FunctionAppScaleLimit: Maximum number of workers that a site can scale out to.
	// This setting only applies to the Consumption and Elastic Premium Plans
	FunctionAppScaleLimit *int `json:"functionAppScaleLimit,omitempty"`

	// FunctionsRuntimeScaleMonitoringEnabled: Gets or sets a value indicating whether functions runtime scale monitoring is
	// enabled. When enabled,
	// the ScaleController will not monitor event sources directly, but will instead call to the
	// runtime to get scale status.
	FunctionsRuntimeScaleMonitoringEnabled *bool `json:"functionsRuntimeScaleMonitoringEnabled,omitempty"`

	// HandlerMappings: Handler mappings.
	HandlerMappings []HandlerMapping_STATUS `json:"handlerMappings,omitempty"`

	// HealthCheckPath: Health check path
	HealthCheckPath *string `json:"healthCheckPath,omitempty"`

	// Http20Enabled: Http20Enabled: configures a web site to allow clients to connect over http2.0
	Http20Enabled *bool `json:"http20Enabled,omitempty"`

	// HttpLoggingEnabled: <code>true</code> if HTTP logging is enabled; otherwise, <code>false</code>.
	HttpLoggingEnabled *bool `json:"httpLoggingEnabled,omitempty"`

	// IpSecurityRestrictions: IP security restrictions for main.
	IpSecurityRestrictions []IpSecurityRestriction_STATUS `json:"ipSecurityRestrictions,omitempty"`

	// JavaContainer: Java container.
	JavaContainer *string `json:"javaContainer,omitempty"`

	// JavaContainerVersion: Java container version.
	JavaContainerVersion *string `json:"javaContainerVersion,omitempty"`

	// JavaVersion: Java version.
	JavaVersion *string `json:"javaVersion,omitempty"`

	// KeyVaultReferenceIdentity: Identity to use for Key Vault Reference authentication.
	KeyVaultReferenceIdentity *string `json:"keyVaultReferenceIdentity,omitempty"`

	// Limits: Site limits.
	Limits *SiteLimits_STATUS `json:"limits,omitempty"`

	// LinuxFxVersion: Linux App Framework and version
	LinuxFxVersion *string `json:"linuxFxVersion,omitempty"`

	// LoadBalancing: Site load balancing.
	LoadBalancing *SiteConfigSTATUSLoadBalancing `json:"loadBalancing,omitempty"`

	// LocalMySqlEnabled: <code>true</code> to enable local MySQL; otherwise, <code>false</code>.
	LocalMySqlEnabled *bool `json:"localMySqlEnabled,omitempty"`

	// LogsDirectorySizeLimit: HTTP logs directory size limit.
	LogsDirectorySizeLimit *int `json:"logsDirectorySizeLimit,omitempty"`

	// MachineKey: Site MachineKey.
	MachineKey *SiteMachineKey_STATUS `json:"machineKey,omitempty"`

	// ManagedPipelineMode: Managed pipeline mode.
	ManagedPipelineMode *SiteConfigSTATUSManagedPipelineMode `json:"managedPipelineMode,omitempty"`

	// ManagedServiceIdentityId: Managed Service Identity Id
	ManagedServiceIdentityId *int `json:"managedServiceIdentityId,omitempty"`

	// MinTlsVersion: MinTlsVersion: configures the minimum version of TLS required for SSL requests
	MinTlsVersion *SiteConfigSTATUSMinTlsVersion `json:"minTlsVersion,omitempty"`

	// MinimumElasticInstanceCount: Number of minimum instance count for a site
	// This setting only applies to the Elastic Plans
	MinimumElasticInstanceCount *int `json:"minimumElasticInstanceCount,omitempty"`

	// NetFrameworkVersion: .NET Framework version.
	NetFrameworkVersion *string `json:"netFrameworkVersion,omitempty"`

	// NodeVersion: Version of Node.js.
	NodeVersion *string `json:"nodeVersion,omitempty"`

	// NumberOfWorkers: Number of workers.
	NumberOfWorkers *int `json:"numberOfWorkers,omitempty"`

	// PhpVersion: Version of PHP.
	PhpVersion *string `json:"phpVersion,omitempty"`

	// PowerShellVersion: Version of PowerShell.
	PowerShellVersion *string `json:"powerShellVersion,omitempty"`

	// PreWarmedInstanceCount: Number of preWarmed instances.
	// This setting only applies to the Consumption and Elastic Plans
	PreWarmedInstanceCount *int `json:"preWarmedInstanceCount,omitempty"`

	// PublicNetworkAccess: Property to allow or block all public traffic.
	PublicNetworkAccess *string `json:"publicNetworkAccess,omitempty"`

	// PublishingUsername: Publishing user name.
	PublishingUsername *string `json:"publishingUsername,omitempty"`

	// Push: Push endpoint settings.
	Push *PushSettings_STATUS `json:"push,omitempty"`

	// PythonVersion: Version of Python.
	PythonVersion *string `json:"pythonVersion,omitempty"`

	// RemoteDebuggingEnabled: <code>true</code> if remote debugging is enabled; otherwise, <code>false</code>.
	RemoteDebuggingEnabled *bool `json:"remoteDebuggingEnabled,omitempty"`

	// RemoteDebuggingVersion: Remote debugging version.
	RemoteDebuggingVersion *string `json:"remoteDebuggingVersion,omitempty"`

	// RequestTracingEnabled: <code>true</code> if request tracing is enabled; otherwise, <code>false</code>.
	RequestTracingEnabled *bool `json:"requestTracingEnabled,omitempty"`

	// RequestTracingExpirationTime: Request tracing expiration time.
	RequestTracingExpirationTime *string `json:"requestTracingExpirationTime,omitempty"`

	// ScmIpSecurityRestrictions: IP security restrictions for scm.
	ScmIpSecurityRestrictions []IpSecurityRestriction_STATUS `json:"scmIpSecurityRestrictions,omitempty"`

	// ScmIpSecurityRestrictionsUseMain: IP security restrictions for scm to use main.
	ScmIpSecurityRestrictionsUseMain *bool `json:"scmIpSecurityRestrictionsUseMain,omitempty"`

	// ScmMinTlsVersion: ScmMinTlsVersion: configures the minimum version of TLS required for SSL requests for SCM site
	ScmMinTlsVersion *SiteConfigSTATUSScmMinTlsVersion `json:"scmMinTlsVersion,omitempty"`

	// ScmType: SCM type.
	ScmType *SiteConfigSTATUSScmType `json:"scmType,omitempty"`

	// TracingOptions: Tracing options.
	TracingOptions *string `json:"tracingOptions,omitempty"`

	// Use32BitWorkerProcess: <code>true</code> to use 32-bit worker process; otherwise, <code>false</code>.
	Use32BitWorkerProcess *bool `json:"use32BitWorkerProcess,omitempty"`

	// VirtualApplications: Virtual applications.
	VirtualApplications []VirtualApplication_STATUS `json:"virtualApplications,omitempty"`

	// VnetName: Virtual Network name.
	VnetName *string `json:"vnetName,omitempty"`

	// VnetPrivatePortsCount: The number of private ports assigned to this app. These will be assigned dynamically on runtime.
	VnetPrivatePortsCount *int `json:"vnetPrivatePortsCount,omitempty"`

	// VnetRouteAllEnabled: Virtual Network Route All enabled. This causes all outbound traffic to have Virtual Network
	// Security Groups and User Defined Routes applied.
	VnetRouteAllEnabled *bool `json:"vnetRouteAllEnabled,omitempty"`

	// WebSocketsEnabled: <code>true</code> if WebSocket is enabled; otherwise, <code>false</code>.
	WebSocketsEnabled *bool `json:"webSocketsEnabled,omitempty"`

	// WebsiteTimeZone: Sets the time zone a site uses for generating timestamps. Compatible with Linux and Windows App
	// Service. Setting the WEBSITE_TIME_ZONE app setting takes precedence over this config. For Linux, expects tz database
	// values https://www.iana.org/time-zones (for a quick reference see
	// https://en.wikipedia.org/wiki/List_of_tz_database_time_zones). For Windows, expects one of the time zones listed under
	// HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Time Zones
	WebsiteTimeZone *string `json:"websiteTimeZone,omitempty"`

	// WindowsFxVersion: Xenon App Framework and version
	WindowsFxVersion *string `json:"windowsFxVersion,omitempty"`

	// XManagedServiceIdentityId: Explicit Managed Service Identity Id
	XManagedServiceIdentityId *int `json:"xManagedServiceIdentityId,omitempty"`
}

var _ genruntime.FromARMConverter = &SiteConfig_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (config *SiteConfig_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SiteConfig_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (config *SiteConfig_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SiteConfig_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SiteConfig_STATUSARM, got %T", armInput)
	}

	// Set property ‘AcrUseManagedIdentityCreds’:
	if typedInput.AcrUseManagedIdentityCreds != nil {
		acrUseManagedIdentityCreds := *typedInput.AcrUseManagedIdentityCreds
		config.AcrUseManagedIdentityCreds = &acrUseManagedIdentityCreds
	}

	// Set property ‘AcrUserManagedIdentityID’:
	if typedInput.AcrUserManagedIdentityID != nil {
		acrUserManagedIdentityID := *typedInput.AcrUserManagedIdentityID
		config.AcrUserManagedIdentityID = &acrUserManagedIdentityID
	}

	// Set property ‘AlwaysOn’:
	if typedInput.AlwaysOn != nil {
		alwaysOn := *typedInput.AlwaysOn
		config.AlwaysOn = &alwaysOn
	}

	// Set property ‘ApiDefinition’:
	if typedInput.ApiDefinition != nil {
		var apiDefinition1 ApiDefinitionInfo_STATUS
		err := apiDefinition1.PopulateFromARM(owner, *typedInput.ApiDefinition)
		if err != nil {
			return err
		}
		apiDefinition := apiDefinition1
		config.ApiDefinition = &apiDefinition
	}

	// Set property ‘ApiManagementConfig’:
	if typedInput.ApiManagementConfig != nil {
		var apiManagementConfig1 ApiManagementConfig_STATUS
		err := apiManagementConfig1.PopulateFromARM(owner, *typedInput.ApiManagementConfig)
		if err != nil {
			return err
		}
		apiManagementConfig := apiManagementConfig1
		config.ApiManagementConfig = &apiManagementConfig
	}

	// Set property ‘AppCommandLine’:
	if typedInput.AppCommandLine != nil {
		appCommandLine := *typedInput.AppCommandLine
		config.AppCommandLine = &appCommandLine
	}

	// Set property ‘AppSettings’:
	for _, item := range typedInput.AppSettings {
		var item1 NameValuePair_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		config.AppSettings = append(config.AppSettings, item1)
	}

	// Set property ‘AutoHealEnabled’:
	if typedInput.AutoHealEnabled != nil {
		autoHealEnabled := *typedInput.AutoHealEnabled
		config.AutoHealEnabled = &autoHealEnabled
	}

	// Set property ‘AutoHealRules’:
	if typedInput.AutoHealRules != nil {
		var autoHealRules1 AutoHealRules_STATUS
		err := autoHealRules1.PopulateFromARM(owner, *typedInput.AutoHealRules)
		if err != nil {
			return err
		}
		autoHealRules := autoHealRules1
		config.AutoHealRules = &autoHealRules
	}

	// Set property ‘AutoSwapSlotName’:
	if typedInput.AutoSwapSlotName != nil {
		autoSwapSlotName := *typedInput.AutoSwapSlotName
		config.AutoSwapSlotName = &autoSwapSlotName
	}

	// Set property ‘AzureStorageAccounts’:
	if typedInput.AzureStorageAccounts != nil {
		config.AzureStorageAccounts = make(map[string]AzureStorageInfoValue_STATUS, len(typedInput.AzureStorageAccounts))
		for key, value := range typedInput.AzureStorageAccounts {
			var value1 AzureStorageInfoValue_STATUS
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			config.AzureStorageAccounts[key] = value1
		}
	}

	// Set property ‘ConnectionStrings’:
	for _, item := range typedInput.ConnectionStrings {
		var item1 ConnStringInfo_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		config.ConnectionStrings = append(config.ConnectionStrings, item1)
	}

	// Set property ‘Cors’:
	if typedInput.Cors != nil {
		var cors1 CorsSettings_STATUS
		err := cors1.PopulateFromARM(owner, *typedInput.Cors)
		if err != nil {
			return err
		}
		cors := cors1
		config.Cors = &cors
	}

	// Set property ‘DefaultDocuments’:
	for _, item := range typedInput.DefaultDocuments {
		config.DefaultDocuments = append(config.DefaultDocuments, item)
	}

	// Set property ‘DetailedErrorLoggingEnabled’:
	if typedInput.DetailedErrorLoggingEnabled != nil {
		detailedErrorLoggingEnabled := *typedInput.DetailedErrorLoggingEnabled
		config.DetailedErrorLoggingEnabled = &detailedErrorLoggingEnabled
	}

	// Set property ‘DocumentRoot’:
	if typedInput.DocumentRoot != nil {
		documentRoot := *typedInput.DocumentRoot
		config.DocumentRoot = &documentRoot
	}

	// Set property ‘Experiments’:
	if typedInput.Experiments != nil {
		var experiments1 Experiments_STATUS
		err := experiments1.PopulateFromARM(owner, *typedInput.Experiments)
		if err != nil {
			return err
		}
		experiments := experiments1
		config.Experiments = &experiments
	}

	// Set property ‘FtpsState’:
	if typedInput.FtpsState != nil {
		ftpsState := *typedInput.FtpsState
		config.FtpsState = &ftpsState
	}

	// Set property ‘FunctionAppScaleLimit’:
	if typedInput.FunctionAppScaleLimit != nil {
		functionAppScaleLimit := *typedInput.FunctionAppScaleLimit
		config.FunctionAppScaleLimit = &functionAppScaleLimit
	}

	// Set property ‘FunctionsRuntimeScaleMonitoringEnabled’:
	if typedInput.FunctionsRuntimeScaleMonitoringEnabled != nil {
		functionsRuntimeScaleMonitoringEnabled := *typedInput.FunctionsRuntimeScaleMonitoringEnabled
		config.FunctionsRuntimeScaleMonitoringEnabled = &functionsRuntimeScaleMonitoringEnabled
	}

	// Set property ‘HandlerMappings’:
	for _, item := range typedInput.HandlerMappings {
		var item1 HandlerMapping_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		config.HandlerMappings = append(config.HandlerMappings, item1)
	}

	// Set property ‘HealthCheckPath’:
	if typedInput.HealthCheckPath != nil {
		healthCheckPath := *typedInput.HealthCheckPath
		config.HealthCheckPath = &healthCheckPath
	}

	// Set property ‘Http20Enabled’:
	if typedInput.Http20Enabled != nil {
		http20Enabled := *typedInput.Http20Enabled
		config.Http20Enabled = &http20Enabled
	}

	// Set property ‘HttpLoggingEnabled’:
	if typedInput.HttpLoggingEnabled != nil {
		httpLoggingEnabled := *typedInput.HttpLoggingEnabled
		config.HttpLoggingEnabled = &httpLoggingEnabled
	}

	// Set property ‘IpSecurityRestrictions’:
	for _, item := range typedInput.IpSecurityRestrictions {
		var item1 IpSecurityRestriction_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		config.IpSecurityRestrictions = append(config.IpSecurityRestrictions, item1)
	}

	// Set property ‘JavaContainer’:
	if typedInput.JavaContainer != nil {
		javaContainer := *typedInput.JavaContainer
		config.JavaContainer = &javaContainer
	}

	// Set property ‘JavaContainerVersion’:
	if typedInput.JavaContainerVersion != nil {
		javaContainerVersion := *typedInput.JavaContainerVersion
		config.JavaContainerVersion = &javaContainerVersion
	}

	// Set property ‘JavaVersion’:
	if typedInput.JavaVersion != nil {
		javaVersion := *typedInput.JavaVersion
		config.JavaVersion = &javaVersion
	}

	// Set property ‘KeyVaultReferenceIdentity’:
	if typedInput.KeyVaultReferenceIdentity != nil {
		keyVaultReferenceIdentity := *typedInput.KeyVaultReferenceIdentity
		config.KeyVaultReferenceIdentity = &keyVaultReferenceIdentity
	}

	// Set property ‘Limits’:
	if typedInput.Limits != nil {
		var limits1 SiteLimits_STATUS
		err := limits1.PopulateFromARM(owner, *typedInput.Limits)
		if err != nil {
			return err
		}
		limits := limits1
		config.Limits = &limits
	}

	// Set property ‘LinuxFxVersion’:
	if typedInput.LinuxFxVersion != nil {
		linuxFxVersion := *typedInput.LinuxFxVersion
		config.LinuxFxVersion = &linuxFxVersion
	}

	// Set property ‘LoadBalancing’:
	if typedInput.LoadBalancing != nil {
		loadBalancing := *typedInput.LoadBalancing
		config.LoadBalancing = &loadBalancing
	}

	// Set property ‘LocalMySqlEnabled’:
	if typedInput.LocalMySqlEnabled != nil {
		localMySqlEnabled := *typedInput.LocalMySqlEnabled
		config.LocalMySqlEnabled = &localMySqlEnabled
	}

	// Set property ‘LogsDirectorySizeLimit’:
	if typedInput.LogsDirectorySizeLimit != nil {
		logsDirectorySizeLimit := *typedInput.LogsDirectorySizeLimit
		config.LogsDirectorySizeLimit = &logsDirectorySizeLimit
	}

	// Set property ‘MachineKey’:
	if typedInput.MachineKey != nil {
		var machineKey1 SiteMachineKey_STATUS
		err := machineKey1.PopulateFromARM(owner, *typedInput.MachineKey)
		if err != nil {
			return err
		}
		machineKey := machineKey1
		config.MachineKey = &machineKey
	}

	// Set property ‘ManagedPipelineMode’:
	if typedInput.ManagedPipelineMode != nil {
		managedPipelineMode := *typedInput.ManagedPipelineMode
		config.ManagedPipelineMode = &managedPipelineMode
	}

	// Set property ‘ManagedServiceIdentityId’:
	if typedInput.ManagedServiceIdentityId != nil {
		managedServiceIdentityId := *typedInput.ManagedServiceIdentityId
		config.ManagedServiceIdentityId = &managedServiceIdentityId
	}

	// Set property ‘MinTlsVersion’:
	if typedInput.MinTlsVersion != nil {
		minTlsVersion := *typedInput.MinTlsVersion
		config.MinTlsVersion = &minTlsVersion
	}

	// Set property ‘MinimumElasticInstanceCount’:
	if typedInput.MinimumElasticInstanceCount != nil {
		minimumElasticInstanceCount := *typedInput.MinimumElasticInstanceCount
		config.MinimumElasticInstanceCount = &minimumElasticInstanceCount
	}

	// Set property ‘NetFrameworkVersion’:
	if typedInput.NetFrameworkVersion != nil {
		netFrameworkVersion := *typedInput.NetFrameworkVersion
		config.NetFrameworkVersion = &netFrameworkVersion
	}

	// Set property ‘NodeVersion’:
	if typedInput.NodeVersion != nil {
		nodeVersion := *typedInput.NodeVersion
		config.NodeVersion = &nodeVersion
	}

	// Set property ‘NumberOfWorkers’:
	if typedInput.NumberOfWorkers != nil {
		numberOfWorkers := *typedInput.NumberOfWorkers
		config.NumberOfWorkers = &numberOfWorkers
	}

	// Set property ‘PhpVersion’:
	if typedInput.PhpVersion != nil {
		phpVersion := *typedInput.PhpVersion
		config.PhpVersion = &phpVersion
	}

	// Set property ‘PowerShellVersion’:
	if typedInput.PowerShellVersion != nil {
		powerShellVersion := *typedInput.PowerShellVersion
		config.PowerShellVersion = &powerShellVersion
	}

	// Set property ‘PreWarmedInstanceCount’:
	if typedInput.PreWarmedInstanceCount != nil {
		preWarmedInstanceCount := *typedInput.PreWarmedInstanceCount
		config.PreWarmedInstanceCount = &preWarmedInstanceCount
	}

	// Set property ‘PublicNetworkAccess’:
	if typedInput.PublicNetworkAccess != nil {
		publicNetworkAccess := *typedInput.PublicNetworkAccess
		config.PublicNetworkAccess = &publicNetworkAccess
	}

	// Set property ‘PublishingUsername’:
	if typedInput.PublishingUsername != nil {
		publishingUsername := *typedInput.PublishingUsername
		config.PublishingUsername = &publishingUsername
	}

	// Set property ‘Push’:
	if typedInput.Push != nil {
		var push1 PushSettings_STATUS
		err := push1.PopulateFromARM(owner, *typedInput.Push)
		if err != nil {
			return err
		}
		push := push1
		config.Push = &push
	}

	// Set property ‘PythonVersion’:
	if typedInput.PythonVersion != nil {
		pythonVersion := *typedInput.PythonVersion
		config.PythonVersion = &pythonVersion
	}

	// Set property ‘RemoteDebuggingEnabled’:
	if typedInput.RemoteDebuggingEnabled != nil {
		remoteDebuggingEnabled := *typedInput.RemoteDebuggingEnabled
		config.RemoteDebuggingEnabled = &remoteDebuggingEnabled
	}

	// Set property ‘RemoteDebuggingVersion’:
	if typedInput.RemoteDebuggingVersion != nil {
		remoteDebuggingVersion := *typedInput.RemoteDebuggingVersion
		config.RemoteDebuggingVersion = &remoteDebuggingVersion
	}

	// Set property ‘RequestTracingEnabled’:
	if typedInput.RequestTracingEnabled != nil {
		requestTracingEnabled := *typedInput.RequestTracingEnabled
		config.RequestTracingEnabled = &requestTracingEnabled
	}

	// Set property ‘RequestTracingExpirationTime’:
	if typedInput.RequestTracingExpirationTime != nil {
		requestTracingExpirationTime := *typedInput.RequestTracingExpirationTime
		config.RequestTracingExpirationTime = &requestTracingExpirationTime
	}

	// Set property ‘ScmIpSecurityRestrictions’:
	for _, item := range typedInput.ScmIpSecurityRestrictions {
		var item1 IpSecurityRestriction_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		config.ScmIpSecurityRestrictions = append(config.ScmIpSecurityRestrictions, item1)
	}

	// Set property ‘ScmIpSecurityRestrictionsUseMain’:
	if typedInput.ScmIpSecurityRestrictionsUseMain != nil {
		scmIpSecurityRestrictionsUseMain := *typedInput.ScmIpSecurityRestrictionsUseMain
		config.ScmIpSecurityRestrictionsUseMain = &scmIpSecurityRestrictionsUseMain
	}

	// Set property ‘ScmMinTlsVersion’:
	if typedInput.ScmMinTlsVersion != nil {
		scmMinTlsVersion := *typedInput.ScmMinTlsVersion
		config.ScmMinTlsVersion = &scmMinTlsVersion
	}

	// Set property ‘ScmType’:
	if typedInput.ScmType != nil {
		scmType := *typedInput.ScmType
		config.ScmType = &scmType
	}

	// Set property ‘TracingOptions’:
	if typedInput.TracingOptions != nil {
		tracingOptions := *typedInput.TracingOptions
		config.TracingOptions = &tracingOptions
	}

	// Set property ‘Use32BitWorkerProcess’:
	if typedInput.Use32BitWorkerProcess != nil {
		use32BitWorkerProcess := *typedInput.Use32BitWorkerProcess
		config.Use32BitWorkerProcess = &use32BitWorkerProcess
	}

	// Set property ‘VirtualApplications’:
	for _, item := range typedInput.VirtualApplications {
		var item1 VirtualApplication_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		config.VirtualApplications = append(config.VirtualApplications, item1)
	}

	// Set property ‘VnetName’:
	if typedInput.VnetName != nil {
		vnetName := *typedInput.VnetName
		config.VnetName = &vnetName
	}

	// Set property ‘VnetPrivatePortsCount’:
	if typedInput.VnetPrivatePortsCount != nil {
		vnetPrivatePortsCount := *typedInput.VnetPrivatePortsCount
		config.VnetPrivatePortsCount = &vnetPrivatePortsCount
	}

	// Set property ‘VnetRouteAllEnabled’:
	if typedInput.VnetRouteAllEnabled != nil {
		vnetRouteAllEnabled := *typedInput.VnetRouteAllEnabled
		config.VnetRouteAllEnabled = &vnetRouteAllEnabled
	}

	// Set property ‘WebSocketsEnabled’:
	if typedInput.WebSocketsEnabled != nil {
		webSocketsEnabled := *typedInput.WebSocketsEnabled
		config.WebSocketsEnabled = &webSocketsEnabled
	}

	// Set property ‘WebsiteTimeZone’:
	if typedInput.WebsiteTimeZone != nil {
		websiteTimeZone := *typedInput.WebsiteTimeZone
		config.WebsiteTimeZone = &websiteTimeZone
	}

	// Set property ‘WindowsFxVersion’:
	if typedInput.WindowsFxVersion != nil {
		windowsFxVersion := *typedInput.WindowsFxVersion
		config.WindowsFxVersion = &windowsFxVersion
	}

	// Set property ‘XManagedServiceIdentityId’:
	if typedInput.XManagedServiceIdentityId != nil {
		xManagedServiceIdentityId := *typedInput.XManagedServiceIdentityId
		config.XManagedServiceIdentityId = &xManagedServiceIdentityId
	}

	// No error
	return nil
}

// AssignPropertiesFromSiteConfigSTATUS populates our SiteConfig_STATUS from the provided source SiteConfig_STATUS
func (config *SiteConfig_STATUS) AssignPropertiesFromSiteConfigSTATUS(source *v20220301s.SiteConfig_STATUS) error {

	// AcrUseManagedIdentityCreds
	if source.AcrUseManagedIdentityCreds != nil {
		acrUseManagedIdentityCred := *source.AcrUseManagedIdentityCreds
		config.AcrUseManagedIdentityCreds = &acrUseManagedIdentityCred
	} else {
		config.AcrUseManagedIdentityCreds = nil
	}

	// AcrUserManagedIdentityID
	config.AcrUserManagedIdentityID = genruntime.ClonePointerToString(source.AcrUserManagedIdentityID)

	// AlwaysOn
	if source.AlwaysOn != nil {
		alwaysOn := *source.AlwaysOn
		config.AlwaysOn = &alwaysOn
	} else {
		config.AlwaysOn = nil
	}

	// ApiDefinition
	if source.ApiDefinition != nil {
		var apiDefinition ApiDefinitionInfo_STATUS
		err := apiDefinition.AssignPropertiesFromApiDefinitionInfoSTATUS(source.ApiDefinition)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromApiDefinitionInfoSTATUS() to populate field ApiDefinition")
		}
		config.ApiDefinition = &apiDefinition
	} else {
		config.ApiDefinition = nil
	}

	// ApiManagementConfig
	if source.ApiManagementConfig != nil {
		var apiManagementConfig ApiManagementConfig_STATUS
		err := apiManagementConfig.AssignPropertiesFromApiManagementConfigSTATUS(source.ApiManagementConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromApiManagementConfigSTATUS() to populate field ApiManagementConfig")
		}
		config.ApiManagementConfig = &apiManagementConfig
	} else {
		config.ApiManagementConfig = nil
	}

	// AppCommandLine
	config.AppCommandLine = genruntime.ClonePointerToString(source.AppCommandLine)

	// AppSettings
	if source.AppSettings != nil {
		appSettingList := make([]NameValuePair_STATUS, len(source.AppSettings))
		for appSettingIndex, appSettingItem := range source.AppSettings {
			// Shadow the loop variable to avoid aliasing
			appSettingItem := appSettingItem
			var appSetting NameValuePair_STATUS
			err := appSetting.AssignPropertiesFromNameValuePairSTATUS(&appSettingItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromNameValuePairSTATUS() to populate field AppSettings")
			}
			appSettingList[appSettingIndex] = appSetting
		}
		config.AppSettings = appSettingList
	} else {
		config.AppSettings = nil
	}

	// AutoHealEnabled
	if source.AutoHealEnabled != nil {
		autoHealEnabled := *source.AutoHealEnabled
		config.AutoHealEnabled = &autoHealEnabled
	} else {
		config.AutoHealEnabled = nil
	}

	// AutoHealRules
	if source.AutoHealRules != nil {
		var autoHealRule AutoHealRules_STATUS
		err := autoHealRule.AssignPropertiesFromAutoHealRulesSTATUS(source.AutoHealRules)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromAutoHealRulesSTATUS() to populate field AutoHealRules")
		}
		config.AutoHealRules = &autoHealRule
	} else {
		config.AutoHealRules = nil
	}

	// AutoSwapSlotName
	config.AutoSwapSlotName = genruntime.ClonePointerToString(source.AutoSwapSlotName)

	// AzureStorageAccounts
	if source.AzureStorageAccounts != nil {
		azureStorageAccountMap := make(map[string]AzureStorageInfoValue_STATUS, len(source.AzureStorageAccounts))
		for azureStorageAccountKey, azureStorageAccountValue := range source.AzureStorageAccounts {
			// Shadow the loop variable to avoid aliasing
			azureStorageAccountValue := azureStorageAccountValue
			var azureStorageAccount AzureStorageInfoValue_STATUS
			err := azureStorageAccount.AssignPropertiesFromAzureStorageInfoValueSTATUS(&azureStorageAccountValue)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromAzureStorageInfoValueSTATUS() to populate field AzureStorageAccounts")
			}
			azureStorageAccountMap[azureStorageAccountKey] = azureStorageAccount
		}
		config.AzureStorageAccounts = azureStorageAccountMap
	} else {
		config.AzureStorageAccounts = nil
	}

	// ConnectionStrings
	if source.ConnectionStrings != nil {
		connectionStringList := make([]ConnStringInfo_STATUS, len(source.ConnectionStrings))
		for connectionStringIndex, connectionStringItem := range source.ConnectionStrings {
			// Shadow the loop variable to avoid aliasing
			connectionStringItem := connectionStringItem
			var connectionString ConnStringInfo_STATUS
			err := connectionString.AssignPropertiesFromConnStringInfoSTATUS(&connectionStringItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromConnStringInfoSTATUS() to populate field ConnectionStrings")
			}
			connectionStringList[connectionStringIndex] = connectionString
		}
		config.ConnectionStrings = connectionStringList
	} else {
		config.ConnectionStrings = nil
	}

	// Cors
	if source.Cors != nil {
		var cor CorsSettings_STATUS
		err := cor.AssignPropertiesFromCorsSettingsSTATUS(source.Cors)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromCorsSettingsSTATUS() to populate field Cors")
		}
		config.Cors = &cor
	} else {
		config.Cors = nil
	}

	// DefaultDocuments
	config.DefaultDocuments = genruntime.CloneSliceOfString(source.DefaultDocuments)

	// DetailedErrorLoggingEnabled
	if source.DetailedErrorLoggingEnabled != nil {
		detailedErrorLoggingEnabled := *source.DetailedErrorLoggingEnabled
		config.DetailedErrorLoggingEnabled = &detailedErrorLoggingEnabled
	} else {
		config.DetailedErrorLoggingEnabled = nil
	}

	// DocumentRoot
	config.DocumentRoot = genruntime.ClonePointerToString(source.DocumentRoot)

	// Experiments
	if source.Experiments != nil {
		var experiment Experiments_STATUS
		err := experiment.AssignPropertiesFromExperimentsSTATUS(source.Experiments)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromExperimentsSTATUS() to populate field Experiments")
		}
		config.Experiments = &experiment
	} else {
		config.Experiments = nil
	}

	// FtpsState
	if source.FtpsState != nil {
		ftpsState := SiteConfigSTATUSFtpsState(*source.FtpsState)
		config.FtpsState = &ftpsState
	} else {
		config.FtpsState = nil
	}

	// FunctionAppScaleLimit
	config.FunctionAppScaleLimit = genruntime.ClonePointerToInt(source.FunctionAppScaleLimit)

	// FunctionsRuntimeScaleMonitoringEnabled
	if source.FunctionsRuntimeScaleMonitoringEnabled != nil {
		functionsRuntimeScaleMonitoringEnabled := *source.FunctionsRuntimeScaleMonitoringEnabled
		config.FunctionsRuntimeScaleMonitoringEnabled = &functionsRuntimeScaleMonitoringEnabled
	} else {
		config.FunctionsRuntimeScaleMonitoringEnabled = nil
	}

	// HandlerMappings
	if source.HandlerMappings != nil {
		handlerMappingList := make([]HandlerMapping_STATUS, len(source.HandlerMappings))
		for handlerMappingIndex, handlerMappingItem := range source.HandlerMappings {
			// Shadow the loop variable to avoid aliasing
			handlerMappingItem := handlerMappingItem
			var handlerMapping HandlerMapping_STATUS
			err := handlerMapping.AssignPropertiesFromHandlerMappingSTATUS(&handlerMappingItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromHandlerMappingSTATUS() to populate field HandlerMappings")
			}
			handlerMappingList[handlerMappingIndex] = handlerMapping
		}
		config.HandlerMappings = handlerMappingList
	} else {
		config.HandlerMappings = nil
	}

	// HealthCheckPath
	config.HealthCheckPath = genruntime.ClonePointerToString(source.HealthCheckPath)

	// Http20Enabled
	if source.Http20Enabled != nil {
		http20Enabled := *source.Http20Enabled
		config.Http20Enabled = &http20Enabled
	} else {
		config.Http20Enabled = nil
	}

	// HttpLoggingEnabled
	if source.HttpLoggingEnabled != nil {
		httpLoggingEnabled := *source.HttpLoggingEnabled
		config.HttpLoggingEnabled = &httpLoggingEnabled
	} else {
		config.HttpLoggingEnabled = nil
	}

	// IpSecurityRestrictions
	if source.IpSecurityRestrictions != nil {
		ipSecurityRestrictionList := make([]IpSecurityRestriction_STATUS, len(source.IpSecurityRestrictions))
		for ipSecurityRestrictionIndex, ipSecurityRestrictionItem := range source.IpSecurityRestrictions {
			// Shadow the loop variable to avoid aliasing
			ipSecurityRestrictionItem := ipSecurityRestrictionItem
			var ipSecurityRestriction IpSecurityRestriction_STATUS
			err := ipSecurityRestriction.AssignPropertiesFromIpSecurityRestrictionSTATUS(&ipSecurityRestrictionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromIpSecurityRestrictionSTATUS() to populate field IpSecurityRestrictions")
			}
			ipSecurityRestrictionList[ipSecurityRestrictionIndex] = ipSecurityRestriction
		}
		config.IpSecurityRestrictions = ipSecurityRestrictionList
	} else {
		config.IpSecurityRestrictions = nil
	}

	// JavaContainer
	config.JavaContainer = genruntime.ClonePointerToString(source.JavaContainer)

	// JavaContainerVersion
	config.JavaContainerVersion = genruntime.ClonePointerToString(source.JavaContainerVersion)

	// JavaVersion
	config.JavaVersion = genruntime.ClonePointerToString(source.JavaVersion)

	// KeyVaultReferenceIdentity
	config.KeyVaultReferenceIdentity = genruntime.ClonePointerToString(source.KeyVaultReferenceIdentity)

	// Limits
	if source.Limits != nil {
		var limit SiteLimits_STATUS
		err := limit.AssignPropertiesFromSiteLimitsSTATUS(source.Limits)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSiteLimitsSTATUS() to populate field Limits")
		}
		config.Limits = &limit
	} else {
		config.Limits = nil
	}

	// LinuxFxVersion
	config.LinuxFxVersion = genruntime.ClonePointerToString(source.LinuxFxVersion)

	// LoadBalancing
	if source.LoadBalancing != nil {
		loadBalancing := SiteConfigSTATUSLoadBalancing(*source.LoadBalancing)
		config.LoadBalancing = &loadBalancing
	} else {
		config.LoadBalancing = nil
	}

	// LocalMySqlEnabled
	if source.LocalMySqlEnabled != nil {
		localMySqlEnabled := *source.LocalMySqlEnabled
		config.LocalMySqlEnabled = &localMySqlEnabled
	} else {
		config.LocalMySqlEnabled = nil
	}

	// LogsDirectorySizeLimit
	config.LogsDirectorySizeLimit = genruntime.ClonePointerToInt(source.LogsDirectorySizeLimit)

	// MachineKey
	if source.MachineKey != nil {
		var machineKey SiteMachineKey_STATUS
		err := machineKey.AssignPropertiesFromSiteMachineKeySTATUS(source.MachineKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSiteMachineKeySTATUS() to populate field MachineKey")
		}
		config.MachineKey = &machineKey
	} else {
		config.MachineKey = nil
	}

	// ManagedPipelineMode
	if source.ManagedPipelineMode != nil {
		managedPipelineMode := SiteConfigSTATUSManagedPipelineMode(*source.ManagedPipelineMode)
		config.ManagedPipelineMode = &managedPipelineMode
	} else {
		config.ManagedPipelineMode = nil
	}

	// ManagedServiceIdentityId
	config.ManagedServiceIdentityId = genruntime.ClonePointerToInt(source.ManagedServiceIdentityId)

	// MinTlsVersion
	if source.MinTlsVersion != nil {
		minTlsVersion := SiteConfigSTATUSMinTlsVersion(*source.MinTlsVersion)
		config.MinTlsVersion = &minTlsVersion
	} else {
		config.MinTlsVersion = nil
	}

	// MinimumElasticInstanceCount
	config.MinimumElasticInstanceCount = genruntime.ClonePointerToInt(source.MinimumElasticInstanceCount)

	// NetFrameworkVersion
	config.NetFrameworkVersion = genruntime.ClonePointerToString(source.NetFrameworkVersion)

	// NodeVersion
	config.NodeVersion = genruntime.ClonePointerToString(source.NodeVersion)

	// NumberOfWorkers
	config.NumberOfWorkers = genruntime.ClonePointerToInt(source.NumberOfWorkers)

	// PhpVersion
	config.PhpVersion = genruntime.ClonePointerToString(source.PhpVersion)

	// PowerShellVersion
	config.PowerShellVersion = genruntime.ClonePointerToString(source.PowerShellVersion)

	// PreWarmedInstanceCount
	config.PreWarmedInstanceCount = genruntime.ClonePointerToInt(source.PreWarmedInstanceCount)

	// PublicNetworkAccess
	config.PublicNetworkAccess = genruntime.ClonePointerToString(source.PublicNetworkAccess)

	// PublishingUsername
	config.PublishingUsername = genruntime.ClonePointerToString(source.PublishingUsername)

	// Push
	if source.Push != nil {
		var push PushSettings_STATUS
		err := push.AssignPropertiesFromPushSettingsSTATUS(source.Push)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromPushSettingsSTATUS() to populate field Push")
		}
		config.Push = &push
	} else {
		config.Push = nil
	}

	// PythonVersion
	config.PythonVersion = genruntime.ClonePointerToString(source.PythonVersion)

	// RemoteDebuggingEnabled
	if source.RemoteDebuggingEnabled != nil {
		remoteDebuggingEnabled := *source.RemoteDebuggingEnabled
		config.RemoteDebuggingEnabled = &remoteDebuggingEnabled
	} else {
		config.RemoteDebuggingEnabled = nil
	}

	// RemoteDebuggingVersion
	config.RemoteDebuggingVersion = genruntime.ClonePointerToString(source.RemoteDebuggingVersion)

	// RequestTracingEnabled
	if source.RequestTracingEnabled != nil {
		requestTracingEnabled := *source.RequestTracingEnabled
		config.RequestTracingEnabled = &requestTracingEnabled
	} else {
		config.RequestTracingEnabled = nil
	}

	// RequestTracingExpirationTime
	config.RequestTracingExpirationTime = genruntime.ClonePointerToString(source.RequestTracingExpirationTime)

	// ScmIpSecurityRestrictions
	if source.ScmIpSecurityRestrictions != nil {
		scmIpSecurityRestrictionList := make([]IpSecurityRestriction_STATUS, len(source.ScmIpSecurityRestrictions))
		for scmIpSecurityRestrictionIndex, scmIpSecurityRestrictionItem := range source.ScmIpSecurityRestrictions {
			// Shadow the loop variable to avoid aliasing
			scmIpSecurityRestrictionItem := scmIpSecurityRestrictionItem
			var scmIpSecurityRestriction IpSecurityRestriction_STATUS
			err := scmIpSecurityRestriction.AssignPropertiesFromIpSecurityRestrictionSTATUS(&scmIpSecurityRestrictionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromIpSecurityRestrictionSTATUS() to populate field ScmIpSecurityRestrictions")
			}
			scmIpSecurityRestrictionList[scmIpSecurityRestrictionIndex] = scmIpSecurityRestriction
		}
		config.ScmIpSecurityRestrictions = scmIpSecurityRestrictionList
	} else {
		config.ScmIpSecurityRestrictions = nil
	}

	// ScmIpSecurityRestrictionsUseMain
	if source.ScmIpSecurityRestrictionsUseMain != nil {
		scmIpSecurityRestrictionsUseMain := *source.ScmIpSecurityRestrictionsUseMain
		config.ScmIpSecurityRestrictionsUseMain = &scmIpSecurityRestrictionsUseMain
	} else {
		config.ScmIpSecurityRestrictionsUseMain = nil
	}

	// ScmMinTlsVersion
	if source.ScmMinTlsVersion != nil {
		scmMinTlsVersion := SiteConfigSTATUSScmMinTlsVersion(*source.ScmMinTlsVersion)
		config.ScmMinTlsVersion = &scmMinTlsVersion
	} else {
		config.ScmMinTlsVersion = nil
	}

	// ScmType
	if source.ScmType != nil {
		scmType := SiteConfigSTATUSScmType(*source.ScmType)
		config.ScmType = &scmType
	} else {
		config.ScmType = nil
	}

	// TracingOptions
	config.TracingOptions = genruntime.ClonePointerToString(source.TracingOptions)

	// Use32BitWorkerProcess
	if source.Use32BitWorkerProcess != nil {
		use32BitWorkerProcess := *source.Use32BitWorkerProcess
		config.Use32BitWorkerProcess = &use32BitWorkerProcess
	} else {
		config.Use32BitWorkerProcess = nil
	}

	// VirtualApplications
	if source.VirtualApplications != nil {
		virtualApplicationList := make([]VirtualApplication_STATUS, len(source.VirtualApplications))
		for virtualApplicationIndex, virtualApplicationItem := range source.VirtualApplications {
			// Shadow the loop variable to avoid aliasing
			virtualApplicationItem := virtualApplicationItem
			var virtualApplication VirtualApplication_STATUS
			err := virtualApplication.AssignPropertiesFromVirtualApplicationSTATUS(&virtualApplicationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVirtualApplicationSTATUS() to populate field VirtualApplications")
			}
			virtualApplicationList[virtualApplicationIndex] = virtualApplication
		}
		config.VirtualApplications = virtualApplicationList
	} else {
		config.VirtualApplications = nil
	}

	// VnetName
	config.VnetName = genruntime.ClonePointerToString(source.VnetName)

	// VnetPrivatePortsCount
	config.VnetPrivatePortsCount = genruntime.ClonePointerToInt(source.VnetPrivatePortsCount)

	// VnetRouteAllEnabled
	if source.VnetRouteAllEnabled != nil {
		vnetRouteAllEnabled := *source.VnetRouteAllEnabled
		config.VnetRouteAllEnabled = &vnetRouteAllEnabled
	} else {
		config.VnetRouteAllEnabled = nil
	}

	// WebSocketsEnabled
	if source.WebSocketsEnabled != nil {
		webSocketsEnabled := *source.WebSocketsEnabled
		config.WebSocketsEnabled = &webSocketsEnabled
	} else {
		config.WebSocketsEnabled = nil
	}

	// WebsiteTimeZone
	config.WebsiteTimeZone = genruntime.ClonePointerToString(source.WebsiteTimeZone)

	// WindowsFxVersion
	config.WindowsFxVersion = genruntime.ClonePointerToString(source.WindowsFxVersion)

	// XManagedServiceIdentityId
	config.XManagedServiceIdentityId = genruntime.ClonePointerToInt(source.XManagedServiceIdentityId)

	// No error
	return nil
}

// AssignPropertiesToSiteConfigSTATUS populates the provided destination SiteConfig_STATUS from our SiteConfig_STATUS
func (config *SiteConfig_STATUS) AssignPropertiesToSiteConfigSTATUS(destination *v20220301s.SiteConfig_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AcrUseManagedIdentityCreds
	if config.AcrUseManagedIdentityCreds != nil {
		acrUseManagedIdentityCred := *config.AcrUseManagedIdentityCreds
		destination.AcrUseManagedIdentityCreds = &acrUseManagedIdentityCred
	} else {
		destination.AcrUseManagedIdentityCreds = nil
	}

	// AcrUserManagedIdentityID
	destination.AcrUserManagedIdentityID = genruntime.ClonePointerToString(config.AcrUserManagedIdentityID)

	// AlwaysOn
	if config.AlwaysOn != nil {
		alwaysOn := *config.AlwaysOn
		destination.AlwaysOn = &alwaysOn
	} else {
		destination.AlwaysOn = nil
	}

	// ApiDefinition
	if config.ApiDefinition != nil {
		var apiDefinition v20220301s.ApiDefinitionInfo_STATUS
		err := config.ApiDefinition.AssignPropertiesToApiDefinitionInfoSTATUS(&apiDefinition)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToApiDefinitionInfoSTATUS() to populate field ApiDefinition")
		}
		destination.ApiDefinition = &apiDefinition
	} else {
		destination.ApiDefinition = nil
	}

	// ApiManagementConfig
	if config.ApiManagementConfig != nil {
		var apiManagementConfig v20220301s.ApiManagementConfig_STATUS
		err := config.ApiManagementConfig.AssignPropertiesToApiManagementConfigSTATUS(&apiManagementConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToApiManagementConfigSTATUS() to populate field ApiManagementConfig")
		}
		destination.ApiManagementConfig = &apiManagementConfig
	} else {
		destination.ApiManagementConfig = nil
	}

	// AppCommandLine
	destination.AppCommandLine = genruntime.ClonePointerToString(config.AppCommandLine)

	// AppSettings
	if config.AppSettings != nil {
		appSettingList := make([]v20220301s.NameValuePair_STATUS, len(config.AppSettings))
		for appSettingIndex, appSettingItem := range config.AppSettings {
			// Shadow the loop variable to avoid aliasing
			appSettingItem := appSettingItem
			var appSetting v20220301s.NameValuePair_STATUS
			err := appSettingItem.AssignPropertiesToNameValuePairSTATUS(&appSetting)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToNameValuePairSTATUS() to populate field AppSettings")
			}
			appSettingList[appSettingIndex] = appSetting
		}
		destination.AppSettings = appSettingList
	} else {
		destination.AppSettings = nil
	}

	// AutoHealEnabled
	if config.AutoHealEnabled != nil {
		autoHealEnabled := *config.AutoHealEnabled
		destination.AutoHealEnabled = &autoHealEnabled
	} else {
		destination.AutoHealEnabled = nil
	}

	// AutoHealRules
	if config.AutoHealRules != nil {
		var autoHealRule v20220301s.AutoHealRules_STATUS
		err := config.AutoHealRules.AssignPropertiesToAutoHealRulesSTATUS(&autoHealRule)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToAutoHealRulesSTATUS() to populate field AutoHealRules")
		}
		destination.AutoHealRules = &autoHealRule
	} else {
		destination.AutoHealRules = nil
	}

	// AutoSwapSlotName
	destination.AutoSwapSlotName = genruntime.ClonePointerToString(config.AutoSwapSlotName)

	// AzureStorageAccounts
	if config.AzureStorageAccounts != nil {
		azureStorageAccountMap := make(map[string]v20220301s.AzureStorageInfoValue_STATUS, len(config.AzureStorageAccounts))
		for azureStorageAccountKey, azureStorageAccountValue := range config.AzureStorageAccounts {
			// Shadow the loop variable to avoid aliasing
			azureStorageAccountValue := azureStorageAccountValue
			var azureStorageAccount v20220301s.AzureStorageInfoValue_STATUS
			err := azureStorageAccountValue.AssignPropertiesToAzureStorageInfoValueSTATUS(&azureStorageAccount)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToAzureStorageInfoValueSTATUS() to populate field AzureStorageAccounts")
			}
			azureStorageAccountMap[azureStorageAccountKey] = azureStorageAccount
		}
		destination.AzureStorageAccounts = azureStorageAccountMap
	} else {
		destination.AzureStorageAccounts = nil
	}

	// ConnectionStrings
	if config.ConnectionStrings != nil {
		connectionStringList := make([]v20220301s.ConnStringInfo_STATUS, len(config.ConnectionStrings))
		for connectionStringIndex, connectionStringItem := range config.ConnectionStrings {
			// Shadow the loop variable to avoid aliasing
			connectionStringItem := connectionStringItem
			var connectionString v20220301s.ConnStringInfo_STATUS
			err := connectionStringItem.AssignPropertiesToConnStringInfoSTATUS(&connectionString)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToConnStringInfoSTATUS() to populate field ConnectionStrings")
			}
			connectionStringList[connectionStringIndex] = connectionString
		}
		destination.ConnectionStrings = connectionStringList
	} else {
		destination.ConnectionStrings = nil
	}

	// Cors
	if config.Cors != nil {
		var cor v20220301s.CorsSettings_STATUS
		err := config.Cors.AssignPropertiesToCorsSettingsSTATUS(&cor)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToCorsSettingsSTATUS() to populate field Cors")
		}
		destination.Cors = &cor
	} else {
		destination.Cors = nil
	}

	// DefaultDocuments
	destination.DefaultDocuments = genruntime.CloneSliceOfString(config.DefaultDocuments)

	// DetailedErrorLoggingEnabled
	if config.DetailedErrorLoggingEnabled != nil {
		detailedErrorLoggingEnabled := *config.DetailedErrorLoggingEnabled
		destination.DetailedErrorLoggingEnabled = &detailedErrorLoggingEnabled
	} else {
		destination.DetailedErrorLoggingEnabled = nil
	}

	// DocumentRoot
	destination.DocumentRoot = genruntime.ClonePointerToString(config.DocumentRoot)

	// Experiments
	if config.Experiments != nil {
		var experiment v20220301s.Experiments_STATUS
		err := config.Experiments.AssignPropertiesToExperimentsSTATUS(&experiment)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToExperimentsSTATUS() to populate field Experiments")
		}
		destination.Experiments = &experiment
	} else {
		destination.Experiments = nil
	}

	// FtpsState
	if config.FtpsState != nil {
		ftpsState := string(*config.FtpsState)
		destination.FtpsState = &ftpsState
	} else {
		destination.FtpsState = nil
	}

	// FunctionAppScaleLimit
	destination.FunctionAppScaleLimit = genruntime.ClonePointerToInt(config.FunctionAppScaleLimit)

	// FunctionsRuntimeScaleMonitoringEnabled
	if config.FunctionsRuntimeScaleMonitoringEnabled != nil {
		functionsRuntimeScaleMonitoringEnabled := *config.FunctionsRuntimeScaleMonitoringEnabled
		destination.FunctionsRuntimeScaleMonitoringEnabled = &functionsRuntimeScaleMonitoringEnabled
	} else {
		destination.FunctionsRuntimeScaleMonitoringEnabled = nil
	}

	// HandlerMappings
	if config.HandlerMappings != nil {
		handlerMappingList := make([]v20220301s.HandlerMapping_STATUS, len(config.HandlerMappings))
		for handlerMappingIndex, handlerMappingItem := range config.HandlerMappings {
			// Shadow the loop variable to avoid aliasing
			handlerMappingItem := handlerMappingItem
			var handlerMapping v20220301s.HandlerMapping_STATUS
			err := handlerMappingItem.AssignPropertiesToHandlerMappingSTATUS(&handlerMapping)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToHandlerMappingSTATUS() to populate field HandlerMappings")
			}
			handlerMappingList[handlerMappingIndex] = handlerMapping
		}
		destination.HandlerMappings = handlerMappingList
	} else {
		destination.HandlerMappings = nil
	}

	// HealthCheckPath
	destination.HealthCheckPath = genruntime.ClonePointerToString(config.HealthCheckPath)

	// Http20Enabled
	if config.Http20Enabled != nil {
		http20Enabled := *config.Http20Enabled
		destination.Http20Enabled = &http20Enabled
	} else {
		destination.Http20Enabled = nil
	}

	// HttpLoggingEnabled
	if config.HttpLoggingEnabled != nil {
		httpLoggingEnabled := *config.HttpLoggingEnabled
		destination.HttpLoggingEnabled = &httpLoggingEnabled
	} else {
		destination.HttpLoggingEnabled = nil
	}

	// IpSecurityRestrictions
	if config.IpSecurityRestrictions != nil {
		ipSecurityRestrictionList := make([]v20220301s.IpSecurityRestriction_STATUS, len(config.IpSecurityRestrictions))
		for ipSecurityRestrictionIndex, ipSecurityRestrictionItem := range config.IpSecurityRestrictions {
			// Shadow the loop variable to avoid aliasing
			ipSecurityRestrictionItem := ipSecurityRestrictionItem
			var ipSecurityRestriction v20220301s.IpSecurityRestriction_STATUS
			err := ipSecurityRestrictionItem.AssignPropertiesToIpSecurityRestrictionSTATUS(&ipSecurityRestriction)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToIpSecurityRestrictionSTATUS() to populate field IpSecurityRestrictions")
			}
			ipSecurityRestrictionList[ipSecurityRestrictionIndex] = ipSecurityRestriction
		}
		destination.IpSecurityRestrictions = ipSecurityRestrictionList
	} else {
		destination.IpSecurityRestrictions = nil
	}

	// JavaContainer
	destination.JavaContainer = genruntime.ClonePointerToString(config.JavaContainer)

	// JavaContainerVersion
	destination.JavaContainerVersion = genruntime.ClonePointerToString(config.JavaContainerVersion)

	// JavaVersion
	destination.JavaVersion = genruntime.ClonePointerToString(config.JavaVersion)

	// KeyVaultReferenceIdentity
	destination.KeyVaultReferenceIdentity = genruntime.ClonePointerToString(config.KeyVaultReferenceIdentity)

	// Limits
	if config.Limits != nil {
		var limit v20220301s.SiteLimits_STATUS
		err := config.Limits.AssignPropertiesToSiteLimitsSTATUS(&limit)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSiteLimitsSTATUS() to populate field Limits")
		}
		destination.Limits = &limit
	} else {
		destination.Limits = nil
	}

	// LinuxFxVersion
	destination.LinuxFxVersion = genruntime.ClonePointerToString(config.LinuxFxVersion)

	// LoadBalancing
	if config.LoadBalancing != nil {
		loadBalancing := string(*config.LoadBalancing)
		destination.LoadBalancing = &loadBalancing
	} else {
		destination.LoadBalancing = nil
	}

	// LocalMySqlEnabled
	if config.LocalMySqlEnabled != nil {
		localMySqlEnabled := *config.LocalMySqlEnabled
		destination.LocalMySqlEnabled = &localMySqlEnabled
	} else {
		destination.LocalMySqlEnabled = nil
	}

	// LogsDirectorySizeLimit
	destination.LogsDirectorySizeLimit = genruntime.ClonePointerToInt(config.LogsDirectorySizeLimit)

	// MachineKey
	if config.MachineKey != nil {
		var machineKey v20220301s.SiteMachineKey_STATUS
		err := config.MachineKey.AssignPropertiesToSiteMachineKeySTATUS(&machineKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSiteMachineKeySTATUS() to populate field MachineKey")
		}
		destination.MachineKey = &machineKey
	} else {
		destination.MachineKey = nil
	}

	// ManagedPipelineMode
	if config.ManagedPipelineMode != nil {
		managedPipelineMode := string(*config.ManagedPipelineMode)
		destination.ManagedPipelineMode = &managedPipelineMode
	} else {
		destination.ManagedPipelineMode = nil
	}

	// ManagedServiceIdentityId
	destination.ManagedServiceIdentityId = genruntime.ClonePointerToInt(config.ManagedServiceIdentityId)

	// MinTlsVersion
	if config.MinTlsVersion != nil {
		minTlsVersion := string(*config.MinTlsVersion)
		destination.MinTlsVersion = &minTlsVersion
	} else {
		destination.MinTlsVersion = nil
	}

	// MinimumElasticInstanceCount
	destination.MinimumElasticInstanceCount = genruntime.ClonePointerToInt(config.MinimumElasticInstanceCount)

	// NetFrameworkVersion
	destination.NetFrameworkVersion = genruntime.ClonePointerToString(config.NetFrameworkVersion)

	// NodeVersion
	destination.NodeVersion = genruntime.ClonePointerToString(config.NodeVersion)

	// NumberOfWorkers
	destination.NumberOfWorkers = genruntime.ClonePointerToInt(config.NumberOfWorkers)

	// PhpVersion
	destination.PhpVersion = genruntime.ClonePointerToString(config.PhpVersion)

	// PowerShellVersion
	destination.PowerShellVersion = genruntime.ClonePointerToString(config.PowerShellVersion)

	// PreWarmedInstanceCount
	destination.PreWarmedInstanceCount = genruntime.ClonePointerToInt(config.PreWarmedInstanceCount)

	// PublicNetworkAccess
	destination.PublicNetworkAccess = genruntime.ClonePointerToString(config.PublicNetworkAccess)

	// PublishingUsername
	destination.PublishingUsername = genruntime.ClonePointerToString(config.PublishingUsername)

	// Push
	if config.Push != nil {
		var push v20220301s.PushSettings_STATUS
		err := config.Push.AssignPropertiesToPushSettingsSTATUS(&push)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToPushSettingsSTATUS() to populate field Push")
		}
		destination.Push = &push
	} else {
		destination.Push = nil
	}

	// PythonVersion
	destination.PythonVersion = genruntime.ClonePointerToString(config.PythonVersion)

	// RemoteDebuggingEnabled
	if config.RemoteDebuggingEnabled != nil {
		remoteDebuggingEnabled := *config.RemoteDebuggingEnabled
		destination.RemoteDebuggingEnabled = &remoteDebuggingEnabled
	} else {
		destination.RemoteDebuggingEnabled = nil
	}

	// RemoteDebuggingVersion
	destination.RemoteDebuggingVersion = genruntime.ClonePointerToString(config.RemoteDebuggingVersion)

	// RequestTracingEnabled
	if config.RequestTracingEnabled != nil {
		requestTracingEnabled := *config.RequestTracingEnabled
		destination.RequestTracingEnabled = &requestTracingEnabled
	} else {
		destination.RequestTracingEnabled = nil
	}

	// RequestTracingExpirationTime
	destination.RequestTracingExpirationTime = genruntime.ClonePointerToString(config.RequestTracingExpirationTime)

	// ScmIpSecurityRestrictions
	if config.ScmIpSecurityRestrictions != nil {
		scmIpSecurityRestrictionList := make([]v20220301s.IpSecurityRestriction_STATUS, len(config.ScmIpSecurityRestrictions))
		for scmIpSecurityRestrictionIndex, scmIpSecurityRestrictionItem := range config.ScmIpSecurityRestrictions {
			// Shadow the loop variable to avoid aliasing
			scmIpSecurityRestrictionItem := scmIpSecurityRestrictionItem
			var scmIpSecurityRestriction v20220301s.IpSecurityRestriction_STATUS
			err := scmIpSecurityRestrictionItem.AssignPropertiesToIpSecurityRestrictionSTATUS(&scmIpSecurityRestriction)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToIpSecurityRestrictionSTATUS() to populate field ScmIpSecurityRestrictions")
			}
			scmIpSecurityRestrictionList[scmIpSecurityRestrictionIndex] = scmIpSecurityRestriction
		}
		destination.ScmIpSecurityRestrictions = scmIpSecurityRestrictionList
	} else {
		destination.ScmIpSecurityRestrictions = nil
	}

	// ScmIpSecurityRestrictionsUseMain
	if config.ScmIpSecurityRestrictionsUseMain != nil {
		scmIpSecurityRestrictionsUseMain := *config.ScmIpSecurityRestrictionsUseMain
		destination.ScmIpSecurityRestrictionsUseMain = &scmIpSecurityRestrictionsUseMain
	} else {
		destination.ScmIpSecurityRestrictionsUseMain = nil
	}

	// ScmMinTlsVersion
	if config.ScmMinTlsVersion != nil {
		scmMinTlsVersion := string(*config.ScmMinTlsVersion)
		destination.ScmMinTlsVersion = &scmMinTlsVersion
	} else {
		destination.ScmMinTlsVersion = nil
	}

	// ScmType
	if config.ScmType != nil {
		scmType := string(*config.ScmType)
		destination.ScmType = &scmType
	} else {
		destination.ScmType = nil
	}

	// TracingOptions
	destination.TracingOptions = genruntime.ClonePointerToString(config.TracingOptions)

	// Use32BitWorkerProcess
	if config.Use32BitWorkerProcess != nil {
		use32BitWorkerProcess := *config.Use32BitWorkerProcess
		destination.Use32BitWorkerProcess = &use32BitWorkerProcess
	} else {
		destination.Use32BitWorkerProcess = nil
	}

	// VirtualApplications
	if config.VirtualApplications != nil {
		virtualApplicationList := make([]v20220301s.VirtualApplication_STATUS, len(config.VirtualApplications))
		for virtualApplicationIndex, virtualApplicationItem := range config.VirtualApplications {
			// Shadow the loop variable to avoid aliasing
			virtualApplicationItem := virtualApplicationItem
			var virtualApplication v20220301s.VirtualApplication_STATUS
			err := virtualApplicationItem.AssignPropertiesToVirtualApplicationSTATUS(&virtualApplication)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVirtualApplicationSTATUS() to populate field VirtualApplications")
			}
			virtualApplicationList[virtualApplicationIndex] = virtualApplication
		}
		destination.VirtualApplications = virtualApplicationList
	} else {
		destination.VirtualApplications = nil
	}

	// VnetName
	destination.VnetName = genruntime.ClonePointerToString(config.VnetName)

	// VnetPrivatePortsCount
	destination.VnetPrivatePortsCount = genruntime.ClonePointerToInt(config.VnetPrivatePortsCount)

	// VnetRouteAllEnabled
	if config.VnetRouteAllEnabled != nil {
		vnetRouteAllEnabled := *config.VnetRouteAllEnabled
		destination.VnetRouteAllEnabled = &vnetRouteAllEnabled
	} else {
		destination.VnetRouteAllEnabled = nil
	}

	// WebSocketsEnabled
	if config.WebSocketsEnabled != nil {
		webSocketsEnabled := *config.WebSocketsEnabled
		destination.WebSocketsEnabled = &webSocketsEnabled
	} else {
		destination.WebSocketsEnabled = nil
	}

	// WebsiteTimeZone
	destination.WebsiteTimeZone = genruntime.ClonePointerToString(config.WebsiteTimeZone)

	// WindowsFxVersion
	destination.WindowsFxVersion = genruntime.ClonePointerToString(config.WindowsFxVersion)

	// XManagedServiceIdentityId
	destination.XManagedServiceIdentityId = genruntime.ClonePointerToInt(config.XManagedServiceIdentityId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Sites_Spec_Properties_SiteConfig struct {
	// AcrUseManagedIdentityCreds: Flag to use Managed Identity Creds for ACR pull
	AcrUseManagedIdentityCreds *bool `json:"acrUseManagedIdentityCreds,omitempty"`

	// AcrUserManagedIdentityID: If using user managed identity, the user managed identity ClientId
	AcrUserManagedIdentityID *string `json:"acrUserManagedIdentityID,omitempty"`

	// AlwaysOn: <code>true</code> if Always On is enabled; otherwise, <code>false</code>.
	AlwaysOn *bool `json:"alwaysOn,omitempty"`

	// ApiDefinition: Information about the formal API definition for the app.
	ApiDefinition *ApiDefinitionInfo `json:"apiDefinition,omitempty"`

	// ApiManagementConfig: Azure API management (APIM) configuration linked to the app.
	ApiManagementConfig *ApiManagementConfig `json:"apiManagementConfig,omitempty"`

	// AppCommandLine: App command line to launch.
	AppCommandLine *string `json:"appCommandLine,omitempty"`

	// AppSettings: Application settings.
	AppSettings []NameValuePair `json:"appSettings,omitempty"`

	// AutoHealEnabled: <code>true</code> if Auto Heal is enabled; otherwise, <code>false</code>.
	AutoHealEnabled *bool `json:"autoHealEnabled,omitempty"`

	// AutoHealRules: Rules that can be defined for auto-heal.
	AutoHealRules *AutoHealRules `json:"autoHealRules,omitempty"`

	// AutoSwapSlotName: Auto-swap slot name.
	AutoSwapSlotName *string `json:"autoSwapSlotName,omitempty"`

	// AzureStorageAccounts: List of Azure Storage Accounts.
	AzureStorageAccounts map[string]Sites_Spec_Properties_SiteConfig_AzureStorageAccounts `json:"azureStorageAccounts,omitempty"`

	// ConnectionStrings: Connection strings.
	ConnectionStrings []ConnStringInfo `json:"connectionStrings,omitempty"`

	// Cors: Cross-Origin Resource Sharing (CORS) settings for the app.
	Cors *CorsSettings `json:"cors,omitempty"`

	// DefaultDocuments: Default documents.
	DefaultDocuments []string `json:"defaultDocuments,omitempty"`

	// DetailedErrorLoggingEnabled: <code>true</code> if detailed error logging is enabled; otherwise, <code>false</code>.
	DetailedErrorLoggingEnabled *bool `json:"detailedErrorLoggingEnabled,omitempty"`

	// DocumentRoot: Document root.
	DocumentRoot *string `json:"documentRoot,omitempty"`

	// Experiments: Routing rules in production experiments.
	Experiments *Experiments `json:"experiments,omitempty"`

	// FtpsState: State of FTP / FTPS service.
	FtpsState *SitesSpecPropertiesSiteConfigFtpsState `json:"ftpsState,omitempty"`

	// +kubebuilder:validation:Minimum=0
	// FunctionAppScaleLimit: Maximum number of workers that a site can scale out to.
	// This setting only applies to the Consumption and Elastic Premium Plans
	FunctionAppScaleLimit *int `json:"functionAppScaleLimit,omitempty"`

	// FunctionsRuntimeScaleMonitoringEnabled: Gets or sets a value indicating whether functions runtime scale monitoring is
	// enabled. When enabled,
	// the ScaleController will not monitor event sources directly, but will instead call to the
	// runtime to get scale status.
	FunctionsRuntimeScaleMonitoringEnabled *bool `json:"functionsRuntimeScaleMonitoringEnabled,omitempty"`

	// HandlerMappings: Handler mappings.
	HandlerMappings []HandlerMapping `json:"handlerMappings,omitempty"`

	// HealthCheckPath: Health check path
	HealthCheckPath *string `json:"healthCheckPath,omitempty"`

	// Http20Enabled: Http20Enabled: configures a web site to allow clients to connect over http2.0
	Http20Enabled *bool `json:"http20Enabled,omitempty"`

	// HttpLoggingEnabled: <code>true</code> if HTTP logging is enabled; otherwise, <code>false</code>.
	HttpLoggingEnabled *bool `json:"httpLoggingEnabled,omitempty"`

	// IpSecurityRestrictions: IP security restrictions for main.
	IpSecurityRestrictions []IpSecurityRestriction `json:"ipSecurityRestrictions,omitempty"`

	// JavaContainer: Java container.
	JavaContainer *string `json:"javaContainer,omitempty"`

	// JavaContainerVersion: Java container version.
	JavaContainerVersion *string `json:"javaContainerVersion,omitempty"`

	// JavaVersion: Java version.
	JavaVersion *string `json:"javaVersion,omitempty"`

	// KeyVaultReferenceIdentity: Identity to use for Key Vault Reference authentication.
	KeyVaultReferenceIdentity *string `json:"keyVaultReferenceIdentity,omitempty"`

	// Limits: Metric limits set on an app.
	Limits *SiteLimits `json:"limits,omitempty"`

	// LinuxFxVersion: Linux App Framework and version
	LinuxFxVersion *string `json:"linuxFxVersion,omitempty"`

	// LoadBalancing: Site load balancing.
	LoadBalancing *SitesSpecPropertiesSiteConfigLoadBalancing `json:"loadBalancing,omitempty"`

	// LocalMySqlEnabled: <code>true</code> to enable local MySQL; otherwise, <code>false</code>.
	LocalMySqlEnabled *bool `json:"localMySqlEnabled,omitempty"`

	// LogsDirectorySizeLimit: HTTP logs directory size limit.
	LogsDirectorySizeLimit *int `json:"logsDirectorySizeLimit,omitempty"`

	// ManagedPipelineMode: Managed pipeline mode.
	ManagedPipelineMode *SitesSpecPropertiesSiteConfigManagedPipelineMode `json:"managedPipelineMode,omitempty"`

	// ManagedServiceIdentityId: Managed Service Identity Id
	ManagedServiceIdentityId *int `json:"managedServiceIdentityId,omitempty"`

	// MinTlsVersion: MinTlsVersion: configures the minimum version of TLS required for SSL requests.
	MinTlsVersion *SitesSpecPropertiesSiteConfigMinTlsVersion `json:"minTlsVersion,omitempty"`

	// +kubebuilder:validation:Maximum=20
	// +kubebuilder:validation:Minimum=0
	// MinimumElasticInstanceCount: Number of minimum instance count for a site
	// This setting only applies to the Elastic Plans
	MinimumElasticInstanceCount *int `json:"minimumElasticInstanceCount,omitempty"`

	// NetFrameworkVersion: .NET Framework version.
	NetFrameworkVersion *string `json:"netFrameworkVersion,omitempty"`

	// NodeVersion: Version of Node.js.
	NodeVersion *string `json:"nodeVersion,omitempty"`

	// NumberOfWorkers: Number of workers.
	NumberOfWorkers *int `json:"numberOfWorkers,omitempty"`

	// PhpVersion: Version of PHP.
	PhpVersion *string `json:"phpVersion,omitempty"`

	// PowerShellVersion: Version of PowerShell.
	PowerShellVersion *string `json:"powerShellVersion,omitempty"`

	// +kubebuilder:validation:Maximum=10
	// +kubebuilder:validation:Minimum=0
	// PreWarmedInstanceCount: Number of preWarmed instances.
	// This setting only applies to the Consumption and Elastic Plans
	PreWarmedInstanceCount *int `json:"preWarmedInstanceCount,omitempty"`

	// PublicNetworkAccess: Property to allow or block all public traffic.
	PublicNetworkAccess *string `json:"publicNetworkAccess,omitempty"`

	// PublishingUsername: Publishing user name.
	PublishingUsername *string `json:"publishingUsername,omitempty"`

	// Push: Push settings for the App.
	Push *Sites_Spec_Properties_SiteConfig_Push `json:"push,omitempty"`

	// PythonVersion: Version of Python.
	PythonVersion *string `json:"pythonVersion,omitempty"`

	// RemoteDebuggingEnabled: <code>true</code> if remote debugging is enabled; otherwise, <code>false</code>.
	RemoteDebuggingEnabled *bool `json:"remoteDebuggingEnabled,omitempty"`

	// RemoteDebuggingVersion: Remote debugging version.
	RemoteDebuggingVersion *string `json:"remoteDebuggingVersion,omitempty"`

	// RequestTracingEnabled: <code>true</code> if request tracing is enabled; otherwise, <code>false</code>.
	RequestTracingEnabled *bool `json:"requestTracingEnabled,omitempty"`

	// RequestTracingExpirationTime: Request tracing expiration time.
	RequestTracingExpirationTime *string `json:"requestTracingExpirationTime,omitempty"`

	// ScmIpSecurityRestrictions: IP security restrictions for scm.
	ScmIpSecurityRestrictions []IpSecurityRestriction `json:"scmIpSecurityRestrictions,omitempty"`

	// ScmIpSecurityRestrictionsUseMain: IP security restrictions for scm to use main.
	ScmIpSecurityRestrictionsUseMain *bool `json:"scmIpSecurityRestrictionsUseMain,omitempty"`

	// ScmMinTlsVersion: ScmMinTlsVersion: configures the minimum version of TLS required for SSL requests for SCM site.
	ScmMinTlsVersion *SitesSpecPropertiesSiteConfigScmMinTlsVersion `json:"scmMinTlsVersion,omitempty"`

	// ScmType: SCM type.
	ScmType *SitesSpecPropertiesSiteConfigScmType `json:"scmType,omitempty"`

	// TracingOptions: Tracing options.
	TracingOptions *string `json:"tracingOptions,omitempty"`

	// Use32BitWorkerProcess: <code>true</code> to use 32-bit worker process; otherwise, <code>false</code>.
	Use32BitWorkerProcess *bool `json:"use32BitWorkerProcess,omitempty"`

	// VirtualApplications: Virtual applications.
	VirtualApplications []VirtualApplication `json:"virtualApplications,omitempty"`

	// VnetName: Virtual Network name.
	VnetName *string `json:"vnetName,omitempty"`

	// VnetPrivatePortsCount: The number of private ports assigned to this app. These will be assigned dynamically on runtime.
	VnetPrivatePortsCount *int `json:"vnetPrivatePortsCount,omitempty"`

	// VnetRouteAllEnabled: Virtual Network Route All enabled. This causes all outbound traffic to have Virtual Network
	// Security Groups and User Defined Routes applied.
	VnetRouteAllEnabled *bool `json:"vnetRouteAllEnabled,omitempty"`

	// WebSocketsEnabled: <code>true</code> if WebSocket is enabled; otherwise, <code>false</code>.
	WebSocketsEnabled *bool `json:"webSocketsEnabled,omitempty"`

	// WebsiteTimeZone: Sets the time zone a site uses for generating timestamps. Compatible with Linux and Windows App
	// Service. Setting the WEBSITE_TIME_ZONE app setting takes precedence over this config. For Linux, expects tz database
	// values https://www.iana.org/time-zones (for a quick reference see
	// https://en.wikipedia.org/wiki/List_of_tz_database_time_zones). For Windows, expects one of the time zones listed under
	// HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Time Zones
	WebsiteTimeZone *string `json:"websiteTimeZone,omitempty"`

	// WindowsFxVersion: Xenon App Framework and version
	WindowsFxVersion *string `json:"windowsFxVersion,omitempty"`

	// XManagedServiceIdentityId: Explicit Managed Service Identity Id
	XManagedServiceIdentityId *int `json:"xManagedServiceIdentityId,omitempty"`
}

var _ genruntime.ARMTransformer = &Sites_Spec_Properties_SiteConfig{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (config *Sites_Spec_Properties_SiteConfig) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if config == nil {
		return nil, nil
	}
	result := &Sites_Spec_Properties_SiteConfigARM{}

	// Set property ‘AcrUseManagedIdentityCreds’:
	if config.AcrUseManagedIdentityCreds != nil {
		acrUseManagedIdentityCreds := *config.AcrUseManagedIdentityCreds
		result.AcrUseManagedIdentityCreds = &acrUseManagedIdentityCreds
	}

	// Set property ‘AcrUserManagedIdentityID’:
	if config.AcrUserManagedIdentityID != nil {
		acrUserManagedIdentityID := *config.AcrUserManagedIdentityID
		result.AcrUserManagedIdentityID = &acrUserManagedIdentityID
	}

	// Set property ‘AlwaysOn’:
	if config.AlwaysOn != nil {
		alwaysOn := *config.AlwaysOn
		result.AlwaysOn = &alwaysOn
	}

	// Set property ‘ApiDefinition’:
	if config.ApiDefinition != nil {
		apiDefinitionARM, err := (*config.ApiDefinition).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		apiDefinition := *apiDefinitionARM.(*ApiDefinitionInfoARM)
		result.ApiDefinition = &apiDefinition
	}

	// Set property ‘ApiManagementConfig’:
	if config.ApiManagementConfig != nil {
		apiManagementConfigARM, err := (*config.ApiManagementConfig).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		apiManagementConfig := *apiManagementConfigARM.(*ApiManagementConfigARM)
		result.ApiManagementConfig = &apiManagementConfig
	}

	// Set property ‘AppCommandLine’:
	if config.AppCommandLine != nil {
		appCommandLine := *config.AppCommandLine
		result.AppCommandLine = &appCommandLine
	}

	// Set property ‘AppSettings’:
	for _, item := range config.AppSettings {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.AppSettings = append(result.AppSettings, *itemARM.(*NameValuePairARM))
	}

	// Set property ‘AutoHealEnabled’:
	if config.AutoHealEnabled != nil {
		autoHealEnabled := *config.AutoHealEnabled
		result.AutoHealEnabled = &autoHealEnabled
	}

	// Set property ‘AutoHealRules’:
	if config.AutoHealRules != nil {
		autoHealRulesARM, err := (*config.AutoHealRules).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		autoHealRules := *autoHealRulesARM.(*AutoHealRulesARM)
		result.AutoHealRules = &autoHealRules
	}

	// Set property ‘AutoSwapSlotName’:
	if config.AutoSwapSlotName != nil {
		autoSwapSlotName := *config.AutoSwapSlotName
		result.AutoSwapSlotName = &autoSwapSlotName
	}

	// Set property ‘AzureStorageAccounts’:
	if config.AzureStorageAccounts != nil {
		result.AzureStorageAccounts = make(map[string]Sites_Spec_Properties_SiteConfig_AzureStorageAccountsARM, len(config.AzureStorageAccounts))
		for key, value := range config.AzureStorageAccounts {
			valueARM, err := value.ConvertToARM(resolved)
			if err != nil {
				return nil, err
			}
			result.AzureStorageAccounts[key] = *valueARM.(*Sites_Spec_Properties_SiteConfig_AzureStorageAccountsARM)
		}
	}

	// Set property ‘ConnectionStrings’:
	for _, item := range config.ConnectionStrings {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.ConnectionStrings = append(result.ConnectionStrings, *itemARM.(*ConnStringInfoARM))
	}

	// Set property ‘Cors’:
	if config.Cors != nil {
		corsARM, err := (*config.Cors).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		cors := *corsARM.(*CorsSettingsARM)
		result.Cors = &cors
	}

	// Set property ‘DefaultDocuments’:
	for _, item := range config.DefaultDocuments {
		result.DefaultDocuments = append(result.DefaultDocuments, item)
	}

	// Set property ‘DetailedErrorLoggingEnabled’:
	if config.DetailedErrorLoggingEnabled != nil {
		detailedErrorLoggingEnabled := *config.DetailedErrorLoggingEnabled
		result.DetailedErrorLoggingEnabled = &detailedErrorLoggingEnabled
	}

	// Set property ‘DocumentRoot’:
	if config.DocumentRoot != nil {
		documentRoot := *config.DocumentRoot
		result.DocumentRoot = &documentRoot
	}

	// Set property ‘Experiments’:
	if config.Experiments != nil {
		experimentsARM, err := (*config.Experiments).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		experiments := *experimentsARM.(*ExperimentsARM)
		result.Experiments = &experiments
	}

	// Set property ‘FtpsState’:
	if config.FtpsState != nil {
		ftpsState := *config.FtpsState
		result.FtpsState = &ftpsState
	}

	// Set property ‘FunctionAppScaleLimit’:
	if config.FunctionAppScaleLimit != nil {
		functionAppScaleLimit := *config.FunctionAppScaleLimit
		result.FunctionAppScaleLimit = &functionAppScaleLimit
	}

	// Set property ‘FunctionsRuntimeScaleMonitoringEnabled’:
	if config.FunctionsRuntimeScaleMonitoringEnabled != nil {
		functionsRuntimeScaleMonitoringEnabled := *config.FunctionsRuntimeScaleMonitoringEnabled
		result.FunctionsRuntimeScaleMonitoringEnabled = &functionsRuntimeScaleMonitoringEnabled
	}

	// Set property ‘HandlerMappings’:
	for _, item := range config.HandlerMappings {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.HandlerMappings = append(result.HandlerMappings, *itemARM.(*HandlerMappingARM))
	}

	// Set property ‘HealthCheckPath’:
	if config.HealthCheckPath != nil {
		healthCheckPath := *config.HealthCheckPath
		result.HealthCheckPath = &healthCheckPath
	}

	// Set property ‘Http20Enabled’:
	if config.Http20Enabled != nil {
		http20Enabled := *config.Http20Enabled
		result.Http20Enabled = &http20Enabled
	}

	// Set property ‘HttpLoggingEnabled’:
	if config.HttpLoggingEnabled != nil {
		httpLoggingEnabled := *config.HttpLoggingEnabled
		result.HttpLoggingEnabled = &httpLoggingEnabled
	}

	// Set property ‘IpSecurityRestrictions’:
	for _, item := range config.IpSecurityRestrictions {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.IpSecurityRestrictions = append(result.IpSecurityRestrictions, *itemARM.(*IpSecurityRestrictionARM))
	}

	// Set property ‘JavaContainer’:
	if config.JavaContainer != nil {
		javaContainer := *config.JavaContainer
		result.JavaContainer = &javaContainer
	}

	// Set property ‘JavaContainerVersion’:
	if config.JavaContainerVersion != nil {
		javaContainerVersion := *config.JavaContainerVersion
		result.JavaContainerVersion = &javaContainerVersion
	}

	// Set property ‘JavaVersion’:
	if config.JavaVersion != nil {
		javaVersion := *config.JavaVersion
		result.JavaVersion = &javaVersion
	}

	// Set property ‘KeyVaultReferenceIdentity’:
	if config.KeyVaultReferenceIdentity != nil {
		keyVaultReferenceIdentity := *config.KeyVaultReferenceIdentity
		result.KeyVaultReferenceIdentity = &keyVaultReferenceIdentity
	}

	// Set property ‘Limits’:
	if config.Limits != nil {
		limitsARM, err := (*config.Limits).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		limits := *limitsARM.(*SiteLimitsARM)
		result.Limits = &limits
	}

	// Set property ‘LinuxFxVersion’:
	if config.LinuxFxVersion != nil {
		linuxFxVersion := *config.LinuxFxVersion
		result.LinuxFxVersion = &linuxFxVersion
	}

	// Set property ‘LoadBalancing’:
	if config.LoadBalancing != nil {
		loadBalancing := *config.LoadBalancing
		result.LoadBalancing = &loadBalancing
	}

	// Set property ‘LocalMySqlEnabled’:
	if config.LocalMySqlEnabled != nil {
		localMySqlEnabled := *config.LocalMySqlEnabled
		result.LocalMySqlEnabled = &localMySqlEnabled
	}

	// Set property ‘LogsDirectorySizeLimit’:
	if config.LogsDirectorySizeLimit != nil {
		logsDirectorySizeLimit := *config.LogsDirectorySizeLimit
		result.LogsDirectorySizeLimit = &logsDirectorySizeLimit
	}

	// Set property ‘ManagedPipelineMode’:
	if config.ManagedPipelineMode != nil {
		managedPipelineMode := *config.ManagedPipelineMode
		result.ManagedPipelineMode = &managedPipelineMode
	}

	// Set property ‘ManagedServiceIdentityId’:
	if config.ManagedServiceIdentityId != nil {
		managedServiceIdentityId := *config.ManagedServiceIdentityId
		result.ManagedServiceIdentityId = &managedServiceIdentityId
	}

	// Set property ‘MinTlsVersion’:
	if config.MinTlsVersion != nil {
		minTlsVersion := *config.MinTlsVersion
		result.MinTlsVersion = &minTlsVersion
	}

	// Set property ‘MinimumElasticInstanceCount’:
	if config.MinimumElasticInstanceCount != nil {
		minimumElasticInstanceCount := *config.MinimumElasticInstanceCount
		result.MinimumElasticInstanceCount = &minimumElasticInstanceCount
	}

	// Set property ‘NetFrameworkVersion’:
	if config.NetFrameworkVersion != nil {
		netFrameworkVersion := *config.NetFrameworkVersion
		result.NetFrameworkVersion = &netFrameworkVersion
	}

	// Set property ‘NodeVersion’:
	if config.NodeVersion != nil {
		nodeVersion := *config.NodeVersion
		result.NodeVersion = &nodeVersion
	}

	// Set property ‘NumberOfWorkers’:
	if config.NumberOfWorkers != nil {
		numberOfWorkers := *config.NumberOfWorkers
		result.NumberOfWorkers = &numberOfWorkers
	}

	// Set property ‘PhpVersion’:
	if config.PhpVersion != nil {
		phpVersion := *config.PhpVersion
		result.PhpVersion = &phpVersion
	}

	// Set property ‘PowerShellVersion’:
	if config.PowerShellVersion != nil {
		powerShellVersion := *config.PowerShellVersion
		result.PowerShellVersion = &powerShellVersion
	}

	// Set property ‘PreWarmedInstanceCount’:
	if config.PreWarmedInstanceCount != nil {
		preWarmedInstanceCount := *config.PreWarmedInstanceCount
		result.PreWarmedInstanceCount = &preWarmedInstanceCount
	}

	// Set property ‘PublicNetworkAccess’:
	if config.PublicNetworkAccess != nil {
		publicNetworkAccess := *config.PublicNetworkAccess
		result.PublicNetworkAccess = &publicNetworkAccess
	}

	// Set property ‘PublishingUsername’:
	if config.PublishingUsername != nil {
		publishingUsername := *config.PublishingUsername
		result.PublishingUsername = &publishingUsername
	}

	// Set property ‘Push’:
	if config.Push != nil {
		pushARM, err := (*config.Push).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		push := *pushARM.(*Sites_Spec_Properties_SiteConfig_PushARM)
		result.Push = &push
	}

	// Set property ‘PythonVersion’:
	if config.PythonVersion != nil {
		pythonVersion := *config.PythonVersion
		result.PythonVersion = &pythonVersion
	}

	// Set property ‘RemoteDebuggingEnabled’:
	if config.RemoteDebuggingEnabled != nil {
		remoteDebuggingEnabled := *config.RemoteDebuggingEnabled
		result.RemoteDebuggingEnabled = &remoteDebuggingEnabled
	}

	// Set property ‘RemoteDebuggingVersion’:
	if config.RemoteDebuggingVersion != nil {
		remoteDebuggingVersion := *config.RemoteDebuggingVersion
		result.RemoteDebuggingVersion = &remoteDebuggingVersion
	}

	// Set property ‘RequestTracingEnabled’:
	if config.RequestTracingEnabled != nil {
		requestTracingEnabled := *config.RequestTracingEnabled
		result.RequestTracingEnabled = &requestTracingEnabled
	}

	// Set property ‘RequestTracingExpirationTime’:
	if config.RequestTracingExpirationTime != nil {
		requestTracingExpirationTime := *config.RequestTracingExpirationTime
		result.RequestTracingExpirationTime = &requestTracingExpirationTime
	}

	// Set property ‘ScmIpSecurityRestrictions’:
	for _, item := range config.ScmIpSecurityRestrictions {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.ScmIpSecurityRestrictions = append(result.ScmIpSecurityRestrictions, *itemARM.(*IpSecurityRestrictionARM))
	}

	// Set property ‘ScmIpSecurityRestrictionsUseMain’:
	if config.ScmIpSecurityRestrictionsUseMain != nil {
		scmIpSecurityRestrictionsUseMain := *config.ScmIpSecurityRestrictionsUseMain
		result.ScmIpSecurityRestrictionsUseMain = &scmIpSecurityRestrictionsUseMain
	}

	// Set property ‘ScmMinTlsVersion’:
	if config.ScmMinTlsVersion != nil {
		scmMinTlsVersion := *config.ScmMinTlsVersion
		result.ScmMinTlsVersion = &scmMinTlsVersion
	}

	// Set property ‘ScmType’:
	if config.ScmType != nil {
		scmType := *config.ScmType
		result.ScmType = &scmType
	}

	// Set property ‘TracingOptions’:
	if config.TracingOptions != nil {
		tracingOptions := *config.TracingOptions
		result.TracingOptions = &tracingOptions
	}

	// Set property ‘Use32BitWorkerProcess’:
	if config.Use32BitWorkerProcess != nil {
		use32BitWorkerProcess := *config.Use32BitWorkerProcess
		result.Use32BitWorkerProcess = &use32BitWorkerProcess
	}

	// Set property ‘VirtualApplications’:
	for _, item := range config.VirtualApplications {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.VirtualApplications = append(result.VirtualApplications, *itemARM.(*VirtualApplicationARM))
	}

	// Set property ‘VnetName’:
	if config.VnetName != nil {
		vnetName := *config.VnetName
		result.VnetName = &vnetName
	}

	// Set property ‘VnetPrivatePortsCount’:
	if config.VnetPrivatePortsCount != nil {
		vnetPrivatePortsCount := *config.VnetPrivatePortsCount
		result.VnetPrivatePortsCount = &vnetPrivatePortsCount
	}

	// Set property ‘VnetRouteAllEnabled’:
	if config.VnetRouteAllEnabled != nil {
		vnetRouteAllEnabled := *config.VnetRouteAllEnabled
		result.VnetRouteAllEnabled = &vnetRouteAllEnabled
	}

	// Set property ‘WebSocketsEnabled’:
	if config.WebSocketsEnabled != nil {
		webSocketsEnabled := *config.WebSocketsEnabled
		result.WebSocketsEnabled = &webSocketsEnabled
	}

	// Set property ‘WebsiteTimeZone’:
	if config.WebsiteTimeZone != nil {
		websiteTimeZone := *config.WebsiteTimeZone
		result.WebsiteTimeZone = &websiteTimeZone
	}

	// Set property ‘WindowsFxVersion’:
	if config.WindowsFxVersion != nil {
		windowsFxVersion := *config.WindowsFxVersion
		result.WindowsFxVersion = &windowsFxVersion
	}

	// Set property ‘XManagedServiceIdentityId’:
	if config.XManagedServiceIdentityId != nil {
		xManagedServiceIdentityId := *config.XManagedServiceIdentityId
		result.XManagedServiceIdentityId = &xManagedServiceIdentityId
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (config *Sites_Spec_Properties_SiteConfig) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Sites_Spec_Properties_SiteConfigARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (config *Sites_Spec_Properties_SiteConfig) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Sites_Spec_Properties_SiteConfigARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Sites_Spec_Properties_SiteConfigARM, got %T", armInput)
	}

	// Set property ‘AcrUseManagedIdentityCreds’:
	if typedInput.AcrUseManagedIdentityCreds != nil {
		acrUseManagedIdentityCreds := *typedInput.AcrUseManagedIdentityCreds
		config.AcrUseManagedIdentityCreds = &acrUseManagedIdentityCreds
	}

	// Set property ‘AcrUserManagedIdentityID’:
	if typedInput.AcrUserManagedIdentityID != nil {
		acrUserManagedIdentityID := *typedInput.AcrUserManagedIdentityID
		config.AcrUserManagedIdentityID = &acrUserManagedIdentityID
	}

	// Set property ‘AlwaysOn’:
	if typedInput.AlwaysOn != nil {
		alwaysOn := *typedInput.AlwaysOn
		config.AlwaysOn = &alwaysOn
	}

	// Set property ‘ApiDefinition’:
	if typedInput.ApiDefinition != nil {
		var apiDefinition1 ApiDefinitionInfo
		err := apiDefinition1.PopulateFromARM(owner, *typedInput.ApiDefinition)
		if err != nil {
			return err
		}
		apiDefinition := apiDefinition1
		config.ApiDefinition = &apiDefinition
	}

	// Set property ‘ApiManagementConfig’:
	if typedInput.ApiManagementConfig != nil {
		var apiManagementConfig1 ApiManagementConfig
		err := apiManagementConfig1.PopulateFromARM(owner, *typedInput.ApiManagementConfig)
		if err != nil {
			return err
		}
		apiManagementConfig := apiManagementConfig1
		config.ApiManagementConfig = &apiManagementConfig
	}

	// Set property ‘AppCommandLine’:
	if typedInput.AppCommandLine != nil {
		appCommandLine := *typedInput.AppCommandLine
		config.AppCommandLine = &appCommandLine
	}

	// Set property ‘AppSettings’:
	for _, item := range typedInput.AppSettings {
		var item1 NameValuePair
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		config.AppSettings = append(config.AppSettings, item1)
	}

	// Set property ‘AutoHealEnabled’:
	if typedInput.AutoHealEnabled != nil {
		autoHealEnabled := *typedInput.AutoHealEnabled
		config.AutoHealEnabled = &autoHealEnabled
	}

	// Set property ‘AutoHealRules’:
	if typedInput.AutoHealRules != nil {
		var autoHealRules1 AutoHealRules
		err := autoHealRules1.PopulateFromARM(owner, *typedInput.AutoHealRules)
		if err != nil {
			return err
		}
		autoHealRules := autoHealRules1
		config.AutoHealRules = &autoHealRules
	}

	// Set property ‘AutoSwapSlotName’:
	if typedInput.AutoSwapSlotName != nil {
		autoSwapSlotName := *typedInput.AutoSwapSlotName
		config.AutoSwapSlotName = &autoSwapSlotName
	}

	// Set property ‘AzureStorageAccounts’:
	if typedInput.AzureStorageAccounts != nil {
		config.AzureStorageAccounts = make(map[string]Sites_Spec_Properties_SiteConfig_AzureStorageAccounts, len(typedInput.AzureStorageAccounts))
		for key, value := range typedInput.AzureStorageAccounts {
			var value1 Sites_Spec_Properties_SiteConfig_AzureStorageAccounts
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			config.AzureStorageAccounts[key] = value1
		}
	}

	// Set property ‘ConnectionStrings’:
	for _, item := range typedInput.ConnectionStrings {
		var item1 ConnStringInfo
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		config.ConnectionStrings = append(config.ConnectionStrings, item1)
	}

	// Set property ‘Cors’:
	if typedInput.Cors != nil {
		var cors1 CorsSettings
		err := cors1.PopulateFromARM(owner, *typedInput.Cors)
		if err != nil {
			return err
		}
		cors := cors1
		config.Cors = &cors
	}

	// Set property ‘DefaultDocuments’:
	for _, item := range typedInput.DefaultDocuments {
		config.DefaultDocuments = append(config.DefaultDocuments, item)
	}

	// Set property ‘DetailedErrorLoggingEnabled’:
	if typedInput.DetailedErrorLoggingEnabled != nil {
		detailedErrorLoggingEnabled := *typedInput.DetailedErrorLoggingEnabled
		config.DetailedErrorLoggingEnabled = &detailedErrorLoggingEnabled
	}

	// Set property ‘DocumentRoot’:
	if typedInput.DocumentRoot != nil {
		documentRoot := *typedInput.DocumentRoot
		config.DocumentRoot = &documentRoot
	}

	// Set property ‘Experiments’:
	if typedInput.Experiments != nil {
		var experiments1 Experiments
		err := experiments1.PopulateFromARM(owner, *typedInput.Experiments)
		if err != nil {
			return err
		}
		experiments := experiments1
		config.Experiments = &experiments
	}

	// Set property ‘FtpsState’:
	if typedInput.FtpsState != nil {
		ftpsState := *typedInput.FtpsState
		config.FtpsState = &ftpsState
	}

	// Set property ‘FunctionAppScaleLimit’:
	if typedInput.FunctionAppScaleLimit != nil {
		functionAppScaleLimit := *typedInput.FunctionAppScaleLimit
		config.FunctionAppScaleLimit = &functionAppScaleLimit
	}

	// Set property ‘FunctionsRuntimeScaleMonitoringEnabled’:
	if typedInput.FunctionsRuntimeScaleMonitoringEnabled != nil {
		functionsRuntimeScaleMonitoringEnabled := *typedInput.FunctionsRuntimeScaleMonitoringEnabled
		config.FunctionsRuntimeScaleMonitoringEnabled = &functionsRuntimeScaleMonitoringEnabled
	}

	// Set property ‘HandlerMappings’:
	for _, item := range typedInput.HandlerMappings {
		var item1 HandlerMapping
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		config.HandlerMappings = append(config.HandlerMappings, item1)
	}

	// Set property ‘HealthCheckPath’:
	if typedInput.HealthCheckPath != nil {
		healthCheckPath := *typedInput.HealthCheckPath
		config.HealthCheckPath = &healthCheckPath
	}

	// Set property ‘Http20Enabled’:
	if typedInput.Http20Enabled != nil {
		http20Enabled := *typedInput.Http20Enabled
		config.Http20Enabled = &http20Enabled
	}

	// Set property ‘HttpLoggingEnabled’:
	if typedInput.HttpLoggingEnabled != nil {
		httpLoggingEnabled := *typedInput.HttpLoggingEnabled
		config.HttpLoggingEnabled = &httpLoggingEnabled
	}

	// Set property ‘IpSecurityRestrictions’:
	for _, item := range typedInput.IpSecurityRestrictions {
		var item1 IpSecurityRestriction
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		config.IpSecurityRestrictions = append(config.IpSecurityRestrictions, item1)
	}

	// Set property ‘JavaContainer’:
	if typedInput.JavaContainer != nil {
		javaContainer := *typedInput.JavaContainer
		config.JavaContainer = &javaContainer
	}

	// Set property ‘JavaContainerVersion’:
	if typedInput.JavaContainerVersion != nil {
		javaContainerVersion := *typedInput.JavaContainerVersion
		config.JavaContainerVersion = &javaContainerVersion
	}

	// Set property ‘JavaVersion’:
	if typedInput.JavaVersion != nil {
		javaVersion := *typedInput.JavaVersion
		config.JavaVersion = &javaVersion
	}

	// Set property ‘KeyVaultReferenceIdentity’:
	if typedInput.KeyVaultReferenceIdentity != nil {
		keyVaultReferenceIdentity := *typedInput.KeyVaultReferenceIdentity
		config.KeyVaultReferenceIdentity = &keyVaultReferenceIdentity
	}

	// Set property ‘Limits’:
	if typedInput.Limits != nil {
		var limits1 SiteLimits
		err := limits1.PopulateFromARM(owner, *typedInput.Limits)
		if err != nil {
			return err
		}
		limits := limits1
		config.Limits = &limits
	}

	// Set property ‘LinuxFxVersion’:
	if typedInput.LinuxFxVersion != nil {
		linuxFxVersion := *typedInput.LinuxFxVersion
		config.LinuxFxVersion = &linuxFxVersion
	}

	// Set property ‘LoadBalancing’:
	if typedInput.LoadBalancing != nil {
		loadBalancing := *typedInput.LoadBalancing
		config.LoadBalancing = &loadBalancing
	}

	// Set property ‘LocalMySqlEnabled’:
	if typedInput.LocalMySqlEnabled != nil {
		localMySqlEnabled := *typedInput.LocalMySqlEnabled
		config.LocalMySqlEnabled = &localMySqlEnabled
	}

	// Set property ‘LogsDirectorySizeLimit’:
	if typedInput.LogsDirectorySizeLimit != nil {
		logsDirectorySizeLimit := *typedInput.LogsDirectorySizeLimit
		config.LogsDirectorySizeLimit = &logsDirectorySizeLimit
	}

	// Set property ‘ManagedPipelineMode’:
	if typedInput.ManagedPipelineMode != nil {
		managedPipelineMode := *typedInput.ManagedPipelineMode
		config.ManagedPipelineMode = &managedPipelineMode
	}

	// Set property ‘ManagedServiceIdentityId’:
	if typedInput.ManagedServiceIdentityId != nil {
		managedServiceIdentityId := *typedInput.ManagedServiceIdentityId
		config.ManagedServiceIdentityId = &managedServiceIdentityId
	}

	// Set property ‘MinTlsVersion’:
	if typedInput.MinTlsVersion != nil {
		minTlsVersion := *typedInput.MinTlsVersion
		config.MinTlsVersion = &minTlsVersion
	}

	// Set property ‘MinimumElasticInstanceCount’:
	if typedInput.MinimumElasticInstanceCount != nil {
		minimumElasticInstanceCount := *typedInput.MinimumElasticInstanceCount
		config.MinimumElasticInstanceCount = &minimumElasticInstanceCount
	}

	// Set property ‘NetFrameworkVersion’:
	if typedInput.NetFrameworkVersion != nil {
		netFrameworkVersion := *typedInput.NetFrameworkVersion
		config.NetFrameworkVersion = &netFrameworkVersion
	}

	// Set property ‘NodeVersion’:
	if typedInput.NodeVersion != nil {
		nodeVersion := *typedInput.NodeVersion
		config.NodeVersion = &nodeVersion
	}

	// Set property ‘NumberOfWorkers’:
	if typedInput.NumberOfWorkers != nil {
		numberOfWorkers := *typedInput.NumberOfWorkers
		config.NumberOfWorkers = &numberOfWorkers
	}

	// Set property ‘PhpVersion’:
	if typedInput.PhpVersion != nil {
		phpVersion := *typedInput.PhpVersion
		config.PhpVersion = &phpVersion
	}

	// Set property ‘PowerShellVersion’:
	if typedInput.PowerShellVersion != nil {
		powerShellVersion := *typedInput.PowerShellVersion
		config.PowerShellVersion = &powerShellVersion
	}

	// Set property ‘PreWarmedInstanceCount’:
	if typedInput.PreWarmedInstanceCount != nil {
		preWarmedInstanceCount := *typedInput.PreWarmedInstanceCount
		config.PreWarmedInstanceCount = &preWarmedInstanceCount
	}

	// Set property ‘PublicNetworkAccess’:
	if typedInput.PublicNetworkAccess != nil {
		publicNetworkAccess := *typedInput.PublicNetworkAccess
		config.PublicNetworkAccess = &publicNetworkAccess
	}

	// Set property ‘PublishingUsername’:
	if typedInput.PublishingUsername != nil {
		publishingUsername := *typedInput.PublishingUsername
		config.PublishingUsername = &publishingUsername
	}

	// Set property ‘Push’:
	if typedInput.Push != nil {
		var push1 Sites_Spec_Properties_SiteConfig_Push
		err := push1.PopulateFromARM(owner, *typedInput.Push)
		if err != nil {
			return err
		}
		push := push1
		config.Push = &push
	}

	// Set property ‘PythonVersion’:
	if typedInput.PythonVersion != nil {
		pythonVersion := *typedInput.PythonVersion
		config.PythonVersion = &pythonVersion
	}

	// Set property ‘RemoteDebuggingEnabled’:
	if typedInput.RemoteDebuggingEnabled != nil {
		remoteDebuggingEnabled := *typedInput.RemoteDebuggingEnabled
		config.RemoteDebuggingEnabled = &remoteDebuggingEnabled
	}

	// Set property ‘RemoteDebuggingVersion’:
	if typedInput.RemoteDebuggingVersion != nil {
		remoteDebuggingVersion := *typedInput.RemoteDebuggingVersion
		config.RemoteDebuggingVersion = &remoteDebuggingVersion
	}

	// Set property ‘RequestTracingEnabled’:
	if typedInput.RequestTracingEnabled != nil {
		requestTracingEnabled := *typedInput.RequestTracingEnabled
		config.RequestTracingEnabled = &requestTracingEnabled
	}

	// Set property ‘RequestTracingExpirationTime’:
	if typedInput.RequestTracingExpirationTime != nil {
		requestTracingExpirationTime := *typedInput.RequestTracingExpirationTime
		config.RequestTracingExpirationTime = &requestTracingExpirationTime
	}

	// Set property ‘ScmIpSecurityRestrictions’:
	for _, item := range typedInput.ScmIpSecurityRestrictions {
		var item1 IpSecurityRestriction
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		config.ScmIpSecurityRestrictions = append(config.ScmIpSecurityRestrictions, item1)
	}

	// Set property ‘ScmIpSecurityRestrictionsUseMain’:
	if typedInput.ScmIpSecurityRestrictionsUseMain != nil {
		scmIpSecurityRestrictionsUseMain := *typedInput.ScmIpSecurityRestrictionsUseMain
		config.ScmIpSecurityRestrictionsUseMain = &scmIpSecurityRestrictionsUseMain
	}

	// Set property ‘ScmMinTlsVersion’:
	if typedInput.ScmMinTlsVersion != nil {
		scmMinTlsVersion := *typedInput.ScmMinTlsVersion
		config.ScmMinTlsVersion = &scmMinTlsVersion
	}

	// Set property ‘ScmType’:
	if typedInput.ScmType != nil {
		scmType := *typedInput.ScmType
		config.ScmType = &scmType
	}

	// Set property ‘TracingOptions’:
	if typedInput.TracingOptions != nil {
		tracingOptions := *typedInput.TracingOptions
		config.TracingOptions = &tracingOptions
	}

	// Set property ‘Use32BitWorkerProcess’:
	if typedInput.Use32BitWorkerProcess != nil {
		use32BitWorkerProcess := *typedInput.Use32BitWorkerProcess
		config.Use32BitWorkerProcess = &use32BitWorkerProcess
	}

	// Set property ‘VirtualApplications’:
	for _, item := range typedInput.VirtualApplications {
		var item1 VirtualApplication
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		config.VirtualApplications = append(config.VirtualApplications, item1)
	}

	// Set property ‘VnetName’:
	if typedInput.VnetName != nil {
		vnetName := *typedInput.VnetName
		config.VnetName = &vnetName
	}

	// Set property ‘VnetPrivatePortsCount’:
	if typedInput.VnetPrivatePortsCount != nil {
		vnetPrivatePortsCount := *typedInput.VnetPrivatePortsCount
		config.VnetPrivatePortsCount = &vnetPrivatePortsCount
	}

	// Set property ‘VnetRouteAllEnabled’:
	if typedInput.VnetRouteAllEnabled != nil {
		vnetRouteAllEnabled := *typedInput.VnetRouteAllEnabled
		config.VnetRouteAllEnabled = &vnetRouteAllEnabled
	}

	// Set property ‘WebSocketsEnabled’:
	if typedInput.WebSocketsEnabled != nil {
		webSocketsEnabled := *typedInput.WebSocketsEnabled
		config.WebSocketsEnabled = &webSocketsEnabled
	}

	// Set property ‘WebsiteTimeZone’:
	if typedInput.WebsiteTimeZone != nil {
		websiteTimeZone := *typedInput.WebsiteTimeZone
		config.WebsiteTimeZone = &websiteTimeZone
	}

	// Set property ‘WindowsFxVersion’:
	if typedInput.WindowsFxVersion != nil {
		windowsFxVersion := *typedInput.WindowsFxVersion
		config.WindowsFxVersion = &windowsFxVersion
	}

	// Set property ‘XManagedServiceIdentityId’:
	if typedInput.XManagedServiceIdentityId != nil {
		xManagedServiceIdentityId := *typedInput.XManagedServiceIdentityId
		config.XManagedServiceIdentityId = &xManagedServiceIdentityId
	}

	// No error
	return nil
}

// AssignPropertiesFromSitesSpecPropertiesSiteConfig populates our Sites_Spec_Properties_SiteConfig from the provided source Sites_Spec_Properties_SiteConfig
func (config *Sites_Spec_Properties_SiteConfig) AssignPropertiesFromSitesSpecPropertiesSiteConfig(source *v20220301s.Sites_Spec_Properties_SiteConfig) error {

	// AcrUseManagedIdentityCreds
	if source.AcrUseManagedIdentityCreds != nil {
		acrUseManagedIdentityCred := *source.AcrUseManagedIdentityCreds
		config.AcrUseManagedIdentityCreds = &acrUseManagedIdentityCred
	} else {
		config.AcrUseManagedIdentityCreds = nil
	}

	// AcrUserManagedIdentityID
	config.AcrUserManagedIdentityID = genruntime.ClonePointerToString(source.AcrUserManagedIdentityID)

	// AlwaysOn
	if source.AlwaysOn != nil {
		alwaysOn := *source.AlwaysOn
		config.AlwaysOn = &alwaysOn
	} else {
		config.AlwaysOn = nil
	}

	// ApiDefinition
	if source.ApiDefinition != nil {
		var apiDefinition ApiDefinitionInfo
		err := apiDefinition.AssignPropertiesFromApiDefinitionInfo(source.ApiDefinition)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromApiDefinitionInfo() to populate field ApiDefinition")
		}
		config.ApiDefinition = &apiDefinition
	} else {
		config.ApiDefinition = nil
	}

	// ApiManagementConfig
	if source.ApiManagementConfig != nil {
		var apiManagementConfig ApiManagementConfig
		err := apiManagementConfig.AssignPropertiesFromApiManagementConfig(source.ApiManagementConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromApiManagementConfig() to populate field ApiManagementConfig")
		}
		config.ApiManagementConfig = &apiManagementConfig
	} else {
		config.ApiManagementConfig = nil
	}

	// AppCommandLine
	config.AppCommandLine = genruntime.ClonePointerToString(source.AppCommandLine)

	// AppSettings
	if source.AppSettings != nil {
		appSettingList := make([]NameValuePair, len(source.AppSettings))
		for appSettingIndex, appSettingItem := range source.AppSettings {
			// Shadow the loop variable to avoid aliasing
			appSettingItem := appSettingItem
			var appSetting NameValuePair
			err := appSetting.AssignPropertiesFromNameValuePair(&appSettingItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromNameValuePair() to populate field AppSettings")
			}
			appSettingList[appSettingIndex] = appSetting
		}
		config.AppSettings = appSettingList
	} else {
		config.AppSettings = nil
	}

	// AutoHealEnabled
	if source.AutoHealEnabled != nil {
		autoHealEnabled := *source.AutoHealEnabled
		config.AutoHealEnabled = &autoHealEnabled
	} else {
		config.AutoHealEnabled = nil
	}

	// AutoHealRules
	if source.AutoHealRules != nil {
		var autoHealRule AutoHealRules
		err := autoHealRule.AssignPropertiesFromAutoHealRules(source.AutoHealRules)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromAutoHealRules() to populate field AutoHealRules")
		}
		config.AutoHealRules = &autoHealRule
	} else {
		config.AutoHealRules = nil
	}

	// AutoSwapSlotName
	config.AutoSwapSlotName = genruntime.ClonePointerToString(source.AutoSwapSlotName)

	// AzureStorageAccounts
	if source.AzureStorageAccounts != nil {
		azureStorageAccountMap := make(map[string]Sites_Spec_Properties_SiteConfig_AzureStorageAccounts, len(source.AzureStorageAccounts))
		for azureStorageAccountKey, azureStorageAccountValue := range source.AzureStorageAccounts {
			// Shadow the loop variable to avoid aliasing
			azureStorageAccountValue := azureStorageAccountValue
			var azureStorageAccount Sites_Spec_Properties_SiteConfig_AzureStorageAccounts
			err := azureStorageAccount.AssignPropertiesFromSitesSpecPropertiesSiteConfigAzureStorageAccounts(&azureStorageAccountValue)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromSitesSpecPropertiesSiteConfigAzureStorageAccounts() to populate field AzureStorageAccounts")
			}
			azureStorageAccountMap[azureStorageAccountKey] = azureStorageAccount
		}
		config.AzureStorageAccounts = azureStorageAccountMap
	} else {
		config.AzureStorageAccounts = nil
	}

	// ConnectionStrings
	if source.ConnectionStrings != nil {
		connectionStringList := make([]ConnStringInfo, len(source.ConnectionStrings))
		for connectionStringIndex, connectionStringItem := range source.ConnectionStrings {
			// Shadow the loop variable to avoid aliasing
			connectionStringItem := connectionStringItem
			var connectionString ConnStringInfo
			err := connectionString.AssignPropertiesFromConnStringInfo(&connectionStringItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromConnStringInfo() to populate field ConnectionStrings")
			}
			connectionStringList[connectionStringIndex] = connectionString
		}
		config.ConnectionStrings = connectionStringList
	} else {
		config.ConnectionStrings = nil
	}

	// Cors
	if source.Cors != nil {
		var cor CorsSettings
		err := cor.AssignPropertiesFromCorsSettings(source.Cors)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromCorsSettings() to populate field Cors")
		}
		config.Cors = &cor
	} else {
		config.Cors = nil
	}

	// DefaultDocuments
	config.DefaultDocuments = genruntime.CloneSliceOfString(source.DefaultDocuments)

	// DetailedErrorLoggingEnabled
	if source.DetailedErrorLoggingEnabled != nil {
		detailedErrorLoggingEnabled := *source.DetailedErrorLoggingEnabled
		config.DetailedErrorLoggingEnabled = &detailedErrorLoggingEnabled
	} else {
		config.DetailedErrorLoggingEnabled = nil
	}

	// DocumentRoot
	config.DocumentRoot = genruntime.ClonePointerToString(source.DocumentRoot)

	// Experiments
	if source.Experiments != nil {
		var experiment Experiments
		err := experiment.AssignPropertiesFromExperiments(source.Experiments)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromExperiments() to populate field Experiments")
		}
		config.Experiments = &experiment
	} else {
		config.Experiments = nil
	}

	// FtpsState
	if source.FtpsState != nil {
		ftpsState := SitesSpecPropertiesSiteConfigFtpsState(*source.FtpsState)
		config.FtpsState = &ftpsState
	} else {
		config.FtpsState = nil
	}

	// FunctionAppScaleLimit
	if source.FunctionAppScaleLimit != nil {
		functionAppScaleLimit := *source.FunctionAppScaleLimit
		config.FunctionAppScaleLimit = &functionAppScaleLimit
	} else {
		config.FunctionAppScaleLimit = nil
	}

	// FunctionsRuntimeScaleMonitoringEnabled
	if source.FunctionsRuntimeScaleMonitoringEnabled != nil {
		functionsRuntimeScaleMonitoringEnabled := *source.FunctionsRuntimeScaleMonitoringEnabled
		config.FunctionsRuntimeScaleMonitoringEnabled = &functionsRuntimeScaleMonitoringEnabled
	} else {
		config.FunctionsRuntimeScaleMonitoringEnabled = nil
	}

	// HandlerMappings
	if source.HandlerMappings != nil {
		handlerMappingList := make([]HandlerMapping, len(source.HandlerMappings))
		for handlerMappingIndex, handlerMappingItem := range source.HandlerMappings {
			// Shadow the loop variable to avoid aliasing
			handlerMappingItem := handlerMappingItem
			var handlerMapping HandlerMapping
			err := handlerMapping.AssignPropertiesFromHandlerMapping(&handlerMappingItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromHandlerMapping() to populate field HandlerMappings")
			}
			handlerMappingList[handlerMappingIndex] = handlerMapping
		}
		config.HandlerMappings = handlerMappingList
	} else {
		config.HandlerMappings = nil
	}

	// HealthCheckPath
	config.HealthCheckPath = genruntime.ClonePointerToString(source.HealthCheckPath)

	// Http20Enabled
	if source.Http20Enabled != nil {
		http20Enabled := *source.Http20Enabled
		config.Http20Enabled = &http20Enabled
	} else {
		config.Http20Enabled = nil
	}

	// HttpLoggingEnabled
	if source.HttpLoggingEnabled != nil {
		httpLoggingEnabled := *source.HttpLoggingEnabled
		config.HttpLoggingEnabled = &httpLoggingEnabled
	} else {
		config.HttpLoggingEnabled = nil
	}

	// IpSecurityRestrictions
	if source.IpSecurityRestrictions != nil {
		ipSecurityRestrictionList := make([]IpSecurityRestriction, len(source.IpSecurityRestrictions))
		for ipSecurityRestrictionIndex, ipSecurityRestrictionItem := range source.IpSecurityRestrictions {
			// Shadow the loop variable to avoid aliasing
			ipSecurityRestrictionItem := ipSecurityRestrictionItem
			var ipSecurityRestriction IpSecurityRestriction
			err := ipSecurityRestriction.AssignPropertiesFromIpSecurityRestriction(&ipSecurityRestrictionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromIpSecurityRestriction() to populate field IpSecurityRestrictions")
			}
			ipSecurityRestrictionList[ipSecurityRestrictionIndex] = ipSecurityRestriction
		}
		config.IpSecurityRestrictions = ipSecurityRestrictionList
	} else {
		config.IpSecurityRestrictions = nil
	}

	// JavaContainer
	config.JavaContainer = genruntime.ClonePointerToString(source.JavaContainer)

	// JavaContainerVersion
	config.JavaContainerVersion = genruntime.ClonePointerToString(source.JavaContainerVersion)

	// JavaVersion
	config.JavaVersion = genruntime.ClonePointerToString(source.JavaVersion)

	// KeyVaultReferenceIdentity
	config.KeyVaultReferenceIdentity = genruntime.ClonePointerToString(source.KeyVaultReferenceIdentity)

	// Limits
	if source.Limits != nil {
		var limit SiteLimits
		err := limit.AssignPropertiesFromSiteLimits(source.Limits)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSiteLimits() to populate field Limits")
		}
		config.Limits = &limit
	} else {
		config.Limits = nil
	}

	// LinuxFxVersion
	config.LinuxFxVersion = genruntime.ClonePointerToString(source.LinuxFxVersion)

	// LoadBalancing
	if source.LoadBalancing != nil {
		loadBalancing := SitesSpecPropertiesSiteConfigLoadBalancing(*source.LoadBalancing)
		config.LoadBalancing = &loadBalancing
	} else {
		config.LoadBalancing = nil
	}

	// LocalMySqlEnabled
	if source.LocalMySqlEnabled != nil {
		localMySqlEnabled := *source.LocalMySqlEnabled
		config.LocalMySqlEnabled = &localMySqlEnabled
	} else {
		config.LocalMySqlEnabled = nil
	}

	// LogsDirectorySizeLimit
	config.LogsDirectorySizeLimit = genruntime.ClonePointerToInt(source.LogsDirectorySizeLimit)

	// ManagedPipelineMode
	if source.ManagedPipelineMode != nil {
		managedPipelineMode := SitesSpecPropertiesSiteConfigManagedPipelineMode(*source.ManagedPipelineMode)
		config.ManagedPipelineMode = &managedPipelineMode
	} else {
		config.ManagedPipelineMode = nil
	}

	// ManagedServiceIdentityId
	config.ManagedServiceIdentityId = genruntime.ClonePointerToInt(source.ManagedServiceIdentityId)

	// MinTlsVersion
	if source.MinTlsVersion != nil {
		minTlsVersion := SitesSpecPropertiesSiteConfigMinTlsVersion(*source.MinTlsVersion)
		config.MinTlsVersion = &minTlsVersion
	} else {
		config.MinTlsVersion = nil
	}

	// MinimumElasticInstanceCount
	if source.MinimumElasticInstanceCount != nil {
		minimumElasticInstanceCount := *source.MinimumElasticInstanceCount
		config.MinimumElasticInstanceCount = &minimumElasticInstanceCount
	} else {
		config.MinimumElasticInstanceCount = nil
	}

	// NetFrameworkVersion
	config.NetFrameworkVersion = genruntime.ClonePointerToString(source.NetFrameworkVersion)

	// NodeVersion
	config.NodeVersion = genruntime.ClonePointerToString(source.NodeVersion)

	// NumberOfWorkers
	config.NumberOfWorkers = genruntime.ClonePointerToInt(source.NumberOfWorkers)

	// PhpVersion
	config.PhpVersion = genruntime.ClonePointerToString(source.PhpVersion)

	// PowerShellVersion
	config.PowerShellVersion = genruntime.ClonePointerToString(source.PowerShellVersion)

	// PreWarmedInstanceCount
	if source.PreWarmedInstanceCount != nil {
		preWarmedInstanceCount := *source.PreWarmedInstanceCount
		config.PreWarmedInstanceCount = &preWarmedInstanceCount
	} else {
		config.PreWarmedInstanceCount = nil
	}

	// PublicNetworkAccess
	config.PublicNetworkAccess = genruntime.ClonePointerToString(source.PublicNetworkAccess)

	// PublishingUsername
	config.PublishingUsername = genruntime.ClonePointerToString(source.PublishingUsername)

	// Push
	if source.Push != nil {
		var push Sites_Spec_Properties_SiteConfig_Push
		err := push.AssignPropertiesFromSitesSpecPropertiesSiteConfigPush(source.Push)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSitesSpecPropertiesSiteConfigPush() to populate field Push")
		}
		config.Push = &push
	} else {
		config.Push = nil
	}

	// PythonVersion
	config.PythonVersion = genruntime.ClonePointerToString(source.PythonVersion)

	// RemoteDebuggingEnabled
	if source.RemoteDebuggingEnabled != nil {
		remoteDebuggingEnabled := *source.RemoteDebuggingEnabled
		config.RemoteDebuggingEnabled = &remoteDebuggingEnabled
	} else {
		config.RemoteDebuggingEnabled = nil
	}

	// RemoteDebuggingVersion
	config.RemoteDebuggingVersion = genruntime.ClonePointerToString(source.RemoteDebuggingVersion)

	// RequestTracingEnabled
	if source.RequestTracingEnabled != nil {
		requestTracingEnabled := *source.RequestTracingEnabled
		config.RequestTracingEnabled = &requestTracingEnabled
	} else {
		config.RequestTracingEnabled = nil
	}

	// RequestTracingExpirationTime
	if source.RequestTracingExpirationTime != nil {
		requestTracingExpirationTime := *source.RequestTracingExpirationTime
		config.RequestTracingExpirationTime = &requestTracingExpirationTime
	} else {
		config.RequestTracingExpirationTime = nil
	}

	// ScmIpSecurityRestrictions
	if source.ScmIpSecurityRestrictions != nil {
		scmIpSecurityRestrictionList := make([]IpSecurityRestriction, len(source.ScmIpSecurityRestrictions))
		for scmIpSecurityRestrictionIndex, scmIpSecurityRestrictionItem := range source.ScmIpSecurityRestrictions {
			// Shadow the loop variable to avoid aliasing
			scmIpSecurityRestrictionItem := scmIpSecurityRestrictionItem
			var scmIpSecurityRestriction IpSecurityRestriction
			err := scmIpSecurityRestriction.AssignPropertiesFromIpSecurityRestriction(&scmIpSecurityRestrictionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromIpSecurityRestriction() to populate field ScmIpSecurityRestrictions")
			}
			scmIpSecurityRestrictionList[scmIpSecurityRestrictionIndex] = scmIpSecurityRestriction
		}
		config.ScmIpSecurityRestrictions = scmIpSecurityRestrictionList
	} else {
		config.ScmIpSecurityRestrictions = nil
	}

	// ScmIpSecurityRestrictionsUseMain
	if source.ScmIpSecurityRestrictionsUseMain != nil {
		scmIpSecurityRestrictionsUseMain := *source.ScmIpSecurityRestrictionsUseMain
		config.ScmIpSecurityRestrictionsUseMain = &scmIpSecurityRestrictionsUseMain
	} else {
		config.ScmIpSecurityRestrictionsUseMain = nil
	}

	// ScmMinTlsVersion
	if source.ScmMinTlsVersion != nil {
		scmMinTlsVersion := SitesSpecPropertiesSiteConfigScmMinTlsVersion(*source.ScmMinTlsVersion)
		config.ScmMinTlsVersion = &scmMinTlsVersion
	} else {
		config.ScmMinTlsVersion = nil
	}

	// ScmType
	if source.ScmType != nil {
		scmType := SitesSpecPropertiesSiteConfigScmType(*source.ScmType)
		config.ScmType = &scmType
	} else {
		config.ScmType = nil
	}

	// TracingOptions
	config.TracingOptions = genruntime.ClonePointerToString(source.TracingOptions)

	// Use32BitWorkerProcess
	if source.Use32BitWorkerProcess != nil {
		use32BitWorkerProcess := *source.Use32BitWorkerProcess
		config.Use32BitWorkerProcess = &use32BitWorkerProcess
	} else {
		config.Use32BitWorkerProcess = nil
	}

	// VirtualApplications
	if source.VirtualApplications != nil {
		virtualApplicationList := make([]VirtualApplication, len(source.VirtualApplications))
		for virtualApplicationIndex, virtualApplicationItem := range source.VirtualApplications {
			// Shadow the loop variable to avoid aliasing
			virtualApplicationItem := virtualApplicationItem
			var virtualApplication VirtualApplication
			err := virtualApplication.AssignPropertiesFromVirtualApplication(&virtualApplicationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVirtualApplication() to populate field VirtualApplications")
			}
			virtualApplicationList[virtualApplicationIndex] = virtualApplication
		}
		config.VirtualApplications = virtualApplicationList
	} else {
		config.VirtualApplications = nil
	}

	// VnetName
	config.VnetName = genruntime.ClonePointerToString(source.VnetName)

	// VnetPrivatePortsCount
	config.VnetPrivatePortsCount = genruntime.ClonePointerToInt(source.VnetPrivatePortsCount)

	// VnetRouteAllEnabled
	if source.VnetRouteAllEnabled != nil {
		vnetRouteAllEnabled := *source.VnetRouteAllEnabled
		config.VnetRouteAllEnabled = &vnetRouteAllEnabled
	} else {
		config.VnetRouteAllEnabled = nil
	}

	// WebSocketsEnabled
	if source.WebSocketsEnabled != nil {
		webSocketsEnabled := *source.WebSocketsEnabled
		config.WebSocketsEnabled = &webSocketsEnabled
	} else {
		config.WebSocketsEnabled = nil
	}

	// WebsiteTimeZone
	config.WebsiteTimeZone = genruntime.ClonePointerToString(source.WebsiteTimeZone)

	// WindowsFxVersion
	config.WindowsFxVersion = genruntime.ClonePointerToString(source.WindowsFxVersion)

	// XManagedServiceIdentityId
	config.XManagedServiceIdentityId = genruntime.ClonePointerToInt(source.XManagedServiceIdentityId)

	// No error
	return nil
}

// AssignPropertiesToSitesSpecPropertiesSiteConfig populates the provided destination Sites_Spec_Properties_SiteConfig from our Sites_Spec_Properties_SiteConfig
func (config *Sites_Spec_Properties_SiteConfig) AssignPropertiesToSitesSpecPropertiesSiteConfig(destination *v20220301s.Sites_Spec_Properties_SiteConfig) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AcrUseManagedIdentityCreds
	if config.AcrUseManagedIdentityCreds != nil {
		acrUseManagedIdentityCred := *config.AcrUseManagedIdentityCreds
		destination.AcrUseManagedIdentityCreds = &acrUseManagedIdentityCred
	} else {
		destination.AcrUseManagedIdentityCreds = nil
	}

	// AcrUserManagedIdentityID
	destination.AcrUserManagedIdentityID = genruntime.ClonePointerToString(config.AcrUserManagedIdentityID)

	// AlwaysOn
	if config.AlwaysOn != nil {
		alwaysOn := *config.AlwaysOn
		destination.AlwaysOn = &alwaysOn
	} else {
		destination.AlwaysOn = nil
	}

	// ApiDefinition
	if config.ApiDefinition != nil {
		var apiDefinition v20220301s.ApiDefinitionInfo
		err := config.ApiDefinition.AssignPropertiesToApiDefinitionInfo(&apiDefinition)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToApiDefinitionInfo() to populate field ApiDefinition")
		}
		destination.ApiDefinition = &apiDefinition
	} else {
		destination.ApiDefinition = nil
	}

	// ApiManagementConfig
	if config.ApiManagementConfig != nil {
		var apiManagementConfig v20220301s.ApiManagementConfig
		err := config.ApiManagementConfig.AssignPropertiesToApiManagementConfig(&apiManagementConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToApiManagementConfig() to populate field ApiManagementConfig")
		}
		destination.ApiManagementConfig = &apiManagementConfig
	} else {
		destination.ApiManagementConfig = nil
	}

	// AppCommandLine
	destination.AppCommandLine = genruntime.ClonePointerToString(config.AppCommandLine)

	// AppSettings
	if config.AppSettings != nil {
		appSettingList := make([]v20220301s.NameValuePair, len(config.AppSettings))
		for appSettingIndex, appSettingItem := range config.AppSettings {
			// Shadow the loop variable to avoid aliasing
			appSettingItem := appSettingItem
			var appSetting v20220301s.NameValuePair
			err := appSettingItem.AssignPropertiesToNameValuePair(&appSetting)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToNameValuePair() to populate field AppSettings")
			}
			appSettingList[appSettingIndex] = appSetting
		}
		destination.AppSettings = appSettingList
	} else {
		destination.AppSettings = nil
	}

	// AutoHealEnabled
	if config.AutoHealEnabled != nil {
		autoHealEnabled := *config.AutoHealEnabled
		destination.AutoHealEnabled = &autoHealEnabled
	} else {
		destination.AutoHealEnabled = nil
	}

	// AutoHealRules
	if config.AutoHealRules != nil {
		var autoHealRule v20220301s.AutoHealRules
		err := config.AutoHealRules.AssignPropertiesToAutoHealRules(&autoHealRule)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToAutoHealRules() to populate field AutoHealRules")
		}
		destination.AutoHealRules = &autoHealRule
	} else {
		destination.AutoHealRules = nil
	}

	// AutoSwapSlotName
	destination.AutoSwapSlotName = genruntime.ClonePointerToString(config.AutoSwapSlotName)

	// AzureStorageAccounts
	if config.AzureStorageAccounts != nil {
		azureStorageAccountMap := make(map[string]v20220301s.Sites_Spec_Properties_SiteConfig_AzureStorageAccounts, len(config.AzureStorageAccounts))
		for azureStorageAccountKey, azureStorageAccountValue := range config.AzureStorageAccounts {
			// Shadow the loop variable to avoid aliasing
			azureStorageAccountValue := azureStorageAccountValue
			var azureStorageAccount v20220301s.Sites_Spec_Properties_SiteConfig_AzureStorageAccounts
			err := azureStorageAccountValue.AssignPropertiesToSitesSpecPropertiesSiteConfigAzureStorageAccounts(&azureStorageAccount)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToSitesSpecPropertiesSiteConfigAzureStorageAccounts() to populate field AzureStorageAccounts")
			}
			azureStorageAccountMap[azureStorageAccountKey] = azureStorageAccount
		}
		destination.AzureStorageAccounts = azureStorageAccountMap
	} else {
		destination.AzureStorageAccounts = nil
	}

	// ConnectionStrings
	if config.ConnectionStrings != nil {
		connectionStringList := make([]v20220301s.ConnStringInfo, len(config.ConnectionStrings))
		for connectionStringIndex, connectionStringItem := range config.ConnectionStrings {
			// Shadow the loop variable to avoid aliasing
			connectionStringItem := connectionStringItem
			var connectionString v20220301s.ConnStringInfo
			err := connectionStringItem.AssignPropertiesToConnStringInfo(&connectionString)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToConnStringInfo() to populate field ConnectionStrings")
			}
			connectionStringList[connectionStringIndex] = connectionString
		}
		destination.ConnectionStrings = connectionStringList
	} else {
		destination.ConnectionStrings = nil
	}

	// Cors
	if config.Cors != nil {
		var cor v20220301s.CorsSettings
		err := config.Cors.AssignPropertiesToCorsSettings(&cor)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToCorsSettings() to populate field Cors")
		}
		destination.Cors = &cor
	} else {
		destination.Cors = nil
	}

	// DefaultDocuments
	destination.DefaultDocuments = genruntime.CloneSliceOfString(config.DefaultDocuments)

	// DetailedErrorLoggingEnabled
	if config.DetailedErrorLoggingEnabled != nil {
		detailedErrorLoggingEnabled := *config.DetailedErrorLoggingEnabled
		destination.DetailedErrorLoggingEnabled = &detailedErrorLoggingEnabled
	} else {
		destination.DetailedErrorLoggingEnabled = nil
	}

	// DocumentRoot
	destination.DocumentRoot = genruntime.ClonePointerToString(config.DocumentRoot)

	// Experiments
	if config.Experiments != nil {
		var experiment v20220301s.Experiments
		err := config.Experiments.AssignPropertiesToExperiments(&experiment)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToExperiments() to populate field Experiments")
		}
		destination.Experiments = &experiment
	} else {
		destination.Experiments = nil
	}

	// FtpsState
	if config.FtpsState != nil {
		ftpsState := string(*config.FtpsState)
		destination.FtpsState = &ftpsState
	} else {
		destination.FtpsState = nil
	}

	// FunctionAppScaleLimit
	if config.FunctionAppScaleLimit != nil {
		functionAppScaleLimit := *config.FunctionAppScaleLimit
		destination.FunctionAppScaleLimit = &functionAppScaleLimit
	} else {
		destination.FunctionAppScaleLimit = nil
	}

	// FunctionsRuntimeScaleMonitoringEnabled
	if config.FunctionsRuntimeScaleMonitoringEnabled != nil {
		functionsRuntimeScaleMonitoringEnabled := *config.FunctionsRuntimeScaleMonitoringEnabled
		destination.FunctionsRuntimeScaleMonitoringEnabled = &functionsRuntimeScaleMonitoringEnabled
	} else {
		destination.FunctionsRuntimeScaleMonitoringEnabled = nil
	}

	// HandlerMappings
	if config.HandlerMappings != nil {
		handlerMappingList := make([]v20220301s.HandlerMapping, len(config.HandlerMappings))
		for handlerMappingIndex, handlerMappingItem := range config.HandlerMappings {
			// Shadow the loop variable to avoid aliasing
			handlerMappingItem := handlerMappingItem
			var handlerMapping v20220301s.HandlerMapping
			err := handlerMappingItem.AssignPropertiesToHandlerMapping(&handlerMapping)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToHandlerMapping() to populate field HandlerMappings")
			}
			handlerMappingList[handlerMappingIndex] = handlerMapping
		}
		destination.HandlerMappings = handlerMappingList
	} else {
		destination.HandlerMappings = nil
	}

	// HealthCheckPath
	destination.HealthCheckPath = genruntime.ClonePointerToString(config.HealthCheckPath)

	// Http20Enabled
	if config.Http20Enabled != nil {
		http20Enabled := *config.Http20Enabled
		destination.Http20Enabled = &http20Enabled
	} else {
		destination.Http20Enabled = nil
	}

	// HttpLoggingEnabled
	if config.HttpLoggingEnabled != nil {
		httpLoggingEnabled := *config.HttpLoggingEnabled
		destination.HttpLoggingEnabled = &httpLoggingEnabled
	} else {
		destination.HttpLoggingEnabled = nil
	}

	// IpSecurityRestrictions
	if config.IpSecurityRestrictions != nil {
		ipSecurityRestrictionList := make([]v20220301s.IpSecurityRestriction, len(config.IpSecurityRestrictions))
		for ipSecurityRestrictionIndex, ipSecurityRestrictionItem := range config.IpSecurityRestrictions {
			// Shadow the loop variable to avoid aliasing
			ipSecurityRestrictionItem := ipSecurityRestrictionItem
			var ipSecurityRestriction v20220301s.IpSecurityRestriction
			err := ipSecurityRestrictionItem.AssignPropertiesToIpSecurityRestriction(&ipSecurityRestriction)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToIpSecurityRestriction() to populate field IpSecurityRestrictions")
			}
			ipSecurityRestrictionList[ipSecurityRestrictionIndex] = ipSecurityRestriction
		}
		destination.IpSecurityRestrictions = ipSecurityRestrictionList
	} else {
		destination.IpSecurityRestrictions = nil
	}

	// JavaContainer
	destination.JavaContainer = genruntime.ClonePointerToString(config.JavaContainer)

	// JavaContainerVersion
	destination.JavaContainerVersion = genruntime.ClonePointerToString(config.JavaContainerVersion)

	// JavaVersion
	destination.JavaVersion = genruntime.ClonePointerToString(config.JavaVersion)

	// KeyVaultReferenceIdentity
	destination.KeyVaultReferenceIdentity = genruntime.ClonePointerToString(config.KeyVaultReferenceIdentity)

	// Limits
	if config.Limits != nil {
		var limit v20220301s.SiteLimits
		err := config.Limits.AssignPropertiesToSiteLimits(&limit)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSiteLimits() to populate field Limits")
		}
		destination.Limits = &limit
	} else {
		destination.Limits = nil
	}

	// LinuxFxVersion
	destination.LinuxFxVersion = genruntime.ClonePointerToString(config.LinuxFxVersion)

	// LoadBalancing
	if config.LoadBalancing != nil {
		loadBalancing := string(*config.LoadBalancing)
		destination.LoadBalancing = &loadBalancing
	} else {
		destination.LoadBalancing = nil
	}

	// LocalMySqlEnabled
	if config.LocalMySqlEnabled != nil {
		localMySqlEnabled := *config.LocalMySqlEnabled
		destination.LocalMySqlEnabled = &localMySqlEnabled
	} else {
		destination.LocalMySqlEnabled = nil
	}

	// LogsDirectorySizeLimit
	destination.LogsDirectorySizeLimit = genruntime.ClonePointerToInt(config.LogsDirectorySizeLimit)

	// ManagedPipelineMode
	if config.ManagedPipelineMode != nil {
		managedPipelineMode := string(*config.ManagedPipelineMode)
		destination.ManagedPipelineMode = &managedPipelineMode
	} else {
		destination.ManagedPipelineMode = nil
	}

	// ManagedServiceIdentityId
	destination.ManagedServiceIdentityId = genruntime.ClonePointerToInt(config.ManagedServiceIdentityId)

	// MinTlsVersion
	if config.MinTlsVersion != nil {
		minTlsVersion := string(*config.MinTlsVersion)
		destination.MinTlsVersion = &minTlsVersion
	} else {
		destination.MinTlsVersion = nil
	}

	// MinimumElasticInstanceCount
	if config.MinimumElasticInstanceCount != nil {
		minimumElasticInstanceCount := *config.MinimumElasticInstanceCount
		destination.MinimumElasticInstanceCount = &minimumElasticInstanceCount
	} else {
		destination.MinimumElasticInstanceCount = nil
	}

	// NetFrameworkVersion
	destination.NetFrameworkVersion = genruntime.ClonePointerToString(config.NetFrameworkVersion)

	// NodeVersion
	destination.NodeVersion = genruntime.ClonePointerToString(config.NodeVersion)

	// NumberOfWorkers
	destination.NumberOfWorkers = genruntime.ClonePointerToInt(config.NumberOfWorkers)

	// PhpVersion
	destination.PhpVersion = genruntime.ClonePointerToString(config.PhpVersion)

	// PowerShellVersion
	destination.PowerShellVersion = genruntime.ClonePointerToString(config.PowerShellVersion)

	// PreWarmedInstanceCount
	if config.PreWarmedInstanceCount != nil {
		preWarmedInstanceCount := *config.PreWarmedInstanceCount
		destination.PreWarmedInstanceCount = &preWarmedInstanceCount
	} else {
		destination.PreWarmedInstanceCount = nil
	}

	// PublicNetworkAccess
	destination.PublicNetworkAccess = genruntime.ClonePointerToString(config.PublicNetworkAccess)

	// PublishingUsername
	destination.PublishingUsername = genruntime.ClonePointerToString(config.PublishingUsername)

	// Push
	if config.Push != nil {
		var push v20220301s.Sites_Spec_Properties_SiteConfig_Push
		err := config.Push.AssignPropertiesToSitesSpecPropertiesSiteConfigPush(&push)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSitesSpecPropertiesSiteConfigPush() to populate field Push")
		}
		destination.Push = &push
	} else {
		destination.Push = nil
	}

	// PythonVersion
	destination.PythonVersion = genruntime.ClonePointerToString(config.PythonVersion)

	// RemoteDebuggingEnabled
	if config.RemoteDebuggingEnabled != nil {
		remoteDebuggingEnabled := *config.RemoteDebuggingEnabled
		destination.RemoteDebuggingEnabled = &remoteDebuggingEnabled
	} else {
		destination.RemoteDebuggingEnabled = nil
	}

	// RemoteDebuggingVersion
	destination.RemoteDebuggingVersion = genruntime.ClonePointerToString(config.RemoteDebuggingVersion)

	// RequestTracingEnabled
	if config.RequestTracingEnabled != nil {
		requestTracingEnabled := *config.RequestTracingEnabled
		destination.RequestTracingEnabled = &requestTracingEnabled
	} else {
		destination.RequestTracingEnabled = nil
	}

	// RequestTracingExpirationTime
	if config.RequestTracingExpirationTime != nil {
		requestTracingExpirationTime := *config.RequestTracingExpirationTime
		destination.RequestTracingExpirationTime = &requestTracingExpirationTime
	} else {
		destination.RequestTracingExpirationTime = nil
	}

	// ScmIpSecurityRestrictions
	if config.ScmIpSecurityRestrictions != nil {
		scmIpSecurityRestrictionList := make([]v20220301s.IpSecurityRestriction, len(config.ScmIpSecurityRestrictions))
		for scmIpSecurityRestrictionIndex, scmIpSecurityRestrictionItem := range config.ScmIpSecurityRestrictions {
			// Shadow the loop variable to avoid aliasing
			scmIpSecurityRestrictionItem := scmIpSecurityRestrictionItem
			var scmIpSecurityRestriction v20220301s.IpSecurityRestriction
			err := scmIpSecurityRestrictionItem.AssignPropertiesToIpSecurityRestriction(&scmIpSecurityRestriction)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToIpSecurityRestriction() to populate field ScmIpSecurityRestrictions")
			}
			scmIpSecurityRestrictionList[scmIpSecurityRestrictionIndex] = scmIpSecurityRestriction
		}
		destination.ScmIpSecurityRestrictions = scmIpSecurityRestrictionList
	} else {
		destination.ScmIpSecurityRestrictions = nil
	}

	// ScmIpSecurityRestrictionsUseMain
	if config.ScmIpSecurityRestrictionsUseMain != nil {
		scmIpSecurityRestrictionsUseMain := *config.ScmIpSecurityRestrictionsUseMain
		destination.ScmIpSecurityRestrictionsUseMain = &scmIpSecurityRestrictionsUseMain
	} else {
		destination.ScmIpSecurityRestrictionsUseMain = nil
	}

	// ScmMinTlsVersion
	if config.ScmMinTlsVersion != nil {
		scmMinTlsVersion := string(*config.ScmMinTlsVersion)
		destination.ScmMinTlsVersion = &scmMinTlsVersion
	} else {
		destination.ScmMinTlsVersion = nil
	}

	// ScmType
	if config.ScmType != nil {
		scmType := string(*config.ScmType)
		destination.ScmType = &scmType
	} else {
		destination.ScmType = nil
	}

	// TracingOptions
	destination.TracingOptions = genruntime.ClonePointerToString(config.TracingOptions)

	// Use32BitWorkerProcess
	if config.Use32BitWorkerProcess != nil {
		use32BitWorkerProcess := *config.Use32BitWorkerProcess
		destination.Use32BitWorkerProcess = &use32BitWorkerProcess
	} else {
		destination.Use32BitWorkerProcess = nil
	}

	// VirtualApplications
	if config.VirtualApplications != nil {
		virtualApplicationList := make([]v20220301s.VirtualApplication, len(config.VirtualApplications))
		for virtualApplicationIndex, virtualApplicationItem := range config.VirtualApplications {
			// Shadow the loop variable to avoid aliasing
			virtualApplicationItem := virtualApplicationItem
			var virtualApplication v20220301s.VirtualApplication
			err := virtualApplicationItem.AssignPropertiesToVirtualApplication(&virtualApplication)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVirtualApplication() to populate field VirtualApplications")
			}
			virtualApplicationList[virtualApplicationIndex] = virtualApplication
		}
		destination.VirtualApplications = virtualApplicationList
	} else {
		destination.VirtualApplications = nil
	}

	// VnetName
	destination.VnetName = genruntime.ClonePointerToString(config.VnetName)

	// VnetPrivatePortsCount
	destination.VnetPrivatePortsCount = genruntime.ClonePointerToInt(config.VnetPrivatePortsCount)

	// VnetRouteAllEnabled
	if config.VnetRouteAllEnabled != nil {
		vnetRouteAllEnabled := *config.VnetRouteAllEnabled
		destination.VnetRouteAllEnabled = &vnetRouteAllEnabled
	} else {
		destination.VnetRouteAllEnabled = nil
	}

	// WebSocketsEnabled
	if config.WebSocketsEnabled != nil {
		webSocketsEnabled := *config.WebSocketsEnabled
		destination.WebSocketsEnabled = &webSocketsEnabled
	} else {
		destination.WebSocketsEnabled = nil
	}

	// WebsiteTimeZone
	destination.WebsiteTimeZone = genruntime.ClonePointerToString(config.WebsiteTimeZone)

	// WindowsFxVersion
	destination.WindowsFxVersion = genruntime.ClonePointerToString(config.WindowsFxVersion)

	// XManagedServiceIdentityId
	destination.XManagedServiceIdentityId = genruntime.ClonePointerToInt(config.XManagedServiceIdentityId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Optional","OptionalInteractiveUser","Required"}
type SitesSpecPropertiesClientCertMode string

const (
	SitesSpecPropertiesClientCertMode_Optional                = SitesSpecPropertiesClientCertMode("Optional")
	SitesSpecPropertiesClientCertMode_OptionalInteractiveUser = SitesSpecPropertiesClientCertMode("OptionalInteractiveUser")
	SitesSpecPropertiesClientCertMode_Required                = SitesSpecPropertiesClientCertMode("Required")
)

// +kubebuilder:validation:Enum={"ActiveActive","Failover","GeoRedundant","Manual","None"}
type SitesSpecPropertiesRedundancyMode string

const (
	SitesSpecPropertiesRedundancyMode_ActiveActive = SitesSpecPropertiesRedundancyMode("ActiveActive")
	SitesSpecPropertiesRedundancyMode_Failover     = SitesSpecPropertiesRedundancyMode("Failover")
	SitesSpecPropertiesRedundancyMode_GeoRedundant = SitesSpecPropertiesRedundancyMode("GeoRedundant")
	SitesSpecPropertiesRedundancyMode_Manual       = SitesSpecPropertiesRedundancyMode("Manual")
	SitesSpecPropertiesRedundancyMode_None         = SitesSpecPropertiesRedundancyMode("None")
)

type SiteSTATUSPropertiesAvailabilityState string

const (
	SiteSTATUSPropertiesAvailabilityState_DisasterRecoveryMode = SiteSTATUSPropertiesAvailabilityState("DisasterRecoveryMode")
	SiteSTATUSPropertiesAvailabilityState_Limited              = SiteSTATUSPropertiesAvailabilityState("Limited")
	SiteSTATUSPropertiesAvailabilityState_Normal               = SiteSTATUSPropertiesAvailabilityState("Normal")
)

type SiteSTATUSPropertiesClientCertMode string

const (
	SiteSTATUSPropertiesClientCertMode_Optional                = SiteSTATUSPropertiesClientCertMode("Optional")
	SiteSTATUSPropertiesClientCertMode_OptionalInteractiveUser = SiteSTATUSPropertiesClientCertMode("OptionalInteractiveUser")
	SiteSTATUSPropertiesClientCertMode_Required                = SiteSTATUSPropertiesClientCertMode("Required")
)

type SiteSTATUSPropertiesRedundancyMode string

const (
	SiteSTATUSPropertiesRedundancyMode_ActiveActive = SiteSTATUSPropertiesRedundancyMode("ActiveActive")
	SiteSTATUSPropertiesRedundancyMode_Failover     = SiteSTATUSPropertiesRedundancyMode("Failover")
	SiteSTATUSPropertiesRedundancyMode_GeoRedundant = SiteSTATUSPropertiesRedundancyMode("GeoRedundant")
	SiteSTATUSPropertiesRedundancyMode_Manual       = SiteSTATUSPropertiesRedundancyMode("Manual")
	SiteSTATUSPropertiesRedundancyMode_None         = SiteSTATUSPropertiesRedundancyMode("None")
)

type SiteSTATUSPropertiesUsageState string

const (
	SiteSTATUSPropertiesUsageState_Exceeded = SiteSTATUSPropertiesUsageState("Exceeded")
	SiteSTATUSPropertiesUsageState_Normal   = SiteSTATUSPropertiesUsageState("Normal")
)

type SlotSwapStatus_STATUS struct {
	// DestinationSlotName: The destination slot of the last swap operation.
	DestinationSlotName *string `json:"destinationSlotName,omitempty"`

	// SourceSlotName: The source slot of the last swap operation.
	SourceSlotName *string `json:"sourceSlotName,omitempty"`

	// TimestampUtc: The time the last successful slot swap completed.
	TimestampUtc *string `json:"timestampUtc,omitempty"`
}

var _ genruntime.FromARMConverter = &SlotSwapStatus_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (status *SlotSwapStatus_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SlotSwapStatus_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (status *SlotSwapStatus_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SlotSwapStatus_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SlotSwapStatus_STATUSARM, got %T", armInput)
	}

	// Set property ‘DestinationSlotName’:
	if typedInput.DestinationSlotName != nil {
		destinationSlotName := *typedInput.DestinationSlotName
		status.DestinationSlotName = &destinationSlotName
	}

	// Set property ‘SourceSlotName’:
	if typedInput.SourceSlotName != nil {
		sourceSlotName := *typedInput.SourceSlotName
		status.SourceSlotName = &sourceSlotName
	}

	// Set property ‘TimestampUtc’:
	if typedInput.TimestampUtc != nil {
		timestampUtc := *typedInput.TimestampUtc
		status.TimestampUtc = &timestampUtc
	}

	// No error
	return nil
}

// AssignPropertiesFromSlotSwapStatusSTATUS populates our SlotSwapStatus_STATUS from the provided source SlotSwapStatus_STATUS
func (status *SlotSwapStatus_STATUS) AssignPropertiesFromSlotSwapStatusSTATUS(source *v20220301s.SlotSwapStatus_STATUS) error {

	// DestinationSlotName
	status.DestinationSlotName = genruntime.ClonePointerToString(source.DestinationSlotName)

	// SourceSlotName
	status.SourceSlotName = genruntime.ClonePointerToString(source.SourceSlotName)

	// TimestampUtc
	status.TimestampUtc = genruntime.ClonePointerToString(source.TimestampUtc)

	// No error
	return nil
}

// AssignPropertiesToSlotSwapStatusSTATUS populates the provided destination SlotSwapStatus_STATUS from our SlotSwapStatus_STATUS
func (status *SlotSwapStatus_STATUS) AssignPropertiesToSlotSwapStatusSTATUS(destination *v20220301s.SlotSwapStatus_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DestinationSlotName
	destination.DestinationSlotName = genruntime.ClonePointerToString(status.DestinationSlotName)

	// SourceSlotName
	destination.SourceSlotName = genruntime.ClonePointerToString(status.SourceSlotName)

	// TimestampUtc
	destination.TimestampUtc = genruntime.ClonePointerToString(status.TimestampUtc)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2022-03-01/Microsoft.Web.json#/definitions/ApiDefinitionInfo
type ApiDefinitionInfo struct {
	// Url: The URL of the API definition.
	Url *string `json:"url,omitempty"`
}

var _ genruntime.ARMTransformer = &ApiDefinitionInfo{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (info *ApiDefinitionInfo) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if info == nil {
		return nil, nil
	}
	result := &ApiDefinitionInfoARM{}

	// Set property ‘Url’:
	if info.Url != nil {
		url := *info.Url
		result.Url = &url
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (info *ApiDefinitionInfo) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ApiDefinitionInfoARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (info *ApiDefinitionInfo) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ApiDefinitionInfoARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ApiDefinitionInfoARM, got %T", armInput)
	}

	// Set property ‘Url’:
	if typedInput.Url != nil {
		url := *typedInput.Url
		info.Url = &url
	}

	// No error
	return nil
}

// AssignPropertiesFromApiDefinitionInfo populates our ApiDefinitionInfo from the provided source ApiDefinitionInfo
func (info *ApiDefinitionInfo) AssignPropertiesFromApiDefinitionInfo(source *v20220301s.ApiDefinitionInfo) error {

	// Url
	info.Url = genruntime.ClonePointerToString(source.Url)

	// No error
	return nil
}

// AssignPropertiesToApiDefinitionInfo populates the provided destination ApiDefinitionInfo from our ApiDefinitionInfo
func (info *ApiDefinitionInfo) AssignPropertiesToApiDefinitionInfo(destination *v20220301s.ApiDefinitionInfo) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Url
	destination.Url = genruntime.ClonePointerToString(info.Url)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ApiDefinitionInfo_STATUS struct {
	// Url: The URL of the API definition.
	Url *string `json:"url,omitempty"`
}

var _ genruntime.FromARMConverter = &ApiDefinitionInfo_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (info *ApiDefinitionInfo_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ApiDefinitionInfo_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (info *ApiDefinitionInfo_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ApiDefinitionInfo_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ApiDefinitionInfo_STATUSARM, got %T", armInput)
	}

	// Set property ‘Url’:
	if typedInput.Url != nil {
		url := *typedInput.Url
		info.Url = &url
	}

	// No error
	return nil
}

// AssignPropertiesFromApiDefinitionInfoSTATUS populates our ApiDefinitionInfo_STATUS from the provided source ApiDefinitionInfo_STATUS
func (info *ApiDefinitionInfo_STATUS) AssignPropertiesFromApiDefinitionInfoSTATUS(source *v20220301s.ApiDefinitionInfo_STATUS) error {

	// Url
	info.Url = genruntime.ClonePointerToString(source.Url)

	// No error
	return nil
}

// AssignPropertiesToApiDefinitionInfoSTATUS populates the provided destination ApiDefinitionInfo_STATUS from our ApiDefinitionInfo_STATUS
func (info *ApiDefinitionInfo_STATUS) AssignPropertiesToApiDefinitionInfoSTATUS(destination *v20220301s.ApiDefinitionInfo_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Url
	destination.Url = genruntime.ClonePointerToString(info.Url)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2022-03-01/Microsoft.Web.json#/definitions/ApiManagementConfig
type ApiManagementConfig struct {
	// Reference: APIM-Api Identifier.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &ApiManagementConfig{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (config *ApiManagementConfig) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if config == nil {
		return nil, nil
	}
	result := &ApiManagementConfigARM{}

	// Set property ‘Id’:
	if config.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*config.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (config *ApiManagementConfig) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ApiManagementConfigARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (config *ApiManagementConfig) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(ApiManagementConfigARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ApiManagementConfigARM, got %T", armInput)
	}

	// no assignment for property ‘Reference’

	// No error
	return nil
}

// AssignPropertiesFromApiManagementConfig populates our ApiManagementConfig from the provided source ApiManagementConfig
func (config *ApiManagementConfig) AssignPropertiesFromApiManagementConfig(source *v20220301s.ApiManagementConfig) error {

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		config.Reference = &reference
	} else {
		config.Reference = nil
	}

	// No error
	return nil
}

// AssignPropertiesToApiManagementConfig populates the provided destination ApiManagementConfig from our ApiManagementConfig
func (config *ApiManagementConfig) AssignPropertiesToApiManagementConfig(destination *v20220301s.ApiManagementConfig) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if config.Reference != nil {
		reference := config.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ApiManagementConfig_STATUS struct {
	// Id: APIM-Api Identifier.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &ApiManagementConfig_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (config *ApiManagementConfig_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ApiManagementConfig_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (config *ApiManagementConfig_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ApiManagementConfig_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ApiManagementConfig_STATUSARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		config.Id = &id
	}

	// No error
	return nil
}

// AssignPropertiesFromApiManagementConfigSTATUS populates our ApiManagementConfig_STATUS from the provided source ApiManagementConfig_STATUS
func (config *ApiManagementConfig_STATUS) AssignPropertiesFromApiManagementConfigSTATUS(source *v20220301s.ApiManagementConfig_STATUS) error {

	// Id
	config.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignPropertiesToApiManagementConfigSTATUS populates the provided destination ApiManagementConfig_STATUS from our ApiManagementConfig_STATUS
func (config *ApiManagementConfig_STATUS) AssignPropertiesToApiManagementConfigSTATUS(destination *v20220301s.ApiManagementConfig_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(config.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2022-03-01/Microsoft.Web.json#/definitions/AutoHealRules
type AutoHealRules struct {
	// Actions: Actions which to take by the auto-heal module when a rule is triggered.
	Actions *AutoHealActions `json:"actions,omitempty"`

	// Triggers: Triggers for auto-heal.
	Triggers *AutoHealTriggers `json:"triggers,omitempty"`
}

var _ genruntime.ARMTransformer = &AutoHealRules{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rules *AutoHealRules) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rules == nil {
		return nil, nil
	}
	result := &AutoHealRulesARM{}

	// Set property ‘Actions’:
	if rules.Actions != nil {
		actionsARM, err := (*rules.Actions).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		actions := *actionsARM.(*AutoHealActionsARM)
		result.Actions = &actions
	}

	// Set property ‘Triggers’:
	if rules.Triggers != nil {
		triggersARM, err := (*rules.Triggers).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		triggers := *triggersARM.(*AutoHealTriggersARM)
		result.Triggers = &triggers
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rules *AutoHealRules) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AutoHealRulesARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rules *AutoHealRules) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AutoHealRulesARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AutoHealRulesARM, got %T", armInput)
	}

	// Set property ‘Actions’:
	if typedInput.Actions != nil {
		var actions1 AutoHealActions
		err := actions1.PopulateFromARM(owner, *typedInput.Actions)
		if err != nil {
			return err
		}
		actions := actions1
		rules.Actions = &actions
	}

	// Set property ‘Triggers’:
	if typedInput.Triggers != nil {
		var triggers1 AutoHealTriggers
		err := triggers1.PopulateFromARM(owner, *typedInput.Triggers)
		if err != nil {
			return err
		}
		triggers := triggers1
		rules.Triggers = &triggers
	}

	// No error
	return nil
}

// AssignPropertiesFromAutoHealRules populates our AutoHealRules from the provided source AutoHealRules
func (rules *AutoHealRules) AssignPropertiesFromAutoHealRules(source *v20220301s.AutoHealRules) error {

	// Actions
	if source.Actions != nil {
		var action AutoHealActions
		err := action.AssignPropertiesFromAutoHealActions(source.Actions)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromAutoHealActions() to populate field Actions")
		}
		rules.Actions = &action
	} else {
		rules.Actions = nil
	}

	// Triggers
	if source.Triggers != nil {
		var trigger AutoHealTriggers
		err := trigger.AssignPropertiesFromAutoHealTriggers(source.Triggers)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromAutoHealTriggers() to populate field Triggers")
		}
		rules.Triggers = &trigger
	} else {
		rules.Triggers = nil
	}

	// No error
	return nil
}

// AssignPropertiesToAutoHealRules populates the provided destination AutoHealRules from our AutoHealRules
func (rules *AutoHealRules) AssignPropertiesToAutoHealRules(destination *v20220301s.AutoHealRules) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Actions
	if rules.Actions != nil {
		var action v20220301s.AutoHealActions
		err := rules.Actions.AssignPropertiesToAutoHealActions(&action)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToAutoHealActions() to populate field Actions")
		}
		destination.Actions = &action
	} else {
		destination.Actions = nil
	}

	// Triggers
	if rules.Triggers != nil {
		var trigger v20220301s.AutoHealTriggers
		err := rules.Triggers.AssignPropertiesToAutoHealTriggers(&trigger)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToAutoHealTriggers() to populate field Triggers")
		}
		destination.Triggers = &trigger
	} else {
		destination.Triggers = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AutoHealRules_STATUS struct {
	// Actions: Actions to be executed when a rule is triggered.
	Actions *AutoHealActions_STATUS `json:"actions,omitempty"`

	// Triggers: Conditions that describe when to execute the auto-heal actions.
	Triggers *AutoHealTriggers_STATUS `json:"triggers,omitempty"`
}

var _ genruntime.FromARMConverter = &AutoHealRules_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rules *AutoHealRules_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AutoHealRules_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rules *AutoHealRules_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AutoHealRules_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AutoHealRules_STATUSARM, got %T", armInput)
	}

	// Set property ‘Actions’:
	if typedInput.Actions != nil {
		var actions1 AutoHealActions_STATUS
		err := actions1.PopulateFromARM(owner, *typedInput.Actions)
		if err != nil {
			return err
		}
		actions := actions1
		rules.Actions = &actions
	}

	// Set property ‘Triggers’:
	if typedInput.Triggers != nil {
		var triggers1 AutoHealTriggers_STATUS
		err := triggers1.PopulateFromARM(owner, *typedInput.Triggers)
		if err != nil {
			return err
		}
		triggers := triggers1
		rules.Triggers = &triggers
	}

	// No error
	return nil
}

// AssignPropertiesFromAutoHealRulesSTATUS populates our AutoHealRules_STATUS from the provided source AutoHealRules_STATUS
func (rules *AutoHealRules_STATUS) AssignPropertiesFromAutoHealRulesSTATUS(source *v20220301s.AutoHealRules_STATUS) error {

	// Actions
	if source.Actions != nil {
		var action AutoHealActions_STATUS
		err := action.AssignPropertiesFromAutoHealActionsSTATUS(source.Actions)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromAutoHealActionsSTATUS() to populate field Actions")
		}
		rules.Actions = &action
	} else {
		rules.Actions = nil
	}

	// Triggers
	if source.Triggers != nil {
		var trigger AutoHealTriggers_STATUS
		err := trigger.AssignPropertiesFromAutoHealTriggersSTATUS(source.Triggers)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromAutoHealTriggersSTATUS() to populate field Triggers")
		}
		rules.Triggers = &trigger
	} else {
		rules.Triggers = nil
	}

	// No error
	return nil
}

// AssignPropertiesToAutoHealRulesSTATUS populates the provided destination AutoHealRules_STATUS from our AutoHealRules_STATUS
func (rules *AutoHealRules_STATUS) AssignPropertiesToAutoHealRulesSTATUS(destination *v20220301s.AutoHealRules_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Actions
	if rules.Actions != nil {
		var action v20220301s.AutoHealActions_STATUS
		err := rules.Actions.AssignPropertiesToAutoHealActionsSTATUS(&action)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToAutoHealActionsSTATUS() to populate field Actions")
		}
		destination.Actions = &action
	} else {
		destination.Actions = nil
	}

	// Triggers
	if rules.Triggers != nil {
		var trigger v20220301s.AutoHealTriggers_STATUS
		err := rules.Triggers.AssignPropertiesToAutoHealTriggersSTATUS(&trigger)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToAutoHealTriggersSTATUS() to populate field Triggers")
		}
		destination.Triggers = &trigger
	} else {
		destination.Triggers = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AzureStorageInfoValue_STATUS struct {
	// AccountName: Name of the storage account.
	AccountName *string `json:"accountName,omitempty"`

	// MountPath: Path to mount the storage within the site's runtime environment.
	MountPath *string `json:"mountPath,omitempty"`

	// ShareName: Name of the file share (container name, for Blob storage).
	ShareName *string `json:"shareName,omitempty"`

	// State: State of the storage account.
	State *AzureStorageInfoValueSTATUSState `json:"state,omitempty"`

	// Type: Type of storage.
	Type *AzureStorageInfoValueSTATUSType `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &AzureStorageInfoValue_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (value *AzureStorageInfoValue_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AzureStorageInfoValue_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (value *AzureStorageInfoValue_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AzureStorageInfoValue_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AzureStorageInfoValue_STATUSARM, got %T", armInput)
	}

	// Set property ‘AccountName’:
	if typedInput.AccountName != nil {
		accountName := *typedInput.AccountName
		value.AccountName = &accountName
	}

	// Set property ‘MountPath’:
	if typedInput.MountPath != nil {
		mountPath := *typedInput.MountPath
		value.MountPath = &mountPath
	}

	// Set property ‘ShareName’:
	if typedInput.ShareName != nil {
		shareName := *typedInput.ShareName
		value.ShareName = &shareName
	}

	// Set property ‘State’:
	if typedInput.State != nil {
		state := *typedInput.State
		value.State = &state
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		value.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromAzureStorageInfoValueSTATUS populates our AzureStorageInfoValue_STATUS from the provided source AzureStorageInfoValue_STATUS
func (value *AzureStorageInfoValue_STATUS) AssignPropertiesFromAzureStorageInfoValueSTATUS(source *v20220301s.AzureStorageInfoValue_STATUS) error {

	// AccountName
	value.AccountName = genruntime.ClonePointerToString(source.AccountName)

	// MountPath
	value.MountPath = genruntime.ClonePointerToString(source.MountPath)

	// ShareName
	value.ShareName = genruntime.ClonePointerToString(source.ShareName)

	// State
	if source.State != nil {
		state := AzureStorageInfoValueSTATUSState(*source.State)
		value.State = &state
	} else {
		value.State = nil
	}

	// Type
	if source.Type != nil {
		typeVar := AzureStorageInfoValueSTATUSType(*source.Type)
		value.Type = &typeVar
	} else {
		value.Type = nil
	}

	// No error
	return nil
}

// AssignPropertiesToAzureStorageInfoValueSTATUS populates the provided destination AzureStorageInfoValue_STATUS from our AzureStorageInfoValue_STATUS
func (value *AzureStorageInfoValue_STATUS) AssignPropertiesToAzureStorageInfoValueSTATUS(destination *v20220301s.AzureStorageInfoValue_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AccountName
	destination.AccountName = genruntime.ClonePointerToString(value.AccountName)

	// MountPath
	destination.MountPath = genruntime.ClonePointerToString(value.MountPath)

	// ShareName
	destination.ShareName = genruntime.ClonePointerToString(value.ShareName)

	// State
	if value.State != nil {
		state := string(*value.State)
		destination.State = &state
	} else {
		destination.State = nil
	}

	// Type
	if value.Type != nil {
		typeVar := string(*value.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2022-03-01/Microsoft.Web.json#/definitions/ConnStringInfo
type ConnStringInfo struct {
	// ConnectionString: Connection string value.
	ConnectionString *string `json:"connectionString,omitempty"`

	// Name: Name of connection string.
	Name *string `json:"name,omitempty"`

	// Type: Type of database.
	Type *ConnStringInfoType `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &ConnStringInfo{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (info *ConnStringInfo) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if info == nil {
		return nil, nil
	}
	result := &ConnStringInfoARM{}

	// Set property ‘ConnectionString’:
	if info.ConnectionString != nil {
		connectionString := *info.ConnectionString
		result.ConnectionString = &connectionString
	}

	// Set property ‘Name’:
	if info.Name != nil {
		name := *info.Name
		result.Name = &name
	}

	// Set property ‘Type’:
	if info.Type != nil {
		typeVar := *info.Type
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (info *ConnStringInfo) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ConnStringInfoARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (info *ConnStringInfo) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ConnStringInfoARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ConnStringInfoARM, got %T", armInput)
	}

	// Set property ‘ConnectionString’:
	if typedInput.ConnectionString != nil {
		connectionString := *typedInput.ConnectionString
		info.ConnectionString = &connectionString
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		info.Name = &name
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		info.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromConnStringInfo populates our ConnStringInfo from the provided source ConnStringInfo
func (info *ConnStringInfo) AssignPropertiesFromConnStringInfo(source *v20220301s.ConnStringInfo) error {

	// ConnectionString
	info.ConnectionString = genruntime.ClonePointerToString(source.ConnectionString)

	// Name
	info.Name = genruntime.ClonePointerToString(source.Name)

	// Type
	if source.Type != nil {
		typeVar := ConnStringInfoType(*source.Type)
		info.Type = &typeVar
	} else {
		info.Type = nil
	}

	// No error
	return nil
}

// AssignPropertiesToConnStringInfo populates the provided destination ConnStringInfo from our ConnStringInfo
func (info *ConnStringInfo) AssignPropertiesToConnStringInfo(destination *v20220301s.ConnStringInfo) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConnectionString
	destination.ConnectionString = genruntime.ClonePointerToString(info.ConnectionString)

	// Name
	destination.Name = genruntime.ClonePointerToString(info.Name)

	// Type
	if info.Type != nil {
		typeVar := string(*info.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ConnStringInfo_STATUS struct {
	// ConnectionString: Connection string value.
	ConnectionString *string `json:"connectionString,omitempty"`

	// Name: Name of connection string.
	Name *string `json:"name,omitempty"`

	// Type: Type of database.
	Type *ConnStringInfoSTATUSType `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &ConnStringInfo_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (info *ConnStringInfo_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ConnStringInfo_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (info *ConnStringInfo_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ConnStringInfo_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ConnStringInfo_STATUSARM, got %T", armInput)
	}

	// Set property ‘ConnectionString’:
	if typedInput.ConnectionString != nil {
		connectionString := *typedInput.ConnectionString
		info.ConnectionString = &connectionString
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		info.Name = &name
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		info.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromConnStringInfoSTATUS populates our ConnStringInfo_STATUS from the provided source ConnStringInfo_STATUS
func (info *ConnStringInfo_STATUS) AssignPropertiesFromConnStringInfoSTATUS(source *v20220301s.ConnStringInfo_STATUS) error {

	// ConnectionString
	info.ConnectionString = genruntime.ClonePointerToString(source.ConnectionString)

	// Name
	info.Name = genruntime.ClonePointerToString(source.Name)

	// Type
	if source.Type != nil {
		typeVar := ConnStringInfoSTATUSType(*source.Type)
		info.Type = &typeVar
	} else {
		info.Type = nil
	}

	// No error
	return nil
}

// AssignPropertiesToConnStringInfoSTATUS populates the provided destination ConnStringInfo_STATUS from our ConnStringInfo_STATUS
func (info *ConnStringInfo_STATUS) AssignPropertiesToConnStringInfoSTATUS(destination *v20220301s.ConnStringInfo_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConnectionString
	destination.ConnectionString = genruntime.ClonePointerToString(info.ConnectionString)

	// Name
	destination.Name = genruntime.ClonePointerToString(info.Name)

	// Type
	if info.Type != nil {
		typeVar := string(*info.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2022-03-01/Microsoft.Web.json#/definitions/CorsSettings
type CorsSettings struct {
	// AllowedOrigins: Gets or sets the list of origins that should be allowed to make cross-origin
	// calls (for example: http://example.com:12345). Use "*" to allow all.
	AllowedOrigins []string `json:"allowedOrigins,omitempty"`

	// SupportCredentials: Gets or sets whether CORS requests with credentials are allowed. See
	// https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Requests_with_credentials
	// for more details.
	SupportCredentials *bool `json:"supportCredentials,omitempty"`
}

var _ genruntime.ARMTransformer = &CorsSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *CorsSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &CorsSettingsARM{}

	// Set property ‘AllowedOrigins’:
	for _, item := range settings.AllowedOrigins {
		result.AllowedOrigins = append(result.AllowedOrigins, item)
	}

	// Set property ‘SupportCredentials’:
	if settings.SupportCredentials != nil {
		supportCredentials := *settings.SupportCredentials
		result.SupportCredentials = &supportCredentials
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *CorsSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &CorsSettingsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *CorsSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(CorsSettingsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CorsSettingsARM, got %T", armInput)
	}

	// Set property ‘AllowedOrigins’:
	for _, item := range typedInput.AllowedOrigins {
		settings.AllowedOrigins = append(settings.AllowedOrigins, item)
	}

	// Set property ‘SupportCredentials’:
	if typedInput.SupportCredentials != nil {
		supportCredentials := *typedInput.SupportCredentials
		settings.SupportCredentials = &supportCredentials
	}

	// No error
	return nil
}

// AssignPropertiesFromCorsSettings populates our CorsSettings from the provided source CorsSettings
func (settings *CorsSettings) AssignPropertiesFromCorsSettings(source *v20220301s.CorsSettings) error {

	// AllowedOrigins
	settings.AllowedOrigins = genruntime.CloneSliceOfString(source.AllowedOrigins)

	// SupportCredentials
	if source.SupportCredentials != nil {
		supportCredential := *source.SupportCredentials
		settings.SupportCredentials = &supportCredential
	} else {
		settings.SupportCredentials = nil
	}

	// No error
	return nil
}

// AssignPropertiesToCorsSettings populates the provided destination CorsSettings from our CorsSettings
func (settings *CorsSettings) AssignPropertiesToCorsSettings(destination *v20220301s.CorsSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllowedOrigins
	destination.AllowedOrigins = genruntime.CloneSliceOfString(settings.AllowedOrigins)

	// SupportCredentials
	if settings.SupportCredentials != nil {
		supportCredential := *settings.SupportCredentials
		destination.SupportCredentials = &supportCredential
	} else {
		destination.SupportCredentials = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type CorsSettings_STATUS struct {
	// AllowedOrigins: Gets or sets the list of origins that should be allowed to make cross-origin
	// calls (for example: http://example.com:12345). Use "*" to allow all.
	AllowedOrigins []string `json:"allowedOrigins,omitempty"`

	// SupportCredentials: Gets or sets whether CORS requests with credentials are allowed. See
	// https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Requests_with_credentials
	// for more details.
	SupportCredentials *bool `json:"supportCredentials,omitempty"`
}

var _ genruntime.FromARMConverter = &CorsSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *CorsSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &CorsSettings_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *CorsSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(CorsSettings_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CorsSettings_STATUSARM, got %T", armInput)
	}

	// Set property ‘AllowedOrigins’:
	for _, item := range typedInput.AllowedOrigins {
		settings.AllowedOrigins = append(settings.AllowedOrigins, item)
	}

	// Set property ‘SupportCredentials’:
	if typedInput.SupportCredentials != nil {
		supportCredentials := *typedInput.SupportCredentials
		settings.SupportCredentials = &supportCredentials
	}

	// No error
	return nil
}

// AssignPropertiesFromCorsSettingsSTATUS populates our CorsSettings_STATUS from the provided source CorsSettings_STATUS
func (settings *CorsSettings_STATUS) AssignPropertiesFromCorsSettingsSTATUS(source *v20220301s.CorsSettings_STATUS) error {

	// AllowedOrigins
	settings.AllowedOrigins = genruntime.CloneSliceOfString(source.AllowedOrigins)

	// SupportCredentials
	if source.SupportCredentials != nil {
		supportCredential := *source.SupportCredentials
		settings.SupportCredentials = &supportCredential
	} else {
		settings.SupportCredentials = nil
	}

	// No error
	return nil
}

// AssignPropertiesToCorsSettingsSTATUS populates the provided destination CorsSettings_STATUS from our CorsSettings_STATUS
func (settings *CorsSettings_STATUS) AssignPropertiesToCorsSettingsSTATUS(destination *v20220301s.CorsSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllowedOrigins
	destination.AllowedOrigins = genruntime.CloneSliceOfString(settings.AllowedOrigins)

	// SupportCredentials
	if settings.SupportCredentials != nil {
		supportCredential := *settings.SupportCredentials
		destination.SupportCredentials = &supportCredential
	} else {
		destination.SupportCredentials = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2022-03-01/Microsoft.Web.json#/definitions/Experiments
type Experiments struct {
	// RampUpRules: List of ramp-up rules.
	RampUpRules []RampUpRule `json:"rampUpRules,omitempty"`
}

var _ genruntime.ARMTransformer = &Experiments{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (experiments *Experiments) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if experiments == nil {
		return nil, nil
	}
	result := &ExperimentsARM{}

	// Set property ‘RampUpRules’:
	for _, item := range experiments.RampUpRules {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.RampUpRules = append(result.RampUpRules, *itemARM.(*RampUpRuleARM))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (experiments *Experiments) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ExperimentsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (experiments *Experiments) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ExperimentsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ExperimentsARM, got %T", armInput)
	}

	// Set property ‘RampUpRules’:
	for _, item := range typedInput.RampUpRules {
		var item1 RampUpRule
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		experiments.RampUpRules = append(experiments.RampUpRules, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromExperiments populates our Experiments from the provided source Experiments
func (experiments *Experiments) AssignPropertiesFromExperiments(source *v20220301s.Experiments) error {

	// RampUpRules
	if source.RampUpRules != nil {
		rampUpRuleList := make([]RampUpRule, len(source.RampUpRules))
		for rampUpRuleIndex, rampUpRuleItem := range source.RampUpRules {
			// Shadow the loop variable to avoid aliasing
			rampUpRuleItem := rampUpRuleItem
			var rampUpRule RampUpRule
			err := rampUpRule.AssignPropertiesFromRampUpRule(&rampUpRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromRampUpRule() to populate field RampUpRules")
			}
			rampUpRuleList[rampUpRuleIndex] = rampUpRule
		}
		experiments.RampUpRules = rampUpRuleList
	} else {
		experiments.RampUpRules = nil
	}

	// No error
	return nil
}

// AssignPropertiesToExperiments populates the provided destination Experiments from our Experiments
func (experiments *Experiments) AssignPropertiesToExperiments(destination *v20220301s.Experiments) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// RampUpRules
	if experiments.RampUpRules != nil {
		rampUpRuleList := make([]v20220301s.RampUpRule, len(experiments.RampUpRules))
		for rampUpRuleIndex, rampUpRuleItem := range experiments.RampUpRules {
			// Shadow the loop variable to avoid aliasing
			rampUpRuleItem := rampUpRuleItem
			var rampUpRule v20220301s.RampUpRule
			err := rampUpRuleItem.AssignPropertiesToRampUpRule(&rampUpRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToRampUpRule() to populate field RampUpRules")
			}
			rampUpRuleList[rampUpRuleIndex] = rampUpRule
		}
		destination.RampUpRules = rampUpRuleList
	} else {
		destination.RampUpRules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Experiments_STATUS struct {
	// RampUpRules: List of ramp-up rules.
	RampUpRules []RampUpRule_STATUS `json:"rampUpRules,omitempty"`
}

var _ genruntime.FromARMConverter = &Experiments_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (experiments *Experiments_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Experiments_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (experiments *Experiments_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Experiments_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Experiments_STATUSARM, got %T", armInput)
	}

	// Set property ‘RampUpRules’:
	for _, item := range typedInput.RampUpRules {
		var item1 RampUpRule_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		experiments.RampUpRules = append(experiments.RampUpRules, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromExperimentsSTATUS populates our Experiments_STATUS from the provided source Experiments_STATUS
func (experiments *Experiments_STATUS) AssignPropertiesFromExperimentsSTATUS(source *v20220301s.Experiments_STATUS) error {

	// RampUpRules
	if source.RampUpRules != nil {
		rampUpRuleList := make([]RampUpRule_STATUS, len(source.RampUpRules))
		for rampUpRuleIndex, rampUpRuleItem := range source.RampUpRules {
			// Shadow the loop variable to avoid aliasing
			rampUpRuleItem := rampUpRuleItem
			var rampUpRule RampUpRule_STATUS
			err := rampUpRule.AssignPropertiesFromRampUpRuleSTATUS(&rampUpRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromRampUpRuleSTATUS() to populate field RampUpRules")
			}
			rampUpRuleList[rampUpRuleIndex] = rampUpRule
		}
		experiments.RampUpRules = rampUpRuleList
	} else {
		experiments.RampUpRules = nil
	}

	// No error
	return nil
}

// AssignPropertiesToExperimentsSTATUS populates the provided destination Experiments_STATUS from our Experiments_STATUS
func (experiments *Experiments_STATUS) AssignPropertiesToExperimentsSTATUS(destination *v20220301s.Experiments_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// RampUpRules
	if experiments.RampUpRules != nil {
		rampUpRuleList := make([]v20220301s.RampUpRule_STATUS, len(experiments.RampUpRules))
		for rampUpRuleIndex, rampUpRuleItem := range experiments.RampUpRules {
			// Shadow the loop variable to avoid aliasing
			rampUpRuleItem := rampUpRuleItem
			var rampUpRule v20220301s.RampUpRule_STATUS
			err := rampUpRuleItem.AssignPropertiesToRampUpRuleSTATUS(&rampUpRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToRampUpRuleSTATUS() to populate field RampUpRules")
			}
			rampUpRuleList[rampUpRuleIndex] = rampUpRule
		}
		destination.RampUpRules = rampUpRuleList
	} else {
		destination.RampUpRules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2022-03-01/Microsoft.Web.json#/definitions/HandlerMapping
type HandlerMapping struct {
	// Arguments: Command-line arguments to be passed to the script processor.
	Arguments *string `json:"arguments,omitempty"`

	// Extension: Requests with this extension will be handled using the specified FastCGI application.
	Extension *string `json:"extension,omitempty"`

	// ScriptProcessor: The absolute path to the FastCGI application.
	ScriptProcessor *string `json:"scriptProcessor,omitempty"`
}

var _ genruntime.ARMTransformer = &HandlerMapping{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (mapping *HandlerMapping) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if mapping == nil {
		return nil, nil
	}
	result := &HandlerMappingARM{}

	// Set property ‘Arguments’:
	if mapping.Arguments != nil {
		arguments := *mapping.Arguments
		result.Arguments = &arguments
	}

	// Set property ‘Extension’:
	if mapping.Extension != nil {
		extension := *mapping.Extension
		result.Extension = &extension
	}

	// Set property ‘ScriptProcessor’:
	if mapping.ScriptProcessor != nil {
		scriptProcessor := *mapping.ScriptProcessor
		result.ScriptProcessor = &scriptProcessor
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (mapping *HandlerMapping) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &HandlerMappingARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (mapping *HandlerMapping) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(HandlerMappingARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected HandlerMappingARM, got %T", armInput)
	}

	// Set property ‘Arguments’:
	if typedInput.Arguments != nil {
		arguments := *typedInput.Arguments
		mapping.Arguments = &arguments
	}

	// Set property ‘Extension’:
	if typedInput.Extension != nil {
		extension := *typedInput.Extension
		mapping.Extension = &extension
	}

	// Set property ‘ScriptProcessor’:
	if typedInput.ScriptProcessor != nil {
		scriptProcessor := *typedInput.ScriptProcessor
		mapping.ScriptProcessor = &scriptProcessor
	}

	// No error
	return nil
}

// AssignPropertiesFromHandlerMapping populates our HandlerMapping from the provided source HandlerMapping
func (mapping *HandlerMapping) AssignPropertiesFromHandlerMapping(source *v20220301s.HandlerMapping) error {

	// Arguments
	mapping.Arguments = genruntime.ClonePointerToString(source.Arguments)

	// Extension
	mapping.Extension = genruntime.ClonePointerToString(source.Extension)

	// ScriptProcessor
	mapping.ScriptProcessor = genruntime.ClonePointerToString(source.ScriptProcessor)

	// No error
	return nil
}

// AssignPropertiesToHandlerMapping populates the provided destination HandlerMapping from our HandlerMapping
func (mapping *HandlerMapping) AssignPropertiesToHandlerMapping(destination *v20220301s.HandlerMapping) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Arguments
	destination.Arguments = genruntime.ClonePointerToString(mapping.Arguments)

	// Extension
	destination.Extension = genruntime.ClonePointerToString(mapping.Extension)

	// ScriptProcessor
	destination.ScriptProcessor = genruntime.ClonePointerToString(mapping.ScriptProcessor)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type HandlerMapping_STATUS struct {
	// Arguments: Command-line arguments to be passed to the script processor.
	Arguments *string `json:"arguments,omitempty"`

	// Extension: Requests with this extension will be handled using the specified FastCGI application.
	Extension *string `json:"extension,omitempty"`

	// ScriptProcessor: The absolute path to the FastCGI application.
	ScriptProcessor *string `json:"scriptProcessor,omitempty"`
}

var _ genruntime.FromARMConverter = &HandlerMapping_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (mapping *HandlerMapping_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &HandlerMapping_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (mapping *HandlerMapping_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(HandlerMapping_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected HandlerMapping_STATUSARM, got %T", armInput)
	}

	// Set property ‘Arguments’:
	if typedInput.Arguments != nil {
		arguments := *typedInput.Arguments
		mapping.Arguments = &arguments
	}

	// Set property ‘Extension’:
	if typedInput.Extension != nil {
		extension := *typedInput.Extension
		mapping.Extension = &extension
	}

	// Set property ‘ScriptProcessor’:
	if typedInput.ScriptProcessor != nil {
		scriptProcessor := *typedInput.ScriptProcessor
		mapping.ScriptProcessor = &scriptProcessor
	}

	// No error
	return nil
}

// AssignPropertiesFromHandlerMappingSTATUS populates our HandlerMapping_STATUS from the provided source HandlerMapping_STATUS
func (mapping *HandlerMapping_STATUS) AssignPropertiesFromHandlerMappingSTATUS(source *v20220301s.HandlerMapping_STATUS) error {

	// Arguments
	mapping.Arguments = genruntime.ClonePointerToString(source.Arguments)

	// Extension
	mapping.Extension = genruntime.ClonePointerToString(source.Extension)

	// ScriptProcessor
	mapping.ScriptProcessor = genruntime.ClonePointerToString(source.ScriptProcessor)

	// No error
	return nil
}

// AssignPropertiesToHandlerMappingSTATUS populates the provided destination HandlerMapping_STATUS from our HandlerMapping_STATUS
func (mapping *HandlerMapping_STATUS) AssignPropertiesToHandlerMappingSTATUS(destination *v20220301s.HandlerMapping_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Arguments
	destination.Arguments = genruntime.ClonePointerToString(mapping.Arguments)

	// Extension
	destination.Extension = genruntime.ClonePointerToString(mapping.Extension)

	// ScriptProcessor
	destination.ScriptProcessor = genruntime.ClonePointerToString(mapping.ScriptProcessor)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Repository","Standard"}
type HostNameSslStateHostType string

const (
	HostNameSslStateHostType_Repository = HostNameSslStateHostType("Repository")
	HostNameSslStateHostType_Standard   = HostNameSslStateHostType("Standard")
)

// +kubebuilder:validation:Enum={"Disabled","IpBasedEnabled","SniEnabled"}
type HostNameSslStateSslState string

const (
	HostNameSslStateSslState_Disabled       = HostNameSslStateSslState("Disabled")
	HostNameSslStateSslState_IpBasedEnabled = HostNameSslStateSslState("IpBasedEnabled")
	HostNameSslStateSslState_SniEnabled     = HostNameSslStateSslState("SniEnabled")
)

type HostNameSslStateSTATUSHostType string

const (
	HostNameSslStateSTATUSHostType_Repository = HostNameSslStateSTATUSHostType("Repository")
	HostNameSslStateSTATUSHostType_Standard   = HostNameSslStateSTATUSHostType("Standard")
)

type HostNameSslStateSTATUSSslState string

const (
	HostNameSslStateSTATUSSslState_Disabled       = HostNameSslStateSTATUSSslState("Disabled")
	HostNameSslStateSTATUSSslState_IpBasedEnabled = HostNameSslStateSTATUSSslState("IpBasedEnabled")
	HostNameSslStateSTATUSSslState_SniEnabled     = HostNameSslStateSTATUSSslState("SniEnabled")
)

// Generated from: https://schema.management.azure.com/schemas/2022-03-01/Microsoft.Web.json#/definitions/IpSecurityRestriction
type IpSecurityRestriction struct {
	// Action: Allow or Deny access for this IP range.
	Action *string `json:"action,omitempty"`

	// Description: IP restriction rule description.
	Description *string `json:"description,omitempty"`

	// Headers: IP restriction rule headers.
	// X-Forwarded-Host (https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Host#Examples).
	// The matching logic is ..
	// - If the property is null or empty (default), all hosts(or lack of) are allowed.
	// - A value is compared using ordinal-ignore-case (excluding port number).
	// - Subdomain wildcards are permitted but don't match the root domain. For example, *.contoso.com matches the subdomain
	// foo.contoso.com
	// but not the root domain contoso.com or multi-level foo.bar.contoso.com
	// - Unicode host names are allowed but are converted to Punycode for matching.
	// X-Forwarded-For (https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For#Examples).
	// The matching logic is ..
	// - If the property is null or empty (default), any forwarded-for chains (or lack of) are allowed.
	// - If any address (excluding port number) in the chain (comma separated) matches the CIDR defined by the property.
	// X-Azure-FDID and X-FD-HealthProbe.
	// The matching logic is exact match.
	Headers map[string][]string `json:"headers,omitempty"`

	// IpAddress: IP address the security restriction is valid for.
	// It can be in form of pure ipv4 address (required SubnetMask property) or
	// CIDR notation such as ipv4/mask (leading bit match). For CIDR,
	// SubnetMask property must not be specified.
	IpAddress *string `json:"ipAddress,omitempty"`

	// Name: IP restriction rule name.
	Name *string `json:"name,omitempty"`

	// Priority: Priority of IP restriction rule.
	Priority *int `json:"priority,omitempty"`

	// SubnetMask: Subnet mask for the range of IP addresses the restriction is valid for.
	SubnetMask *string `json:"subnetMask,omitempty"`

	// SubnetTrafficTag: (internal) Subnet traffic tag
	SubnetTrafficTag *int `json:"subnetTrafficTag,omitempty"`

	// Tag: Defines what this IP filter will be used for. This is to support IP filtering on proxies.
	Tag *IpSecurityRestrictionTag `json:"tag,omitempty"`

	// VnetSubnetResourceReference: Virtual network resource id
	VnetSubnetResourceReference *genruntime.ResourceReference `armReference:"VnetSubnetResourceId" json:"vnetSubnetResourceReference,omitempty"`

	// VnetTrafficTag: (internal) Vnet traffic tag
	VnetTrafficTag *int `json:"vnetTrafficTag,omitempty"`
}

var _ genruntime.ARMTransformer = &IpSecurityRestriction{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (restriction *IpSecurityRestriction) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if restriction == nil {
		return nil, nil
	}
	result := &IpSecurityRestrictionARM{}

	// Set property ‘Action’:
	if restriction.Action != nil {
		action := *restriction.Action
		result.Action = &action
	}

	// Set property ‘Description’:
	if restriction.Description != nil {
		description := *restriction.Description
		result.Description = &description
	}

	// Set property ‘Headers’:
	if restriction.Headers != nil {
		result.Headers = make(map[string][]string, len(restriction.Headers))
		for key, value := range restriction.Headers {
			var valueTemp []string
			for _, item := range value {
				valueTemp = append(valueTemp, item)
			}
			result.Headers[key] = valueTemp
		}
	}

	// Set property ‘IpAddress’:
	if restriction.IpAddress != nil {
		ipAddress := *restriction.IpAddress
		result.IpAddress = &ipAddress
	}

	// Set property ‘Name’:
	if restriction.Name != nil {
		name := *restriction.Name
		result.Name = &name
	}

	// Set property ‘Priority’:
	if restriction.Priority != nil {
		priority := *restriction.Priority
		result.Priority = &priority
	}

	// Set property ‘SubnetMask’:
	if restriction.SubnetMask != nil {
		subnetMask := *restriction.SubnetMask
		result.SubnetMask = &subnetMask
	}

	// Set property ‘SubnetTrafficTag’:
	if restriction.SubnetTrafficTag != nil {
		subnetTrafficTag := *restriction.SubnetTrafficTag
		result.SubnetTrafficTag = &subnetTrafficTag
	}

	// Set property ‘Tag’:
	if restriction.Tag != nil {
		tag := *restriction.Tag
		result.Tag = &tag
	}

	// Set property ‘VnetSubnetResourceId’:
	if restriction.VnetSubnetResourceReference != nil {
		vnetSubnetResourceReferenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*restriction.VnetSubnetResourceReference)
		if err != nil {
			return nil, err
		}
		vnetSubnetResourceReference := vnetSubnetResourceReferenceARMID
		result.VnetSubnetResourceId = &vnetSubnetResourceReference
	}

	// Set property ‘VnetTrafficTag’:
	if restriction.VnetTrafficTag != nil {
		vnetTrafficTag := *restriction.VnetTrafficTag
		result.VnetTrafficTag = &vnetTrafficTag
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (restriction *IpSecurityRestriction) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &IpSecurityRestrictionARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (restriction *IpSecurityRestriction) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(IpSecurityRestrictionARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected IpSecurityRestrictionARM, got %T", armInput)
	}

	// Set property ‘Action’:
	if typedInput.Action != nil {
		action := *typedInput.Action
		restriction.Action = &action
	}

	// Set property ‘Description’:
	if typedInput.Description != nil {
		description := *typedInput.Description
		restriction.Description = &description
	}

	// Set property ‘Headers’:
	if typedInput.Headers != nil {
		restriction.Headers = make(map[string][]string, len(typedInput.Headers))
		for key, value := range typedInput.Headers {
			var valueTemp []string
			for _, item := range value {
				valueTemp = append(valueTemp, item)
			}
			restriction.Headers[key] = valueTemp
		}
	}

	// Set property ‘IpAddress’:
	if typedInput.IpAddress != nil {
		ipAddress := *typedInput.IpAddress
		restriction.IpAddress = &ipAddress
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		restriction.Name = &name
	}

	// Set property ‘Priority’:
	if typedInput.Priority != nil {
		priority := *typedInput.Priority
		restriction.Priority = &priority
	}

	// Set property ‘SubnetMask’:
	if typedInput.SubnetMask != nil {
		subnetMask := *typedInput.SubnetMask
		restriction.SubnetMask = &subnetMask
	}

	// Set property ‘SubnetTrafficTag’:
	if typedInput.SubnetTrafficTag != nil {
		subnetTrafficTag := *typedInput.SubnetTrafficTag
		restriction.SubnetTrafficTag = &subnetTrafficTag
	}

	// Set property ‘Tag’:
	if typedInput.Tag != nil {
		tag := *typedInput.Tag
		restriction.Tag = &tag
	}

	// no assignment for property ‘VnetSubnetResourceReference’

	// Set property ‘VnetTrafficTag’:
	if typedInput.VnetTrafficTag != nil {
		vnetTrafficTag := *typedInput.VnetTrafficTag
		restriction.VnetTrafficTag = &vnetTrafficTag
	}

	// No error
	return nil
}

// AssignPropertiesFromIpSecurityRestriction populates our IpSecurityRestriction from the provided source IpSecurityRestriction
func (restriction *IpSecurityRestriction) AssignPropertiesFromIpSecurityRestriction(source *v20220301s.IpSecurityRestriction) error {

	// Action
	restriction.Action = genruntime.ClonePointerToString(source.Action)

	// Description
	restriction.Description = genruntime.ClonePointerToString(source.Description)

	// Headers
	if source.Headers != nil {
		headerMap := make(map[string][]string, len(source.Headers))
		for headerKey, headerValue := range source.Headers {
			// Shadow the loop variable to avoid aliasing
			headerValue := headerValue
			headerMap[headerKey] = genruntime.CloneSliceOfString(headerValue)
		}
		restriction.Headers = headerMap
	} else {
		restriction.Headers = nil
	}

	// IpAddress
	restriction.IpAddress = genruntime.ClonePointerToString(source.IpAddress)

	// Name
	restriction.Name = genruntime.ClonePointerToString(source.Name)

	// Priority
	restriction.Priority = genruntime.ClonePointerToInt(source.Priority)

	// SubnetMask
	restriction.SubnetMask = genruntime.ClonePointerToString(source.SubnetMask)

	// SubnetTrafficTag
	restriction.SubnetTrafficTag = genruntime.ClonePointerToInt(source.SubnetTrafficTag)

	// Tag
	if source.Tag != nil {
		tag := IpSecurityRestrictionTag(*source.Tag)
		restriction.Tag = &tag
	} else {
		restriction.Tag = nil
	}

	// VnetSubnetResourceReference
	if source.VnetSubnetResourceReference != nil {
		vnetSubnetResourceReference := source.VnetSubnetResourceReference.Copy()
		restriction.VnetSubnetResourceReference = &vnetSubnetResourceReference
	} else {
		restriction.VnetSubnetResourceReference = nil
	}

	// VnetTrafficTag
	restriction.VnetTrafficTag = genruntime.ClonePointerToInt(source.VnetTrafficTag)

	// No error
	return nil
}

// AssignPropertiesToIpSecurityRestriction populates the provided destination IpSecurityRestriction from our IpSecurityRestriction
func (restriction *IpSecurityRestriction) AssignPropertiesToIpSecurityRestriction(destination *v20220301s.IpSecurityRestriction) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Action
	destination.Action = genruntime.ClonePointerToString(restriction.Action)

	// Description
	destination.Description = genruntime.ClonePointerToString(restriction.Description)

	// Headers
	if restriction.Headers != nil {
		headerMap := make(map[string][]string, len(restriction.Headers))
		for headerKey, headerValue := range restriction.Headers {
			// Shadow the loop variable to avoid aliasing
			headerValue := headerValue
			headerMap[headerKey] = genruntime.CloneSliceOfString(headerValue)
		}
		destination.Headers = headerMap
	} else {
		destination.Headers = nil
	}

	// IpAddress
	destination.IpAddress = genruntime.ClonePointerToString(restriction.IpAddress)

	// Name
	destination.Name = genruntime.ClonePointerToString(restriction.Name)

	// Priority
	destination.Priority = genruntime.ClonePointerToInt(restriction.Priority)

	// SubnetMask
	destination.SubnetMask = genruntime.ClonePointerToString(restriction.SubnetMask)

	// SubnetTrafficTag
	destination.SubnetTrafficTag = genruntime.ClonePointerToInt(restriction.SubnetTrafficTag)

	// Tag
	if restriction.Tag != nil {
		tag := string(*restriction.Tag)
		destination.Tag = &tag
	} else {
		destination.Tag = nil
	}

	// VnetSubnetResourceReference
	if restriction.VnetSubnetResourceReference != nil {
		vnetSubnetResourceReference := restriction.VnetSubnetResourceReference.Copy()
		destination.VnetSubnetResourceReference = &vnetSubnetResourceReference
	} else {
		destination.VnetSubnetResourceReference = nil
	}

	// VnetTrafficTag
	destination.VnetTrafficTag = genruntime.ClonePointerToInt(restriction.VnetTrafficTag)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type IpSecurityRestriction_STATUS struct {
	// Action: Allow or Deny access for this IP range.
	Action *string `json:"action,omitempty"`

	// Description: IP restriction rule description.
	Description *string `json:"description,omitempty"`

	// Headers: IP restriction rule headers.
	// X-Forwarded-Host (https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Host#Examples).
	// The matching logic is ..
	// - If the property is null or empty (default), all hosts(or lack of) are allowed.
	// - A value is compared using ordinal-ignore-case (excluding port number).
	// - Subdomain wildcards are permitted but don't match the root domain. For example, *.contoso.com matches the subdomain
	// foo.contoso.com
	// but not the root domain contoso.com or multi-level foo.bar.contoso.com
	// - Unicode host names are allowed but are converted to Punycode for matching.
	// X-Forwarded-For (https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For#Examples).
	// The matching logic is ..
	// - If the property is null or empty (default), any forwarded-for chains (or lack of) are allowed.
	// - If any address (excluding port number) in the chain (comma separated) matches the CIDR defined by the property.
	// X-Azure-FDID and X-FD-HealthProbe.
	// The matching logic is exact match.
	Headers map[string][]string `json:"headers,omitempty"`

	// IpAddress: IP address the security restriction is valid for.
	// It can be in form of pure ipv4 address (required SubnetMask property) or
	// CIDR notation such as ipv4/mask (leading bit match). For CIDR,
	// SubnetMask property must not be specified.
	IpAddress *string `json:"ipAddress,omitempty"`

	// Name: IP restriction rule name.
	Name *string `json:"name,omitempty"`

	// Priority: Priority of IP restriction rule.
	Priority *int `json:"priority,omitempty"`

	// SubnetMask: Subnet mask for the range of IP addresses the restriction is valid for.
	SubnetMask *string `json:"subnetMask,omitempty"`

	// SubnetTrafficTag: (internal) Subnet traffic tag
	SubnetTrafficTag *int `json:"subnetTrafficTag,omitempty"`

	// Tag: Defines what this IP filter will be used for. This is to support IP filtering on proxies.
	Tag *IpSecurityRestrictionSTATUSTag `json:"tag,omitempty"`

	// VnetSubnetResourceId: Virtual network resource id
	VnetSubnetResourceId *string `json:"vnetSubnetResourceId,omitempty"`

	// VnetTrafficTag: (internal) Vnet traffic tag
	VnetTrafficTag *int `json:"vnetTrafficTag,omitempty"`
}

var _ genruntime.FromARMConverter = &IpSecurityRestriction_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (restriction *IpSecurityRestriction_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &IpSecurityRestriction_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (restriction *IpSecurityRestriction_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(IpSecurityRestriction_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected IpSecurityRestriction_STATUSARM, got %T", armInput)
	}

	// Set property ‘Action’:
	if typedInput.Action != nil {
		action := *typedInput.Action
		restriction.Action = &action
	}

	// Set property ‘Description’:
	if typedInput.Description != nil {
		description := *typedInput.Description
		restriction.Description = &description
	}

	// Set property ‘Headers’:
	if typedInput.Headers != nil {
		restriction.Headers = make(map[string][]string, len(typedInput.Headers))
		for key, value := range typedInput.Headers {
			var valueTemp []string
			for _, item := range value {
				valueTemp = append(valueTemp, item)
			}
			restriction.Headers[key] = valueTemp
		}
	}

	// Set property ‘IpAddress’:
	if typedInput.IpAddress != nil {
		ipAddress := *typedInput.IpAddress
		restriction.IpAddress = &ipAddress
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		restriction.Name = &name
	}

	// Set property ‘Priority’:
	if typedInput.Priority != nil {
		priority := *typedInput.Priority
		restriction.Priority = &priority
	}

	// Set property ‘SubnetMask’:
	if typedInput.SubnetMask != nil {
		subnetMask := *typedInput.SubnetMask
		restriction.SubnetMask = &subnetMask
	}

	// Set property ‘SubnetTrafficTag’:
	if typedInput.SubnetTrafficTag != nil {
		subnetTrafficTag := *typedInput.SubnetTrafficTag
		restriction.SubnetTrafficTag = &subnetTrafficTag
	}

	// Set property ‘Tag’:
	if typedInput.Tag != nil {
		tag := *typedInput.Tag
		restriction.Tag = &tag
	}

	// Set property ‘VnetSubnetResourceId’:
	if typedInput.VnetSubnetResourceId != nil {
		vnetSubnetResourceId := *typedInput.VnetSubnetResourceId
		restriction.VnetSubnetResourceId = &vnetSubnetResourceId
	}

	// Set property ‘VnetTrafficTag’:
	if typedInput.VnetTrafficTag != nil {
		vnetTrafficTag := *typedInput.VnetTrafficTag
		restriction.VnetTrafficTag = &vnetTrafficTag
	}

	// No error
	return nil
}

// AssignPropertiesFromIpSecurityRestrictionSTATUS populates our IpSecurityRestriction_STATUS from the provided source IpSecurityRestriction_STATUS
func (restriction *IpSecurityRestriction_STATUS) AssignPropertiesFromIpSecurityRestrictionSTATUS(source *v20220301s.IpSecurityRestriction_STATUS) error {

	// Action
	restriction.Action = genruntime.ClonePointerToString(source.Action)

	// Description
	restriction.Description = genruntime.ClonePointerToString(source.Description)

	// Headers
	if source.Headers != nil {
		headerMap := make(map[string][]string, len(source.Headers))
		for headerKey, headerValue := range source.Headers {
			// Shadow the loop variable to avoid aliasing
			headerValue := headerValue
			headerMap[headerKey] = genruntime.CloneSliceOfString(headerValue)
		}
		restriction.Headers = headerMap
	} else {
		restriction.Headers = nil
	}

	// IpAddress
	restriction.IpAddress = genruntime.ClonePointerToString(source.IpAddress)

	// Name
	restriction.Name = genruntime.ClonePointerToString(source.Name)

	// Priority
	restriction.Priority = genruntime.ClonePointerToInt(source.Priority)

	// SubnetMask
	restriction.SubnetMask = genruntime.ClonePointerToString(source.SubnetMask)

	// SubnetTrafficTag
	restriction.SubnetTrafficTag = genruntime.ClonePointerToInt(source.SubnetTrafficTag)

	// Tag
	if source.Tag != nil {
		tag := IpSecurityRestrictionSTATUSTag(*source.Tag)
		restriction.Tag = &tag
	} else {
		restriction.Tag = nil
	}

	// VnetSubnetResourceId
	restriction.VnetSubnetResourceId = genruntime.ClonePointerToString(source.VnetSubnetResourceId)

	// VnetTrafficTag
	restriction.VnetTrafficTag = genruntime.ClonePointerToInt(source.VnetTrafficTag)

	// No error
	return nil
}

// AssignPropertiesToIpSecurityRestrictionSTATUS populates the provided destination IpSecurityRestriction_STATUS from our IpSecurityRestriction_STATUS
func (restriction *IpSecurityRestriction_STATUS) AssignPropertiesToIpSecurityRestrictionSTATUS(destination *v20220301s.IpSecurityRestriction_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Action
	destination.Action = genruntime.ClonePointerToString(restriction.Action)

	// Description
	destination.Description = genruntime.ClonePointerToString(restriction.Description)

	// Headers
	if restriction.Headers != nil {
		headerMap := make(map[string][]string, len(restriction.Headers))
		for headerKey, headerValue := range restriction.Headers {
			// Shadow the loop variable to avoid aliasing
			headerValue := headerValue
			headerMap[headerKey] = genruntime.CloneSliceOfString(headerValue)
		}
		destination.Headers = headerMap
	} else {
		destination.Headers = nil
	}

	// IpAddress
	destination.IpAddress = genruntime.ClonePointerToString(restriction.IpAddress)

	// Name
	destination.Name = genruntime.ClonePointerToString(restriction.Name)

	// Priority
	destination.Priority = genruntime.ClonePointerToInt(restriction.Priority)

	// SubnetMask
	destination.SubnetMask = genruntime.ClonePointerToString(restriction.SubnetMask)

	// SubnetTrafficTag
	destination.SubnetTrafficTag = genruntime.ClonePointerToInt(restriction.SubnetTrafficTag)

	// Tag
	if restriction.Tag != nil {
		tag := string(*restriction.Tag)
		destination.Tag = &tag
	} else {
		destination.Tag = nil
	}

	// VnetSubnetResourceId
	destination.VnetSubnetResourceId = genruntime.ClonePointerToString(restriction.VnetSubnetResourceId)

	// VnetTrafficTag
	destination.VnetTrafficTag = genruntime.ClonePointerToInt(restriction.VnetTrafficTag)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2022-03-01/Microsoft.Web.json#/definitions/NameValuePair
type NameValuePair struct {
	// Name: Pair name.
	Name *string `json:"name,omitempty"`

	// Value: Pair value.
	Value *string `json:"value,omitempty"`
}

var _ genruntime.ARMTransformer = &NameValuePair{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (pair *NameValuePair) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if pair == nil {
		return nil, nil
	}
	result := &NameValuePairARM{}

	// Set property ‘Name’:
	if pair.Name != nil {
		name := *pair.Name
		result.Name = &name
	}

	// Set property ‘Value’:
	if pair.Value != nil {
		value := *pair.Value
		result.Value = &value
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (pair *NameValuePair) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &NameValuePairARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (pair *NameValuePair) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(NameValuePairARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected NameValuePairARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		pair.Name = &name
	}

	// Set property ‘Value’:
	if typedInput.Value != nil {
		value := *typedInput.Value
		pair.Value = &value
	}

	// No error
	return nil
}

// AssignPropertiesFromNameValuePair populates our NameValuePair from the provided source NameValuePair
func (pair *NameValuePair) AssignPropertiesFromNameValuePair(source *v20220301s.NameValuePair) error {

	// Name
	pair.Name = genruntime.ClonePointerToString(source.Name)

	// Value
	pair.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignPropertiesToNameValuePair populates the provided destination NameValuePair from our NameValuePair
func (pair *NameValuePair) AssignPropertiesToNameValuePair(destination *v20220301s.NameValuePair) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(pair.Name)

	// Value
	destination.Value = genruntime.ClonePointerToString(pair.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type NameValuePair_STATUS struct {
	// Name: Pair name.
	Name *string `json:"name,omitempty"`

	// Value: Pair value.
	Value *string `json:"value,omitempty"`
}

var _ genruntime.FromARMConverter = &NameValuePair_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (pair *NameValuePair_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &NameValuePair_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (pair *NameValuePair_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(NameValuePair_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected NameValuePair_STATUSARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		pair.Name = &name
	}

	// Set property ‘Value’:
	if typedInput.Value != nil {
		value := *typedInput.Value
		pair.Value = &value
	}

	// No error
	return nil
}

// AssignPropertiesFromNameValuePairSTATUS populates our NameValuePair_STATUS from the provided source NameValuePair_STATUS
func (pair *NameValuePair_STATUS) AssignPropertiesFromNameValuePairSTATUS(source *v20220301s.NameValuePair_STATUS) error {

	// Name
	pair.Name = genruntime.ClonePointerToString(source.Name)

	// Value
	pair.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignPropertiesToNameValuePairSTATUS populates the provided destination NameValuePair_STATUS from our NameValuePair_STATUS
func (pair *NameValuePair_STATUS) AssignPropertiesToNameValuePairSTATUS(destination *v20220301s.NameValuePair_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(pair.Name)

	// Value
	destination.Value = genruntime.ClonePointerToString(pair.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type PushSettings_STATUS struct {
	// DynamicTagsJson: Gets or sets a JSON string containing a list of dynamic tags that will be evaluated from user claims in
	// the push registration endpoint.
	DynamicTagsJson *string `json:"dynamicTagsJson,omitempty"`

	// Id: Resource Id.
	Id *string `json:"id,omitempty"`

	// IsPushEnabled: Gets or sets a flag indicating whether the Push endpoint is enabled.
	IsPushEnabled *bool `json:"isPushEnabled,omitempty"`

	// Kind: Kind of resource.
	Kind *string `json:"kind,omitempty"`

	// Name: Resource Name.
	Name *string `json:"name,omitempty"`

	// TagWhitelistJson: Gets or sets a JSON string containing a list of tags that are whitelisted for use by the push
	// registration endpoint.
	TagWhitelistJson *string `json:"tagWhitelistJson,omitempty"`

	// TagsRequiringAuth: Gets or sets a JSON string containing a list of tags that require user authentication to be used in
	// the push registration endpoint.
	// Tags can consist of alphanumeric characters and the following:
	// '_', '@', '#', '.', ':', '-'.
	// Validation should be performed at the PushRequestHandler.
	TagsRequiringAuth *string `json:"tagsRequiringAuth,omitempty"`

	// Type: Resource type.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &PushSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *PushSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &PushSettings_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *PushSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(PushSettings_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PushSettings_STATUSARM, got %T", armInput)
	}

	// Set property ‘DynamicTagsJson’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DynamicTagsJson != nil {
			dynamicTagsJson := *typedInput.Properties.DynamicTagsJson
			settings.DynamicTagsJson = &dynamicTagsJson
		}
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		settings.Id = &id
	}

	// Set property ‘IsPushEnabled’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IsPushEnabled != nil {
			isPushEnabled := *typedInput.Properties.IsPushEnabled
			settings.IsPushEnabled = &isPushEnabled
		}
	}

	// Set property ‘Kind’:
	if typedInput.Kind != nil {
		kind := *typedInput.Kind
		settings.Kind = &kind
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		settings.Name = &name
	}

	// Set property ‘TagWhitelistJson’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TagWhitelistJson != nil {
			tagWhitelistJson := *typedInput.Properties.TagWhitelistJson
			settings.TagWhitelistJson = &tagWhitelistJson
		}
	}

	// Set property ‘TagsRequiringAuth’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TagsRequiringAuth != nil {
			tagsRequiringAuth := *typedInput.Properties.TagsRequiringAuth
			settings.TagsRequiringAuth = &tagsRequiringAuth
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		settings.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromPushSettingsSTATUS populates our PushSettings_STATUS from the provided source PushSettings_STATUS
func (settings *PushSettings_STATUS) AssignPropertiesFromPushSettingsSTATUS(source *v20220301s.PushSettings_STATUS) error {

	// DynamicTagsJson
	settings.DynamicTagsJson = genruntime.ClonePointerToString(source.DynamicTagsJson)

	// Id
	settings.Id = genruntime.ClonePointerToString(source.Id)

	// IsPushEnabled
	if source.IsPushEnabled != nil {
		isPushEnabled := *source.IsPushEnabled
		settings.IsPushEnabled = &isPushEnabled
	} else {
		settings.IsPushEnabled = nil
	}

	// Kind
	settings.Kind = genruntime.ClonePointerToString(source.Kind)

	// Name
	settings.Name = genruntime.ClonePointerToString(source.Name)

	// TagWhitelistJson
	settings.TagWhitelistJson = genruntime.ClonePointerToString(source.TagWhitelistJson)

	// TagsRequiringAuth
	settings.TagsRequiringAuth = genruntime.ClonePointerToString(source.TagsRequiringAuth)

	// Type
	settings.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignPropertiesToPushSettingsSTATUS populates the provided destination PushSettings_STATUS from our PushSettings_STATUS
func (settings *PushSettings_STATUS) AssignPropertiesToPushSettingsSTATUS(destination *v20220301s.PushSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DynamicTagsJson
	destination.DynamicTagsJson = genruntime.ClonePointerToString(settings.DynamicTagsJson)

	// Id
	destination.Id = genruntime.ClonePointerToString(settings.Id)

	// IsPushEnabled
	if settings.IsPushEnabled != nil {
		isPushEnabled := *settings.IsPushEnabled
		destination.IsPushEnabled = &isPushEnabled
	} else {
		destination.IsPushEnabled = nil
	}

	// Kind
	destination.Kind = genruntime.ClonePointerToString(settings.Kind)

	// Name
	destination.Name = genruntime.ClonePointerToString(settings.Name)

	// TagWhitelistJson
	destination.TagWhitelistJson = genruntime.ClonePointerToString(settings.TagWhitelistJson)

	// TagsRequiringAuth
	destination.TagsRequiringAuth = genruntime.ClonePointerToString(settings.TagsRequiringAuth)

	// Type
	destination.Type = genruntime.ClonePointerToString(settings.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type SiteConfigSTATUSFtpsState string

const (
	SiteConfigSTATUSFtpsState_AllAllowed = SiteConfigSTATUSFtpsState("AllAllowed")
	SiteConfigSTATUSFtpsState_Disabled   = SiteConfigSTATUSFtpsState("Disabled")
	SiteConfigSTATUSFtpsState_FtpsOnly   = SiteConfigSTATUSFtpsState("FtpsOnly")
)

type SiteConfigSTATUSLoadBalancing string

const (
	SiteConfigSTATUSLoadBalancing_LeastRequests        = SiteConfigSTATUSLoadBalancing("LeastRequests")
	SiteConfigSTATUSLoadBalancing_LeastResponseTime    = SiteConfigSTATUSLoadBalancing("LeastResponseTime")
	SiteConfigSTATUSLoadBalancing_PerSiteRoundRobin    = SiteConfigSTATUSLoadBalancing("PerSiteRoundRobin")
	SiteConfigSTATUSLoadBalancing_RequestHash          = SiteConfigSTATUSLoadBalancing("RequestHash")
	SiteConfigSTATUSLoadBalancing_WeightedRoundRobin   = SiteConfigSTATUSLoadBalancing("WeightedRoundRobin")
	SiteConfigSTATUSLoadBalancing_WeightedTotalTraffic = SiteConfigSTATUSLoadBalancing("WeightedTotalTraffic")
)

type SiteConfigSTATUSManagedPipelineMode string

const (
	SiteConfigSTATUSManagedPipelineMode_Classic    = SiteConfigSTATUSManagedPipelineMode("Classic")
	SiteConfigSTATUSManagedPipelineMode_Integrated = SiteConfigSTATUSManagedPipelineMode("Integrated")
)

type SiteConfigSTATUSMinTlsVersion string

const (
	SiteConfigSTATUSMinTlsVersion_10 = SiteConfigSTATUSMinTlsVersion("1.0")
	SiteConfigSTATUSMinTlsVersion_11 = SiteConfigSTATUSMinTlsVersion("1.1")
	SiteConfigSTATUSMinTlsVersion_12 = SiteConfigSTATUSMinTlsVersion("1.2")
)

type SiteConfigSTATUSScmMinTlsVersion string

const (
	SiteConfigSTATUSScmMinTlsVersion_10 = SiteConfigSTATUSScmMinTlsVersion("1.0")
	SiteConfigSTATUSScmMinTlsVersion_11 = SiteConfigSTATUSScmMinTlsVersion("1.1")
	SiteConfigSTATUSScmMinTlsVersion_12 = SiteConfigSTATUSScmMinTlsVersion("1.2")
)

type SiteConfigSTATUSScmType string

const (
	SiteConfigSTATUSScmType_BitbucketGit = SiteConfigSTATUSScmType("BitbucketGit")
	SiteConfigSTATUSScmType_BitbucketHg  = SiteConfigSTATUSScmType("BitbucketHg")
	SiteConfigSTATUSScmType_CodePlexGit  = SiteConfigSTATUSScmType("CodePlexGit")
	SiteConfigSTATUSScmType_CodePlexHg   = SiteConfigSTATUSScmType("CodePlexHg")
	SiteConfigSTATUSScmType_Dropbox      = SiteConfigSTATUSScmType("Dropbox")
	SiteConfigSTATUSScmType_ExternalGit  = SiteConfigSTATUSScmType("ExternalGit")
	SiteConfigSTATUSScmType_ExternalHg   = SiteConfigSTATUSScmType("ExternalHg")
	SiteConfigSTATUSScmType_GitHub       = SiteConfigSTATUSScmType("GitHub")
	SiteConfigSTATUSScmType_LocalGit     = SiteConfigSTATUSScmType("LocalGit")
	SiteConfigSTATUSScmType_None         = SiteConfigSTATUSScmType("None")
	SiteConfigSTATUSScmType_OneDrive     = SiteConfigSTATUSScmType("OneDrive")
	SiteConfigSTATUSScmType_Tfs          = SiteConfigSTATUSScmType("Tfs")
	SiteConfigSTATUSScmType_VSO          = SiteConfigSTATUSScmType("VSO")
	SiteConfigSTATUSScmType_VSTSRM       = SiteConfigSTATUSScmType("VSTSRM")
)

// Generated from: https://schema.management.azure.com/schemas/2022-03-01/Microsoft.Web.json#/definitions/SiteLimits
type SiteLimits struct {
	// MaxDiskSizeInMb: Maximum allowed disk size usage in MB.
	MaxDiskSizeInMb *int `json:"maxDiskSizeInMb,omitempty"`

	// MaxMemoryInMb: Maximum allowed memory usage in MB.
	MaxMemoryInMb *int `json:"maxMemoryInMb,omitempty"`

	// MaxPercentageCpu: Maximum allowed CPU usage percentage.
	MaxPercentageCpu *float64 `json:"maxPercentageCpu,omitempty"`
}

var _ genruntime.ARMTransformer = &SiteLimits{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (limits *SiteLimits) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if limits == nil {
		return nil, nil
	}
	result := &SiteLimitsARM{}

	// Set property ‘MaxDiskSizeInMb’:
	if limits.MaxDiskSizeInMb != nil {
		maxDiskSizeInMb := *limits.MaxDiskSizeInMb
		result.MaxDiskSizeInMb = &maxDiskSizeInMb
	}

	// Set property ‘MaxMemoryInMb’:
	if limits.MaxMemoryInMb != nil {
		maxMemoryInMb := *limits.MaxMemoryInMb
		result.MaxMemoryInMb = &maxMemoryInMb
	}

	// Set property ‘MaxPercentageCpu’:
	if limits.MaxPercentageCpu != nil {
		maxPercentageCpu := *limits.MaxPercentageCpu
		result.MaxPercentageCpu = &maxPercentageCpu
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (limits *SiteLimits) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SiteLimitsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (limits *SiteLimits) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SiteLimitsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SiteLimitsARM, got %T", armInput)
	}

	// Set property ‘MaxDiskSizeInMb’:
	if typedInput.MaxDiskSizeInMb != nil {
		maxDiskSizeInMb := *typedInput.MaxDiskSizeInMb
		limits.MaxDiskSizeInMb = &maxDiskSizeInMb
	}

	// Set property ‘MaxMemoryInMb’:
	if typedInput.MaxMemoryInMb != nil {
		maxMemoryInMb := *typedInput.MaxMemoryInMb
		limits.MaxMemoryInMb = &maxMemoryInMb
	}

	// Set property ‘MaxPercentageCpu’:
	if typedInput.MaxPercentageCpu != nil {
		maxPercentageCpu := *typedInput.MaxPercentageCpu
		limits.MaxPercentageCpu = &maxPercentageCpu
	}

	// No error
	return nil
}

// AssignPropertiesFromSiteLimits populates our SiteLimits from the provided source SiteLimits
func (limits *SiteLimits) AssignPropertiesFromSiteLimits(source *v20220301s.SiteLimits) error {

	// MaxDiskSizeInMb
	limits.MaxDiskSizeInMb = genruntime.ClonePointerToInt(source.MaxDiskSizeInMb)

	// MaxMemoryInMb
	limits.MaxMemoryInMb = genruntime.ClonePointerToInt(source.MaxMemoryInMb)

	// MaxPercentageCpu
	if source.MaxPercentageCpu != nil {
		maxPercentageCpu := *source.MaxPercentageCpu
		limits.MaxPercentageCpu = &maxPercentageCpu
	} else {
		limits.MaxPercentageCpu = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSiteLimits populates the provided destination SiteLimits from our SiteLimits
func (limits *SiteLimits) AssignPropertiesToSiteLimits(destination *v20220301s.SiteLimits) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MaxDiskSizeInMb
	destination.MaxDiskSizeInMb = genruntime.ClonePointerToInt(limits.MaxDiskSizeInMb)

	// MaxMemoryInMb
	destination.MaxMemoryInMb = genruntime.ClonePointerToInt(limits.MaxMemoryInMb)

	// MaxPercentageCpu
	if limits.MaxPercentageCpu != nil {
		maxPercentageCpu := *limits.MaxPercentageCpu
		destination.MaxPercentageCpu = &maxPercentageCpu
	} else {
		destination.MaxPercentageCpu = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type SiteLimits_STATUS struct {
	// MaxDiskSizeInMb: Maximum allowed disk size usage in MB.
	MaxDiskSizeInMb *int `json:"maxDiskSizeInMb,omitempty"`

	// MaxMemoryInMb: Maximum allowed memory usage in MB.
	MaxMemoryInMb *int `json:"maxMemoryInMb,omitempty"`

	// MaxPercentageCpu: Maximum allowed CPU usage percentage.
	MaxPercentageCpu *float64 `json:"maxPercentageCpu,omitempty"`
}

var _ genruntime.FromARMConverter = &SiteLimits_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (limits *SiteLimits_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SiteLimits_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (limits *SiteLimits_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SiteLimits_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SiteLimits_STATUSARM, got %T", armInput)
	}

	// Set property ‘MaxDiskSizeInMb’:
	if typedInput.MaxDiskSizeInMb != nil {
		maxDiskSizeInMb := *typedInput.MaxDiskSizeInMb
		limits.MaxDiskSizeInMb = &maxDiskSizeInMb
	}

	// Set property ‘MaxMemoryInMb’:
	if typedInput.MaxMemoryInMb != nil {
		maxMemoryInMb := *typedInput.MaxMemoryInMb
		limits.MaxMemoryInMb = &maxMemoryInMb
	}

	// Set property ‘MaxPercentageCpu’:
	if typedInput.MaxPercentageCpu != nil {
		maxPercentageCpu := *typedInput.MaxPercentageCpu
		limits.MaxPercentageCpu = &maxPercentageCpu
	}

	// No error
	return nil
}

// AssignPropertiesFromSiteLimitsSTATUS populates our SiteLimits_STATUS from the provided source SiteLimits_STATUS
func (limits *SiteLimits_STATUS) AssignPropertiesFromSiteLimitsSTATUS(source *v20220301s.SiteLimits_STATUS) error {

	// MaxDiskSizeInMb
	limits.MaxDiskSizeInMb = genruntime.ClonePointerToInt(source.MaxDiskSizeInMb)

	// MaxMemoryInMb
	limits.MaxMemoryInMb = genruntime.ClonePointerToInt(source.MaxMemoryInMb)

	// MaxPercentageCpu
	if source.MaxPercentageCpu != nil {
		maxPercentageCpu := *source.MaxPercentageCpu
		limits.MaxPercentageCpu = &maxPercentageCpu
	} else {
		limits.MaxPercentageCpu = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSiteLimitsSTATUS populates the provided destination SiteLimits_STATUS from our SiteLimits_STATUS
func (limits *SiteLimits_STATUS) AssignPropertiesToSiteLimitsSTATUS(destination *v20220301s.SiteLimits_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MaxDiskSizeInMb
	destination.MaxDiskSizeInMb = genruntime.ClonePointerToInt(limits.MaxDiskSizeInMb)

	// MaxMemoryInMb
	destination.MaxMemoryInMb = genruntime.ClonePointerToInt(limits.MaxMemoryInMb)

	// MaxPercentageCpu
	if limits.MaxPercentageCpu != nil {
		maxPercentageCpu := *limits.MaxPercentageCpu
		destination.MaxPercentageCpu = &maxPercentageCpu
	} else {
		destination.MaxPercentageCpu = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type SiteMachineKey_STATUS struct {
	// Decryption: Algorithm used for decryption.
	Decryption *string `json:"decryption,omitempty"`

	// DecryptionKey: Decryption key.
	DecryptionKey *string `json:"decryptionKey,omitempty"`

	// Validation: MachineKey validation.
	Validation *string `json:"validation,omitempty"`

	// ValidationKey: Validation key.
	ValidationKey *string `json:"validationKey,omitempty"`
}

var _ genruntime.FromARMConverter = &SiteMachineKey_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (machineKey *SiteMachineKey_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SiteMachineKey_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (machineKey *SiteMachineKey_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SiteMachineKey_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SiteMachineKey_STATUSARM, got %T", armInput)
	}

	// Set property ‘Decryption’:
	if typedInput.Decryption != nil {
		decryption := *typedInput.Decryption
		machineKey.Decryption = &decryption
	}

	// Set property ‘DecryptionKey’:
	if typedInput.DecryptionKey != nil {
		decryptionKey := *typedInput.DecryptionKey
		machineKey.DecryptionKey = &decryptionKey
	}

	// Set property ‘Validation’:
	if typedInput.Validation != nil {
		validation := *typedInput.Validation
		machineKey.Validation = &validation
	}

	// Set property ‘ValidationKey’:
	if typedInput.ValidationKey != nil {
		validationKey := *typedInput.ValidationKey
		machineKey.ValidationKey = &validationKey
	}

	// No error
	return nil
}

// AssignPropertiesFromSiteMachineKeySTATUS populates our SiteMachineKey_STATUS from the provided source SiteMachineKey_STATUS
func (machineKey *SiteMachineKey_STATUS) AssignPropertiesFromSiteMachineKeySTATUS(source *v20220301s.SiteMachineKey_STATUS) error {

	// Decryption
	machineKey.Decryption = genruntime.ClonePointerToString(source.Decryption)

	// DecryptionKey
	machineKey.DecryptionKey = genruntime.ClonePointerToString(source.DecryptionKey)

	// Validation
	machineKey.Validation = genruntime.ClonePointerToString(source.Validation)

	// ValidationKey
	machineKey.ValidationKey = genruntime.ClonePointerToString(source.ValidationKey)

	// No error
	return nil
}

// AssignPropertiesToSiteMachineKeySTATUS populates the provided destination SiteMachineKey_STATUS from our SiteMachineKey_STATUS
func (machineKey *SiteMachineKey_STATUS) AssignPropertiesToSiteMachineKeySTATUS(destination *v20220301s.SiteMachineKey_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Decryption
	destination.Decryption = genruntime.ClonePointerToString(machineKey.Decryption)

	// DecryptionKey
	destination.DecryptionKey = genruntime.ClonePointerToString(machineKey.DecryptionKey)

	// Validation
	destination.Validation = genruntime.ClonePointerToString(machineKey.Validation)

	// ValidationKey
	destination.ValidationKey = genruntime.ClonePointerToString(machineKey.ValidationKey)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Sites_Spec_Properties_SiteConfig_AzureStorageAccounts struct {
	// AccessKey: Access key for the storage account.
	AccessKey *genruntime.SecretReference `json:"accessKey,omitempty"`

	// AccountName: Name of the storage account.
	AccountName *string `json:"accountName,omitempty"`

	// MountPath: Path to mount the storage within the site's runtime environment.
	MountPath *string `json:"mountPath,omitempty"`

	// ShareName: Name of the file share (container name, for Blob storage).
	ShareName *string `json:"shareName,omitempty"`

	// Type: Type of storage.
	Type *SitesSpecPropertiesSiteConfigAzureStorageAccountsType `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &Sites_Spec_Properties_SiteConfig_AzureStorageAccounts{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (accounts *Sites_Spec_Properties_SiteConfig_AzureStorageAccounts) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if accounts == nil {
		return nil, nil
	}
	result := &Sites_Spec_Properties_SiteConfig_AzureStorageAccountsARM{}

	// Set property ‘AccessKey’:
	if accounts.AccessKey != nil {
		accessKeySecret, err := resolved.ResolvedSecrets.LookupSecret(*accounts.AccessKey)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property AccessKey")
		}
		accessKey := accessKeySecret
		result.AccessKey = &accessKey
	}

	// Set property ‘AccountName’:
	if accounts.AccountName != nil {
		accountName := *accounts.AccountName
		result.AccountName = &accountName
	}

	// Set property ‘MountPath’:
	if accounts.MountPath != nil {
		mountPath := *accounts.MountPath
		result.MountPath = &mountPath
	}

	// Set property ‘ShareName’:
	if accounts.ShareName != nil {
		shareName := *accounts.ShareName
		result.ShareName = &shareName
	}

	// Set property ‘Type’:
	if accounts.Type != nil {
		typeVar := *accounts.Type
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (accounts *Sites_Spec_Properties_SiteConfig_AzureStorageAccounts) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Sites_Spec_Properties_SiteConfig_AzureStorageAccountsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (accounts *Sites_Spec_Properties_SiteConfig_AzureStorageAccounts) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Sites_Spec_Properties_SiteConfig_AzureStorageAccountsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Sites_Spec_Properties_SiteConfig_AzureStorageAccountsARM, got %T", armInput)
	}

	// no assignment for property ‘AccessKey’

	// Set property ‘AccountName’:
	if typedInput.AccountName != nil {
		accountName := *typedInput.AccountName
		accounts.AccountName = &accountName
	}

	// Set property ‘MountPath’:
	if typedInput.MountPath != nil {
		mountPath := *typedInput.MountPath
		accounts.MountPath = &mountPath
	}

	// Set property ‘ShareName’:
	if typedInput.ShareName != nil {
		shareName := *typedInput.ShareName
		accounts.ShareName = &shareName
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		accounts.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromSitesSpecPropertiesSiteConfigAzureStorageAccounts populates our Sites_Spec_Properties_SiteConfig_AzureStorageAccounts from the provided source Sites_Spec_Properties_SiteConfig_AzureStorageAccounts
func (accounts *Sites_Spec_Properties_SiteConfig_AzureStorageAccounts) AssignPropertiesFromSitesSpecPropertiesSiteConfigAzureStorageAccounts(source *v20220301s.Sites_Spec_Properties_SiteConfig_AzureStorageAccounts) error {

	// AccessKey
	if source.AccessKey != nil {
		accessKey := source.AccessKey.Copy()
		accounts.AccessKey = &accessKey
	} else {
		accounts.AccessKey = nil
	}

	// AccountName
	accounts.AccountName = genruntime.ClonePointerToString(source.AccountName)

	// MountPath
	accounts.MountPath = genruntime.ClonePointerToString(source.MountPath)

	// ShareName
	accounts.ShareName = genruntime.ClonePointerToString(source.ShareName)

	// Type
	if source.Type != nil {
		typeVar := SitesSpecPropertiesSiteConfigAzureStorageAccountsType(*source.Type)
		accounts.Type = &typeVar
	} else {
		accounts.Type = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSitesSpecPropertiesSiteConfigAzureStorageAccounts populates the provided destination Sites_Spec_Properties_SiteConfig_AzureStorageAccounts from our Sites_Spec_Properties_SiteConfig_AzureStorageAccounts
func (accounts *Sites_Spec_Properties_SiteConfig_AzureStorageAccounts) AssignPropertiesToSitesSpecPropertiesSiteConfigAzureStorageAccounts(destination *v20220301s.Sites_Spec_Properties_SiteConfig_AzureStorageAccounts) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AccessKey
	if accounts.AccessKey != nil {
		accessKey := accounts.AccessKey.Copy()
		destination.AccessKey = &accessKey
	} else {
		destination.AccessKey = nil
	}

	// AccountName
	destination.AccountName = genruntime.ClonePointerToString(accounts.AccountName)

	// MountPath
	destination.MountPath = genruntime.ClonePointerToString(accounts.MountPath)

	// ShareName
	destination.ShareName = genruntime.ClonePointerToString(accounts.ShareName)

	// Type
	if accounts.Type != nil {
		typeVar := string(*accounts.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Sites_Spec_Properties_SiteConfig_Push struct {
	// DynamicTagsJson: Gets or sets a JSON string containing a list of dynamic tags that will be evaluated from user claims in
	// the push registration endpoint.
	DynamicTagsJson *string `json:"dynamicTagsJson,omitempty"`

	// +kubebuilder:validation:Required
	// IsPushEnabled: Gets or sets a flag indicating whether the Push endpoint is enabled.
	IsPushEnabled *bool `json:"isPushEnabled,omitempty"`

	// Kind: Kind of resource.
	Kind *string `json:"kind,omitempty"`

	// TagWhitelistJson: Gets or sets a JSON string containing a list of tags that are whitelisted for use by the push
	// registration endpoint.
	TagWhitelistJson *string `json:"tagWhitelistJson,omitempty"`

	// TagsRequiringAuth: Gets or sets a JSON string containing a list of tags that require user authentication to be used in
	// the push registration endpoint.
	// Tags can consist of alphanumeric characters and the following:
	// '_', '@', '#', '.', ':', '-'.
	// Validation should be performed at the PushRequestHandler.
	TagsRequiringAuth *string `json:"tagsRequiringAuth,omitempty"`
}

var _ genruntime.ARMTransformer = &Sites_Spec_Properties_SiteConfig_Push{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (push *Sites_Spec_Properties_SiteConfig_Push) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if push == nil {
		return nil, nil
	}
	result := &Sites_Spec_Properties_SiteConfig_PushARM{}

	// Set property ‘Kind’:
	if push.Kind != nil {
		kind := *push.Kind
		result.Kind = &kind
	}

	// Set property ‘Properties’:
	if push.DynamicTagsJson != nil ||
		push.IsPushEnabled != nil ||
		push.TagWhitelistJson != nil ||
		push.TagsRequiringAuth != nil {
		result.Properties = &PushSettingsPropertiesARM{}
	}
	if push.DynamicTagsJson != nil {
		dynamicTagsJson := *push.DynamicTagsJson
		result.Properties.DynamicTagsJson = &dynamicTagsJson
	}
	if push.IsPushEnabled != nil {
		isPushEnabled := *push.IsPushEnabled
		result.Properties.IsPushEnabled = &isPushEnabled
	}
	if push.TagWhitelistJson != nil {
		tagWhitelistJson := *push.TagWhitelistJson
		result.Properties.TagWhitelistJson = &tagWhitelistJson
	}
	if push.TagsRequiringAuth != nil {
		tagsRequiringAuth := *push.TagsRequiringAuth
		result.Properties.TagsRequiringAuth = &tagsRequiringAuth
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (push *Sites_Spec_Properties_SiteConfig_Push) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Sites_Spec_Properties_SiteConfig_PushARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (push *Sites_Spec_Properties_SiteConfig_Push) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Sites_Spec_Properties_SiteConfig_PushARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Sites_Spec_Properties_SiteConfig_PushARM, got %T", armInput)
	}

	// Set property ‘DynamicTagsJson’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DynamicTagsJson != nil {
			dynamicTagsJson := *typedInput.Properties.DynamicTagsJson
			push.DynamicTagsJson = &dynamicTagsJson
		}
	}

	// Set property ‘IsPushEnabled’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IsPushEnabled != nil {
			isPushEnabled := *typedInput.Properties.IsPushEnabled
			push.IsPushEnabled = &isPushEnabled
		}
	}

	// Set property ‘Kind’:
	if typedInput.Kind != nil {
		kind := *typedInput.Kind
		push.Kind = &kind
	}

	// Set property ‘TagWhitelistJson’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TagWhitelistJson != nil {
			tagWhitelistJson := *typedInput.Properties.TagWhitelistJson
			push.TagWhitelistJson = &tagWhitelistJson
		}
	}

	// Set property ‘TagsRequiringAuth’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TagsRequiringAuth != nil {
			tagsRequiringAuth := *typedInput.Properties.TagsRequiringAuth
			push.TagsRequiringAuth = &tagsRequiringAuth
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromSitesSpecPropertiesSiteConfigPush populates our Sites_Spec_Properties_SiteConfig_Push from the provided source Sites_Spec_Properties_SiteConfig_Push
func (push *Sites_Spec_Properties_SiteConfig_Push) AssignPropertiesFromSitesSpecPropertiesSiteConfigPush(source *v20220301s.Sites_Spec_Properties_SiteConfig_Push) error {

	// DynamicTagsJson
	push.DynamicTagsJson = genruntime.ClonePointerToString(source.DynamicTagsJson)

	// IsPushEnabled
	if source.IsPushEnabled != nil {
		isPushEnabled := *source.IsPushEnabled
		push.IsPushEnabled = &isPushEnabled
	} else {
		push.IsPushEnabled = nil
	}

	// Kind
	push.Kind = genruntime.ClonePointerToString(source.Kind)

	// TagWhitelistJson
	push.TagWhitelistJson = genruntime.ClonePointerToString(source.TagWhitelistJson)

	// TagsRequiringAuth
	push.TagsRequiringAuth = genruntime.ClonePointerToString(source.TagsRequiringAuth)

	// No error
	return nil
}

// AssignPropertiesToSitesSpecPropertiesSiteConfigPush populates the provided destination Sites_Spec_Properties_SiteConfig_Push from our Sites_Spec_Properties_SiteConfig_Push
func (push *Sites_Spec_Properties_SiteConfig_Push) AssignPropertiesToSitesSpecPropertiesSiteConfigPush(destination *v20220301s.Sites_Spec_Properties_SiteConfig_Push) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DynamicTagsJson
	destination.DynamicTagsJson = genruntime.ClonePointerToString(push.DynamicTagsJson)

	// IsPushEnabled
	if push.IsPushEnabled != nil {
		isPushEnabled := *push.IsPushEnabled
		destination.IsPushEnabled = &isPushEnabled
	} else {
		destination.IsPushEnabled = nil
	}

	// Kind
	destination.Kind = genruntime.ClonePointerToString(push.Kind)

	// TagWhitelistJson
	destination.TagWhitelistJson = genruntime.ClonePointerToString(push.TagWhitelistJson)

	// TagsRequiringAuth
	destination.TagsRequiringAuth = genruntime.ClonePointerToString(push.TagsRequiringAuth)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"AllAllowed","Disabled","FtpsOnly"}
type SitesSpecPropertiesSiteConfigFtpsState string

const (
	SitesSpecPropertiesSiteConfigFtpsState_AllAllowed = SitesSpecPropertiesSiteConfigFtpsState("AllAllowed")
	SitesSpecPropertiesSiteConfigFtpsState_Disabled   = SitesSpecPropertiesSiteConfigFtpsState("Disabled")
	SitesSpecPropertiesSiteConfigFtpsState_FtpsOnly   = SitesSpecPropertiesSiteConfigFtpsState("FtpsOnly")
)

// +kubebuilder:validation:Enum={"LeastRequests","LeastResponseTime","PerSiteRoundRobin","RequestHash","WeightedRoundRobin","WeightedTotalTraffic"}
type SitesSpecPropertiesSiteConfigLoadBalancing string

const (
	SitesSpecPropertiesSiteConfigLoadBalancing_LeastRequests        = SitesSpecPropertiesSiteConfigLoadBalancing("LeastRequests")
	SitesSpecPropertiesSiteConfigLoadBalancing_LeastResponseTime    = SitesSpecPropertiesSiteConfigLoadBalancing("LeastResponseTime")
	SitesSpecPropertiesSiteConfigLoadBalancing_PerSiteRoundRobin    = SitesSpecPropertiesSiteConfigLoadBalancing("PerSiteRoundRobin")
	SitesSpecPropertiesSiteConfigLoadBalancing_RequestHash          = SitesSpecPropertiesSiteConfigLoadBalancing("RequestHash")
	SitesSpecPropertiesSiteConfigLoadBalancing_WeightedRoundRobin   = SitesSpecPropertiesSiteConfigLoadBalancing("WeightedRoundRobin")
	SitesSpecPropertiesSiteConfigLoadBalancing_WeightedTotalTraffic = SitesSpecPropertiesSiteConfigLoadBalancing("WeightedTotalTraffic")
)

// +kubebuilder:validation:Enum={"Classic","Integrated"}
type SitesSpecPropertiesSiteConfigManagedPipelineMode string

const (
	SitesSpecPropertiesSiteConfigManagedPipelineMode_Classic    = SitesSpecPropertiesSiteConfigManagedPipelineMode("Classic")
	SitesSpecPropertiesSiteConfigManagedPipelineMode_Integrated = SitesSpecPropertiesSiteConfigManagedPipelineMode("Integrated")
)

// +kubebuilder:validation:Enum={"1.0","1.1","1.2"}
type SitesSpecPropertiesSiteConfigMinTlsVersion string

const (
	SitesSpecPropertiesSiteConfigMinTlsVersion_10 = SitesSpecPropertiesSiteConfigMinTlsVersion("1.0")
	SitesSpecPropertiesSiteConfigMinTlsVersion_11 = SitesSpecPropertiesSiteConfigMinTlsVersion("1.1")
	SitesSpecPropertiesSiteConfigMinTlsVersion_12 = SitesSpecPropertiesSiteConfigMinTlsVersion("1.2")
)

// +kubebuilder:validation:Enum={"1.0","1.1","1.2"}
type SitesSpecPropertiesSiteConfigScmMinTlsVersion string

const (
	SitesSpecPropertiesSiteConfigScmMinTlsVersion_10 = SitesSpecPropertiesSiteConfigScmMinTlsVersion("1.0")
	SitesSpecPropertiesSiteConfigScmMinTlsVersion_11 = SitesSpecPropertiesSiteConfigScmMinTlsVersion("1.1")
	SitesSpecPropertiesSiteConfigScmMinTlsVersion_12 = SitesSpecPropertiesSiteConfigScmMinTlsVersion("1.2")
)

// +kubebuilder:validation:Enum={"BitbucketGit","BitbucketHg","CodePlexGit","CodePlexHg","Dropbox","ExternalGit","ExternalHg","GitHub","LocalGit","None","OneDrive","Tfs","VSO","VSTSRM"}
type SitesSpecPropertiesSiteConfigScmType string

const (
	SitesSpecPropertiesSiteConfigScmType_BitbucketGit = SitesSpecPropertiesSiteConfigScmType("BitbucketGit")
	SitesSpecPropertiesSiteConfigScmType_BitbucketHg  = SitesSpecPropertiesSiteConfigScmType("BitbucketHg")
	SitesSpecPropertiesSiteConfigScmType_CodePlexGit  = SitesSpecPropertiesSiteConfigScmType("CodePlexGit")
	SitesSpecPropertiesSiteConfigScmType_CodePlexHg   = SitesSpecPropertiesSiteConfigScmType("CodePlexHg")
	SitesSpecPropertiesSiteConfigScmType_Dropbox      = SitesSpecPropertiesSiteConfigScmType("Dropbox")
	SitesSpecPropertiesSiteConfigScmType_ExternalGit  = SitesSpecPropertiesSiteConfigScmType("ExternalGit")
	SitesSpecPropertiesSiteConfigScmType_ExternalHg   = SitesSpecPropertiesSiteConfigScmType("ExternalHg")
	SitesSpecPropertiesSiteConfigScmType_GitHub       = SitesSpecPropertiesSiteConfigScmType("GitHub")
	SitesSpecPropertiesSiteConfigScmType_LocalGit     = SitesSpecPropertiesSiteConfigScmType("LocalGit")
	SitesSpecPropertiesSiteConfigScmType_None         = SitesSpecPropertiesSiteConfigScmType("None")
	SitesSpecPropertiesSiteConfigScmType_OneDrive     = SitesSpecPropertiesSiteConfigScmType("OneDrive")
	SitesSpecPropertiesSiteConfigScmType_Tfs          = SitesSpecPropertiesSiteConfigScmType("Tfs")
	SitesSpecPropertiesSiteConfigScmType_VSO          = SitesSpecPropertiesSiteConfigScmType("VSO")
	SitesSpecPropertiesSiteConfigScmType_VSTSRM       = SitesSpecPropertiesSiteConfigScmType("VSTSRM")
)

type UserAssignedIdentity_STATUS struct {
	// ClientId: Client Id of user assigned identity
	ClientId *string `json:"clientId,omitempty"`

	// PrincipalId: Principal Id of user assigned identity
	PrincipalId *string `json:"principalId,omitempty"`
}

var _ genruntime.FromARMConverter = &UserAssignedIdentity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *UserAssignedIdentity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &UserAssignedIdentity_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *UserAssignedIdentity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(UserAssignedIdentity_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected UserAssignedIdentity_STATUSARM, got %T", armInput)
	}

	// Set property ‘ClientId’:
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		identity.ClientId = &clientId
	}

	// Set property ‘PrincipalId’:
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identity.PrincipalId = &principalId
	}

	// No error
	return nil
}

// AssignPropertiesFromUserAssignedIdentitySTATUS populates our UserAssignedIdentity_STATUS from the provided source UserAssignedIdentity_STATUS
func (identity *UserAssignedIdentity_STATUS) AssignPropertiesFromUserAssignedIdentitySTATUS(source *v20220301s.UserAssignedIdentity_STATUS) error {

	// ClientId
	identity.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// No error
	return nil
}

// AssignPropertiesToUserAssignedIdentitySTATUS populates the provided destination UserAssignedIdentity_STATUS from our UserAssignedIdentity_STATUS
func (identity *UserAssignedIdentity_STATUS) AssignPropertiesToUserAssignedIdentitySTATUS(destination *v20220301s.UserAssignedIdentity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(identity.ClientId)

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2022-03-01/Microsoft.Web.json#/definitions/VirtualApplication
type VirtualApplication struct {
	// PhysicalPath: Physical path.
	PhysicalPath *string `json:"physicalPath,omitempty"`

	// PreloadEnabled: <code>true</code> if preloading is enabled; otherwise, <code>false</code>.
	PreloadEnabled *bool `json:"preloadEnabled,omitempty"`

	// VirtualDirectories: Virtual directories for virtual application.
	VirtualDirectories []VirtualDirectory `json:"virtualDirectories,omitempty"`

	// VirtualPath: Virtual path.
	VirtualPath *string `json:"virtualPath,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualApplication{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (application *VirtualApplication) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if application == nil {
		return nil, nil
	}
	result := &VirtualApplicationARM{}

	// Set property ‘PhysicalPath’:
	if application.PhysicalPath != nil {
		physicalPath := *application.PhysicalPath
		result.PhysicalPath = &physicalPath
	}

	// Set property ‘PreloadEnabled’:
	if application.PreloadEnabled != nil {
		preloadEnabled := *application.PreloadEnabled
		result.PreloadEnabled = &preloadEnabled
	}

	// Set property ‘VirtualDirectories’:
	for _, item := range application.VirtualDirectories {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.VirtualDirectories = append(result.VirtualDirectories, *itemARM.(*VirtualDirectoryARM))
	}

	// Set property ‘VirtualPath’:
	if application.VirtualPath != nil {
		virtualPath := *application.VirtualPath
		result.VirtualPath = &virtualPath
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (application *VirtualApplication) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualApplicationARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (application *VirtualApplication) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualApplicationARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualApplicationARM, got %T", armInput)
	}

	// Set property ‘PhysicalPath’:
	if typedInput.PhysicalPath != nil {
		physicalPath := *typedInput.PhysicalPath
		application.PhysicalPath = &physicalPath
	}

	// Set property ‘PreloadEnabled’:
	if typedInput.PreloadEnabled != nil {
		preloadEnabled := *typedInput.PreloadEnabled
		application.PreloadEnabled = &preloadEnabled
	}

	// Set property ‘VirtualDirectories’:
	for _, item := range typedInput.VirtualDirectories {
		var item1 VirtualDirectory
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		application.VirtualDirectories = append(application.VirtualDirectories, item1)
	}

	// Set property ‘VirtualPath’:
	if typedInput.VirtualPath != nil {
		virtualPath := *typedInput.VirtualPath
		application.VirtualPath = &virtualPath
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualApplication populates our VirtualApplication from the provided source VirtualApplication
func (application *VirtualApplication) AssignPropertiesFromVirtualApplication(source *v20220301s.VirtualApplication) error {

	// PhysicalPath
	application.PhysicalPath = genruntime.ClonePointerToString(source.PhysicalPath)

	// PreloadEnabled
	if source.PreloadEnabled != nil {
		preloadEnabled := *source.PreloadEnabled
		application.PreloadEnabled = &preloadEnabled
	} else {
		application.PreloadEnabled = nil
	}

	// VirtualDirectories
	if source.VirtualDirectories != nil {
		virtualDirectoryList := make([]VirtualDirectory, len(source.VirtualDirectories))
		for virtualDirectoryIndex, virtualDirectoryItem := range source.VirtualDirectories {
			// Shadow the loop variable to avoid aliasing
			virtualDirectoryItem := virtualDirectoryItem
			var virtualDirectory VirtualDirectory
			err := virtualDirectory.AssignPropertiesFromVirtualDirectory(&virtualDirectoryItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVirtualDirectory() to populate field VirtualDirectories")
			}
			virtualDirectoryList[virtualDirectoryIndex] = virtualDirectory
		}
		application.VirtualDirectories = virtualDirectoryList
	} else {
		application.VirtualDirectories = nil
	}

	// VirtualPath
	application.VirtualPath = genruntime.ClonePointerToString(source.VirtualPath)

	// No error
	return nil
}

// AssignPropertiesToVirtualApplication populates the provided destination VirtualApplication from our VirtualApplication
func (application *VirtualApplication) AssignPropertiesToVirtualApplication(destination *v20220301s.VirtualApplication) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PhysicalPath
	destination.PhysicalPath = genruntime.ClonePointerToString(application.PhysicalPath)

	// PreloadEnabled
	if application.PreloadEnabled != nil {
		preloadEnabled := *application.PreloadEnabled
		destination.PreloadEnabled = &preloadEnabled
	} else {
		destination.PreloadEnabled = nil
	}

	// VirtualDirectories
	if application.VirtualDirectories != nil {
		virtualDirectoryList := make([]v20220301s.VirtualDirectory, len(application.VirtualDirectories))
		for virtualDirectoryIndex, virtualDirectoryItem := range application.VirtualDirectories {
			// Shadow the loop variable to avoid aliasing
			virtualDirectoryItem := virtualDirectoryItem
			var virtualDirectory v20220301s.VirtualDirectory
			err := virtualDirectoryItem.AssignPropertiesToVirtualDirectory(&virtualDirectory)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVirtualDirectory() to populate field VirtualDirectories")
			}
			virtualDirectoryList[virtualDirectoryIndex] = virtualDirectory
		}
		destination.VirtualDirectories = virtualDirectoryList
	} else {
		destination.VirtualDirectories = nil
	}

	// VirtualPath
	destination.VirtualPath = genruntime.ClonePointerToString(application.VirtualPath)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualApplication_STATUS struct {
	// PhysicalPath: Physical path.
	PhysicalPath *string `json:"physicalPath,omitempty"`

	// PreloadEnabled: <code>true</code> if preloading is enabled; otherwise, <code>false</code>.
	PreloadEnabled *bool `json:"preloadEnabled,omitempty"`

	// VirtualDirectories: Virtual directories for virtual application.
	VirtualDirectories []VirtualDirectory_STATUS `json:"virtualDirectories,omitempty"`

	// VirtualPath: Virtual path.
	VirtualPath *string `json:"virtualPath,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualApplication_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (application *VirtualApplication_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualApplication_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (application *VirtualApplication_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualApplication_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualApplication_STATUSARM, got %T", armInput)
	}

	// Set property ‘PhysicalPath’:
	if typedInput.PhysicalPath != nil {
		physicalPath := *typedInput.PhysicalPath
		application.PhysicalPath = &physicalPath
	}

	// Set property ‘PreloadEnabled’:
	if typedInput.PreloadEnabled != nil {
		preloadEnabled := *typedInput.PreloadEnabled
		application.PreloadEnabled = &preloadEnabled
	}

	// Set property ‘VirtualDirectories’:
	for _, item := range typedInput.VirtualDirectories {
		var item1 VirtualDirectory_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		application.VirtualDirectories = append(application.VirtualDirectories, item1)
	}

	// Set property ‘VirtualPath’:
	if typedInput.VirtualPath != nil {
		virtualPath := *typedInput.VirtualPath
		application.VirtualPath = &virtualPath
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualApplicationSTATUS populates our VirtualApplication_STATUS from the provided source VirtualApplication_STATUS
func (application *VirtualApplication_STATUS) AssignPropertiesFromVirtualApplicationSTATUS(source *v20220301s.VirtualApplication_STATUS) error {

	// PhysicalPath
	application.PhysicalPath = genruntime.ClonePointerToString(source.PhysicalPath)

	// PreloadEnabled
	if source.PreloadEnabled != nil {
		preloadEnabled := *source.PreloadEnabled
		application.PreloadEnabled = &preloadEnabled
	} else {
		application.PreloadEnabled = nil
	}

	// VirtualDirectories
	if source.VirtualDirectories != nil {
		virtualDirectoryList := make([]VirtualDirectory_STATUS, len(source.VirtualDirectories))
		for virtualDirectoryIndex, virtualDirectoryItem := range source.VirtualDirectories {
			// Shadow the loop variable to avoid aliasing
			virtualDirectoryItem := virtualDirectoryItem
			var virtualDirectory VirtualDirectory_STATUS
			err := virtualDirectory.AssignPropertiesFromVirtualDirectorySTATUS(&virtualDirectoryItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromVirtualDirectorySTATUS() to populate field VirtualDirectories")
			}
			virtualDirectoryList[virtualDirectoryIndex] = virtualDirectory
		}
		application.VirtualDirectories = virtualDirectoryList
	} else {
		application.VirtualDirectories = nil
	}

	// VirtualPath
	application.VirtualPath = genruntime.ClonePointerToString(source.VirtualPath)

	// No error
	return nil
}

// AssignPropertiesToVirtualApplicationSTATUS populates the provided destination VirtualApplication_STATUS from our VirtualApplication_STATUS
func (application *VirtualApplication_STATUS) AssignPropertiesToVirtualApplicationSTATUS(destination *v20220301s.VirtualApplication_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PhysicalPath
	destination.PhysicalPath = genruntime.ClonePointerToString(application.PhysicalPath)

	// PreloadEnabled
	if application.PreloadEnabled != nil {
		preloadEnabled := *application.PreloadEnabled
		destination.PreloadEnabled = &preloadEnabled
	} else {
		destination.PreloadEnabled = nil
	}

	// VirtualDirectories
	if application.VirtualDirectories != nil {
		virtualDirectoryList := make([]v20220301s.VirtualDirectory_STATUS, len(application.VirtualDirectories))
		for virtualDirectoryIndex, virtualDirectoryItem := range application.VirtualDirectories {
			// Shadow the loop variable to avoid aliasing
			virtualDirectoryItem := virtualDirectoryItem
			var virtualDirectory v20220301s.VirtualDirectory_STATUS
			err := virtualDirectoryItem.AssignPropertiesToVirtualDirectorySTATUS(&virtualDirectory)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToVirtualDirectorySTATUS() to populate field VirtualDirectories")
			}
			virtualDirectoryList[virtualDirectoryIndex] = virtualDirectory
		}
		destination.VirtualDirectories = virtualDirectoryList
	} else {
		destination.VirtualDirectories = nil
	}

	// VirtualPath
	destination.VirtualPath = genruntime.ClonePointerToString(application.VirtualPath)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2022-03-01/Microsoft.Web.json#/definitions/AutoHealActions
type AutoHealActions struct {
	// ActionType: Predefined action to be taken.
	ActionType *AutoHealActionsActionType `json:"actionType,omitempty"`

	// CustomAction: Custom action to be executed
	// when an auto heal rule is triggered.
	CustomAction *AutoHealCustomAction `json:"customAction,omitempty"`

	// MinProcessExecutionTime: Minimum time the process must execute
	// before taking the action
	MinProcessExecutionTime *string `json:"minProcessExecutionTime,omitempty"`
}

var _ genruntime.ARMTransformer = &AutoHealActions{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (actions *AutoHealActions) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if actions == nil {
		return nil, nil
	}
	result := &AutoHealActionsARM{}

	// Set property ‘ActionType’:
	if actions.ActionType != nil {
		actionType := *actions.ActionType
		result.ActionType = &actionType
	}

	// Set property ‘CustomAction’:
	if actions.CustomAction != nil {
		customActionARM, err := (*actions.CustomAction).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		customAction := *customActionARM.(*AutoHealCustomActionARM)
		result.CustomAction = &customAction
	}

	// Set property ‘MinProcessExecutionTime’:
	if actions.MinProcessExecutionTime != nil {
		minProcessExecutionTime := *actions.MinProcessExecutionTime
		result.MinProcessExecutionTime = &minProcessExecutionTime
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (actions *AutoHealActions) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AutoHealActionsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (actions *AutoHealActions) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AutoHealActionsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AutoHealActionsARM, got %T", armInput)
	}

	// Set property ‘ActionType’:
	if typedInput.ActionType != nil {
		actionType := *typedInput.ActionType
		actions.ActionType = &actionType
	}

	// Set property ‘CustomAction’:
	if typedInput.CustomAction != nil {
		var customAction1 AutoHealCustomAction
		err := customAction1.PopulateFromARM(owner, *typedInput.CustomAction)
		if err != nil {
			return err
		}
		customAction := customAction1
		actions.CustomAction = &customAction
	}

	// Set property ‘MinProcessExecutionTime’:
	if typedInput.MinProcessExecutionTime != nil {
		minProcessExecutionTime := *typedInput.MinProcessExecutionTime
		actions.MinProcessExecutionTime = &minProcessExecutionTime
	}

	// No error
	return nil
}

// AssignPropertiesFromAutoHealActions populates our AutoHealActions from the provided source AutoHealActions
func (actions *AutoHealActions) AssignPropertiesFromAutoHealActions(source *v20220301s.AutoHealActions) error {

	// ActionType
	if source.ActionType != nil {
		actionType := AutoHealActionsActionType(*source.ActionType)
		actions.ActionType = &actionType
	} else {
		actions.ActionType = nil
	}

	// CustomAction
	if source.CustomAction != nil {
		var customAction AutoHealCustomAction
		err := customAction.AssignPropertiesFromAutoHealCustomAction(source.CustomAction)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromAutoHealCustomAction() to populate field CustomAction")
		}
		actions.CustomAction = &customAction
	} else {
		actions.CustomAction = nil
	}

	// MinProcessExecutionTime
	actions.MinProcessExecutionTime = genruntime.ClonePointerToString(source.MinProcessExecutionTime)

	// No error
	return nil
}

// AssignPropertiesToAutoHealActions populates the provided destination AutoHealActions from our AutoHealActions
func (actions *AutoHealActions) AssignPropertiesToAutoHealActions(destination *v20220301s.AutoHealActions) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ActionType
	if actions.ActionType != nil {
		actionType := string(*actions.ActionType)
		destination.ActionType = &actionType
	} else {
		destination.ActionType = nil
	}

	// CustomAction
	if actions.CustomAction != nil {
		var customAction v20220301s.AutoHealCustomAction
		err := actions.CustomAction.AssignPropertiesToAutoHealCustomAction(&customAction)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToAutoHealCustomAction() to populate field CustomAction")
		}
		destination.CustomAction = &customAction
	} else {
		destination.CustomAction = nil
	}

	// MinProcessExecutionTime
	destination.MinProcessExecutionTime = genruntime.ClonePointerToString(actions.MinProcessExecutionTime)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AutoHealActions_STATUS struct {
	// ActionType: Predefined action to be taken.
	ActionType *AutoHealActionsSTATUSActionType `json:"actionType,omitempty"`

	// CustomAction: Custom action to be taken.
	CustomAction *AutoHealCustomAction_STATUS `json:"customAction,omitempty"`

	// MinProcessExecutionTime: Minimum time the process must execute
	// before taking the action
	MinProcessExecutionTime *string `json:"minProcessExecutionTime,omitempty"`
}

var _ genruntime.FromARMConverter = &AutoHealActions_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (actions *AutoHealActions_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AutoHealActions_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (actions *AutoHealActions_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AutoHealActions_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AutoHealActions_STATUSARM, got %T", armInput)
	}

	// Set property ‘ActionType’:
	if typedInput.ActionType != nil {
		actionType := *typedInput.ActionType
		actions.ActionType = &actionType
	}

	// Set property ‘CustomAction’:
	if typedInput.CustomAction != nil {
		var customAction1 AutoHealCustomAction_STATUS
		err := customAction1.PopulateFromARM(owner, *typedInput.CustomAction)
		if err != nil {
			return err
		}
		customAction := customAction1
		actions.CustomAction = &customAction
	}

	// Set property ‘MinProcessExecutionTime’:
	if typedInput.MinProcessExecutionTime != nil {
		minProcessExecutionTime := *typedInput.MinProcessExecutionTime
		actions.MinProcessExecutionTime = &minProcessExecutionTime
	}

	// No error
	return nil
}

// AssignPropertiesFromAutoHealActionsSTATUS populates our AutoHealActions_STATUS from the provided source AutoHealActions_STATUS
func (actions *AutoHealActions_STATUS) AssignPropertiesFromAutoHealActionsSTATUS(source *v20220301s.AutoHealActions_STATUS) error {

	// ActionType
	if source.ActionType != nil {
		actionType := AutoHealActionsSTATUSActionType(*source.ActionType)
		actions.ActionType = &actionType
	} else {
		actions.ActionType = nil
	}

	// CustomAction
	if source.CustomAction != nil {
		var customAction AutoHealCustomAction_STATUS
		err := customAction.AssignPropertiesFromAutoHealCustomActionSTATUS(source.CustomAction)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromAutoHealCustomActionSTATUS() to populate field CustomAction")
		}
		actions.CustomAction = &customAction
	} else {
		actions.CustomAction = nil
	}

	// MinProcessExecutionTime
	actions.MinProcessExecutionTime = genruntime.ClonePointerToString(source.MinProcessExecutionTime)

	// No error
	return nil
}

// AssignPropertiesToAutoHealActionsSTATUS populates the provided destination AutoHealActions_STATUS from our AutoHealActions_STATUS
func (actions *AutoHealActions_STATUS) AssignPropertiesToAutoHealActionsSTATUS(destination *v20220301s.AutoHealActions_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ActionType
	if actions.ActionType != nil {
		actionType := string(*actions.ActionType)
		destination.ActionType = &actionType
	} else {
		destination.ActionType = nil
	}

	// CustomAction
	if actions.CustomAction != nil {
		var customAction v20220301s.AutoHealCustomAction_STATUS
		err := actions.CustomAction.AssignPropertiesToAutoHealCustomActionSTATUS(&customAction)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToAutoHealCustomActionSTATUS() to populate field CustomAction")
		}
		destination.CustomAction = &customAction
	} else {
		destination.CustomAction = nil
	}

	// MinProcessExecutionTime
	destination.MinProcessExecutionTime = genruntime.ClonePointerToString(actions.MinProcessExecutionTime)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2022-03-01/Microsoft.Web.json#/definitions/AutoHealTriggers
type AutoHealTriggers struct {
	// PrivateBytesInKB: A rule based on private bytes.
	PrivateBytesInKB *int `json:"privateBytesInKB,omitempty"`

	// Requests: Trigger based on total requests.
	Requests *RequestsBasedTrigger `json:"requests,omitempty"`

	// SlowRequests: Trigger based on request execution time.
	SlowRequests *SlowRequestsBasedTrigger `json:"slowRequests,omitempty"`

	// SlowRequestsWithPath: A rule based on multiple Slow Requests Rule with path
	SlowRequestsWithPath []SlowRequestsBasedTrigger `json:"slowRequestsWithPath,omitempty"`

	// StatusCodes: A rule based on status codes.
	StatusCodes []StatusCodesBasedTrigger `json:"statusCodes,omitempty"`

	// StatusCodesRange: A rule based on status codes ranges.
	StatusCodesRange []StatusCodesRangeBasedTrigger `json:"statusCodesRange,omitempty"`
}

var _ genruntime.ARMTransformer = &AutoHealTriggers{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (triggers *AutoHealTriggers) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if triggers == nil {
		return nil, nil
	}
	result := &AutoHealTriggersARM{}

	// Set property ‘PrivateBytesInKB’:
	if triggers.PrivateBytesInKB != nil {
		privateBytesInKB := *triggers.PrivateBytesInKB
		result.PrivateBytesInKB = &privateBytesInKB
	}

	// Set property ‘Requests’:
	if triggers.Requests != nil {
		requestsARM, err := (*triggers.Requests).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		requests := *requestsARM.(*RequestsBasedTriggerARM)
		result.Requests = &requests
	}

	// Set property ‘SlowRequests’:
	if triggers.SlowRequests != nil {
		slowRequestsARM, err := (*triggers.SlowRequests).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		slowRequests := *slowRequestsARM.(*SlowRequestsBasedTriggerARM)
		result.SlowRequests = &slowRequests
	}

	// Set property ‘SlowRequestsWithPath’:
	for _, item := range triggers.SlowRequestsWithPath {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.SlowRequestsWithPath = append(result.SlowRequestsWithPath, *itemARM.(*SlowRequestsBasedTriggerARM))
	}

	// Set property ‘StatusCodes’:
	for _, item := range triggers.StatusCodes {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.StatusCodes = append(result.StatusCodes, *itemARM.(*StatusCodesBasedTriggerARM))
	}

	// Set property ‘StatusCodesRange’:
	for _, item := range triggers.StatusCodesRange {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.StatusCodesRange = append(result.StatusCodesRange, *itemARM.(*StatusCodesRangeBasedTriggerARM))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (triggers *AutoHealTriggers) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AutoHealTriggersARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (triggers *AutoHealTriggers) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AutoHealTriggersARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AutoHealTriggersARM, got %T", armInput)
	}

	// Set property ‘PrivateBytesInKB’:
	if typedInput.PrivateBytesInKB != nil {
		privateBytesInKB := *typedInput.PrivateBytesInKB
		triggers.PrivateBytesInKB = &privateBytesInKB
	}

	// Set property ‘Requests’:
	if typedInput.Requests != nil {
		var requests1 RequestsBasedTrigger
		err := requests1.PopulateFromARM(owner, *typedInput.Requests)
		if err != nil {
			return err
		}
		requests := requests1
		triggers.Requests = &requests
	}

	// Set property ‘SlowRequests’:
	if typedInput.SlowRequests != nil {
		var slowRequests1 SlowRequestsBasedTrigger
		err := slowRequests1.PopulateFromARM(owner, *typedInput.SlowRequests)
		if err != nil {
			return err
		}
		slowRequests := slowRequests1
		triggers.SlowRequests = &slowRequests
	}

	// Set property ‘SlowRequestsWithPath’:
	for _, item := range typedInput.SlowRequestsWithPath {
		var item1 SlowRequestsBasedTrigger
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		triggers.SlowRequestsWithPath = append(triggers.SlowRequestsWithPath, item1)
	}

	// Set property ‘StatusCodes’:
	for _, item := range typedInput.StatusCodes {
		var item1 StatusCodesBasedTrigger
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		triggers.StatusCodes = append(triggers.StatusCodes, item1)
	}

	// Set property ‘StatusCodesRange’:
	for _, item := range typedInput.StatusCodesRange {
		var item1 StatusCodesRangeBasedTrigger
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		triggers.StatusCodesRange = append(triggers.StatusCodesRange, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromAutoHealTriggers populates our AutoHealTriggers from the provided source AutoHealTriggers
func (triggers *AutoHealTriggers) AssignPropertiesFromAutoHealTriggers(source *v20220301s.AutoHealTriggers) error {

	// PrivateBytesInKB
	triggers.PrivateBytesInKB = genruntime.ClonePointerToInt(source.PrivateBytesInKB)

	// Requests
	if source.Requests != nil {
		var request RequestsBasedTrigger
		err := request.AssignPropertiesFromRequestsBasedTrigger(source.Requests)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromRequestsBasedTrigger() to populate field Requests")
		}
		triggers.Requests = &request
	} else {
		triggers.Requests = nil
	}

	// SlowRequests
	if source.SlowRequests != nil {
		var slowRequest SlowRequestsBasedTrigger
		err := slowRequest.AssignPropertiesFromSlowRequestsBasedTrigger(source.SlowRequests)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSlowRequestsBasedTrigger() to populate field SlowRequests")
		}
		triggers.SlowRequests = &slowRequest
	} else {
		triggers.SlowRequests = nil
	}

	// SlowRequestsWithPath
	if source.SlowRequestsWithPath != nil {
		slowRequestsWithPathList := make([]SlowRequestsBasedTrigger, len(source.SlowRequestsWithPath))
		for slowRequestsWithPathIndex, slowRequestsWithPathItem := range source.SlowRequestsWithPath {
			// Shadow the loop variable to avoid aliasing
			slowRequestsWithPathItem := slowRequestsWithPathItem
			var slowRequestsWithPath SlowRequestsBasedTrigger
			err := slowRequestsWithPath.AssignPropertiesFromSlowRequestsBasedTrigger(&slowRequestsWithPathItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromSlowRequestsBasedTrigger() to populate field SlowRequestsWithPath")
			}
			slowRequestsWithPathList[slowRequestsWithPathIndex] = slowRequestsWithPath
		}
		triggers.SlowRequestsWithPath = slowRequestsWithPathList
	} else {
		triggers.SlowRequestsWithPath = nil
	}

	// StatusCodes
	if source.StatusCodes != nil {
		statusCodeList := make([]StatusCodesBasedTrigger, len(source.StatusCodes))
		for statusCodeIndex, statusCodeItem := range source.StatusCodes {
			// Shadow the loop variable to avoid aliasing
			statusCodeItem := statusCodeItem
			var statusCode StatusCodesBasedTrigger
			err := statusCode.AssignPropertiesFromStatusCodesBasedTrigger(&statusCodeItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromStatusCodesBasedTrigger() to populate field StatusCodes")
			}
			statusCodeList[statusCodeIndex] = statusCode
		}
		triggers.StatusCodes = statusCodeList
	} else {
		triggers.StatusCodes = nil
	}

	// StatusCodesRange
	if source.StatusCodesRange != nil {
		statusCodesRangeList := make([]StatusCodesRangeBasedTrigger, len(source.StatusCodesRange))
		for statusCodesRangeIndex, statusCodesRangeItem := range source.StatusCodesRange {
			// Shadow the loop variable to avoid aliasing
			statusCodesRangeItem := statusCodesRangeItem
			var statusCodesRange StatusCodesRangeBasedTrigger
			err := statusCodesRange.AssignPropertiesFromStatusCodesRangeBasedTrigger(&statusCodesRangeItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromStatusCodesRangeBasedTrigger() to populate field StatusCodesRange")
			}
			statusCodesRangeList[statusCodesRangeIndex] = statusCodesRange
		}
		triggers.StatusCodesRange = statusCodesRangeList
	} else {
		triggers.StatusCodesRange = nil
	}

	// No error
	return nil
}

// AssignPropertiesToAutoHealTriggers populates the provided destination AutoHealTriggers from our AutoHealTriggers
func (triggers *AutoHealTriggers) AssignPropertiesToAutoHealTriggers(destination *v20220301s.AutoHealTriggers) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrivateBytesInKB
	destination.PrivateBytesInKB = genruntime.ClonePointerToInt(triggers.PrivateBytesInKB)

	// Requests
	if triggers.Requests != nil {
		var request v20220301s.RequestsBasedTrigger
		err := triggers.Requests.AssignPropertiesToRequestsBasedTrigger(&request)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToRequestsBasedTrigger() to populate field Requests")
		}
		destination.Requests = &request
	} else {
		destination.Requests = nil
	}

	// SlowRequests
	if triggers.SlowRequests != nil {
		var slowRequest v20220301s.SlowRequestsBasedTrigger
		err := triggers.SlowRequests.AssignPropertiesToSlowRequestsBasedTrigger(&slowRequest)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSlowRequestsBasedTrigger() to populate field SlowRequests")
		}
		destination.SlowRequests = &slowRequest
	} else {
		destination.SlowRequests = nil
	}

	// SlowRequestsWithPath
	if triggers.SlowRequestsWithPath != nil {
		slowRequestsWithPathList := make([]v20220301s.SlowRequestsBasedTrigger, len(triggers.SlowRequestsWithPath))
		for slowRequestsWithPathIndex, slowRequestsWithPathItem := range triggers.SlowRequestsWithPath {
			// Shadow the loop variable to avoid aliasing
			slowRequestsWithPathItem := slowRequestsWithPathItem
			var slowRequestsWithPath v20220301s.SlowRequestsBasedTrigger
			err := slowRequestsWithPathItem.AssignPropertiesToSlowRequestsBasedTrigger(&slowRequestsWithPath)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToSlowRequestsBasedTrigger() to populate field SlowRequestsWithPath")
			}
			slowRequestsWithPathList[slowRequestsWithPathIndex] = slowRequestsWithPath
		}
		destination.SlowRequestsWithPath = slowRequestsWithPathList
	} else {
		destination.SlowRequestsWithPath = nil
	}

	// StatusCodes
	if triggers.StatusCodes != nil {
		statusCodeList := make([]v20220301s.StatusCodesBasedTrigger, len(triggers.StatusCodes))
		for statusCodeIndex, statusCodeItem := range triggers.StatusCodes {
			// Shadow the loop variable to avoid aliasing
			statusCodeItem := statusCodeItem
			var statusCode v20220301s.StatusCodesBasedTrigger
			err := statusCodeItem.AssignPropertiesToStatusCodesBasedTrigger(&statusCode)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToStatusCodesBasedTrigger() to populate field StatusCodes")
			}
			statusCodeList[statusCodeIndex] = statusCode
		}
		destination.StatusCodes = statusCodeList
	} else {
		destination.StatusCodes = nil
	}

	// StatusCodesRange
	if triggers.StatusCodesRange != nil {
		statusCodesRangeList := make([]v20220301s.StatusCodesRangeBasedTrigger, len(triggers.StatusCodesRange))
		for statusCodesRangeIndex, statusCodesRangeItem := range triggers.StatusCodesRange {
			// Shadow the loop variable to avoid aliasing
			statusCodesRangeItem := statusCodesRangeItem
			var statusCodesRange v20220301s.StatusCodesRangeBasedTrigger
			err := statusCodesRangeItem.AssignPropertiesToStatusCodesRangeBasedTrigger(&statusCodesRange)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToStatusCodesRangeBasedTrigger() to populate field StatusCodesRange")
			}
			statusCodesRangeList[statusCodesRangeIndex] = statusCodesRange
		}
		destination.StatusCodesRange = statusCodesRangeList
	} else {
		destination.StatusCodesRange = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AutoHealTriggers_STATUS struct {
	// PrivateBytesInKB: A rule based on private bytes.
	PrivateBytesInKB *int `json:"privateBytesInKB,omitempty"`

	// Requests: A rule based on total requests.
	Requests *RequestsBasedTrigger_STATUS `json:"requests,omitempty"`

	// SlowRequests: A rule based on request execution time.
	SlowRequests *SlowRequestsBasedTrigger_STATUS `json:"slowRequests,omitempty"`

	// SlowRequestsWithPath: A rule based on multiple Slow Requests Rule with path
	SlowRequestsWithPath []SlowRequestsBasedTrigger_STATUS `json:"slowRequestsWithPath,omitempty"`

	// StatusCodes: A rule based on status codes.
	StatusCodes []StatusCodesBasedTrigger_STATUS `json:"statusCodes,omitempty"`

	// StatusCodesRange: A rule based on status codes ranges.
	StatusCodesRange []StatusCodesRangeBasedTrigger_STATUS `json:"statusCodesRange,omitempty"`
}

var _ genruntime.FromARMConverter = &AutoHealTriggers_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (triggers *AutoHealTriggers_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AutoHealTriggers_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (triggers *AutoHealTriggers_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AutoHealTriggers_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AutoHealTriggers_STATUSARM, got %T", armInput)
	}

	// Set property ‘PrivateBytesInKB’:
	if typedInput.PrivateBytesInKB != nil {
		privateBytesInKB := *typedInput.PrivateBytesInKB
		triggers.PrivateBytesInKB = &privateBytesInKB
	}

	// Set property ‘Requests’:
	if typedInput.Requests != nil {
		var requests1 RequestsBasedTrigger_STATUS
		err := requests1.PopulateFromARM(owner, *typedInput.Requests)
		if err != nil {
			return err
		}
		requests := requests1
		triggers.Requests = &requests
	}

	// Set property ‘SlowRequests’:
	if typedInput.SlowRequests != nil {
		var slowRequests1 SlowRequestsBasedTrigger_STATUS
		err := slowRequests1.PopulateFromARM(owner, *typedInput.SlowRequests)
		if err != nil {
			return err
		}
		slowRequests := slowRequests1
		triggers.SlowRequests = &slowRequests
	}

	// Set property ‘SlowRequestsWithPath’:
	for _, item := range typedInput.SlowRequestsWithPath {
		var item1 SlowRequestsBasedTrigger_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		triggers.SlowRequestsWithPath = append(triggers.SlowRequestsWithPath, item1)
	}

	// Set property ‘StatusCodes’:
	for _, item := range typedInput.StatusCodes {
		var item1 StatusCodesBasedTrigger_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		triggers.StatusCodes = append(triggers.StatusCodes, item1)
	}

	// Set property ‘StatusCodesRange’:
	for _, item := range typedInput.StatusCodesRange {
		var item1 StatusCodesRangeBasedTrigger_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		triggers.StatusCodesRange = append(triggers.StatusCodesRange, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromAutoHealTriggersSTATUS populates our AutoHealTriggers_STATUS from the provided source AutoHealTriggers_STATUS
func (triggers *AutoHealTriggers_STATUS) AssignPropertiesFromAutoHealTriggersSTATUS(source *v20220301s.AutoHealTriggers_STATUS) error {

	// PrivateBytesInKB
	triggers.PrivateBytesInKB = genruntime.ClonePointerToInt(source.PrivateBytesInKB)

	// Requests
	if source.Requests != nil {
		var request RequestsBasedTrigger_STATUS
		err := request.AssignPropertiesFromRequestsBasedTriggerSTATUS(source.Requests)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromRequestsBasedTriggerSTATUS() to populate field Requests")
		}
		triggers.Requests = &request
	} else {
		triggers.Requests = nil
	}

	// SlowRequests
	if source.SlowRequests != nil {
		var slowRequest SlowRequestsBasedTrigger_STATUS
		err := slowRequest.AssignPropertiesFromSlowRequestsBasedTriggerSTATUS(source.SlowRequests)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSlowRequestsBasedTriggerSTATUS() to populate field SlowRequests")
		}
		triggers.SlowRequests = &slowRequest
	} else {
		triggers.SlowRequests = nil
	}

	// SlowRequestsWithPath
	if source.SlowRequestsWithPath != nil {
		slowRequestsWithPathList := make([]SlowRequestsBasedTrigger_STATUS, len(source.SlowRequestsWithPath))
		for slowRequestsWithPathIndex, slowRequestsWithPathItem := range source.SlowRequestsWithPath {
			// Shadow the loop variable to avoid aliasing
			slowRequestsWithPathItem := slowRequestsWithPathItem
			var slowRequestsWithPath SlowRequestsBasedTrigger_STATUS
			err := slowRequestsWithPath.AssignPropertiesFromSlowRequestsBasedTriggerSTATUS(&slowRequestsWithPathItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromSlowRequestsBasedTriggerSTATUS() to populate field SlowRequestsWithPath")
			}
			slowRequestsWithPathList[slowRequestsWithPathIndex] = slowRequestsWithPath
		}
		triggers.SlowRequestsWithPath = slowRequestsWithPathList
	} else {
		triggers.SlowRequestsWithPath = nil
	}

	// StatusCodes
	if source.StatusCodes != nil {
		statusCodeList := make([]StatusCodesBasedTrigger_STATUS, len(source.StatusCodes))
		for statusCodeIndex, statusCodeItem := range source.StatusCodes {
			// Shadow the loop variable to avoid aliasing
			statusCodeItem := statusCodeItem
			var statusCode StatusCodesBasedTrigger_STATUS
			err := statusCode.AssignPropertiesFromStatusCodesBasedTriggerSTATUS(&statusCodeItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromStatusCodesBasedTriggerSTATUS() to populate field StatusCodes")
			}
			statusCodeList[statusCodeIndex] = statusCode
		}
		triggers.StatusCodes = statusCodeList
	} else {
		triggers.StatusCodes = nil
	}

	// StatusCodesRange
	if source.StatusCodesRange != nil {
		statusCodesRangeList := make([]StatusCodesRangeBasedTrigger_STATUS, len(source.StatusCodesRange))
		for statusCodesRangeIndex, statusCodesRangeItem := range source.StatusCodesRange {
			// Shadow the loop variable to avoid aliasing
			statusCodesRangeItem := statusCodesRangeItem
			var statusCodesRange StatusCodesRangeBasedTrigger_STATUS
			err := statusCodesRange.AssignPropertiesFromStatusCodesRangeBasedTriggerSTATUS(&statusCodesRangeItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromStatusCodesRangeBasedTriggerSTATUS() to populate field StatusCodesRange")
			}
			statusCodesRangeList[statusCodesRangeIndex] = statusCodesRange
		}
		triggers.StatusCodesRange = statusCodesRangeList
	} else {
		triggers.StatusCodesRange = nil
	}

	// No error
	return nil
}

// AssignPropertiesToAutoHealTriggersSTATUS populates the provided destination AutoHealTriggers_STATUS from our AutoHealTriggers_STATUS
func (triggers *AutoHealTriggers_STATUS) AssignPropertiesToAutoHealTriggersSTATUS(destination *v20220301s.AutoHealTriggers_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrivateBytesInKB
	destination.PrivateBytesInKB = genruntime.ClonePointerToInt(triggers.PrivateBytesInKB)

	// Requests
	if triggers.Requests != nil {
		var request v20220301s.RequestsBasedTrigger_STATUS
		err := triggers.Requests.AssignPropertiesToRequestsBasedTriggerSTATUS(&request)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToRequestsBasedTriggerSTATUS() to populate field Requests")
		}
		destination.Requests = &request
	} else {
		destination.Requests = nil
	}

	// SlowRequests
	if triggers.SlowRequests != nil {
		var slowRequest v20220301s.SlowRequestsBasedTrigger_STATUS
		err := triggers.SlowRequests.AssignPropertiesToSlowRequestsBasedTriggerSTATUS(&slowRequest)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSlowRequestsBasedTriggerSTATUS() to populate field SlowRequests")
		}
		destination.SlowRequests = &slowRequest
	} else {
		destination.SlowRequests = nil
	}

	// SlowRequestsWithPath
	if triggers.SlowRequestsWithPath != nil {
		slowRequestsWithPathList := make([]v20220301s.SlowRequestsBasedTrigger_STATUS, len(triggers.SlowRequestsWithPath))
		for slowRequestsWithPathIndex, slowRequestsWithPathItem := range triggers.SlowRequestsWithPath {
			// Shadow the loop variable to avoid aliasing
			slowRequestsWithPathItem := slowRequestsWithPathItem
			var slowRequestsWithPath v20220301s.SlowRequestsBasedTrigger_STATUS
			err := slowRequestsWithPathItem.AssignPropertiesToSlowRequestsBasedTriggerSTATUS(&slowRequestsWithPath)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToSlowRequestsBasedTriggerSTATUS() to populate field SlowRequestsWithPath")
			}
			slowRequestsWithPathList[slowRequestsWithPathIndex] = slowRequestsWithPath
		}
		destination.SlowRequestsWithPath = slowRequestsWithPathList
	} else {
		destination.SlowRequestsWithPath = nil
	}

	// StatusCodes
	if triggers.StatusCodes != nil {
		statusCodeList := make([]v20220301s.StatusCodesBasedTrigger_STATUS, len(triggers.StatusCodes))
		for statusCodeIndex, statusCodeItem := range triggers.StatusCodes {
			// Shadow the loop variable to avoid aliasing
			statusCodeItem := statusCodeItem
			var statusCode v20220301s.StatusCodesBasedTrigger_STATUS
			err := statusCodeItem.AssignPropertiesToStatusCodesBasedTriggerSTATUS(&statusCode)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToStatusCodesBasedTriggerSTATUS() to populate field StatusCodes")
			}
			statusCodeList[statusCodeIndex] = statusCode
		}
		destination.StatusCodes = statusCodeList
	} else {
		destination.StatusCodes = nil
	}

	// StatusCodesRange
	if triggers.StatusCodesRange != nil {
		statusCodesRangeList := make([]v20220301s.StatusCodesRangeBasedTrigger_STATUS, len(triggers.StatusCodesRange))
		for statusCodesRangeIndex, statusCodesRangeItem := range triggers.StatusCodesRange {
			// Shadow the loop variable to avoid aliasing
			statusCodesRangeItem := statusCodesRangeItem
			var statusCodesRange v20220301s.StatusCodesRangeBasedTrigger_STATUS
			err := statusCodesRangeItem.AssignPropertiesToStatusCodesRangeBasedTriggerSTATUS(&statusCodesRange)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToStatusCodesRangeBasedTriggerSTATUS() to populate field StatusCodesRange")
			}
			statusCodesRangeList[statusCodesRangeIndex] = statusCodesRange
		}
		destination.StatusCodesRange = statusCodesRangeList
	} else {
		destination.StatusCodesRange = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AzureStorageInfoValueSTATUSState string

const (
	AzureStorageInfoValueSTATUSState_InvalidCredentials = AzureStorageInfoValueSTATUSState("InvalidCredentials")
	AzureStorageInfoValueSTATUSState_InvalidShare       = AzureStorageInfoValueSTATUSState("InvalidShare")
	AzureStorageInfoValueSTATUSState_NotValidated       = AzureStorageInfoValueSTATUSState("NotValidated")
	AzureStorageInfoValueSTATUSState_Ok                 = AzureStorageInfoValueSTATUSState("Ok")
)

type AzureStorageInfoValueSTATUSType string

const (
	AzureStorageInfoValueSTATUSType_AzureBlob  = AzureStorageInfoValueSTATUSType("AzureBlob")
	AzureStorageInfoValueSTATUSType_AzureFiles = AzureStorageInfoValueSTATUSType("AzureFiles")
)

type ConnStringInfoSTATUSType string

const (
	ConnStringInfoSTATUSType_ApiHub          = ConnStringInfoSTATUSType("ApiHub")
	ConnStringInfoSTATUSType_Custom          = ConnStringInfoSTATUSType("Custom")
	ConnStringInfoSTATUSType_DocDb           = ConnStringInfoSTATUSType("DocDb")
	ConnStringInfoSTATUSType_EventHub        = ConnStringInfoSTATUSType("EventHub")
	ConnStringInfoSTATUSType_MySql           = ConnStringInfoSTATUSType("MySql")
	ConnStringInfoSTATUSType_NotificationHub = ConnStringInfoSTATUSType("NotificationHub")
	ConnStringInfoSTATUSType_PostgreSQL      = ConnStringInfoSTATUSType("PostgreSQL")
	ConnStringInfoSTATUSType_RedisCache      = ConnStringInfoSTATUSType("RedisCache")
	ConnStringInfoSTATUSType_SQLAzure        = ConnStringInfoSTATUSType("SQLAzure")
	ConnStringInfoSTATUSType_SQLServer       = ConnStringInfoSTATUSType("SQLServer")
	ConnStringInfoSTATUSType_ServiceBus      = ConnStringInfoSTATUSType("ServiceBus")
)

// +kubebuilder:validation:Enum={"ApiHub","Custom","DocDb","EventHub","MySql","NotificationHub","PostgreSQL","RedisCache","SQLAzure","SQLServer","ServiceBus"}
type ConnStringInfoType string

const (
	ConnStringInfoType_ApiHub          = ConnStringInfoType("ApiHub")
	ConnStringInfoType_Custom          = ConnStringInfoType("Custom")
	ConnStringInfoType_DocDb           = ConnStringInfoType("DocDb")
	ConnStringInfoType_EventHub        = ConnStringInfoType("EventHub")
	ConnStringInfoType_MySql           = ConnStringInfoType("MySql")
	ConnStringInfoType_NotificationHub = ConnStringInfoType("NotificationHub")
	ConnStringInfoType_PostgreSQL      = ConnStringInfoType("PostgreSQL")
	ConnStringInfoType_RedisCache      = ConnStringInfoType("RedisCache")
	ConnStringInfoType_SQLAzure        = ConnStringInfoType("SQLAzure")
	ConnStringInfoType_SQLServer       = ConnStringInfoType("SQLServer")
	ConnStringInfoType_ServiceBus      = ConnStringInfoType("ServiceBus")
)

type IpSecurityRestrictionSTATUSTag string

const (
	IpSecurityRestrictionSTATUSTag_Default    = IpSecurityRestrictionSTATUSTag("Default")
	IpSecurityRestrictionSTATUSTag_ServiceTag = IpSecurityRestrictionSTATUSTag("ServiceTag")
	IpSecurityRestrictionSTATUSTag_XffProxy   = IpSecurityRestrictionSTATUSTag("XffProxy")
)

// +kubebuilder:validation:Enum={"Default","ServiceTag","XffProxy"}
type IpSecurityRestrictionTag string

const (
	IpSecurityRestrictionTag_Default    = IpSecurityRestrictionTag("Default")
	IpSecurityRestrictionTag_ServiceTag = IpSecurityRestrictionTag("ServiceTag")
	IpSecurityRestrictionTag_XffProxy   = IpSecurityRestrictionTag("XffProxy")
)

// Generated from: https://schema.management.azure.com/schemas/2022-03-01/Microsoft.Web.json#/definitions/RampUpRule
type RampUpRule struct {
	// ActionHostName: Hostname of a slot to which the traffic will be redirected if decided to. E.g.
	// myapp-stage.azurewebsites.net.
	ActionHostName *string `json:"actionHostName,omitempty"`

	// ChangeDecisionCallbackUrl: Custom decision algorithm can be provided in TiPCallback site extension which URL can be
	// specified. See TiPCallback site extension for the scaffold and contracts.
	// https://www.siteextensions.net/packages/TiPCallback/
	ChangeDecisionCallbackUrl *string `json:"changeDecisionCallbackUrl,omitempty"`

	// ChangeIntervalInMinutes: Specifies interval in minutes to reevaluate ReroutePercentage.
	ChangeIntervalInMinutes *int `json:"changeIntervalInMinutes,omitempty"`

	// ChangeStep: In auto ramp up scenario this is the step to add/remove from <code>ReroutePercentage</code> until it reaches
	// \n<code>MinReroutePercentage</code> or
	// <code>MaxReroutePercentage</code>. Site metrics are checked every N minutes specified in
	// <code>ChangeIntervalInMinutes</code>.\nCustom decision algorithm
	// can be provided in TiPCallback site extension which URL can be specified in <code>ChangeDecisionCallbackUrl</code>.
	ChangeStep *float64 `json:"changeStep,omitempty"`

	// MaxReroutePercentage: Specifies upper boundary below which ReroutePercentage will stay.
	MaxReroutePercentage *float64 `json:"maxReroutePercentage,omitempty"`

	// MinReroutePercentage: Specifies lower boundary above which ReroutePercentage will stay.
	MinReroutePercentage *float64 `json:"minReroutePercentage,omitempty"`

	// Name: Name of the routing rule. The recommended name would be to point to the slot which will receive the traffic in the
	// experiment.
	Name *string `json:"name,omitempty"`

	// ReroutePercentage: Percentage of the traffic which will be redirected to <code>ActionHostName</code>.
	ReroutePercentage *float64 `json:"reroutePercentage,omitempty"`
}

var _ genruntime.ARMTransformer = &RampUpRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *RampUpRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &RampUpRuleARM{}

	// Set property ‘ActionHostName’:
	if rule.ActionHostName != nil {
		actionHostName := *rule.ActionHostName
		result.ActionHostName = &actionHostName
	}

	// Set property ‘ChangeDecisionCallbackUrl’:
	if rule.ChangeDecisionCallbackUrl != nil {
		changeDecisionCallbackUrl := *rule.ChangeDecisionCallbackUrl
		result.ChangeDecisionCallbackUrl = &changeDecisionCallbackUrl
	}

	// Set property ‘ChangeIntervalInMinutes’:
	if rule.ChangeIntervalInMinutes != nil {
		changeIntervalInMinutes := *rule.ChangeIntervalInMinutes
		result.ChangeIntervalInMinutes = &changeIntervalInMinutes
	}

	// Set property ‘ChangeStep’:
	if rule.ChangeStep != nil {
		changeStep := *rule.ChangeStep
		result.ChangeStep = &changeStep
	}

	// Set property ‘MaxReroutePercentage’:
	if rule.MaxReroutePercentage != nil {
		maxReroutePercentage := *rule.MaxReroutePercentage
		result.MaxReroutePercentage = &maxReroutePercentage
	}

	// Set property ‘MinReroutePercentage’:
	if rule.MinReroutePercentage != nil {
		minReroutePercentage := *rule.MinReroutePercentage
		result.MinReroutePercentage = &minReroutePercentage
	}

	// Set property ‘Name’:
	if rule.Name != nil {
		name := *rule.Name
		result.Name = &name
	}

	// Set property ‘ReroutePercentage’:
	if rule.ReroutePercentage != nil {
		reroutePercentage := *rule.ReroutePercentage
		result.ReroutePercentage = &reroutePercentage
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *RampUpRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &RampUpRuleARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *RampUpRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(RampUpRuleARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected RampUpRuleARM, got %T", armInput)
	}

	// Set property ‘ActionHostName’:
	if typedInput.ActionHostName != nil {
		actionHostName := *typedInput.ActionHostName
		rule.ActionHostName = &actionHostName
	}

	// Set property ‘ChangeDecisionCallbackUrl’:
	if typedInput.ChangeDecisionCallbackUrl != nil {
		changeDecisionCallbackUrl := *typedInput.ChangeDecisionCallbackUrl
		rule.ChangeDecisionCallbackUrl = &changeDecisionCallbackUrl
	}

	// Set property ‘ChangeIntervalInMinutes’:
	if typedInput.ChangeIntervalInMinutes != nil {
		changeIntervalInMinutes := *typedInput.ChangeIntervalInMinutes
		rule.ChangeIntervalInMinutes = &changeIntervalInMinutes
	}

	// Set property ‘ChangeStep’:
	if typedInput.ChangeStep != nil {
		changeStep := *typedInput.ChangeStep
		rule.ChangeStep = &changeStep
	}

	// Set property ‘MaxReroutePercentage’:
	if typedInput.MaxReroutePercentage != nil {
		maxReroutePercentage := *typedInput.MaxReroutePercentage
		rule.MaxReroutePercentage = &maxReroutePercentage
	}

	// Set property ‘MinReroutePercentage’:
	if typedInput.MinReroutePercentage != nil {
		minReroutePercentage := *typedInput.MinReroutePercentage
		rule.MinReroutePercentage = &minReroutePercentage
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property ‘ReroutePercentage’:
	if typedInput.ReroutePercentage != nil {
		reroutePercentage := *typedInput.ReroutePercentage
		rule.ReroutePercentage = &reroutePercentage
	}

	// No error
	return nil
}

// AssignPropertiesFromRampUpRule populates our RampUpRule from the provided source RampUpRule
func (rule *RampUpRule) AssignPropertiesFromRampUpRule(source *v20220301s.RampUpRule) error {

	// ActionHostName
	rule.ActionHostName = genruntime.ClonePointerToString(source.ActionHostName)

	// ChangeDecisionCallbackUrl
	rule.ChangeDecisionCallbackUrl = genruntime.ClonePointerToString(source.ChangeDecisionCallbackUrl)

	// ChangeIntervalInMinutes
	rule.ChangeIntervalInMinutes = genruntime.ClonePointerToInt(source.ChangeIntervalInMinutes)

	// ChangeStep
	if source.ChangeStep != nil {
		changeStep := *source.ChangeStep
		rule.ChangeStep = &changeStep
	} else {
		rule.ChangeStep = nil
	}

	// MaxReroutePercentage
	if source.MaxReroutePercentage != nil {
		maxReroutePercentage := *source.MaxReroutePercentage
		rule.MaxReroutePercentage = &maxReroutePercentage
	} else {
		rule.MaxReroutePercentage = nil
	}

	// MinReroutePercentage
	if source.MinReroutePercentage != nil {
		minReroutePercentage := *source.MinReroutePercentage
		rule.MinReroutePercentage = &minReroutePercentage
	} else {
		rule.MinReroutePercentage = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// ReroutePercentage
	if source.ReroutePercentage != nil {
		reroutePercentage := *source.ReroutePercentage
		rule.ReroutePercentage = &reroutePercentage
	} else {
		rule.ReroutePercentage = nil
	}

	// No error
	return nil
}

// AssignPropertiesToRampUpRule populates the provided destination RampUpRule from our RampUpRule
func (rule *RampUpRule) AssignPropertiesToRampUpRule(destination *v20220301s.RampUpRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ActionHostName
	destination.ActionHostName = genruntime.ClonePointerToString(rule.ActionHostName)

	// ChangeDecisionCallbackUrl
	destination.ChangeDecisionCallbackUrl = genruntime.ClonePointerToString(rule.ChangeDecisionCallbackUrl)

	// ChangeIntervalInMinutes
	destination.ChangeIntervalInMinutes = genruntime.ClonePointerToInt(rule.ChangeIntervalInMinutes)

	// ChangeStep
	if rule.ChangeStep != nil {
		changeStep := *rule.ChangeStep
		destination.ChangeStep = &changeStep
	} else {
		destination.ChangeStep = nil
	}

	// MaxReroutePercentage
	if rule.MaxReroutePercentage != nil {
		maxReroutePercentage := *rule.MaxReroutePercentage
		destination.MaxReroutePercentage = &maxReroutePercentage
	} else {
		destination.MaxReroutePercentage = nil
	}

	// MinReroutePercentage
	if rule.MinReroutePercentage != nil {
		minReroutePercentage := *rule.MinReroutePercentage
		destination.MinReroutePercentage = &minReroutePercentage
	} else {
		destination.MinReroutePercentage = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// ReroutePercentage
	if rule.ReroutePercentage != nil {
		reroutePercentage := *rule.ReroutePercentage
		destination.ReroutePercentage = &reroutePercentage
	} else {
		destination.ReroutePercentage = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type RampUpRule_STATUS struct {
	// ActionHostName: Hostname of a slot to which the traffic will be redirected if decided to. E.g.
	// myapp-stage.azurewebsites.net.
	ActionHostName *string `json:"actionHostName,omitempty"`

	// ChangeDecisionCallbackUrl: Custom decision algorithm can be provided in TiPCallback site extension which URL can be
	// specified. See TiPCallback site extension for the scaffold and contracts.
	// https://www.siteextensions.net/packages/TiPCallback/
	ChangeDecisionCallbackUrl *string `json:"changeDecisionCallbackUrl,omitempty"`

	// ChangeIntervalInMinutes: Specifies interval in minutes to reevaluate ReroutePercentage.
	ChangeIntervalInMinutes *int `json:"changeIntervalInMinutes,omitempty"`

	// ChangeStep: In auto ramp up scenario this is the step to add/remove from <code>ReroutePercentage</code> until it reaches
	// \n<code>MinReroutePercentage</code> or
	// <code>MaxReroutePercentage</code>. Site metrics are checked every N minutes specified in
	// <code>ChangeIntervalInMinutes</code>.\nCustom decision algorithm
	// can be provided in TiPCallback site extension which URL can be specified in <code>ChangeDecisionCallbackUrl</code>.
	ChangeStep *float64 `json:"changeStep,omitempty"`

	// MaxReroutePercentage: Specifies upper boundary below which ReroutePercentage will stay.
	MaxReroutePercentage *float64 `json:"maxReroutePercentage,omitempty"`

	// MinReroutePercentage: Specifies lower boundary above which ReroutePercentage will stay.
	MinReroutePercentage *float64 `json:"minReroutePercentage,omitempty"`

	// Name: Name of the routing rule. The recommended name would be to point to the slot which will receive the traffic in the
	// experiment.
	Name *string `json:"name,omitempty"`

	// ReroutePercentage: Percentage of the traffic which will be redirected to <code>ActionHostName</code>.
	ReroutePercentage *float64 `json:"reroutePercentage,omitempty"`
}

var _ genruntime.FromARMConverter = &RampUpRule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *RampUpRule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &RampUpRule_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *RampUpRule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(RampUpRule_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected RampUpRule_STATUSARM, got %T", armInput)
	}

	// Set property ‘ActionHostName’:
	if typedInput.ActionHostName != nil {
		actionHostName := *typedInput.ActionHostName
		rule.ActionHostName = &actionHostName
	}

	// Set property ‘ChangeDecisionCallbackUrl’:
	if typedInput.ChangeDecisionCallbackUrl != nil {
		changeDecisionCallbackUrl := *typedInput.ChangeDecisionCallbackUrl
		rule.ChangeDecisionCallbackUrl = &changeDecisionCallbackUrl
	}

	// Set property ‘ChangeIntervalInMinutes’:
	if typedInput.ChangeIntervalInMinutes != nil {
		changeIntervalInMinutes := *typedInput.ChangeIntervalInMinutes
		rule.ChangeIntervalInMinutes = &changeIntervalInMinutes
	}

	// Set property ‘ChangeStep’:
	if typedInput.ChangeStep != nil {
		changeStep := *typedInput.ChangeStep
		rule.ChangeStep = &changeStep
	}

	// Set property ‘MaxReroutePercentage’:
	if typedInput.MaxReroutePercentage != nil {
		maxReroutePercentage := *typedInput.MaxReroutePercentage
		rule.MaxReroutePercentage = &maxReroutePercentage
	}

	// Set property ‘MinReroutePercentage’:
	if typedInput.MinReroutePercentage != nil {
		minReroutePercentage := *typedInput.MinReroutePercentage
		rule.MinReroutePercentage = &minReroutePercentage
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property ‘ReroutePercentage’:
	if typedInput.ReroutePercentage != nil {
		reroutePercentage := *typedInput.ReroutePercentage
		rule.ReroutePercentage = &reroutePercentage
	}

	// No error
	return nil
}

// AssignPropertiesFromRampUpRuleSTATUS populates our RampUpRule_STATUS from the provided source RampUpRule_STATUS
func (rule *RampUpRule_STATUS) AssignPropertiesFromRampUpRuleSTATUS(source *v20220301s.RampUpRule_STATUS) error {

	// ActionHostName
	rule.ActionHostName = genruntime.ClonePointerToString(source.ActionHostName)

	// ChangeDecisionCallbackUrl
	rule.ChangeDecisionCallbackUrl = genruntime.ClonePointerToString(source.ChangeDecisionCallbackUrl)

	// ChangeIntervalInMinutes
	rule.ChangeIntervalInMinutes = genruntime.ClonePointerToInt(source.ChangeIntervalInMinutes)

	// ChangeStep
	if source.ChangeStep != nil {
		changeStep := *source.ChangeStep
		rule.ChangeStep = &changeStep
	} else {
		rule.ChangeStep = nil
	}

	// MaxReroutePercentage
	if source.MaxReroutePercentage != nil {
		maxReroutePercentage := *source.MaxReroutePercentage
		rule.MaxReroutePercentage = &maxReroutePercentage
	} else {
		rule.MaxReroutePercentage = nil
	}

	// MinReroutePercentage
	if source.MinReroutePercentage != nil {
		minReroutePercentage := *source.MinReroutePercentage
		rule.MinReroutePercentage = &minReroutePercentage
	} else {
		rule.MinReroutePercentage = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// ReroutePercentage
	if source.ReroutePercentage != nil {
		reroutePercentage := *source.ReroutePercentage
		rule.ReroutePercentage = &reroutePercentage
	} else {
		rule.ReroutePercentage = nil
	}

	// No error
	return nil
}

// AssignPropertiesToRampUpRuleSTATUS populates the provided destination RampUpRule_STATUS from our RampUpRule_STATUS
func (rule *RampUpRule_STATUS) AssignPropertiesToRampUpRuleSTATUS(destination *v20220301s.RampUpRule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ActionHostName
	destination.ActionHostName = genruntime.ClonePointerToString(rule.ActionHostName)

	// ChangeDecisionCallbackUrl
	destination.ChangeDecisionCallbackUrl = genruntime.ClonePointerToString(rule.ChangeDecisionCallbackUrl)

	// ChangeIntervalInMinutes
	destination.ChangeIntervalInMinutes = genruntime.ClonePointerToInt(rule.ChangeIntervalInMinutes)

	// ChangeStep
	if rule.ChangeStep != nil {
		changeStep := *rule.ChangeStep
		destination.ChangeStep = &changeStep
	} else {
		destination.ChangeStep = nil
	}

	// MaxReroutePercentage
	if rule.MaxReroutePercentage != nil {
		maxReroutePercentage := *rule.MaxReroutePercentage
		destination.MaxReroutePercentage = &maxReroutePercentage
	} else {
		destination.MaxReroutePercentage = nil
	}

	// MinReroutePercentage
	if rule.MinReroutePercentage != nil {
		minReroutePercentage := *rule.MinReroutePercentage
		destination.MinReroutePercentage = &minReroutePercentage
	} else {
		destination.MinReroutePercentage = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// ReroutePercentage
	if rule.ReroutePercentage != nil {
		reroutePercentage := *rule.ReroutePercentage
		destination.ReroutePercentage = &reroutePercentage
	} else {
		destination.ReroutePercentage = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"AzureBlob","AzureFiles"}
type SitesSpecPropertiesSiteConfigAzureStorageAccountsType string

const (
	SitesSpecPropertiesSiteConfigAzureStorageAccountsType_AzureBlob  = SitesSpecPropertiesSiteConfigAzureStorageAccountsType("AzureBlob")
	SitesSpecPropertiesSiteConfigAzureStorageAccountsType_AzureFiles = SitesSpecPropertiesSiteConfigAzureStorageAccountsType("AzureFiles")
)

// Generated from: https://schema.management.azure.com/schemas/2022-03-01/Microsoft.Web.json#/definitions/VirtualDirectory
type VirtualDirectory struct {
	// PhysicalPath: Physical path.
	PhysicalPath *string `json:"physicalPath,omitempty"`

	// VirtualPath: Path to virtual application.
	VirtualPath *string `json:"virtualPath,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualDirectory{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (directory *VirtualDirectory) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if directory == nil {
		return nil, nil
	}
	result := &VirtualDirectoryARM{}

	// Set property ‘PhysicalPath’:
	if directory.PhysicalPath != nil {
		physicalPath := *directory.PhysicalPath
		result.PhysicalPath = &physicalPath
	}

	// Set property ‘VirtualPath’:
	if directory.VirtualPath != nil {
		virtualPath := *directory.VirtualPath
		result.VirtualPath = &virtualPath
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (directory *VirtualDirectory) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualDirectoryARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (directory *VirtualDirectory) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualDirectoryARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualDirectoryARM, got %T", armInput)
	}

	// Set property ‘PhysicalPath’:
	if typedInput.PhysicalPath != nil {
		physicalPath := *typedInput.PhysicalPath
		directory.PhysicalPath = &physicalPath
	}

	// Set property ‘VirtualPath’:
	if typedInput.VirtualPath != nil {
		virtualPath := *typedInput.VirtualPath
		directory.VirtualPath = &virtualPath
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualDirectory populates our VirtualDirectory from the provided source VirtualDirectory
func (directory *VirtualDirectory) AssignPropertiesFromVirtualDirectory(source *v20220301s.VirtualDirectory) error {

	// PhysicalPath
	directory.PhysicalPath = genruntime.ClonePointerToString(source.PhysicalPath)

	// VirtualPath
	directory.VirtualPath = genruntime.ClonePointerToString(source.VirtualPath)

	// No error
	return nil
}

// AssignPropertiesToVirtualDirectory populates the provided destination VirtualDirectory from our VirtualDirectory
func (directory *VirtualDirectory) AssignPropertiesToVirtualDirectory(destination *v20220301s.VirtualDirectory) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PhysicalPath
	destination.PhysicalPath = genruntime.ClonePointerToString(directory.PhysicalPath)

	// VirtualPath
	destination.VirtualPath = genruntime.ClonePointerToString(directory.VirtualPath)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualDirectory_STATUS struct {
	// PhysicalPath: Physical path.
	PhysicalPath *string `json:"physicalPath,omitempty"`

	// VirtualPath: Path to virtual application.
	VirtualPath *string `json:"virtualPath,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualDirectory_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (directory *VirtualDirectory_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualDirectory_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (directory *VirtualDirectory_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualDirectory_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualDirectory_STATUSARM, got %T", armInput)
	}

	// Set property ‘PhysicalPath’:
	if typedInput.PhysicalPath != nil {
		physicalPath := *typedInput.PhysicalPath
		directory.PhysicalPath = &physicalPath
	}

	// Set property ‘VirtualPath’:
	if typedInput.VirtualPath != nil {
		virtualPath := *typedInput.VirtualPath
		directory.VirtualPath = &virtualPath
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualDirectorySTATUS populates our VirtualDirectory_STATUS from the provided source VirtualDirectory_STATUS
func (directory *VirtualDirectory_STATUS) AssignPropertiesFromVirtualDirectorySTATUS(source *v20220301s.VirtualDirectory_STATUS) error {

	// PhysicalPath
	directory.PhysicalPath = genruntime.ClonePointerToString(source.PhysicalPath)

	// VirtualPath
	directory.VirtualPath = genruntime.ClonePointerToString(source.VirtualPath)

	// No error
	return nil
}

// AssignPropertiesToVirtualDirectorySTATUS populates the provided destination VirtualDirectory_STATUS from our VirtualDirectory_STATUS
func (directory *VirtualDirectory_STATUS) AssignPropertiesToVirtualDirectorySTATUS(destination *v20220301s.VirtualDirectory_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PhysicalPath
	destination.PhysicalPath = genruntime.ClonePointerToString(directory.PhysicalPath)

	// VirtualPath
	destination.VirtualPath = genruntime.ClonePointerToString(directory.VirtualPath)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"CustomAction","LogEvent","Recycle"}
type AutoHealActionsActionType string

const (
	AutoHealActionsActionType_CustomAction = AutoHealActionsActionType("CustomAction")
	AutoHealActionsActionType_LogEvent     = AutoHealActionsActionType("LogEvent")
	AutoHealActionsActionType_Recycle      = AutoHealActionsActionType("Recycle")
)

type AutoHealActionsSTATUSActionType string

const (
	AutoHealActionsSTATUSActionType_CustomAction = AutoHealActionsSTATUSActionType("CustomAction")
	AutoHealActionsSTATUSActionType_LogEvent     = AutoHealActionsSTATUSActionType("LogEvent")
	AutoHealActionsSTATUSActionType_Recycle      = AutoHealActionsSTATUSActionType("Recycle")
)

// Generated from: https://schema.management.azure.com/schemas/2022-03-01/Microsoft.Web.json#/definitions/AutoHealCustomAction
type AutoHealCustomAction struct {
	// Exe: Executable to be run.
	Exe *string `json:"exe,omitempty"`

	// Parameters: Parameters for the executable.
	Parameters *string `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &AutoHealCustomAction{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (action *AutoHealCustomAction) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if action == nil {
		return nil, nil
	}
	result := &AutoHealCustomActionARM{}

	// Set property ‘Exe’:
	if action.Exe != nil {
		exe := *action.Exe
		result.Exe = &exe
	}

	// Set property ‘Parameters’:
	if action.Parameters != nil {
		parameters := *action.Parameters
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *AutoHealCustomAction) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AutoHealCustomActionARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *AutoHealCustomAction) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AutoHealCustomActionARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AutoHealCustomActionARM, got %T", armInput)
	}

	// Set property ‘Exe’:
	if typedInput.Exe != nil {
		exe := *typedInput.Exe
		action.Exe = &exe
	}

	// Set property ‘Parameters’:
	if typedInput.Parameters != nil {
		parameters := *typedInput.Parameters
		action.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignPropertiesFromAutoHealCustomAction populates our AutoHealCustomAction from the provided source AutoHealCustomAction
func (action *AutoHealCustomAction) AssignPropertiesFromAutoHealCustomAction(source *v20220301s.AutoHealCustomAction) error {

	// Exe
	action.Exe = genruntime.ClonePointerToString(source.Exe)

	// Parameters
	action.Parameters = genruntime.ClonePointerToString(source.Parameters)

	// No error
	return nil
}

// AssignPropertiesToAutoHealCustomAction populates the provided destination AutoHealCustomAction from our AutoHealCustomAction
func (action *AutoHealCustomAction) AssignPropertiesToAutoHealCustomAction(destination *v20220301s.AutoHealCustomAction) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Exe
	destination.Exe = genruntime.ClonePointerToString(action.Exe)

	// Parameters
	destination.Parameters = genruntime.ClonePointerToString(action.Parameters)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AutoHealCustomAction_STATUS struct {
	// Exe: Executable to be run.
	Exe *string `json:"exe,omitempty"`

	// Parameters: Parameters for the executable.
	Parameters *string `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &AutoHealCustomAction_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *AutoHealCustomAction_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AutoHealCustomAction_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *AutoHealCustomAction_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AutoHealCustomAction_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AutoHealCustomAction_STATUSARM, got %T", armInput)
	}

	// Set property ‘Exe’:
	if typedInput.Exe != nil {
		exe := *typedInput.Exe
		action.Exe = &exe
	}

	// Set property ‘Parameters’:
	if typedInput.Parameters != nil {
		parameters := *typedInput.Parameters
		action.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignPropertiesFromAutoHealCustomActionSTATUS populates our AutoHealCustomAction_STATUS from the provided source AutoHealCustomAction_STATUS
func (action *AutoHealCustomAction_STATUS) AssignPropertiesFromAutoHealCustomActionSTATUS(source *v20220301s.AutoHealCustomAction_STATUS) error {

	// Exe
	action.Exe = genruntime.ClonePointerToString(source.Exe)

	// Parameters
	action.Parameters = genruntime.ClonePointerToString(source.Parameters)

	// No error
	return nil
}

// AssignPropertiesToAutoHealCustomActionSTATUS populates the provided destination AutoHealCustomAction_STATUS from our AutoHealCustomAction_STATUS
func (action *AutoHealCustomAction_STATUS) AssignPropertiesToAutoHealCustomActionSTATUS(destination *v20220301s.AutoHealCustomAction_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Exe
	destination.Exe = genruntime.ClonePointerToString(action.Exe)

	// Parameters
	destination.Parameters = genruntime.ClonePointerToString(action.Parameters)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2022-03-01/Microsoft.Web.json#/definitions/RequestsBasedTrigger
type RequestsBasedTrigger struct {
	// Count: Request Count.
	Count *int `json:"count,omitempty"`

	// TimeInterval: Time interval.
	TimeInterval *string `json:"timeInterval,omitempty"`
}

var _ genruntime.ARMTransformer = &RequestsBasedTrigger{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (trigger *RequestsBasedTrigger) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if trigger == nil {
		return nil, nil
	}
	result := &RequestsBasedTriggerARM{}

	// Set property ‘Count’:
	if trigger.Count != nil {
		count := *trigger.Count
		result.Count = &count
	}

	// Set property ‘TimeInterval’:
	if trigger.TimeInterval != nil {
		timeInterval := *trigger.TimeInterval
		result.TimeInterval = &timeInterval
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (trigger *RequestsBasedTrigger) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &RequestsBasedTriggerARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (trigger *RequestsBasedTrigger) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(RequestsBasedTriggerARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected RequestsBasedTriggerARM, got %T", armInput)
	}

	// Set property ‘Count’:
	if typedInput.Count != nil {
		count := *typedInput.Count
		trigger.Count = &count
	}

	// Set property ‘TimeInterval’:
	if typedInput.TimeInterval != nil {
		timeInterval := *typedInput.TimeInterval
		trigger.TimeInterval = &timeInterval
	}

	// No error
	return nil
}

// AssignPropertiesFromRequestsBasedTrigger populates our RequestsBasedTrigger from the provided source RequestsBasedTrigger
func (trigger *RequestsBasedTrigger) AssignPropertiesFromRequestsBasedTrigger(source *v20220301s.RequestsBasedTrigger) error {

	// Count
	trigger.Count = genruntime.ClonePointerToInt(source.Count)

	// TimeInterval
	trigger.TimeInterval = genruntime.ClonePointerToString(source.TimeInterval)

	// No error
	return nil
}

// AssignPropertiesToRequestsBasedTrigger populates the provided destination RequestsBasedTrigger from our RequestsBasedTrigger
func (trigger *RequestsBasedTrigger) AssignPropertiesToRequestsBasedTrigger(destination *v20220301s.RequestsBasedTrigger) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Count
	destination.Count = genruntime.ClonePointerToInt(trigger.Count)

	// TimeInterval
	destination.TimeInterval = genruntime.ClonePointerToString(trigger.TimeInterval)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type RequestsBasedTrigger_STATUS struct {
	// Count: Request Count.
	Count *int `json:"count,omitempty"`

	// TimeInterval: Time interval.
	TimeInterval *string `json:"timeInterval,omitempty"`
}

var _ genruntime.FromARMConverter = &RequestsBasedTrigger_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (trigger *RequestsBasedTrigger_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &RequestsBasedTrigger_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (trigger *RequestsBasedTrigger_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(RequestsBasedTrigger_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected RequestsBasedTrigger_STATUSARM, got %T", armInput)
	}

	// Set property ‘Count’:
	if typedInput.Count != nil {
		count := *typedInput.Count
		trigger.Count = &count
	}

	// Set property ‘TimeInterval’:
	if typedInput.TimeInterval != nil {
		timeInterval := *typedInput.TimeInterval
		trigger.TimeInterval = &timeInterval
	}

	// No error
	return nil
}

// AssignPropertiesFromRequestsBasedTriggerSTATUS populates our RequestsBasedTrigger_STATUS from the provided source RequestsBasedTrigger_STATUS
func (trigger *RequestsBasedTrigger_STATUS) AssignPropertiesFromRequestsBasedTriggerSTATUS(source *v20220301s.RequestsBasedTrigger_STATUS) error {

	// Count
	trigger.Count = genruntime.ClonePointerToInt(source.Count)

	// TimeInterval
	trigger.TimeInterval = genruntime.ClonePointerToString(source.TimeInterval)

	// No error
	return nil
}

// AssignPropertiesToRequestsBasedTriggerSTATUS populates the provided destination RequestsBasedTrigger_STATUS from our RequestsBasedTrigger_STATUS
func (trigger *RequestsBasedTrigger_STATUS) AssignPropertiesToRequestsBasedTriggerSTATUS(destination *v20220301s.RequestsBasedTrigger_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Count
	destination.Count = genruntime.ClonePointerToInt(trigger.Count)

	// TimeInterval
	destination.TimeInterval = genruntime.ClonePointerToString(trigger.TimeInterval)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2022-03-01/Microsoft.Web.json#/definitions/SlowRequestsBasedTrigger
type SlowRequestsBasedTrigger struct {
	// Count: Request Count.
	Count *int `json:"count,omitempty"`

	// Path: Request Path.
	Path *string `json:"path,omitempty"`

	// TimeInterval: Time interval.
	TimeInterval *string `json:"timeInterval,omitempty"`

	// TimeTaken: Time taken.
	TimeTaken *string `json:"timeTaken,omitempty"`
}

var _ genruntime.ARMTransformer = &SlowRequestsBasedTrigger{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (trigger *SlowRequestsBasedTrigger) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if trigger == nil {
		return nil, nil
	}
	result := &SlowRequestsBasedTriggerARM{}

	// Set property ‘Count’:
	if trigger.Count != nil {
		count := *trigger.Count
		result.Count = &count
	}

	// Set property ‘Path’:
	if trigger.Path != nil {
		path := *trigger.Path
		result.Path = &path
	}

	// Set property ‘TimeInterval’:
	if trigger.TimeInterval != nil {
		timeInterval := *trigger.TimeInterval
		result.TimeInterval = &timeInterval
	}

	// Set property ‘TimeTaken’:
	if trigger.TimeTaken != nil {
		timeTaken := *trigger.TimeTaken
		result.TimeTaken = &timeTaken
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (trigger *SlowRequestsBasedTrigger) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SlowRequestsBasedTriggerARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (trigger *SlowRequestsBasedTrigger) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SlowRequestsBasedTriggerARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SlowRequestsBasedTriggerARM, got %T", armInput)
	}

	// Set property ‘Count’:
	if typedInput.Count != nil {
		count := *typedInput.Count
		trigger.Count = &count
	}

	// Set property ‘Path’:
	if typedInput.Path != nil {
		path := *typedInput.Path
		trigger.Path = &path
	}

	// Set property ‘TimeInterval’:
	if typedInput.TimeInterval != nil {
		timeInterval := *typedInput.TimeInterval
		trigger.TimeInterval = &timeInterval
	}

	// Set property ‘TimeTaken’:
	if typedInput.TimeTaken != nil {
		timeTaken := *typedInput.TimeTaken
		trigger.TimeTaken = &timeTaken
	}

	// No error
	return nil
}

// AssignPropertiesFromSlowRequestsBasedTrigger populates our SlowRequestsBasedTrigger from the provided source SlowRequestsBasedTrigger
func (trigger *SlowRequestsBasedTrigger) AssignPropertiesFromSlowRequestsBasedTrigger(source *v20220301s.SlowRequestsBasedTrigger) error {

	// Count
	trigger.Count = genruntime.ClonePointerToInt(source.Count)

	// Path
	trigger.Path = genruntime.ClonePointerToString(source.Path)

	// TimeInterval
	trigger.TimeInterval = genruntime.ClonePointerToString(source.TimeInterval)

	// TimeTaken
	trigger.TimeTaken = genruntime.ClonePointerToString(source.TimeTaken)

	// No error
	return nil
}

// AssignPropertiesToSlowRequestsBasedTrigger populates the provided destination SlowRequestsBasedTrigger from our SlowRequestsBasedTrigger
func (trigger *SlowRequestsBasedTrigger) AssignPropertiesToSlowRequestsBasedTrigger(destination *v20220301s.SlowRequestsBasedTrigger) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Count
	destination.Count = genruntime.ClonePointerToInt(trigger.Count)

	// Path
	destination.Path = genruntime.ClonePointerToString(trigger.Path)

	// TimeInterval
	destination.TimeInterval = genruntime.ClonePointerToString(trigger.TimeInterval)

	// TimeTaken
	destination.TimeTaken = genruntime.ClonePointerToString(trigger.TimeTaken)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type SlowRequestsBasedTrigger_STATUS struct {
	// Count: Request Count.
	Count *int `json:"count,omitempty"`

	// Path: Request Path.
	Path *string `json:"path,omitempty"`

	// TimeInterval: Time interval.
	TimeInterval *string `json:"timeInterval,omitempty"`

	// TimeTaken: Time taken.
	TimeTaken *string `json:"timeTaken,omitempty"`
}

var _ genruntime.FromARMConverter = &SlowRequestsBasedTrigger_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (trigger *SlowRequestsBasedTrigger_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SlowRequestsBasedTrigger_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (trigger *SlowRequestsBasedTrigger_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SlowRequestsBasedTrigger_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SlowRequestsBasedTrigger_STATUSARM, got %T", armInput)
	}

	// Set property ‘Count’:
	if typedInput.Count != nil {
		count := *typedInput.Count
		trigger.Count = &count
	}

	// Set property ‘Path’:
	if typedInput.Path != nil {
		path := *typedInput.Path
		trigger.Path = &path
	}

	// Set property ‘TimeInterval’:
	if typedInput.TimeInterval != nil {
		timeInterval := *typedInput.TimeInterval
		trigger.TimeInterval = &timeInterval
	}

	// Set property ‘TimeTaken’:
	if typedInput.TimeTaken != nil {
		timeTaken := *typedInput.TimeTaken
		trigger.TimeTaken = &timeTaken
	}

	// No error
	return nil
}

// AssignPropertiesFromSlowRequestsBasedTriggerSTATUS populates our SlowRequestsBasedTrigger_STATUS from the provided source SlowRequestsBasedTrigger_STATUS
func (trigger *SlowRequestsBasedTrigger_STATUS) AssignPropertiesFromSlowRequestsBasedTriggerSTATUS(source *v20220301s.SlowRequestsBasedTrigger_STATUS) error {

	// Count
	trigger.Count = genruntime.ClonePointerToInt(source.Count)

	// Path
	trigger.Path = genruntime.ClonePointerToString(source.Path)

	// TimeInterval
	trigger.TimeInterval = genruntime.ClonePointerToString(source.TimeInterval)

	// TimeTaken
	trigger.TimeTaken = genruntime.ClonePointerToString(source.TimeTaken)

	// No error
	return nil
}

// AssignPropertiesToSlowRequestsBasedTriggerSTATUS populates the provided destination SlowRequestsBasedTrigger_STATUS from our SlowRequestsBasedTrigger_STATUS
func (trigger *SlowRequestsBasedTrigger_STATUS) AssignPropertiesToSlowRequestsBasedTriggerSTATUS(destination *v20220301s.SlowRequestsBasedTrigger_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Count
	destination.Count = genruntime.ClonePointerToInt(trigger.Count)

	// Path
	destination.Path = genruntime.ClonePointerToString(trigger.Path)

	// TimeInterval
	destination.TimeInterval = genruntime.ClonePointerToString(trigger.TimeInterval)

	// TimeTaken
	destination.TimeTaken = genruntime.ClonePointerToString(trigger.TimeTaken)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2022-03-01/Microsoft.Web.json#/definitions/StatusCodesBasedTrigger
type StatusCodesBasedTrigger struct {
	// Count: Request Count.
	Count *int `json:"count,omitempty"`

	// Path: Request Path
	Path *string `json:"path,omitempty"`

	// Status: HTTP status code.
	Status *int `json:"status,omitempty"`

	// SubStatus: Request Sub Status.
	SubStatus *int `json:"subStatus,omitempty"`

	// TimeInterval: Time interval.
	TimeInterval *string `json:"timeInterval,omitempty"`

	// Win32Status: Win32 error code.
	Win32Status *int `json:"win32Status,omitempty"`
}

var _ genruntime.ARMTransformer = &StatusCodesBasedTrigger{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (trigger *StatusCodesBasedTrigger) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if trigger == nil {
		return nil, nil
	}
	result := &StatusCodesBasedTriggerARM{}

	// Set property ‘Count’:
	if trigger.Count != nil {
		count := *trigger.Count
		result.Count = &count
	}

	// Set property ‘Path’:
	if trigger.Path != nil {
		path := *trigger.Path
		result.Path = &path
	}

	// Set property ‘Status’:
	if trigger.Status != nil {
		status := *trigger.Status
		result.Status = &status
	}

	// Set property ‘SubStatus’:
	if trigger.SubStatus != nil {
		subStatus := *trigger.SubStatus
		result.SubStatus = &subStatus
	}

	// Set property ‘TimeInterval’:
	if trigger.TimeInterval != nil {
		timeInterval := *trigger.TimeInterval
		result.TimeInterval = &timeInterval
	}

	// Set property ‘Win32Status’:
	if trigger.Win32Status != nil {
		win32Status := *trigger.Win32Status
		result.Win32Status = &win32Status
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (trigger *StatusCodesBasedTrigger) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &StatusCodesBasedTriggerARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (trigger *StatusCodesBasedTrigger) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(StatusCodesBasedTriggerARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected StatusCodesBasedTriggerARM, got %T", armInput)
	}

	// Set property ‘Count’:
	if typedInput.Count != nil {
		count := *typedInput.Count
		trigger.Count = &count
	}

	// Set property ‘Path’:
	if typedInput.Path != nil {
		path := *typedInput.Path
		trigger.Path = &path
	}

	// Set property ‘Status’:
	if typedInput.Status != nil {
		status := *typedInput.Status
		trigger.Status = &status
	}

	// Set property ‘SubStatus’:
	if typedInput.SubStatus != nil {
		subStatus := *typedInput.SubStatus
		trigger.SubStatus = &subStatus
	}

	// Set property ‘TimeInterval’:
	if typedInput.TimeInterval != nil {
		timeInterval := *typedInput.TimeInterval
		trigger.TimeInterval = &timeInterval
	}

	// Set property ‘Win32Status’:
	if typedInput.Win32Status != nil {
		win32Status := *typedInput.Win32Status
		trigger.Win32Status = &win32Status
	}

	// No error
	return nil
}

// AssignPropertiesFromStatusCodesBasedTrigger populates our StatusCodesBasedTrigger from the provided source StatusCodesBasedTrigger
func (trigger *StatusCodesBasedTrigger) AssignPropertiesFromStatusCodesBasedTrigger(source *v20220301s.StatusCodesBasedTrigger) error {

	// Count
	trigger.Count = genruntime.ClonePointerToInt(source.Count)

	// Path
	trigger.Path = genruntime.ClonePointerToString(source.Path)

	// Status
	trigger.Status = genruntime.ClonePointerToInt(source.Status)

	// SubStatus
	trigger.SubStatus = genruntime.ClonePointerToInt(source.SubStatus)

	// TimeInterval
	trigger.TimeInterval = genruntime.ClonePointerToString(source.TimeInterval)

	// Win32Status
	trigger.Win32Status = genruntime.ClonePointerToInt(source.Win32Status)

	// No error
	return nil
}

// AssignPropertiesToStatusCodesBasedTrigger populates the provided destination StatusCodesBasedTrigger from our StatusCodesBasedTrigger
func (trigger *StatusCodesBasedTrigger) AssignPropertiesToStatusCodesBasedTrigger(destination *v20220301s.StatusCodesBasedTrigger) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Count
	destination.Count = genruntime.ClonePointerToInt(trigger.Count)

	// Path
	destination.Path = genruntime.ClonePointerToString(trigger.Path)

	// Status
	destination.Status = genruntime.ClonePointerToInt(trigger.Status)

	// SubStatus
	destination.SubStatus = genruntime.ClonePointerToInt(trigger.SubStatus)

	// TimeInterval
	destination.TimeInterval = genruntime.ClonePointerToString(trigger.TimeInterval)

	// Win32Status
	destination.Win32Status = genruntime.ClonePointerToInt(trigger.Win32Status)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type StatusCodesBasedTrigger_STATUS struct {
	// Count: Request Count.
	Count *int `json:"count,omitempty"`

	// Path: Request Path
	Path *string `json:"path,omitempty"`

	// Status: HTTP status code.
	Status *int `json:"status,omitempty"`

	// SubStatus: Request Sub Status.
	SubStatus *int `json:"subStatus,omitempty"`

	// TimeInterval: Time interval.
	TimeInterval *string `json:"timeInterval,omitempty"`

	// Win32Status: Win32 error code.
	Win32Status *int `json:"win32Status,omitempty"`
}

var _ genruntime.FromARMConverter = &StatusCodesBasedTrigger_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (trigger *StatusCodesBasedTrigger_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &StatusCodesBasedTrigger_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (trigger *StatusCodesBasedTrigger_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(StatusCodesBasedTrigger_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected StatusCodesBasedTrigger_STATUSARM, got %T", armInput)
	}

	// Set property ‘Count’:
	if typedInput.Count != nil {
		count := *typedInput.Count
		trigger.Count = &count
	}

	// Set property ‘Path’:
	if typedInput.Path != nil {
		path := *typedInput.Path
		trigger.Path = &path
	}

	// Set property ‘Status’:
	if typedInput.Status != nil {
		status := *typedInput.Status
		trigger.Status = &status
	}

	// Set property ‘SubStatus’:
	if typedInput.SubStatus != nil {
		subStatus := *typedInput.SubStatus
		trigger.SubStatus = &subStatus
	}

	// Set property ‘TimeInterval’:
	if typedInput.TimeInterval != nil {
		timeInterval := *typedInput.TimeInterval
		trigger.TimeInterval = &timeInterval
	}

	// Set property ‘Win32Status’:
	if typedInput.Win32Status != nil {
		win32Status := *typedInput.Win32Status
		trigger.Win32Status = &win32Status
	}

	// No error
	return nil
}

// AssignPropertiesFromStatusCodesBasedTriggerSTATUS populates our StatusCodesBasedTrigger_STATUS from the provided source StatusCodesBasedTrigger_STATUS
func (trigger *StatusCodesBasedTrigger_STATUS) AssignPropertiesFromStatusCodesBasedTriggerSTATUS(source *v20220301s.StatusCodesBasedTrigger_STATUS) error {

	// Count
	trigger.Count = genruntime.ClonePointerToInt(source.Count)

	// Path
	trigger.Path = genruntime.ClonePointerToString(source.Path)

	// Status
	trigger.Status = genruntime.ClonePointerToInt(source.Status)

	// SubStatus
	trigger.SubStatus = genruntime.ClonePointerToInt(source.SubStatus)

	// TimeInterval
	trigger.TimeInterval = genruntime.ClonePointerToString(source.TimeInterval)

	// Win32Status
	trigger.Win32Status = genruntime.ClonePointerToInt(source.Win32Status)

	// No error
	return nil
}

// AssignPropertiesToStatusCodesBasedTriggerSTATUS populates the provided destination StatusCodesBasedTrigger_STATUS from our StatusCodesBasedTrigger_STATUS
func (trigger *StatusCodesBasedTrigger_STATUS) AssignPropertiesToStatusCodesBasedTriggerSTATUS(destination *v20220301s.StatusCodesBasedTrigger_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Count
	destination.Count = genruntime.ClonePointerToInt(trigger.Count)

	// Path
	destination.Path = genruntime.ClonePointerToString(trigger.Path)

	// Status
	destination.Status = genruntime.ClonePointerToInt(trigger.Status)

	// SubStatus
	destination.SubStatus = genruntime.ClonePointerToInt(trigger.SubStatus)

	// TimeInterval
	destination.TimeInterval = genruntime.ClonePointerToString(trigger.TimeInterval)

	// Win32Status
	destination.Win32Status = genruntime.ClonePointerToInt(trigger.Win32Status)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Generated from: https://schema.management.azure.com/schemas/2022-03-01/Microsoft.Web.json#/definitions/StatusCodesRangeBasedTrigger
type StatusCodesRangeBasedTrigger struct {
	// Count: Request Count.
	Count *int    `json:"count,omitempty"`
	Path  *string `json:"path,omitempty"`

	// StatusCodes: HTTP status code.
	StatusCodes *string `json:"statusCodes,omitempty"`

	// TimeInterval: Time interval.
	TimeInterval *string `json:"timeInterval,omitempty"`
}

var _ genruntime.ARMTransformer = &StatusCodesRangeBasedTrigger{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (trigger *StatusCodesRangeBasedTrigger) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if trigger == nil {
		return nil, nil
	}
	result := &StatusCodesRangeBasedTriggerARM{}

	// Set property ‘Count’:
	if trigger.Count != nil {
		count := *trigger.Count
		result.Count = &count
	}

	// Set property ‘Path’:
	if trigger.Path != nil {
		path := *trigger.Path
		result.Path = &path
	}

	// Set property ‘StatusCodes’:
	if trigger.StatusCodes != nil {
		statusCodes := *trigger.StatusCodes
		result.StatusCodes = &statusCodes
	}

	// Set property ‘TimeInterval’:
	if trigger.TimeInterval != nil {
		timeInterval := *trigger.TimeInterval
		result.TimeInterval = &timeInterval
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (trigger *StatusCodesRangeBasedTrigger) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &StatusCodesRangeBasedTriggerARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (trigger *StatusCodesRangeBasedTrigger) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(StatusCodesRangeBasedTriggerARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected StatusCodesRangeBasedTriggerARM, got %T", armInput)
	}

	// Set property ‘Count’:
	if typedInput.Count != nil {
		count := *typedInput.Count
		trigger.Count = &count
	}

	// Set property ‘Path’:
	if typedInput.Path != nil {
		path := *typedInput.Path
		trigger.Path = &path
	}

	// Set property ‘StatusCodes’:
	if typedInput.StatusCodes != nil {
		statusCodes := *typedInput.StatusCodes
		trigger.StatusCodes = &statusCodes
	}

	// Set property ‘TimeInterval’:
	if typedInput.TimeInterval != nil {
		timeInterval := *typedInput.TimeInterval
		trigger.TimeInterval = &timeInterval
	}

	// No error
	return nil
}

// AssignPropertiesFromStatusCodesRangeBasedTrigger populates our StatusCodesRangeBasedTrigger from the provided source StatusCodesRangeBasedTrigger
func (trigger *StatusCodesRangeBasedTrigger) AssignPropertiesFromStatusCodesRangeBasedTrigger(source *v20220301s.StatusCodesRangeBasedTrigger) error {

	// Count
	trigger.Count = genruntime.ClonePointerToInt(source.Count)

	// Path
	trigger.Path = genruntime.ClonePointerToString(source.Path)

	// StatusCodes
	trigger.StatusCodes = genruntime.ClonePointerToString(source.StatusCodes)

	// TimeInterval
	trigger.TimeInterval = genruntime.ClonePointerToString(source.TimeInterval)

	// No error
	return nil
}

// AssignPropertiesToStatusCodesRangeBasedTrigger populates the provided destination StatusCodesRangeBasedTrigger from our StatusCodesRangeBasedTrigger
func (trigger *StatusCodesRangeBasedTrigger) AssignPropertiesToStatusCodesRangeBasedTrigger(destination *v20220301s.StatusCodesRangeBasedTrigger) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Count
	destination.Count = genruntime.ClonePointerToInt(trigger.Count)

	// Path
	destination.Path = genruntime.ClonePointerToString(trigger.Path)

	// StatusCodes
	destination.StatusCodes = genruntime.ClonePointerToString(trigger.StatusCodes)

	// TimeInterval
	destination.TimeInterval = genruntime.ClonePointerToString(trigger.TimeInterval)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type StatusCodesRangeBasedTrigger_STATUS struct {
	// Count: Request Count.
	Count *int    `json:"count,omitempty"`
	Path  *string `json:"path,omitempty"`

	// StatusCodes: HTTP status code.
	StatusCodes *string `json:"statusCodes,omitempty"`

	// TimeInterval: Time interval.
	TimeInterval *string `json:"timeInterval,omitempty"`
}

var _ genruntime.FromARMConverter = &StatusCodesRangeBasedTrigger_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (trigger *StatusCodesRangeBasedTrigger_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &StatusCodesRangeBasedTrigger_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (trigger *StatusCodesRangeBasedTrigger_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(StatusCodesRangeBasedTrigger_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected StatusCodesRangeBasedTrigger_STATUSARM, got %T", armInput)
	}

	// Set property ‘Count’:
	if typedInput.Count != nil {
		count := *typedInput.Count
		trigger.Count = &count
	}

	// Set property ‘Path’:
	if typedInput.Path != nil {
		path := *typedInput.Path
		trigger.Path = &path
	}

	// Set property ‘StatusCodes’:
	if typedInput.StatusCodes != nil {
		statusCodes := *typedInput.StatusCodes
		trigger.StatusCodes = &statusCodes
	}

	// Set property ‘TimeInterval’:
	if typedInput.TimeInterval != nil {
		timeInterval := *typedInput.TimeInterval
		trigger.TimeInterval = &timeInterval
	}

	// No error
	return nil
}

// AssignPropertiesFromStatusCodesRangeBasedTriggerSTATUS populates our StatusCodesRangeBasedTrigger_STATUS from the provided source StatusCodesRangeBasedTrigger_STATUS
func (trigger *StatusCodesRangeBasedTrigger_STATUS) AssignPropertiesFromStatusCodesRangeBasedTriggerSTATUS(source *v20220301s.StatusCodesRangeBasedTrigger_STATUS) error {

	// Count
	trigger.Count = genruntime.ClonePointerToInt(source.Count)

	// Path
	trigger.Path = genruntime.ClonePointerToString(source.Path)

	// StatusCodes
	trigger.StatusCodes = genruntime.ClonePointerToString(source.StatusCodes)

	// TimeInterval
	trigger.TimeInterval = genruntime.ClonePointerToString(source.TimeInterval)

	// No error
	return nil
}

// AssignPropertiesToStatusCodesRangeBasedTriggerSTATUS populates the provided destination StatusCodesRangeBasedTrigger_STATUS from our StatusCodesRangeBasedTrigger_STATUS
func (trigger *StatusCodesRangeBasedTrigger_STATUS) AssignPropertiesToStatusCodesRangeBasedTriggerSTATUS(destination *v20220301s.StatusCodesRangeBasedTrigger_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Count
	destination.Count = genruntime.ClonePointerToInt(trigger.Count)

	// Path
	destination.Path = genruntime.ClonePointerToString(trigger.Path)

	// StatusCodes
	destination.StatusCodes = genruntime.ClonePointerToString(trigger.StatusCodes)

	// TimeInterval
	destination.TimeInterval = genruntime.ClonePointerToString(trigger.TimeInterval)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&Site{}, &SiteList{})
}
