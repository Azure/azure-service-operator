// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20220301

import (
	"fmt"
	v1beta20220301s "github.com/Azure/azure-service-operator/v2/api/web/v1beta20220301/storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Deprecated version of Site. Use v1api20220301.Site instead
type Site struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              Site_Spec   `json:"spec,omitempty"`
	Status            Site_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &Site{}

// GetConditions returns the conditions of the resource
func (site *Site) GetConditions() conditions.Conditions {
	return site.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (site *Site) SetConditions(conditions conditions.Conditions) {
	site.Status.Conditions = conditions
}

var _ conversion.Convertible = &Site{}

// ConvertFrom populates our Site from the provided hub Site
func (site *Site) ConvertFrom(hub conversion.Hub) error {
	// intermediate variable for conversion
	var source v1beta20220301s.Site

	err := source.ConvertFrom(hub)
	if err != nil {
		return errors.Wrap(err, "converting from hub to source")
	}

	err = site.AssignProperties_From_Site(&source)
	if err != nil {
		return errors.Wrap(err, "converting from source to site")
	}

	return nil
}

// ConvertTo populates the provided hub Site from our Site
func (site *Site) ConvertTo(hub conversion.Hub) error {
	// intermediate variable for conversion
	var destination v1beta20220301s.Site
	err := site.AssignProperties_To_Site(&destination)
	if err != nil {
		return errors.Wrap(err, "converting to destination from site")
	}
	err = destination.ConvertTo(hub)
	if err != nil {
		return errors.Wrap(err, "converting from destination to hub")
	}

	return nil
}

// +kubebuilder:webhook:path=/mutate-web-azure-com-v1beta20220301-site,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=web.azure.com,resources=sites,verbs=create;update,versions=v1beta20220301,name=default.v1beta20220301.sites.web.azure.com,admissionReviewVersions=v1

var _ admission.Defaulter = &Site{}

// Default applies defaults to the Site resource
func (site *Site) Default() {
	site.defaultImpl()
	var temp any = site
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (site *Site) defaultAzureName() {
	if site.Spec.AzureName == "" {
		site.Spec.AzureName = site.Name
	}
}

// defaultImpl applies the code generated defaults to the Site resource
func (site *Site) defaultImpl() { site.defaultAzureName() }

var _ genruntime.KubernetesResource = &Site{}

// AzureName returns the Azure name of the resource
func (site *Site) AzureName() string {
	return site.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2022-03-01"
func (site Site) GetAPIVersion() string {
	return string(APIVersion_Value)
}

// GetResourceScope returns the scope of the resource
func (site *Site) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (site *Site) GetSpec() genruntime.ConvertibleSpec {
	return &site.Spec
}

// GetStatus returns the status of this resource
func (site *Site) GetStatus() genruntime.ConvertibleStatus {
	return &site.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (site *Site) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Web/sites"
func (site *Site) GetType() string {
	return "Microsoft.Web/sites"
}

// NewEmptyStatus returns a new empty (blank) status
func (site *Site) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &Site_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (site *Site) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(site.Spec)
	return site.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (site *Site) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*Site_STATUS); ok {
		site.Status = *st
		return nil
	}

	// Convert status to required version
	var st Site_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	site.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-web-azure-com-v1beta20220301-site,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=web.azure.com,resources=sites,verbs=create;update,versions=v1beta20220301,name=validate.v1beta20220301.sites.web.azure.com,admissionReviewVersions=v1

var _ admission.Validator = &Site{}

// ValidateCreate validates the creation of the resource
func (site *Site) ValidateCreate() (admission.Warnings, error) {
	validations := site.createValidations()
	var temp any = site
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	return genruntime.ValidateCreate(validations)
}

// ValidateDelete validates the deletion of the resource
func (site *Site) ValidateDelete() (admission.Warnings, error) {
	validations := site.deleteValidations()
	var temp any = site
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	return genruntime.ValidateDelete(validations)
}

// ValidateUpdate validates an update of the resource
func (site *Site) ValidateUpdate(old runtime.Object) (admission.Warnings, error) {
	validations := site.updateValidations()
	var temp any = site
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	return genruntime.ValidateUpdate(old, validations)
}

// createValidations validates the creation of the resource
func (site *Site) createValidations() []func() (admission.Warnings, error) {
	return []func() (admission.Warnings, error){site.validateResourceReferences, site.validateOwnerReference}
}

// deleteValidations validates the deletion of the resource
func (site *Site) deleteValidations() []func() (admission.Warnings, error) {
	return nil
}

// updateValidations validates the update of the resource
func (site *Site) updateValidations() []func(old runtime.Object) (admission.Warnings, error) {
	return []func(old runtime.Object) (admission.Warnings, error){
		func(old runtime.Object) (admission.Warnings, error) {
			return site.validateResourceReferences()
		},
		site.validateWriteOnceProperties,
		func(old runtime.Object) (admission.Warnings, error) {
			return site.validateOwnerReference()
		},
	}
}

// validateOwnerReference validates the owner field
func (site *Site) validateOwnerReference() (admission.Warnings, error) {
	return genruntime.ValidateOwner(site)
}

// validateResourceReferences validates all resource references
func (site *Site) validateResourceReferences() (admission.Warnings, error) {
	refs, err := reflecthelpers.FindResourceReferences(&site.Spec)
	if err != nil {
		return nil, err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// validateWriteOnceProperties validates all WriteOnce properties
func (site *Site) validateWriteOnceProperties(old runtime.Object) (admission.Warnings, error) {
	oldObj, ok := old.(*Site)
	if !ok {
		return nil, nil
	}

	return genruntime.ValidateWriteOnceProperties(oldObj, site)
}

// AssignProperties_From_Site populates our Site from the provided source Site
func (site *Site) AssignProperties_From_Site(source *v1beta20220301s.Site) error {

	// ObjectMeta
	site.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec Site_Spec
	err := spec.AssignProperties_From_Site_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_Site_Spec() to populate field Spec")
	}
	site.Spec = spec

	// Status
	var status Site_STATUS
	err = status.AssignProperties_From_Site_STATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_Site_STATUS() to populate field Status")
	}
	site.Status = status

	// No error
	return nil
}

// AssignProperties_To_Site populates the provided destination Site from our Site
func (site *Site) AssignProperties_To_Site(destination *v1beta20220301s.Site) error {

	// ObjectMeta
	destination.ObjectMeta = *site.ObjectMeta.DeepCopy()

	// Spec
	var spec v1beta20220301s.Site_Spec
	err := site.Spec.AssignProperties_To_Site_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_Site_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status v1beta20220301s.Site_STATUS
	err = site.Status.AssignProperties_To_Site_STATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_Site_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (site *Site) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: site.Spec.OriginalVersion(),
		Kind:    "Site",
	}
}

// +kubebuilder:object:root=true
// Deprecated version of Site. Use v1api20220301.Site instead
type SiteList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Site `json:"items"`
}

type Site_Spec struct {
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName                  string                               `json:"azureName,omitempty"`
	ClientAffinityEnabled      *bool                                `json:"clientAffinityEnabled,omitempty"`
	ClientCertEnabled          *bool                                `json:"clientCertEnabled,omitempty"`
	ClientCertExclusionPaths   *string                              `json:"clientCertExclusionPaths,omitempty"`
	ClientCertMode             *Site_Properties_ClientCertMode_Spec `json:"clientCertMode,omitempty"`
	CloningInfo                *CloningInfo                         `json:"cloningInfo,omitempty"`
	ContainerSize              *int                                 `json:"containerSize,omitempty"`
	CustomDomainVerificationId *string                              `json:"customDomainVerificationId,omitempty"`
	DailyMemoryTimeQuota       *int                                 `json:"dailyMemoryTimeQuota,omitempty"`
	Enabled                    *bool                                `json:"enabled,omitempty"`
	ExtendedLocation           *ExtendedLocation                    `json:"extendedLocation,omitempty"`
	HostNameSslStates          []HostNameSslState                   `json:"hostNameSslStates,omitempty"`
	HostNamesDisabled          *bool                                `json:"hostNamesDisabled,omitempty"`
	HostingEnvironmentProfile  *HostingEnvironmentProfile           `json:"hostingEnvironmentProfile,omitempty"`
	HttpsOnly                  *bool                                `json:"httpsOnly,omitempty"`
	HyperV                     *bool                                `json:"hyperV,omitempty"`
	Identity                   *ManagedServiceIdentity              `json:"identity,omitempty"`
	IsXenon                    *bool                                `json:"isXenon,omitempty"`
	KeyVaultReferenceIdentity  *string                              `json:"keyVaultReferenceIdentity,omitempty"`
	Kind                       *string                              `json:"kind,omitempty"`

	// +kubebuilder:validation:Required
	Location *string `json:"location,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner                         *genruntime.KnownResourceReference   `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`
	PublicNetworkAccess           *string                              `json:"publicNetworkAccess,omitempty"`
	RedundancyMode                *Site_Properties_RedundancyMode_Spec `json:"redundancyMode,omitempty"`
	Reserved                      *bool                                `json:"reserved,omitempty"`
	ScmSiteAlsoStopped            *bool                                `json:"scmSiteAlsoStopped,omitempty"`
	ServerFarmReference           *genruntime.ResourceReference        `armReference:"ServerFarmId" json:"serverFarmReference,omitempty"`
	SiteConfig                    *SiteConfig                          `json:"siteConfig,omitempty"`
	StorageAccountRequired        *bool                                `json:"storageAccountRequired,omitempty"`
	Tags                          map[string]string                    `json:"tags,omitempty"`
	VirtualNetworkSubnetReference *genruntime.ResourceReference        `armReference:"VirtualNetworkSubnetId" json:"virtualNetworkSubnetReference,omitempty"`
	VnetContentShareEnabled       *bool                                `json:"vnetContentShareEnabled,omitempty"`
	VnetImagePullEnabled          *bool                                `json:"vnetImagePullEnabled,omitempty"`
	VnetRouteAllEnabled           *bool                                `json:"vnetRouteAllEnabled,omitempty"`
}

var _ genruntime.ARMTransformer = &Site_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (site *Site_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if site == nil {
		return nil, nil
	}
	result := &Site_Spec_ARM{}

	// Set property "ExtendedLocation":
	if site.ExtendedLocation != nil {
		extendedLocation_ARM, err := (*site.ExtendedLocation).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		extendedLocation := *extendedLocation_ARM.(*ExtendedLocation_ARM)
		result.ExtendedLocation = &extendedLocation
	}

	// Set property "Identity":
	if site.Identity != nil {
		identity_ARM, err := (*site.Identity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := *identity_ARM.(*ManagedServiceIdentity_ARM)
		result.Identity = &identity
	}

	// Set property "Kind":
	if site.Kind != nil {
		kind := *site.Kind
		result.Kind = &kind
	}

	// Set property "Location":
	if site.Location != nil {
		location := *site.Location
		result.Location = &location
	}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if site.ClientAffinityEnabled != nil ||
		site.ClientCertEnabled != nil ||
		site.ClientCertExclusionPaths != nil ||
		site.ClientCertMode != nil ||
		site.CloningInfo != nil ||
		site.ContainerSize != nil ||
		site.CustomDomainVerificationId != nil ||
		site.DailyMemoryTimeQuota != nil ||
		site.Enabled != nil ||
		site.HostNameSslStates != nil ||
		site.HostNamesDisabled != nil ||
		site.HostingEnvironmentProfile != nil ||
		site.HttpsOnly != nil ||
		site.HyperV != nil ||
		site.IsXenon != nil ||
		site.KeyVaultReferenceIdentity != nil ||
		site.PublicNetworkAccess != nil ||
		site.RedundancyMode != nil ||
		site.Reserved != nil ||
		site.ScmSiteAlsoStopped != nil ||
		site.ServerFarmReference != nil ||
		site.SiteConfig != nil ||
		site.StorageAccountRequired != nil ||
		site.VirtualNetworkSubnetReference != nil ||
		site.VnetContentShareEnabled != nil ||
		site.VnetImagePullEnabled != nil ||
		site.VnetRouteAllEnabled != nil {
		result.Properties = &Site_Properties_Spec_ARM{}
	}
	if site.ClientAffinityEnabled != nil {
		clientAffinityEnabled := *site.ClientAffinityEnabled
		result.Properties.ClientAffinityEnabled = &clientAffinityEnabled
	}
	if site.ClientCertEnabled != nil {
		clientCertEnabled := *site.ClientCertEnabled
		result.Properties.ClientCertEnabled = &clientCertEnabled
	}
	if site.ClientCertExclusionPaths != nil {
		clientCertExclusionPaths := *site.ClientCertExclusionPaths
		result.Properties.ClientCertExclusionPaths = &clientCertExclusionPaths
	}
	if site.ClientCertMode != nil {
		clientCertMode := *site.ClientCertMode
		result.Properties.ClientCertMode = &clientCertMode
	}
	if site.CloningInfo != nil {
		cloningInfo_ARM, err := (*site.CloningInfo).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		cloningInfo := *cloningInfo_ARM.(*CloningInfo_ARM)
		result.Properties.CloningInfo = &cloningInfo
	}
	if site.ContainerSize != nil {
		containerSize := *site.ContainerSize
		result.Properties.ContainerSize = &containerSize
	}
	if site.CustomDomainVerificationId != nil {
		customDomainVerificationId := *site.CustomDomainVerificationId
		result.Properties.CustomDomainVerificationId = &customDomainVerificationId
	}
	if site.DailyMemoryTimeQuota != nil {
		dailyMemoryTimeQuota := *site.DailyMemoryTimeQuota
		result.Properties.DailyMemoryTimeQuota = &dailyMemoryTimeQuota
	}
	if site.Enabled != nil {
		enabled := *site.Enabled
		result.Properties.Enabled = &enabled
	}
	for _, item := range site.HostNameSslStates {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.HostNameSslStates = append(result.Properties.HostNameSslStates, *item_ARM.(*HostNameSslState_ARM))
	}
	if site.HostNamesDisabled != nil {
		hostNamesDisabled := *site.HostNamesDisabled
		result.Properties.HostNamesDisabled = &hostNamesDisabled
	}
	if site.HostingEnvironmentProfile != nil {
		hostingEnvironmentProfile_ARM, err := (*site.HostingEnvironmentProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		hostingEnvironmentProfile := *hostingEnvironmentProfile_ARM.(*HostingEnvironmentProfile_ARM)
		result.Properties.HostingEnvironmentProfile = &hostingEnvironmentProfile
	}
	if site.HttpsOnly != nil {
		httpsOnly := *site.HttpsOnly
		result.Properties.HttpsOnly = &httpsOnly
	}
	if site.HyperV != nil {
		hyperV := *site.HyperV
		result.Properties.HyperV = &hyperV
	}
	if site.IsXenon != nil {
		isXenon := *site.IsXenon
		result.Properties.IsXenon = &isXenon
	}
	if site.KeyVaultReferenceIdentity != nil {
		keyVaultReferenceIdentity := *site.KeyVaultReferenceIdentity
		result.Properties.KeyVaultReferenceIdentity = &keyVaultReferenceIdentity
	}
	if site.PublicNetworkAccess != nil {
		publicNetworkAccess := *site.PublicNetworkAccess
		result.Properties.PublicNetworkAccess = &publicNetworkAccess
	}
	if site.RedundancyMode != nil {
		redundancyMode := *site.RedundancyMode
		result.Properties.RedundancyMode = &redundancyMode
	}
	if site.Reserved != nil {
		reserved := *site.Reserved
		result.Properties.Reserved = &reserved
	}
	if site.ScmSiteAlsoStopped != nil {
		scmSiteAlsoStopped := *site.ScmSiteAlsoStopped
		result.Properties.ScmSiteAlsoStopped = &scmSiteAlsoStopped
	}
	if site.ServerFarmReference != nil {
		serverFarmIdARMID, err := resolved.ResolvedReferences.Lookup(*site.ServerFarmReference)
		if err != nil {
			return nil, err
		}
		serverFarmId := serverFarmIdARMID
		result.Properties.ServerFarmId = &serverFarmId
	}
	if site.SiteConfig != nil {
		siteConfig_ARM, err := (*site.SiteConfig).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		siteConfig := *siteConfig_ARM.(*SiteConfig_ARM)
		result.Properties.SiteConfig = &siteConfig
	}
	if site.StorageAccountRequired != nil {
		storageAccountRequired := *site.StorageAccountRequired
		result.Properties.StorageAccountRequired = &storageAccountRequired
	}
	if site.VirtualNetworkSubnetReference != nil {
		virtualNetworkSubnetIdARMID, err := resolved.ResolvedReferences.Lookup(*site.VirtualNetworkSubnetReference)
		if err != nil {
			return nil, err
		}
		virtualNetworkSubnetId := virtualNetworkSubnetIdARMID
		result.Properties.VirtualNetworkSubnetId = &virtualNetworkSubnetId
	}
	if site.VnetContentShareEnabled != nil {
		vnetContentShareEnabled := *site.VnetContentShareEnabled
		result.Properties.VnetContentShareEnabled = &vnetContentShareEnabled
	}
	if site.VnetImagePullEnabled != nil {
		vnetImagePullEnabled := *site.VnetImagePullEnabled
		result.Properties.VnetImagePullEnabled = &vnetImagePullEnabled
	}
	if site.VnetRouteAllEnabled != nil {
		vnetRouteAllEnabled := *site.VnetRouteAllEnabled
		result.Properties.VnetRouteAllEnabled = &vnetRouteAllEnabled
	}

	// Set property "Tags":
	if site.Tags != nil {
		result.Tags = make(map[string]string, len(site.Tags))
		for key, value := range site.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (site *Site_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Site_Spec_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (site *Site_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Site_Spec_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Site_Spec_ARM, got %T", armInput)
	}

	// Set property "AzureName":
	site.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "ClientAffinityEnabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ClientAffinityEnabled != nil {
			clientAffinityEnabled := *typedInput.Properties.ClientAffinityEnabled
			site.ClientAffinityEnabled = &clientAffinityEnabled
		}
	}

	// Set property "ClientCertEnabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ClientCertEnabled != nil {
			clientCertEnabled := *typedInput.Properties.ClientCertEnabled
			site.ClientCertEnabled = &clientCertEnabled
		}
	}

	// Set property "ClientCertExclusionPaths":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ClientCertExclusionPaths != nil {
			clientCertExclusionPaths := *typedInput.Properties.ClientCertExclusionPaths
			site.ClientCertExclusionPaths = &clientCertExclusionPaths
		}
	}

	// Set property "ClientCertMode":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ClientCertMode != nil {
			clientCertMode := *typedInput.Properties.ClientCertMode
			site.ClientCertMode = &clientCertMode
		}
	}

	// Set property "CloningInfo":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CloningInfo != nil {
			var cloningInfo1 CloningInfo
			err := cloningInfo1.PopulateFromARM(owner, *typedInput.Properties.CloningInfo)
			if err != nil {
				return err
			}
			cloningInfo := cloningInfo1
			site.CloningInfo = &cloningInfo
		}
	}

	// Set property "ContainerSize":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ContainerSize != nil {
			containerSize := *typedInput.Properties.ContainerSize
			site.ContainerSize = &containerSize
		}
	}

	// Set property "CustomDomainVerificationId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CustomDomainVerificationId != nil {
			customDomainVerificationId := *typedInput.Properties.CustomDomainVerificationId
			site.CustomDomainVerificationId = &customDomainVerificationId
		}
	}

	// Set property "DailyMemoryTimeQuota":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DailyMemoryTimeQuota != nil {
			dailyMemoryTimeQuota := *typedInput.Properties.DailyMemoryTimeQuota
			site.DailyMemoryTimeQuota = &dailyMemoryTimeQuota
		}
	}

	// Set property "Enabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Enabled != nil {
			enabled := *typedInput.Properties.Enabled
			site.Enabled = &enabled
		}
	}

	// Set property "ExtendedLocation":
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		site.ExtendedLocation = &extendedLocation
	}

	// Set property "HostNameSslStates":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.HostNameSslStates {
			var item1 HostNameSslState
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			site.HostNameSslStates = append(site.HostNameSslStates, item1)
		}
	}

	// Set property "HostNamesDisabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HostNamesDisabled != nil {
			hostNamesDisabled := *typedInput.Properties.HostNamesDisabled
			site.HostNamesDisabled = &hostNamesDisabled
		}
	}

	// Set property "HostingEnvironmentProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HostingEnvironmentProfile != nil {
			var hostingEnvironmentProfile1 HostingEnvironmentProfile
			err := hostingEnvironmentProfile1.PopulateFromARM(owner, *typedInput.Properties.HostingEnvironmentProfile)
			if err != nil {
				return err
			}
			hostingEnvironmentProfile := hostingEnvironmentProfile1
			site.HostingEnvironmentProfile = &hostingEnvironmentProfile
		}
	}

	// Set property "HttpsOnly":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HttpsOnly != nil {
			httpsOnly := *typedInput.Properties.HttpsOnly
			site.HttpsOnly = &httpsOnly
		}
	}

	// Set property "HyperV":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HyperV != nil {
			hyperV := *typedInput.Properties.HyperV
			site.HyperV = &hyperV
		}
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 ManagedServiceIdentity
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		site.Identity = &identity
	}

	// Set property "IsXenon":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IsXenon != nil {
			isXenon := *typedInput.Properties.IsXenon
			site.IsXenon = &isXenon
		}
	}

	// Set property "KeyVaultReferenceIdentity":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.KeyVaultReferenceIdentity != nil {
			keyVaultReferenceIdentity := *typedInput.Properties.KeyVaultReferenceIdentity
			site.KeyVaultReferenceIdentity = &keyVaultReferenceIdentity
		}
	}

	// Set property "Kind":
	if typedInput.Kind != nil {
		kind := *typedInput.Kind
		site.Kind = &kind
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		site.Location = &location
	}

	// Set property "Owner":
	site.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "PublicNetworkAccess":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicNetworkAccess != nil {
			publicNetworkAccess := *typedInput.Properties.PublicNetworkAccess
			site.PublicNetworkAccess = &publicNetworkAccess
		}
	}

	// Set property "RedundancyMode":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RedundancyMode != nil {
			redundancyMode := *typedInput.Properties.RedundancyMode
			site.RedundancyMode = &redundancyMode
		}
	}

	// Set property "Reserved":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Reserved != nil {
			reserved := *typedInput.Properties.Reserved
			site.Reserved = &reserved
		}
	}

	// Set property "ScmSiteAlsoStopped":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ScmSiteAlsoStopped != nil {
			scmSiteAlsoStopped := *typedInput.Properties.ScmSiteAlsoStopped
			site.ScmSiteAlsoStopped = &scmSiteAlsoStopped
		}
	}

	// no assignment for property "ServerFarmReference"

	// Set property "SiteConfig":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SiteConfig != nil {
			var siteConfig1 SiteConfig
			err := siteConfig1.PopulateFromARM(owner, *typedInput.Properties.SiteConfig)
			if err != nil {
				return err
			}
			siteConfig := siteConfig1
			site.SiteConfig = &siteConfig
		}
	}

	// Set property "StorageAccountRequired":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.StorageAccountRequired != nil {
			storageAccountRequired := *typedInput.Properties.StorageAccountRequired
			site.StorageAccountRequired = &storageAccountRequired
		}
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		site.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			site.Tags[key] = value
		}
	}

	// no assignment for property "VirtualNetworkSubnetReference"

	// Set property "VnetContentShareEnabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VnetContentShareEnabled != nil {
			vnetContentShareEnabled := *typedInput.Properties.VnetContentShareEnabled
			site.VnetContentShareEnabled = &vnetContentShareEnabled
		}
	}

	// Set property "VnetImagePullEnabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VnetImagePullEnabled != nil {
			vnetImagePullEnabled := *typedInput.Properties.VnetImagePullEnabled
			site.VnetImagePullEnabled = &vnetImagePullEnabled
		}
	}

	// Set property "VnetRouteAllEnabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VnetRouteAllEnabled != nil {
			vnetRouteAllEnabled := *typedInput.Properties.VnetRouteAllEnabled
			site.VnetRouteAllEnabled = &vnetRouteAllEnabled
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &Site_Spec{}

// ConvertSpecFrom populates our Site_Spec from the provided source
func (site *Site_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v1beta20220301s.Site_Spec)
	if ok {
		// Populate our instance from source
		return site.AssignProperties_From_Site_Spec(src)
	}

	// Convert to an intermediate form
	src = &v1beta20220301s.Site_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = site.AssignProperties_From_Site_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our Site_Spec
func (site *Site_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v1beta20220301s.Site_Spec)
	if ok {
		// Populate destination from our instance
		return site.AssignProperties_To_Site_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &v1beta20220301s.Site_Spec{}
	err := site.AssignProperties_To_Site_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_Site_Spec populates our Site_Spec from the provided source Site_Spec
func (site *Site_Spec) AssignProperties_From_Site_Spec(source *v1beta20220301s.Site_Spec) error {

	// AzureName
	site.AzureName = source.AzureName

	// ClientAffinityEnabled
	if source.ClientAffinityEnabled != nil {
		clientAffinityEnabled := *source.ClientAffinityEnabled
		site.ClientAffinityEnabled = &clientAffinityEnabled
	} else {
		site.ClientAffinityEnabled = nil
	}

	// ClientCertEnabled
	if source.ClientCertEnabled != nil {
		clientCertEnabled := *source.ClientCertEnabled
		site.ClientCertEnabled = &clientCertEnabled
	} else {
		site.ClientCertEnabled = nil
	}

	// ClientCertExclusionPaths
	site.ClientCertExclusionPaths = genruntime.ClonePointerToString(source.ClientCertExclusionPaths)

	// ClientCertMode
	if source.ClientCertMode != nil {
		clientCertMode := Site_Properties_ClientCertMode_Spec(*source.ClientCertMode)
		site.ClientCertMode = &clientCertMode
	} else {
		site.ClientCertMode = nil
	}

	// CloningInfo
	if source.CloningInfo != nil {
		var cloningInfo CloningInfo
		err := cloningInfo.AssignProperties_From_CloningInfo(source.CloningInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CloningInfo() to populate field CloningInfo")
		}
		site.CloningInfo = &cloningInfo
	} else {
		site.CloningInfo = nil
	}

	// ContainerSize
	site.ContainerSize = genruntime.ClonePointerToInt(source.ContainerSize)

	// CustomDomainVerificationId
	site.CustomDomainVerificationId = genruntime.ClonePointerToString(source.CustomDomainVerificationId)

	// DailyMemoryTimeQuota
	site.DailyMemoryTimeQuota = genruntime.ClonePointerToInt(source.DailyMemoryTimeQuota)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		site.Enabled = &enabled
	} else {
		site.Enabled = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation
		err := extendedLocation.AssignProperties_From_ExtendedLocation(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ExtendedLocation() to populate field ExtendedLocation")
		}
		site.ExtendedLocation = &extendedLocation
	} else {
		site.ExtendedLocation = nil
	}

	// HostNameSslStates
	if source.HostNameSslStates != nil {
		hostNameSslStateList := make([]HostNameSslState, len(source.HostNameSslStates))
		for hostNameSslStateIndex, hostNameSslStateItem := range source.HostNameSslStates {
			// Shadow the loop variable to avoid aliasing
			hostNameSslStateItem := hostNameSslStateItem
			var hostNameSslState HostNameSslState
			err := hostNameSslState.AssignProperties_From_HostNameSslState(&hostNameSslStateItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_HostNameSslState() to populate field HostNameSslStates")
			}
			hostNameSslStateList[hostNameSslStateIndex] = hostNameSslState
		}
		site.HostNameSslStates = hostNameSslStateList
	} else {
		site.HostNameSslStates = nil
	}

	// HostNamesDisabled
	if source.HostNamesDisabled != nil {
		hostNamesDisabled := *source.HostNamesDisabled
		site.HostNamesDisabled = &hostNamesDisabled
	} else {
		site.HostNamesDisabled = nil
	}

	// HostingEnvironmentProfile
	if source.HostingEnvironmentProfile != nil {
		var hostingEnvironmentProfile HostingEnvironmentProfile
		err := hostingEnvironmentProfile.AssignProperties_From_HostingEnvironmentProfile(source.HostingEnvironmentProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HostingEnvironmentProfile() to populate field HostingEnvironmentProfile")
		}
		site.HostingEnvironmentProfile = &hostingEnvironmentProfile
	} else {
		site.HostingEnvironmentProfile = nil
	}

	// HttpsOnly
	if source.HttpsOnly != nil {
		httpsOnly := *source.HttpsOnly
		site.HttpsOnly = &httpsOnly
	} else {
		site.HttpsOnly = nil
	}

	// HyperV
	if source.HyperV != nil {
		hyperV := *source.HyperV
		site.HyperV = &hyperV
	} else {
		site.HyperV = nil
	}

	// Identity
	if source.Identity != nil {
		var identity ManagedServiceIdentity
		err := identity.AssignProperties_From_ManagedServiceIdentity(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedServiceIdentity() to populate field Identity")
		}
		site.Identity = &identity
	} else {
		site.Identity = nil
	}

	// IsXenon
	if source.IsXenon != nil {
		isXenon := *source.IsXenon
		site.IsXenon = &isXenon
	} else {
		site.IsXenon = nil
	}

	// KeyVaultReferenceIdentity
	site.KeyVaultReferenceIdentity = genruntime.ClonePointerToString(source.KeyVaultReferenceIdentity)

	// Kind
	site.Kind = genruntime.ClonePointerToString(source.Kind)

	// Location
	site.Location = genruntime.ClonePointerToString(source.Location)

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		site.Owner = &owner
	} else {
		site.Owner = nil
	}

	// PublicNetworkAccess
	site.PublicNetworkAccess = genruntime.ClonePointerToString(source.PublicNetworkAccess)

	// RedundancyMode
	if source.RedundancyMode != nil {
		redundancyMode := Site_Properties_RedundancyMode_Spec(*source.RedundancyMode)
		site.RedundancyMode = &redundancyMode
	} else {
		site.RedundancyMode = nil
	}

	// Reserved
	if source.Reserved != nil {
		reserved := *source.Reserved
		site.Reserved = &reserved
	} else {
		site.Reserved = nil
	}

	// ScmSiteAlsoStopped
	if source.ScmSiteAlsoStopped != nil {
		scmSiteAlsoStopped := *source.ScmSiteAlsoStopped
		site.ScmSiteAlsoStopped = &scmSiteAlsoStopped
	} else {
		site.ScmSiteAlsoStopped = nil
	}

	// ServerFarmReference
	if source.ServerFarmReference != nil {
		serverFarmReference := source.ServerFarmReference.Copy()
		site.ServerFarmReference = &serverFarmReference
	} else {
		site.ServerFarmReference = nil
	}

	// SiteConfig
	if source.SiteConfig != nil {
		var siteConfig SiteConfig
		err := siteConfig.AssignProperties_From_SiteConfig(source.SiteConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SiteConfig() to populate field SiteConfig")
		}
		site.SiteConfig = &siteConfig
	} else {
		site.SiteConfig = nil
	}

	// StorageAccountRequired
	if source.StorageAccountRequired != nil {
		storageAccountRequired := *source.StorageAccountRequired
		site.StorageAccountRequired = &storageAccountRequired
	} else {
		site.StorageAccountRequired = nil
	}

	// Tags
	site.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// VirtualNetworkSubnetReference
	if source.VirtualNetworkSubnetReference != nil {
		virtualNetworkSubnetReference := source.VirtualNetworkSubnetReference.Copy()
		site.VirtualNetworkSubnetReference = &virtualNetworkSubnetReference
	} else {
		site.VirtualNetworkSubnetReference = nil
	}

	// VnetContentShareEnabled
	if source.VnetContentShareEnabled != nil {
		vnetContentShareEnabled := *source.VnetContentShareEnabled
		site.VnetContentShareEnabled = &vnetContentShareEnabled
	} else {
		site.VnetContentShareEnabled = nil
	}

	// VnetImagePullEnabled
	if source.VnetImagePullEnabled != nil {
		vnetImagePullEnabled := *source.VnetImagePullEnabled
		site.VnetImagePullEnabled = &vnetImagePullEnabled
	} else {
		site.VnetImagePullEnabled = nil
	}

	// VnetRouteAllEnabled
	if source.VnetRouteAllEnabled != nil {
		vnetRouteAllEnabled := *source.VnetRouteAllEnabled
		site.VnetRouteAllEnabled = &vnetRouteAllEnabled
	} else {
		site.VnetRouteAllEnabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Site_Spec populates the provided destination Site_Spec from our Site_Spec
func (site *Site_Spec) AssignProperties_To_Site_Spec(destination *v1beta20220301s.Site_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = site.AzureName

	// ClientAffinityEnabled
	if site.ClientAffinityEnabled != nil {
		clientAffinityEnabled := *site.ClientAffinityEnabled
		destination.ClientAffinityEnabled = &clientAffinityEnabled
	} else {
		destination.ClientAffinityEnabled = nil
	}

	// ClientCertEnabled
	if site.ClientCertEnabled != nil {
		clientCertEnabled := *site.ClientCertEnabled
		destination.ClientCertEnabled = &clientCertEnabled
	} else {
		destination.ClientCertEnabled = nil
	}

	// ClientCertExclusionPaths
	destination.ClientCertExclusionPaths = genruntime.ClonePointerToString(site.ClientCertExclusionPaths)

	// ClientCertMode
	if site.ClientCertMode != nil {
		clientCertMode := string(*site.ClientCertMode)
		destination.ClientCertMode = &clientCertMode
	} else {
		destination.ClientCertMode = nil
	}

	// CloningInfo
	if site.CloningInfo != nil {
		var cloningInfo v1beta20220301s.CloningInfo
		err := site.CloningInfo.AssignProperties_To_CloningInfo(&cloningInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CloningInfo() to populate field CloningInfo")
		}
		destination.CloningInfo = &cloningInfo
	} else {
		destination.CloningInfo = nil
	}

	// ContainerSize
	destination.ContainerSize = genruntime.ClonePointerToInt(site.ContainerSize)

	// CustomDomainVerificationId
	destination.CustomDomainVerificationId = genruntime.ClonePointerToString(site.CustomDomainVerificationId)

	// DailyMemoryTimeQuota
	destination.DailyMemoryTimeQuota = genruntime.ClonePointerToInt(site.DailyMemoryTimeQuota)

	// Enabled
	if site.Enabled != nil {
		enabled := *site.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// ExtendedLocation
	if site.ExtendedLocation != nil {
		var extendedLocation v1beta20220301s.ExtendedLocation
		err := site.ExtendedLocation.AssignProperties_To_ExtendedLocation(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ExtendedLocation() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// HostNameSslStates
	if site.HostNameSslStates != nil {
		hostNameSslStateList := make([]v1beta20220301s.HostNameSslState, len(site.HostNameSslStates))
		for hostNameSslStateIndex, hostNameSslStateItem := range site.HostNameSslStates {
			// Shadow the loop variable to avoid aliasing
			hostNameSslStateItem := hostNameSslStateItem
			var hostNameSslState v1beta20220301s.HostNameSslState
			err := hostNameSslStateItem.AssignProperties_To_HostNameSslState(&hostNameSslState)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_HostNameSslState() to populate field HostNameSslStates")
			}
			hostNameSslStateList[hostNameSslStateIndex] = hostNameSslState
		}
		destination.HostNameSslStates = hostNameSslStateList
	} else {
		destination.HostNameSslStates = nil
	}

	// HostNamesDisabled
	if site.HostNamesDisabled != nil {
		hostNamesDisabled := *site.HostNamesDisabled
		destination.HostNamesDisabled = &hostNamesDisabled
	} else {
		destination.HostNamesDisabled = nil
	}

	// HostingEnvironmentProfile
	if site.HostingEnvironmentProfile != nil {
		var hostingEnvironmentProfile v1beta20220301s.HostingEnvironmentProfile
		err := site.HostingEnvironmentProfile.AssignProperties_To_HostingEnvironmentProfile(&hostingEnvironmentProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HostingEnvironmentProfile() to populate field HostingEnvironmentProfile")
		}
		destination.HostingEnvironmentProfile = &hostingEnvironmentProfile
	} else {
		destination.HostingEnvironmentProfile = nil
	}

	// HttpsOnly
	if site.HttpsOnly != nil {
		httpsOnly := *site.HttpsOnly
		destination.HttpsOnly = &httpsOnly
	} else {
		destination.HttpsOnly = nil
	}

	// HyperV
	if site.HyperV != nil {
		hyperV := *site.HyperV
		destination.HyperV = &hyperV
	} else {
		destination.HyperV = nil
	}

	// Identity
	if site.Identity != nil {
		var identity v1beta20220301s.ManagedServiceIdentity
		err := site.Identity.AssignProperties_To_ManagedServiceIdentity(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedServiceIdentity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// IsXenon
	if site.IsXenon != nil {
		isXenon := *site.IsXenon
		destination.IsXenon = &isXenon
	} else {
		destination.IsXenon = nil
	}

	// KeyVaultReferenceIdentity
	destination.KeyVaultReferenceIdentity = genruntime.ClonePointerToString(site.KeyVaultReferenceIdentity)

	// Kind
	destination.Kind = genruntime.ClonePointerToString(site.Kind)

	// Location
	destination.Location = genruntime.ClonePointerToString(site.Location)

	// OriginalVersion
	destination.OriginalVersion = site.OriginalVersion()

	// Owner
	if site.Owner != nil {
		owner := site.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// PublicNetworkAccess
	destination.PublicNetworkAccess = genruntime.ClonePointerToString(site.PublicNetworkAccess)

	// RedundancyMode
	if site.RedundancyMode != nil {
		redundancyMode := string(*site.RedundancyMode)
		destination.RedundancyMode = &redundancyMode
	} else {
		destination.RedundancyMode = nil
	}

	// Reserved
	if site.Reserved != nil {
		reserved := *site.Reserved
		destination.Reserved = &reserved
	} else {
		destination.Reserved = nil
	}

	// ScmSiteAlsoStopped
	if site.ScmSiteAlsoStopped != nil {
		scmSiteAlsoStopped := *site.ScmSiteAlsoStopped
		destination.ScmSiteAlsoStopped = &scmSiteAlsoStopped
	} else {
		destination.ScmSiteAlsoStopped = nil
	}

	// ServerFarmReference
	if site.ServerFarmReference != nil {
		serverFarmReference := site.ServerFarmReference.Copy()
		destination.ServerFarmReference = &serverFarmReference
	} else {
		destination.ServerFarmReference = nil
	}

	// SiteConfig
	if site.SiteConfig != nil {
		var siteConfig v1beta20220301s.SiteConfig
		err := site.SiteConfig.AssignProperties_To_SiteConfig(&siteConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SiteConfig() to populate field SiteConfig")
		}
		destination.SiteConfig = &siteConfig
	} else {
		destination.SiteConfig = nil
	}

	// StorageAccountRequired
	if site.StorageAccountRequired != nil {
		storageAccountRequired := *site.StorageAccountRequired
		destination.StorageAccountRequired = &storageAccountRequired
	} else {
		destination.StorageAccountRequired = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(site.Tags)

	// VirtualNetworkSubnetReference
	if site.VirtualNetworkSubnetReference != nil {
		virtualNetworkSubnetReference := site.VirtualNetworkSubnetReference.Copy()
		destination.VirtualNetworkSubnetReference = &virtualNetworkSubnetReference
	} else {
		destination.VirtualNetworkSubnetReference = nil
	}

	// VnetContentShareEnabled
	if site.VnetContentShareEnabled != nil {
		vnetContentShareEnabled := *site.VnetContentShareEnabled
		destination.VnetContentShareEnabled = &vnetContentShareEnabled
	} else {
		destination.VnetContentShareEnabled = nil
	}

	// VnetImagePullEnabled
	if site.VnetImagePullEnabled != nil {
		vnetImagePullEnabled := *site.VnetImagePullEnabled
		destination.VnetImagePullEnabled = &vnetImagePullEnabled
	} else {
		destination.VnetImagePullEnabled = nil
	}

	// VnetRouteAllEnabled
	if site.VnetRouteAllEnabled != nil {
		vnetRouteAllEnabled := *site.VnetRouteAllEnabled
		destination.VnetRouteAllEnabled = &vnetRouteAllEnabled
	} else {
		destination.VnetRouteAllEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (site *Site_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (site *Site_Spec) SetAzureName(azureName string) { site.AzureName = azureName }

// Deprecated version of Site_STATUS. Use v1api20220301.Site_STATUS instead
type Site_STATUS struct {
	AvailabilityState        *Site_Properties_AvailabilityState_STATUS `json:"availabilityState,omitempty"`
	ClientAffinityEnabled    *bool                                     `json:"clientAffinityEnabled,omitempty"`
	ClientCertEnabled        *bool                                     `json:"clientCertEnabled,omitempty"`
	ClientCertExclusionPaths *string                                   `json:"clientCertExclusionPaths,omitempty"`
	ClientCertMode           *Site_Properties_ClientCertMode_STATUS    `json:"clientCertMode,omitempty"`
	CloningInfo              *CloningInfo_STATUS                       `json:"cloningInfo,omitempty"`

	// Conditions: The observed state of the resource
	Conditions                  []conditions.Condition                 `json:"conditions,omitempty"`
	ContainerSize               *int                                   `json:"containerSize,omitempty"`
	CustomDomainVerificationId  *string                                `json:"customDomainVerificationId,omitempty"`
	DailyMemoryTimeQuota        *int                                   `json:"dailyMemoryTimeQuota,omitempty"`
	DefaultHostName             *string                                `json:"defaultHostName,omitempty"`
	Enabled                     *bool                                  `json:"enabled,omitempty"`
	EnabledHostNames            []string                               `json:"enabledHostNames,omitempty"`
	ExtendedLocation            *ExtendedLocation_STATUS               `json:"extendedLocation,omitempty"`
	HostNameSslStates           []HostNameSslState_STATUS              `json:"hostNameSslStates,omitempty"`
	HostNames                   []string                               `json:"hostNames,omitempty"`
	HostNamesDisabled           *bool                                  `json:"hostNamesDisabled,omitempty"`
	HostingEnvironmentProfile   *HostingEnvironmentProfile_STATUS      `json:"hostingEnvironmentProfile,omitempty"`
	HttpsOnly                   *bool                                  `json:"httpsOnly,omitempty"`
	HyperV                      *bool                                  `json:"hyperV,omitempty"`
	Id                          *string                                `json:"id,omitempty"`
	Identity                    *ManagedServiceIdentity_STATUS         `json:"identity,omitempty"`
	InProgressOperationId       *string                                `json:"inProgressOperationId,omitempty"`
	IsDefaultContainer          *bool                                  `json:"isDefaultContainer,omitempty"`
	IsXenon                     *bool                                  `json:"isXenon,omitempty"`
	KeyVaultReferenceIdentity   *string                                `json:"keyVaultReferenceIdentity,omitempty"`
	Kind                        *string                                `json:"kind,omitempty"`
	LastModifiedTimeUtc         *string                                `json:"lastModifiedTimeUtc,omitempty"`
	Location                    *string                                `json:"location,omitempty"`
	MaxNumberOfWorkers          *int                                   `json:"maxNumberOfWorkers,omitempty"`
	Name                        *string                                `json:"name,omitempty"`
	OutboundIpAddresses         *string                                `json:"outboundIpAddresses,omitempty"`
	PossibleOutboundIpAddresses *string                                `json:"possibleOutboundIpAddresses,omitempty"`
	PublicNetworkAccess         *string                                `json:"publicNetworkAccess,omitempty"`
	RedundancyMode              *Site_Properties_RedundancyMode_STATUS `json:"redundancyMode,omitempty"`
	RepositorySiteName          *string                                `json:"repositorySiteName,omitempty"`
	Reserved                    *bool                                  `json:"reserved,omitempty"`
	ResourceGroup               *string                                `json:"resourceGroup,omitempty"`
	ScmSiteAlsoStopped          *bool                                  `json:"scmSiteAlsoStopped,omitempty"`
	ServerFarmId                *string                                `json:"serverFarmId,omitempty"`
	SiteConfig                  *SiteConfig_STATUS                     `json:"siteConfig,omitempty"`
	SlotSwapStatus              *SlotSwapStatus_STATUS                 `json:"slotSwapStatus,omitempty"`
	State                       *string                                `json:"state,omitempty"`
	StorageAccountRequired      *bool                                  `json:"storageAccountRequired,omitempty"`
	SuspendedTill               *string                                `json:"suspendedTill,omitempty"`
	Tags                        map[string]string                      `json:"tags,omitempty"`
	TargetSwapSlot              *string                                `json:"targetSwapSlot,omitempty"`
	TrafficManagerHostNames     []string                               `json:"trafficManagerHostNames,omitempty"`
	Type                        *string                                `json:"type,omitempty"`
	UsageState                  *Site_Properties_UsageState_STATUS     `json:"usageState,omitempty"`
	VirtualNetworkSubnetId      *string                                `json:"virtualNetworkSubnetId,omitempty"`
	VnetContentShareEnabled     *bool                                  `json:"vnetContentShareEnabled,omitempty"`
	VnetImagePullEnabled        *bool                                  `json:"vnetImagePullEnabled,omitempty"`
	VnetRouteAllEnabled         *bool                                  `json:"vnetRouteAllEnabled,omitempty"`
}

var _ genruntime.ConvertibleStatus = &Site_STATUS{}

// ConvertStatusFrom populates our Site_STATUS from the provided source
func (site *Site_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v1beta20220301s.Site_STATUS)
	if ok {
		// Populate our instance from source
		return site.AssignProperties_From_Site_STATUS(src)
	}

	// Convert to an intermediate form
	src = &v1beta20220301s.Site_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = site.AssignProperties_From_Site_STATUS(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our Site_STATUS
func (site *Site_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v1beta20220301s.Site_STATUS)
	if ok {
		// Populate destination from our instance
		return site.AssignProperties_To_Site_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &v1beta20220301s.Site_STATUS{}
	err := site.AssignProperties_To_Site_STATUS(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &Site_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (site *Site_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Site_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (site *Site_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Site_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Site_STATUS_ARM, got %T", armInput)
	}

	// Set property "AvailabilityState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AvailabilityState != nil {
			availabilityState := *typedInput.Properties.AvailabilityState
			site.AvailabilityState = &availabilityState
		}
	}

	// Set property "ClientAffinityEnabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ClientAffinityEnabled != nil {
			clientAffinityEnabled := *typedInput.Properties.ClientAffinityEnabled
			site.ClientAffinityEnabled = &clientAffinityEnabled
		}
	}

	// Set property "ClientCertEnabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ClientCertEnabled != nil {
			clientCertEnabled := *typedInput.Properties.ClientCertEnabled
			site.ClientCertEnabled = &clientCertEnabled
		}
	}

	// Set property "ClientCertExclusionPaths":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ClientCertExclusionPaths != nil {
			clientCertExclusionPaths := *typedInput.Properties.ClientCertExclusionPaths
			site.ClientCertExclusionPaths = &clientCertExclusionPaths
		}
	}

	// Set property "ClientCertMode":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ClientCertMode != nil {
			clientCertMode := *typedInput.Properties.ClientCertMode
			site.ClientCertMode = &clientCertMode
		}
	}

	// Set property "CloningInfo":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CloningInfo != nil {
			var cloningInfo1 CloningInfo_STATUS
			err := cloningInfo1.PopulateFromARM(owner, *typedInput.Properties.CloningInfo)
			if err != nil {
				return err
			}
			cloningInfo := cloningInfo1
			site.CloningInfo = &cloningInfo
		}
	}

	// no assignment for property "Conditions"

	// Set property "ContainerSize":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ContainerSize != nil {
			containerSize := *typedInput.Properties.ContainerSize
			site.ContainerSize = &containerSize
		}
	}

	// Set property "CustomDomainVerificationId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CustomDomainVerificationId != nil {
			customDomainVerificationId := *typedInput.Properties.CustomDomainVerificationId
			site.CustomDomainVerificationId = &customDomainVerificationId
		}
	}

	// Set property "DailyMemoryTimeQuota":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DailyMemoryTimeQuota != nil {
			dailyMemoryTimeQuota := *typedInput.Properties.DailyMemoryTimeQuota
			site.DailyMemoryTimeQuota = &dailyMemoryTimeQuota
		}
	}

	// Set property "DefaultHostName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DefaultHostName != nil {
			defaultHostName := *typedInput.Properties.DefaultHostName
			site.DefaultHostName = &defaultHostName
		}
	}

	// Set property "Enabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Enabled != nil {
			enabled := *typedInput.Properties.Enabled
			site.Enabled = &enabled
		}
	}

	// Set property "EnabledHostNames":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.EnabledHostNames {
			site.EnabledHostNames = append(site.EnabledHostNames, item)
		}
	}

	// Set property "ExtendedLocation":
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation_STATUS
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		site.ExtendedLocation = &extendedLocation
	}

	// Set property "HostNameSslStates":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.HostNameSslStates {
			var item1 HostNameSslState_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			site.HostNameSslStates = append(site.HostNameSslStates, item1)
		}
	}

	// Set property "HostNames":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.HostNames {
			site.HostNames = append(site.HostNames, item)
		}
	}

	// Set property "HostNamesDisabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HostNamesDisabled != nil {
			hostNamesDisabled := *typedInput.Properties.HostNamesDisabled
			site.HostNamesDisabled = &hostNamesDisabled
		}
	}

	// Set property "HostingEnvironmentProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HostingEnvironmentProfile != nil {
			var hostingEnvironmentProfile1 HostingEnvironmentProfile_STATUS
			err := hostingEnvironmentProfile1.PopulateFromARM(owner, *typedInput.Properties.HostingEnvironmentProfile)
			if err != nil {
				return err
			}
			hostingEnvironmentProfile := hostingEnvironmentProfile1
			site.HostingEnvironmentProfile = &hostingEnvironmentProfile
		}
	}

	// Set property "HttpsOnly":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HttpsOnly != nil {
			httpsOnly := *typedInput.Properties.HttpsOnly
			site.HttpsOnly = &httpsOnly
		}
	}

	// Set property "HyperV":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HyperV != nil {
			hyperV := *typedInput.Properties.HyperV
			site.HyperV = &hyperV
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		site.Id = &id
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 ManagedServiceIdentity_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		site.Identity = &identity
	}

	// Set property "InProgressOperationId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.InProgressOperationId != nil {
			inProgressOperationId := *typedInput.Properties.InProgressOperationId
			site.InProgressOperationId = &inProgressOperationId
		}
	}

	// Set property "IsDefaultContainer":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IsDefaultContainer != nil {
			isDefaultContainer := *typedInput.Properties.IsDefaultContainer
			site.IsDefaultContainer = &isDefaultContainer
		}
	}

	// Set property "IsXenon":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IsXenon != nil {
			isXenon := *typedInput.Properties.IsXenon
			site.IsXenon = &isXenon
		}
	}

	// Set property "KeyVaultReferenceIdentity":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.KeyVaultReferenceIdentity != nil {
			keyVaultReferenceIdentity := *typedInput.Properties.KeyVaultReferenceIdentity
			site.KeyVaultReferenceIdentity = &keyVaultReferenceIdentity
		}
	}

	// Set property "Kind":
	if typedInput.Kind != nil {
		kind := *typedInput.Kind
		site.Kind = &kind
	}

	// Set property "LastModifiedTimeUtc":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LastModifiedTimeUtc != nil {
			lastModifiedTimeUtc := *typedInput.Properties.LastModifiedTimeUtc
			site.LastModifiedTimeUtc = &lastModifiedTimeUtc
		}
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		site.Location = &location
	}

	// Set property "MaxNumberOfWorkers":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MaxNumberOfWorkers != nil {
			maxNumberOfWorkers := *typedInput.Properties.MaxNumberOfWorkers
			site.MaxNumberOfWorkers = &maxNumberOfWorkers
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		site.Name = &name
	}

	// Set property "OutboundIpAddresses":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.OutboundIpAddresses != nil {
			outboundIpAddresses := *typedInput.Properties.OutboundIpAddresses
			site.OutboundIpAddresses = &outboundIpAddresses
		}
	}

	// Set property "PossibleOutboundIpAddresses":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PossibleOutboundIpAddresses != nil {
			possibleOutboundIpAddresses := *typedInput.Properties.PossibleOutboundIpAddresses
			site.PossibleOutboundIpAddresses = &possibleOutboundIpAddresses
		}
	}

	// Set property "PublicNetworkAccess":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicNetworkAccess != nil {
			publicNetworkAccess := *typedInput.Properties.PublicNetworkAccess
			site.PublicNetworkAccess = &publicNetworkAccess
		}
	}

	// Set property "RedundancyMode":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RedundancyMode != nil {
			redundancyMode := *typedInput.Properties.RedundancyMode
			site.RedundancyMode = &redundancyMode
		}
	}

	// Set property "RepositorySiteName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RepositorySiteName != nil {
			repositorySiteName := *typedInput.Properties.RepositorySiteName
			site.RepositorySiteName = &repositorySiteName
		}
	}

	// Set property "Reserved":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Reserved != nil {
			reserved := *typedInput.Properties.Reserved
			site.Reserved = &reserved
		}
	}

	// Set property "ResourceGroup":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ResourceGroup != nil {
			resourceGroup := *typedInput.Properties.ResourceGroup
			site.ResourceGroup = &resourceGroup
		}
	}

	// Set property "ScmSiteAlsoStopped":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ScmSiteAlsoStopped != nil {
			scmSiteAlsoStopped := *typedInput.Properties.ScmSiteAlsoStopped
			site.ScmSiteAlsoStopped = &scmSiteAlsoStopped
		}
	}

	// Set property "ServerFarmId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ServerFarmId != nil {
			serverFarmId := *typedInput.Properties.ServerFarmId
			site.ServerFarmId = &serverFarmId
		}
	}

	// Set property "SiteConfig":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SiteConfig != nil {
			var siteConfig1 SiteConfig_STATUS
			err := siteConfig1.PopulateFromARM(owner, *typedInput.Properties.SiteConfig)
			if err != nil {
				return err
			}
			siteConfig := siteConfig1
			site.SiteConfig = &siteConfig
		}
	}

	// Set property "SlotSwapStatus":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SlotSwapStatus != nil {
			var slotSwapStatus1 SlotSwapStatus_STATUS
			err := slotSwapStatus1.PopulateFromARM(owner, *typedInput.Properties.SlotSwapStatus)
			if err != nil {
				return err
			}
			slotSwapStatus := slotSwapStatus1
			site.SlotSwapStatus = &slotSwapStatus
		}
	}

	// Set property "State":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.State != nil {
			state := *typedInput.Properties.State
			site.State = &state
		}
	}

	// Set property "StorageAccountRequired":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.StorageAccountRequired != nil {
			storageAccountRequired := *typedInput.Properties.StorageAccountRequired
			site.StorageAccountRequired = &storageAccountRequired
		}
	}

	// Set property "SuspendedTill":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SuspendedTill != nil {
			suspendedTill := *typedInput.Properties.SuspendedTill
			site.SuspendedTill = &suspendedTill
		}
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		site.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			site.Tags[key] = value
		}
	}

	// Set property "TargetSwapSlot":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TargetSwapSlot != nil {
			targetSwapSlot := *typedInput.Properties.TargetSwapSlot
			site.TargetSwapSlot = &targetSwapSlot
		}
	}

	// Set property "TrafficManagerHostNames":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.TrafficManagerHostNames {
			site.TrafficManagerHostNames = append(site.TrafficManagerHostNames, item)
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		site.Type = &typeVar
	}

	// Set property "UsageState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.UsageState != nil {
			usageState := *typedInput.Properties.UsageState
			site.UsageState = &usageState
		}
	}

	// Set property "VirtualNetworkSubnetId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VirtualNetworkSubnetId != nil {
			virtualNetworkSubnetId := *typedInput.Properties.VirtualNetworkSubnetId
			site.VirtualNetworkSubnetId = &virtualNetworkSubnetId
		}
	}

	// Set property "VnetContentShareEnabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VnetContentShareEnabled != nil {
			vnetContentShareEnabled := *typedInput.Properties.VnetContentShareEnabled
			site.VnetContentShareEnabled = &vnetContentShareEnabled
		}
	}

	// Set property "VnetImagePullEnabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VnetImagePullEnabled != nil {
			vnetImagePullEnabled := *typedInput.Properties.VnetImagePullEnabled
			site.VnetImagePullEnabled = &vnetImagePullEnabled
		}
	}

	// Set property "VnetRouteAllEnabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VnetRouteAllEnabled != nil {
			vnetRouteAllEnabled := *typedInput.Properties.VnetRouteAllEnabled
			site.VnetRouteAllEnabled = &vnetRouteAllEnabled
		}
	}

	// No error
	return nil
}

// AssignProperties_From_Site_STATUS populates our Site_STATUS from the provided source Site_STATUS
func (site *Site_STATUS) AssignProperties_From_Site_STATUS(source *v1beta20220301s.Site_STATUS) error {

	// AvailabilityState
	if source.AvailabilityState != nil {
		availabilityState := Site_Properties_AvailabilityState_STATUS(*source.AvailabilityState)
		site.AvailabilityState = &availabilityState
	} else {
		site.AvailabilityState = nil
	}

	// ClientAffinityEnabled
	if source.ClientAffinityEnabled != nil {
		clientAffinityEnabled := *source.ClientAffinityEnabled
		site.ClientAffinityEnabled = &clientAffinityEnabled
	} else {
		site.ClientAffinityEnabled = nil
	}

	// ClientCertEnabled
	if source.ClientCertEnabled != nil {
		clientCertEnabled := *source.ClientCertEnabled
		site.ClientCertEnabled = &clientCertEnabled
	} else {
		site.ClientCertEnabled = nil
	}

	// ClientCertExclusionPaths
	site.ClientCertExclusionPaths = genruntime.ClonePointerToString(source.ClientCertExclusionPaths)

	// ClientCertMode
	if source.ClientCertMode != nil {
		clientCertMode := Site_Properties_ClientCertMode_STATUS(*source.ClientCertMode)
		site.ClientCertMode = &clientCertMode
	} else {
		site.ClientCertMode = nil
	}

	// CloningInfo
	if source.CloningInfo != nil {
		var cloningInfo CloningInfo_STATUS
		err := cloningInfo.AssignProperties_From_CloningInfo_STATUS(source.CloningInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CloningInfo_STATUS() to populate field CloningInfo")
		}
		site.CloningInfo = &cloningInfo
	} else {
		site.CloningInfo = nil
	}

	// Conditions
	site.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// ContainerSize
	site.ContainerSize = genruntime.ClonePointerToInt(source.ContainerSize)

	// CustomDomainVerificationId
	site.CustomDomainVerificationId = genruntime.ClonePointerToString(source.CustomDomainVerificationId)

	// DailyMemoryTimeQuota
	site.DailyMemoryTimeQuota = genruntime.ClonePointerToInt(source.DailyMemoryTimeQuota)

	// DefaultHostName
	site.DefaultHostName = genruntime.ClonePointerToString(source.DefaultHostName)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		site.Enabled = &enabled
	} else {
		site.Enabled = nil
	}

	// EnabledHostNames
	site.EnabledHostNames = genruntime.CloneSliceOfString(source.EnabledHostNames)

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation_STATUS
		err := extendedLocation.AssignProperties_From_ExtendedLocation_STATUS(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ExtendedLocation_STATUS() to populate field ExtendedLocation")
		}
		site.ExtendedLocation = &extendedLocation
	} else {
		site.ExtendedLocation = nil
	}

	// HostNameSslStates
	if source.HostNameSslStates != nil {
		hostNameSslStateList := make([]HostNameSslState_STATUS, len(source.HostNameSslStates))
		for hostNameSslStateIndex, hostNameSslStateItem := range source.HostNameSslStates {
			// Shadow the loop variable to avoid aliasing
			hostNameSslStateItem := hostNameSslStateItem
			var hostNameSslState HostNameSslState_STATUS
			err := hostNameSslState.AssignProperties_From_HostNameSslState_STATUS(&hostNameSslStateItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_HostNameSslState_STATUS() to populate field HostNameSslStates")
			}
			hostNameSslStateList[hostNameSslStateIndex] = hostNameSslState
		}
		site.HostNameSslStates = hostNameSslStateList
	} else {
		site.HostNameSslStates = nil
	}

	// HostNames
	site.HostNames = genruntime.CloneSliceOfString(source.HostNames)

	// HostNamesDisabled
	if source.HostNamesDisabled != nil {
		hostNamesDisabled := *source.HostNamesDisabled
		site.HostNamesDisabled = &hostNamesDisabled
	} else {
		site.HostNamesDisabled = nil
	}

	// HostingEnvironmentProfile
	if source.HostingEnvironmentProfile != nil {
		var hostingEnvironmentProfile HostingEnvironmentProfile_STATUS
		err := hostingEnvironmentProfile.AssignProperties_From_HostingEnvironmentProfile_STATUS(source.HostingEnvironmentProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HostingEnvironmentProfile_STATUS() to populate field HostingEnvironmentProfile")
		}
		site.HostingEnvironmentProfile = &hostingEnvironmentProfile
	} else {
		site.HostingEnvironmentProfile = nil
	}

	// HttpsOnly
	if source.HttpsOnly != nil {
		httpsOnly := *source.HttpsOnly
		site.HttpsOnly = &httpsOnly
	} else {
		site.HttpsOnly = nil
	}

	// HyperV
	if source.HyperV != nil {
		hyperV := *source.HyperV
		site.HyperV = &hyperV
	} else {
		site.HyperV = nil
	}

	// Id
	site.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity ManagedServiceIdentity_STATUS
		err := identity.AssignProperties_From_ManagedServiceIdentity_STATUS(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedServiceIdentity_STATUS() to populate field Identity")
		}
		site.Identity = &identity
	} else {
		site.Identity = nil
	}

	// InProgressOperationId
	site.InProgressOperationId = genruntime.ClonePointerToString(source.InProgressOperationId)

	// IsDefaultContainer
	if source.IsDefaultContainer != nil {
		isDefaultContainer := *source.IsDefaultContainer
		site.IsDefaultContainer = &isDefaultContainer
	} else {
		site.IsDefaultContainer = nil
	}

	// IsXenon
	if source.IsXenon != nil {
		isXenon := *source.IsXenon
		site.IsXenon = &isXenon
	} else {
		site.IsXenon = nil
	}

	// KeyVaultReferenceIdentity
	site.KeyVaultReferenceIdentity = genruntime.ClonePointerToString(source.KeyVaultReferenceIdentity)

	// Kind
	site.Kind = genruntime.ClonePointerToString(source.Kind)

	// LastModifiedTimeUtc
	site.LastModifiedTimeUtc = genruntime.ClonePointerToString(source.LastModifiedTimeUtc)

	// Location
	site.Location = genruntime.ClonePointerToString(source.Location)

	// MaxNumberOfWorkers
	site.MaxNumberOfWorkers = genruntime.ClonePointerToInt(source.MaxNumberOfWorkers)

	// Name
	site.Name = genruntime.ClonePointerToString(source.Name)

	// OutboundIpAddresses
	site.OutboundIpAddresses = genruntime.ClonePointerToString(source.OutboundIpAddresses)

	// PossibleOutboundIpAddresses
	site.PossibleOutboundIpAddresses = genruntime.ClonePointerToString(source.PossibleOutboundIpAddresses)

	// PublicNetworkAccess
	site.PublicNetworkAccess = genruntime.ClonePointerToString(source.PublicNetworkAccess)

	// RedundancyMode
	if source.RedundancyMode != nil {
		redundancyMode := Site_Properties_RedundancyMode_STATUS(*source.RedundancyMode)
		site.RedundancyMode = &redundancyMode
	} else {
		site.RedundancyMode = nil
	}

	// RepositorySiteName
	site.RepositorySiteName = genruntime.ClonePointerToString(source.RepositorySiteName)

	// Reserved
	if source.Reserved != nil {
		reserved := *source.Reserved
		site.Reserved = &reserved
	} else {
		site.Reserved = nil
	}

	// ResourceGroup
	site.ResourceGroup = genruntime.ClonePointerToString(source.ResourceGroup)

	// ScmSiteAlsoStopped
	if source.ScmSiteAlsoStopped != nil {
		scmSiteAlsoStopped := *source.ScmSiteAlsoStopped
		site.ScmSiteAlsoStopped = &scmSiteAlsoStopped
	} else {
		site.ScmSiteAlsoStopped = nil
	}

	// ServerFarmId
	site.ServerFarmId = genruntime.ClonePointerToString(source.ServerFarmId)

	// SiteConfig
	if source.SiteConfig != nil {
		var siteConfig SiteConfig_STATUS
		err := siteConfig.AssignProperties_From_SiteConfig_STATUS(source.SiteConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SiteConfig_STATUS() to populate field SiteConfig")
		}
		site.SiteConfig = &siteConfig
	} else {
		site.SiteConfig = nil
	}

	// SlotSwapStatus
	if source.SlotSwapStatus != nil {
		var slotSwapStatus SlotSwapStatus_STATUS
		err := slotSwapStatus.AssignProperties_From_SlotSwapStatus_STATUS(source.SlotSwapStatus)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SlotSwapStatus_STATUS() to populate field SlotSwapStatus")
		}
		site.SlotSwapStatus = &slotSwapStatus
	} else {
		site.SlotSwapStatus = nil
	}

	// State
	site.State = genruntime.ClonePointerToString(source.State)

	// StorageAccountRequired
	if source.StorageAccountRequired != nil {
		storageAccountRequired := *source.StorageAccountRequired
		site.StorageAccountRequired = &storageAccountRequired
	} else {
		site.StorageAccountRequired = nil
	}

	// SuspendedTill
	site.SuspendedTill = genruntime.ClonePointerToString(source.SuspendedTill)

	// Tags
	site.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// TargetSwapSlot
	site.TargetSwapSlot = genruntime.ClonePointerToString(source.TargetSwapSlot)

	// TrafficManagerHostNames
	site.TrafficManagerHostNames = genruntime.CloneSliceOfString(source.TrafficManagerHostNames)

	// Type
	site.Type = genruntime.ClonePointerToString(source.Type)

	// UsageState
	if source.UsageState != nil {
		usageState := Site_Properties_UsageState_STATUS(*source.UsageState)
		site.UsageState = &usageState
	} else {
		site.UsageState = nil
	}

	// VirtualNetworkSubnetId
	site.VirtualNetworkSubnetId = genruntime.ClonePointerToString(source.VirtualNetworkSubnetId)

	// VnetContentShareEnabled
	if source.VnetContentShareEnabled != nil {
		vnetContentShareEnabled := *source.VnetContentShareEnabled
		site.VnetContentShareEnabled = &vnetContentShareEnabled
	} else {
		site.VnetContentShareEnabled = nil
	}

	// VnetImagePullEnabled
	if source.VnetImagePullEnabled != nil {
		vnetImagePullEnabled := *source.VnetImagePullEnabled
		site.VnetImagePullEnabled = &vnetImagePullEnabled
	} else {
		site.VnetImagePullEnabled = nil
	}

	// VnetRouteAllEnabled
	if source.VnetRouteAllEnabled != nil {
		vnetRouteAllEnabled := *source.VnetRouteAllEnabled
		site.VnetRouteAllEnabled = &vnetRouteAllEnabled
	} else {
		site.VnetRouteAllEnabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Site_STATUS populates the provided destination Site_STATUS from our Site_STATUS
func (site *Site_STATUS) AssignProperties_To_Site_STATUS(destination *v1beta20220301s.Site_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AvailabilityState
	if site.AvailabilityState != nil {
		availabilityState := string(*site.AvailabilityState)
		destination.AvailabilityState = &availabilityState
	} else {
		destination.AvailabilityState = nil
	}

	// ClientAffinityEnabled
	if site.ClientAffinityEnabled != nil {
		clientAffinityEnabled := *site.ClientAffinityEnabled
		destination.ClientAffinityEnabled = &clientAffinityEnabled
	} else {
		destination.ClientAffinityEnabled = nil
	}

	// ClientCertEnabled
	if site.ClientCertEnabled != nil {
		clientCertEnabled := *site.ClientCertEnabled
		destination.ClientCertEnabled = &clientCertEnabled
	} else {
		destination.ClientCertEnabled = nil
	}

	// ClientCertExclusionPaths
	destination.ClientCertExclusionPaths = genruntime.ClonePointerToString(site.ClientCertExclusionPaths)

	// ClientCertMode
	if site.ClientCertMode != nil {
		clientCertMode := string(*site.ClientCertMode)
		destination.ClientCertMode = &clientCertMode
	} else {
		destination.ClientCertMode = nil
	}

	// CloningInfo
	if site.CloningInfo != nil {
		var cloningInfo v1beta20220301s.CloningInfo_STATUS
		err := site.CloningInfo.AssignProperties_To_CloningInfo_STATUS(&cloningInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CloningInfo_STATUS() to populate field CloningInfo")
		}
		destination.CloningInfo = &cloningInfo
	} else {
		destination.CloningInfo = nil
	}

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(site.Conditions)

	// ContainerSize
	destination.ContainerSize = genruntime.ClonePointerToInt(site.ContainerSize)

	// CustomDomainVerificationId
	destination.CustomDomainVerificationId = genruntime.ClonePointerToString(site.CustomDomainVerificationId)

	// DailyMemoryTimeQuota
	destination.DailyMemoryTimeQuota = genruntime.ClonePointerToInt(site.DailyMemoryTimeQuota)

	// DefaultHostName
	destination.DefaultHostName = genruntime.ClonePointerToString(site.DefaultHostName)

	// Enabled
	if site.Enabled != nil {
		enabled := *site.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// EnabledHostNames
	destination.EnabledHostNames = genruntime.CloneSliceOfString(site.EnabledHostNames)

	// ExtendedLocation
	if site.ExtendedLocation != nil {
		var extendedLocation v1beta20220301s.ExtendedLocation_STATUS
		err := site.ExtendedLocation.AssignProperties_To_ExtendedLocation_STATUS(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ExtendedLocation_STATUS() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// HostNameSslStates
	if site.HostNameSslStates != nil {
		hostNameSslStateList := make([]v1beta20220301s.HostNameSslState_STATUS, len(site.HostNameSslStates))
		for hostNameSslStateIndex, hostNameSslStateItem := range site.HostNameSslStates {
			// Shadow the loop variable to avoid aliasing
			hostNameSslStateItem := hostNameSslStateItem
			var hostNameSslState v1beta20220301s.HostNameSslState_STATUS
			err := hostNameSslStateItem.AssignProperties_To_HostNameSslState_STATUS(&hostNameSslState)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_HostNameSslState_STATUS() to populate field HostNameSslStates")
			}
			hostNameSslStateList[hostNameSslStateIndex] = hostNameSslState
		}
		destination.HostNameSslStates = hostNameSslStateList
	} else {
		destination.HostNameSslStates = nil
	}

	// HostNames
	destination.HostNames = genruntime.CloneSliceOfString(site.HostNames)

	// HostNamesDisabled
	if site.HostNamesDisabled != nil {
		hostNamesDisabled := *site.HostNamesDisabled
		destination.HostNamesDisabled = &hostNamesDisabled
	} else {
		destination.HostNamesDisabled = nil
	}

	// HostingEnvironmentProfile
	if site.HostingEnvironmentProfile != nil {
		var hostingEnvironmentProfile v1beta20220301s.HostingEnvironmentProfile_STATUS
		err := site.HostingEnvironmentProfile.AssignProperties_To_HostingEnvironmentProfile_STATUS(&hostingEnvironmentProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HostingEnvironmentProfile_STATUS() to populate field HostingEnvironmentProfile")
		}
		destination.HostingEnvironmentProfile = &hostingEnvironmentProfile
	} else {
		destination.HostingEnvironmentProfile = nil
	}

	// HttpsOnly
	if site.HttpsOnly != nil {
		httpsOnly := *site.HttpsOnly
		destination.HttpsOnly = &httpsOnly
	} else {
		destination.HttpsOnly = nil
	}

	// HyperV
	if site.HyperV != nil {
		hyperV := *site.HyperV
		destination.HyperV = &hyperV
	} else {
		destination.HyperV = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(site.Id)

	// Identity
	if site.Identity != nil {
		var identity v1beta20220301s.ManagedServiceIdentity_STATUS
		err := site.Identity.AssignProperties_To_ManagedServiceIdentity_STATUS(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedServiceIdentity_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// InProgressOperationId
	destination.InProgressOperationId = genruntime.ClonePointerToString(site.InProgressOperationId)

	// IsDefaultContainer
	if site.IsDefaultContainer != nil {
		isDefaultContainer := *site.IsDefaultContainer
		destination.IsDefaultContainer = &isDefaultContainer
	} else {
		destination.IsDefaultContainer = nil
	}

	// IsXenon
	if site.IsXenon != nil {
		isXenon := *site.IsXenon
		destination.IsXenon = &isXenon
	} else {
		destination.IsXenon = nil
	}

	// KeyVaultReferenceIdentity
	destination.KeyVaultReferenceIdentity = genruntime.ClonePointerToString(site.KeyVaultReferenceIdentity)

	// Kind
	destination.Kind = genruntime.ClonePointerToString(site.Kind)

	// LastModifiedTimeUtc
	destination.LastModifiedTimeUtc = genruntime.ClonePointerToString(site.LastModifiedTimeUtc)

	// Location
	destination.Location = genruntime.ClonePointerToString(site.Location)

	// MaxNumberOfWorkers
	destination.MaxNumberOfWorkers = genruntime.ClonePointerToInt(site.MaxNumberOfWorkers)

	// Name
	destination.Name = genruntime.ClonePointerToString(site.Name)

	// OutboundIpAddresses
	destination.OutboundIpAddresses = genruntime.ClonePointerToString(site.OutboundIpAddresses)

	// PossibleOutboundIpAddresses
	destination.PossibleOutboundIpAddresses = genruntime.ClonePointerToString(site.PossibleOutboundIpAddresses)

	// PublicNetworkAccess
	destination.PublicNetworkAccess = genruntime.ClonePointerToString(site.PublicNetworkAccess)

	// RedundancyMode
	if site.RedundancyMode != nil {
		redundancyMode := string(*site.RedundancyMode)
		destination.RedundancyMode = &redundancyMode
	} else {
		destination.RedundancyMode = nil
	}

	// RepositorySiteName
	destination.RepositorySiteName = genruntime.ClonePointerToString(site.RepositorySiteName)

	// Reserved
	if site.Reserved != nil {
		reserved := *site.Reserved
		destination.Reserved = &reserved
	} else {
		destination.Reserved = nil
	}

	// ResourceGroup
	destination.ResourceGroup = genruntime.ClonePointerToString(site.ResourceGroup)

	// ScmSiteAlsoStopped
	if site.ScmSiteAlsoStopped != nil {
		scmSiteAlsoStopped := *site.ScmSiteAlsoStopped
		destination.ScmSiteAlsoStopped = &scmSiteAlsoStopped
	} else {
		destination.ScmSiteAlsoStopped = nil
	}

	// ServerFarmId
	destination.ServerFarmId = genruntime.ClonePointerToString(site.ServerFarmId)

	// SiteConfig
	if site.SiteConfig != nil {
		var siteConfig v1beta20220301s.SiteConfig_STATUS
		err := site.SiteConfig.AssignProperties_To_SiteConfig_STATUS(&siteConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SiteConfig_STATUS() to populate field SiteConfig")
		}
		destination.SiteConfig = &siteConfig
	} else {
		destination.SiteConfig = nil
	}

	// SlotSwapStatus
	if site.SlotSwapStatus != nil {
		var slotSwapStatus v1beta20220301s.SlotSwapStatus_STATUS
		err := site.SlotSwapStatus.AssignProperties_To_SlotSwapStatus_STATUS(&slotSwapStatus)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SlotSwapStatus_STATUS() to populate field SlotSwapStatus")
		}
		destination.SlotSwapStatus = &slotSwapStatus
	} else {
		destination.SlotSwapStatus = nil
	}

	// State
	destination.State = genruntime.ClonePointerToString(site.State)

	// StorageAccountRequired
	if site.StorageAccountRequired != nil {
		storageAccountRequired := *site.StorageAccountRequired
		destination.StorageAccountRequired = &storageAccountRequired
	} else {
		destination.StorageAccountRequired = nil
	}

	// SuspendedTill
	destination.SuspendedTill = genruntime.ClonePointerToString(site.SuspendedTill)

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(site.Tags)

	// TargetSwapSlot
	destination.TargetSwapSlot = genruntime.ClonePointerToString(site.TargetSwapSlot)

	// TrafficManagerHostNames
	destination.TrafficManagerHostNames = genruntime.CloneSliceOfString(site.TrafficManagerHostNames)

	// Type
	destination.Type = genruntime.ClonePointerToString(site.Type)

	// UsageState
	if site.UsageState != nil {
		usageState := string(*site.UsageState)
		destination.UsageState = &usageState
	} else {
		destination.UsageState = nil
	}

	// VirtualNetworkSubnetId
	destination.VirtualNetworkSubnetId = genruntime.ClonePointerToString(site.VirtualNetworkSubnetId)

	// VnetContentShareEnabled
	if site.VnetContentShareEnabled != nil {
		vnetContentShareEnabled := *site.VnetContentShareEnabled
		destination.VnetContentShareEnabled = &vnetContentShareEnabled
	} else {
		destination.VnetContentShareEnabled = nil
	}

	// VnetImagePullEnabled
	if site.VnetImagePullEnabled != nil {
		vnetImagePullEnabled := *site.VnetImagePullEnabled
		destination.VnetImagePullEnabled = &vnetImagePullEnabled
	} else {
		destination.VnetImagePullEnabled = nil
	}

	// VnetRouteAllEnabled
	if site.VnetRouteAllEnabled != nil {
		vnetRouteAllEnabled := *site.VnetRouteAllEnabled
		destination.VnetRouteAllEnabled = &vnetRouteAllEnabled
	} else {
		destination.VnetRouteAllEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of CloningInfo. Use v1api20220301.CloningInfo instead
type CloningInfo struct {
	AppSettingsOverrides   map[string]string `json:"appSettingsOverrides,omitempty"`
	CloneCustomHostNames   *bool             `json:"cloneCustomHostNames,omitempty"`
	CloneSourceControl     *bool             `json:"cloneSourceControl,omitempty"`
	ConfigureLoadBalancing *bool             `json:"configureLoadBalancing,omitempty"`

	// +kubebuilder:validation:Pattern="^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$"
	CorrelationId        *string `json:"correlationId,omitempty"`
	HostingEnvironment   *string `json:"hostingEnvironment,omitempty"`
	Overwrite            *bool   `json:"overwrite,omitempty"`
	SourceWebAppLocation *string `json:"sourceWebAppLocation,omitempty"`

	// +kubebuilder:validation:Required
	SourceWebAppReference          *genruntime.ResourceReference `armReference:"SourceWebAppId" json:"sourceWebAppReference,omitempty"`
	TrafficManagerProfileName      *string                       `json:"trafficManagerProfileName,omitempty"`
	TrafficManagerProfileReference *genruntime.ResourceReference `armReference:"TrafficManagerProfileId" json:"trafficManagerProfileReference,omitempty"`
}

var _ genruntime.ARMTransformer = &CloningInfo{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (info *CloningInfo) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if info == nil {
		return nil, nil
	}
	result := &CloningInfo_ARM{}

	// Set property "AppSettingsOverrides":
	if info.AppSettingsOverrides != nil {
		result.AppSettingsOverrides = make(map[string]string, len(info.AppSettingsOverrides))
		for key, value := range info.AppSettingsOverrides {
			result.AppSettingsOverrides[key] = value
		}
	}

	// Set property "CloneCustomHostNames":
	if info.CloneCustomHostNames != nil {
		cloneCustomHostNames := *info.CloneCustomHostNames
		result.CloneCustomHostNames = &cloneCustomHostNames
	}

	// Set property "CloneSourceControl":
	if info.CloneSourceControl != nil {
		cloneSourceControl := *info.CloneSourceControl
		result.CloneSourceControl = &cloneSourceControl
	}

	// Set property "ConfigureLoadBalancing":
	if info.ConfigureLoadBalancing != nil {
		configureLoadBalancing := *info.ConfigureLoadBalancing
		result.ConfigureLoadBalancing = &configureLoadBalancing
	}

	// Set property "CorrelationId":
	if info.CorrelationId != nil {
		correlationId := *info.CorrelationId
		result.CorrelationId = &correlationId
	}

	// Set property "HostingEnvironment":
	if info.HostingEnvironment != nil {
		hostingEnvironment := *info.HostingEnvironment
		result.HostingEnvironment = &hostingEnvironment
	}

	// Set property "Overwrite":
	if info.Overwrite != nil {
		overwrite := *info.Overwrite
		result.Overwrite = &overwrite
	}

	// Set property "SourceWebAppId":
	if info.SourceWebAppReference != nil {
		sourceWebAppReferenceARMID, err := resolved.ResolvedReferences.Lookup(*info.SourceWebAppReference)
		if err != nil {
			return nil, err
		}
		sourceWebAppReference := sourceWebAppReferenceARMID
		result.SourceWebAppId = &sourceWebAppReference
	}

	// Set property "SourceWebAppLocation":
	if info.SourceWebAppLocation != nil {
		sourceWebAppLocation := *info.SourceWebAppLocation
		result.SourceWebAppLocation = &sourceWebAppLocation
	}

	// Set property "TrafficManagerProfileId":
	if info.TrafficManagerProfileReference != nil {
		trafficManagerProfileReferenceARMID, err := resolved.ResolvedReferences.Lookup(*info.TrafficManagerProfileReference)
		if err != nil {
			return nil, err
		}
		trafficManagerProfileReference := trafficManagerProfileReferenceARMID
		result.TrafficManagerProfileId = &trafficManagerProfileReference
	}

	// Set property "TrafficManagerProfileName":
	if info.TrafficManagerProfileName != nil {
		trafficManagerProfileName := *info.TrafficManagerProfileName
		result.TrafficManagerProfileName = &trafficManagerProfileName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (info *CloningInfo) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &CloningInfo_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (info *CloningInfo) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(CloningInfo_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CloningInfo_ARM, got %T", armInput)
	}

	// Set property "AppSettingsOverrides":
	if typedInput.AppSettingsOverrides != nil {
		info.AppSettingsOverrides = make(map[string]string, len(typedInput.AppSettingsOverrides))
		for key, value := range typedInput.AppSettingsOverrides {
			info.AppSettingsOverrides[key] = value
		}
	}

	// Set property "CloneCustomHostNames":
	if typedInput.CloneCustomHostNames != nil {
		cloneCustomHostNames := *typedInput.CloneCustomHostNames
		info.CloneCustomHostNames = &cloneCustomHostNames
	}

	// Set property "CloneSourceControl":
	if typedInput.CloneSourceControl != nil {
		cloneSourceControl := *typedInput.CloneSourceControl
		info.CloneSourceControl = &cloneSourceControl
	}

	// Set property "ConfigureLoadBalancing":
	if typedInput.ConfigureLoadBalancing != nil {
		configureLoadBalancing := *typedInput.ConfigureLoadBalancing
		info.ConfigureLoadBalancing = &configureLoadBalancing
	}

	// Set property "CorrelationId":
	if typedInput.CorrelationId != nil {
		correlationId := *typedInput.CorrelationId
		info.CorrelationId = &correlationId
	}

	// Set property "HostingEnvironment":
	if typedInput.HostingEnvironment != nil {
		hostingEnvironment := *typedInput.HostingEnvironment
		info.HostingEnvironment = &hostingEnvironment
	}

	// Set property "Overwrite":
	if typedInput.Overwrite != nil {
		overwrite := *typedInput.Overwrite
		info.Overwrite = &overwrite
	}

	// Set property "SourceWebAppLocation":
	if typedInput.SourceWebAppLocation != nil {
		sourceWebAppLocation := *typedInput.SourceWebAppLocation
		info.SourceWebAppLocation = &sourceWebAppLocation
	}

	// no assignment for property "SourceWebAppReference"

	// Set property "TrafficManagerProfileName":
	if typedInput.TrafficManagerProfileName != nil {
		trafficManagerProfileName := *typedInput.TrafficManagerProfileName
		info.TrafficManagerProfileName = &trafficManagerProfileName
	}

	// no assignment for property "TrafficManagerProfileReference"

	// No error
	return nil
}

// AssignProperties_From_CloningInfo populates our CloningInfo from the provided source CloningInfo
func (info *CloningInfo) AssignProperties_From_CloningInfo(source *v1beta20220301s.CloningInfo) error {

	// AppSettingsOverrides
	info.AppSettingsOverrides = genruntime.CloneMapOfStringToString(source.AppSettingsOverrides)

	// CloneCustomHostNames
	if source.CloneCustomHostNames != nil {
		cloneCustomHostName := *source.CloneCustomHostNames
		info.CloneCustomHostNames = &cloneCustomHostName
	} else {
		info.CloneCustomHostNames = nil
	}

	// CloneSourceControl
	if source.CloneSourceControl != nil {
		cloneSourceControl := *source.CloneSourceControl
		info.CloneSourceControl = &cloneSourceControl
	} else {
		info.CloneSourceControl = nil
	}

	// ConfigureLoadBalancing
	if source.ConfigureLoadBalancing != nil {
		configureLoadBalancing := *source.ConfigureLoadBalancing
		info.ConfigureLoadBalancing = &configureLoadBalancing
	} else {
		info.ConfigureLoadBalancing = nil
	}

	// CorrelationId
	if source.CorrelationId != nil {
		correlationId := *source.CorrelationId
		info.CorrelationId = &correlationId
	} else {
		info.CorrelationId = nil
	}

	// HostingEnvironment
	info.HostingEnvironment = genruntime.ClonePointerToString(source.HostingEnvironment)

	// Overwrite
	if source.Overwrite != nil {
		overwrite := *source.Overwrite
		info.Overwrite = &overwrite
	} else {
		info.Overwrite = nil
	}

	// SourceWebAppLocation
	info.SourceWebAppLocation = genruntime.ClonePointerToString(source.SourceWebAppLocation)

	// SourceWebAppReference
	if source.SourceWebAppReference != nil {
		sourceWebAppReference := source.SourceWebAppReference.Copy()
		info.SourceWebAppReference = &sourceWebAppReference
	} else {
		info.SourceWebAppReference = nil
	}

	// TrafficManagerProfileName
	info.TrafficManagerProfileName = genruntime.ClonePointerToString(source.TrafficManagerProfileName)

	// TrafficManagerProfileReference
	if source.TrafficManagerProfileReference != nil {
		trafficManagerProfileReference := source.TrafficManagerProfileReference.Copy()
		info.TrafficManagerProfileReference = &trafficManagerProfileReference
	} else {
		info.TrafficManagerProfileReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CloningInfo populates the provided destination CloningInfo from our CloningInfo
func (info *CloningInfo) AssignProperties_To_CloningInfo(destination *v1beta20220301s.CloningInfo) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AppSettingsOverrides
	destination.AppSettingsOverrides = genruntime.CloneMapOfStringToString(info.AppSettingsOverrides)

	// CloneCustomHostNames
	if info.CloneCustomHostNames != nil {
		cloneCustomHostName := *info.CloneCustomHostNames
		destination.CloneCustomHostNames = &cloneCustomHostName
	} else {
		destination.CloneCustomHostNames = nil
	}

	// CloneSourceControl
	if info.CloneSourceControl != nil {
		cloneSourceControl := *info.CloneSourceControl
		destination.CloneSourceControl = &cloneSourceControl
	} else {
		destination.CloneSourceControl = nil
	}

	// ConfigureLoadBalancing
	if info.ConfigureLoadBalancing != nil {
		configureLoadBalancing := *info.ConfigureLoadBalancing
		destination.ConfigureLoadBalancing = &configureLoadBalancing
	} else {
		destination.ConfigureLoadBalancing = nil
	}

	// CorrelationId
	if info.CorrelationId != nil {
		correlationId := *info.CorrelationId
		destination.CorrelationId = &correlationId
	} else {
		destination.CorrelationId = nil
	}

	// HostingEnvironment
	destination.HostingEnvironment = genruntime.ClonePointerToString(info.HostingEnvironment)

	// Overwrite
	if info.Overwrite != nil {
		overwrite := *info.Overwrite
		destination.Overwrite = &overwrite
	} else {
		destination.Overwrite = nil
	}

	// SourceWebAppLocation
	destination.SourceWebAppLocation = genruntime.ClonePointerToString(info.SourceWebAppLocation)

	// SourceWebAppReference
	if info.SourceWebAppReference != nil {
		sourceWebAppReference := info.SourceWebAppReference.Copy()
		destination.SourceWebAppReference = &sourceWebAppReference
	} else {
		destination.SourceWebAppReference = nil
	}

	// TrafficManagerProfileName
	destination.TrafficManagerProfileName = genruntime.ClonePointerToString(info.TrafficManagerProfileName)

	// TrafficManagerProfileReference
	if info.TrafficManagerProfileReference != nil {
		trafficManagerProfileReference := info.TrafficManagerProfileReference.Copy()
		destination.TrafficManagerProfileReference = &trafficManagerProfileReference
	} else {
		destination.TrafficManagerProfileReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of CloningInfo_STATUS. Use v1api20220301.CloningInfo_STATUS instead
type CloningInfo_STATUS struct {
	AppSettingsOverrides      map[string]string `json:"appSettingsOverrides,omitempty"`
	CloneCustomHostNames      *bool             `json:"cloneCustomHostNames,omitempty"`
	CloneSourceControl        *bool             `json:"cloneSourceControl,omitempty"`
	ConfigureLoadBalancing    *bool             `json:"configureLoadBalancing,omitempty"`
	CorrelationId             *string           `json:"correlationId,omitempty"`
	HostingEnvironment        *string           `json:"hostingEnvironment,omitempty"`
	Overwrite                 *bool             `json:"overwrite,omitempty"`
	SourceWebAppId            *string           `json:"sourceWebAppId,omitempty"`
	SourceWebAppLocation      *string           `json:"sourceWebAppLocation,omitempty"`
	TrafficManagerProfileId   *string           `json:"trafficManagerProfileId,omitempty"`
	TrafficManagerProfileName *string           `json:"trafficManagerProfileName,omitempty"`
}

var _ genruntime.FromARMConverter = &CloningInfo_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (info *CloningInfo_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &CloningInfo_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (info *CloningInfo_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(CloningInfo_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CloningInfo_STATUS_ARM, got %T", armInput)
	}

	// Set property "AppSettingsOverrides":
	if typedInput.AppSettingsOverrides != nil {
		info.AppSettingsOverrides = make(map[string]string, len(typedInput.AppSettingsOverrides))
		for key, value := range typedInput.AppSettingsOverrides {
			info.AppSettingsOverrides[key] = value
		}
	}

	// Set property "CloneCustomHostNames":
	if typedInput.CloneCustomHostNames != nil {
		cloneCustomHostNames := *typedInput.CloneCustomHostNames
		info.CloneCustomHostNames = &cloneCustomHostNames
	}

	// Set property "CloneSourceControl":
	if typedInput.CloneSourceControl != nil {
		cloneSourceControl := *typedInput.CloneSourceControl
		info.CloneSourceControl = &cloneSourceControl
	}

	// Set property "ConfigureLoadBalancing":
	if typedInput.ConfigureLoadBalancing != nil {
		configureLoadBalancing := *typedInput.ConfigureLoadBalancing
		info.ConfigureLoadBalancing = &configureLoadBalancing
	}

	// Set property "CorrelationId":
	if typedInput.CorrelationId != nil {
		correlationId := *typedInput.CorrelationId
		info.CorrelationId = &correlationId
	}

	// Set property "HostingEnvironment":
	if typedInput.HostingEnvironment != nil {
		hostingEnvironment := *typedInput.HostingEnvironment
		info.HostingEnvironment = &hostingEnvironment
	}

	// Set property "Overwrite":
	if typedInput.Overwrite != nil {
		overwrite := *typedInput.Overwrite
		info.Overwrite = &overwrite
	}

	// Set property "SourceWebAppId":
	if typedInput.SourceWebAppId != nil {
		sourceWebAppId := *typedInput.SourceWebAppId
		info.SourceWebAppId = &sourceWebAppId
	}

	// Set property "SourceWebAppLocation":
	if typedInput.SourceWebAppLocation != nil {
		sourceWebAppLocation := *typedInput.SourceWebAppLocation
		info.SourceWebAppLocation = &sourceWebAppLocation
	}

	// Set property "TrafficManagerProfileId":
	if typedInput.TrafficManagerProfileId != nil {
		trafficManagerProfileId := *typedInput.TrafficManagerProfileId
		info.TrafficManagerProfileId = &trafficManagerProfileId
	}

	// Set property "TrafficManagerProfileName":
	if typedInput.TrafficManagerProfileName != nil {
		trafficManagerProfileName := *typedInput.TrafficManagerProfileName
		info.TrafficManagerProfileName = &trafficManagerProfileName
	}

	// No error
	return nil
}

// AssignProperties_From_CloningInfo_STATUS populates our CloningInfo_STATUS from the provided source CloningInfo_STATUS
func (info *CloningInfo_STATUS) AssignProperties_From_CloningInfo_STATUS(source *v1beta20220301s.CloningInfo_STATUS) error {

	// AppSettingsOverrides
	info.AppSettingsOverrides = genruntime.CloneMapOfStringToString(source.AppSettingsOverrides)

	// CloneCustomHostNames
	if source.CloneCustomHostNames != nil {
		cloneCustomHostName := *source.CloneCustomHostNames
		info.CloneCustomHostNames = &cloneCustomHostName
	} else {
		info.CloneCustomHostNames = nil
	}

	// CloneSourceControl
	if source.CloneSourceControl != nil {
		cloneSourceControl := *source.CloneSourceControl
		info.CloneSourceControl = &cloneSourceControl
	} else {
		info.CloneSourceControl = nil
	}

	// ConfigureLoadBalancing
	if source.ConfigureLoadBalancing != nil {
		configureLoadBalancing := *source.ConfigureLoadBalancing
		info.ConfigureLoadBalancing = &configureLoadBalancing
	} else {
		info.ConfigureLoadBalancing = nil
	}

	// CorrelationId
	info.CorrelationId = genruntime.ClonePointerToString(source.CorrelationId)

	// HostingEnvironment
	info.HostingEnvironment = genruntime.ClonePointerToString(source.HostingEnvironment)

	// Overwrite
	if source.Overwrite != nil {
		overwrite := *source.Overwrite
		info.Overwrite = &overwrite
	} else {
		info.Overwrite = nil
	}

	// SourceWebAppId
	info.SourceWebAppId = genruntime.ClonePointerToString(source.SourceWebAppId)

	// SourceWebAppLocation
	info.SourceWebAppLocation = genruntime.ClonePointerToString(source.SourceWebAppLocation)

	// TrafficManagerProfileId
	info.TrafficManagerProfileId = genruntime.ClonePointerToString(source.TrafficManagerProfileId)

	// TrafficManagerProfileName
	info.TrafficManagerProfileName = genruntime.ClonePointerToString(source.TrafficManagerProfileName)

	// No error
	return nil
}

// AssignProperties_To_CloningInfo_STATUS populates the provided destination CloningInfo_STATUS from our CloningInfo_STATUS
func (info *CloningInfo_STATUS) AssignProperties_To_CloningInfo_STATUS(destination *v1beta20220301s.CloningInfo_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AppSettingsOverrides
	destination.AppSettingsOverrides = genruntime.CloneMapOfStringToString(info.AppSettingsOverrides)

	// CloneCustomHostNames
	if info.CloneCustomHostNames != nil {
		cloneCustomHostName := *info.CloneCustomHostNames
		destination.CloneCustomHostNames = &cloneCustomHostName
	} else {
		destination.CloneCustomHostNames = nil
	}

	// CloneSourceControl
	if info.CloneSourceControl != nil {
		cloneSourceControl := *info.CloneSourceControl
		destination.CloneSourceControl = &cloneSourceControl
	} else {
		destination.CloneSourceControl = nil
	}

	// ConfigureLoadBalancing
	if info.ConfigureLoadBalancing != nil {
		configureLoadBalancing := *info.ConfigureLoadBalancing
		destination.ConfigureLoadBalancing = &configureLoadBalancing
	} else {
		destination.ConfigureLoadBalancing = nil
	}

	// CorrelationId
	destination.CorrelationId = genruntime.ClonePointerToString(info.CorrelationId)

	// HostingEnvironment
	destination.HostingEnvironment = genruntime.ClonePointerToString(info.HostingEnvironment)

	// Overwrite
	if info.Overwrite != nil {
		overwrite := *info.Overwrite
		destination.Overwrite = &overwrite
	} else {
		destination.Overwrite = nil
	}

	// SourceWebAppId
	destination.SourceWebAppId = genruntime.ClonePointerToString(info.SourceWebAppId)

	// SourceWebAppLocation
	destination.SourceWebAppLocation = genruntime.ClonePointerToString(info.SourceWebAppLocation)

	// TrafficManagerProfileId
	destination.TrafficManagerProfileId = genruntime.ClonePointerToString(info.TrafficManagerProfileId)

	// TrafficManagerProfileName
	destination.TrafficManagerProfileName = genruntime.ClonePointerToString(info.TrafficManagerProfileName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of HostNameSslState. Use v1api20220301.HostNameSslState instead
type HostNameSslState struct {
	HostType   *HostNameSslState_HostType `json:"hostType,omitempty"`
	Name       *string                    `json:"name,omitempty"`
	SslState   *HostNameSslState_SslState `json:"sslState,omitempty"`
	Thumbprint *string                    `json:"thumbprint,omitempty"`
	ToUpdate   *bool                      `json:"toUpdate,omitempty"`
	VirtualIP  *string                    `json:"virtualIP,omitempty"`
}

var _ genruntime.ARMTransformer = &HostNameSslState{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (state *HostNameSslState) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if state == nil {
		return nil, nil
	}
	result := &HostNameSslState_ARM{}

	// Set property "HostType":
	if state.HostType != nil {
		hostType := *state.HostType
		result.HostType = &hostType
	}

	// Set property "Name":
	if state.Name != nil {
		name := *state.Name
		result.Name = &name
	}

	// Set property "SslState":
	if state.SslState != nil {
		sslState := *state.SslState
		result.SslState = &sslState
	}

	// Set property "Thumbprint":
	if state.Thumbprint != nil {
		thumbprint := *state.Thumbprint
		result.Thumbprint = &thumbprint
	}

	// Set property "ToUpdate":
	if state.ToUpdate != nil {
		toUpdate := *state.ToUpdate
		result.ToUpdate = &toUpdate
	}

	// Set property "VirtualIP":
	if state.VirtualIP != nil {
		virtualIP := *state.VirtualIP
		result.VirtualIP = &virtualIP
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (state *HostNameSslState) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &HostNameSslState_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (state *HostNameSslState) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(HostNameSslState_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected HostNameSslState_ARM, got %T", armInput)
	}

	// Set property "HostType":
	if typedInput.HostType != nil {
		hostType := *typedInput.HostType
		state.HostType = &hostType
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		state.Name = &name
	}

	// Set property "SslState":
	if typedInput.SslState != nil {
		sslState := *typedInput.SslState
		state.SslState = &sslState
	}

	// Set property "Thumbprint":
	if typedInput.Thumbprint != nil {
		thumbprint := *typedInput.Thumbprint
		state.Thumbprint = &thumbprint
	}

	// Set property "ToUpdate":
	if typedInput.ToUpdate != nil {
		toUpdate := *typedInput.ToUpdate
		state.ToUpdate = &toUpdate
	}

	// Set property "VirtualIP":
	if typedInput.VirtualIP != nil {
		virtualIP := *typedInput.VirtualIP
		state.VirtualIP = &virtualIP
	}

	// No error
	return nil
}

// AssignProperties_From_HostNameSslState populates our HostNameSslState from the provided source HostNameSslState
func (state *HostNameSslState) AssignProperties_From_HostNameSslState(source *v1beta20220301s.HostNameSslState) error {

	// HostType
	if source.HostType != nil {
		hostType := HostNameSslState_HostType(*source.HostType)
		state.HostType = &hostType
	} else {
		state.HostType = nil
	}

	// Name
	state.Name = genruntime.ClonePointerToString(source.Name)

	// SslState
	if source.SslState != nil {
		sslState := HostNameSslState_SslState(*source.SslState)
		state.SslState = &sslState
	} else {
		state.SslState = nil
	}

	// Thumbprint
	state.Thumbprint = genruntime.ClonePointerToString(source.Thumbprint)

	// ToUpdate
	if source.ToUpdate != nil {
		toUpdate := *source.ToUpdate
		state.ToUpdate = &toUpdate
	} else {
		state.ToUpdate = nil
	}

	// VirtualIP
	state.VirtualIP = genruntime.ClonePointerToString(source.VirtualIP)

	// No error
	return nil
}

// AssignProperties_To_HostNameSslState populates the provided destination HostNameSslState from our HostNameSslState
func (state *HostNameSslState) AssignProperties_To_HostNameSslState(destination *v1beta20220301s.HostNameSslState) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HostType
	if state.HostType != nil {
		hostType := string(*state.HostType)
		destination.HostType = &hostType
	} else {
		destination.HostType = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(state.Name)

	// SslState
	if state.SslState != nil {
		sslState := string(*state.SslState)
		destination.SslState = &sslState
	} else {
		destination.SslState = nil
	}

	// Thumbprint
	destination.Thumbprint = genruntime.ClonePointerToString(state.Thumbprint)

	// ToUpdate
	if state.ToUpdate != nil {
		toUpdate := *state.ToUpdate
		destination.ToUpdate = &toUpdate
	} else {
		destination.ToUpdate = nil
	}

	// VirtualIP
	destination.VirtualIP = genruntime.ClonePointerToString(state.VirtualIP)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of HostNameSslState_STATUS. Use v1api20220301.HostNameSslState_STATUS instead
type HostNameSslState_STATUS struct {
	HostType   *HostNameSslState_HostType_STATUS `json:"hostType,omitempty"`
	Name       *string                           `json:"name,omitempty"`
	SslState   *HostNameSslState_SslState_STATUS `json:"sslState,omitempty"`
	Thumbprint *string                           `json:"thumbprint,omitempty"`
	ToUpdate   *bool                             `json:"toUpdate,omitempty"`
	VirtualIP  *string                           `json:"virtualIP,omitempty"`
}

var _ genruntime.FromARMConverter = &HostNameSslState_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (state *HostNameSslState_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &HostNameSslState_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (state *HostNameSslState_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(HostNameSslState_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected HostNameSslState_STATUS_ARM, got %T", armInput)
	}

	// Set property "HostType":
	if typedInput.HostType != nil {
		hostType := *typedInput.HostType
		state.HostType = &hostType
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		state.Name = &name
	}

	// Set property "SslState":
	if typedInput.SslState != nil {
		sslState := *typedInput.SslState
		state.SslState = &sslState
	}

	// Set property "Thumbprint":
	if typedInput.Thumbprint != nil {
		thumbprint := *typedInput.Thumbprint
		state.Thumbprint = &thumbprint
	}

	// Set property "ToUpdate":
	if typedInput.ToUpdate != nil {
		toUpdate := *typedInput.ToUpdate
		state.ToUpdate = &toUpdate
	}

	// Set property "VirtualIP":
	if typedInput.VirtualIP != nil {
		virtualIP := *typedInput.VirtualIP
		state.VirtualIP = &virtualIP
	}

	// No error
	return nil
}

// AssignProperties_From_HostNameSslState_STATUS populates our HostNameSslState_STATUS from the provided source HostNameSslState_STATUS
func (state *HostNameSslState_STATUS) AssignProperties_From_HostNameSslState_STATUS(source *v1beta20220301s.HostNameSslState_STATUS) error {

	// HostType
	if source.HostType != nil {
		hostType := HostNameSslState_HostType_STATUS(*source.HostType)
		state.HostType = &hostType
	} else {
		state.HostType = nil
	}

	// Name
	state.Name = genruntime.ClonePointerToString(source.Name)

	// SslState
	if source.SslState != nil {
		sslState := HostNameSslState_SslState_STATUS(*source.SslState)
		state.SslState = &sslState
	} else {
		state.SslState = nil
	}

	// Thumbprint
	state.Thumbprint = genruntime.ClonePointerToString(source.Thumbprint)

	// ToUpdate
	if source.ToUpdate != nil {
		toUpdate := *source.ToUpdate
		state.ToUpdate = &toUpdate
	} else {
		state.ToUpdate = nil
	}

	// VirtualIP
	state.VirtualIP = genruntime.ClonePointerToString(source.VirtualIP)

	// No error
	return nil
}

// AssignProperties_To_HostNameSslState_STATUS populates the provided destination HostNameSslState_STATUS from our HostNameSslState_STATUS
func (state *HostNameSslState_STATUS) AssignProperties_To_HostNameSslState_STATUS(destination *v1beta20220301s.HostNameSslState_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HostType
	if state.HostType != nil {
		hostType := string(*state.HostType)
		destination.HostType = &hostType
	} else {
		destination.HostType = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(state.Name)

	// SslState
	if state.SslState != nil {
		sslState := string(*state.SslState)
		destination.SslState = &sslState
	} else {
		destination.SslState = nil
	}

	// Thumbprint
	destination.Thumbprint = genruntime.ClonePointerToString(state.Thumbprint)

	// ToUpdate
	if state.ToUpdate != nil {
		toUpdate := *state.ToUpdate
		destination.ToUpdate = &toUpdate
	} else {
		destination.ToUpdate = nil
	}

	// VirtualIP
	destination.VirtualIP = genruntime.ClonePointerToString(state.VirtualIP)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of ManagedServiceIdentity. Use v1api20220301.ManagedServiceIdentity instead
type ManagedServiceIdentity struct {
	Type                   *ManagedServiceIdentity_Type  `json:"type,omitempty"`
	UserAssignedIdentities []UserAssignedIdentityDetails `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedServiceIdentity{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (identity *ManagedServiceIdentity) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if identity == nil {
		return nil, nil
	}
	result := &ManagedServiceIdentity_ARM{}

	// Set property "Type":
	if identity.Type != nil {
		typeVar := *identity.Type
		result.Type = &typeVar
	}

	// Set property "UserAssignedIdentities":
	result.UserAssignedIdentities = make(map[string]UserAssignedIdentityDetails_ARM, len(identity.UserAssignedIdentities))
	for _, ident := range identity.UserAssignedIdentities {
		identARMID, err := resolved.ResolvedReferences.Lookup(ident.Reference)
		if err != nil {
			return nil, err
		}
		key := identARMID
		result.UserAssignedIdentities[key] = UserAssignedIdentityDetails_ARM{}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ManagedServiceIdentity) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedServiceIdentity_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ManagedServiceIdentity) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedServiceIdentity_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedServiceIdentity_ARM, got %T", armInput)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		identity.Type = &typeVar
	}

	// no assignment for property "UserAssignedIdentities"

	// No error
	return nil
}

// AssignProperties_From_ManagedServiceIdentity populates our ManagedServiceIdentity from the provided source ManagedServiceIdentity
func (identity *ManagedServiceIdentity) AssignProperties_From_ManagedServiceIdentity(source *v1beta20220301s.ManagedServiceIdentity) error {

	// Type
	if source.Type != nil {
		typeVar := ManagedServiceIdentity_Type(*source.Type)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]UserAssignedIdentityDetails, len(source.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity UserAssignedIdentityDetails
			err := userAssignedIdentity.AssignProperties_From_UserAssignedIdentityDetails(&userAssignedIdentityItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityList
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedServiceIdentity populates the provided destination ManagedServiceIdentity from our ManagedServiceIdentity
func (identity *ManagedServiceIdentity) AssignProperties_To_ManagedServiceIdentity(destination *v1beta20220301s.ManagedServiceIdentity) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]v1beta20220301s.UserAssignedIdentityDetails, len(identity.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity v1beta20220301s.UserAssignedIdentityDetails
			err := userAssignedIdentityItem.AssignProperties_To_UserAssignedIdentityDetails(&userAssignedIdentity)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityList
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of ManagedServiceIdentity_STATUS. Use v1api20220301.ManagedServiceIdentity_STATUS instead
type ManagedServiceIdentity_STATUS struct {
	PrincipalId            *string                                `json:"principalId,omitempty"`
	TenantId               *string                                `json:"tenantId,omitempty"`
	Type                   *ManagedServiceIdentity_Type_STATUS    `json:"type,omitempty"`
	UserAssignedIdentities map[string]UserAssignedIdentity_STATUS `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedServiceIdentity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ManagedServiceIdentity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ManagedServiceIdentity_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ManagedServiceIdentity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ManagedServiceIdentity_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ManagedServiceIdentity_STATUS_ARM, got %T", armInput)
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identity.PrincipalId = &principalId
	}

	// Set property "TenantId":
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		identity.TenantId = &tenantId
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		identity.Type = &typeVar
	}

	// Set property "UserAssignedIdentities":
	if typedInput.UserAssignedIdentities != nil {
		identity.UserAssignedIdentities = make(map[string]UserAssignedIdentity_STATUS, len(typedInput.UserAssignedIdentities))
		for key, value := range typedInput.UserAssignedIdentities {
			var value1 UserAssignedIdentity_STATUS
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			identity.UserAssignedIdentities[key] = value1
		}
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedServiceIdentity_STATUS populates our ManagedServiceIdentity_STATUS from the provided source ManagedServiceIdentity_STATUS
func (identity *ManagedServiceIdentity_STATUS) AssignProperties_From_ManagedServiceIdentity_STATUS(source *v1beta20220301s.ManagedServiceIdentity_STATUS) error {

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// TenantId
	identity.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	if source.Type != nil {
		typeVar := ManagedServiceIdentity_Type_STATUS(*source.Type)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]UserAssignedIdentity_STATUS, len(source.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity UserAssignedIdentity_STATUS
			err := userAssignedIdentity.AssignProperties_From_UserAssignedIdentity_STATUS(&userAssignedIdentityValue)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_UserAssignedIdentity_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedServiceIdentity_STATUS populates the provided destination ManagedServiceIdentity_STATUS from our ManagedServiceIdentity_STATUS
func (identity *ManagedServiceIdentity_STATUS) AssignProperties_To_ManagedServiceIdentity_STATUS(destination *v1beta20220301s.ManagedServiceIdentity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(identity.TenantId)

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]v1beta20220301s.UserAssignedIdentity_STATUS, len(identity.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity v1beta20220301s.UserAssignedIdentity_STATUS
			err := userAssignedIdentityValue.AssignProperties_To_UserAssignedIdentity_STATUS(&userAssignedIdentity)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_UserAssignedIdentity_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of Site_Properties_AvailabilityState_STATUS. Use
// v1api20220301.Site_Properties_AvailabilityState_STATUS instead
type Site_Properties_AvailabilityState_STATUS string

const (
	Site_Properties_AvailabilityState_STATUS_DisasterRecoveryMode = Site_Properties_AvailabilityState_STATUS("DisasterRecoveryMode")
	Site_Properties_AvailabilityState_STATUS_Limited              = Site_Properties_AvailabilityState_STATUS("Limited")
	Site_Properties_AvailabilityState_STATUS_Normal               = Site_Properties_AvailabilityState_STATUS("Normal")
)

// Deprecated version of Site_Properties_ClientCertMode_Spec. Use v1api20220301.Site_Properties_ClientCertMode_Spec instead
// +kubebuilder:validation:Enum={"Optional","OptionalInteractiveUser","Required"}
type Site_Properties_ClientCertMode_Spec string

const (
	Site_Properties_ClientCertMode_Spec_Optional                = Site_Properties_ClientCertMode_Spec("Optional")
	Site_Properties_ClientCertMode_Spec_OptionalInteractiveUser = Site_Properties_ClientCertMode_Spec("OptionalInteractiveUser")
	Site_Properties_ClientCertMode_Spec_Required                = Site_Properties_ClientCertMode_Spec("Required")
)

// Deprecated version of Site_Properties_ClientCertMode_STATUS. Use v1api20220301.Site_Properties_ClientCertMode_STATUS
// instead
type Site_Properties_ClientCertMode_STATUS string

const (
	Site_Properties_ClientCertMode_STATUS_Optional                = Site_Properties_ClientCertMode_STATUS("Optional")
	Site_Properties_ClientCertMode_STATUS_OptionalInteractiveUser = Site_Properties_ClientCertMode_STATUS("OptionalInteractiveUser")
	Site_Properties_ClientCertMode_STATUS_Required                = Site_Properties_ClientCertMode_STATUS("Required")
)

// Deprecated version of Site_Properties_RedundancyMode_Spec. Use v1api20220301.Site_Properties_RedundancyMode_Spec instead
// +kubebuilder:validation:Enum={"ActiveActive","Failover","GeoRedundant","Manual","None"}
type Site_Properties_RedundancyMode_Spec string

const (
	Site_Properties_RedundancyMode_Spec_ActiveActive = Site_Properties_RedundancyMode_Spec("ActiveActive")
	Site_Properties_RedundancyMode_Spec_Failover     = Site_Properties_RedundancyMode_Spec("Failover")
	Site_Properties_RedundancyMode_Spec_GeoRedundant = Site_Properties_RedundancyMode_Spec("GeoRedundant")
	Site_Properties_RedundancyMode_Spec_Manual       = Site_Properties_RedundancyMode_Spec("Manual")
	Site_Properties_RedundancyMode_Spec_None         = Site_Properties_RedundancyMode_Spec("None")
)

// Deprecated version of Site_Properties_RedundancyMode_STATUS. Use v1api20220301.Site_Properties_RedundancyMode_STATUS
// instead
type Site_Properties_RedundancyMode_STATUS string

const (
	Site_Properties_RedundancyMode_STATUS_ActiveActive = Site_Properties_RedundancyMode_STATUS("ActiveActive")
	Site_Properties_RedundancyMode_STATUS_Failover     = Site_Properties_RedundancyMode_STATUS("Failover")
	Site_Properties_RedundancyMode_STATUS_GeoRedundant = Site_Properties_RedundancyMode_STATUS("GeoRedundant")
	Site_Properties_RedundancyMode_STATUS_Manual       = Site_Properties_RedundancyMode_STATUS("Manual")
	Site_Properties_RedundancyMode_STATUS_None         = Site_Properties_RedundancyMode_STATUS("None")
)

// Deprecated version of Site_Properties_UsageState_STATUS. Use v1api20220301.Site_Properties_UsageState_STATUS instead
type Site_Properties_UsageState_STATUS string

const (
	Site_Properties_UsageState_STATUS_Exceeded = Site_Properties_UsageState_STATUS("Exceeded")
	Site_Properties_UsageState_STATUS_Normal   = Site_Properties_UsageState_STATUS("Normal")
)

// Deprecated version of SiteConfig. Use v1api20220301.SiteConfig instead
type SiteConfig struct {
	AcrUseManagedIdentityCreds  *bool                            `json:"acrUseManagedIdentityCreds,omitempty"`
	AcrUserManagedIdentityID    *string                          `json:"acrUserManagedIdentityID,omitempty"`
	AlwaysOn                    *bool                            `json:"alwaysOn,omitempty"`
	ApiDefinition               *ApiDefinitionInfo               `json:"apiDefinition,omitempty"`
	ApiManagementConfig         *ApiManagementConfig             `json:"apiManagementConfig,omitempty"`
	AppCommandLine              *string                          `json:"appCommandLine,omitempty"`
	AppSettings                 []NameValuePair                  `json:"appSettings,omitempty"`
	AutoHealEnabled             *bool                            `json:"autoHealEnabled,omitempty"`
	AutoHealRules               *AutoHealRules                   `json:"autoHealRules,omitempty"`
	AutoSwapSlotName            *string                          `json:"autoSwapSlotName,omitempty"`
	AzureStorageAccounts        map[string]AzureStorageInfoValue `json:"azureStorageAccounts,omitempty"`
	ConnectionStrings           []ConnStringInfo                 `json:"connectionStrings,omitempty"`
	Cors                        *CorsSettings                    `json:"cors,omitempty"`
	DefaultDocuments            []string                         `json:"defaultDocuments,omitempty"`
	DetailedErrorLoggingEnabled *bool                            `json:"detailedErrorLoggingEnabled,omitempty"`
	DocumentRoot                *string                          `json:"documentRoot,omitempty"`
	Experiments                 *Experiments                     `json:"experiments,omitempty"`
	FtpsState                   *SiteConfig_FtpsState            `json:"ftpsState,omitempty"`

	// +kubebuilder:validation:Minimum=0
	FunctionAppScaleLimit                  *int                            `json:"functionAppScaleLimit,omitempty"`
	FunctionsRuntimeScaleMonitoringEnabled *bool                           `json:"functionsRuntimeScaleMonitoringEnabled,omitempty"`
	HandlerMappings                        []HandlerMapping                `json:"handlerMappings,omitempty"`
	HealthCheckPath                        *string                         `json:"healthCheckPath,omitempty"`
	Http20Enabled                          *bool                           `json:"http20Enabled,omitempty"`
	HttpLoggingEnabled                     *bool                           `json:"httpLoggingEnabled,omitempty"`
	IpSecurityRestrictions                 []IpSecurityRestriction         `json:"ipSecurityRestrictions,omitempty"`
	JavaContainer                          *string                         `json:"javaContainer,omitempty"`
	JavaContainerVersion                   *string                         `json:"javaContainerVersion,omitempty"`
	JavaVersion                            *string                         `json:"javaVersion,omitempty"`
	KeyVaultReferenceIdentity              *string                         `json:"keyVaultReferenceIdentity,omitempty"`
	Limits                                 *SiteLimits                     `json:"limits,omitempty"`
	LinuxFxVersion                         *string                         `json:"linuxFxVersion,omitempty"`
	LoadBalancing                          *SiteConfig_LoadBalancing       `json:"loadBalancing,omitempty"`
	LocalMySqlEnabled                      *bool                           `json:"localMySqlEnabled,omitempty"`
	LogsDirectorySizeLimit                 *int                            `json:"logsDirectorySizeLimit,omitempty"`
	ManagedPipelineMode                    *SiteConfig_ManagedPipelineMode `json:"managedPipelineMode,omitempty"`
	ManagedServiceIdentityId               *int                            `json:"managedServiceIdentityId,omitempty"`
	MinTlsVersion                          *SiteConfig_MinTlsVersion       `json:"minTlsVersion,omitempty"`

	// +kubebuilder:validation:Maximum=20
	// +kubebuilder:validation:Minimum=0
	MinimumElasticInstanceCount *int    `json:"minimumElasticInstanceCount,omitempty"`
	NetFrameworkVersion         *string `json:"netFrameworkVersion,omitempty"`
	NodeVersion                 *string `json:"nodeVersion,omitempty"`
	NumberOfWorkers             *int    `json:"numberOfWorkers,omitempty"`
	PhpVersion                  *string `json:"phpVersion,omitempty"`
	PowerShellVersion           *string `json:"powerShellVersion,omitempty"`

	// +kubebuilder:validation:Maximum=10
	// +kubebuilder:validation:Minimum=0
	PreWarmedInstanceCount           *int                         `json:"preWarmedInstanceCount,omitempty"`
	PublicNetworkAccess              *string                      `json:"publicNetworkAccess,omitempty"`
	PublishingUsername               *string                      `json:"publishingUsername,omitempty"`
	Push                             *PushSettings                `json:"push,omitempty"`
	PythonVersion                    *string                      `json:"pythonVersion,omitempty"`
	RemoteDebuggingEnabled           *bool                        `json:"remoteDebuggingEnabled,omitempty"`
	RemoteDebuggingVersion           *string                      `json:"remoteDebuggingVersion,omitempty"`
	RequestTracingEnabled            *bool                        `json:"requestTracingEnabled,omitempty"`
	RequestTracingExpirationTime     *string                      `json:"requestTracingExpirationTime,omitempty"`
	ScmIpSecurityRestrictions        []IpSecurityRestriction      `json:"scmIpSecurityRestrictions,omitempty"`
	ScmIpSecurityRestrictionsUseMain *bool                        `json:"scmIpSecurityRestrictionsUseMain,omitempty"`
	ScmMinTlsVersion                 *SiteConfig_ScmMinTlsVersion `json:"scmMinTlsVersion,omitempty"`
	ScmType                          *SiteConfig_ScmType          `json:"scmType,omitempty"`
	TracingOptions                   *string                      `json:"tracingOptions,omitempty"`
	Use32BitWorkerProcess            *bool                        `json:"use32BitWorkerProcess,omitempty"`
	VirtualApplications              []VirtualApplication         `json:"virtualApplications,omitempty"`
	VnetName                         *string                      `json:"vnetName,omitempty"`
	VnetPrivatePortsCount            *int                         `json:"vnetPrivatePortsCount,omitempty"`
	VnetRouteAllEnabled              *bool                        `json:"vnetRouteAllEnabled,omitempty"`
	WebSocketsEnabled                *bool                        `json:"webSocketsEnabled,omitempty"`
	WebsiteTimeZone                  *string                      `json:"websiteTimeZone,omitempty"`
	WindowsFxVersion                 *string                      `json:"windowsFxVersion,omitempty"`
	XManagedServiceIdentityId        *int                         `json:"xManagedServiceIdentityId,omitempty"`
}

var _ genruntime.ARMTransformer = &SiteConfig{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (config *SiteConfig) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if config == nil {
		return nil, nil
	}
	result := &SiteConfig_ARM{}

	// Set property "AcrUseManagedIdentityCreds":
	if config.AcrUseManagedIdentityCreds != nil {
		acrUseManagedIdentityCreds := *config.AcrUseManagedIdentityCreds
		result.AcrUseManagedIdentityCreds = &acrUseManagedIdentityCreds
	}

	// Set property "AcrUserManagedIdentityID":
	if config.AcrUserManagedIdentityID != nil {
		acrUserManagedIdentityID := *config.AcrUserManagedIdentityID
		result.AcrUserManagedIdentityID = &acrUserManagedIdentityID
	}

	// Set property "AlwaysOn":
	if config.AlwaysOn != nil {
		alwaysOn := *config.AlwaysOn
		result.AlwaysOn = &alwaysOn
	}

	// Set property "ApiDefinition":
	if config.ApiDefinition != nil {
		apiDefinition_ARM, err := (*config.ApiDefinition).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		apiDefinition := *apiDefinition_ARM.(*ApiDefinitionInfo_ARM)
		result.ApiDefinition = &apiDefinition
	}

	// Set property "ApiManagementConfig":
	if config.ApiManagementConfig != nil {
		apiManagementConfig_ARM, err := (*config.ApiManagementConfig).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		apiManagementConfig := *apiManagementConfig_ARM.(*ApiManagementConfig_ARM)
		result.ApiManagementConfig = &apiManagementConfig
	}

	// Set property "AppCommandLine":
	if config.AppCommandLine != nil {
		appCommandLine := *config.AppCommandLine
		result.AppCommandLine = &appCommandLine
	}

	// Set property "AppSettings":
	for _, item := range config.AppSettings {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.AppSettings = append(result.AppSettings, *item_ARM.(*NameValuePair_ARM))
	}

	// Set property "AutoHealEnabled":
	if config.AutoHealEnabled != nil {
		autoHealEnabled := *config.AutoHealEnabled
		result.AutoHealEnabled = &autoHealEnabled
	}

	// Set property "AutoHealRules":
	if config.AutoHealRules != nil {
		autoHealRules_ARM, err := (*config.AutoHealRules).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		autoHealRules := *autoHealRules_ARM.(*AutoHealRules_ARM)
		result.AutoHealRules = &autoHealRules
	}

	// Set property "AutoSwapSlotName":
	if config.AutoSwapSlotName != nil {
		autoSwapSlotName := *config.AutoSwapSlotName
		result.AutoSwapSlotName = &autoSwapSlotName
	}

	// Set property "AzureStorageAccounts":
	if config.AzureStorageAccounts != nil {
		result.AzureStorageAccounts = make(map[string]AzureStorageInfoValue_ARM, len(config.AzureStorageAccounts))
		for key, value := range config.AzureStorageAccounts {
			value_ARM, err := value.ConvertToARM(resolved)
			if err != nil {
				return nil, err
			}
			result.AzureStorageAccounts[key] = *value_ARM.(*AzureStorageInfoValue_ARM)
		}
	}

	// Set property "ConnectionStrings":
	for _, item := range config.ConnectionStrings {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.ConnectionStrings = append(result.ConnectionStrings, *item_ARM.(*ConnStringInfo_ARM))
	}

	// Set property "Cors":
	if config.Cors != nil {
		cors_ARM, err := (*config.Cors).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		cors := *cors_ARM.(*CorsSettings_ARM)
		result.Cors = &cors
	}

	// Set property "DefaultDocuments":
	for _, item := range config.DefaultDocuments {
		result.DefaultDocuments = append(result.DefaultDocuments, item)
	}

	// Set property "DetailedErrorLoggingEnabled":
	if config.DetailedErrorLoggingEnabled != nil {
		detailedErrorLoggingEnabled := *config.DetailedErrorLoggingEnabled
		result.DetailedErrorLoggingEnabled = &detailedErrorLoggingEnabled
	}

	// Set property "DocumentRoot":
	if config.DocumentRoot != nil {
		documentRoot := *config.DocumentRoot
		result.DocumentRoot = &documentRoot
	}

	// Set property "Experiments":
	if config.Experiments != nil {
		experiments_ARM, err := (*config.Experiments).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		experiments := *experiments_ARM.(*Experiments_ARM)
		result.Experiments = &experiments
	}

	// Set property "FtpsState":
	if config.FtpsState != nil {
		ftpsState := *config.FtpsState
		result.FtpsState = &ftpsState
	}

	// Set property "FunctionAppScaleLimit":
	if config.FunctionAppScaleLimit != nil {
		functionAppScaleLimit := *config.FunctionAppScaleLimit
		result.FunctionAppScaleLimit = &functionAppScaleLimit
	}

	// Set property "FunctionsRuntimeScaleMonitoringEnabled":
	if config.FunctionsRuntimeScaleMonitoringEnabled != nil {
		functionsRuntimeScaleMonitoringEnabled := *config.FunctionsRuntimeScaleMonitoringEnabled
		result.FunctionsRuntimeScaleMonitoringEnabled = &functionsRuntimeScaleMonitoringEnabled
	}

	// Set property "HandlerMappings":
	for _, item := range config.HandlerMappings {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.HandlerMappings = append(result.HandlerMappings, *item_ARM.(*HandlerMapping_ARM))
	}

	// Set property "HealthCheckPath":
	if config.HealthCheckPath != nil {
		healthCheckPath := *config.HealthCheckPath
		result.HealthCheckPath = &healthCheckPath
	}

	// Set property "Http20Enabled":
	if config.Http20Enabled != nil {
		http20Enabled := *config.Http20Enabled
		result.Http20Enabled = &http20Enabled
	}

	// Set property "HttpLoggingEnabled":
	if config.HttpLoggingEnabled != nil {
		httpLoggingEnabled := *config.HttpLoggingEnabled
		result.HttpLoggingEnabled = &httpLoggingEnabled
	}

	// Set property "IpSecurityRestrictions":
	for _, item := range config.IpSecurityRestrictions {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.IpSecurityRestrictions = append(result.IpSecurityRestrictions, *item_ARM.(*IpSecurityRestriction_ARM))
	}

	// Set property "JavaContainer":
	if config.JavaContainer != nil {
		javaContainer := *config.JavaContainer
		result.JavaContainer = &javaContainer
	}

	// Set property "JavaContainerVersion":
	if config.JavaContainerVersion != nil {
		javaContainerVersion := *config.JavaContainerVersion
		result.JavaContainerVersion = &javaContainerVersion
	}

	// Set property "JavaVersion":
	if config.JavaVersion != nil {
		javaVersion := *config.JavaVersion
		result.JavaVersion = &javaVersion
	}

	// Set property "KeyVaultReferenceIdentity":
	if config.KeyVaultReferenceIdentity != nil {
		keyVaultReferenceIdentity := *config.KeyVaultReferenceIdentity
		result.KeyVaultReferenceIdentity = &keyVaultReferenceIdentity
	}

	// Set property "Limits":
	if config.Limits != nil {
		limits_ARM, err := (*config.Limits).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		limits := *limits_ARM.(*SiteLimits_ARM)
		result.Limits = &limits
	}

	// Set property "LinuxFxVersion":
	if config.LinuxFxVersion != nil {
		linuxFxVersion := *config.LinuxFxVersion
		result.LinuxFxVersion = &linuxFxVersion
	}

	// Set property "LoadBalancing":
	if config.LoadBalancing != nil {
		loadBalancing := *config.LoadBalancing
		result.LoadBalancing = &loadBalancing
	}

	// Set property "LocalMySqlEnabled":
	if config.LocalMySqlEnabled != nil {
		localMySqlEnabled := *config.LocalMySqlEnabled
		result.LocalMySqlEnabled = &localMySqlEnabled
	}

	// Set property "LogsDirectorySizeLimit":
	if config.LogsDirectorySizeLimit != nil {
		logsDirectorySizeLimit := *config.LogsDirectorySizeLimit
		result.LogsDirectorySizeLimit = &logsDirectorySizeLimit
	}

	// Set property "ManagedPipelineMode":
	if config.ManagedPipelineMode != nil {
		managedPipelineMode := *config.ManagedPipelineMode
		result.ManagedPipelineMode = &managedPipelineMode
	}

	// Set property "ManagedServiceIdentityId":
	if config.ManagedServiceIdentityId != nil {
		managedServiceIdentityId := *config.ManagedServiceIdentityId
		result.ManagedServiceIdentityId = &managedServiceIdentityId
	}

	// Set property "MinTlsVersion":
	if config.MinTlsVersion != nil {
		minTlsVersion := *config.MinTlsVersion
		result.MinTlsVersion = &minTlsVersion
	}

	// Set property "MinimumElasticInstanceCount":
	if config.MinimumElasticInstanceCount != nil {
		minimumElasticInstanceCount := *config.MinimumElasticInstanceCount
		result.MinimumElasticInstanceCount = &minimumElasticInstanceCount
	}

	// Set property "NetFrameworkVersion":
	if config.NetFrameworkVersion != nil {
		netFrameworkVersion := *config.NetFrameworkVersion
		result.NetFrameworkVersion = &netFrameworkVersion
	}

	// Set property "NodeVersion":
	if config.NodeVersion != nil {
		nodeVersion := *config.NodeVersion
		result.NodeVersion = &nodeVersion
	}

	// Set property "NumberOfWorkers":
	if config.NumberOfWorkers != nil {
		numberOfWorkers := *config.NumberOfWorkers
		result.NumberOfWorkers = &numberOfWorkers
	}

	// Set property "PhpVersion":
	if config.PhpVersion != nil {
		phpVersion := *config.PhpVersion
		result.PhpVersion = &phpVersion
	}

	// Set property "PowerShellVersion":
	if config.PowerShellVersion != nil {
		powerShellVersion := *config.PowerShellVersion
		result.PowerShellVersion = &powerShellVersion
	}

	// Set property "PreWarmedInstanceCount":
	if config.PreWarmedInstanceCount != nil {
		preWarmedInstanceCount := *config.PreWarmedInstanceCount
		result.PreWarmedInstanceCount = &preWarmedInstanceCount
	}

	// Set property "PublicNetworkAccess":
	if config.PublicNetworkAccess != nil {
		publicNetworkAccess := *config.PublicNetworkAccess
		result.PublicNetworkAccess = &publicNetworkAccess
	}

	// Set property "PublishingUsername":
	if config.PublishingUsername != nil {
		publishingUsername := *config.PublishingUsername
		result.PublishingUsername = &publishingUsername
	}

	// Set property "Push":
	if config.Push != nil {
		push_ARM, err := (*config.Push).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		push := *push_ARM.(*PushSettings_ARM)
		result.Push = &push
	}

	// Set property "PythonVersion":
	if config.PythonVersion != nil {
		pythonVersion := *config.PythonVersion
		result.PythonVersion = &pythonVersion
	}

	// Set property "RemoteDebuggingEnabled":
	if config.RemoteDebuggingEnabled != nil {
		remoteDebuggingEnabled := *config.RemoteDebuggingEnabled
		result.RemoteDebuggingEnabled = &remoteDebuggingEnabled
	}

	// Set property "RemoteDebuggingVersion":
	if config.RemoteDebuggingVersion != nil {
		remoteDebuggingVersion := *config.RemoteDebuggingVersion
		result.RemoteDebuggingVersion = &remoteDebuggingVersion
	}

	// Set property "RequestTracingEnabled":
	if config.RequestTracingEnabled != nil {
		requestTracingEnabled := *config.RequestTracingEnabled
		result.RequestTracingEnabled = &requestTracingEnabled
	}

	// Set property "RequestTracingExpirationTime":
	if config.RequestTracingExpirationTime != nil {
		requestTracingExpirationTime := *config.RequestTracingExpirationTime
		result.RequestTracingExpirationTime = &requestTracingExpirationTime
	}

	// Set property "ScmIpSecurityRestrictions":
	for _, item := range config.ScmIpSecurityRestrictions {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.ScmIpSecurityRestrictions = append(result.ScmIpSecurityRestrictions, *item_ARM.(*IpSecurityRestriction_ARM))
	}

	// Set property "ScmIpSecurityRestrictionsUseMain":
	if config.ScmIpSecurityRestrictionsUseMain != nil {
		scmIpSecurityRestrictionsUseMain := *config.ScmIpSecurityRestrictionsUseMain
		result.ScmIpSecurityRestrictionsUseMain = &scmIpSecurityRestrictionsUseMain
	}

	// Set property "ScmMinTlsVersion":
	if config.ScmMinTlsVersion != nil {
		scmMinTlsVersion := *config.ScmMinTlsVersion
		result.ScmMinTlsVersion = &scmMinTlsVersion
	}

	// Set property "ScmType":
	if config.ScmType != nil {
		scmType := *config.ScmType
		result.ScmType = &scmType
	}

	// Set property "TracingOptions":
	if config.TracingOptions != nil {
		tracingOptions := *config.TracingOptions
		result.TracingOptions = &tracingOptions
	}

	// Set property "Use32BitWorkerProcess":
	if config.Use32BitWorkerProcess != nil {
		use32BitWorkerProcess := *config.Use32BitWorkerProcess
		result.Use32BitWorkerProcess = &use32BitWorkerProcess
	}

	// Set property "VirtualApplications":
	for _, item := range config.VirtualApplications {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.VirtualApplications = append(result.VirtualApplications, *item_ARM.(*VirtualApplication_ARM))
	}

	// Set property "VnetName":
	if config.VnetName != nil {
		vnetName := *config.VnetName
		result.VnetName = &vnetName
	}

	// Set property "VnetPrivatePortsCount":
	if config.VnetPrivatePortsCount != nil {
		vnetPrivatePortsCount := *config.VnetPrivatePortsCount
		result.VnetPrivatePortsCount = &vnetPrivatePortsCount
	}

	// Set property "VnetRouteAllEnabled":
	if config.VnetRouteAllEnabled != nil {
		vnetRouteAllEnabled := *config.VnetRouteAllEnabled
		result.VnetRouteAllEnabled = &vnetRouteAllEnabled
	}

	// Set property "WebSocketsEnabled":
	if config.WebSocketsEnabled != nil {
		webSocketsEnabled := *config.WebSocketsEnabled
		result.WebSocketsEnabled = &webSocketsEnabled
	}

	// Set property "WebsiteTimeZone":
	if config.WebsiteTimeZone != nil {
		websiteTimeZone := *config.WebsiteTimeZone
		result.WebsiteTimeZone = &websiteTimeZone
	}

	// Set property "WindowsFxVersion":
	if config.WindowsFxVersion != nil {
		windowsFxVersion := *config.WindowsFxVersion
		result.WindowsFxVersion = &windowsFxVersion
	}

	// Set property "XManagedServiceIdentityId":
	if config.XManagedServiceIdentityId != nil {
		xManagedServiceIdentityId := *config.XManagedServiceIdentityId
		result.XManagedServiceIdentityId = &xManagedServiceIdentityId
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (config *SiteConfig) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SiteConfig_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (config *SiteConfig) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SiteConfig_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SiteConfig_ARM, got %T", armInput)
	}

	// Set property "AcrUseManagedIdentityCreds":
	if typedInput.AcrUseManagedIdentityCreds != nil {
		acrUseManagedIdentityCreds := *typedInput.AcrUseManagedIdentityCreds
		config.AcrUseManagedIdentityCreds = &acrUseManagedIdentityCreds
	}

	// Set property "AcrUserManagedIdentityID":
	if typedInput.AcrUserManagedIdentityID != nil {
		acrUserManagedIdentityID := *typedInput.AcrUserManagedIdentityID
		config.AcrUserManagedIdentityID = &acrUserManagedIdentityID
	}

	// Set property "AlwaysOn":
	if typedInput.AlwaysOn != nil {
		alwaysOn := *typedInput.AlwaysOn
		config.AlwaysOn = &alwaysOn
	}

	// Set property "ApiDefinition":
	if typedInput.ApiDefinition != nil {
		var apiDefinition1 ApiDefinitionInfo
		err := apiDefinition1.PopulateFromARM(owner, *typedInput.ApiDefinition)
		if err != nil {
			return err
		}
		apiDefinition := apiDefinition1
		config.ApiDefinition = &apiDefinition
	}

	// Set property "ApiManagementConfig":
	if typedInput.ApiManagementConfig != nil {
		var apiManagementConfig1 ApiManagementConfig
		err := apiManagementConfig1.PopulateFromARM(owner, *typedInput.ApiManagementConfig)
		if err != nil {
			return err
		}
		apiManagementConfig := apiManagementConfig1
		config.ApiManagementConfig = &apiManagementConfig
	}

	// Set property "AppCommandLine":
	if typedInput.AppCommandLine != nil {
		appCommandLine := *typedInput.AppCommandLine
		config.AppCommandLine = &appCommandLine
	}

	// Set property "AppSettings":
	for _, item := range typedInput.AppSettings {
		var item1 NameValuePair
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		config.AppSettings = append(config.AppSettings, item1)
	}

	// Set property "AutoHealEnabled":
	if typedInput.AutoHealEnabled != nil {
		autoHealEnabled := *typedInput.AutoHealEnabled
		config.AutoHealEnabled = &autoHealEnabled
	}

	// Set property "AutoHealRules":
	if typedInput.AutoHealRules != nil {
		var autoHealRules1 AutoHealRules
		err := autoHealRules1.PopulateFromARM(owner, *typedInput.AutoHealRules)
		if err != nil {
			return err
		}
		autoHealRules := autoHealRules1
		config.AutoHealRules = &autoHealRules
	}

	// Set property "AutoSwapSlotName":
	if typedInput.AutoSwapSlotName != nil {
		autoSwapSlotName := *typedInput.AutoSwapSlotName
		config.AutoSwapSlotName = &autoSwapSlotName
	}

	// Set property "AzureStorageAccounts":
	if typedInput.AzureStorageAccounts != nil {
		config.AzureStorageAccounts = make(map[string]AzureStorageInfoValue, len(typedInput.AzureStorageAccounts))
		for key, value := range typedInput.AzureStorageAccounts {
			var value1 AzureStorageInfoValue
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			config.AzureStorageAccounts[key] = value1
		}
	}

	// Set property "ConnectionStrings":
	for _, item := range typedInput.ConnectionStrings {
		var item1 ConnStringInfo
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		config.ConnectionStrings = append(config.ConnectionStrings, item1)
	}

	// Set property "Cors":
	if typedInput.Cors != nil {
		var cors1 CorsSettings
		err := cors1.PopulateFromARM(owner, *typedInput.Cors)
		if err != nil {
			return err
		}
		cors := cors1
		config.Cors = &cors
	}

	// Set property "DefaultDocuments":
	for _, item := range typedInput.DefaultDocuments {
		config.DefaultDocuments = append(config.DefaultDocuments, item)
	}

	// Set property "DetailedErrorLoggingEnabled":
	if typedInput.DetailedErrorLoggingEnabled != nil {
		detailedErrorLoggingEnabled := *typedInput.DetailedErrorLoggingEnabled
		config.DetailedErrorLoggingEnabled = &detailedErrorLoggingEnabled
	}

	// Set property "DocumentRoot":
	if typedInput.DocumentRoot != nil {
		documentRoot := *typedInput.DocumentRoot
		config.DocumentRoot = &documentRoot
	}

	// Set property "Experiments":
	if typedInput.Experiments != nil {
		var experiments1 Experiments
		err := experiments1.PopulateFromARM(owner, *typedInput.Experiments)
		if err != nil {
			return err
		}
		experiments := experiments1
		config.Experiments = &experiments
	}

	// Set property "FtpsState":
	if typedInput.FtpsState != nil {
		ftpsState := *typedInput.FtpsState
		config.FtpsState = &ftpsState
	}

	// Set property "FunctionAppScaleLimit":
	if typedInput.FunctionAppScaleLimit != nil {
		functionAppScaleLimit := *typedInput.FunctionAppScaleLimit
		config.FunctionAppScaleLimit = &functionAppScaleLimit
	}

	// Set property "FunctionsRuntimeScaleMonitoringEnabled":
	if typedInput.FunctionsRuntimeScaleMonitoringEnabled != nil {
		functionsRuntimeScaleMonitoringEnabled := *typedInput.FunctionsRuntimeScaleMonitoringEnabled
		config.FunctionsRuntimeScaleMonitoringEnabled = &functionsRuntimeScaleMonitoringEnabled
	}

	// Set property "HandlerMappings":
	for _, item := range typedInput.HandlerMappings {
		var item1 HandlerMapping
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		config.HandlerMappings = append(config.HandlerMappings, item1)
	}

	// Set property "HealthCheckPath":
	if typedInput.HealthCheckPath != nil {
		healthCheckPath := *typedInput.HealthCheckPath
		config.HealthCheckPath = &healthCheckPath
	}

	// Set property "Http20Enabled":
	if typedInput.Http20Enabled != nil {
		http20Enabled := *typedInput.Http20Enabled
		config.Http20Enabled = &http20Enabled
	}

	// Set property "HttpLoggingEnabled":
	if typedInput.HttpLoggingEnabled != nil {
		httpLoggingEnabled := *typedInput.HttpLoggingEnabled
		config.HttpLoggingEnabled = &httpLoggingEnabled
	}

	// Set property "IpSecurityRestrictions":
	for _, item := range typedInput.IpSecurityRestrictions {
		var item1 IpSecurityRestriction
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		config.IpSecurityRestrictions = append(config.IpSecurityRestrictions, item1)
	}

	// Set property "JavaContainer":
	if typedInput.JavaContainer != nil {
		javaContainer := *typedInput.JavaContainer
		config.JavaContainer = &javaContainer
	}

	// Set property "JavaContainerVersion":
	if typedInput.JavaContainerVersion != nil {
		javaContainerVersion := *typedInput.JavaContainerVersion
		config.JavaContainerVersion = &javaContainerVersion
	}

	// Set property "JavaVersion":
	if typedInput.JavaVersion != nil {
		javaVersion := *typedInput.JavaVersion
		config.JavaVersion = &javaVersion
	}

	// Set property "KeyVaultReferenceIdentity":
	if typedInput.KeyVaultReferenceIdentity != nil {
		keyVaultReferenceIdentity := *typedInput.KeyVaultReferenceIdentity
		config.KeyVaultReferenceIdentity = &keyVaultReferenceIdentity
	}

	// Set property "Limits":
	if typedInput.Limits != nil {
		var limits1 SiteLimits
		err := limits1.PopulateFromARM(owner, *typedInput.Limits)
		if err != nil {
			return err
		}
		limits := limits1
		config.Limits = &limits
	}

	// Set property "LinuxFxVersion":
	if typedInput.LinuxFxVersion != nil {
		linuxFxVersion := *typedInput.LinuxFxVersion
		config.LinuxFxVersion = &linuxFxVersion
	}

	// Set property "LoadBalancing":
	if typedInput.LoadBalancing != nil {
		loadBalancing := *typedInput.LoadBalancing
		config.LoadBalancing = &loadBalancing
	}

	// Set property "LocalMySqlEnabled":
	if typedInput.LocalMySqlEnabled != nil {
		localMySqlEnabled := *typedInput.LocalMySqlEnabled
		config.LocalMySqlEnabled = &localMySqlEnabled
	}

	// Set property "LogsDirectorySizeLimit":
	if typedInput.LogsDirectorySizeLimit != nil {
		logsDirectorySizeLimit := *typedInput.LogsDirectorySizeLimit
		config.LogsDirectorySizeLimit = &logsDirectorySizeLimit
	}

	// Set property "ManagedPipelineMode":
	if typedInput.ManagedPipelineMode != nil {
		managedPipelineMode := *typedInput.ManagedPipelineMode
		config.ManagedPipelineMode = &managedPipelineMode
	}

	// Set property "ManagedServiceIdentityId":
	if typedInput.ManagedServiceIdentityId != nil {
		managedServiceIdentityId := *typedInput.ManagedServiceIdentityId
		config.ManagedServiceIdentityId = &managedServiceIdentityId
	}

	// Set property "MinTlsVersion":
	if typedInput.MinTlsVersion != nil {
		minTlsVersion := *typedInput.MinTlsVersion
		config.MinTlsVersion = &minTlsVersion
	}

	// Set property "MinimumElasticInstanceCount":
	if typedInput.MinimumElasticInstanceCount != nil {
		minimumElasticInstanceCount := *typedInput.MinimumElasticInstanceCount
		config.MinimumElasticInstanceCount = &minimumElasticInstanceCount
	}

	// Set property "NetFrameworkVersion":
	if typedInput.NetFrameworkVersion != nil {
		netFrameworkVersion := *typedInput.NetFrameworkVersion
		config.NetFrameworkVersion = &netFrameworkVersion
	}

	// Set property "NodeVersion":
	if typedInput.NodeVersion != nil {
		nodeVersion := *typedInput.NodeVersion
		config.NodeVersion = &nodeVersion
	}

	// Set property "NumberOfWorkers":
	if typedInput.NumberOfWorkers != nil {
		numberOfWorkers := *typedInput.NumberOfWorkers
		config.NumberOfWorkers = &numberOfWorkers
	}

	// Set property "PhpVersion":
	if typedInput.PhpVersion != nil {
		phpVersion := *typedInput.PhpVersion
		config.PhpVersion = &phpVersion
	}

	// Set property "PowerShellVersion":
	if typedInput.PowerShellVersion != nil {
		powerShellVersion := *typedInput.PowerShellVersion
		config.PowerShellVersion = &powerShellVersion
	}

	// Set property "PreWarmedInstanceCount":
	if typedInput.PreWarmedInstanceCount != nil {
		preWarmedInstanceCount := *typedInput.PreWarmedInstanceCount
		config.PreWarmedInstanceCount = &preWarmedInstanceCount
	}

	// Set property "PublicNetworkAccess":
	if typedInput.PublicNetworkAccess != nil {
		publicNetworkAccess := *typedInput.PublicNetworkAccess
		config.PublicNetworkAccess = &publicNetworkAccess
	}

	// Set property "PublishingUsername":
	if typedInput.PublishingUsername != nil {
		publishingUsername := *typedInput.PublishingUsername
		config.PublishingUsername = &publishingUsername
	}

	// Set property "Push":
	if typedInput.Push != nil {
		var push1 PushSettings
		err := push1.PopulateFromARM(owner, *typedInput.Push)
		if err != nil {
			return err
		}
		push := push1
		config.Push = &push
	}

	// Set property "PythonVersion":
	if typedInput.PythonVersion != nil {
		pythonVersion := *typedInput.PythonVersion
		config.PythonVersion = &pythonVersion
	}

	// Set property "RemoteDebuggingEnabled":
	if typedInput.RemoteDebuggingEnabled != nil {
		remoteDebuggingEnabled := *typedInput.RemoteDebuggingEnabled
		config.RemoteDebuggingEnabled = &remoteDebuggingEnabled
	}

	// Set property "RemoteDebuggingVersion":
	if typedInput.RemoteDebuggingVersion != nil {
		remoteDebuggingVersion := *typedInput.RemoteDebuggingVersion
		config.RemoteDebuggingVersion = &remoteDebuggingVersion
	}

	// Set property "RequestTracingEnabled":
	if typedInput.RequestTracingEnabled != nil {
		requestTracingEnabled := *typedInput.RequestTracingEnabled
		config.RequestTracingEnabled = &requestTracingEnabled
	}

	// Set property "RequestTracingExpirationTime":
	if typedInput.RequestTracingExpirationTime != nil {
		requestTracingExpirationTime := *typedInput.RequestTracingExpirationTime
		config.RequestTracingExpirationTime = &requestTracingExpirationTime
	}

	// Set property "ScmIpSecurityRestrictions":
	for _, item := range typedInput.ScmIpSecurityRestrictions {
		var item1 IpSecurityRestriction
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		config.ScmIpSecurityRestrictions = append(config.ScmIpSecurityRestrictions, item1)
	}

	// Set property "ScmIpSecurityRestrictionsUseMain":
	if typedInput.ScmIpSecurityRestrictionsUseMain != nil {
		scmIpSecurityRestrictionsUseMain := *typedInput.ScmIpSecurityRestrictionsUseMain
		config.ScmIpSecurityRestrictionsUseMain = &scmIpSecurityRestrictionsUseMain
	}

	// Set property "ScmMinTlsVersion":
	if typedInput.ScmMinTlsVersion != nil {
		scmMinTlsVersion := *typedInput.ScmMinTlsVersion
		config.ScmMinTlsVersion = &scmMinTlsVersion
	}

	// Set property "ScmType":
	if typedInput.ScmType != nil {
		scmType := *typedInput.ScmType
		config.ScmType = &scmType
	}

	// Set property "TracingOptions":
	if typedInput.TracingOptions != nil {
		tracingOptions := *typedInput.TracingOptions
		config.TracingOptions = &tracingOptions
	}

	// Set property "Use32BitWorkerProcess":
	if typedInput.Use32BitWorkerProcess != nil {
		use32BitWorkerProcess := *typedInput.Use32BitWorkerProcess
		config.Use32BitWorkerProcess = &use32BitWorkerProcess
	}

	// Set property "VirtualApplications":
	for _, item := range typedInput.VirtualApplications {
		var item1 VirtualApplication
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		config.VirtualApplications = append(config.VirtualApplications, item1)
	}

	// Set property "VnetName":
	if typedInput.VnetName != nil {
		vnetName := *typedInput.VnetName
		config.VnetName = &vnetName
	}

	// Set property "VnetPrivatePortsCount":
	if typedInput.VnetPrivatePortsCount != nil {
		vnetPrivatePortsCount := *typedInput.VnetPrivatePortsCount
		config.VnetPrivatePortsCount = &vnetPrivatePortsCount
	}

	// Set property "VnetRouteAllEnabled":
	if typedInput.VnetRouteAllEnabled != nil {
		vnetRouteAllEnabled := *typedInput.VnetRouteAllEnabled
		config.VnetRouteAllEnabled = &vnetRouteAllEnabled
	}

	// Set property "WebSocketsEnabled":
	if typedInput.WebSocketsEnabled != nil {
		webSocketsEnabled := *typedInput.WebSocketsEnabled
		config.WebSocketsEnabled = &webSocketsEnabled
	}

	// Set property "WebsiteTimeZone":
	if typedInput.WebsiteTimeZone != nil {
		websiteTimeZone := *typedInput.WebsiteTimeZone
		config.WebsiteTimeZone = &websiteTimeZone
	}

	// Set property "WindowsFxVersion":
	if typedInput.WindowsFxVersion != nil {
		windowsFxVersion := *typedInput.WindowsFxVersion
		config.WindowsFxVersion = &windowsFxVersion
	}

	// Set property "XManagedServiceIdentityId":
	if typedInput.XManagedServiceIdentityId != nil {
		xManagedServiceIdentityId := *typedInput.XManagedServiceIdentityId
		config.XManagedServiceIdentityId = &xManagedServiceIdentityId
	}

	// No error
	return nil
}

// AssignProperties_From_SiteConfig populates our SiteConfig from the provided source SiteConfig
func (config *SiteConfig) AssignProperties_From_SiteConfig(source *v1beta20220301s.SiteConfig) error {

	// AcrUseManagedIdentityCreds
	if source.AcrUseManagedIdentityCreds != nil {
		acrUseManagedIdentityCred := *source.AcrUseManagedIdentityCreds
		config.AcrUseManagedIdentityCreds = &acrUseManagedIdentityCred
	} else {
		config.AcrUseManagedIdentityCreds = nil
	}

	// AcrUserManagedIdentityID
	config.AcrUserManagedIdentityID = genruntime.ClonePointerToString(source.AcrUserManagedIdentityID)

	// AlwaysOn
	if source.AlwaysOn != nil {
		alwaysOn := *source.AlwaysOn
		config.AlwaysOn = &alwaysOn
	} else {
		config.AlwaysOn = nil
	}

	// ApiDefinition
	if source.ApiDefinition != nil {
		var apiDefinition ApiDefinitionInfo
		err := apiDefinition.AssignProperties_From_ApiDefinitionInfo(source.ApiDefinition)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ApiDefinitionInfo() to populate field ApiDefinition")
		}
		config.ApiDefinition = &apiDefinition
	} else {
		config.ApiDefinition = nil
	}

	// ApiManagementConfig
	if source.ApiManagementConfig != nil {
		var apiManagementConfig ApiManagementConfig
		err := apiManagementConfig.AssignProperties_From_ApiManagementConfig(source.ApiManagementConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ApiManagementConfig() to populate field ApiManagementConfig")
		}
		config.ApiManagementConfig = &apiManagementConfig
	} else {
		config.ApiManagementConfig = nil
	}

	// AppCommandLine
	config.AppCommandLine = genruntime.ClonePointerToString(source.AppCommandLine)

	// AppSettings
	if source.AppSettings != nil {
		appSettingList := make([]NameValuePair, len(source.AppSettings))
		for appSettingIndex, appSettingItem := range source.AppSettings {
			// Shadow the loop variable to avoid aliasing
			appSettingItem := appSettingItem
			var appSetting NameValuePair
			err := appSetting.AssignProperties_From_NameValuePair(&appSettingItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_NameValuePair() to populate field AppSettings")
			}
			appSettingList[appSettingIndex] = appSetting
		}
		config.AppSettings = appSettingList
	} else {
		config.AppSettings = nil
	}

	// AutoHealEnabled
	if source.AutoHealEnabled != nil {
		autoHealEnabled := *source.AutoHealEnabled
		config.AutoHealEnabled = &autoHealEnabled
	} else {
		config.AutoHealEnabled = nil
	}

	// AutoHealRules
	if source.AutoHealRules != nil {
		var autoHealRule AutoHealRules
		err := autoHealRule.AssignProperties_From_AutoHealRules(source.AutoHealRules)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AutoHealRules() to populate field AutoHealRules")
		}
		config.AutoHealRules = &autoHealRule
	} else {
		config.AutoHealRules = nil
	}

	// AutoSwapSlotName
	config.AutoSwapSlotName = genruntime.ClonePointerToString(source.AutoSwapSlotName)

	// AzureStorageAccounts
	if source.AzureStorageAccounts != nil {
		azureStorageAccountMap := make(map[string]AzureStorageInfoValue, len(source.AzureStorageAccounts))
		for azureStorageAccountKey, azureStorageAccountValue := range source.AzureStorageAccounts {
			// Shadow the loop variable to avoid aliasing
			azureStorageAccountValue := azureStorageAccountValue
			var azureStorageAccount AzureStorageInfoValue
			err := azureStorageAccount.AssignProperties_From_AzureStorageInfoValue(&azureStorageAccountValue)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_AzureStorageInfoValue() to populate field AzureStorageAccounts")
			}
			azureStorageAccountMap[azureStorageAccountKey] = azureStorageAccount
		}
		config.AzureStorageAccounts = azureStorageAccountMap
	} else {
		config.AzureStorageAccounts = nil
	}

	// ConnectionStrings
	if source.ConnectionStrings != nil {
		connectionStringList := make([]ConnStringInfo, len(source.ConnectionStrings))
		for connectionStringIndex, connectionStringItem := range source.ConnectionStrings {
			// Shadow the loop variable to avoid aliasing
			connectionStringItem := connectionStringItem
			var connectionString ConnStringInfo
			err := connectionString.AssignProperties_From_ConnStringInfo(&connectionStringItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ConnStringInfo() to populate field ConnectionStrings")
			}
			connectionStringList[connectionStringIndex] = connectionString
		}
		config.ConnectionStrings = connectionStringList
	} else {
		config.ConnectionStrings = nil
	}

	// Cors
	if source.Cors != nil {
		var cor CorsSettings
		err := cor.AssignProperties_From_CorsSettings(source.Cors)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CorsSettings() to populate field Cors")
		}
		config.Cors = &cor
	} else {
		config.Cors = nil
	}

	// DefaultDocuments
	config.DefaultDocuments = genruntime.CloneSliceOfString(source.DefaultDocuments)

	// DetailedErrorLoggingEnabled
	if source.DetailedErrorLoggingEnabled != nil {
		detailedErrorLoggingEnabled := *source.DetailedErrorLoggingEnabled
		config.DetailedErrorLoggingEnabled = &detailedErrorLoggingEnabled
	} else {
		config.DetailedErrorLoggingEnabled = nil
	}

	// DocumentRoot
	config.DocumentRoot = genruntime.ClonePointerToString(source.DocumentRoot)

	// Experiments
	if source.Experiments != nil {
		var experiment Experiments
		err := experiment.AssignProperties_From_Experiments(source.Experiments)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Experiments() to populate field Experiments")
		}
		config.Experiments = &experiment
	} else {
		config.Experiments = nil
	}

	// FtpsState
	if source.FtpsState != nil {
		ftpsState := SiteConfig_FtpsState(*source.FtpsState)
		config.FtpsState = &ftpsState
	} else {
		config.FtpsState = nil
	}

	// FunctionAppScaleLimit
	if source.FunctionAppScaleLimit != nil {
		functionAppScaleLimit := *source.FunctionAppScaleLimit
		config.FunctionAppScaleLimit = &functionAppScaleLimit
	} else {
		config.FunctionAppScaleLimit = nil
	}

	// FunctionsRuntimeScaleMonitoringEnabled
	if source.FunctionsRuntimeScaleMonitoringEnabled != nil {
		functionsRuntimeScaleMonitoringEnabled := *source.FunctionsRuntimeScaleMonitoringEnabled
		config.FunctionsRuntimeScaleMonitoringEnabled = &functionsRuntimeScaleMonitoringEnabled
	} else {
		config.FunctionsRuntimeScaleMonitoringEnabled = nil
	}

	// HandlerMappings
	if source.HandlerMappings != nil {
		handlerMappingList := make([]HandlerMapping, len(source.HandlerMappings))
		for handlerMappingIndex, handlerMappingItem := range source.HandlerMappings {
			// Shadow the loop variable to avoid aliasing
			handlerMappingItem := handlerMappingItem
			var handlerMapping HandlerMapping
			err := handlerMapping.AssignProperties_From_HandlerMapping(&handlerMappingItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_HandlerMapping() to populate field HandlerMappings")
			}
			handlerMappingList[handlerMappingIndex] = handlerMapping
		}
		config.HandlerMappings = handlerMappingList
	} else {
		config.HandlerMappings = nil
	}

	// HealthCheckPath
	config.HealthCheckPath = genruntime.ClonePointerToString(source.HealthCheckPath)

	// Http20Enabled
	if source.Http20Enabled != nil {
		http20Enabled := *source.Http20Enabled
		config.Http20Enabled = &http20Enabled
	} else {
		config.Http20Enabled = nil
	}

	// HttpLoggingEnabled
	if source.HttpLoggingEnabled != nil {
		httpLoggingEnabled := *source.HttpLoggingEnabled
		config.HttpLoggingEnabled = &httpLoggingEnabled
	} else {
		config.HttpLoggingEnabled = nil
	}

	// IpSecurityRestrictions
	if source.IpSecurityRestrictions != nil {
		ipSecurityRestrictionList := make([]IpSecurityRestriction, len(source.IpSecurityRestrictions))
		for ipSecurityRestrictionIndex, ipSecurityRestrictionItem := range source.IpSecurityRestrictions {
			// Shadow the loop variable to avoid aliasing
			ipSecurityRestrictionItem := ipSecurityRestrictionItem
			var ipSecurityRestriction IpSecurityRestriction
			err := ipSecurityRestriction.AssignProperties_From_IpSecurityRestriction(&ipSecurityRestrictionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_IpSecurityRestriction() to populate field IpSecurityRestrictions")
			}
			ipSecurityRestrictionList[ipSecurityRestrictionIndex] = ipSecurityRestriction
		}
		config.IpSecurityRestrictions = ipSecurityRestrictionList
	} else {
		config.IpSecurityRestrictions = nil
	}

	// JavaContainer
	config.JavaContainer = genruntime.ClonePointerToString(source.JavaContainer)

	// JavaContainerVersion
	config.JavaContainerVersion = genruntime.ClonePointerToString(source.JavaContainerVersion)

	// JavaVersion
	config.JavaVersion = genruntime.ClonePointerToString(source.JavaVersion)

	// KeyVaultReferenceIdentity
	config.KeyVaultReferenceIdentity = genruntime.ClonePointerToString(source.KeyVaultReferenceIdentity)

	// Limits
	if source.Limits != nil {
		var limit SiteLimits
		err := limit.AssignProperties_From_SiteLimits(source.Limits)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SiteLimits() to populate field Limits")
		}
		config.Limits = &limit
	} else {
		config.Limits = nil
	}

	// LinuxFxVersion
	config.LinuxFxVersion = genruntime.ClonePointerToString(source.LinuxFxVersion)

	// LoadBalancing
	if source.LoadBalancing != nil {
		loadBalancing := SiteConfig_LoadBalancing(*source.LoadBalancing)
		config.LoadBalancing = &loadBalancing
	} else {
		config.LoadBalancing = nil
	}

	// LocalMySqlEnabled
	if source.LocalMySqlEnabled != nil {
		localMySqlEnabled := *source.LocalMySqlEnabled
		config.LocalMySqlEnabled = &localMySqlEnabled
	} else {
		config.LocalMySqlEnabled = nil
	}

	// LogsDirectorySizeLimit
	config.LogsDirectorySizeLimit = genruntime.ClonePointerToInt(source.LogsDirectorySizeLimit)

	// ManagedPipelineMode
	if source.ManagedPipelineMode != nil {
		managedPipelineMode := SiteConfig_ManagedPipelineMode(*source.ManagedPipelineMode)
		config.ManagedPipelineMode = &managedPipelineMode
	} else {
		config.ManagedPipelineMode = nil
	}

	// ManagedServiceIdentityId
	config.ManagedServiceIdentityId = genruntime.ClonePointerToInt(source.ManagedServiceIdentityId)

	// MinTlsVersion
	if source.MinTlsVersion != nil {
		minTlsVersion := SiteConfig_MinTlsVersion(*source.MinTlsVersion)
		config.MinTlsVersion = &minTlsVersion
	} else {
		config.MinTlsVersion = nil
	}

	// MinimumElasticInstanceCount
	if source.MinimumElasticInstanceCount != nil {
		minimumElasticInstanceCount := *source.MinimumElasticInstanceCount
		config.MinimumElasticInstanceCount = &minimumElasticInstanceCount
	} else {
		config.MinimumElasticInstanceCount = nil
	}

	// NetFrameworkVersion
	config.NetFrameworkVersion = genruntime.ClonePointerToString(source.NetFrameworkVersion)

	// NodeVersion
	config.NodeVersion = genruntime.ClonePointerToString(source.NodeVersion)

	// NumberOfWorkers
	config.NumberOfWorkers = genruntime.ClonePointerToInt(source.NumberOfWorkers)

	// PhpVersion
	config.PhpVersion = genruntime.ClonePointerToString(source.PhpVersion)

	// PowerShellVersion
	config.PowerShellVersion = genruntime.ClonePointerToString(source.PowerShellVersion)

	// PreWarmedInstanceCount
	if source.PreWarmedInstanceCount != nil {
		preWarmedInstanceCount := *source.PreWarmedInstanceCount
		config.PreWarmedInstanceCount = &preWarmedInstanceCount
	} else {
		config.PreWarmedInstanceCount = nil
	}

	// PublicNetworkAccess
	config.PublicNetworkAccess = genruntime.ClonePointerToString(source.PublicNetworkAccess)

	// PublishingUsername
	config.PublishingUsername = genruntime.ClonePointerToString(source.PublishingUsername)

	// Push
	if source.Push != nil {
		var push PushSettings
		err := push.AssignProperties_From_PushSettings(source.Push)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PushSettings() to populate field Push")
		}
		config.Push = &push
	} else {
		config.Push = nil
	}

	// PythonVersion
	config.PythonVersion = genruntime.ClonePointerToString(source.PythonVersion)

	// RemoteDebuggingEnabled
	if source.RemoteDebuggingEnabled != nil {
		remoteDebuggingEnabled := *source.RemoteDebuggingEnabled
		config.RemoteDebuggingEnabled = &remoteDebuggingEnabled
	} else {
		config.RemoteDebuggingEnabled = nil
	}

	// RemoteDebuggingVersion
	config.RemoteDebuggingVersion = genruntime.ClonePointerToString(source.RemoteDebuggingVersion)

	// RequestTracingEnabled
	if source.RequestTracingEnabled != nil {
		requestTracingEnabled := *source.RequestTracingEnabled
		config.RequestTracingEnabled = &requestTracingEnabled
	} else {
		config.RequestTracingEnabled = nil
	}

	// RequestTracingExpirationTime
	config.RequestTracingExpirationTime = genruntime.ClonePointerToString(source.RequestTracingExpirationTime)

	// ScmIpSecurityRestrictions
	if source.ScmIpSecurityRestrictions != nil {
		scmIpSecurityRestrictionList := make([]IpSecurityRestriction, len(source.ScmIpSecurityRestrictions))
		for scmIpSecurityRestrictionIndex, scmIpSecurityRestrictionItem := range source.ScmIpSecurityRestrictions {
			// Shadow the loop variable to avoid aliasing
			scmIpSecurityRestrictionItem := scmIpSecurityRestrictionItem
			var scmIpSecurityRestriction IpSecurityRestriction
			err := scmIpSecurityRestriction.AssignProperties_From_IpSecurityRestriction(&scmIpSecurityRestrictionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_IpSecurityRestriction() to populate field ScmIpSecurityRestrictions")
			}
			scmIpSecurityRestrictionList[scmIpSecurityRestrictionIndex] = scmIpSecurityRestriction
		}
		config.ScmIpSecurityRestrictions = scmIpSecurityRestrictionList
	} else {
		config.ScmIpSecurityRestrictions = nil
	}

	// ScmIpSecurityRestrictionsUseMain
	if source.ScmIpSecurityRestrictionsUseMain != nil {
		scmIpSecurityRestrictionsUseMain := *source.ScmIpSecurityRestrictionsUseMain
		config.ScmIpSecurityRestrictionsUseMain = &scmIpSecurityRestrictionsUseMain
	} else {
		config.ScmIpSecurityRestrictionsUseMain = nil
	}

	// ScmMinTlsVersion
	if source.ScmMinTlsVersion != nil {
		scmMinTlsVersion := SiteConfig_ScmMinTlsVersion(*source.ScmMinTlsVersion)
		config.ScmMinTlsVersion = &scmMinTlsVersion
	} else {
		config.ScmMinTlsVersion = nil
	}

	// ScmType
	if source.ScmType != nil {
		scmType := SiteConfig_ScmType(*source.ScmType)
		config.ScmType = &scmType
	} else {
		config.ScmType = nil
	}

	// TracingOptions
	config.TracingOptions = genruntime.ClonePointerToString(source.TracingOptions)

	// Use32BitWorkerProcess
	if source.Use32BitWorkerProcess != nil {
		use32BitWorkerProcess := *source.Use32BitWorkerProcess
		config.Use32BitWorkerProcess = &use32BitWorkerProcess
	} else {
		config.Use32BitWorkerProcess = nil
	}

	// VirtualApplications
	if source.VirtualApplications != nil {
		virtualApplicationList := make([]VirtualApplication, len(source.VirtualApplications))
		for virtualApplicationIndex, virtualApplicationItem := range source.VirtualApplications {
			// Shadow the loop variable to avoid aliasing
			virtualApplicationItem := virtualApplicationItem
			var virtualApplication VirtualApplication
			err := virtualApplication.AssignProperties_From_VirtualApplication(&virtualApplicationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VirtualApplication() to populate field VirtualApplications")
			}
			virtualApplicationList[virtualApplicationIndex] = virtualApplication
		}
		config.VirtualApplications = virtualApplicationList
	} else {
		config.VirtualApplications = nil
	}

	// VnetName
	config.VnetName = genruntime.ClonePointerToString(source.VnetName)

	// VnetPrivatePortsCount
	config.VnetPrivatePortsCount = genruntime.ClonePointerToInt(source.VnetPrivatePortsCount)

	// VnetRouteAllEnabled
	if source.VnetRouteAllEnabled != nil {
		vnetRouteAllEnabled := *source.VnetRouteAllEnabled
		config.VnetRouteAllEnabled = &vnetRouteAllEnabled
	} else {
		config.VnetRouteAllEnabled = nil
	}

	// WebSocketsEnabled
	if source.WebSocketsEnabled != nil {
		webSocketsEnabled := *source.WebSocketsEnabled
		config.WebSocketsEnabled = &webSocketsEnabled
	} else {
		config.WebSocketsEnabled = nil
	}

	// WebsiteTimeZone
	config.WebsiteTimeZone = genruntime.ClonePointerToString(source.WebsiteTimeZone)

	// WindowsFxVersion
	config.WindowsFxVersion = genruntime.ClonePointerToString(source.WindowsFxVersion)

	// XManagedServiceIdentityId
	config.XManagedServiceIdentityId = genruntime.ClonePointerToInt(source.XManagedServiceIdentityId)

	// No error
	return nil
}

// AssignProperties_To_SiteConfig populates the provided destination SiteConfig from our SiteConfig
func (config *SiteConfig) AssignProperties_To_SiteConfig(destination *v1beta20220301s.SiteConfig) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AcrUseManagedIdentityCreds
	if config.AcrUseManagedIdentityCreds != nil {
		acrUseManagedIdentityCred := *config.AcrUseManagedIdentityCreds
		destination.AcrUseManagedIdentityCreds = &acrUseManagedIdentityCred
	} else {
		destination.AcrUseManagedIdentityCreds = nil
	}

	// AcrUserManagedIdentityID
	destination.AcrUserManagedIdentityID = genruntime.ClonePointerToString(config.AcrUserManagedIdentityID)

	// AlwaysOn
	if config.AlwaysOn != nil {
		alwaysOn := *config.AlwaysOn
		destination.AlwaysOn = &alwaysOn
	} else {
		destination.AlwaysOn = nil
	}

	// ApiDefinition
	if config.ApiDefinition != nil {
		var apiDefinition v1beta20220301s.ApiDefinitionInfo
		err := config.ApiDefinition.AssignProperties_To_ApiDefinitionInfo(&apiDefinition)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ApiDefinitionInfo() to populate field ApiDefinition")
		}
		destination.ApiDefinition = &apiDefinition
	} else {
		destination.ApiDefinition = nil
	}

	// ApiManagementConfig
	if config.ApiManagementConfig != nil {
		var apiManagementConfig v1beta20220301s.ApiManagementConfig
		err := config.ApiManagementConfig.AssignProperties_To_ApiManagementConfig(&apiManagementConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ApiManagementConfig() to populate field ApiManagementConfig")
		}
		destination.ApiManagementConfig = &apiManagementConfig
	} else {
		destination.ApiManagementConfig = nil
	}

	// AppCommandLine
	destination.AppCommandLine = genruntime.ClonePointerToString(config.AppCommandLine)

	// AppSettings
	if config.AppSettings != nil {
		appSettingList := make([]v1beta20220301s.NameValuePair, len(config.AppSettings))
		for appSettingIndex, appSettingItem := range config.AppSettings {
			// Shadow the loop variable to avoid aliasing
			appSettingItem := appSettingItem
			var appSetting v1beta20220301s.NameValuePair
			err := appSettingItem.AssignProperties_To_NameValuePair(&appSetting)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_NameValuePair() to populate field AppSettings")
			}
			appSettingList[appSettingIndex] = appSetting
		}
		destination.AppSettings = appSettingList
	} else {
		destination.AppSettings = nil
	}

	// AutoHealEnabled
	if config.AutoHealEnabled != nil {
		autoHealEnabled := *config.AutoHealEnabled
		destination.AutoHealEnabled = &autoHealEnabled
	} else {
		destination.AutoHealEnabled = nil
	}

	// AutoHealRules
	if config.AutoHealRules != nil {
		var autoHealRule v1beta20220301s.AutoHealRules
		err := config.AutoHealRules.AssignProperties_To_AutoHealRules(&autoHealRule)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AutoHealRules() to populate field AutoHealRules")
		}
		destination.AutoHealRules = &autoHealRule
	} else {
		destination.AutoHealRules = nil
	}

	// AutoSwapSlotName
	destination.AutoSwapSlotName = genruntime.ClonePointerToString(config.AutoSwapSlotName)

	// AzureStorageAccounts
	if config.AzureStorageAccounts != nil {
		azureStorageAccountMap := make(map[string]v1beta20220301s.AzureStorageInfoValue, len(config.AzureStorageAccounts))
		for azureStorageAccountKey, azureStorageAccountValue := range config.AzureStorageAccounts {
			// Shadow the loop variable to avoid aliasing
			azureStorageAccountValue := azureStorageAccountValue
			var azureStorageAccount v1beta20220301s.AzureStorageInfoValue
			err := azureStorageAccountValue.AssignProperties_To_AzureStorageInfoValue(&azureStorageAccount)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_AzureStorageInfoValue() to populate field AzureStorageAccounts")
			}
			azureStorageAccountMap[azureStorageAccountKey] = azureStorageAccount
		}
		destination.AzureStorageAccounts = azureStorageAccountMap
	} else {
		destination.AzureStorageAccounts = nil
	}

	// ConnectionStrings
	if config.ConnectionStrings != nil {
		connectionStringList := make([]v1beta20220301s.ConnStringInfo, len(config.ConnectionStrings))
		for connectionStringIndex, connectionStringItem := range config.ConnectionStrings {
			// Shadow the loop variable to avoid aliasing
			connectionStringItem := connectionStringItem
			var connectionString v1beta20220301s.ConnStringInfo
			err := connectionStringItem.AssignProperties_To_ConnStringInfo(&connectionString)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ConnStringInfo() to populate field ConnectionStrings")
			}
			connectionStringList[connectionStringIndex] = connectionString
		}
		destination.ConnectionStrings = connectionStringList
	} else {
		destination.ConnectionStrings = nil
	}

	// Cors
	if config.Cors != nil {
		var cor v1beta20220301s.CorsSettings
		err := config.Cors.AssignProperties_To_CorsSettings(&cor)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CorsSettings() to populate field Cors")
		}
		destination.Cors = &cor
	} else {
		destination.Cors = nil
	}

	// DefaultDocuments
	destination.DefaultDocuments = genruntime.CloneSliceOfString(config.DefaultDocuments)

	// DetailedErrorLoggingEnabled
	if config.DetailedErrorLoggingEnabled != nil {
		detailedErrorLoggingEnabled := *config.DetailedErrorLoggingEnabled
		destination.DetailedErrorLoggingEnabled = &detailedErrorLoggingEnabled
	} else {
		destination.DetailedErrorLoggingEnabled = nil
	}

	// DocumentRoot
	destination.DocumentRoot = genruntime.ClonePointerToString(config.DocumentRoot)

	// Experiments
	if config.Experiments != nil {
		var experiment v1beta20220301s.Experiments
		err := config.Experiments.AssignProperties_To_Experiments(&experiment)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Experiments() to populate field Experiments")
		}
		destination.Experiments = &experiment
	} else {
		destination.Experiments = nil
	}

	// FtpsState
	if config.FtpsState != nil {
		ftpsState := string(*config.FtpsState)
		destination.FtpsState = &ftpsState
	} else {
		destination.FtpsState = nil
	}

	// FunctionAppScaleLimit
	if config.FunctionAppScaleLimit != nil {
		functionAppScaleLimit := *config.FunctionAppScaleLimit
		destination.FunctionAppScaleLimit = &functionAppScaleLimit
	} else {
		destination.FunctionAppScaleLimit = nil
	}

	// FunctionsRuntimeScaleMonitoringEnabled
	if config.FunctionsRuntimeScaleMonitoringEnabled != nil {
		functionsRuntimeScaleMonitoringEnabled := *config.FunctionsRuntimeScaleMonitoringEnabled
		destination.FunctionsRuntimeScaleMonitoringEnabled = &functionsRuntimeScaleMonitoringEnabled
	} else {
		destination.FunctionsRuntimeScaleMonitoringEnabled = nil
	}

	// HandlerMappings
	if config.HandlerMappings != nil {
		handlerMappingList := make([]v1beta20220301s.HandlerMapping, len(config.HandlerMappings))
		for handlerMappingIndex, handlerMappingItem := range config.HandlerMappings {
			// Shadow the loop variable to avoid aliasing
			handlerMappingItem := handlerMappingItem
			var handlerMapping v1beta20220301s.HandlerMapping
			err := handlerMappingItem.AssignProperties_To_HandlerMapping(&handlerMapping)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_HandlerMapping() to populate field HandlerMappings")
			}
			handlerMappingList[handlerMappingIndex] = handlerMapping
		}
		destination.HandlerMappings = handlerMappingList
	} else {
		destination.HandlerMappings = nil
	}

	// HealthCheckPath
	destination.HealthCheckPath = genruntime.ClonePointerToString(config.HealthCheckPath)

	// Http20Enabled
	if config.Http20Enabled != nil {
		http20Enabled := *config.Http20Enabled
		destination.Http20Enabled = &http20Enabled
	} else {
		destination.Http20Enabled = nil
	}

	// HttpLoggingEnabled
	if config.HttpLoggingEnabled != nil {
		httpLoggingEnabled := *config.HttpLoggingEnabled
		destination.HttpLoggingEnabled = &httpLoggingEnabled
	} else {
		destination.HttpLoggingEnabled = nil
	}

	// IpSecurityRestrictions
	if config.IpSecurityRestrictions != nil {
		ipSecurityRestrictionList := make([]v1beta20220301s.IpSecurityRestriction, len(config.IpSecurityRestrictions))
		for ipSecurityRestrictionIndex, ipSecurityRestrictionItem := range config.IpSecurityRestrictions {
			// Shadow the loop variable to avoid aliasing
			ipSecurityRestrictionItem := ipSecurityRestrictionItem
			var ipSecurityRestriction v1beta20220301s.IpSecurityRestriction
			err := ipSecurityRestrictionItem.AssignProperties_To_IpSecurityRestriction(&ipSecurityRestriction)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_IpSecurityRestriction() to populate field IpSecurityRestrictions")
			}
			ipSecurityRestrictionList[ipSecurityRestrictionIndex] = ipSecurityRestriction
		}
		destination.IpSecurityRestrictions = ipSecurityRestrictionList
	} else {
		destination.IpSecurityRestrictions = nil
	}

	// JavaContainer
	destination.JavaContainer = genruntime.ClonePointerToString(config.JavaContainer)

	// JavaContainerVersion
	destination.JavaContainerVersion = genruntime.ClonePointerToString(config.JavaContainerVersion)

	// JavaVersion
	destination.JavaVersion = genruntime.ClonePointerToString(config.JavaVersion)

	// KeyVaultReferenceIdentity
	destination.KeyVaultReferenceIdentity = genruntime.ClonePointerToString(config.KeyVaultReferenceIdentity)

	// Limits
	if config.Limits != nil {
		var limit v1beta20220301s.SiteLimits
		err := config.Limits.AssignProperties_To_SiteLimits(&limit)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SiteLimits() to populate field Limits")
		}
		destination.Limits = &limit
	} else {
		destination.Limits = nil
	}

	// LinuxFxVersion
	destination.LinuxFxVersion = genruntime.ClonePointerToString(config.LinuxFxVersion)

	// LoadBalancing
	if config.LoadBalancing != nil {
		loadBalancing := string(*config.LoadBalancing)
		destination.LoadBalancing = &loadBalancing
	} else {
		destination.LoadBalancing = nil
	}

	// LocalMySqlEnabled
	if config.LocalMySqlEnabled != nil {
		localMySqlEnabled := *config.LocalMySqlEnabled
		destination.LocalMySqlEnabled = &localMySqlEnabled
	} else {
		destination.LocalMySqlEnabled = nil
	}

	// LogsDirectorySizeLimit
	destination.LogsDirectorySizeLimit = genruntime.ClonePointerToInt(config.LogsDirectorySizeLimit)

	// ManagedPipelineMode
	if config.ManagedPipelineMode != nil {
		managedPipelineMode := string(*config.ManagedPipelineMode)
		destination.ManagedPipelineMode = &managedPipelineMode
	} else {
		destination.ManagedPipelineMode = nil
	}

	// ManagedServiceIdentityId
	destination.ManagedServiceIdentityId = genruntime.ClonePointerToInt(config.ManagedServiceIdentityId)

	// MinTlsVersion
	if config.MinTlsVersion != nil {
		minTlsVersion := string(*config.MinTlsVersion)
		destination.MinTlsVersion = &minTlsVersion
	} else {
		destination.MinTlsVersion = nil
	}

	// MinimumElasticInstanceCount
	if config.MinimumElasticInstanceCount != nil {
		minimumElasticInstanceCount := *config.MinimumElasticInstanceCount
		destination.MinimumElasticInstanceCount = &minimumElasticInstanceCount
	} else {
		destination.MinimumElasticInstanceCount = nil
	}

	// NetFrameworkVersion
	destination.NetFrameworkVersion = genruntime.ClonePointerToString(config.NetFrameworkVersion)

	// NodeVersion
	destination.NodeVersion = genruntime.ClonePointerToString(config.NodeVersion)

	// NumberOfWorkers
	destination.NumberOfWorkers = genruntime.ClonePointerToInt(config.NumberOfWorkers)

	// PhpVersion
	destination.PhpVersion = genruntime.ClonePointerToString(config.PhpVersion)

	// PowerShellVersion
	destination.PowerShellVersion = genruntime.ClonePointerToString(config.PowerShellVersion)

	// PreWarmedInstanceCount
	if config.PreWarmedInstanceCount != nil {
		preWarmedInstanceCount := *config.PreWarmedInstanceCount
		destination.PreWarmedInstanceCount = &preWarmedInstanceCount
	} else {
		destination.PreWarmedInstanceCount = nil
	}

	// PublicNetworkAccess
	destination.PublicNetworkAccess = genruntime.ClonePointerToString(config.PublicNetworkAccess)

	// PublishingUsername
	destination.PublishingUsername = genruntime.ClonePointerToString(config.PublishingUsername)

	// Push
	if config.Push != nil {
		var push v1beta20220301s.PushSettings
		err := config.Push.AssignProperties_To_PushSettings(&push)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PushSettings() to populate field Push")
		}
		destination.Push = &push
	} else {
		destination.Push = nil
	}

	// PythonVersion
	destination.PythonVersion = genruntime.ClonePointerToString(config.PythonVersion)

	// RemoteDebuggingEnabled
	if config.RemoteDebuggingEnabled != nil {
		remoteDebuggingEnabled := *config.RemoteDebuggingEnabled
		destination.RemoteDebuggingEnabled = &remoteDebuggingEnabled
	} else {
		destination.RemoteDebuggingEnabled = nil
	}

	// RemoteDebuggingVersion
	destination.RemoteDebuggingVersion = genruntime.ClonePointerToString(config.RemoteDebuggingVersion)

	// RequestTracingEnabled
	if config.RequestTracingEnabled != nil {
		requestTracingEnabled := *config.RequestTracingEnabled
		destination.RequestTracingEnabled = &requestTracingEnabled
	} else {
		destination.RequestTracingEnabled = nil
	}

	// RequestTracingExpirationTime
	destination.RequestTracingExpirationTime = genruntime.ClonePointerToString(config.RequestTracingExpirationTime)

	// ScmIpSecurityRestrictions
	if config.ScmIpSecurityRestrictions != nil {
		scmIpSecurityRestrictionList := make([]v1beta20220301s.IpSecurityRestriction, len(config.ScmIpSecurityRestrictions))
		for scmIpSecurityRestrictionIndex, scmIpSecurityRestrictionItem := range config.ScmIpSecurityRestrictions {
			// Shadow the loop variable to avoid aliasing
			scmIpSecurityRestrictionItem := scmIpSecurityRestrictionItem
			var scmIpSecurityRestriction v1beta20220301s.IpSecurityRestriction
			err := scmIpSecurityRestrictionItem.AssignProperties_To_IpSecurityRestriction(&scmIpSecurityRestriction)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_IpSecurityRestriction() to populate field ScmIpSecurityRestrictions")
			}
			scmIpSecurityRestrictionList[scmIpSecurityRestrictionIndex] = scmIpSecurityRestriction
		}
		destination.ScmIpSecurityRestrictions = scmIpSecurityRestrictionList
	} else {
		destination.ScmIpSecurityRestrictions = nil
	}

	// ScmIpSecurityRestrictionsUseMain
	if config.ScmIpSecurityRestrictionsUseMain != nil {
		scmIpSecurityRestrictionsUseMain := *config.ScmIpSecurityRestrictionsUseMain
		destination.ScmIpSecurityRestrictionsUseMain = &scmIpSecurityRestrictionsUseMain
	} else {
		destination.ScmIpSecurityRestrictionsUseMain = nil
	}

	// ScmMinTlsVersion
	if config.ScmMinTlsVersion != nil {
		scmMinTlsVersion := string(*config.ScmMinTlsVersion)
		destination.ScmMinTlsVersion = &scmMinTlsVersion
	} else {
		destination.ScmMinTlsVersion = nil
	}

	// ScmType
	if config.ScmType != nil {
		scmType := string(*config.ScmType)
		destination.ScmType = &scmType
	} else {
		destination.ScmType = nil
	}

	// TracingOptions
	destination.TracingOptions = genruntime.ClonePointerToString(config.TracingOptions)

	// Use32BitWorkerProcess
	if config.Use32BitWorkerProcess != nil {
		use32BitWorkerProcess := *config.Use32BitWorkerProcess
		destination.Use32BitWorkerProcess = &use32BitWorkerProcess
	} else {
		destination.Use32BitWorkerProcess = nil
	}

	// VirtualApplications
	if config.VirtualApplications != nil {
		virtualApplicationList := make([]v1beta20220301s.VirtualApplication, len(config.VirtualApplications))
		for virtualApplicationIndex, virtualApplicationItem := range config.VirtualApplications {
			// Shadow the loop variable to avoid aliasing
			virtualApplicationItem := virtualApplicationItem
			var virtualApplication v1beta20220301s.VirtualApplication
			err := virtualApplicationItem.AssignProperties_To_VirtualApplication(&virtualApplication)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VirtualApplication() to populate field VirtualApplications")
			}
			virtualApplicationList[virtualApplicationIndex] = virtualApplication
		}
		destination.VirtualApplications = virtualApplicationList
	} else {
		destination.VirtualApplications = nil
	}

	// VnetName
	destination.VnetName = genruntime.ClonePointerToString(config.VnetName)

	// VnetPrivatePortsCount
	destination.VnetPrivatePortsCount = genruntime.ClonePointerToInt(config.VnetPrivatePortsCount)

	// VnetRouteAllEnabled
	if config.VnetRouteAllEnabled != nil {
		vnetRouteAllEnabled := *config.VnetRouteAllEnabled
		destination.VnetRouteAllEnabled = &vnetRouteAllEnabled
	} else {
		destination.VnetRouteAllEnabled = nil
	}

	// WebSocketsEnabled
	if config.WebSocketsEnabled != nil {
		webSocketsEnabled := *config.WebSocketsEnabled
		destination.WebSocketsEnabled = &webSocketsEnabled
	} else {
		destination.WebSocketsEnabled = nil
	}

	// WebsiteTimeZone
	destination.WebsiteTimeZone = genruntime.ClonePointerToString(config.WebsiteTimeZone)

	// WindowsFxVersion
	destination.WindowsFxVersion = genruntime.ClonePointerToString(config.WindowsFxVersion)

	// XManagedServiceIdentityId
	destination.XManagedServiceIdentityId = genruntime.ClonePointerToInt(config.XManagedServiceIdentityId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of SiteConfig_STATUS. Use v1api20220301.SiteConfig_STATUS instead
type SiteConfig_STATUS struct {
	AcrUseManagedIdentityCreds             *bool                                   `json:"acrUseManagedIdentityCreds,omitempty"`
	AcrUserManagedIdentityID               *string                                 `json:"acrUserManagedIdentityID,omitempty"`
	AlwaysOn                               *bool                                   `json:"alwaysOn,omitempty"`
	ApiDefinition                          *ApiDefinitionInfo_STATUS               `json:"apiDefinition,omitempty"`
	ApiManagementConfig                    *ApiManagementConfig_STATUS             `json:"apiManagementConfig,omitempty"`
	AppCommandLine                         *string                                 `json:"appCommandLine,omitempty"`
	AppSettings                            []NameValuePair_STATUS                  `json:"appSettings,omitempty"`
	AutoHealEnabled                        *bool                                   `json:"autoHealEnabled,omitempty"`
	AutoHealRules                          *AutoHealRules_STATUS                   `json:"autoHealRules,omitempty"`
	AutoSwapSlotName                       *string                                 `json:"autoSwapSlotName,omitempty"`
	AzureStorageAccounts                   map[string]AzureStorageInfoValue_STATUS `json:"azureStorageAccounts,omitempty"`
	ConnectionStrings                      []ConnStringInfo_STATUS                 `json:"connectionStrings,omitempty"`
	Cors                                   *CorsSettings_STATUS                    `json:"cors,omitempty"`
	DefaultDocuments                       []string                                `json:"defaultDocuments,omitempty"`
	DetailedErrorLoggingEnabled            *bool                                   `json:"detailedErrorLoggingEnabled,omitempty"`
	DocumentRoot                           *string                                 `json:"documentRoot,omitempty"`
	Experiments                            *Experiments_STATUS                     `json:"experiments,omitempty"`
	FtpsState                              *SiteConfig_FtpsState_STATUS            `json:"ftpsState,omitempty"`
	FunctionAppScaleLimit                  *int                                    `json:"functionAppScaleLimit,omitempty"`
	FunctionsRuntimeScaleMonitoringEnabled *bool                                   `json:"functionsRuntimeScaleMonitoringEnabled,omitempty"`
	HandlerMappings                        []HandlerMapping_STATUS                 `json:"handlerMappings,omitempty"`
	HealthCheckPath                        *string                                 `json:"healthCheckPath,omitempty"`
	Http20Enabled                          *bool                                   `json:"http20Enabled,omitempty"`
	HttpLoggingEnabled                     *bool                                   `json:"httpLoggingEnabled,omitempty"`
	IpSecurityRestrictions                 []IpSecurityRestriction_STATUS          `json:"ipSecurityRestrictions,omitempty"`
	JavaContainer                          *string                                 `json:"javaContainer,omitempty"`
	JavaContainerVersion                   *string                                 `json:"javaContainerVersion,omitempty"`
	JavaVersion                            *string                                 `json:"javaVersion,omitempty"`
	KeyVaultReferenceIdentity              *string                                 `json:"keyVaultReferenceIdentity,omitempty"`
	Limits                                 *SiteLimits_STATUS                      `json:"limits,omitempty"`
	LinuxFxVersion                         *string                                 `json:"linuxFxVersion,omitempty"`
	LoadBalancing                          *SiteConfig_LoadBalancing_STATUS        `json:"loadBalancing,omitempty"`
	LocalMySqlEnabled                      *bool                                   `json:"localMySqlEnabled,omitempty"`
	LogsDirectorySizeLimit                 *int                                    `json:"logsDirectorySizeLimit,omitempty"`
	MachineKey                             *SiteMachineKey_STATUS                  `json:"machineKey,omitempty"`
	ManagedPipelineMode                    *SiteConfig_ManagedPipelineMode_STATUS  `json:"managedPipelineMode,omitempty"`
	ManagedServiceIdentityId               *int                                    `json:"managedServiceIdentityId,omitempty"`
	MinTlsVersion                          *SiteConfig_MinTlsVersion_STATUS        `json:"minTlsVersion,omitempty"`
	MinimumElasticInstanceCount            *int                                    `json:"minimumElasticInstanceCount,omitempty"`
	NetFrameworkVersion                    *string                                 `json:"netFrameworkVersion,omitempty"`
	NodeVersion                            *string                                 `json:"nodeVersion,omitempty"`
	NumberOfWorkers                        *int                                    `json:"numberOfWorkers,omitempty"`
	PhpVersion                             *string                                 `json:"phpVersion,omitempty"`
	PowerShellVersion                      *string                                 `json:"powerShellVersion,omitempty"`
	PreWarmedInstanceCount                 *int                                    `json:"preWarmedInstanceCount,omitempty"`
	PublicNetworkAccess                    *string                                 `json:"publicNetworkAccess,omitempty"`
	PublishingUsername                     *string                                 `json:"publishingUsername,omitempty"`
	Push                                   *PushSettings_STATUS                    `json:"push,omitempty"`
	PythonVersion                          *string                                 `json:"pythonVersion,omitempty"`
	RemoteDebuggingEnabled                 *bool                                   `json:"remoteDebuggingEnabled,omitempty"`
	RemoteDebuggingVersion                 *string                                 `json:"remoteDebuggingVersion,omitempty"`
	RequestTracingEnabled                  *bool                                   `json:"requestTracingEnabled,omitempty"`
	RequestTracingExpirationTime           *string                                 `json:"requestTracingExpirationTime,omitempty"`
	ScmIpSecurityRestrictions              []IpSecurityRestriction_STATUS          `json:"scmIpSecurityRestrictions,omitempty"`
	ScmIpSecurityRestrictionsUseMain       *bool                                   `json:"scmIpSecurityRestrictionsUseMain,omitempty"`
	ScmMinTlsVersion                       *SiteConfig_ScmMinTlsVersion_STATUS     `json:"scmMinTlsVersion,omitempty"`
	ScmType                                *SiteConfig_ScmType_STATUS              `json:"scmType,omitempty"`
	TracingOptions                         *string                                 `json:"tracingOptions,omitempty"`
	Use32BitWorkerProcess                  *bool                                   `json:"use32BitWorkerProcess,omitempty"`
	VirtualApplications                    []VirtualApplication_STATUS             `json:"virtualApplications,omitempty"`
	VnetName                               *string                                 `json:"vnetName,omitempty"`
	VnetPrivatePortsCount                  *int                                    `json:"vnetPrivatePortsCount,omitempty"`
	VnetRouteAllEnabled                    *bool                                   `json:"vnetRouteAllEnabled,omitempty"`
	WebSocketsEnabled                      *bool                                   `json:"webSocketsEnabled,omitempty"`
	WebsiteTimeZone                        *string                                 `json:"websiteTimeZone,omitempty"`
	WindowsFxVersion                       *string                                 `json:"windowsFxVersion,omitempty"`
	XManagedServiceIdentityId              *int                                    `json:"xManagedServiceIdentityId,omitempty"`
}

var _ genruntime.FromARMConverter = &SiteConfig_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (config *SiteConfig_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SiteConfig_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (config *SiteConfig_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SiteConfig_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SiteConfig_STATUS_ARM, got %T", armInput)
	}

	// Set property "AcrUseManagedIdentityCreds":
	if typedInput.AcrUseManagedIdentityCreds != nil {
		acrUseManagedIdentityCreds := *typedInput.AcrUseManagedIdentityCreds
		config.AcrUseManagedIdentityCreds = &acrUseManagedIdentityCreds
	}

	// Set property "AcrUserManagedIdentityID":
	if typedInput.AcrUserManagedIdentityID != nil {
		acrUserManagedIdentityID := *typedInput.AcrUserManagedIdentityID
		config.AcrUserManagedIdentityID = &acrUserManagedIdentityID
	}

	// Set property "AlwaysOn":
	if typedInput.AlwaysOn != nil {
		alwaysOn := *typedInput.AlwaysOn
		config.AlwaysOn = &alwaysOn
	}

	// Set property "ApiDefinition":
	if typedInput.ApiDefinition != nil {
		var apiDefinition1 ApiDefinitionInfo_STATUS
		err := apiDefinition1.PopulateFromARM(owner, *typedInput.ApiDefinition)
		if err != nil {
			return err
		}
		apiDefinition := apiDefinition1
		config.ApiDefinition = &apiDefinition
	}

	// Set property "ApiManagementConfig":
	if typedInput.ApiManagementConfig != nil {
		var apiManagementConfig1 ApiManagementConfig_STATUS
		err := apiManagementConfig1.PopulateFromARM(owner, *typedInput.ApiManagementConfig)
		if err != nil {
			return err
		}
		apiManagementConfig := apiManagementConfig1
		config.ApiManagementConfig = &apiManagementConfig
	}

	// Set property "AppCommandLine":
	if typedInput.AppCommandLine != nil {
		appCommandLine := *typedInput.AppCommandLine
		config.AppCommandLine = &appCommandLine
	}

	// Set property "AppSettings":
	for _, item := range typedInput.AppSettings {
		var item1 NameValuePair_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		config.AppSettings = append(config.AppSettings, item1)
	}

	// Set property "AutoHealEnabled":
	if typedInput.AutoHealEnabled != nil {
		autoHealEnabled := *typedInput.AutoHealEnabled
		config.AutoHealEnabled = &autoHealEnabled
	}

	// Set property "AutoHealRules":
	if typedInput.AutoHealRules != nil {
		var autoHealRules1 AutoHealRules_STATUS
		err := autoHealRules1.PopulateFromARM(owner, *typedInput.AutoHealRules)
		if err != nil {
			return err
		}
		autoHealRules := autoHealRules1
		config.AutoHealRules = &autoHealRules
	}

	// Set property "AutoSwapSlotName":
	if typedInput.AutoSwapSlotName != nil {
		autoSwapSlotName := *typedInput.AutoSwapSlotName
		config.AutoSwapSlotName = &autoSwapSlotName
	}

	// Set property "AzureStorageAccounts":
	if typedInput.AzureStorageAccounts != nil {
		config.AzureStorageAccounts = make(map[string]AzureStorageInfoValue_STATUS, len(typedInput.AzureStorageAccounts))
		for key, value := range typedInput.AzureStorageAccounts {
			var value1 AzureStorageInfoValue_STATUS
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			config.AzureStorageAccounts[key] = value1
		}
	}

	// Set property "ConnectionStrings":
	for _, item := range typedInput.ConnectionStrings {
		var item1 ConnStringInfo_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		config.ConnectionStrings = append(config.ConnectionStrings, item1)
	}

	// Set property "Cors":
	if typedInput.Cors != nil {
		var cors1 CorsSettings_STATUS
		err := cors1.PopulateFromARM(owner, *typedInput.Cors)
		if err != nil {
			return err
		}
		cors := cors1
		config.Cors = &cors
	}

	// Set property "DefaultDocuments":
	for _, item := range typedInput.DefaultDocuments {
		config.DefaultDocuments = append(config.DefaultDocuments, item)
	}

	// Set property "DetailedErrorLoggingEnabled":
	if typedInput.DetailedErrorLoggingEnabled != nil {
		detailedErrorLoggingEnabled := *typedInput.DetailedErrorLoggingEnabled
		config.DetailedErrorLoggingEnabled = &detailedErrorLoggingEnabled
	}

	// Set property "DocumentRoot":
	if typedInput.DocumentRoot != nil {
		documentRoot := *typedInput.DocumentRoot
		config.DocumentRoot = &documentRoot
	}

	// Set property "Experiments":
	if typedInput.Experiments != nil {
		var experiments1 Experiments_STATUS
		err := experiments1.PopulateFromARM(owner, *typedInput.Experiments)
		if err != nil {
			return err
		}
		experiments := experiments1
		config.Experiments = &experiments
	}

	// Set property "FtpsState":
	if typedInput.FtpsState != nil {
		ftpsState := *typedInput.FtpsState
		config.FtpsState = &ftpsState
	}

	// Set property "FunctionAppScaleLimit":
	if typedInput.FunctionAppScaleLimit != nil {
		functionAppScaleLimit := *typedInput.FunctionAppScaleLimit
		config.FunctionAppScaleLimit = &functionAppScaleLimit
	}

	// Set property "FunctionsRuntimeScaleMonitoringEnabled":
	if typedInput.FunctionsRuntimeScaleMonitoringEnabled != nil {
		functionsRuntimeScaleMonitoringEnabled := *typedInput.FunctionsRuntimeScaleMonitoringEnabled
		config.FunctionsRuntimeScaleMonitoringEnabled = &functionsRuntimeScaleMonitoringEnabled
	}

	// Set property "HandlerMappings":
	for _, item := range typedInput.HandlerMappings {
		var item1 HandlerMapping_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		config.HandlerMappings = append(config.HandlerMappings, item1)
	}

	// Set property "HealthCheckPath":
	if typedInput.HealthCheckPath != nil {
		healthCheckPath := *typedInput.HealthCheckPath
		config.HealthCheckPath = &healthCheckPath
	}

	// Set property "Http20Enabled":
	if typedInput.Http20Enabled != nil {
		http20Enabled := *typedInput.Http20Enabled
		config.Http20Enabled = &http20Enabled
	}

	// Set property "HttpLoggingEnabled":
	if typedInput.HttpLoggingEnabled != nil {
		httpLoggingEnabled := *typedInput.HttpLoggingEnabled
		config.HttpLoggingEnabled = &httpLoggingEnabled
	}

	// Set property "IpSecurityRestrictions":
	for _, item := range typedInput.IpSecurityRestrictions {
		var item1 IpSecurityRestriction_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		config.IpSecurityRestrictions = append(config.IpSecurityRestrictions, item1)
	}

	// Set property "JavaContainer":
	if typedInput.JavaContainer != nil {
		javaContainer := *typedInput.JavaContainer
		config.JavaContainer = &javaContainer
	}

	// Set property "JavaContainerVersion":
	if typedInput.JavaContainerVersion != nil {
		javaContainerVersion := *typedInput.JavaContainerVersion
		config.JavaContainerVersion = &javaContainerVersion
	}

	// Set property "JavaVersion":
	if typedInput.JavaVersion != nil {
		javaVersion := *typedInput.JavaVersion
		config.JavaVersion = &javaVersion
	}

	// Set property "KeyVaultReferenceIdentity":
	if typedInput.KeyVaultReferenceIdentity != nil {
		keyVaultReferenceIdentity := *typedInput.KeyVaultReferenceIdentity
		config.KeyVaultReferenceIdentity = &keyVaultReferenceIdentity
	}

	// Set property "Limits":
	if typedInput.Limits != nil {
		var limits1 SiteLimits_STATUS
		err := limits1.PopulateFromARM(owner, *typedInput.Limits)
		if err != nil {
			return err
		}
		limits := limits1
		config.Limits = &limits
	}

	// Set property "LinuxFxVersion":
	if typedInput.LinuxFxVersion != nil {
		linuxFxVersion := *typedInput.LinuxFxVersion
		config.LinuxFxVersion = &linuxFxVersion
	}

	// Set property "LoadBalancing":
	if typedInput.LoadBalancing != nil {
		loadBalancing := *typedInput.LoadBalancing
		config.LoadBalancing = &loadBalancing
	}

	// Set property "LocalMySqlEnabled":
	if typedInput.LocalMySqlEnabled != nil {
		localMySqlEnabled := *typedInput.LocalMySqlEnabled
		config.LocalMySqlEnabled = &localMySqlEnabled
	}

	// Set property "LogsDirectorySizeLimit":
	if typedInput.LogsDirectorySizeLimit != nil {
		logsDirectorySizeLimit := *typedInput.LogsDirectorySizeLimit
		config.LogsDirectorySizeLimit = &logsDirectorySizeLimit
	}

	// Set property "MachineKey":
	if typedInput.MachineKey != nil {
		var machineKey1 SiteMachineKey_STATUS
		err := machineKey1.PopulateFromARM(owner, *typedInput.MachineKey)
		if err != nil {
			return err
		}
		machineKey := machineKey1
		config.MachineKey = &machineKey
	}

	// Set property "ManagedPipelineMode":
	if typedInput.ManagedPipelineMode != nil {
		managedPipelineMode := *typedInput.ManagedPipelineMode
		config.ManagedPipelineMode = &managedPipelineMode
	}

	// Set property "ManagedServiceIdentityId":
	if typedInput.ManagedServiceIdentityId != nil {
		managedServiceIdentityId := *typedInput.ManagedServiceIdentityId
		config.ManagedServiceIdentityId = &managedServiceIdentityId
	}

	// Set property "MinTlsVersion":
	if typedInput.MinTlsVersion != nil {
		minTlsVersion := *typedInput.MinTlsVersion
		config.MinTlsVersion = &minTlsVersion
	}

	// Set property "MinimumElasticInstanceCount":
	if typedInput.MinimumElasticInstanceCount != nil {
		minimumElasticInstanceCount := *typedInput.MinimumElasticInstanceCount
		config.MinimumElasticInstanceCount = &minimumElasticInstanceCount
	}

	// Set property "NetFrameworkVersion":
	if typedInput.NetFrameworkVersion != nil {
		netFrameworkVersion := *typedInput.NetFrameworkVersion
		config.NetFrameworkVersion = &netFrameworkVersion
	}

	// Set property "NodeVersion":
	if typedInput.NodeVersion != nil {
		nodeVersion := *typedInput.NodeVersion
		config.NodeVersion = &nodeVersion
	}

	// Set property "NumberOfWorkers":
	if typedInput.NumberOfWorkers != nil {
		numberOfWorkers := *typedInput.NumberOfWorkers
		config.NumberOfWorkers = &numberOfWorkers
	}

	// Set property "PhpVersion":
	if typedInput.PhpVersion != nil {
		phpVersion := *typedInput.PhpVersion
		config.PhpVersion = &phpVersion
	}

	// Set property "PowerShellVersion":
	if typedInput.PowerShellVersion != nil {
		powerShellVersion := *typedInput.PowerShellVersion
		config.PowerShellVersion = &powerShellVersion
	}

	// Set property "PreWarmedInstanceCount":
	if typedInput.PreWarmedInstanceCount != nil {
		preWarmedInstanceCount := *typedInput.PreWarmedInstanceCount
		config.PreWarmedInstanceCount = &preWarmedInstanceCount
	}

	// Set property "PublicNetworkAccess":
	if typedInput.PublicNetworkAccess != nil {
		publicNetworkAccess := *typedInput.PublicNetworkAccess
		config.PublicNetworkAccess = &publicNetworkAccess
	}

	// Set property "PublishingUsername":
	if typedInput.PublishingUsername != nil {
		publishingUsername := *typedInput.PublishingUsername
		config.PublishingUsername = &publishingUsername
	}

	// Set property "Push":
	if typedInput.Push != nil {
		var push1 PushSettings_STATUS
		err := push1.PopulateFromARM(owner, *typedInput.Push)
		if err != nil {
			return err
		}
		push := push1
		config.Push = &push
	}

	// Set property "PythonVersion":
	if typedInput.PythonVersion != nil {
		pythonVersion := *typedInput.PythonVersion
		config.PythonVersion = &pythonVersion
	}

	// Set property "RemoteDebuggingEnabled":
	if typedInput.RemoteDebuggingEnabled != nil {
		remoteDebuggingEnabled := *typedInput.RemoteDebuggingEnabled
		config.RemoteDebuggingEnabled = &remoteDebuggingEnabled
	}

	// Set property "RemoteDebuggingVersion":
	if typedInput.RemoteDebuggingVersion != nil {
		remoteDebuggingVersion := *typedInput.RemoteDebuggingVersion
		config.RemoteDebuggingVersion = &remoteDebuggingVersion
	}

	// Set property "RequestTracingEnabled":
	if typedInput.RequestTracingEnabled != nil {
		requestTracingEnabled := *typedInput.RequestTracingEnabled
		config.RequestTracingEnabled = &requestTracingEnabled
	}

	// Set property "RequestTracingExpirationTime":
	if typedInput.RequestTracingExpirationTime != nil {
		requestTracingExpirationTime := *typedInput.RequestTracingExpirationTime
		config.RequestTracingExpirationTime = &requestTracingExpirationTime
	}

	// Set property "ScmIpSecurityRestrictions":
	for _, item := range typedInput.ScmIpSecurityRestrictions {
		var item1 IpSecurityRestriction_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		config.ScmIpSecurityRestrictions = append(config.ScmIpSecurityRestrictions, item1)
	}

	// Set property "ScmIpSecurityRestrictionsUseMain":
	if typedInput.ScmIpSecurityRestrictionsUseMain != nil {
		scmIpSecurityRestrictionsUseMain := *typedInput.ScmIpSecurityRestrictionsUseMain
		config.ScmIpSecurityRestrictionsUseMain = &scmIpSecurityRestrictionsUseMain
	}

	// Set property "ScmMinTlsVersion":
	if typedInput.ScmMinTlsVersion != nil {
		scmMinTlsVersion := *typedInput.ScmMinTlsVersion
		config.ScmMinTlsVersion = &scmMinTlsVersion
	}

	// Set property "ScmType":
	if typedInput.ScmType != nil {
		scmType := *typedInput.ScmType
		config.ScmType = &scmType
	}

	// Set property "TracingOptions":
	if typedInput.TracingOptions != nil {
		tracingOptions := *typedInput.TracingOptions
		config.TracingOptions = &tracingOptions
	}

	// Set property "Use32BitWorkerProcess":
	if typedInput.Use32BitWorkerProcess != nil {
		use32BitWorkerProcess := *typedInput.Use32BitWorkerProcess
		config.Use32BitWorkerProcess = &use32BitWorkerProcess
	}

	// Set property "VirtualApplications":
	for _, item := range typedInput.VirtualApplications {
		var item1 VirtualApplication_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		config.VirtualApplications = append(config.VirtualApplications, item1)
	}

	// Set property "VnetName":
	if typedInput.VnetName != nil {
		vnetName := *typedInput.VnetName
		config.VnetName = &vnetName
	}

	// Set property "VnetPrivatePortsCount":
	if typedInput.VnetPrivatePortsCount != nil {
		vnetPrivatePortsCount := *typedInput.VnetPrivatePortsCount
		config.VnetPrivatePortsCount = &vnetPrivatePortsCount
	}

	// Set property "VnetRouteAllEnabled":
	if typedInput.VnetRouteAllEnabled != nil {
		vnetRouteAllEnabled := *typedInput.VnetRouteAllEnabled
		config.VnetRouteAllEnabled = &vnetRouteAllEnabled
	}

	// Set property "WebSocketsEnabled":
	if typedInput.WebSocketsEnabled != nil {
		webSocketsEnabled := *typedInput.WebSocketsEnabled
		config.WebSocketsEnabled = &webSocketsEnabled
	}

	// Set property "WebsiteTimeZone":
	if typedInput.WebsiteTimeZone != nil {
		websiteTimeZone := *typedInput.WebsiteTimeZone
		config.WebsiteTimeZone = &websiteTimeZone
	}

	// Set property "WindowsFxVersion":
	if typedInput.WindowsFxVersion != nil {
		windowsFxVersion := *typedInput.WindowsFxVersion
		config.WindowsFxVersion = &windowsFxVersion
	}

	// Set property "XManagedServiceIdentityId":
	if typedInput.XManagedServiceIdentityId != nil {
		xManagedServiceIdentityId := *typedInput.XManagedServiceIdentityId
		config.XManagedServiceIdentityId = &xManagedServiceIdentityId
	}

	// No error
	return nil
}

// AssignProperties_From_SiteConfig_STATUS populates our SiteConfig_STATUS from the provided source SiteConfig_STATUS
func (config *SiteConfig_STATUS) AssignProperties_From_SiteConfig_STATUS(source *v1beta20220301s.SiteConfig_STATUS) error {

	// AcrUseManagedIdentityCreds
	if source.AcrUseManagedIdentityCreds != nil {
		acrUseManagedIdentityCred := *source.AcrUseManagedIdentityCreds
		config.AcrUseManagedIdentityCreds = &acrUseManagedIdentityCred
	} else {
		config.AcrUseManagedIdentityCreds = nil
	}

	// AcrUserManagedIdentityID
	config.AcrUserManagedIdentityID = genruntime.ClonePointerToString(source.AcrUserManagedIdentityID)

	// AlwaysOn
	if source.AlwaysOn != nil {
		alwaysOn := *source.AlwaysOn
		config.AlwaysOn = &alwaysOn
	} else {
		config.AlwaysOn = nil
	}

	// ApiDefinition
	if source.ApiDefinition != nil {
		var apiDefinition ApiDefinitionInfo_STATUS
		err := apiDefinition.AssignProperties_From_ApiDefinitionInfo_STATUS(source.ApiDefinition)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ApiDefinitionInfo_STATUS() to populate field ApiDefinition")
		}
		config.ApiDefinition = &apiDefinition
	} else {
		config.ApiDefinition = nil
	}

	// ApiManagementConfig
	if source.ApiManagementConfig != nil {
		var apiManagementConfig ApiManagementConfig_STATUS
		err := apiManagementConfig.AssignProperties_From_ApiManagementConfig_STATUS(source.ApiManagementConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ApiManagementConfig_STATUS() to populate field ApiManagementConfig")
		}
		config.ApiManagementConfig = &apiManagementConfig
	} else {
		config.ApiManagementConfig = nil
	}

	// AppCommandLine
	config.AppCommandLine = genruntime.ClonePointerToString(source.AppCommandLine)

	// AppSettings
	if source.AppSettings != nil {
		appSettingList := make([]NameValuePair_STATUS, len(source.AppSettings))
		for appSettingIndex, appSettingItem := range source.AppSettings {
			// Shadow the loop variable to avoid aliasing
			appSettingItem := appSettingItem
			var appSetting NameValuePair_STATUS
			err := appSetting.AssignProperties_From_NameValuePair_STATUS(&appSettingItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_NameValuePair_STATUS() to populate field AppSettings")
			}
			appSettingList[appSettingIndex] = appSetting
		}
		config.AppSettings = appSettingList
	} else {
		config.AppSettings = nil
	}

	// AutoHealEnabled
	if source.AutoHealEnabled != nil {
		autoHealEnabled := *source.AutoHealEnabled
		config.AutoHealEnabled = &autoHealEnabled
	} else {
		config.AutoHealEnabled = nil
	}

	// AutoHealRules
	if source.AutoHealRules != nil {
		var autoHealRule AutoHealRules_STATUS
		err := autoHealRule.AssignProperties_From_AutoHealRules_STATUS(source.AutoHealRules)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AutoHealRules_STATUS() to populate field AutoHealRules")
		}
		config.AutoHealRules = &autoHealRule
	} else {
		config.AutoHealRules = nil
	}

	// AutoSwapSlotName
	config.AutoSwapSlotName = genruntime.ClonePointerToString(source.AutoSwapSlotName)

	// AzureStorageAccounts
	if source.AzureStorageAccounts != nil {
		azureStorageAccountMap := make(map[string]AzureStorageInfoValue_STATUS, len(source.AzureStorageAccounts))
		for azureStorageAccountKey, azureStorageAccountValue := range source.AzureStorageAccounts {
			// Shadow the loop variable to avoid aliasing
			azureStorageAccountValue := azureStorageAccountValue
			var azureStorageAccount AzureStorageInfoValue_STATUS
			err := azureStorageAccount.AssignProperties_From_AzureStorageInfoValue_STATUS(&azureStorageAccountValue)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_AzureStorageInfoValue_STATUS() to populate field AzureStorageAccounts")
			}
			azureStorageAccountMap[azureStorageAccountKey] = azureStorageAccount
		}
		config.AzureStorageAccounts = azureStorageAccountMap
	} else {
		config.AzureStorageAccounts = nil
	}

	// ConnectionStrings
	if source.ConnectionStrings != nil {
		connectionStringList := make([]ConnStringInfo_STATUS, len(source.ConnectionStrings))
		for connectionStringIndex, connectionStringItem := range source.ConnectionStrings {
			// Shadow the loop variable to avoid aliasing
			connectionStringItem := connectionStringItem
			var connectionString ConnStringInfo_STATUS
			err := connectionString.AssignProperties_From_ConnStringInfo_STATUS(&connectionStringItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ConnStringInfo_STATUS() to populate field ConnectionStrings")
			}
			connectionStringList[connectionStringIndex] = connectionString
		}
		config.ConnectionStrings = connectionStringList
	} else {
		config.ConnectionStrings = nil
	}

	// Cors
	if source.Cors != nil {
		var cor CorsSettings_STATUS
		err := cor.AssignProperties_From_CorsSettings_STATUS(source.Cors)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CorsSettings_STATUS() to populate field Cors")
		}
		config.Cors = &cor
	} else {
		config.Cors = nil
	}

	// DefaultDocuments
	config.DefaultDocuments = genruntime.CloneSliceOfString(source.DefaultDocuments)

	// DetailedErrorLoggingEnabled
	if source.DetailedErrorLoggingEnabled != nil {
		detailedErrorLoggingEnabled := *source.DetailedErrorLoggingEnabled
		config.DetailedErrorLoggingEnabled = &detailedErrorLoggingEnabled
	} else {
		config.DetailedErrorLoggingEnabled = nil
	}

	// DocumentRoot
	config.DocumentRoot = genruntime.ClonePointerToString(source.DocumentRoot)

	// Experiments
	if source.Experiments != nil {
		var experiment Experiments_STATUS
		err := experiment.AssignProperties_From_Experiments_STATUS(source.Experiments)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Experiments_STATUS() to populate field Experiments")
		}
		config.Experiments = &experiment
	} else {
		config.Experiments = nil
	}

	// FtpsState
	if source.FtpsState != nil {
		ftpsState := SiteConfig_FtpsState_STATUS(*source.FtpsState)
		config.FtpsState = &ftpsState
	} else {
		config.FtpsState = nil
	}

	// FunctionAppScaleLimit
	config.FunctionAppScaleLimit = genruntime.ClonePointerToInt(source.FunctionAppScaleLimit)

	// FunctionsRuntimeScaleMonitoringEnabled
	if source.FunctionsRuntimeScaleMonitoringEnabled != nil {
		functionsRuntimeScaleMonitoringEnabled := *source.FunctionsRuntimeScaleMonitoringEnabled
		config.FunctionsRuntimeScaleMonitoringEnabled = &functionsRuntimeScaleMonitoringEnabled
	} else {
		config.FunctionsRuntimeScaleMonitoringEnabled = nil
	}

	// HandlerMappings
	if source.HandlerMappings != nil {
		handlerMappingList := make([]HandlerMapping_STATUS, len(source.HandlerMappings))
		for handlerMappingIndex, handlerMappingItem := range source.HandlerMappings {
			// Shadow the loop variable to avoid aliasing
			handlerMappingItem := handlerMappingItem
			var handlerMapping HandlerMapping_STATUS
			err := handlerMapping.AssignProperties_From_HandlerMapping_STATUS(&handlerMappingItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_HandlerMapping_STATUS() to populate field HandlerMappings")
			}
			handlerMappingList[handlerMappingIndex] = handlerMapping
		}
		config.HandlerMappings = handlerMappingList
	} else {
		config.HandlerMappings = nil
	}

	// HealthCheckPath
	config.HealthCheckPath = genruntime.ClonePointerToString(source.HealthCheckPath)

	// Http20Enabled
	if source.Http20Enabled != nil {
		http20Enabled := *source.Http20Enabled
		config.Http20Enabled = &http20Enabled
	} else {
		config.Http20Enabled = nil
	}

	// HttpLoggingEnabled
	if source.HttpLoggingEnabled != nil {
		httpLoggingEnabled := *source.HttpLoggingEnabled
		config.HttpLoggingEnabled = &httpLoggingEnabled
	} else {
		config.HttpLoggingEnabled = nil
	}

	// IpSecurityRestrictions
	if source.IpSecurityRestrictions != nil {
		ipSecurityRestrictionList := make([]IpSecurityRestriction_STATUS, len(source.IpSecurityRestrictions))
		for ipSecurityRestrictionIndex, ipSecurityRestrictionItem := range source.IpSecurityRestrictions {
			// Shadow the loop variable to avoid aliasing
			ipSecurityRestrictionItem := ipSecurityRestrictionItem
			var ipSecurityRestriction IpSecurityRestriction_STATUS
			err := ipSecurityRestriction.AssignProperties_From_IpSecurityRestriction_STATUS(&ipSecurityRestrictionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_IpSecurityRestriction_STATUS() to populate field IpSecurityRestrictions")
			}
			ipSecurityRestrictionList[ipSecurityRestrictionIndex] = ipSecurityRestriction
		}
		config.IpSecurityRestrictions = ipSecurityRestrictionList
	} else {
		config.IpSecurityRestrictions = nil
	}

	// JavaContainer
	config.JavaContainer = genruntime.ClonePointerToString(source.JavaContainer)

	// JavaContainerVersion
	config.JavaContainerVersion = genruntime.ClonePointerToString(source.JavaContainerVersion)

	// JavaVersion
	config.JavaVersion = genruntime.ClonePointerToString(source.JavaVersion)

	// KeyVaultReferenceIdentity
	config.KeyVaultReferenceIdentity = genruntime.ClonePointerToString(source.KeyVaultReferenceIdentity)

	// Limits
	if source.Limits != nil {
		var limit SiteLimits_STATUS
		err := limit.AssignProperties_From_SiteLimits_STATUS(source.Limits)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SiteLimits_STATUS() to populate field Limits")
		}
		config.Limits = &limit
	} else {
		config.Limits = nil
	}

	// LinuxFxVersion
	config.LinuxFxVersion = genruntime.ClonePointerToString(source.LinuxFxVersion)

	// LoadBalancing
	if source.LoadBalancing != nil {
		loadBalancing := SiteConfig_LoadBalancing_STATUS(*source.LoadBalancing)
		config.LoadBalancing = &loadBalancing
	} else {
		config.LoadBalancing = nil
	}

	// LocalMySqlEnabled
	if source.LocalMySqlEnabled != nil {
		localMySqlEnabled := *source.LocalMySqlEnabled
		config.LocalMySqlEnabled = &localMySqlEnabled
	} else {
		config.LocalMySqlEnabled = nil
	}

	// LogsDirectorySizeLimit
	config.LogsDirectorySizeLimit = genruntime.ClonePointerToInt(source.LogsDirectorySizeLimit)

	// MachineKey
	if source.MachineKey != nil {
		var machineKey SiteMachineKey_STATUS
		err := machineKey.AssignProperties_From_SiteMachineKey_STATUS(source.MachineKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SiteMachineKey_STATUS() to populate field MachineKey")
		}
		config.MachineKey = &machineKey
	} else {
		config.MachineKey = nil
	}

	// ManagedPipelineMode
	if source.ManagedPipelineMode != nil {
		managedPipelineMode := SiteConfig_ManagedPipelineMode_STATUS(*source.ManagedPipelineMode)
		config.ManagedPipelineMode = &managedPipelineMode
	} else {
		config.ManagedPipelineMode = nil
	}

	// ManagedServiceIdentityId
	config.ManagedServiceIdentityId = genruntime.ClonePointerToInt(source.ManagedServiceIdentityId)

	// MinTlsVersion
	if source.MinTlsVersion != nil {
		minTlsVersion := SiteConfig_MinTlsVersion_STATUS(*source.MinTlsVersion)
		config.MinTlsVersion = &minTlsVersion
	} else {
		config.MinTlsVersion = nil
	}

	// MinimumElasticInstanceCount
	config.MinimumElasticInstanceCount = genruntime.ClonePointerToInt(source.MinimumElasticInstanceCount)

	// NetFrameworkVersion
	config.NetFrameworkVersion = genruntime.ClonePointerToString(source.NetFrameworkVersion)

	// NodeVersion
	config.NodeVersion = genruntime.ClonePointerToString(source.NodeVersion)

	// NumberOfWorkers
	config.NumberOfWorkers = genruntime.ClonePointerToInt(source.NumberOfWorkers)

	// PhpVersion
	config.PhpVersion = genruntime.ClonePointerToString(source.PhpVersion)

	// PowerShellVersion
	config.PowerShellVersion = genruntime.ClonePointerToString(source.PowerShellVersion)

	// PreWarmedInstanceCount
	config.PreWarmedInstanceCount = genruntime.ClonePointerToInt(source.PreWarmedInstanceCount)

	// PublicNetworkAccess
	config.PublicNetworkAccess = genruntime.ClonePointerToString(source.PublicNetworkAccess)

	// PublishingUsername
	config.PublishingUsername = genruntime.ClonePointerToString(source.PublishingUsername)

	// Push
	if source.Push != nil {
		var push PushSettings_STATUS
		err := push.AssignProperties_From_PushSettings_STATUS(source.Push)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PushSettings_STATUS() to populate field Push")
		}
		config.Push = &push
	} else {
		config.Push = nil
	}

	// PythonVersion
	config.PythonVersion = genruntime.ClonePointerToString(source.PythonVersion)

	// RemoteDebuggingEnabled
	if source.RemoteDebuggingEnabled != nil {
		remoteDebuggingEnabled := *source.RemoteDebuggingEnabled
		config.RemoteDebuggingEnabled = &remoteDebuggingEnabled
	} else {
		config.RemoteDebuggingEnabled = nil
	}

	// RemoteDebuggingVersion
	config.RemoteDebuggingVersion = genruntime.ClonePointerToString(source.RemoteDebuggingVersion)

	// RequestTracingEnabled
	if source.RequestTracingEnabled != nil {
		requestTracingEnabled := *source.RequestTracingEnabled
		config.RequestTracingEnabled = &requestTracingEnabled
	} else {
		config.RequestTracingEnabled = nil
	}

	// RequestTracingExpirationTime
	config.RequestTracingExpirationTime = genruntime.ClonePointerToString(source.RequestTracingExpirationTime)

	// ScmIpSecurityRestrictions
	if source.ScmIpSecurityRestrictions != nil {
		scmIpSecurityRestrictionList := make([]IpSecurityRestriction_STATUS, len(source.ScmIpSecurityRestrictions))
		for scmIpSecurityRestrictionIndex, scmIpSecurityRestrictionItem := range source.ScmIpSecurityRestrictions {
			// Shadow the loop variable to avoid aliasing
			scmIpSecurityRestrictionItem := scmIpSecurityRestrictionItem
			var scmIpSecurityRestriction IpSecurityRestriction_STATUS
			err := scmIpSecurityRestriction.AssignProperties_From_IpSecurityRestriction_STATUS(&scmIpSecurityRestrictionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_IpSecurityRestriction_STATUS() to populate field ScmIpSecurityRestrictions")
			}
			scmIpSecurityRestrictionList[scmIpSecurityRestrictionIndex] = scmIpSecurityRestriction
		}
		config.ScmIpSecurityRestrictions = scmIpSecurityRestrictionList
	} else {
		config.ScmIpSecurityRestrictions = nil
	}

	// ScmIpSecurityRestrictionsUseMain
	if source.ScmIpSecurityRestrictionsUseMain != nil {
		scmIpSecurityRestrictionsUseMain := *source.ScmIpSecurityRestrictionsUseMain
		config.ScmIpSecurityRestrictionsUseMain = &scmIpSecurityRestrictionsUseMain
	} else {
		config.ScmIpSecurityRestrictionsUseMain = nil
	}

	// ScmMinTlsVersion
	if source.ScmMinTlsVersion != nil {
		scmMinTlsVersion := SiteConfig_ScmMinTlsVersion_STATUS(*source.ScmMinTlsVersion)
		config.ScmMinTlsVersion = &scmMinTlsVersion
	} else {
		config.ScmMinTlsVersion = nil
	}

	// ScmType
	if source.ScmType != nil {
		scmType := SiteConfig_ScmType_STATUS(*source.ScmType)
		config.ScmType = &scmType
	} else {
		config.ScmType = nil
	}

	// TracingOptions
	config.TracingOptions = genruntime.ClonePointerToString(source.TracingOptions)

	// Use32BitWorkerProcess
	if source.Use32BitWorkerProcess != nil {
		use32BitWorkerProcess := *source.Use32BitWorkerProcess
		config.Use32BitWorkerProcess = &use32BitWorkerProcess
	} else {
		config.Use32BitWorkerProcess = nil
	}

	// VirtualApplications
	if source.VirtualApplications != nil {
		virtualApplicationList := make([]VirtualApplication_STATUS, len(source.VirtualApplications))
		for virtualApplicationIndex, virtualApplicationItem := range source.VirtualApplications {
			// Shadow the loop variable to avoid aliasing
			virtualApplicationItem := virtualApplicationItem
			var virtualApplication VirtualApplication_STATUS
			err := virtualApplication.AssignProperties_From_VirtualApplication_STATUS(&virtualApplicationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VirtualApplication_STATUS() to populate field VirtualApplications")
			}
			virtualApplicationList[virtualApplicationIndex] = virtualApplication
		}
		config.VirtualApplications = virtualApplicationList
	} else {
		config.VirtualApplications = nil
	}

	// VnetName
	config.VnetName = genruntime.ClonePointerToString(source.VnetName)

	// VnetPrivatePortsCount
	config.VnetPrivatePortsCount = genruntime.ClonePointerToInt(source.VnetPrivatePortsCount)

	// VnetRouteAllEnabled
	if source.VnetRouteAllEnabled != nil {
		vnetRouteAllEnabled := *source.VnetRouteAllEnabled
		config.VnetRouteAllEnabled = &vnetRouteAllEnabled
	} else {
		config.VnetRouteAllEnabled = nil
	}

	// WebSocketsEnabled
	if source.WebSocketsEnabled != nil {
		webSocketsEnabled := *source.WebSocketsEnabled
		config.WebSocketsEnabled = &webSocketsEnabled
	} else {
		config.WebSocketsEnabled = nil
	}

	// WebsiteTimeZone
	config.WebsiteTimeZone = genruntime.ClonePointerToString(source.WebsiteTimeZone)

	// WindowsFxVersion
	config.WindowsFxVersion = genruntime.ClonePointerToString(source.WindowsFxVersion)

	// XManagedServiceIdentityId
	config.XManagedServiceIdentityId = genruntime.ClonePointerToInt(source.XManagedServiceIdentityId)

	// No error
	return nil
}

// AssignProperties_To_SiteConfig_STATUS populates the provided destination SiteConfig_STATUS from our SiteConfig_STATUS
func (config *SiteConfig_STATUS) AssignProperties_To_SiteConfig_STATUS(destination *v1beta20220301s.SiteConfig_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AcrUseManagedIdentityCreds
	if config.AcrUseManagedIdentityCreds != nil {
		acrUseManagedIdentityCred := *config.AcrUseManagedIdentityCreds
		destination.AcrUseManagedIdentityCreds = &acrUseManagedIdentityCred
	} else {
		destination.AcrUseManagedIdentityCreds = nil
	}

	// AcrUserManagedIdentityID
	destination.AcrUserManagedIdentityID = genruntime.ClonePointerToString(config.AcrUserManagedIdentityID)

	// AlwaysOn
	if config.AlwaysOn != nil {
		alwaysOn := *config.AlwaysOn
		destination.AlwaysOn = &alwaysOn
	} else {
		destination.AlwaysOn = nil
	}

	// ApiDefinition
	if config.ApiDefinition != nil {
		var apiDefinition v1beta20220301s.ApiDefinitionInfo_STATUS
		err := config.ApiDefinition.AssignProperties_To_ApiDefinitionInfo_STATUS(&apiDefinition)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ApiDefinitionInfo_STATUS() to populate field ApiDefinition")
		}
		destination.ApiDefinition = &apiDefinition
	} else {
		destination.ApiDefinition = nil
	}

	// ApiManagementConfig
	if config.ApiManagementConfig != nil {
		var apiManagementConfig v1beta20220301s.ApiManagementConfig_STATUS
		err := config.ApiManagementConfig.AssignProperties_To_ApiManagementConfig_STATUS(&apiManagementConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ApiManagementConfig_STATUS() to populate field ApiManagementConfig")
		}
		destination.ApiManagementConfig = &apiManagementConfig
	} else {
		destination.ApiManagementConfig = nil
	}

	// AppCommandLine
	destination.AppCommandLine = genruntime.ClonePointerToString(config.AppCommandLine)

	// AppSettings
	if config.AppSettings != nil {
		appSettingList := make([]v1beta20220301s.NameValuePair_STATUS, len(config.AppSettings))
		for appSettingIndex, appSettingItem := range config.AppSettings {
			// Shadow the loop variable to avoid aliasing
			appSettingItem := appSettingItem
			var appSetting v1beta20220301s.NameValuePair_STATUS
			err := appSettingItem.AssignProperties_To_NameValuePair_STATUS(&appSetting)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_NameValuePair_STATUS() to populate field AppSettings")
			}
			appSettingList[appSettingIndex] = appSetting
		}
		destination.AppSettings = appSettingList
	} else {
		destination.AppSettings = nil
	}

	// AutoHealEnabled
	if config.AutoHealEnabled != nil {
		autoHealEnabled := *config.AutoHealEnabled
		destination.AutoHealEnabled = &autoHealEnabled
	} else {
		destination.AutoHealEnabled = nil
	}

	// AutoHealRules
	if config.AutoHealRules != nil {
		var autoHealRule v1beta20220301s.AutoHealRules_STATUS
		err := config.AutoHealRules.AssignProperties_To_AutoHealRules_STATUS(&autoHealRule)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AutoHealRules_STATUS() to populate field AutoHealRules")
		}
		destination.AutoHealRules = &autoHealRule
	} else {
		destination.AutoHealRules = nil
	}

	// AutoSwapSlotName
	destination.AutoSwapSlotName = genruntime.ClonePointerToString(config.AutoSwapSlotName)

	// AzureStorageAccounts
	if config.AzureStorageAccounts != nil {
		azureStorageAccountMap := make(map[string]v1beta20220301s.AzureStorageInfoValue_STATUS, len(config.AzureStorageAccounts))
		for azureStorageAccountKey, azureStorageAccountValue := range config.AzureStorageAccounts {
			// Shadow the loop variable to avoid aliasing
			azureStorageAccountValue := azureStorageAccountValue
			var azureStorageAccount v1beta20220301s.AzureStorageInfoValue_STATUS
			err := azureStorageAccountValue.AssignProperties_To_AzureStorageInfoValue_STATUS(&azureStorageAccount)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_AzureStorageInfoValue_STATUS() to populate field AzureStorageAccounts")
			}
			azureStorageAccountMap[azureStorageAccountKey] = azureStorageAccount
		}
		destination.AzureStorageAccounts = azureStorageAccountMap
	} else {
		destination.AzureStorageAccounts = nil
	}

	// ConnectionStrings
	if config.ConnectionStrings != nil {
		connectionStringList := make([]v1beta20220301s.ConnStringInfo_STATUS, len(config.ConnectionStrings))
		for connectionStringIndex, connectionStringItem := range config.ConnectionStrings {
			// Shadow the loop variable to avoid aliasing
			connectionStringItem := connectionStringItem
			var connectionString v1beta20220301s.ConnStringInfo_STATUS
			err := connectionStringItem.AssignProperties_To_ConnStringInfo_STATUS(&connectionString)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ConnStringInfo_STATUS() to populate field ConnectionStrings")
			}
			connectionStringList[connectionStringIndex] = connectionString
		}
		destination.ConnectionStrings = connectionStringList
	} else {
		destination.ConnectionStrings = nil
	}

	// Cors
	if config.Cors != nil {
		var cor v1beta20220301s.CorsSettings_STATUS
		err := config.Cors.AssignProperties_To_CorsSettings_STATUS(&cor)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CorsSettings_STATUS() to populate field Cors")
		}
		destination.Cors = &cor
	} else {
		destination.Cors = nil
	}

	// DefaultDocuments
	destination.DefaultDocuments = genruntime.CloneSliceOfString(config.DefaultDocuments)

	// DetailedErrorLoggingEnabled
	if config.DetailedErrorLoggingEnabled != nil {
		detailedErrorLoggingEnabled := *config.DetailedErrorLoggingEnabled
		destination.DetailedErrorLoggingEnabled = &detailedErrorLoggingEnabled
	} else {
		destination.DetailedErrorLoggingEnabled = nil
	}

	// DocumentRoot
	destination.DocumentRoot = genruntime.ClonePointerToString(config.DocumentRoot)

	// Experiments
	if config.Experiments != nil {
		var experiment v1beta20220301s.Experiments_STATUS
		err := config.Experiments.AssignProperties_To_Experiments_STATUS(&experiment)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Experiments_STATUS() to populate field Experiments")
		}
		destination.Experiments = &experiment
	} else {
		destination.Experiments = nil
	}

	// FtpsState
	if config.FtpsState != nil {
		ftpsState := string(*config.FtpsState)
		destination.FtpsState = &ftpsState
	} else {
		destination.FtpsState = nil
	}

	// FunctionAppScaleLimit
	destination.FunctionAppScaleLimit = genruntime.ClonePointerToInt(config.FunctionAppScaleLimit)

	// FunctionsRuntimeScaleMonitoringEnabled
	if config.FunctionsRuntimeScaleMonitoringEnabled != nil {
		functionsRuntimeScaleMonitoringEnabled := *config.FunctionsRuntimeScaleMonitoringEnabled
		destination.FunctionsRuntimeScaleMonitoringEnabled = &functionsRuntimeScaleMonitoringEnabled
	} else {
		destination.FunctionsRuntimeScaleMonitoringEnabled = nil
	}

	// HandlerMappings
	if config.HandlerMappings != nil {
		handlerMappingList := make([]v1beta20220301s.HandlerMapping_STATUS, len(config.HandlerMappings))
		for handlerMappingIndex, handlerMappingItem := range config.HandlerMappings {
			// Shadow the loop variable to avoid aliasing
			handlerMappingItem := handlerMappingItem
			var handlerMapping v1beta20220301s.HandlerMapping_STATUS
			err := handlerMappingItem.AssignProperties_To_HandlerMapping_STATUS(&handlerMapping)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_HandlerMapping_STATUS() to populate field HandlerMappings")
			}
			handlerMappingList[handlerMappingIndex] = handlerMapping
		}
		destination.HandlerMappings = handlerMappingList
	} else {
		destination.HandlerMappings = nil
	}

	// HealthCheckPath
	destination.HealthCheckPath = genruntime.ClonePointerToString(config.HealthCheckPath)

	// Http20Enabled
	if config.Http20Enabled != nil {
		http20Enabled := *config.Http20Enabled
		destination.Http20Enabled = &http20Enabled
	} else {
		destination.Http20Enabled = nil
	}

	// HttpLoggingEnabled
	if config.HttpLoggingEnabled != nil {
		httpLoggingEnabled := *config.HttpLoggingEnabled
		destination.HttpLoggingEnabled = &httpLoggingEnabled
	} else {
		destination.HttpLoggingEnabled = nil
	}

	// IpSecurityRestrictions
	if config.IpSecurityRestrictions != nil {
		ipSecurityRestrictionList := make([]v1beta20220301s.IpSecurityRestriction_STATUS, len(config.IpSecurityRestrictions))
		for ipSecurityRestrictionIndex, ipSecurityRestrictionItem := range config.IpSecurityRestrictions {
			// Shadow the loop variable to avoid aliasing
			ipSecurityRestrictionItem := ipSecurityRestrictionItem
			var ipSecurityRestriction v1beta20220301s.IpSecurityRestriction_STATUS
			err := ipSecurityRestrictionItem.AssignProperties_To_IpSecurityRestriction_STATUS(&ipSecurityRestriction)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_IpSecurityRestriction_STATUS() to populate field IpSecurityRestrictions")
			}
			ipSecurityRestrictionList[ipSecurityRestrictionIndex] = ipSecurityRestriction
		}
		destination.IpSecurityRestrictions = ipSecurityRestrictionList
	} else {
		destination.IpSecurityRestrictions = nil
	}

	// JavaContainer
	destination.JavaContainer = genruntime.ClonePointerToString(config.JavaContainer)

	// JavaContainerVersion
	destination.JavaContainerVersion = genruntime.ClonePointerToString(config.JavaContainerVersion)

	// JavaVersion
	destination.JavaVersion = genruntime.ClonePointerToString(config.JavaVersion)

	// KeyVaultReferenceIdentity
	destination.KeyVaultReferenceIdentity = genruntime.ClonePointerToString(config.KeyVaultReferenceIdentity)

	// Limits
	if config.Limits != nil {
		var limit v1beta20220301s.SiteLimits_STATUS
		err := config.Limits.AssignProperties_To_SiteLimits_STATUS(&limit)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SiteLimits_STATUS() to populate field Limits")
		}
		destination.Limits = &limit
	} else {
		destination.Limits = nil
	}

	// LinuxFxVersion
	destination.LinuxFxVersion = genruntime.ClonePointerToString(config.LinuxFxVersion)

	// LoadBalancing
	if config.LoadBalancing != nil {
		loadBalancing := string(*config.LoadBalancing)
		destination.LoadBalancing = &loadBalancing
	} else {
		destination.LoadBalancing = nil
	}

	// LocalMySqlEnabled
	if config.LocalMySqlEnabled != nil {
		localMySqlEnabled := *config.LocalMySqlEnabled
		destination.LocalMySqlEnabled = &localMySqlEnabled
	} else {
		destination.LocalMySqlEnabled = nil
	}

	// LogsDirectorySizeLimit
	destination.LogsDirectorySizeLimit = genruntime.ClonePointerToInt(config.LogsDirectorySizeLimit)

	// MachineKey
	if config.MachineKey != nil {
		var machineKey v1beta20220301s.SiteMachineKey_STATUS
		err := config.MachineKey.AssignProperties_To_SiteMachineKey_STATUS(&machineKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SiteMachineKey_STATUS() to populate field MachineKey")
		}
		destination.MachineKey = &machineKey
	} else {
		destination.MachineKey = nil
	}

	// ManagedPipelineMode
	if config.ManagedPipelineMode != nil {
		managedPipelineMode := string(*config.ManagedPipelineMode)
		destination.ManagedPipelineMode = &managedPipelineMode
	} else {
		destination.ManagedPipelineMode = nil
	}

	// ManagedServiceIdentityId
	destination.ManagedServiceIdentityId = genruntime.ClonePointerToInt(config.ManagedServiceIdentityId)

	// MinTlsVersion
	if config.MinTlsVersion != nil {
		minTlsVersion := string(*config.MinTlsVersion)
		destination.MinTlsVersion = &minTlsVersion
	} else {
		destination.MinTlsVersion = nil
	}

	// MinimumElasticInstanceCount
	destination.MinimumElasticInstanceCount = genruntime.ClonePointerToInt(config.MinimumElasticInstanceCount)

	// NetFrameworkVersion
	destination.NetFrameworkVersion = genruntime.ClonePointerToString(config.NetFrameworkVersion)

	// NodeVersion
	destination.NodeVersion = genruntime.ClonePointerToString(config.NodeVersion)

	// NumberOfWorkers
	destination.NumberOfWorkers = genruntime.ClonePointerToInt(config.NumberOfWorkers)

	// PhpVersion
	destination.PhpVersion = genruntime.ClonePointerToString(config.PhpVersion)

	// PowerShellVersion
	destination.PowerShellVersion = genruntime.ClonePointerToString(config.PowerShellVersion)

	// PreWarmedInstanceCount
	destination.PreWarmedInstanceCount = genruntime.ClonePointerToInt(config.PreWarmedInstanceCount)

	// PublicNetworkAccess
	destination.PublicNetworkAccess = genruntime.ClonePointerToString(config.PublicNetworkAccess)

	// PublishingUsername
	destination.PublishingUsername = genruntime.ClonePointerToString(config.PublishingUsername)

	// Push
	if config.Push != nil {
		var push v1beta20220301s.PushSettings_STATUS
		err := config.Push.AssignProperties_To_PushSettings_STATUS(&push)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PushSettings_STATUS() to populate field Push")
		}
		destination.Push = &push
	} else {
		destination.Push = nil
	}

	// PythonVersion
	destination.PythonVersion = genruntime.ClonePointerToString(config.PythonVersion)

	// RemoteDebuggingEnabled
	if config.RemoteDebuggingEnabled != nil {
		remoteDebuggingEnabled := *config.RemoteDebuggingEnabled
		destination.RemoteDebuggingEnabled = &remoteDebuggingEnabled
	} else {
		destination.RemoteDebuggingEnabled = nil
	}

	// RemoteDebuggingVersion
	destination.RemoteDebuggingVersion = genruntime.ClonePointerToString(config.RemoteDebuggingVersion)

	// RequestTracingEnabled
	if config.RequestTracingEnabled != nil {
		requestTracingEnabled := *config.RequestTracingEnabled
		destination.RequestTracingEnabled = &requestTracingEnabled
	} else {
		destination.RequestTracingEnabled = nil
	}

	// RequestTracingExpirationTime
	destination.RequestTracingExpirationTime = genruntime.ClonePointerToString(config.RequestTracingExpirationTime)

	// ScmIpSecurityRestrictions
	if config.ScmIpSecurityRestrictions != nil {
		scmIpSecurityRestrictionList := make([]v1beta20220301s.IpSecurityRestriction_STATUS, len(config.ScmIpSecurityRestrictions))
		for scmIpSecurityRestrictionIndex, scmIpSecurityRestrictionItem := range config.ScmIpSecurityRestrictions {
			// Shadow the loop variable to avoid aliasing
			scmIpSecurityRestrictionItem := scmIpSecurityRestrictionItem
			var scmIpSecurityRestriction v1beta20220301s.IpSecurityRestriction_STATUS
			err := scmIpSecurityRestrictionItem.AssignProperties_To_IpSecurityRestriction_STATUS(&scmIpSecurityRestriction)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_IpSecurityRestriction_STATUS() to populate field ScmIpSecurityRestrictions")
			}
			scmIpSecurityRestrictionList[scmIpSecurityRestrictionIndex] = scmIpSecurityRestriction
		}
		destination.ScmIpSecurityRestrictions = scmIpSecurityRestrictionList
	} else {
		destination.ScmIpSecurityRestrictions = nil
	}

	// ScmIpSecurityRestrictionsUseMain
	if config.ScmIpSecurityRestrictionsUseMain != nil {
		scmIpSecurityRestrictionsUseMain := *config.ScmIpSecurityRestrictionsUseMain
		destination.ScmIpSecurityRestrictionsUseMain = &scmIpSecurityRestrictionsUseMain
	} else {
		destination.ScmIpSecurityRestrictionsUseMain = nil
	}

	// ScmMinTlsVersion
	if config.ScmMinTlsVersion != nil {
		scmMinTlsVersion := string(*config.ScmMinTlsVersion)
		destination.ScmMinTlsVersion = &scmMinTlsVersion
	} else {
		destination.ScmMinTlsVersion = nil
	}

	// ScmType
	if config.ScmType != nil {
		scmType := string(*config.ScmType)
		destination.ScmType = &scmType
	} else {
		destination.ScmType = nil
	}

	// TracingOptions
	destination.TracingOptions = genruntime.ClonePointerToString(config.TracingOptions)

	// Use32BitWorkerProcess
	if config.Use32BitWorkerProcess != nil {
		use32BitWorkerProcess := *config.Use32BitWorkerProcess
		destination.Use32BitWorkerProcess = &use32BitWorkerProcess
	} else {
		destination.Use32BitWorkerProcess = nil
	}

	// VirtualApplications
	if config.VirtualApplications != nil {
		virtualApplicationList := make([]v1beta20220301s.VirtualApplication_STATUS, len(config.VirtualApplications))
		for virtualApplicationIndex, virtualApplicationItem := range config.VirtualApplications {
			// Shadow the loop variable to avoid aliasing
			virtualApplicationItem := virtualApplicationItem
			var virtualApplication v1beta20220301s.VirtualApplication_STATUS
			err := virtualApplicationItem.AssignProperties_To_VirtualApplication_STATUS(&virtualApplication)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VirtualApplication_STATUS() to populate field VirtualApplications")
			}
			virtualApplicationList[virtualApplicationIndex] = virtualApplication
		}
		destination.VirtualApplications = virtualApplicationList
	} else {
		destination.VirtualApplications = nil
	}

	// VnetName
	destination.VnetName = genruntime.ClonePointerToString(config.VnetName)

	// VnetPrivatePortsCount
	destination.VnetPrivatePortsCount = genruntime.ClonePointerToInt(config.VnetPrivatePortsCount)

	// VnetRouteAllEnabled
	if config.VnetRouteAllEnabled != nil {
		vnetRouteAllEnabled := *config.VnetRouteAllEnabled
		destination.VnetRouteAllEnabled = &vnetRouteAllEnabled
	} else {
		destination.VnetRouteAllEnabled = nil
	}

	// WebSocketsEnabled
	if config.WebSocketsEnabled != nil {
		webSocketsEnabled := *config.WebSocketsEnabled
		destination.WebSocketsEnabled = &webSocketsEnabled
	} else {
		destination.WebSocketsEnabled = nil
	}

	// WebsiteTimeZone
	destination.WebsiteTimeZone = genruntime.ClonePointerToString(config.WebsiteTimeZone)

	// WindowsFxVersion
	destination.WindowsFxVersion = genruntime.ClonePointerToString(config.WindowsFxVersion)

	// XManagedServiceIdentityId
	destination.XManagedServiceIdentityId = genruntime.ClonePointerToInt(config.XManagedServiceIdentityId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of SlotSwapStatus_STATUS. Use v1api20220301.SlotSwapStatus_STATUS instead
type SlotSwapStatus_STATUS struct {
	DestinationSlotName *string `json:"destinationSlotName,omitempty"`
	SourceSlotName      *string `json:"sourceSlotName,omitempty"`
	TimestampUtc        *string `json:"timestampUtc,omitempty"`
}

var _ genruntime.FromARMConverter = &SlotSwapStatus_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (status *SlotSwapStatus_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SlotSwapStatus_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (status *SlotSwapStatus_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SlotSwapStatus_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SlotSwapStatus_STATUS_ARM, got %T", armInput)
	}

	// Set property "DestinationSlotName":
	if typedInput.DestinationSlotName != nil {
		destinationSlotName := *typedInput.DestinationSlotName
		status.DestinationSlotName = &destinationSlotName
	}

	// Set property "SourceSlotName":
	if typedInput.SourceSlotName != nil {
		sourceSlotName := *typedInput.SourceSlotName
		status.SourceSlotName = &sourceSlotName
	}

	// Set property "TimestampUtc":
	if typedInput.TimestampUtc != nil {
		timestampUtc := *typedInput.TimestampUtc
		status.TimestampUtc = &timestampUtc
	}

	// No error
	return nil
}

// AssignProperties_From_SlotSwapStatus_STATUS populates our SlotSwapStatus_STATUS from the provided source SlotSwapStatus_STATUS
func (status *SlotSwapStatus_STATUS) AssignProperties_From_SlotSwapStatus_STATUS(source *v1beta20220301s.SlotSwapStatus_STATUS) error {

	// DestinationSlotName
	status.DestinationSlotName = genruntime.ClonePointerToString(source.DestinationSlotName)

	// SourceSlotName
	status.SourceSlotName = genruntime.ClonePointerToString(source.SourceSlotName)

	// TimestampUtc
	status.TimestampUtc = genruntime.ClonePointerToString(source.TimestampUtc)

	// No error
	return nil
}

// AssignProperties_To_SlotSwapStatus_STATUS populates the provided destination SlotSwapStatus_STATUS from our SlotSwapStatus_STATUS
func (status *SlotSwapStatus_STATUS) AssignProperties_To_SlotSwapStatus_STATUS(destination *v1beta20220301s.SlotSwapStatus_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DestinationSlotName
	destination.DestinationSlotName = genruntime.ClonePointerToString(status.DestinationSlotName)

	// SourceSlotName
	destination.SourceSlotName = genruntime.ClonePointerToString(status.SourceSlotName)

	// TimestampUtc
	destination.TimestampUtc = genruntime.ClonePointerToString(status.TimestampUtc)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of ApiDefinitionInfo. Use v1api20220301.ApiDefinitionInfo instead
type ApiDefinitionInfo struct {
	Url *string `json:"url,omitempty"`
}

var _ genruntime.ARMTransformer = &ApiDefinitionInfo{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (info *ApiDefinitionInfo) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if info == nil {
		return nil, nil
	}
	result := &ApiDefinitionInfo_ARM{}

	// Set property "Url":
	if info.Url != nil {
		url := *info.Url
		result.Url = &url
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (info *ApiDefinitionInfo) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ApiDefinitionInfo_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (info *ApiDefinitionInfo) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ApiDefinitionInfo_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ApiDefinitionInfo_ARM, got %T", armInput)
	}

	// Set property "Url":
	if typedInput.Url != nil {
		url := *typedInput.Url
		info.Url = &url
	}

	// No error
	return nil
}

// AssignProperties_From_ApiDefinitionInfo populates our ApiDefinitionInfo from the provided source ApiDefinitionInfo
func (info *ApiDefinitionInfo) AssignProperties_From_ApiDefinitionInfo(source *v1beta20220301s.ApiDefinitionInfo) error {

	// Url
	info.Url = genruntime.ClonePointerToString(source.Url)

	// No error
	return nil
}

// AssignProperties_To_ApiDefinitionInfo populates the provided destination ApiDefinitionInfo from our ApiDefinitionInfo
func (info *ApiDefinitionInfo) AssignProperties_To_ApiDefinitionInfo(destination *v1beta20220301s.ApiDefinitionInfo) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Url
	destination.Url = genruntime.ClonePointerToString(info.Url)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of ApiDefinitionInfo_STATUS. Use v1api20220301.ApiDefinitionInfo_STATUS instead
type ApiDefinitionInfo_STATUS struct {
	Url *string `json:"url,omitempty"`
}

var _ genruntime.FromARMConverter = &ApiDefinitionInfo_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (info *ApiDefinitionInfo_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ApiDefinitionInfo_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (info *ApiDefinitionInfo_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ApiDefinitionInfo_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ApiDefinitionInfo_STATUS_ARM, got %T", armInput)
	}

	// Set property "Url":
	if typedInput.Url != nil {
		url := *typedInput.Url
		info.Url = &url
	}

	// No error
	return nil
}

// AssignProperties_From_ApiDefinitionInfo_STATUS populates our ApiDefinitionInfo_STATUS from the provided source ApiDefinitionInfo_STATUS
func (info *ApiDefinitionInfo_STATUS) AssignProperties_From_ApiDefinitionInfo_STATUS(source *v1beta20220301s.ApiDefinitionInfo_STATUS) error {

	// Url
	info.Url = genruntime.ClonePointerToString(source.Url)

	// No error
	return nil
}

// AssignProperties_To_ApiDefinitionInfo_STATUS populates the provided destination ApiDefinitionInfo_STATUS from our ApiDefinitionInfo_STATUS
func (info *ApiDefinitionInfo_STATUS) AssignProperties_To_ApiDefinitionInfo_STATUS(destination *v1beta20220301s.ApiDefinitionInfo_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Url
	destination.Url = genruntime.ClonePointerToString(info.Url)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of ApiManagementConfig. Use v1api20220301.ApiManagementConfig instead
type ApiManagementConfig struct {
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &ApiManagementConfig{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (config *ApiManagementConfig) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if config == nil {
		return nil, nil
	}
	result := &ApiManagementConfig_ARM{}

	// Set property "Id":
	if config.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*config.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (config *ApiManagementConfig) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ApiManagementConfig_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (config *ApiManagementConfig) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(ApiManagementConfig_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ApiManagementConfig_ARM, got %T", armInput)
	}

	// no assignment for property "Reference"

	// No error
	return nil
}

// AssignProperties_From_ApiManagementConfig populates our ApiManagementConfig from the provided source ApiManagementConfig
func (config *ApiManagementConfig) AssignProperties_From_ApiManagementConfig(source *v1beta20220301s.ApiManagementConfig) error {

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		config.Reference = &reference
	} else {
		config.Reference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ApiManagementConfig populates the provided destination ApiManagementConfig from our ApiManagementConfig
func (config *ApiManagementConfig) AssignProperties_To_ApiManagementConfig(destination *v1beta20220301s.ApiManagementConfig) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if config.Reference != nil {
		reference := config.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of ApiManagementConfig_STATUS. Use v1api20220301.ApiManagementConfig_STATUS instead
type ApiManagementConfig_STATUS struct {
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &ApiManagementConfig_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (config *ApiManagementConfig_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ApiManagementConfig_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (config *ApiManagementConfig_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ApiManagementConfig_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ApiManagementConfig_STATUS_ARM, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		config.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_ApiManagementConfig_STATUS populates our ApiManagementConfig_STATUS from the provided source ApiManagementConfig_STATUS
func (config *ApiManagementConfig_STATUS) AssignProperties_From_ApiManagementConfig_STATUS(source *v1beta20220301s.ApiManagementConfig_STATUS) error {

	// Id
	config.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_ApiManagementConfig_STATUS populates the provided destination ApiManagementConfig_STATUS from our ApiManagementConfig_STATUS
func (config *ApiManagementConfig_STATUS) AssignProperties_To_ApiManagementConfig_STATUS(destination *v1beta20220301s.ApiManagementConfig_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(config.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of AutoHealRules. Use v1api20220301.AutoHealRules instead
type AutoHealRules struct {
	Actions  *AutoHealActions  `json:"actions,omitempty"`
	Triggers *AutoHealTriggers `json:"triggers,omitempty"`
}

var _ genruntime.ARMTransformer = &AutoHealRules{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rules *AutoHealRules) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rules == nil {
		return nil, nil
	}
	result := &AutoHealRules_ARM{}

	// Set property "Actions":
	if rules.Actions != nil {
		actions_ARM, err := (*rules.Actions).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		actions := *actions_ARM.(*AutoHealActions_ARM)
		result.Actions = &actions
	}

	// Set property "Triggers":
	if rules.Triggers != nil {
		triggers_ARM, err := (*rules.Triggers).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		triggers := *triggers_ARM.(*AutoHealTriggers_ARM)
		result.Triggers = &triggers
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rules *AutoHealRules) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AutoHealRules_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rules *AutoHealRules) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AutoHealRules_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AutoHealRules_ARM, got %T", armInput)
	}

	// Set property "Actions":
	if typedInput.Actions != nil {
		var actions1 AutoHealActions
		err := actions1.PopulateFromARM(owner, *typedInput.Actions)
		if err != nil {
			return err
		}
		actions := actions1
		rules.Actions = &actions
	}

	// Set property "Triggers":
	if typedInput.Triggers != nil {
		var triggers1 AutoHealTriggers
		err := triggers1.PopulateFromARM(owner, *typedInput.Triggers)
		if err != nil {
			return err
		}
		triggers := triggers1
		rules.Triggers = &triggers
	}

	// No error
	return nil
}

// AssignProperties_From_AutoHealRules populates our AutoHealRules from the provided source AutoHealRules
func (rules *AutoHealRules) AssignProperties_From_AutoHealRules(source *v1beta20220301s.AutoHealRules) error {

	// Actions
	if source.Actions != nil {
		var action AutoHealActions
		err := action.AssignProperties_From_AutoHealActions(source.Actions)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AutoHealActions() to populate field Actions")
		}
		rules.Actions = &action
	} else {
		rules.Actions = nil
	}

	// Triggers
	if source.Triggers != nil {
		var trigger AutoHealTriggers
		err := trigger.AssignProperties_From_AutoHealTriggers(source.Triggers)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AutoHealTriggers() to populate field Triggers")
		}
		rules.Triggers = &trigger
	} else {
		rules.Triggers = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AutoHealRules populates the provided destination AutoHealRules from our AutoHealRules
func (rules *AutoHealRules) AssignProperties_To_AutoHealRules(destination *v1beta20220301s.AutoHealRules) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Actions
	if rules.Actions != nil {
		var action v1beta20220301s.AutoHealActions
		err := rules.Actions.AssignProperties_To_AutoHealActions(&action)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AutoHealActions() to populate field Actions")
		}
		destination.Actions = &action
	} else {
		destination.Actions = nil
	}

	// Triggers
	if rules.Triggers != nil {
		var trigger v1beta20220301s.AutoHealTriggers
		err := rules.Triggers.AssignProperties_To_AutoHealTriggers(&trigger)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AutoHealTriggers() to populate field Triggers")
		}
		destination.Triggers = &trigger
	} else {
		destination.Triggers = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of AutoHealRules_STATUS. Use v1api20220301.AutoHealRules_STATUS instead
type AutoHealRules_STATUS struct {
	Actions  *AutoHealActions_STATUS  `json:"actions,omitempty"`
	Triggers *AutoHealTriggers_STATUS `json:"triggers,omitempty"`
}

var _ genruntime.FromARMConverter = &AutoHealRules_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rules *AutoHealRules_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AutoHealRules_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rules *AutoHealRules_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AutoHealRules_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AutoHealRules_STATUS_ARM, got %T", armInput)
	}

	// Set property "Actions":
	if typedInput.Actions != nil {
		var actions1 AutoHealActions_STATUS
		err := actions1.PopulateFromARM(owner, *typedInput.Actions)
		if err != nil {
			return err
		}
		actions := actions1
		rules.Actions = &actions
	}

	// Set property "Triggers":
	if typedInput.Triggers != nil {
		var triggers1 AutoHealTriggers_STATUS
		err := triggers1.PopulateFromARM(owner, *typedInput.Triggers)
		if err != nil {
			return err
		}
		triggers := triggers1
		rules.Triggers = &triggers
	}

	// No error
	return nil
}

// AssignProperties_From_AutoHealRules_STATUS populates our AutoHealRules_STATUS from the provided source AutoHealRules_STATUS
func (rules *AutoHealRules_STATUS) AssignProperties_From_AutoHealRules_STATUS(source *v1beta20220301s.AutoHealRules_STATUS) error {

	// Actions
	if source.Actions != nil {
		var action AutoHealActions_STATUS
		err := action.AssignProperties_From_AutoHealActions_STATUS(source.Actions)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AutoHealActions_STATUS() to populate field Actions")
		}
		rules.Actions = &action
	} else {
		rules.Actions = nil
	}

	// Triggers
	if source.Triggers != nil {
		var trigger AutoHealTriggers_STATUS
		err := trigger.AssignProperties_From_AutoHealTriggers_STATUS(source.Triggers)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AutoHealTriggers_STATUS() to populate field Triggers")
		}
		rules.Triggers = &trigger
	} else {
		rules.Triggers = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AutoHealRules_STATUS populates the provided destination AutoHealRules_STATUS from our AutoHealRules_STATUS
func (rules *AutoHealRules_STATUS) AssignProperties_To_AutoHealRules_STATUS(destination *v1beta20220301s.AutoHealRules_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Actions
	if rules.Actions != nil {
		var action v1beta20220301s.AutoHealActions_STATUS
		err := rules.Actions.AssignProperties_To_AutoHealActions_STATUS(&action)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AutoHealActions_STATUS() to populate field Actions")
		}
		destination.Actions = &action
	} else {
		destination.Actions = nil
	}

	// Triggers
	if rules.Triggers != nil {
		var trigger v1beta20220301s.AutoHealTriggers_STATUS
		err := rules.Triggers.AssignProperties_To_AutoHealTriggers_STATUS(&trigger)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AutoHealTriggers_STATUS() to populate field Triggers")
		}
		destination.Triggers = &trigger
	} else {
		destination.Triggers = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of AzureStorageInfoValue. Use v1api20220301.AzureStorageInfoValue instead
type AzureStorageInfoValue struct {
	AccessKey   *genruntime.SecretReference `json:"accessKey,omitempty"`
	AccountName *string                     `json:"accountName,omitempty"`
	MountPath   *string                     `json:"mountPath,omitempty"`
	ShareName   *string                     `json:"shareName,omitempty"`
	Type        *AzureStorageInfoValue_Type `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &AzureStorageInfoValue{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (value *AzureStorageInfoValue) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if value == nil {
		return nil, nil
	}
	result := &AzureStorageInfoValue_ARM{}

	// Set property "AccessKey":
	if value.AccessKey != nil {
		accessKeySecret, err := resolved.ResolvedSecrets.Lookup(*value.AccessKey)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property AccessKey")
		}
		accessKey := accessKeySecret
		result.AccessKey = &accessKey
	}

	// Set property "AccountName":
	if value.AccountName != nil {
		accountName := *value.AccountName
		result.AccountName = &accountName
	}

	// Set property "MountPath":
	if value.MountPath != nil {
		mountPath := *value.MountPath
		result.MountPath = &mountPath
	}

	// Set property "ShareName":
	if value.ShareName != nil {
		shareName := *value.ShareName
		result.ShareName = &shareName
	}

	// Set property "Type":
	if value.Type != nil {
		typeVar := *value.Type
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (value *AzureStorageInfoValue) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AzureStorageInfoValue_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (value *AzureStorageInfoValue) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AzureStorageInfoValue_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AzureStorageInfoValue_ARM, got %T", armInput)
	}

	// no assignment for property "AccessKey"

	// Set property "AccountName":
	if typedInput.AccountName != nil {
		accountName := *typedInput.AccountName
		value.AccountName = &accountName
	}

	// Set property "MountPath":
	if typedInput.MountPath != nil {
		mountPath := *typedInput.MountPath
		value.MountPath = &mountPath
	}

	// Set property "ShareName":
	if typedInput.ShareName != nil {
		shareName := *typedInput.ShareName
		value.ShareName = &shareName
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		value.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_AzureStorageInfoValue populates our AzureStorageInfoValue from the provided source AzureStorageInfoValue
func (value *AzureStorageInfoValue) AssignProperties_From_AzureStorageInfoValue(source *v1beta20220301s.AzureStorageInfoValue) error {

	// AccessKey
	if source.AccessKey != nil {
		accessKey := source.AccessKey.Copy()
		value.AccessKey = &accessKey
	} else {
		value.AccessKey = nil
	}

	// AccountName
	value.AccountName = genruntime.ClonePointerToString(source.AccountName)

	// MountPath
	value.MountPath = genruntime.ClonePointerToString(source.MountPath)

	// ShareName
	value.ShareName = genruntime.ClonePointerToString(source.ShareName)

	// Type
	if source.Type != nil {
		typeVar := AzureStorageInfoValue_Type(*source.Type)
		value.Type = &typeVar
	} else {
		value.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AzureStorageInfoValue populates the provided destination AzureStorageInfoValue from our AzureStorageInfoValue
func (value *AzureStorageInfoValue) AssignProperties_To_AzureStorageInfoValue(destination *v1beta20220301s.AzureStorageInfoValue) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AccessKey
	if value.AccessKey != nil {
		accessKey := value.AccessKey.Copy()
		destination.AccessKey = &accessKey
	} else {
		destination.AccessKey = nil
	}

	// AccountName
	destination.AccountName = genruntime.ClonePointerToString(value.AccountName)

	// MountPath
	destination.MountPath = genruntime.ClonePointerToString(value.MountPath)

	// ShareName
	destination.ShareName = genruntime.ClonePointerToString(value.ShareName)

	// Type
	if value.Type != nil {
		typeVar := string(*value.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of AzureStorageInfoValue_STATUS. Use v1api20220301.AzureStorageInfoValue_STATUS instead
type AzureStorageInfoValue_STATUS struct {
	AccountName *string                             `json:"accountName,omitempty"`
	MountPath   *string                             `json:"mountPath,omitempty"`
	ShareName   *string                             `json:"shareName,omitempty"`
	State       *AzureStorageInfoValue_State_STATUS `json:"state,omitempty"`
	Type        *AzureStorageInfoValue_Type_STATUS  `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &AzureStorageInfoValue_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (value *AzureStorageInfoValue_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AzureStorageInfoValue_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (value *AzureStorageInfoValue_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AzureStorageInfoValue_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AzureStorageInfoValue_STATUS_ARM, got %T", armInput)
	}

	// Set property "AccountName":
	if typedInput.AccountName != nil {
		accountName := *typedInput.AccountName
		value.AccountName = &accountName
	}

	// Set property "MountPath":
	if typedInput.MountPath != nil {
		mountPath := *typedInput.MountPath
		value.MountPath = &mountPath
	}

	// Set property "ShareName":
	if typedInput.ShareName != nil {
		shareName := *typedInput.ShareName
		value.ShareName = &shareName
	}

	// Set property "State":
	if typedInput.State != nil {
		state := *typedInput.State
		value.State = &state
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		value.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_AzureStorageInfoValue_STATUS populates our AzureStorageInfoValue_STATUS from the provided source AzureStorageInfoValue_STATUS
func (value *AzureStorageInfoValue_STATUS) AssignProperties_From_AzureStorageInfoValue_STATUS(source *v1beta20220301s.AzureStorageInfoValue_STATUS) error {

	// AccountName
	value.AccountName = genruntime.ClonePointerToString(source.AccountName)

	// MountPath
	value.MountPath = genruntime.ClonePointerToString(source.MountPath)

	// ShareName
	value.ShareName = genruntime.ClonePointerToString(source.ShareName)

	// State
	if source.State != nil {
		state := AzureStorageInfoValue_State_STATUS(*source.State)
		value.State = &state
	} else {
		value.State = nil
	}

	// Type
	if source.Type != nil {
		typeVar := AzureStorageInfoValue_Type_STATUS(*source.Type)
		value.Type = &typeVar
	} else {
		value.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AzureStorageInfoValue_STATUS populates the provided destination AzureStorageInfoValue_STATUS from our AzureStorageInfoValue_STATUS
func (value *AzureStorageInfoValue_STATUS) AssignProperties_To_AzureStorageInfoValue_STATUS(destination *v1beta20220301s.AzureStorageInfoValue_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AccountName
	destination.AccountName = genruntime.ClonePointerToString(value.AccountName)

	// MountPath
	destination.MountPath = genruntime.ClonePointerToString(value.MountPath)

	// ShareName
	destination.ShareName = genruntime.ClonePointerToString(value.ShareName)

	// State
	if value.State != nil {
		state := string(*value.State)
		destination.State = &state
	} else {
		destination.State = nil
	}

	// Type
	if value.Type != nil {
		typeVar := string(*value.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of ConnStringInfo. Use v1api20220301.ConnStringInfo instead
type ConnStringInfo struct {
	ConnectionString *string              `json:"connectionString,omitempty"`
	Name             *string              `json:"name,omitempty"`
	Type             *ConnStringInfo_Type `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &ConnStringInfo{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (info *ConnStringInfo) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if info == nil {
		return nil, nil
	}
	result := &ConnStringInfo_ARM{}

	// Set property "ConnectionString":
	if info.ConnectionString != nil {
		connectionString := *info.ConnectionString
		result.ConnectionString = &connectionString
	}

	// Set property "Name":
	if info.Name != nil {
		name := *info.Name
		result.Name = &name
	}

	// Set property "Type":
	if info.Type != nil {
		typeVar := *info.Type
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (info *ConnStringInfo) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ConnStringInfo_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (info *ConnStringInfo) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ConnStringInfo_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ConnStringInfo_ARM, got %T", armInput)
	}

	// Set property "ConnectionString":
	if typedInput.ConnectionString != nil {
		connectionString := *typedInput.ConnectionString
		info.ConnectionString = &connectionString
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		info.Name = &name
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		info.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_ConnStringInfo populates our ConnStringInfo from the provided source ConnStringInfo
func (info *ConnStringInfo) AssignProperties_From_ConnStringInfo(source *v1beta20220301s.ConnStringInfo) error {

	// ConnectionString
	info.ConnectionString = genruntime.ClonePointerToString(source.ConnectionString)

	// Name
	info.Name = genruntime.ClonePointerToString(source.Name)

	// Type
	if source.Type != nil {
		typeVar := ConnStringInfo_Type(*source.Type)
		info.Type = &typeVar
	} else {
		info.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ConnStringInfo populates the provided destination ConnStringInfo from our ConnStringInfo
func (info *ConnStringInfo) AssignProperties_To_ConnStringInfo(destination *v1beta20220301s.ConnStringInfo) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConnectionString
	destination.ConnectionString = genruntime.ClonePointerToString(info.ConnectionString)

	// Name
	destination.Name = genruntime.ClonePointerToString(info.Name)

	// Type
	if info.Type != nil {
		typeVar := string(*info.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of ConnStringInfo_STATUS. Use v1api20220301.ConnStringInfo_STATUS instead
type ConnStringInfo_STATUS struct {
	ConnectionString *string                     `json:"connectionString,omitempty"`
	Name             *string                     `json:"name,omitempty"`
	Type             *ConnStringInfo_Type_STATUS `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &ConnStringInfo_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (info *ConnStringInfo_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ConnStringInfo_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (info *ConnStringInfo_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ConnStringInfo_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ConnStringInfo_STATUS_ARM, got %T", armInput)
	}

	// Set property "ConnectionString":
	if typedInput.ConnectionString != nil {
		connectionString := *typedInput.ConnectionString
		info.ConnectionString = &connectionString
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		info.Name = &name
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		info.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_ConnStringInfo_STATUS populates our ConnStringInfo_STATUS from the provided source ConnStringInfo_STATUS
func (info *ConnStringInfo_STATUS) AssignProperties_From_ConnStringInfo_STATUS(source *v1beta20220301s.ConnStringInfo_STATUS) error {

	// ConnectionString
	info.ConnectionString = genruntime.ClonePointerToString(source.ConnectionString)

	// Name
	info.Name = genruntime.ClonePointerToString(source.Name)

	// Type
	if source.Type != nil {
		typeVar := ConnStringInfo_Type_STATUS(*source.Type)
		info.Type = &typeVar
	} else {
		info.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ConnStringInfo_STATUS populates the provided destination ConnStringInfo_STATUS from our ConnStringInfo_STATUS
func (info *ConnStringInfo_STATUS) AssignProperties_To_ConnStringInfo_STATUS(destination *v1beta20220301s.ConnStringInfo_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConnectionString
	destination.ConnectionString = genruntime.ClonePointerToString(info.ConnectionString)

	// Name
	destination.Name = genruntime.ClonePointerToString(info.Name)

	// Type
	if info.Type != nil {
		typeVar := string(*info.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of CorsSettings. Use v1api20220301.CorsSettings instead
type CorsSettings struct {
	AllowedOrigins     []string `json:"allowedOrigins,omitempty"`
	SupportCredentials *bool    `json:"supportCredentials,omitempty"`
}

var _ genruntime.ARMTransformer = &CorsSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *CorsSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &CorsSettings_ARM{}

	// Set property "AllowedOrigins":
	for _, item := range settings.AllowedOrigins {
		result.AllowedOrigins = append(result.AllowedOrigins, item)
	}

	// Set property "SupportCredentials":
	if settings.SupportCredentials != nil {
		supportCredentials := *settings.SupportCredentials
		result.SupportCredentials = &supportCredentials
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *CorsSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &CorsSettings_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *CorsSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(CorsSettings_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CorsSettings_ARM, got %T", armInput)
	}

	// Set property "AllowedOrigins":
	for _, item := range typedInput.AllowedOrigins {
		settings.AllowedOrigins = append(settings.AllowedOrigins, item)
	}

	// Set property "SupportCredentials":
	if typedInput.SupportCredentials != nil {
		supportCredentials := *typedInput.SupportCredentials
		settings.SupportCredentials = &supportCredentials
	}

	// No error
	return nil
}

// AssignProperties_From_CorsSettings populates our CorsSettings from the provided source CorsSettings
func (settings *CorsSettings) AssignProperties_From_CorsSettings(source *v1beta20220301s.CorsSettings) error {

	// AllowedOrigins
	settings.AllowedOrigins = genruntime.CloneSliceOfString(source.AllowedOrigins)

	// SupportCredentials
	if source.SupportCredentials != nil {
		supportCredential := *source.SupportCredentials
		settings.SupportCredentials = &supportCredential
	} else {
		settings.SupportCredentials = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CorsSettings populates the provided destination CorsSettings from our CorsSettings
func (settings *CorsSettings) AssignProperties_To_CorsSettings(destination *v1beta20220301s.CorsSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllowedOrigins
	destination.AllowedOrigins = genruntime.CloneSliceOfString(settings.AllowedOrigins)

	// SupportCredentials
	if settings.SupportCredentials != nil {
		supportCredential := *settings.SupportCredentials
		destination.SupportCredentials = &supportCredential
	} else {
		destination.SupportCredentials = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of CorsSettings_STATUS. Use v1api20220301.CorsSettings_STATUS instead
type CorsSettings_STATUS struct {
	AllowedOrigins     []string `json:"allowedOrigins,omitempty"`
	SupportCredentials *bool    `json:"supportCredentials,omitempty"`
}

var _ genruntime.FromARMConverter = &CorsSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *CorsSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &CorsSettings_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *CorsSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(CorsSettings_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CorsSettings_STATUS_ARM, got %T", armInput)
	}

	// Set property "AllowedOrigins":
	for _, item := range typedInput.AllowedOrigins {
		settings.AllowedOrigins = append(settings.AllowedOrigins, item)
	}

	// Set property "SupportCredentials":
	if typedInput.SupportCredentials != nil {
		supportCredentials := *typedInput.SupportCredentials
		settings.SupportCredentials = &supportCredentials
	}

	// No error
	return nil
}

// AssignProperties_From_CorsSettings_STATUS populates our CorsSettings_STATUS from the provided source CorsSettings_STATUS
func (settings *CorsSettings_STATUS) AssignProperties_From_CorsSettings_STATUS(source *v1beta20220301s.CorsSettings_STATUS) error {

	// AllowedOrigins
	settings.AllowedOrigins = genruntime.CloneSliceOfString(source.AllowedOrigins)

	// SupportCredentials
	if source.SupportCredentials != nil {
		supportCredential := *source.SupportCredentials
		settings.SupportCredentials = &supportCredential
	} else {
		settings.SupportCredentials = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CorsSettings_STATUS populates the provided destination CorsSettings_STATUS from our CorsSettings_STATUS
func (settings *CorsSettings_STATUS) AssignProperties_To_CorsSettings_STATUS(destination *v1beta20220301s.CorsSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllowedOrigins
	destination.AllowedOrigins = genruntime.CloneSliceOfString(settings.AllowedOrigins)

	// SupportCredentials
	if settings.SupportCredentials != nil {
		supportCredential := *settings.SupportCredentials
		destination.SupportCredentials = &supportCredential
	} else {
		destination.SupportCredentials = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of Experiments. Use v1api20220301.Experiments instead
type Experiments struct {
	RampUpRules []RampUpRule `json:"rampUpRules,omitempty"`
}

var _ genruntime.ARMTransformer = &Experiments{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (experiments *Experiments) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if experiments == nil {
		return nil, nil
	}
	result := &Experiments_ARM{}

	// Set property "RampUpRules":
	for _, item := range experiments.RampUpRules {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.RampUpRules = append(result.RampUpRules, *item_ARM.(*RampUpRule_ARM))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (experiments *Experiments) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Experiments_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (experiments *Experiments) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Experiments_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Experiments_ARM, got %T", armInput)
	}

	// Set property "RampUpRules":
	for _, item := range typedInput.RampUpRules {
		var item1 RampUpRule
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		experiments.RampUpRules = append(experiments.RampUpRules, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_Experiments populates our Experiments from the provided source Experiments
func (experiments *Experiments) AssignProperties_From_Experiments(source *v1beta20220301s.Experiments) error {

	// RampUpRules
	if source.RampUpRules != nil {
		rampUpRuleList := make([]RampUpRule, len(source.RampUpRules))
		for rampUpRuleIndex, rampUpRuleItem := range source.RampUpRules {
			// Shadow the loop variable to avoid aliasing
			rampUpRuleItem := rampUpRuleItem
			var rampUpRule RampUpRule
			err := rampUpRule.AssignProperties_From_RampUpRule(&rampUpRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_RampUpRule() to populate field RampUpRules")
			}
			rampUpRuleList[rampUpRuleIndex] = rampUpRule
		}
		experiments.RampUpRules = rampUpRuleList
	} else {
		experiments.RampUpRules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Experiments populates the provided destination Experiments from our Experiments
func (experiments *Experiments) AssignProperties_To_Experiments(destination *v1beta20220301s.Experiments) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// RampUpRules
	if experiments.RampUpRules != nil {
		rampUpRuleList := make([]v1beta20220301s.RampUpRule, len(experiments.RampUpRules))
		for rampUpRuleIndex, rampUpRuleItem := range experiments.RampUpRules {
			// Shadow the loop variable to avoid aliasing
			rampUpRuleItem := rampUpRuleItem
			var rampUpRule v1beta20220301s.RampUpRule
			err := rampUpRuleItem.AssignProperties_To_RampUpRule(&rampUpRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_RampUpRule() to populate field RampUpRules")
			}
			rampUpRuleList[rampUpRuleIndex] = rampUpRule
		}
		destination.RampUpRules = rampUpRuleList
	} else {
		destination.RampUpRules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of Experiments_STATUS. Use v1api20220301.Experiments_STATUS instead
type Experiments_STATUS struct {
	RampUpRules []RampUpRule_STATUS `json:"rampUpRules,omitempty"`
}

var _ genruntime.FromARMConverter = &Experiments_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (experiments *Experiments_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Experiments_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (experiments *Experiments_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Experiments_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Experiments_STATUS_ARM, got %T", armInput)
	}

	// Set property "RampUpRules":
	for _, item := range typedInput.RampUpRules {
		var item1 RampUpRule_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		experiments.RampUpRules = append(experiments.RampUpRules, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_Experiments_STATUS populates our Experiments_STATUS from the provided source Experiments_STATUS
func (experiments *Experiments_STATUS) AssignProperties_From_Experiments_STATUS(source *v1beta20220301s.Experiments_STATUS) error {

	// RampUpRules
	if source.RampUpRules != nil {
		rampUpRuleList := make([]RampUpRule_STATUS, len(source.RampUpRules))
		for rampUpRuleIndex, rampUpRuleItem := range source.RampUpRules {
			// Shadow the loop variable to avoid aliasing
			rampUpRuleItem := rampUpRuleItem
			var rampUpRule RampUpRule_STATUS
			err := rampUpRule.AssignProperties_From_RampUpRule_STATUS(&rampUpRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_RampUpRule_STATUS() to populate field RampUpRules")
			}
			rampUpRuleList[rampUpRuleIndex] = rampUpRule
		}
		experiments.RampUpRules = rampUpRuleList
	} else {
		experiments.RampUpRules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Experiments_STATUS populates the provided destination Experiments_STATUS from our Experiments_STATUS
func (experiments *Experiments_STATUS) AssignProperties_To_Experiments_STATUS(destination *v1beta20220301s.Experiments_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// RampUpRules
	if experiments.RampUpRules != nil {
		rampUpRuleList := make([]v1beta20220301s.RampUpRule_STATUS, len(experiments.RampUpRules))
		for rampUpRuleIndex, rampUpRuleItem := range experiments.RampUpRules {
			// Shadow the loop variable to avoid aliasing
			rampUpRuleItem := rampUpRuleItem
			var rampUpRule v1beta20220301s.RampUpRule_STATUS
			err := rampUpRuleItem.AssignProperties_To_RampUpRule_STATUS(&rampUpRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_RampUpRule_STATUS() to populate field RampUpRules")
			}
			rampUpRuleList[rampUpRuleIndex] = rampUpRule
		}
		destination.RampUpRules = rampUpRuleList
	} else {
		destination.RampUpRules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of HandlerMapping. Use v1api20220301.HandlerMapping instead
type HandlerMapping struct {
	Arguments       *string `json:"arguments,omitempty"`
	Extension       *string `json:"extension,omitempty"`
	ScriptProcessor *string `json:"scriptProcessor,omitempty"`
}

var _ genruntime.ARMTransformer = &HandlerMapping{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (mapping *HandlerMapping) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if mapping == nil {
		return nil, nil
	}
	result := &HandlerMapping_ARM{}

	// Set property "Arguments":
	if mapping.Arguments != nil {
		arguments := *mapping.Arguments
		result.Arguments = &arguments
	}

	// Set property "Extension":
	if mapping.Extension != nil {
		extension := *mapping.Extension
		result.Extension = &extension
	}

	// Set property "ScriptProcessor":
	if mapping.ScriptProcessor != nil {
		scriptProcessor := *mapping.ScriptProcessor
		result.ScriptProcessor = &scriptProcessor
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (mapping *HandlerMapping) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &HandlerMapping_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (mapping *HandlerMapping) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(HandlerMapping_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected HandlerMapping_ARM, got %T", armInput)
	}

	// Set property "Arguments":
	if typedInput.Arguments != nil {
		arguments := *typedInput.Arguments
		mapping.Arguments = &arguments
	}

	// Set property "Extension":
	if typedInput.Extension != nil {
		extension := *typedInput.Extension
		mapping.Extension = &extension
	}

	// Set property "ScriptProcessor":
	if typedInput.ScriptProcessor != nil {
		scriptProcessor := *typedInput.ScriptProcessor
		mapping.ScriptProcessor = &scriptProcessor
	}

	// No error
	return nil
}

// AssignProperties_From_HandlerMapping populates our HandlerMapping from the provided source HandlerMapping
func (mapping *HandlerMapping) AssignProperties_From_HandlerMapping(source *v1beta20220301s.HandlerMapping) error {

	// Arguments
	mapping.Arguments = genruntime.ClonePointerToString(source.Arguments)

	// Extension
	mapping.Extension = genruntime.ClonePointerToString(source.Extension)

	// ScriptProcessor
	mapping.ScriptProcessor = genruntime.ClonePointerToString(source.ScriptProcessor)

	// No error
	return nil
}

// AssignProperties_To_HandlerMapping populates the provided destination HandlerMapping from our HandlerMapping
func (mapping *HandlerMapping) AssignProperties_To_HandlerMapping(destination *v1beta20220301s.HandlerMapping) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Arguments
	destination.Arguments = genruntime.ClonePointerToString(mapping.Arguments)

	// Extension
	destination.Extension = genruntime.ClonePointerToString(mapping.Extension)

	// ScriptProcessor
	destination.ScriptProcessor = genruntime.ClonePointerToString(mapping.ScriptProcessor)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of HandlerMapping_STATUS. Use v1api20220301.HandlerMapping_STATUS instead
type HandlerMapping_STATUS struct {
	Arguments       *string `json:"arguments,omitempty"`
	Extension       *string `json:"extension,omitempty"`
	ScriptProcessor *string `json:"scriptProcessor,omitempty"`
}

var _ genruntime.FromARMConverter = &HandlerMapping_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (mapping *HandlerMapping_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &HandlerMapping_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (mapping *HandlerMapping_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(HandlerMapping_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected HandlerMapping_STATUS_ARM, got %T", armInput)
	}

	// Set property "Arguments":
	if typedInput.Arguments != nil {
		arguments := *typedInput.Arguments
		mapping.Arguments = &arguments
	}

	// Set property "Extension":
	if typedInput.Extension != nil {
		extension := *typedInput.Extension
		mapping.Extension = &extension
	}

	// Set property "ScriptProcessor":
	if typedInput.ScriptProcessor != nil {
		scriptProcessor := *typedInput.ScriptProcessor
		mapping.ScriptProcessor = &scriptProcessor
	}

	// No error
	return nil
}

// AssignProperties_From_HandlerMapping_STATUS populates our HandlerMapping_STATUS from the provided source HandlerMapping_STATUS
func (mapping *HandlerMapping_STATUS) AssignProperties_From_HandlerMapping_STATUS(source *v1beta20220301s.HandlerMapping_STATUS) error {

	// Arguments
	mapping.Arguments = genruntime.ClonePointerToString(source.Arguments)

	// Extension
	mapping.Extension = genruntime.ClonePointerToString(source.Extension)

	// ScriptProcessor
	mapping.ScriptProcessor = genruntime.ClonePointerToString(source.ScriptProcessor)

	// No error
	return nil
}

// AssignProperties_To_HandlerMapping_STATUS populates the provided destination HandlerMapping_STATUS from our HandlerMapping_STATUS
func (mapping *HandlerMapping_STATUS) AssignProperties_To_HandlerMapping_STATUS(destination *v1beta20220301s.HandlerMapping_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Arguments
	destination.Arguments = genruntime.ClonePointerToString(mapping.Arguments)

	// Extension
	destination.Extension = genruntime.ClonePointerToString(mapping.Extension)

	// ScriptProcessor
	destination.ScriptProcessor = genruntime.ClonePointerToString(mapping.ScriptProcessor)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of HostNameSslState_HostType. Use v1api20220301.HostNameSslState_HostType instead
// +kubebuilder:validation:Enum={"Repository","Standard"}
type HostNameSslState_HostType string

const (
	HostNameSslState_HostType_Repository = HostNameSslState_HostType("Repository")
	HostNameSslState_HostType_Standard   = HostNameSslState_HostType("Standard")
)

// Deprecated version of HostNameSslState_HostType_STATUS. Use v1api20220301.HostNameSslState_HostType_STATUS instead
type HostNameSslState_HostType_STATUS string

const (
	HostNameSslState_HostType_STATUS_Repository = HostNameSslState_HostType_STATUS("Repository")
	HostNameSslState_HostType_STATUS_Standard   = HostNameSslState_HostType_STATUS("Standard")
)

// Deprecated version of HostNameSslState_SslState. Use v1api20220301.HostNameSslState_SslState instead
// +kubebuilder:validation:Enum={"Disabled","IpBasedEnabled","SniEnabled"}
type HostNameSslState_SslState string

const (
	HostNameSslState_SslState_Disabled       = HostNameSslState_SslState("Disabled")
	HostNameSslState_SslState_IpBasedEnabled = HostNameSslState_SslState("IpBasedEnabled")
	HostNameSslState_SslState_SniEnabled     = HostNameSslState_SslState("SniEnabled")
)

// Deprecated version of HostNameSslState_SslState_STATUS. Use v1api20220301.HostNameSslState_SslState_STATUS instead
type HostNameSslState_SslState_STATUS string

const (
	HostNameSslState_SslState_STATUS_Disabled       = HostNameSslState_SslState_STATUS("Disabled")
	HostNameSslState_SslState_STATUS_IpBasedEnabled = HostNameSslState_SslState_STATUS("IpBasedEnabled")
	HostNameSslState_SslState_STATUS_SniEnabled     = HostNameSslState_SslState_STATUS("SniEnabled")
)

// Deprecated version of IpSecurityRestriction. Use v1api20220301.IpSecurityRestriction instead
type IpSecurityRestriction struct {
	Action                      *string                       `json:"action,omitempty"`
	Description                 *string                       `json:"description,omitempty"`
	Headers                     map[string][]string           `json:"headers,omitempty"`
	IpAddress                   *string                       `json:"ipAddress,omitempty"`
	Name                        *string                       `json:"name,omitempty"`
	Priority                    *int                          `json:"priority,omitempty"`
	SubnetMask                  *string                       `json:"subnetMask,omitempty"`
	SubnetTrafficTag            *int                          `json:"subnetTrafficTag,omitempty"`
	Tag                         *IpSecurityRestriction_Tag    `json:"tag,omitempty"`
	VnetSubnetResourceReference *genruntime.ResourceReference `armReference:"VnetSubnetResourceId" json:"vnetSubnetResourceReference,omitempty"`
	VnetTrafficTag              *int                          `json:"vnetTrafficTag,omitempty"`
}

var _ genruntime.ARMTransformer = &IpSecurityRestriction{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (restriction *IpSecurityRestriction) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if restriction == nil {
		return nil, nil
	}
	result := &IpSecurityRestriction_ARM{}

	// Set property "Action":
	if restriction.Action != nil {
		action := *restriction.Action
		result.Action = &action
	}

	// Set property "Description":
	if restriction.Description != nil {
		description := *restriction.Description
		result.Description = &description
	}

	// Set property "Headers":
	if restriction.Headers != nil {
		result.Headers = make(map[string][]string, len(restriction.Headers))
		for key, value := range restriction.Headers {
			var valueTemp []string
			for _, item := range value {
				valueTemp = append(valueTemp, item)
			}
			result.Headers[key] = valueTemp
		}
	}

	// Set property "IpAddress":
	if restriction.IpAddress != nil {
		ipAddress := *restriction.IpAddress
		result.IpAddress = &ipAddress
	}

	// Set property "Name":
	if restriction.Name != nil {
		name := *restriction.Name
		result.Name = &name
	}

	// Set property "Priority":
	if restriction.Priority != nil {
		priority := *restriction.Priority
		result.Priority = &priority
	}

	// Set property "SubnetMask":
	if restriction.SubnetMask != nil {
		subnetMask := *restriction.SubnetMask
		result.SubnetMask = &subnetMask
	}

	// Set property "SubnetTrafficTag":
	if restriction.SubnetTrafficTag != nil {
		subnetTrafficTag := *restriction.SubnetTrafficTag
		result.SubnetTrafficTag = &subnetTrafficTag
	}

	// Set property "Tag":
	if restriction.Tag != nil {
		tag := *restriction.Tag
		result.Tag = &tag
	}

	// Set property "VnetSubnetResourceId":
	if restriction.VnetSubnetResourceReference != nil {
		vnetSubnetResourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*restriction.VnetSubnetResourceReference)
		if err != nil {
			return nil, err
		}
		vnetSubnetResourceReference := vnetSubnetResourceReferenceARMID
		result.VnetSubnetResourceId = &vnetSubnetResourceReference
	}

	// Set property "VnetTrafficTag":
	if restriction.VnetTrafficTag != nil {
		vnetTrafficTag := *restriction.VnetTrafficTag
		result.VnetTrafficTag = &vnetTrafficTag
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (restriction *IpSecurityRestriction) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &IpSecurityRestriction_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (restriction *IpSecurityRestriction) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(IpSecurityRestriction_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected IpSecurityRestriction_ARM, got %T", armInput)
	}

	// Set property "Action":
	if typedInput.Action != nil {
		action := *typedInput.Action
		restriction.Action = &action
	}

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		restriction.Description = &description
	}

	// Set property "Headers":
	if typedInput.Headers != nil {
		restriction.Headers = make(map[string][]string, len(typedInput.Headers))
		for key, value := range typedInput.Headers {
			var valueTemp []string
			for _, item := range value {
				valueTemp = append(valueTemp, item)
			}
			restriction.Headers[key] = valueTemp
		}
	}

	// Set property "IpAddress":
	if typedInput.IpAddress != nil {
		ipAddress := *typedInput.IpAddress
		restriction.IpAddress = &ipAddress
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		restriction.Name = &name
	}

	// Set property "Priority":
	if typedInput.Priority != nil {
		priority := *typedInput.Priority
		restriction.Priority = &priority
	}

	// Set property "SubnetMask":
	if typedInput.SubnetMask != nil {
		subnetMask := *typedInput.SubnetMask
		restriction.SubnetMask = &subnetMask
	}

	// Set property "SubnetTrafficTag":
	if typedInput.SubnetTrafficTag != nil {
		subnetTrafficTag := *typedInput.SubnetTrafficTag
		restriction.SubnetTrafficTag = &subnetTrafficTag
	}

	// Set property "Tag":
	if typedInput.Tag != nil {
		tag := *typedInput.Tag
		restriction.Tag = &tag
	}

	// no assignment for property "VnetSubnetResourceReference"

	// Set property "VnetTrafficTag":
	if typedInput.VnetTrafficTag != nil {
		vnetTrafficTag := *typedInput.VnetTrafficTag
		restriction.VnetTrafficTag = &vnetTrafficTag
	}

	// No error
	return nil
}

// AssignProperties_From_IpSecurityRestriction populates our IpSecurityRestriction from the provided source IpSecurityRestriction
func (restriction *IpSecurityRestriction) AssignProperties_From_IpSecurityRestriction(source *v1beta20220301s.IpSecurityRestriction) error {

	// Action
	restriction.Action = genruntime.ClonePointerToString(source.Action)

	// Description
	restriction.Description = genruntime.ClonePointerToString(source.Description)

	// Headers
	if source.Headers != nil {
		headerMap := make(map[string][]string, len(source.Headers))
		for headerKey, headerValue := range source.Headers {
			// Shadow the loop variable to avoid aliasing
			headerValue := headerValue
			headerMap[headerKey] = genruntime.CloneSliceOfString(headerValue)
		}
		restriction.Headers = headerMap
	} else {
		restriction.Headers = nil
	}

	// IpAddress
	restriction.IpAddress = genruntime.ClonePointerToString(source.IpAddress)

	// Name
	restriction.Name = genruntime.ClonePointerToString(source.Name)

	// Priority
	restriction.Priority = genruntime.ClonePointerToInt(source.Priority)

	// SubnetMask
	restriction.SubnetMask = genruntime.ClonePointerToString(source.SubnetMask)

	// SubnetTrafficTag
	restriction.SubnetTrafficTag = genruntime.ClonePointerToInt(source.SubnetTrafficTag)

	// Tag
	if source.Tag != nil {
		tag := IpSecurityRestriction_Tag(*source.Tag)
		restriction.Tag = &tag
	} else {
		restriction.Tag = nil
	}

	// VnetSubnetResourceReference
	if source.VnetSubnetResourceReference != nil {
		vnetSubnetResourceReference := source.VnetSubnetResourceReference.Copy()
		restriction.VnetSubnetResourceReference = &vnetSubnetResourceReference
	} else {
		restriction.VnetSubnetResourceReference = nil
	}

	// VnetTrafficTag
	restriction.VnetTrafficTag = genruntime.ClonePointerToInt(source.VnetTrafficTag)

	// No error
	return nil
}

// AssignProperties_To_IpSecurityRestriction populates the provided destination IpSecurityRestriction from our IpSecurityRestriction
func (restriction *IpSecurityRestriction) AssignProperties_To_IpSecurityRestriction(destination *v1beta20220301s.IpSecurityRestriction) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Action
	destination.Action = genruntime.ClonePointerToString(restriction.Action)

	// Description
	destination.Description = genruntime.ClonePointerToString(restriction.Description)

	// Headers
	if restriction.Headers != nil {
		headerMap := make(map[string][]string, len(restriction.Headers))
		for headerKey, headerValue := range restriction.Headers {
			// Shadow the loop variable to avoid aliasing
			headerValue := headerValue
			headerMap[headerKey] = genruntime.CloneSliceOfString(headerValue)
		}
		destination.Headers = headerMap
	} else {
		destination.Headers = nil
	}

	// IpAddress
	destination.IpAddress = genruntime.ClonePointerToString(restriction.IpAddress)

	// Name
	destination.Name = genruntime.ClonePointerToString(restriction.Name)

	// Priority
	destination.Priority = genruntime.ClonePointerToInt(restriction.Priority)

	// SubnetMask
	destination.SubnetMask = genruntime.ClonePointerToString(restriction.SubnetMask)

	// SubnetTrafficTag
	destination.SubnetTrafficTag = genruntime.ClonePointerToInt(restriction.SubnetTrafficTag)

	// Tag
	if restriction.Tag != nil {
		tag := string(*restriction.Tag)
		destination.Tag = &tag
	} else {
		destination.Tag = nil
	}

	// VnetSubnetResourceReference
	if restriction.VnetSubnetResourceReference != nil {
		vnetSubnetResourceReference := restriction.VnetSubnetResourceReference.Copy()
		destination.VnetSubnetResourceReference = &vnetSubnetResourceReference
	} else {
		destination.VnetSubnetResourceReference = nil
	}

	// VnetTrafficTag
	destination.VnetTrafficTag = genruntime.ClonePointerToInt(restriction.VnetTrafficTag)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of IpSecurityRestriction_STATUS. Use v1api20220301.IpSecurityRestriction_STATUS instead
type IpSecurityRestriction_STATUS struct {
	Action               *string                           `json:"action,omitempty"`
	Description          *string                           `json:"description,omitempty"`
	Headers              map[string][]string               `json:"headers,omitempty"`
	IpAddress            *string                           `json:"ipAddress,omitempty"`
	Name                 *string                           `json:"name,omitempty"`
	Priority             *int                              `json:"priority,omitempty"`
	SubnetMask           *string                           `json:"subnetMask,omitempty"`
	SubnetTrafficTag     *int                              `json:"subnetTrafficTag,omitempty"`
	Tag                  *IpSecurityRestriction_Tag_STATUS `json:"tag,omitempty"`
	VnetSubnetResourceId *string                           `json:"vnetSubnetResourceId,omitempty"`
	VnetTrafficTag       *int                              `json:"vnetTrafficTag,omitempty"`
}

var _ genruntime.FromARMConverter = &IpSecurityRestriction_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (restriction *IpSecurityRestriction_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &IpSecurityRestriction_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (restriction *IpSecurityRestriction_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(IpSecurityRestriction_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected IpSecurityRestriction_STATUS_ARM, got %T", armInput)
	}

	// Set property "Action":
	if typedInput.Action != nil {
		action := *typedInput.Action
		restriction.Action = &action
	}

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		restriction.Description = &description
	}

	// Set property "Headers":
	if typedInput.Headers != nil {
		restriction.Headers = make(map[string][]string, len(typedInput.Headers))
		for key, value := range typedInput.Headers {
			var valueTemp []string
			for _, item := range value {
				valueTemp = append(valueTemp, item)
			}
			restriction.Headers[key] = valueTemp
		}
	}

	// Set property "IpAddress":
	if typedInput.IpAddress != nil {
		ipAddress := *typedInput.IpAddress
		restriction.IpAddress = &ipAddress
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		restriction.Name = &name
	}

	// Set property "Priority":
	if typedInput.Priority != nil {
		priority := *typedInput.Priority
		restriction.Priority = &priority
	}

	// Set property "SubnetMask":
	if typedInput.SubnetMask != nil {
		subnetMask := *typedInput.SubnetMask
		restriction.SubnetMask = &subnetMask
	}

	// Set property "SubnetTrafficTag":
	if typedInput.SubnetTrafficTag != nil {
		subnetTrafficTag := *typedInput.SubnetTrafficTag
		restriction.SubnetTrafficTag = &subnetTrafficTag
	}

	// Set property "Tag":
	if typedInput.Tag != nil {
		tag := *typedInput.Tag
		restriction.Tag = &tag
	}

	// Set property "VnetSubnetResourceId":
	if typedInput.VnetSubnetResourceId != nil {
		vnetSubnetResourceId := *typedInput.VnetSubnetResourceId
		restriction.VnetSubnetResourceId = &vnetSubnetResourceId
	}

	// Set property "VnetTrafficTag":
	if typedInput.VnetTrafficTag != nil {
		vnetTrafficTag := *typedInput.VnetTrafficTag
		restriction.VnetTrafficTag = &vnetTrafficTag
	}

	// No error
	return nil
}

// AssignProperties_From_IpSecurityRestriction_STATUS populates our IpSecurityRestriction_STATUS from the provided source IpSecurityRestriction_STATUS
func (restriction *IpSecurityRestriction_STATUS) AssignProperties_From_IpSecurityRestriction_STATUS(source *v1beta20220301s.IpSecurityRestriction_STATUS) error {

	// Action
	restriction.Action = genruntime.ClonePointerToString(source.Action)

	// Description
	restriction.Description = genruntime.ClonePointerToString(source.Description)

	// Headers
	if source.Headers != nil {
		headerMap := make(map[string][]string, len(source.Headers))
		for headerKey, headerValue := range source.Headers {
			// Shadow the loop variable to avoid aliasing
			headerValue := headerValue
			headerMap[headerKey] = genruntime.CloneSliceOfString(headerValue)
		}
		restriction.Headers = headerMap
	} else {
		restriction.Headers = nil
	}

	// IpAddress
	restriction.IpAddress = genruntime.ClonePointerToString(source.IpAddress)

	// Name
	restriction.Name = genruntime.ClonePointerToString(source.Name)

	// Priority
	restriction.Priority = genruntime.ClonePointerToInt(source.Priority)

	// SubnetMask
	restriction.SubnetMask = genruntime.ClonePointerToString(source.SubnetMask)

	// SubnetTrafficTag
	restriction.SubnetTrafficTag = genruntime.ClonePointerToInt(source.SubnetTrafficTag)

	// Tag
	if source.Tag != nil {
		tag := IpSecurityRestriction_Tag_STATUS(*source.Tag)
		restriction.Tag = &tag
	} else {
		restriction.Tag = nil
	}

	// VnetSubnetResourceId
	restriction.VnetSubnetResourceId = genruntime.ClonePointerToString(source.VnetSubnetResourceId)

	// VnetTrafficTag
	restriction.VnetTrafficTag = genruntime.ClonePointerToInt(source.VnetTrafficTag)

	// No error
	return nil
}

// AssignProperties_To_IpSecurityRestriction_STATUS populates the provided destination IpSecurityRestriction_STATUS from our IpSecurityRestriction_STATUS
func (restriction *IpSecurityRestriction_STATUS) AssignProperties_To_IpSecurityRestriction_STATUS(destination *v1beta20220301s.IpSecurityRestriction_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Action
	destination.Action = genruntime.ClonePointerToString(restriction.Action)

	// Description
	destination.Description = genruntime.ClonePointerToString(restriction.Description)

	// Headers
	if restriction.Headers != nil {
		headerMap := make(map[string][]string, len(restriction.Headers))
		for headerKey, headerValue := range restriction.Headers {
			// Shadow the loop variable to avoid aliasing
			headerValue := headerValue
			headerMap[headerKey] = genruntime.CloneSliceOfString(headerValue)
		}
		destination.Headers = headerMap
	} else {
		destination.Headers = nil
	}

	// IpAddress
	destination.IpAddress = genruntime.ClonePointerToString(restriction.IpAddress)

	// Name
	destination.Name = genruntime.ClonePointerToString(restriction.Name)

	// Priority
	destination.Priority = genruntime.ClonePointerToInt(restriction.Priority)

	// SubnetMask
	destination.SubnetMask = genruntime.ClonePointerToString(restriction.SubnetMask)

	// SubnetTrafficTag
	destination.SubnetTrafficTag = genruntime.ClonePointerToInt(restriction.SubnetTrafficTag)

	// Tag
	if restriction.Tag != nil {
		tag := string(*restriction.Tag)
		destination.Tag = &tag
	} else {
		destination.Tag = nil
	}

	// VnetSubnetResourceId
	destination.VnetSubnetResourceId = genruntime.ClonePointerToString(restriction.VnetSubnetResourceId)

	// VnetTrafficTag
	destination.VnetTrafficTag = genruntime.ClonePointerToInt(restriction.VnetTrafficTag)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of NameValuePair. Use v1api20220301.NameValuePair instead
type NameValuePair struct {
	Name  *string `json:"name,omitempty"`
	Value *string `json:"value,omitempty"`
}

var _ genruntime.ARMTransformer = &NameValuePair{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (pair *NameValuePair) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if pair == nil {
		return nil, nil
	}
	result := &NameValuePair_ARM{}

	// Set property "Name":
	if pair.Name != nil {
		name := *pair.Name
		result.Name = &name
	}

	// Set property "Value":
	if pair.Value != nil {
		value := *pair.Value
		result.Value = &value
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (pair *NameValuePair) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &NameValuePair_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (pair *NameValuePair) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(NameValuePair_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected NameValuePair_ARM, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		pair.Name = &name
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		pair.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_NameValuePair populates our NameValuePair from the provided source NameValuePair
func (pair *NameValuePair) AssignProperties_From_NameValuePair(source *v1beta20220301s.NameValuePair) error {

	// Name
	pair.Name = genruntime.ClonePointerToString(source.Name)

	// Value
	pair.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_NameValuePair populates the provided destination NameValuePair from our NameValuePair
func (pair *NameValuePair) AssignProperties_To_NameValuePair(destination *v1beta20220301s.NameValuePair) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(pair.Name)

	// Value
	destination.Value = genruntime.ClonePointerToString(pair.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of NameValuePair_STATUS. Use v1api20220301.NameValuePair_STATUS instead
type NameValuePair_STATUS struct {
	Name  *string `json:"name,omitempty"`
	Value *string `json:"value,omitempty"`
}

var _ genruntime.FromARMConverter = &NameValuePair_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (pair *NameValuePair_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &NameValuePair_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (pair *NameValuePair_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(NameValuePair_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected NameValuePair_STATUS_ARM, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		pair.Name = &name
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		pair.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_NameValuePair_STATUS populates our NameValuePair_STATUS from the provided source NameValuePair_STATUS
func (pair *NameValuePair_STATUS) AssignProperties_From_NameValuePair_STATUS(source *v1beta20220301s.NameValuePair_STATUS) error {

	// Name
	pair.Name = genruntime.ClonePointerToString(source.Name)

	// Value
	pair.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_NameValuePair_STATUS populates the provided destination NameValuePair_STATUS from our NameValuePair_STATUS
func (pair *NameValuePair_STATUS) AssignProperties_To_NameValuePair_STATUS(destination *v1beta20220301s.NameValuePair_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(pair.Name)

	// Value
	destination.Value = genruntime.ClonePointerToString(pair.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of PushSettings. Use v1api20220301.PushSettings instead
type PushSettings struct {
	DynamicTagsJson *string `json:"dynamicTagsJson,omitempty"`

	// +kubebuilder:validation:Required
	IsPushEnabled     *bool   `json:"isPushEnabled,omitempty"`
	Kind              *string `json:"kind,omitempty"`
	TagWhitelistJson  *string `json:"tagWhitelistJson,omitempty"`
	TagsRequiringAuth *string `json:"tagsRequiringAuth,omitempty"`
}

var _ genruntime.ARMTransformer = &PushSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *PushSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &PushSettings_ARM{}

	// Set property "Kind":
	if settings.Kind != nil {
		kind := *settings.Kind
		result.Kind = &kind
	}

	// Set property "Properties":
	if settings.DynamicTagsJson != nil ||
		settings.IsPushEnabled != nil ||
		settings.TagWhitelistJson != nil ||
		settings.TagsRequiringAuth != nil {
		result.Properties = &PushSettings_Properties_ARM{}
	}
	if settings.DynamicTagsJson != nil {
		dynamicTagsJson := *settings.DynamicTagsJson
		result.Properties.DynamicTagsJson = &dynamicTagsJson
	}
	if settings.IsPushEnabled != nil {
		isPushEnabled := *settings.IsPushEnabled
		result.Properties.IsPushEnabled = &isPushEnabled
	}
	if settings.TagWhitelistJson != nil {
		tagWhitelistJson := *settings.TagWhitelistJson
		result.Properties.TagWhitelistJson = &tagWhitelistJson
	}
	if settings.TagsRequiringAuth != nil {
		tagsRequiringAuth := *settings.TagsRequiringAuth
		result.Properties.TagsRequiringAuth = &tagsRequiringAuth
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *PushSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &PushSettings_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *PushSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(PushSettings_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PushSettings_ARM, got %T", armInput)
	}

	// Set property "DynamicTagsJson":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DynamicTagsJson != nil {
			dynamicTagsJson := *typedInput.Properties.DynamicTagsJson
			settings.DynamicTagsJson = &dynamicTagsJson
		}
	}

	// Set property "IsPushEnabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IsPushEnabled != nil {
			isPushEnabled := *typedInput.Properties.IsPushEnabled
			settings.IsPushEnabled = &isPushEnabled
		}
	}

	// Set property "Kind":
	if typedInput.Kind != nil {
		kind := *typedInput.Kind
		settings.Kind = &kind
	}

	// Set property "TagWhitelistJson":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TagWhitelistJson != nil {
			tagWhitelistJson := *typedInput.Properties.TagWhitelistJson
			settings.TagWhitelistJson = &tagWhitelistJson
		}
	}

	// Set property "TagsRequiringAuth":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TagsRequiringAuth != nil {
			tagsRequiringAuth := *typedInput.Properties.TagsRequiringAuth
			settings.TagsRequiringAuth = &tagsRequiringAuth
		}
	}

	// No error
	return nil
}

// AssignProperties_From_PushSettings populates our PushSettings from the provided source PushSettings
func (settings *PushSettings) AssignProperties_From_PushSettings(source *v1beta20220301s.PushSettings) error {

	// DynamicTagsJson
	settings.DynamicTagsJson = genruntime.ClonePointerToString(source.DynamicTagsJson)

	// IsPushEnabled
	if source.IsPushEnabled != nil {
		isPushEnabled := *source.IsPushEnabled
		settings.IsPushEnabled = &isPushEnabled
	} else {
		settings.IsPushEnabled = nil
	}

	// Kind
	settings.Kind = genruntime.ClonePointerToString(source.Kind)

	// TagWhitelistJson
	settings.TagWhitelistJson = genruntime.ClonePointerToString(source.TagWhitelistJson)

	// TagsRequiringAuth
	settings.TagsRequiringAuth = genruntime.ClonePointerToString(source.TagsRequiringAuth)

	// No error
	return nil
}

// AssignProperties_To_PushSettings populates the provided destination PushSettings from our PushSettings
func (settings *PushSettings) AssignProperties_To_PushSettings(destination *v1beta20220301s.PushSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DynamicTagsJson
	destination.DynamicTagsJson = genruntime.ClonePointerToString(settings.DynamicTagsJson)

	// IsPushEnabled
	if settings.IsPushEnabled != nil {
		isPushEnabled := *settings.IsPushEnabled
		destination.IsPushEnabled = &isPushEnabled
	} else {
		destination.IsPushEnabled = nil
	}

	// Kind
	destination.Kind = genruntime.ClonePointerToString(settings.Kind)

	// TagWhitelistJson
	destination.TagWhitelistJson = genruntime.ClonePointerToString(settings.TagWhitelistJson)

	// TagsRequiringAuth
	destination.TagsRequiringAuth = genruntime.ClonePointerToString(settings.TagsRequiringAuth)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of PushSettings_STATUS. Use v1api20220301.PushSettings_STATUS instead
type PushSettings_STATUS struct {
	DynamicTagsJson   *string `json:"dynamicTagsJson,omitempty"`
	Id                *string `json:"id,omitempty"`
	IsPushEnabled     *bool   `json:"isPushEnabled,omitempty"`
	Kind              *string `json:"kind,omitempty"`
	Name              *string `json:"name,omitempty"`
	TagWhitelistJson  *string `json:"tagWhitelistJson,omitempty"`
	TagsRequiringAuth *string `json:"tagsRequiringAuth,omitempty"`
	Type              *string `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &PushSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *PushSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &PushSettings_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *PushSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(PushSettings_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PushSettings_STATUS_ARM, got %T", armInput)
	}

	// Set property "DynamicTagsJson":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DynamicTagsJson != nil {
			dynamicTagsJson := *typedInput.Properties.DynamicTagsJson
			settings.DynamicTagsJson = &dynamicTagsJson
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		settings.Id = &id
	}

	// Set property "IsPushEnabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IsPushEnabled != nil {
			isPushEnabled := *typedInput.Properties.IsPushEnabled
			settings.IsPushEnabled = &isPushEnabled
		}
	}

	// Set property "Kind":
	if typedInput.Kind != nil {
		kind := *typedInput.Kind
		settings.Kind = &kind
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		settings.Name = &name
	}

	// Set property "TagWhitelistJson":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TagWhitelistJson != nil {
			tagWhitelistJson := *typedInput.Properties.TagWhitelistJson
			settings.TagWhitelistJson = &tagWhitelistJson
		}
	}

	// Set property "TagsRequiringAuth":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TagsRequiringAuth != nil {
			tagsRequiringAuth := *typedInput.Properties.TagsRequiringAuth
			settings.TagsRequiringAuth = &tagsRequiringAuth
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		settings.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_PushSettings_STATUS populates our PushSettings_STATUS from the provided source PushSettings_STATUS
func (settings *PushSettings_STATUS) AssignProperties_From_PushSettings_STATUS(source *v1beta20220301s.PushSettings_STATUS) error {

	// DynamicTagsJson
	settings.DynamicTagsJson = genruntime.ClonePointerToString(source.DynamicTagsJson)

	// Id
	settings.Id = genruntime.ClonePointerToString(source.Id)

	// IsPushEnabled
	if source.IsPushEnabled != nil {
		isPushEnabled := *source.IsPushEnabled
		settings.IsPushEnabled = &isPushEnabled
	} else {
		settings.IsPushEnabled = nil
	}

	// Kind
	settings.Kind = genruntime.ClonePointerToString(source.Kind)

	// Name
	settings.Name = genruntime.ClonePointerToString(source.Name)

	// TagWhitelistJson
	settings.TagWhitelistJson = genruntime.ClonePointerToString(source.TagWhitelistJson)

	// TagsRequiringAuth
	settings.TagsRequiringAuth = genruntime.ClonePointerToString(source.TagsRequiringAuth)

	// Type
	settings.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_PushSettings_STATUS populates the provided destination PushSettings_STATUS from our PushSettings_STATUS
func (settings *PushSettings_STATUS) AssignProperties_To_PushSettings_STATUS(destination *v1beta20220301s.PushSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DynamicTagsJson
	destination.DynamicTagsJson = genruntime.ClonePointerToString(settings.DynamicTagsJson)

	// Id
	destination.Id = genruntime.ClonePointerToString(settings.Id)

	// IsPushEnabled
	if settings.IsPushEnabled != nil {
		isPushEnabled := *settings.IsPushEnabled
		destination.IsPushEnabled = &isPushEnabled
	} else {
		destination.IsPushEnabled = nil
	}

	// Kind
	destination.Kind = genruntime.ClonePointerToString(settings.Kind)

	// Name
	destination.Name = genruntime.ClonePointerToString(settings.Name)

	// TagWhitelistJson
	destination.TagWhitelistJson = genruntime.ClonePointerToString(settings.TagWhitelistJson)

	// TagsRequiringAuth
	destination.TagsRequiringAuth = genruntime.ClonePointerToString(settings.TagsRequiringAuth)

	// Type
	destination.Type = genruntime.ClonePointerToString(settings.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of SiteConfig_FtpsState. Use v1api20220301.SiteConfig_FtpsState instead
// +kubebuilder:validation:Enum={"AllAllowed","Disabled","FtpsOnly"}
type SiteConfig_FtpsState string

const (
	SiteConfig_FtpsState_AllAllowed = SiteConfig_FtpsState("AllAllowed")
	SiteConfig_FtpsState_Disabled   = SiteConfig_FtpsState("Disabled")
	SiteConfig_FtpsState_FtpsOnly   = SiteConfig_FtpsState("FtpsOnly")
)

// Deprecated version of SiteConfig_FtpsState_STATUS. Use v1api20220301.SiteConfig_FtpsState_STATUS instead
type SiteConfig_FtpsState_STATUS string

const (
	SiteConfig_FtpsState_STATUS_AllAllowed = SiteConfig_FtpsState_STATUS("AllAllowed")
	SiteConfig_FtpsState_STATUS_Disabled   = SiteConfig_FtpsState_STATUS("Disabled")
	SiteConfig_FtpsState_STATUS_FtpsOnly   = SiteConfig_FtpsState_STATUS("FtpsOnly")
)

// Deprecated version of SiteConfig_LoadBalancing. Use v1api20220301.SiteConfig_LoadBalancing instead
// +kubebuilder:validation:Enum={"LeastRequests","LeastResponseTime","PerSiteRoundRobin","RequestHash","WeightedRoundRobin","WeightedTotalTraffic"}
type SiteConfig_LoadBalancing string

const (
	SiteConfig_LoadBalancing_LeastRequests        = SiteConfig_LoadBalancing("LeastRequests")
	SiteConfig_LoadBalancing_LeastResponseTime    = SiteConfig_LoadBalancing("LeastResponseTime")
	SiteConfig_LoadBalancing_PerSiteRoundRobin    = SiteConfig_LoadBalancing("PerSiteRoundRobin")
	SiteConfig_LoadBalancing_RequestHash          = SiteConfig_LoadBalancing("RequestHash")
	SiteConfig_LoadBalancing_WeightedRoundRobin   = SiteConfig_LoadBalancing("WeightedRoundRobin")
	SiteConfig_LoadBalancing_WeightedTotalTraffic = SiteConfig_LoadBalancing("WeightedTotalTraffic")
)

// Deprecated version of SiteConfig_LoadBalancing_STATUS. Use v1api20220301.SiteConfig_LoadBalancing_STATUS instead
type SiteConfig_LoadBalancing_STATUS string

const (
	SiteConfig_LoadBalancing_STATUS_LeastRequests        = SiteConfig_LoadBalancing_STATUS("LeastRequests")
	SiteConfig_LoadBalancing_STATUS_LeastResponseTime    = SiteConfig_LoadBalancing_STATUS("LeastResponseTime")
	SiteConfig_LoadBalancing_STATUS_PerSiteRoundRobin    = SiteConfig_LoadBalancing_STATUS("PerSiteRoundRobin")
	SiteConfig_LoadBalancing_STATUS_RequestHash          = SiteConfig_LoadBalancing_STATUS("RequestHash")
	SiteConfig_LoadBalancing_STATUS_WeightedRoundRobin   = SiteConfig_LoadBalancing_STATUS("WeightedRoundRobin")
	SiteConfig_LoadBalancing_STATUS_WeightedTotalTraffic = SiteConfig_LoadBalancing_STATUS("WeightedTotalTraffic")
)

// Deprecated version of SiteConfig_ManagedPipelineMode. Use v1api20220301.SiteConfig_ManagedPipelineMode instead
// +kubebuilder:validation:Enum={"Classic","Integrated"}
type SiteConfig_ManagedPipelineMode string

const (
	SiteConfig_ManagedPipelineMode_Classic    = SiteConfig_ManagedPipelineMode("Classic")
	SiteConfig_ManagedPipelineMode_Integrated = SiteConfig_ManagedPipelineMode("Integrated")
)

// Deprecated version of SiteConfig_ManagedPipelineMode_STATUS. Use v1api20220301.SiteConfig_ManagedPipelineMode_STATUS
// instead
type SiteConfig_ManagedPipelineMode_STATUS string

const (
	SiteConfig_ManagedPipelineMode_STATUS_Classic    = SiteConfig_ManagedPipelineMode_STATUS("Classic")
	SiteConfig_ManagedPipelineMode_STATUS_Integrated = SiteConfig_ManagedPipelineMode_STATUS("Integrated")
)

// Deprecated version of SiteConfig_MinTlsVersion. Use v1api20220301.SiteConfig_MinTlsVersion instead
// +kubebuilder:validation:Enum={"1.0","1.1","1.2"}
type SiteConfig_MinTlsVersion string

const (
	SiteConfig_MinTlsVersion_10 = SiteConfig_MinTlsVersion("1.0")
	SiteConfig_MinTlsVersion_11 = SiteConfig_MinTlsVersion("1.1")
	SiteConfig_MinTlsVersion_12 = SiteConfig_MinTlsVersion("1.2")
)

// Deprecated version of SiteConfig_MinTlsVersion_STATUS. Use v1api20220301.SiteConfig_MinTlsVersion_STATUS instead
type SiteConfig_MinTlsVersion_STATUS string

const (
	SiteConfig_MinTlsVersion_STATUS_10 = SiteConfig_MinTlsVersion_STATUS("1.0")
	SiteConfig_MinTlsVersion_STATUS_11 = SiteConfig_MinTlsVersion_STATUS("1.1")
	SiteConfig_MinTlsVersion_STATUS_12 = SiteConfig_MinTlsVersion_STATUS("1.2")
)

// Deprecated version of SiteConfig_ScmMinTlsVersion. Use v1api20220301.SiteConfig_ScmMinTlsVersion instead
// +kubebuilder:validation:Enum={"1.0","1.1","1.2"}
type SiteConfig_ScmMinTlsVersion string

const (
	SiteConfig_ScmMinTlsVersion_10 = SiteConfig_ScmMinTlsVersion("1.0")
	SiteConfig_ScmMinTlsVersion_11 = SiteConfig_ScmMinTlsVersion("1.1")
	SiteConfig_ScmMinTlsVersion_12 = SiteConfig_ScmMinTlsVersion("1.2")
)

// Deprecated version of SiteConfig_ScmMinTlsVersion_STATUS. Use v1api20220301.SiteConfig_ScmMinTlsVersion_STATUS instead
type SiteConfig_ScmMinTlsVersion_STATUS string

const (
	SiteConfig_ScmMinTlsVersion_STATUS_10 = SiteConfig_ScmMinTlsVersion_STATUS("1.0")
	SiteConfig_ScmMinTlsVersion_STATUS_11 = SiteConfig_ScmMinTlsVersion_STATUS("1.1")
	SiteConfig_ScmMinTlsVersion_STATUS_12 = SiteConfig_ScmMinTlsVersion_STATUS("1.2")
)

// Deprecated version of SiteConfig_ScmType. Use v1api20220301.SiteConfig_ScmType instead
// +kubebuilder:validation:Enum={"BitbucketGit","BitbucketHg","CodePlexGit","CodePlexHg","Dropbox","ExternalGit","ExternalHg","GitHub","LocalGit","None","OneDrive","Tfs","VSO","VSTSRM"}
type SiteConfig_ScmType string

const (
	SiteConfig_ScmType_BitbucketGit = SiteConfig_ScmType("BitbucketGit")
	SiteConfig_ScmType_BitbucketHg  = SiteConfig_ScmType("BitbucketHg")
	SiteConfig_ScmType_CodePlexGit  = SiteConfig_ScmType("CodePlexGit")
	SiteConfig_ScmType_CodePlexHg   = SiteConfig_ScmType("CodePlexHg")
	SiteConfig_ScmType_Dropbox      = SiteConfig_ScmType("Dropbox")
	SiteConfig_ScmType_ExternalGit  = SiteConfig_ScmType("ExternalGit")
	SiteConfig_ScmType_ExternalHg   = SiteConfig_ScmType("ExternalHg")
	SiteConfig_ScmType_GitHub       = SiteConfig_ScmType("GitHub")
	SiteConfig_ScmType_LocalGit     = SiteConfig_ScmType("LocalGit")
	SiteConfig_ScmType_None         = SiteConfig_ScmType("None")
	SiteConfig_ScmType_OneDrive     = SiteConfig_ScmType("OneDrive")
	SiteConfig_ScmType_Tfs          = SiteConfig_ScmType("Tfs")
	SiteConfig_ScmType_VSO          = SiteConfig_ScmType("VSO")
	SiteConfig_ScmType_VSTSRM       = SiteConfig_ScmType("VSTSRM")
)

// Deprecated version of SiteConfig_ScmType_STATUS. Use v1api20220301.SiteConfig_ScmType_STATUS instead
type SiteConfig_ScmType_STATUS string

const (
	SiteConfig_ScmType_STATUS_BitbucketGit = SiteConfig_ScmType_STATUS("BitbucketGit")
	SiteConfig_ScmType_STATUS_BitbucketHg  = SiteConfig_ScmType_STATUS("BitbucketHg")
	SiteConfig_ScmType_STATUS_CodePlexGit  = SiteConfig_ScmType_STATUS("CodePlexGit")
	SiteConfig_ScmType_STATUS_CodePlexHg   = SiteConfig_ScmType_STATUS("CodePlexHg")
	SiteConfig_ScmType_STATUS_Dropbox      = SiteConfig_ScmType_STATUS("Dropbox")
	SiteConfig_ScmType_STATUS_ExternalGit  = SiteConfig_ScmType_STATUS("ExternalGit")
	SiteConfig_ScmType_STATUS_ExternalHg   = SiteConfig_ScmType_STATUS("ExternalHg")
	SiteConfig_ScmType_STATUS_GitHub       = SiteConfig_ScmType_STATUS("GitHub")
	SiteConfig_ScmType_STATUS_LocalGit     = SiteConfig_ScmType_STATUS("LocalGit")
	SiteConfig_ScmType_STATUS_None         = SiteConfig_ScmType_STATUS("None")
	SiteConfig_ScmType_STATUS_OneDrive     = SiteConfig_ScmType_STATUS("OneDrive")
	SiteConfig_ScmType_STATUS_Tfs          = SiteConfig_ScmType_STATUS("Tfs")
	SiteConfig_ScmType_STATUS_VSO          = SiteConfig_ScmType_STATUS("VSO")
	SiteConfig_ScmType_STATUS_VSTSRM       = SiteConfig_ScmType_STATUS("VSTSRM")
)

// Deprecated version of SiteLimits. Use v1api20220301.SiteLimits instead
type SiteLimits struct {
	MaxDiskSizeInMb  *int     `json:"maxDiskSizeInMb,omitempty"`
	MaxMemoryInMb    *int     `json:"maxMemoryInMb,omitempty"`
	MaxPercentageCpu *float64 `json:"maxPercentageCpu,omitempty"`
}

var _ genruntime.ARMTransformer = &SiteLimits{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (limits *SiteLimits) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if limits == nil {
		return nil, nil
	}
	result := &SiteLimits_ARM{}

	// Set property "MaxDiskSizeInMb":
	if limits.MaxDiskSizeInMb != nil {
		maxDiskSizeInMb := *limits.MaxDiskSizeInMb
		result.MaxDiskSizeInMb = &maxDiskSizeInMb
	}

	// Set property "MaxMemoryInMb":
	if limits.MaxMemoryInMb != nil {
		maxMemoryInMb := *limits.MaxMemoryInMb
		result.MaxMemoryInMb = &maxMemoryInMb
	}

	// Set property "MaxPercentageCpu":
	if limits.MaxPercentageCpu != nil {
		maxPercentageCpu := *limits.MaxPercentageCpu
		result.MaxPercentageCpu = &maxPercentageCpu
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (limits *SiteLimits) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SiteLimits_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (limits *SiteLimits) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SiteLimits_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SiteLimits_ARM, got %T", armInput)
	}

	// Set property "MaxDiskSizeInMb":
	if typedInput.MaxDiskSizeInMb != nil {
		maxDiskSizeInMb := *typedInput.MaxDiskSizeInMb
		limits.MaxDiskSizeInMb = &maxDiskSizeInMb
	}

	// Set property "MaxMemoryInMb":
	if typedInput.MaxMemoryInMb != nil {
		maxMemoryInMb := *typedInput.MaxMemoryInMb
		limits.MaxMemoryInMb = &maxMemoryInMb
	}

	// Set property "MaxPercentageCpu":
	if typedInput.MaxPercentageCpu != nil {
		maxPercentageCpu := *typedInput.MaxPercentageCpu
		limits.MaxPercentageCpu = &maxPercentageCpu
	}

	// No error
	return nil
}

// AssignProperties_From_SiteLimits populates our SiteLimits from the provided source SiteLimits
func (limits *SiteLimits) AssignProperties_From_SiteLimits(source *v1beta20220301s.SiteLimits) error {

	// MaxDiskSizeInMb
	limits.MaxDiskSizeInMb = genruntime.ClonePointerToInt(source.MaxDiskSizeInMb)

	// MaxMemoryInMb
	limits.MaxMemoryInMb = genruntime.ClonePointerToInt(source.MaxMemoryInMb)

	// MaxPercentageCpu
	if source.MaxPercentageCpu != nil {
		maxPercentageCpu := *source.MaxPercentageCpu
		limits.MaxPercentageCpu = &maxPercentageCpu
	} else {
		limits.MaxPercentageCpu = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SiteLimits populates the provided destination SiteLimits from our SiteLimits
func (limits *SiteLimits) AssignProperties_To_SiteLimits(destination *v1beta20220301s.SiteLimits) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MaxDiskSizeInMb
	destination.MaxDiskSizeInMb = genruntime.ClonePointerToInt(limits.MaxDiskSizeInMb)

	// MaxMemoryInMb
	destination.MaxMemoryInMb = genruntime.ClonePointerToInt(limits.MaxMemoryInMb)

	// MaxPercentageCpu
	if limits.MaxPercentageCpu != nil {
		maxPercentageCpu := *limits.MaxPercentageCpu
		destination.MaxPercentageCpu = &maxPercentageCpu
	} else {
		destination.MaxPercentageCpu = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of SiteLimits_STATUS. Use v1api20220301.SiteLimits_STATUS instead
type SiteLimits_STATUS struct {
	MaxDiskSizeInMb  *int     `json:"maxDiskSizeInMb,omitempty"`
	MaxMemoryInMb    *int     `json:"maxMemoryInMb,omitempty"`
	MaxPercentageCpu *float64 `json:"maxPercentageCpu,omitempty"`
}

var _ genruntime.FromARMConverter = &SiteLimits_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (limits *SiteLimits_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SiteLimits_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (limits *SiteLimits_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SiteLimits_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SiteLimits_STATUS_ARM, got %T", armInput)
	}

	// Set property "MaxDiskSizeInMb":
	if typedInput.MaxDiskSizeInMb != nil {
		maxDiskSizeInMb := *typedInput.MaxDiskSizeInMb
		limits.MaxDiskSizeInMb = &maxDiskSizeInMb
	}

	// Set property "MaxMemoryInMb":
	if typedInput.MaxMemoryInMb != nil {
		maxMemoryInMb := *typedInput.MaxMemoryInMb
		limits.MaxMemoryInMb = &maxMemoryInMb
	}

	// Set property "MaxPercentageCpu":
	if typedInput.MaxPercentageCpu != nil {
		maxPercentageCpu := *typedInput.MaxPercentageCpu
		limits.MaxPercentageCpu = &maxPercentageCpu
	}

	// No error
	return nil
}

// AssignProperties_From_SiteLimits_STATUS populates our SiteLimits_STATUS from the provided source SiteLimits_STATUS
func (limits *SiteLimits_STATUS) AssignProperties_From_SiteLimits_STATUS(source *v1beta20220301s.SiteLimits_STATUS) error {

	// MaxDiskSizeInMb
	limits.MaxDiskSizeInMb = genruntime.ClonePointerToInt(source.MaxDiskSizeInMb)

	// MaxMemoryInMb
	limits.MaxMemoryInMb = genruntime.ClonePointerToInt(source.MaxMemoryInMb)

	// MaxPercentageCpu
	if source.MaxPercentageCpu != nil {
		maxPercentageCpu := *source.MaxPercentageCpu
		limits.MaxPercentageCpu = &maxPercentageCpu
	} else {
		limits.MaxPercentageCpu = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SiteLimits_STATUS populates the provided destination SiteLimits_STATUS from our SiteLimits_STATUS
func (limits *SiteLimits_STATUS) AssignProperties_To_SiteLimits_STATUS(destination *v1beta20220301s.SiteLimits_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MaxDiskSizeInMb
	destination.MaxDiskSizeInMb = genruntime.ClonePointerToInt(limits.MaxDiskSizeInMb)

	// MaxMemoryInMb
	destination.MaxMemoryInMb = genruntime.ClonePointerToInt(limits.MaxMemoryInMb)

	// MaxPercentageCpu
	if limits.MaxPercentageCpu != nil {
		maxPercentageCpu := *limits.MaxPercentageCpu
		destination.MaxPercentageCpu = &maxPercentageCpu
	} else {
		destination.MaxPercentageCpu = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of SiteMachineKey_STATUS. Use v1api20220301.SiteMachineKey_STATUS instead
type SiteMachineKey_STATUS struct {
	Decryption    *string `json:"decryption,omitempty"`
	DecryptionKey *string `json:"decryptionKey,omitempty"`
	Validation    *string `json:"validation,omitempty"`
	ValidationKey *string `json:"validationKey,omitempty"`
}

var _ genruntime.FromARMConverter = &SiteMachineKey_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (machineKey *SiteMachineKey_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SiteMachineKey_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (machineKey *SiteMachineKey_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SiteMachineKey_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SiteMachineKey_STATUS_ARM, got %T", armInput)
	}

	// Set property "Decryption":
	if typedInput.Decryption != nil {
		decryption := *typedInput.Decryption
		machineKey.Decryption = &decryption
	}

	// Set property "DecryptionKey":
	if typedInput.DecryptionKey != nil {
		decryptionKey := *typedInput.DecryptionKey
		machineKey.DecryptionKey = &decryptionKey
	}

	// Set property "Validation":
	if typedInput.Validation != nil {
		validation := *typedInput.Validation
		machineKey.Validation = &validation
	}

	// Set property "ValidationKey":
	if typedInput.ValidationKey != nil {
		validationKey := *typedInput.ValidationKey
		machineKey.ValidationKey = &validationKey
	}

	// No error
	return nil
}

// AssignProperties_From_SiteMachineKey_STATUS populates our SiteMachineKey_STATUS from the provided source SiteMachineKey_STATUS
func (machineKey *SiteMachineKey_STATUS) AssignProperties_From_SiteMachineKey_STATUS(source *v1beta20220301s.SiteMachineKey_STATUS) error {

	// Decryption
	machineKey.Decryption = genruntime.ClonePointerToString(source.Decryption)

	// DecryptionKey
	machineKey.DecryptionKey = genruntime.ClonePointerToString(source.DecryptionKey)

	// Validation
	machineKey.Validation = genruntime.ClonePointerToString(source.Validation)

	// ValidationKey
	machineKey.ValidationKey = genruntime.ClonePointerToString(source.ValidationKey)

	// No error
	return nil
}

// AssignProperties_To_SiteMachineKey_STATUS populates the provided destination SiteMachineKey_STATUS from our SiteMachineKey_STATUS
func (machineKey *SiteMachineKey_STATUS) AssignProperties_To_SiteMachineKey_STATUS(destination *v1beta20220301s.SiteMachineKey_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Decryption
	destination.Decryption = genruntime.ClonePointerToString(machineKey.Decryption)

	// DecryptionKey
	destination.DecryptionKey = genruntime.ClonePointerToString(machineKey.DecryptionKey)

	// Validation
	destination.Validation = genruntime.ClonePointerToString(machineKey.Validation)

	// ValidationKey
	destination.ValidationKey = genruntime.ClonePointerToString(machineKey.ValidationKey)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of UserAssignedIdentity_STATUS. Use v1api20220301.UserAssignedIdentity_STATUS instead
type UserAssignedIdentity_STATUS struct {
	ClientId    *string `json:"clientId,omitempty"`
	PrincipalId *string `json:"principalId,omitempty"`
}

var _ genruntime.FromARMConverter = &UserAssignedIdentity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *UserAssignedIdentity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &UserAssignedIdentity_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *UserAssignedIdentity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(UserAssignedIdentity_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected UserAssignedIdentity_STATUS_ARM, got %T", armInput)
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		identity.ClientId = &clientId
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identity.PrincipalId = &principalId
	}

	// No error
	return nil
}

// AssignProperties_From_UserAssignedIdentity_STATUS populates our UserAssignedIdentity_STATUS from the provided source UserAssignedIdentity_STATUS
func (identity *UserAssignedIdentity_STATUS) AssignProperties_From_UserAssignedIdentity_STATUS(source *v1beta20220301s.UserAssignedIdentity_STATUS) error {

	// ClientId
	identity.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// No error
	return nil
}

// AssignProperties_To_UserAssignedIdentity_STATUS populates the provided destination UserAssignedIdentity_STATUS from our UserAssignedIdentity_STATUS
func (identity *UserAssignedIdentity_STATUS) AssignProperties_To_UserAssignedIdentity_STATUS(destination *v1beta20220301s.UserAssignedIdentity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(identity.ClientId)

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of UserAssignedIdentityDetails. Use v1api20220301.UserAssignedIdentityDetails instead
type UserAssignedIdentityDetails struct {
	Reference genruntime.ResourceReference `armReference:"Reference" json:"reference,omitempty"`
}

// AssignProperties_From_UserAssignedIdentityDetails populates our UserAssignedIdentityDetails from the provided source UserAssignedIdentityDetails
func (details *UserAssignedIdentityDetails) AssignProperties_From_UserAssignedIdentityDetails(source *v1beta20220301s.UserAssignedIdentityDetails) error {

	// Reference
	details.Reference = source.Reference.Copy()

	// No error
	return nil
}

// AssignProperties_To_UserAssignedIdentityDetails populates the provided destination UserAssignedIdentityDetails from our UserAssignedIdentityDetails
func (details *UserAssignedIdentityDetails) AssignProperties_To_UserAssignedIdentityDetails(destination *v1beta20220301s.UserAssignedIdentityDetails) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	destination.Reference = details.Reference.Copy()

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VirtualApplication. Use v1api20220301.VirtualApplication instead
type VirtualApplication struct {
	PhysicalPath       *string            `json:"physicalPath,omitempty"`
	PreloadEnabled     *bool              `json:"preloadEnabled,omitempty"`
	VirtualDirectories []VirtualDirectory `json:"virtualDirectories,omitempty"`
	VirtualPath        *string            `json:"virtualPath,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualApplication{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (application *VirtualApplication) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if application == nil {
		return nil, nil
	}
	result := &VirtualApplication_ARM{}

	// Set property "PhysicalPath":
	if application.PhysicalPath != nil {
		physicalPath := *application.PhysicalPath
		result.PhysicalPath = &physicalPath
	}

	// Set property "PreloadEnabled":
	if application.PreloadEnabled != nil {
		preloadEnabled := *application.PreloadEnabled
		result.PreloadEnabled = &preloadEnabled
	}

	// Set property "VirtualDirectories":
	for _, item := range application.VirtualDirectories {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.VirtualDirectories = append(result.VirtualDirectories, *item_ARM.(*VirtualDirectory_ARM))
	}

	// Set property "VirtualPath":
	if application.VirtualPath != nil {
		virtualPath := *application.VirtualPath
		result.VirtualPath = &virtualPath
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (application *VirtualApplication) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualApplication_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (application *VirtualApplication) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualApplication_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualApplication_ARM, got %T", armInput)
	}

	// Set property "PhysicalPath":
	if typedInput.PhysicalPath != nil {
		physicalPath := *typedInput.PhysicalPath
		application.PhysicalPath = &physicalPath
	}

	// Set property "PreloadEnabled":
	if typedInput.PreloadEnabled != nil {
		preloadEnabled := *typedInput.PreloadEnabled
		application.PreloadEnabled = &preloadEnabled
	}

	// Set property "VirtualDirectories":
	for _, item := range typedInput.VirtualDirectories {
		var item1 VirtualDirectory
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		application.VirtualDirectories = append(application.VirtualDirectories, item1)
	}

	// Set property "VirtualPath":
	if typedInput.VirtualPath != nil {
		virtualPath := *typedInput.VirtualPath
		application.VirtualPath = &virtualPath
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualApplication populates our VirtualApplication from the provided source VirtualApplication
func (application *VirtualApplication) AssignProperties_From_VirtualApplication(source *v1beta20220301s.VirtualApplication) error {

	// PhysicalPath
	application.PhysicalPath = genruntime.ClonePointerToString(source.PhysicalPath)

	// PreloadEnabled
	if source.PreloadEnabled != nil {
		preloadEnabled := *source.PreloadEnabled
		application.PreloadEnabled = &preloadEnabled
	} else {
		application.PreloadEnabled = nil
	}

	// VirtualDirectories
	if source.VirtualDirectories != nil {
		virtualDirectoryList := make([]VirtualDirectory, len(source.VirtualDirectories))
		for virtualDirectoryIndex, virtualDirectoryItem := range source.VirtualDirectories {
			// Shadow the loop variable to avoid aliasing
			virtualDirectoryItem := virtualDirectoryItem
			var virtualDirectory VirtualDirectory
			err := virtualDirectory.AssignProperties_From_VirtualDirectory(&virtualDirectoryItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VirtualDirectory() to populate field VirtualDirectories")
			}
			virtualDirectoryList[virtualDirectoryIndex] = virtualDirectory
		}
		application.VirtualDirectories = virtualDirectoryList
	} else {
		application.VirtualDirectories = nil
	}

	// VirtualPath
	application.VirtualPath = genruntime.ClonePointerToString(source.VirtualPath)

	// No error
	return nil
}

// AssignProperties_To_VirtualApplication populates the provided destination VirtualApplication from our VirtualApplication
func (application *VirtualApplication) AssignProperties_To_VirtualApplication(destination *v1beta20220301s.VirtualApplication) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PhysicalPath
	destination.PhysicalPath = genruntime.ClonePointerToString(application.PhysicalPath)

	// PreloadEnabled
	if application.PreloadEnabled != nil {
		preloadEnabled := *application.PreloadEnabled
		destination.PreloadEnabled = &preloadEnabled
	} else {
		destination.PreloadEnabled = nil
	}

	// VirtualDirectories
	if application.VirtualDirectories != nil {
		virtualDirectoryList := make([]v1beta20220301s.VirtualDirectory, len(application.VirtualDirectories))
		for virtualDirectoryIndex, virtualDirectoryItem := range application.VirtualDirectories {
			// Shadow the loop variable to avoid aliasing
			virtualDirectoryItem := virtualDirectoryItem
			var virtualDirectory v1beta20220301s.VirtualDirectory
			err := virtualDirectoryItem.AssignProperties_To_VirtualDirectory(&virtualDirectory)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VirtualDirectory() to populate field VirtualDirectories")
			}
			virtualDirectoryList[virtualDirectoryIndex] = virtualDirectory
		}
		destination.VirtualDirectories = virtualDirectoryList
	} else {
		destination.VirtualDirectories = nil
	}

	// VirtualPath
	destination.VirtualPath = genruntime.ClonePointerToString(application.VirtualPath)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VirtualApplication_STATUS. Use v1api20220301.VirtualApplication_STATUS instead
type VirtualApplication_STATUS struct {
	PhysicalPath       *string                   `json:"physicalPath,omitempty"`
	PreloadEnabled     *bool                     `json:"preloadEnabled,omitempty"`
	VirtualDirectories []VirtualDirectory_STATUS `json:"virtualDirectories,omitempty"`
	VirtualPath        *string                   `json:"virtualPath,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualApplication_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (application *VirtualApplication_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualApplication_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (application *VirtualApplication_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualApplication_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualApplication_STATUS_ARM, got %T", armInput)
	}

	// Set property "PhysicalPath":
	if typedInput.PhysicalPath != nil {
		physicalPath := *typedInput.PhysicalPath
		application.PhysicalPath = &physicalPath
	}

	// Set property "PreloadEnabled":
	if typedInput.PreloadEnabled != nil {
		preloadEnabled := *typedInput.PreloadEnabled
		application.PreloadEnabled = &preloadEnabled
	}

	// Set property "VirtualDirectories":
	for _, item := range typedInput.VirtualDirectories {
		var item1 VirtualDirectory_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		application.VirtualDirectories = append(application.VirtualDirectories, item1)
	}

	// Set property "VirtualPath":
	if typedInput.VirtualPath != nil {
		virtualPath := *typedInput.VirtualPath
		application.VirtualPath = &virtualPath
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualApplication_STATUS populates our VirtualApplication_STATUS from the provided source VirtualApplication_STATUS
func (application *VirtualApplication_STATUS) AssignProperties_From_VirtualApplication_STATUS(source *v1beta20220301s.VirtualApplication_STATUS) error {

	// PhysicalPath
	application.PhysicalPath = genruntime.ClonePointerToString(source.PhysicalPath)

	// PreloadEnabled
	if source.PreloadEnabled != nil {
		preloadEnabled := *source.PreloadEnabled
		application.PreloadEnabled = &preloadEnabled
	} else {
		application.PreloadEnabled = nil
	}

	// VirtualDirectories
	if source.VirtualDirectories != nil {
		virtualDirectoryList := make([]VirtualDirectory_STATUS, len(source.VirtualDirectories))
		for virtualDirectoryIndex, virtualDirectoryItem := range source.VirtualDirectories {
			// Shadow the loop variable to avoid aliasing
			virtualDirectoryItem := virtualDirectoryItem
			var virtualDirectory VirtualDirectory_STATUS
			err := virtualDirectory.AssignProperties_From_VirtualDirectory_STATUS(&virtualDirectoryItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VirtualDirectory_STATUS() to populate field VirtualDirectories")
			}
			virtualDirectoryList[virtualDirectoryIndex] = virtualDirectory
		}
		application.VirtualDirectories = virtualDirectoryList
	} else {
		application.VirtualDirectories = nil
	}

	// VirtualPath
	application.VirtualPath = genruntime.ClonePointerToString(source.VirtualPath)

	// No error
	return nil
}

// AssignProperties_To_VirtualApplication_STATUS populates the provided destination VirtualApplication_STATUS from our VirtualApplication_STATUS
func (application *VirtualApplication_STATUS) AssignProperties_To_VirtualApplication_STATUS(destination *v1beta20220301s.VirtualApplication_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PhysicalPath
	destination.PhysicalPath = genruntime.ClonePointerToString(application.PhysicalPath)

	// PreloadEnabled
	if application.PreloadEnabled != nil {
		preloadEnabled := *application.PreloadEnabled
		destination.PreloadEnabled = &preloadEnabled
	} else {
		destination.PreloadEnabled = nil
	}

	// VirtualDirectories
	if application.VirtualDirectories != nil {
		virtualDirectoryList := make([]v1beta20220301s.VirtualDirectory_STATUS, len(application.VirtualDirectories))
		for virtualDirectoryIndex, virtualDirectoryItem := range application.VirtualDirectories {
			// Shadow the loop variable to avoid aliasing
			virtualDirectoryItem := virtualDirectoryItem
			var virtualDirectory v1beta20220301s.VirtualDirectory_STATUS
			err := virtualDirectoryItem.AssignProperties_To_VirtualDirectory_STATUS(&virtualDirectory)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VirtualDirectory_STATUS() to populate field VirtualDirectories")
			}
			virtualDirectoryList[virtualDirectoryIndex] = virtualDirectory
		}
		destination.VirtualDirectories = virtualDirectoryList
	} else {
		destination.VirtualDirectories = nil
	}

	// VirtualPath
	destination.VirtualPath = genruntime.ClonePointerToString(application.VirtualPath)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of AutoHealActions. Use v1api20220301.AutoHealActions instead
type AutoHealActions struct {
	ActionType              *AutoHealActions_ActionType `json:"actionType,omitempty"`
	CustomAction            *AutoHealCustomAction       `json:"customAction,omitempty"`
	MinProcessExecutionTime *string                     `json:"minProcessExecutionTime,omitempty"`
}

var _ genruntime.ARMTransformer = &AutoHealActions{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (actions *AutoHealActions) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if actions == nil {
		return nil, nil
	}
	result := &AutoHealActions_ARM{}

	// Set property "ActionType":
	if actions.ActionType != nil {
		actionType := *actions.ActionType
		result.ActionType = &actionType
	}

	// Set property "CustomAction":
	if actions.CustomAction != nil {
		customAction_ARM, err := (*actions.CustomAction).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		customAction := *customAction_ARM.(*AutoHealCustomAction_ARM)
		result.CustomAction = &customAction
	}

	// Set property "MinProcessExecutionTime":
	if actions.MinProcessExecutionTime != nil {
		minProcessExecutionTime := *actions.MinProcessExecutionTime
		result.MinProcessExecutionTime = &minProcessExecutionTime
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (actions *AutoHealActions) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AutoHealActions_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (actions *AutoHealActions) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AutoHealActions_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AutoHealActions_ARM, got %T", armInput)
	}

	// Set property "ActionType":
	if typedInput.ActionType != nil {
		actionType := *typedInput.ActionType
		actions.ActionType = &actionType
	}

	// Set property "CustomAction":
	if typedInput.CustomAction != nil {
		var customAction1 AutoHealCustomAction
		err := customAction1.PopulateFromARM(owner, *typedInput.CustomAction)
		if err != nil {
			return err
		}
		customAction := customAction1
		actions.CustomAction = &customAction
	}

	// Set property "MinProcessExecutionTime":
	if typedInput.MinProcessExecutionTime != nil {
		minProcessExecutionTime := *typedInput.MinProcessExecutionTime
		actions.MinProcessExecutionTime = &minProcessExecutionTime
	}

	// No error
	return nil
}

// AssignProperties_From_AutoHealActions populates our AutoHealActions from the provided source AutoHealActions
func (actions *AutoHealActions) AssignProperties_From_AutoHealActions(source *v1beta20220301s.AutoHealActions) error {

	// ActionType
	if source.ActionType != nil {
		actionType := AutoHealActions_ActionType(*source.ActionType)
		actions.ActionType = &actionType
	} else {
		actions.ActionType = nil
	}

	// CustomAction
	if source.CustomAction != nil {
		var customAction AutoHealCustomAction
		err := customAction.AssignProperties_From_AutoHealCustomAction(source.CustomAction)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AutoHealCustomAction() to populate field CustomAction")
		}
		actions.CustomAction = &customAction
	} else {
		actions.CustomAction = nil
	}

	// MinProcessExecutionTime
	actions.MinProcessExecutionTime = genruntime.ClonePointerToString(source.MinProcessExecutionTime)

	// No error
	return nil
}

// AssignProperties_To_AutoHealActions populates the provided destination AutoHealActions from our AutoHealActions
func (actions *AutoHealActions) AssignProperties_To_AutoHealActions(destination *v1beta20220301s.AutoHealActions) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ActionType
	if actions.ActionType != nil {
		actionType := string(*actions.ActionType)
		destination.ActionType = &actionType
	} else {
		destination.ActionType = nil
	}

	// CustomAction
	if actions.CustomAction != nil {
		var customAction v1beta20220301s.AutoHealCustomAction
		err := actions.CustomAction.AssignProperties_To_AutoHealCustomAction(&customAction)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AutoHealCustomAction() to populate field CustomAction")
		}
		destination.CustomAction = &customAction
	} else {
		destination.CustomAction = nil
	}

	// MinProcessExecutionTime
	destination.MinProcessExecutionTime = genruntime.ClonePointerToString(actions.MinProcessExecutionTime)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of AutoHealActions_STATUS. Use v1api20220301.AutoHealActions_STATUS instead
type AutoHealActions_STATUS struct {
	ActionType              *AutoHealActions_ActionType_STATUS `json:"actionType,omitempty"`
	CustomAction            *AutoHealCustomAction_STATUS       `json:"customAction,omitempty"`
	MinProcessExecutionTime *string                            `json:"minProcessExecutionTime,omitempty"`
}

var _ genruntime.FromARMConverter = &AutoHealActions_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (actions *AutoHealActions_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AutoHealActions_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (actions *AutoHealActions_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AutoHealActions_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AutoHealActions_STATUS_ARM, got %T", armInput)
	}

	// Set property "ActionType":
	if typedInput.ActionType != nil {
		actionType := *typedInput.ActionType
		actions.ActionType = &actionType
	}

	// Set property "CustomAction":
	if typedInput.CustomAction != nil {
		var customAction1 AutoHealCustomAction_STATUS
		err := customAction1.PopulateFromARM(owner, *typedInput.CustomAction)
		if err != nil {
			return err
		}
		customAction := customAction1
		actions.CustomAction = &customAction
	}

	// Set property "MinProcessExecutionTime":
	if typedInput.MinProcessExecutionTime != nil {
		minProcessExecutionTime := *typedInput.MinProcessExecutionTime
		actions.MinProcessExecutionTime = &minProcessExecutionTime
	}

	// No error
	return nil
}

// AssignProperties_From_AutoHealActions_STATUS populates our AutoHealActions_STATUS from the provided source AutoHealActions_STATUS
func (actions *AutoHealActions_STATUS) AssignProperties_From_AutoHealActions_STATUS(source *v1beta20220301s.AutoHealActions_STATUS) error {

	// ActionType
	if source.ActionType != nil {
		actionType := AutoHealActions_ActionType_STATUS(*source.ActionType)
		actions.ActionType = &actionType
	} else {
		actions.ActionType = nil
	}

	// CustomAction
	if source.CustomAction != nil {
		var customAction AutoHealCustomAction_STATUS
		err := customAction.AssignProperties_From_AutoHealCustomAction_STATUS(source.CustomAction)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AutoHealCustomAction_STATUS() to populate field CustomAction")
		}
		actions.CustomAction = &customAction
	} else {
		actions.CustomAction = nil
	}

	// MinProcessExecutionTime
	actions.MinProcessExecutionTime = genruntime.ClonePointerToString(source.MinProcessExecutionTime)

	// No error
	return nil
}

// AssignProperties_To_AutoHealActions_STATUS populates the provided destination AutoHealActions_STATUS from our AutoHealActions_STATUS
func (actions *AutoHealActions_STATUS) AssignProperties_To_AutoHealActions_STATUS(destination *v1beta20220301s.AutoHealActions_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ActionType
	if actions.ActionType != nil {
		actionType := string(*actions.ActionType)
		destination.ActionType = &actionType
	} else {
		destination.ActionType = nil
	}

	// CustomAction
	if actions.CustomAction != nil {
		var customAction v1beta20220301s.AutoHealCustomAction_STATUS
		err := actions.CustomAction.AssignProperties_To_AutoHealCustomAction_STATUS(&customAction)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AutoHealCustomAction_STATUS() to populate field CustomAction")
		}
		destination.CustomAction = &customAction
	} else {
		destination.CustomAction = nil
	}

	// MinProcessExecutionTime
	destination.MinProcessExecutionTime = genruntime.ClonePointerToString(actions.MinProcessExecutionTime)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of AutoHealTriggers. Use v1api20220301.AutoHealTriggers instead
type AutoHealTriggers struct {
	PrivateBytesInKB     *int                           `json:"privateBytesInKB,omitempty"`
	Requests             *RequestsBasedTrigger          `json:"requests,omitempty"`
	SlowRequests         *SlowRequestsBasedTrigger      `json:"slowRequests,omitempty"`
	SlowRequestsWithPath []SlowRequestsBasedTrigger     `json:"slowRequestsWithPath,omitempty"`
	StatusCodes          []StatusCodesBasedTrigger      `json:"statusCodes,omitempty"`
	StatusCodesRange     []StatusCodesRangeBasedTrigger `json:"statusCodesRange,omitempty"`
}

var _ genruntime.ARMTransformer = &AutoHealTriggers{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (triggers *AutoHealTriggers) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if triggers == nil {
		return nil, nil
	}
	result := &AutoHealTriggers_ARM{}

	// Set property "PrivateBytesInKB":
	if triggers.PrivateBytesInKB != nil {
		privateBytesInKB := *triggers.PrivateBytesInKB
		result.PrivateBytesInKB = &privateBytesInKB
	}

	// Set property "Requests":
	if triggers.Requests != nil {
		requests_ARM, err := (*triggers.Requests).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		requests := *requests_ARM.(*RequestsBasedTrigger_ARM)
		result.Requests = &requests
	}

	// Set property "SlowRequests":
	if triggers.SlowRequests != nil {
		slowRequests_ARM, err := (*triggers.SlowRequests).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		slowRequests := *slowRequests_ARM.(*SlowRequestsBasedTrigger_ARM)
		result.SlowRequests = &slowRequests
	}

	// Set property "SlowRequestsWithPath":
	for _, item := range triggers.SlowRequestsWithPath {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.SlowRequestsWithPath = append(result.SlowRequestsWithPath, *item_ARM.(*SlowRequestsBasedTrigger_ARM))
	}

	// Set property "StatusCodes":
	for _, item := range triggers.StatusCodes {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.StatusCodes = append(result.StatusCodes, *item_ARM.(*StatusCodesBasedTrigger_ARM))
	}

	// Set property "StatusCodesRange":
	for _, item := range triggers.StatusCodesRange {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.StatusCodesRange = append(result.StatusCodesRange, *item_ARM.(*StatusCodesRangeBasedTrigger_ARM))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (triggers *AutoHealTriggers) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AutoHealTriggers_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (triggers *AutoHealTriggers) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AutoHealTriggers_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AutoHealTriggers_ARM, got %T", armInput)
	}

	// Set property "PrivateBytesInKB":
	if typedInput.PrivateBytesInKB != nil {
		privateBytesInKB := *typedInput.PrivateBytesInKB
		triggers.PrivateBytesInKB = &privateBytesInKB
	}

	// Set property "Requests":
	if typedInput.Requests != nil {
		var requests1 RequestsBasedTrigger
		err := requests1.PopulateFromARM(owner, *typedInput.Requests)
		if err != nil {
			return err
		}
		requests := requests1
		triggers.Requests = &requests
	}

	// Set property "SlowRequests":
	if typedInput.SlowRequests != nil {
		var slowRequests1 SlowRequestsBasedTrigger
		err := slowRequests1.PopulateFromARM(owner, *typedInput.SlowRequests)
		if err != nil {
			return err
		}
		slowRequests := slowRequests1
		triggers.SlowRequests = &slowRequests
	}

	// Set property "SlowRequestsWithPath":
	for _, item := range typedInput.SlowRequestsWithPath {
		var item1 SlowRequestsBasedTrigger
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		triggers.SlowRequestsWithPath = append(triggers.SlowRequestsWithPath, item1)
	}

	// Set property "StatusCodes":
	for _, item := range typedInput.StatusCodes {
		var item1 StatusCodesBasedTrigger
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		triggers.StatusCodes = append(triggers.StatusCodes, item1)
	}

	// Set property "StatusCodesRange":
	for _, item := range typedInput.StatusCodesRange {
		var item1 StatusCodesRangeBasedTrigger
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		triggers.StatusCodesRange = append(triggers.StatusCodesRange, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_AutoHealTriggers populates our AutoHealTriggers from the provided source AutoHealTriggers
func (triggers *AutoHealTriggers) AssignProperties_From_AutoHealTriggers(source *v1beta20220301s.AutoHealTriggers) error {

	// PrivateBytesInKB
	triggers.PrivateBytesInKB = genruntime.ClonePointerToInt(source.PrivateBytesInKB)

	// Requests
	if source.Requests != nil {
		var request RequestsBasedTrigger
		err := request.AssignProperties_From_RequestsBasedTrigger(source.Requests)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RequestsBasedTrigger() to populate field Requests")
		}
		triggers.Requests = &request
	} else {
		triggers.Requests = nil
	}

	// SlowRequests
	if source.SlowRequests != nil {
		var slowRequest SlowRequestsBasedTrigger
		err := slowRequest.AssignProperties_From_SlowRequestsBasedTrigger(source.SlowRequests)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SlowRequestsBasedTrigger() to populate field SlowRequests")
		}
		triggers.SlowRequests = &slowRequest
	} else {
		triggers.SlowRequests = nil
	}

	// SlowRequestsWithPath
	if source.SlowRequestsWithPath != nil {
		slowRequestsWithPathList := make([]SlowRequestsBasedTrigger, len(source.SlowRequestsWithPath))
		for slowRequestsWithPathIndex, slowRequestsWithPathItem := range source.SlowRequestsWithPath {
			// Shadow the loop variable to avoid aliasing
			slowRequestsWithPathItem := slowRequestsWithPathItem
			var slowRequestsWithPath SlowRequestsBasedTrigger
			err := slowRequestsWithPath.AssignProperties_From_SlowRequestsBasedTrigger(&slowRequestsWithPathItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SlowRequestsBasedTrigger() to populate field SlowRequestsWithPath")
			}
			slowRequestsWithPathList[slowRequestsWithPathIndex] = slowRequestsWithPath
		}
		triggers.SlowRequestsWithPath = slowRequestsWithPathList
	} else {
		triggers.SlowRequestsWithPath = nil
	}

	// StatusCodes
	if source.StatusCodes != nil {
		statusCodeList := make([]StatusCodesBasedTrigger, len(source.StatusCodes))
		for statusCodeIndex, statusCodeItem := range source.StatusCodes {
			// Shadow the loop variable to avoid aliasing
			statusCodeItem := statusCodeItem
			var statusCode StatusCodesBasedTrigger
			err := statusCode.AssignProperties_From_StatusCodesBasedTrigger(&statusCodeItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_StatusCodesBasedTrigger() to populate field StatusCodes")
			}
			statusCodeList[statusCodeIndex] = statusCode
		}
		triggers.StatusCodes = statusCodeList
	} else {
		triggers.StatusCodes = nil
	}

	// StatusCodesRange
	if source.StatusCodesRange != nil {
		statusCodesRangeList := make([]StatusCodesRangeBasedTrigger, len(source.StatusCodesRange))
		for statusCodesRangeIndex, statusCodesRangeItem := range source.StatusCodesRange {
			// Shadow the loop variable to avoid aliasing
			statusCodesRangeItem := statusCodesRangeItem
			var statusCodesRange StatusCodesRangeBasedTrigger
			err := statusCodesRange.AssignProperties_From_StatusCodesRangeBasedTrigger(&statusCodesRangeItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_StatusCodesRangeBasedTrigger() to populate field StatusCodesRange")
			}
			statusCodesRangeList[statusCodesRangeIndex] = statusCodesRange
		}
		triggers.StatusCodesRange = statusCodesRangeList
	} else {
		triggers.StatusCodesRange = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AutoHealTriggers populates the provided destination AutoHealTriggers from our AutoHealTriggers
func (triggers *AutoHealTriggers) AssignProperties_To_AutoHealTriggers(destination *v1beta20220301s.AutoHealTriggers) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrivateBytesInKB
	destination.PrivateBytesInKB = genruntime.ClonePointerToInt(triggers.PrivateBytesInKB)

	// Requests
	if triggers.Requests != nil {
		var request v1beta20220301s.RequestsBasedTrigger
		err := triggers.Requests.AssignProperties_To_RequestsBasedTrigger(&request)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RequestsBasedTrigger() to populate field Requests")
		}
		destination.Requests = &request
	} else {
		destination.Requests = nil
	}

	// SlowRequests
	if triggers.SlowRequests != nil {
		var slowRequest v1beta20220301s.SlowRequestsBasedTrigger
		err := triggers.SlowRequests.AssignProperties_To_SlowRequestsBasedTrigger(&slowRequest)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SlowRequestsBasedTrigger() to populate field SlowRequests")
		}
		destination.SlowRequests = &slowRequest
	} else {
		destination.SlowRequests = nil
	}

	// SlowRequestsWithPath
	if triggers.SlowRequestsWithPath != nil {
		slowRequestsWithPathList := make([]v1beta20220301s.SlowRequestsBasedTrigger, len(triggers.SlowRequestsWithPath))
		for slowRequestsWithPathIndex, slowRequestsWithPathItem := range triggers.SlowRequestsWithPath {
			// Shadow the loop variable to avoid aliasing
			slowRequestsWithPathItem := slowRequestsWithPathItem
			var slowRequestsWithPath v1beta20220301s.SlowRequestsBasedTrigger
			err := slowRequestsWithPathItem.AssignProperties_To_SlowRequestsBasedTrigger(&slowRequestsWithPath)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SlowRequestsBasedTrigger() to populate field SlowRequestsWithPath")
			}
			slowRequestsWithPathList[slowRequestsWithPathIndex] = slowRequestsWithPath
		}
		destination.SlowRequestsWithPath = slowRequestsWithPathList
	} else {
		destination.SlowRequestsWithPath = nil
	}

	// StatusCodes
	if triggers.StatusCodes != nil {
		statusCodeList := make([]v1beta20220301s.StatusCodesBasedTrigger, len(triggers.StatusCodes))
		for statusCodeIndex, statusCodeItem := range triggers.StatusCodes {
			// Shadow the loop variable to avoid aliasing
			statusCodeItem := statusCodeItem
			var statusCode v1beta20220301s.StatusCodesBasedTrigger
			err := statusCodeItem.AssignProperties_To_StatusCodesBasedTrigger(&statusCode)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_StatusCodesBasedTrigger() to populate field StatusCodes")
			}
			statusCodeList[statusCodeIndex] = statusCode
		}
		destination.StatusCodes = statusCodeList
	} else {
		destination.StatusCodes = nil
	}

	// StatusCodesRange
	if triggers.StatusCodesRange != nil {
		statusCodesRangeList := make([]v1beta20220301s.StatusCodesRangeBasedTrigger, len(triggers.StatusCodesRange))
		for statusCodesRangeIndex, statusCodesRangeItem := range triggers.StatusCodesRange {
			// Shadow the loop variable to avoid aliasing
			statusCodesRangeItem := statusCodesRangeItem
			var statusCodesRange v1beta20220301s.StatusCodesRangeBasedTrigger
			err := statusCodesRangeItem.AssignProperties_To_StatusCodesRangeBasedTrigger(&statusCodesRange)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_StatusCodesRangeBasedTrigger() to populate field StatusCodesRange")
			}
			statusCodesRangeList[statusCodesRangeIndex] = statusCodesRange
		}
		destination.StatusCodesRange = statusCodesRangeList
	} else {
		destination.StatusCodesRange = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of AutoHealTriggers_STATUS. Use v1api20220301.AutoHealTriggers_STATUS instead
type AutoHealTriggers_STATUS struct {
	PrivateBytesInKB     *int                                  `json:"privateBytesInKB,omitempty"`
	Requests             *RequestsBasedTrigger_STATUS          `json:"requests,omitempty"`
	SlowRequests         *SlowRequestsBasedTrigger_STATUS      `json:"slowRequests,omitempty"`
	SlowRequestsWithPath []SlowRequestsBasedTrigger_STATUS     `json:"slowRequestsWithPath,omitempty"`
	StatusCodes          []StatusCodesBasedTrigger_STATUS      `json:"statusCodes,omitempty"`
	StatusCodesRange     []StatusCodesRangeBasedTrigger_STATUS `json:"statusCodesRange,omitempty"`
}

var _ genruntime.FromARMConverter = &AutoHealTriggers_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (triggers *AutoHealTriggers_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AutoHealTriggers_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (triggers *AutoHealTriggers_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AutoHealTriggers_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AutoHealTriggers_STATUS_ARM, got %T", armInput)
	}

	// Set property "PrivateBytesInKB":
	if typedInput.PrivateBytesInKB != nil {
		privateBytesInKB := *typedInput.PrivateBytesInKB
		triggers.PrivateBytesInKB = &privateBytesInKB
	}

	// Set property "Requests":
	if typedInput.Requests != nil {
		var requests1 RequestsBasedTrigger_STATUS
		err := requests1.PopulateFromARM(owner, *typedInput.Requests)
		if err != nil {
			return err
		}
		requests := requests1
		triggers.Requests = &requests
	}

	// Set property "SlowRequests":
	if typedInput.SlowRequests != nil {
		var slowRequests1 SlowRequestsBasedTrigger_STATUS
		err := slowRequests1.PopulateFromARM(owner, *typedInput.SlowRequests)
		if err != nil {
			return err
		}
		slowRequests := slowRequests1
		triggers.SlowRequests = &slowRequests
	}

	// Set property "SlowRequestsWithPath":
	for _, item := range typedInput.SlowRequestsWithPath {
		var item1 SlowRequestsBasedTrigger_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		triggers.SlowRequestsWithPath = append(triggers.SlowRequestsWithPath, item1)
	}

	// Set property "StatusCodes":
	for _, item := range typedInput.StatusCodes {
		var item1 StatusCodesBasedTrigger_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		triggers.StatusCodes = append(triggers.StatusCodes, item1)
	}

	// Set property "StatusCodesRange":
	for _, item := range typedInput.StatusCodesRange {
		var item1 StatusCodesRangeBasedTrigger_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		triggers.StatusCodesRange = append(triggers.StatusCodesRange, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_AutoHealTriggers_STATUS populates our AutoHealTriggers_STATUS from the provided source AutoHealTriggers_STATUS
func (triggers *AutoHealTriggers_STATUS) AssignProperties_From_AutoHealTriggers_STATUS(source *v1beta20220301s.AutoHealTriggers_STATUS) error {

	// PrivateBytesInKB
	triggers.PrivateBytesInKB = genruntime.ClonePointerToInt(source.PrivateBytesInKB)

	// Requests
	if source.Requests != nil {
		var request RequestsBasedTrigger_STATUS
		err := request.AssignProperties_From_RequestsBasedTrigger_STATUS(source.Requests)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RequestsBasedTrigger_STATUS() to populate field Requests")
		}
		triggers.Requests = &request
	} else {
		triggers.Requests = nil
	}

	// SlowRequests
	if source.SlowRequests != nil {
		var slowRequest SlowRequestsBasedTrigger_STATUS
		err := slowRequest.AssignProperties_From_SlowRequestsBasedTrigger_STATUS(source.SlowRequests)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SlowRequestsBasedTrigger_STATUS() to populate field SlowRequests")
		}
		triggers.SlowRequests = &slowRequest
	} else {
		triggers.SlowRequests = nil
	}

	// SlowRequestsWithPath
	if source.SlowRequestsWithPath != nil {
		slowRequestsWithPathList := make([]SlowRequestsBasedTrigger_STATUS, len(source.SlowRequestsWithPath))
		for slowRequestsWithPathIndex, slowRequestsWithPathItem := range source.SlowRequestsWithPath {
			// Shadow the loop variable to avoid aliasing
			slowRequestsWithPathItem := slowRequestsWithPathItem
			var slowRequestsWithPath SlowRequestsBasedTrigger_STATUS
			err := slowRequestsWithPath.AssignProperties_From_SlowRequestsBasedTrigger_STATUS(&slowRequestsWithPathItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SlowRequestsBasedTrigger_STATUS() to populate field SlowRequestsWithPath")
			}
			slowRequestsWithPathList[slowRequestsWithPathIndex] = slowRequestsWithPath
		}
		triggers.SlowRequestsWithPath = slowRequestsWithPathList
	} else {
		triggers.SlowRequestsWithPath = nil
	}

	// StatusCodes
	if source.StatusCodes != nil {
		statusCodeList := make([]StatusCodesBasedTrigger_STATUS, len(source.StatusCodes))
		for statusCodeIndex, statusCodeItem := range source.StatusCodes {
			// Shadow the loop variable to avoid aliasing
			statusCodeItem := statusCodeItem
			var statusCode StatusCodesBasedTrigger_STATUS
			err := statusCode.AssignProperties_From_StatusCodesBasedTrigger_STATUS(&statusCodeItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_StatusCodesBasedTrigger_STATUS() to populate field StatusCodes")
			}
			statusCodeList[statusCodeIndex] = statusCode
		}
		triggers.StatusCodes = statusCodeList
	} else {
		triggers.StatusCodes = nil
	}

	// StatusCodesRange
	if source.StatusCodesRange != nil {
		statusCodesRangeList := make([]StatusCodesRangeBasedTrigger_STATUS, len(source.StatusCodesRange))
		for statusCodesRangeIndex, statusCodesRangeItem := range source.StatusCodesRange {
			// Shadow the loop variable to avoid aliasing
			statusCodesRangeItem := statusCodesRangeItem
			var statusCodesRange StatusCodesRangeBasedTrigger_STATUS
			err := statusCodesRange.AssignProperties_From_StatusCodesRangeBasedTrigger_STATUS(&statusCodesRangeItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_StatusCodesRangeBasedTrigger_STATUS() to populate field StatusCodesRange")
			}
			statusCodesRangeList[statusCodesRangeIndex] = statusCodesRange
		}
		triggers.StatusCodesRange = statusCodesRangeList
	} else {
		triggers.StatusCodesRange = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AutoHealTriggers_STATUS populates the provided destination AutoHealTriggers_STATUS from our AutoHealTriggers_STATUS
func (triggers *AutoHealTriggers_STATUS) AssignProperties_To_AutoHealTriggers_STATUS(destination *v1beta20220301s.AutoHealTriggers_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrivateBytesInKB
	destination.PrivateBytesInKB = genruntime.ClonePointerToInt(triggers.PrivateBytesInKB)

	// Requests
	if triggers.Requests != nil {
		var request v1beta20220301s.RequestsBasedTrigger_STATUS
		err := triggers.Requests.AssignProperties_To_RequestsBasedTrigger_STATUS(&request)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RequestsBasedTrigger_STATUS() to populate field Requests")
		}
		destination.Requests = &request
	} else {
		destination.Requests = nil
	}

	// SlowRequests
	if triggers.SlowRequests != nil {
		var slowRequest v1beta20220301s.SlowRequestsBasedTrigger_STATUS
		err := triggers.SlowRequests.AssignProperties_To_SlowRequestsBasedTrigger_STATUS(&slowRequest)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SlowRequestsBasedTrigger_STATUS() to populate field SlowRequests")
		}
		destination.SlowRequests = &slowRequest
	} else {
		destination.SlowRequests = nil
	}

	// SlowRequestsWithPath
	if triggers.SlowRequestsWithPath != nil {
		slowRequestsWithPathList := make([]v1beta20220301s.SlowRequestsBasedTrigger_STATUS, len(triggers.SlowRequestsWithPath))
		for slowRequestsWithPathIndex, slowRequestsWithPathItem := range triggers.SlowRequestsWithPath {
			// Shadow the loop variable to avoid aliasing
			slowRequestsWithPathItem := slowRequestsWithPathItem
			var slowRequestsWithPath v1beta20220301s.SlowRequestsBasedTrigger_STATUS
			err := slowRequestsWithPathItem.AssignProperties_To_SlowRequestsBasedTrigger_STATUS(&slowRequestsWithPath)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SlowRequestsBasedTrigger_STATUS() to populate field SlowRequestsWithPath")
			}
			slowRequestsWithPathList[slowRequestsWithPathIndex] = slowRequestsWithPath
		}
		destination.SlowRequestsWithPath = slowRequestsWithPathList
	} else {
		destination.SlowRequestsWithPath = nil
	}

	// StatusCodes
	if triggers.StatusCodes != nil {
		statusCodeList := make([]v1beta20220301s.StatusCodesBasedTrigger_STATUS, len(triggers.StatusCodes))
		for statusCodeIndex, statusCodeItem := range triggers.StatusCodes {
			// Shadow the loop variable to avoid aliasing
			statusCodeItem := statusCodeItem
			var statusCode v1beta20220301s.StatusCodesBasedTrigger_STATUS
			err := statusCodeItem.AssignProperties_To_StatusCodesBasedTrigger_STATUS(&statusCode)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_StatusCodesBasedTrigger_STATUS() to populate field StatusCodes")
			}
			statusCodeList[statusCodeIndex] = statusCode
		}
		destination.StatusCodes = statusCodeList
	} else {
		destination.StatusCodes = nil
	}

	// StatusCodesRange
	if triggers.StatusCodesRange != nil {
		statusCodesRangeList := make([]v1beta20220301s.StatusCodesRangeBasedTrigger_STATUS, len(triggers.StatusCodesRange))
		for statusCodesRangeIndex, statusCodesRangeItem := range triggers.StatusCodesRange {
			// Shadow the loop variable to avoid aliasing
			statusCodesRangeItem := statusCodesRangeItem
			var statusCodesRange v1beta20220301s.StatusCodesRangeBasedTrigger_STATUS
			err := statusCodesRangeItem.AssignProperties_To_StatusCodesRangeBasedTrigger_STATUS(&statusCodesRange)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_StatusCodesRangeBasedTrigger_STATUS() to populate field StatusCodesRange")
			}
			statusCodesRangeList[statusCodesRangeIndex] = statusCodesRange
		}
		destination.StatusCodesRange = statusCodesRangeList
	} else {
		destination.StatusCodesRange = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of AzureStorageInfoValue_State_STATUS. Use v1api20220301.AzureStorageInfoValue_State_STATUS instead
type AzureStorageInfoValue_State_STATUS string

const (
	AzureStorageInfoValue_State_STATUS_InvalidCredentials = AzureStorageInfoValue_State_STATUS("InvalidCredentials")
	AzureStorageInfoValue_State_STATUS_InvalidShare       = AzureStorageInfoValue_State_STATUS("InvalidShare")
	AzureStorageInfoValue_State_STATUS_NotValidated       = AzureStorageInfoValue_State_STATUS("NotValidated")
	AzureStorageInfoValue_State_STATUS_Ok                 = AzureStorageInfoValue_State_STATUS("Ok")
)

// Deprecated version of AzureStorageInfoValue_Type. Use v1api20220301.AzureStorageInfoValue_Type instead
// +kubebuilder:validation:Enum={"AzureBlob","AzureFiles"}
type AzureStorageInfoValue_Type string

const (
	AzureStorageInfoValue_Type_AzureBlob  = AzureStorageInfoValue_Type("AzureBlob")
	AzureStorageInfoValue_Type_AzureFiles = AzureStorageInfoValue_Type("AzureFiles")
)

// Deprecated version of AzureStorageInfoValue_Type_STATUS. Use v1api20220301.AzureStorageInfoValue_Type_STATUS instead
type AzureStorageInfoValue_Type_STATUS string

const (
	AzureStorageInfoValue_Type_STATUS_AzureBlob  = AzureStorageInfoValue_Type_STATUS("AzureBlob")
	AzureStorageInfoValue_Type_STATUS_AzureFiles = AzureStorageInfoValue_Type_STATUS("AzureFiles")
)

// Deprecated version of ConnStringInfo_Type. Use v1api20220301.ConnStringInfo_Type instead
// +kubebuilder:validation:Enum={"ApiHub","Custom","DocDb","EventHub","MySql","NotificationHub","PostgreSQL","RedisCache","SQLAzure","SQLServer","ServiceBus"}
type ConnStringInfo_Type string

const (
	ConnStringInfo_Type_ApiHub          = ConnStringInfo_Type("ApiHub")
	ConnStringInfo_Type_Custom          = ConnStringInfo_Type("Custom")
	ConnStringInfo_Type_DocDb           = ConnStringInfo_Type("DocDb")
	ConnStringInfo_Type_EventHub        = ConnStringInfo_Type("EventHub")
	ConnStringInfo_Type_MySql           = ConnStringInfo_Type("MySql")
	ConnStringInfo_Type_NotificationHub = ConnStringInfo_Type("NotificationHub")
	ConnStringInfo_Type_PostgreSQL      = ConnStringInfo_Type("PostgreSQL")
	ConnStringInfo_Type_RedisCache      = ConnStringInfo_Type("RedisCache")
	ConnStringInfo_Type_SQLAzure        = ConnStringInfo_Type("SQLAzure")
	ConnStringInfo_Type_SQLServer       = ConnStringInfo_Type("SQLServer")
	ConnStringInfo_Type_ServiceBus      = ConnStringInfo_Type("ServiceBus")
)

// Deprecated version of ConnStringInfo_Type_STATUS. Use v1api20220301.ConnStringInfo_Type_STATUS instead
type ConnStringInfo_Type_STATUS string

const (
	ConnStringInfo_Type_STATUS_ApiHub          = ConnStringInfo_Type_STATUS("ApiHub")
	ConnStringInfo_Type_STATUS_Custom          = ConnStringInfo_Type_STATUS("Custom")
	ConnStringInfo_Type_STATUS_DocDb           = ConnStringInfo_Type_STATUS("DocDb")
	ConnStringInfo_Type_STATUS_EventHub        = ConnStringInfo_Type_STATUS("EventHub")
	ConnStringInfo_Type_STATUS_MySql           = ConnStringInfo_Type_STATUS("MySql")
	ConnStringInfo_Type_STATUS_NotificationHub = ConnStringInfo_Type_STATUS("NotificationHub")
	ConnStringInfo_Type_STATUS_PostgreSQL      = ConnStringInfo_Type_STATUS("PostgreSQL")
	ConnStringInfo_Type_STATUS_RedisCache      = ConnStringInfo_Type_STATUS("RedisCache")
	ConnStringInfo_Type_STATUS_SQLAzure        = ConnStringInfo_Type_STATUS("SQLAzure")
	ConnStringInfo_Type_STATUS_SQLServer       = ConnStringInfo_Type_STATUS("SQLServer")
	ConnStringInfo_Type_STATUS_ServiceBus      = ConnStringInfo_Type_STATUS("ServiceBus")
)

// Deprecated version of IpSecurityRestriction_Tag. Use v1api20220301.IpSecurityRestriction_Tag instead
// +kubebuilder:validation:Enum={"Default","ServiceTag","XffProxy"}
type IpSecurityRestriction_Tag string

const (
	IpSecurityRestriction_Tag_Default    = IpSecurityRestriction_Tag("Default")
	IpSecurityRestriction_Tag_ServiceTag = IpSecurityRestriction_Tag("ServiceTag")
	IpSecurityRestriction_Tag_XffProxy   = IpSecurityRestriction_Tag("XffProxy")
)

// Deprecated version of IpSecurityRestriction_Tag_STATUS. Use v1api20220301.IpSecurityRestriction_Tag_STATUS instead
type IpSecurityRestriction_Tag_STATUS string

const (
	IpSecurityRestriction_Tag_STATUS_Default    = IpSecurityRestriction_Tag_STATUS("Default")
	IpSecurityRestriction_Tag_STATUS_ServiceTag = IpSecurityRestriction_Tag_STATUS("ServiceTag")
	IpSecurityRestriction_Tag_STATUS_XffProxy   = IpSecurityRestriction_Tag_STATUS("XffProxy")
)

// Deprecated version of RampUpRule. Use v1api20220301.RampUpRule instead
type RampUpRule struct {
	ActionHostName            *string  `json:"actionHostName,omitempty"`
	ChangeDecisionCallbackUrl *string  `json:"changeDecisionCallbackUrl,omitempty"`
	ChangeIntervalInMinutes   *int     `json:"changeIntervalInMinutes,omitempty"`
	ChangeStep                *float64 `json:"changeStep,omitempty"`
	MaxReroutePercentage      *float64 `json:"maxReroutePercentage,omitempty"`
	MinReroutePercentage      *float64 `json:"minReroutePercentage,omitempty"`
	Name                      *string  `json:"name,omitempty"`
	ReroutePercentage         *float64 `json:"reroutePercentage,omitempty"`
}

var _ genruntime.ARMTransformer = &RampUpRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *RampUpRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &RampUpRule_ARM{}

	// Set property "ActionHostName":
	if rule.ActionHostName != nil {
		actionHostName := *rule.ActionHostName
		result.ActionHostName = &actionHostName
	}

	// Set property "ChangeDecisionCallbackUrl":
	if rule.ChangeDecisionCallbackUrl != nil {
		changeDecisionCallbackUrl := *rule.ChangeDecisionCallbackUrl
		result.ChangeDecisionCallbackUrl = &changeDecisionCallbackUrl
	}

	// Set property "ChangeIntervalInMinutes":
	if rule.ChangeIntervalInMinutes != nil {
		changeIntervalInMinutes := *rule.ChangeIntervalInMinutes
		result.ChangeIntervalInMinutes = &changeIntervalInMinutes
	}

	// Set property "ChangeStep":
	if rule.ChangeStep != nil {
		changeStep := *rule.ChangeStep
		result.ChangeStep = &changeStep
	}

	// Set property "MaxReroutePercentage":
	if rule.MaxReroutePercentage != nil {
		maxReroutePercentage := *rule.MaxReroutePercentage
		result.MaxReroutePercentage = &maxReroutePercentage
	}

	// Set property "MinReroutePercentage":
	if rule.MinReroutePercentage != nil {
		minReroutePercentage := *rule.MinReroutePercentage
		result.MinReroutePercentage = &minReroutePercentage
	}

	// Set property "Name":
	if rule.Name != nil {
		name := *rule.Name
		result.Name = &name
	}

	// Set property "ReroutePercentage":
	if rule.ReroutePercentage != nil {
		reroutePercentage := *rule.ReroutePercentage
		result.ReroutePercentage = &reroutePercentage
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *RampUpRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &RampUpRule_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *RampUpRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(RampUpRule_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected RampUpRule_ARM, got %T", armInput)
	}

	// Set property "ActionHostName":
	if typedInput.ActionHostName != nil {
		actionHostName := *typedInput.ActionHostName
		rule.ActionHostName = &actionHostName
	}

	// Set property "ChangeDecisionCallbackUrl":
	if typedInput.ChangeDecisionCallbackUrl != nil {
		changeDecisionCallbackUrl := *typedInput.ChangeDecisionCallbackUrl
		rule.ChangeDecisionCallbackUrl = &changeDecisionCallbackUrl
	}

	// Set property "ChangeIntervalInMinutes":
	if typedInput.ChangeIntervalInMinutes != nil {
		changeIntervalInMinutes := *typedInput.ChangeIntervalInMinutes
		rule.ChangeIntervalInMinutes = &changeIntervalInMinutes
	}

	// Set property "ChangeStep":
	if typedInput.ChangeStep != nil {
		changeStep := *typedInput.ChangeStep
		rule.ChangeStep = &changeStep
	}

	// Set property "MaxReroutePercentage":
	if typedInput.MaxReroutePercentage != nil {
		maxReroutePercentage := *typedInput.MaxReroutePercentage
		rule.MaxReroutePercentage = &maxReroutePercentage
	}

	// Set property "MinReroutePercentage":
	if typedInput.MinReroutePercentage != nil {
		minReroutePercentage := *typedInput.MinReroutePercentage
		rule.MinReroutePercentage = &minReroutePercentage
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property "ReroutePercentage":
	if typedInput.ReroutePercentage != nil {
		reroutePercentage := *typedInput.ReroutePercentage
		rule.ReroutePercentage = &reroutePercentage
	}

	// No error
	return nil
}

// AssignProperties_From_RampUpRule populates our RampUpRule from the provided source RampUpRule
func (rule *RampUpRule) AssignProperties_From_RampUpRule(source *v1beta20220301s.RampUpRule) error {

	// ActionHostName
	rule.ActionHostName = genruntime.ClonePointerToString(source.ActionHostName)

	// ChangeDecisionCallbackUrl
	rule.ChangeDecisionCallbackUrl = genruntime.ClonePointerToString(source.ChangeDecisionCallbackUrl)

	// ChangeIntervalInMinutes
	rule.ChangeIntervalInMinutes = genruntime.ClonePointerToInt(source.ChangeIntervalInMinutes)

	// ChangeStep
	if source.ChangeStep != nil {
		changeStep := *source.ChangeStep
		rule.ChangeStep = &changeStep
	} else {
		rule.ChangeStep = nil
	}

	// MaxReroutePercentage
	if source.MaxReroutePercentage != nil {
		maxReroutePercentage := *source.MaxReroutePercentage
		rule.MaxReroutePercentage = &maxReroutePercentage
	} else {
		rule.MaxReroutePercentage = nil
	}

	// MinReroutePercentage
	if source.MinReroutePercentage != nil {
		minReroutePercentage := *source.MinReroutePercentage
		rule.MinReroutePercentage = &minReroutePercentage
	} else {
		rule.MinReroutePercentage = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// ReroutePercentage
	if source.ReroutePercentage != nil {
		reroutePercentage := *source.ReroutePercentage
		rule.ReroutePercentage = &reroutePercentage
	} else {
		rule.ReroutePercentage = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RampUpRule populates the provided destination RampUpRule from our RampUpRule
func (rule *RampUpRule) AssignProperties_To_RampUpRule(destination *v1beta20220301s.RampUpRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ActionHostName
	destination.ActionHostName = genruntime.ClonePointerToString(rule.ActionHostName)

	// ChangeDecisionCallbackUrl
	destination.ChangeDecisionCallbackUrl = genruntime.ClonePointerToString(rule.ChangeDecisionCallbackUrl)

	// ChangeIntervalInMinutes
	destination.ChangeIntervalInMinutes = genruntime.ClonePointerToInt(rule.ChangeIntervalInMinutes)

	// ChangeStep
	if rule.ChangeStep != nil {
		changeStep := *rule.ChangeStep
		destination.ChangeStep = &changeStep
	} else {
		destination.ChangeStep = nil
	}

	// MaxReroutePercentage
	if rule.MaxReroutePercentage != nil {
		maxReroutePercentage := *rule.MaxReroutePercentage
		destination.MaxReroutePercentage = &maxReroutePercentage
	} else {
		destination.MaxReroutePercentage = nil
	}

	// MinReroutePercentage
	if rule.MinReroutePercentage != nil {
		minReroutePercentage := *rule.MinReroutePercentage
		destination.MinReroutePercentage = &minReroutePercentage
	} else {
		destination.MinReroutePercentage = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// ReroutePercentage
	if rule.ReroutePercentage != nil {
		reroutePercentage := *rule.ReroutePercentage
		destination.ReroutePercentage = &reroutePercentage
	} else {
		destination.ReroutePercentage = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of RampUpRule_STATUS. Use v1api20220301.RampUpRule_STATUS instead
type RampUpRule_STATUS struct {
	ActionHostName            *string  `json:"actionHostName,omitempty"`
	ChangeDecisionCallbackUrl *string  `json:"changeDecisionCallbackUrl,omitempty"`
	ChangeIntervalInMinutes   *int     `json:"changeIntervalInMinutes,omitempty"`
	ChangeStep                *float64 `json:"changeStep,omitempty"`
	MaxReroutePercentage      *float64 `json:"maxReroutePercentage,omitempty"`
	MinReroutePercentage      *float64 `json:"minReroutePercentage,omitempty"`
	Name                      *string  `json:"name,omitempty"`
	ReroutePercentage         *float64 `json:"reroutePercentage,omitempty"`
}

var _ genruntime.FromARMConverter = &RampUpRule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *RampUpRule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &RampUpRule_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *RampUpRule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(RampUpRule_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected RampUpRule_STATUS_ARM, got %T", armInput)
	}

	// Set property "ActionHostName":
	if typedInput.ActionHostName != nil {
		actionHostName := *typedInput.ActionHostName
		rule.ActionHostName = &actionHostName
	}

	// Set property "ChangeDecisionCallbackUrl":
	if typedInput.ChangeDecisionCallbackUrl != nil {
		changeDecisionCallbackUrl := *typedInput.ChangeDecisionCallbackUrl
		rule.ChangeDecisionCallbackUrl = &changeDecisionCallbackUrl
	}

	// Set property "ChangeIntervalInMinutes":
	if typedInput.ChangeIntervalInMinutes != nil {
		changeIntervalInMinutes := *typedInput.ChangeIntervalInMinutes
		rule.ChangeIntervalInMinutes = &changeIntervalInMinutes
	}

	// Set property "ChangeStep":
	if typedInput.ChangeStep != nil {
		changeStep := *typedInput.ChangeStep
		rule.ChangeStep = &changeStep
	}

	// Set property "MaxReroutePercentage":
	if typedInput.MaxReroutePercentage != nil {
		maxReroutePercentage := *typedInput.MaxReroutePercentage
		rule.MaxReroutePercentage = &maxReroutePercentage
	}

	// Set property "MinReroutePercentage":
	if typedInput.MinReroutePercentage != nil {
		minReroutePercentage := *typedInput.MinReroutePercentage
		rule.MinReroutePercentage = &minReroutePercentage
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property "ReroutePercentage":
	if typedInput.ReroutePercentage != nil {
		reroutePercentage := *typedInput.ReroutePercentage
		rule.ReroutePercentage = &reroutePercentage
	}

	// No error
	return nil
}

// AssignProperties_From_RampUpRule_STATUS populates our RampUpRule_STATUS from the provided source RampUpRule_STATUS
func (rule *RampUpRule_STATUS) AssignProperties_From_RampUpRule_STATUS(source *v1beta20220301s.RampUpRule_STATUS) error {

	// ActionHostName
	rule.ActionHostName = genruntime.ClonePointerToString(source.ActionHostName)

	// ChangeDecisionCallbackUrl
	rule.ChangeDecisionCallbackUrl = genruntime.ClonePointerToString(source.ChangeDecisionCallbackUrl)

	// ChangeIntervalInMinutes
	rule.ChangeIntervalInMinutes = genruntime.ClonePointerToInt(source.ChangeIntervalInMinutes)

	// ChangeStep
	if source.ChangeStep != nil {
		changeStep := *source.ChangeStep
		rule.ChangeStep = &changeStep
	} else {
		rule.ChangeStep = nil
	}

	// MaxReroutePercentage
	if source.MaxReroutePercentage != nil {
		maxReroutePercentage := *source.MaxReroutePercentage
		rule.MaxReroutePercentage = &maxReroutePercentage
	} else {
		rule.MaxReroutePercentage = nil
	}

	// MinReroutePercentage
	if source.MinReroutePercentage != nil {
		minReroutePercentage := *source.MinReroutePercentage
		rule.MinReroutePercentage = &minReroutePercentage
	} else {
		rule.MinReroutePercentage = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// ReroutePercentage
	if source.ReroutePercentage != nil {
		reroutePercentage := *source.ReroutePercentage
		rule.ReroutePercentage = &reroutePercentage
	} else {
		rule.ReroutePercentage = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RampUpRule_STATUS populates the provided destination RampUpRule_STATUS from our RampUpRule_STATUS
func (rule *RampUpRule_STATUS) AssignProperties_To_RampUpRule_STATUS(destination *v1beta20220301s.RampUpRule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ActionHostName
	destination.ActionHostName = genruntime.ClonePointerToString(rule.ActionHostName)

	// ChangeDecisionCallbackUrl
	destination.ChangeDecisionCallbackUrl = genruntime.ClonePointerToString(rule.ChangeDecisionCallbackUrl)

	// ChangeIntervalInMinutes
	destination.ChangeIntervalInMinutes = genruntime.ClonePointerToInt(rule.ChangeIntervalInMinutes)

	// ChangeStep
	if rule.ChangeStep != nil {
		changeStep := *rule.ChangeStep
		destination.ChangeStep = &changeStep
	} else {
		destination.ChangeStep = nil
	}

	// MaxReroutePercentage
	if rule.MaxReroutePercentage != nil {
		maxReroutePercentage := *rule.MaxReroutePercentage
		destination.MaxReroutePercentage = &maxReroutePercentage
	} else {
		destination.MaxReroutePercentage = nil
	}

	// MinReroutePercentage
	if rule.MinReroutePercentage != nil {
		minReroutePercentage := *rule.MinReroutePercentage
		destination.MinReroutePercentage = &minReroutePercentage
	} else {
		destination.MinReroutePercentage = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// ReroutePercentage
	if rule.ReroutePercentage != nil {
		reroutePercentage := *rule.ReroutePercentage
		destination.ReroutePercentage = &reroutePercentage
	} else {
		destination.ReroutePercentage = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VirtualDirectory. Use v1api20220301.VirtualDirectory instead
type VirtualDirectory struct {
	PhysicalPath *string `json:"physicalPath,omitempty"`
	VirtualPath  *string `json:"virtualPath,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualDirectory{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (directory *VirtualDirectory) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if directory == nil {
		return nil, nil
	}
	result := &VirtualDirectory_ARM{}

	// Set property "PhysicalPath":
	if directory.PhysicalPath != nil {
		physicalPath := *directory.PhysicalPath
		result.PhysicalPath = &physicalPath
	}

	// Set property "VirtualPath":
	if directory.VirtualPath != nil {
		virtualPath := *directory.VirtualPath
		result.VirtualPath = &virtualPath
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (directory *VirtualDirectory) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualDirectory_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (directory *VirtualDirectory) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualDirectory_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualDirectory_ARM, got %T", armInput)
	}

	// Set property "PhysicalPath":
	if typedInput.PhysicalPath != nil {
		physicalPath := *typedInput.PhysicalPath
		directory.PhysicalPath = &physicalPath
	}

	// Set property "VirtualPath":
	if typedInput.VirtualPath != nil {
		virtualPath := *typedInput.VirtualPath
		directory.VirtualPath = &virtualPath
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualDirectory populates our VirtualDirectory from the provided source VirtualDirectory
func (directory *VirtualDirectory) AssignProperties_From_VirtualDirectory(source *v1beta20220301s.VirtualDirectory) error {

	// PhysicalPath
	directory.PhysicalPath = genruntime.ClonePointerToString(source.PhysicalPath)

	// VirtualPath
	directory.VirtualPath = genruntime.ClonePointerToString(source.VirtualPath)

	// No error
	return nil
}

// AssignProperties_To_VirtualDirectory populates the provided destination VirtualDirectory from our VirtualDirectory
func (directory *VirtualDirectory) AssignProperties_To_VirtualDirectory(destination *v1beta20220301s.VirtualDirectory) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PhysicalPath
	destination.PhysicalPath = genruntime.ClonePointerToString(directory.PhysicalPath)

	// VirtualPath
	destination.VirtualPath = genruntime.ClonePointerToString(directory.VirtualPath)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of VirtualDirectory_STATUS. Use v1api20220301.VirtualDirectory_STATUS instead
type VirtualDirectory_STATUS struct {
	PhysicalPath *string `json:"physicalPath,omitempty"`
	VirtualPath  *string `json:"virtualPath,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualDirectory_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (directory *VirtualDirectory_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualDirectory_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (directory *VirtualDirectory_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualDirectory_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualDirectory_STATUS_ARM, got %T", armInput)
	}

	// Set property "PhysicalPath":
	if typedInput.PhysicalPath != nil {
		physicalPath := *typedInput.PhysicalPath
		directory.PhysicalPath = &physicalPath
	}

	// Set property "VirtualPath":
	if typedInput.VirtualPath != nil {
		virtualPath := *typedInput.VirtualPath
		directory.VirtualPath = &virtualPath
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualDirectory_STATUS populates our VirtualDirectory_STATUS from the provided source VirtualDirectory_STATUS
func (directory *VirtualDirectory_STATUS) AssignProperties_From_VirtualDirectory_STATUS(source *v1beta20220301s.VirtualDirectory_STATUS) error {

	// PhysicalPath
	directory.PhysicalPath = genruntime.ClonePointerToString(source.PhysicalPath)

	// VirtualPath
	directory.VirtualPath = genruntime.ClonePointerToString(source.VirtualPath)

	// No error
	return nil
}

// AssignProperties_To_VirtualDirectory_STATUS populates the provided destination VirtualDirectory_STATUS from our VirtualDirectory_STATUS
func (directory *VirtualDirectory_STATUS) AssignProperties_To_VirtualDirectory_STATUS(destination *v1beta20220301s.VirtualDirectory_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PhysicalPath
	destination.PhysicalPath = genruntime.ClonePointerToString(directory.PhysicalPath)

	// VirtualPath
	destination.VirtualPath = genruntime.ClonePointerToString(directory.VirtualPath)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of AutoHealActions_ActionType. Use v1api20220301.AutoHealActions_ActionType instead
// +kubebuilder:validation:Enum={"CustomAction","LogEvent","Recycle"}
type AutoHealActions_ActionType string

const (
	AutoHealActions_ActionType_CustomAction = AutoHealActions_ActionType("CustomAction")
	AutoHealActions_ActionType_LogEvent     = AutoHealActions_ActionType("LogEvent")
	AutoHealActions_ActionType_Recycle      = AutoHealActions_ActionType("Recycle")
)

// Deprecated version of AutoHealActions_ActionType_STATUS. Use v1api20220301.AutoHealActions_ActionType_STATUS instead
type AutoHealActions_ActionType_STATUS string

const (
	AutoHealActions_ActionType_STATUS_CustomAction = AutoHealActions_ActionType_STATUS("CustomAction")
	AutoHealActions_ActionType_STATUS_LogEvent     = AutoHealActions_ActionType_STATUS("LogEvent")
	AutoHealActions_ActionType_STATUS_Recycle      = AutoHealActions_ActionType_STATUS("Recycle")
)

// Deprecated version of AutoHealCustomAction. Use v1api20220301.AutoHealCustomAction instead
type AutoHealCustomAction struct {
	Exe        *string `json:"exe,omitempty"`
	Parameters *string `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &AutoHealCustomAction{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (action *AutoHealCustomAction) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if action == nil {
		return nil, nil
	}
	result := &AutoHealCustomAction_ARM{}

	// Set property "Exe":
	if action.Exe != nil {
		exe := *action.Exe
		result.Exe = &exe
	}

	// Set property "Parameters":
	if action.Parameters != nil {
		parameters := *action.Parameters
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *AutoHealCustomAction) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AutoHealCustomAction_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *AutoHealCustomAction) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AutoHealCustomAction_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AutoHealCustomAction_ARM, got %T", armInput)
	}

	// Set property "Exe":
	if typedInput.Exe != nil {
		exe := *typedInput.Exe
		action.Exe = &exe
	}

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		parameters := *typedInput.Parameters
		action.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_AutoHealCustomAction populates our AutoHealCustomAction from the provided source AutoHealCustomAction
func (action *AutoHealCustomAction) AssignProperties_From_AutoHealCustomAction(source *v1beta20220301s.AutoHealCustomAction) error {

	// Exe
	action.Exe = genruntime.ClonePointerToString(source.Exe)

	// Parameters
	action.Parameters = genruntime.ClonePointerToString(source.Parameters)

	// No error
	return nil
}

// AssignProperties_To_AutoHealCustomAction populates the provided destination AutoHealCustomAction from our AutoHealCustomAction
func (action *AutoHealCustomAction) AssignProperties_To_AutoHealCustomAction(destination *v1beta20220301s.AutoHealCustomAction) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Exe
	destination.Exe = genruntime.ClonePointerToString(action.Exe)

	// Parameters
	destination.Parameters = genruntime.ClonePointerToString(action.Parameters)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of AutoHealCustomAction_STATUS. Use v1api20220301.AutoHealCustomAction_STATUS instead
type AutoHealCustomAction_STATUS struct {
	Exe        *string `json:"exe,omitempty"`
	Parameters *string `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &AutoHealCustomAction_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *AutoHealCustomAction_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AutoHealCustomAction_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *AutoHealCustomAction_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AutoHealCustomAction_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AutoHealCustomAction_STATUS_ARM, got %T", armInput)
	}

	// Set property "Exe":
	if typedInput.Exe != nil {
		exe := *typedInput.Exe
		action.Exe = &exe
	}

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		parameters := *typedInput.Parameters
		action.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_AutoHealCustomAction_STATUS populates our AutoHealCustomAction_STATUS from the provided source AutoHealCustomAction_STATUS
func (action *AutoHealCustomAction_STATUS) AssignProperties_From_AutoHealCustomAction_STATUS(source *v1beta20220301s.AutoHealCustomAction_STATUS) error {

	// Exe
	action.Exe = genruntime.ClonePointerToString(source.Exe)

	// Parameters
	action.Parameters = genruntime.ClonePointerToString(source.Parameters)

	// No error
	return nil
}

// AssignProperties_To_AutoHealCustomAction_STATUS populates the provided destination AutoHealCustomAction_STATUS from our AutoHealCustomAction_STATUS
func (action *AutoHealCustomAction_STATUS) AssignProperties_To_AutoHealCustomAction_STATUS(destination *v1beta20220301s.AutoHealCustomAction_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Exe
	destination.Exe = genruntime.ClonePointerToString(action.Exe)

	// Parameters
	destination.Parameters = genruntime.ClonePointerToString(action.Parameters)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of RequestsBasedTrigger. Use v1api20220301.RequestsBasedTrigger instead
type RequestsBasedTrigger struct {
	Count        *int    `json:"count,omitempty"`
	TimeInterval *string `json:"timeInterval,omitempty"`
}

var _ genruntime.ARMTransformer = &RequestsBasedTrigger{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (trigger *RequestsBasedTrigger) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if trigger == nil {
		return nil, nil
	}
	result := &RequestsBasedTrigger_ARM{}

	// Set property "Count":
	if trigger.Count != nil {
		count := *trigger.Count
		result.Count = &count
	}

	// Set property "TimeInterval":
	if trigger.TimeInterval != nil {
		timeInterval := *trigger.TimeInterval
		result.TimeInterval = &timeInterval
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (trigger *RequestsBasedTrigger) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &RequestsBasedTrigger_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (trigger *RequestsBasedTrigger) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(RequestsBasedTrigger_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected RequestsBasedTrigger_ARM, got %T", armInput)
	}

	// Set property "Count":
	if typedInput.Count != nil {
		count := *typedInput.Count
		trigger.Count = &count
	}

	// Set property "TimeInterval":
	if typedInput.TimeInterval != nil {
		timeInterval := *typedInput.TimeInterval
		trigger.TimeInterval = &timeInterval
	}

	// No error
	return nil
}

// AssignProperties_From_RequestsBasedTrigger populates our RequestsBasedTrigger from the provided source RequestsBasedTrigger
func (trigger *RequestsBasedTrigger) AssignProperties_From_RequestsBasedTrigger(source *v1beta20220301s.RequestsBasedTrigger) error {

	// Count
	trigger.Count = genruntime.ClonePointerToInt(source.Count)

	// TimeInterval
	trigger.TimeInterval = genruntime.ClonePointerToString(source.TimeInterval)

	// No error
	return nil
}

// AssignProperties_To_RequestsBasedTrigger populates the provided destination RequestsBasedTrigger from our RequestsBasedTrigger
func (trigger *RequestsBasedTrigger) AssignProperties_To_RequestsBasedTrigger(destination *v1beta20220301s.RequestsBasedTrigger) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Count
	destination.Count = genruntime.ClonePointerToInt(trigger.Count)

	// TimeInterval
	destination.TimeInterval = genruntime.ClonePointerToString(trigger.TimeInterval)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of RequestsBasedTrigger_STATUS. Use v1api20220301.RequestsBasedTrigger_STATUS instead
type RequestsBasedTrigger_STATUS struct {
	Count        *int    `json:"count,omitempty"`
	TimeInterval *string `json:"timeInterval,omitempty"`
}

var _ genruntime.FromARMConverter = &RequestsBasedTrigger_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (trigger *RequestsBasedTrigger_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &RequestsBasedTrigger_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (trigger *RequestsBasedTrigger_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(RequestsBasedTrigger_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected RequestsBasedTrigger_STATUS_ARM, got %T", armInput)
	}

	// Set property "Count":
	if typedInput.Count != nil {
		count := *typedInput.Count
		trigger.Count = &count
	}

	// Set property "TimeInterval":
	if typedInput.TimeInterval != nil {
		timeInterval := *typedInput.TimeInterval
		trigger.TimeInterval = &timeInterval
	}

	// No error
	return nil
}

// AssignProperties_From_RequestsBasedTrigger_STATUS populates our RequestsBasedTrigger_STATUS from the provided source RequestsBasedTrigger_STATUS
func (trigger *RequestsBasedTrigger_STATUS) AssignProperties_From_RequestsBasedTrigger_STATUS(source *v1beta20220301s.RequestsBasedTrigger_STATUS) error {

	// Count
	trigger.Count = genruntime.ClonePointerToInt(source.Count)

	// TimeInterval
	trigger.TimeInterval = genruntime.ClonePointerToString(source.TimeInterval)

	// No error
	return nil
}

// AssignProperties_To_RequestsBasedTrigger_STATUS populates the provided destination RequestsBasedTrigger_STATUS from our RequestsBasedTrigger_STATUS
func (trigger *RequestsBasedTrigger_STATUS) AssignProperties_To_RequestsBasedTrigger_STATUS(destination *v1beta20220301s.RequestsBasedTrigger_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Count
	destination.Count = genruntime.ClonePointerToInt(trigger.Count)

	// TimeInterval
	destination.TimeInterval = genruntime.ClonePointerToString(trigger.TimeInterval)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of SlowRequestsBasedTrigger. Use v1api20220301.SlowRequestsBasedTrigger instead
type SlowRequestsBasedTrigger struct {
	Count        *int    `json:"count,omitempty"`
	Path         *string `json:"path,omitempty"`
	TimeInterval *string `json:"timeInterval,omitempty"`
	TimeTaken    *string `json:"timeTaken,omitempty"`
}

var _ genruntime.ARMTransformer = &SlowRequestsBasedTrigger{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (trigger *SlowRequestsBasedTrigger) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if trigger == nil {
		return nil, nil
	}
	result := &SlowRequestsBasedTrigger_ARM{}

	// Set property "Count":
	if trigger.Count != nil {
		count := *trigger.Count
		result.Count = &count
	}

	// Set property "Path":
	if trigger.Path != nil {
		path := *trigger.Path
		result.Path = &path
	}

	// Set property "TimeInterval":
	if trigger.TimeInterval != nil {
		timeInterval := *trigger.TimeInterval
		result.TimeInterval = &timeInterval
	}

	// Set property "TimeTaken":
	if trigger.TimeTaken != nil {
		timeTaken := *trigger.TimeTaken
		result.TimeTaken = &timeTaken
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (trigger *SlowRequestsBasedTrigger) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SlowRequestsBasedTrigger_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (trigger *SlowRequestsBasedTrigger) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SlowRequestsBasedTrigger_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SlowRequestsBasedTrigger_ARM, got %T", armInput)
	}

	// Set property "Count":
	if typedInput.Count != nil {
		count := *typedInput.Count
		trigger.Count = &count
	}

	// Set property "Path":
	if typedInput.Path != nil {
		path := *typedInput.Path
		trigger.Path = &path
	}

	// Set property "TimeInterval":
	if typedInput.TimeInterval != nil {
		timeInterval := *typedInput.TimeInterval
		trigger.TimeInterval = &timeInterval
	}

	// Set property "TimeTaken":
	if typedInput.TimeTaken != nil {
		timeTaken := *typedInput.TimeTaken
		trigger.TimeTaken = &timeTaken
	}

	// No error
	return nil
}

// AssignProperties_From_SlowRequestsBasedTrigger populates our SlowRequestsBasedTrigger from the provided source SlowRequestsBasedTrigger
func (trigger *SlowRequestsBasedTrigger) AssignProperties_From_SlowRequestsBasedTrigger(source *v1beta20220301s.SlowRequestsBasedTrigger) error {

	// Count
	trigger.Count = genruntime.ClonePointerToInt(source.Count)

	// Path
	trigger.Path = genruntime.ClonePointerToString(source.Path)

	// TimeInterval
	trigger.TimeInterval = genruntime.ClonePointerToString(source.TimeInterval)

	// TimeTaken
	trigger.TimeTaken = genruntime.ClonePointerToString(source.TimeTaken)

	// No error
	return nil
}

// AssignProperties_To_SlowRequestsBasedTrigger populates the provided destination SlowRequestsBasedTrigger from our SlowRequestsBasedTrigger
func (trigger *SlowRequestsBasedTrigger) AssignProperties_To_SlowRequestsBasedTrigger(destination *v1beta20220301s.SlowRequestsBasedTrigger) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Count
	destination.Count = genruntime.ClonePointerToInt(trigger.Count)

	// Path
	destination.Path = genruntime.ClonePointerToString(trigger.Path)

	// TimeInterval
	destination.TimeInterval = genruntime.ClonePointerToString(trigger.TimeInterval)

	// TimeTaken
	destination.TimeTaken = genruntime.ClonePointerToString(trigger.TimeTaken)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of SlowRequestsBasedTrigger_STATUS. Use v1api20220301.SlowRequestsBasedTrigger_STATUS instead
type SlowRequestsBasedTrigger_STATUS struct {
	Count        *int    `json:"count,omitempty"`
	Path         *string `json:"path,omitempty"`
	TimeInterval *string `json:"timeInterval,omitempty"`
	TimeTaken    *string `json:"timeTaken,omitempty"`
}

var _ genruntime.FromARMConverter = &SlowRequestsBasedTrigger_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (trigger *SlowRequestsBasedTrigger_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SlowRequestsBasedTrigger_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (trigger *SlowRequestsBasedTrigger_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SlowRequestsBasedTrigger_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SlowRequestsBasedTrigger_STATUS_ARM, got %T", armInput)
	}

	// Set property "Count":
	if typedInput.Count != nil {
		count := *typedInput.Count
		trigger.Count = &count
	}

	// Set property "Path":
	if typedInput.Path != nil {
		path := *typedInput.Path
		trigger.Path = &path
	}

	// Set property "TimeInterval":
	if typedInput.TimeInterval != nil {
		timeInterval := *typedInput.TimeInterval
		trigger.TimeInterval = &timeInterval
	}

	// Set property "TimeTaken":
	if typedInput.TimeTaken != nil {
		timeTaken := *typedInput.TimeTaken
		trigger.TimeTaken = &timeTaken
	}

	// No error
	return nil
}

// AssignProperties_From_SlowRequestsBasedTrigger_STATUS populates our SlowRequestsBasedTrigger_STATUS from the provided source SlowRequestsBasedTrigger_STATUS
func (trigger *SlowRequestsBasedTrigger_STATUS) AssignProperties_From_SlowRequestsBasedTrigger_STATUS(source *v1beta20220301s.SlowRequestsBasedTrigger_STATUS) error {

	// Count
	trigger.Count = genruntime.ClonePointerToInt(source.Count)

	// Path
	trigger.Path = genruntime.ClonePointerToString(source.Path)

	// TimeInterval
	trigger.TimeInterval = genruntime.ClonePointerToString(source.TimeInterval)

	// TimeTaken
	trigger.TimeTaken = genruntime.ClonePointerToString(source.TimeTaken)

	// No error
	return nil
}

// AssignProperties_To_SlowRequestsBasedTrigger_STATUS populates the provided destination SlowRequestsBasedTrigger_STATUS from our SlowRequestsBasedTrigger_STATUS
func (trigger *SlowRequestsBasedTrigger_STATUS) AssignProperties_To_SlowRequestsBasedTrigger_STATUS(destination *v1beta20220301s.SlowRequestsBasedTrigger_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Count
	destination.Count = genruntime.ClonePointerToInt(trigger.Count)

	// Path
	destination.Path = genruntime.ClonePointerToString(trigger.Path)

	// TimeInterval
	destination.TimeInterval = genruntime.ClonePointerToString(trigger.TimeInterval)

	// TimeTaken
	destination.TimeTaken = genruntime.ClonePointerToString(trigger.TimeTaken)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of StatusCodesBasedTrigger. Use v1api20220301.StatusCodesBasedTrigger instead
type StatusCodesBasedTrigger struct {
	Count        *int    `json:"count,omitempty"`
	Path         *string `json:"path,omitempty"`
	Status       *int    `json:"status,omitempty"`
	SubStatus    *int    `json:"subStatus,omitempty"`
	TimeInterval *string `json:"timeInterval,omitempty"`
	Win32Status  *int    `json:"win32Status,omitempty"`
}

var _ genruntime.ARMTransformer = &StatusCodesBasedTrigger{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (trigger *StatusCodesBasedTrigger) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if trigger == nil {
		return nil, nil
	}
	result := &StatusCodesBasedTrigger_ARM{}

	// Set property "Count":
	if trigger.Count != nil {
		count := *trigger.Count
		result.Count = &count
	}

	// Set property "Path":
	if trigger.Path != nil {
		path := *trigger.Path
		result.Path = &path
	}

	// Set property "Status":
	if trigger.Status != nil {
		status := *trigger.Status
		result.Status = &status
	}

	// Set property "SubStatus":
	if trigger.SubStatus != nil {
		subStatus := *trigger.SubStatus
		result.SubStatus = &subStatus
	}

	// Set property "TimeInterval":
	if trigger.TimeInterval != nil {
		timeInterval := *trigger.TimeInterval
		result.TimeInterval = &timeInterval
	}

	// Set property "Win32Status":
	if trigger.Win32Status != nil {
		win32Status := *trigger.Win32Status
		result.Win32Status = &win32Status
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (trigger *StatusCodesBasedTrigger) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &StatusCodesBasedTrigger_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (trigger *StatusCodesBasedTrigger) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(StatusCodesBasedTrigger_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected StatusCodesBasedTrigger_ARM, got %T", armInput)
	}

	// Set property "Count":
	if typedInput.Count != nil {
		count := *typedInput.Count
		trigger.Count = &count
	}

	// Set property "Path":
	if typedInput.Path != nil {
		path := *typedInput.Path
		trigger.Path = &path
	}

	// Set property "Status":
	if typedInput.Status != nil {
		status := *typedInput.Status
		trigger.Status = &status
	}

	// Set property "SubStatus":
	if typedInput.SubStatus != nil {
		subStatus := *typedInput.SubStatus
		trigger.SubStatus = &subStatus
	}

	// Set property "TimeInterval":
	if typedInput.TimeInterval != nil {
		timeInterval := *typedInput.TimeInterval
		trigger.TimeInterval = &timeInterval
	}

	// Set property "Win32Status":
	if typedInput.Win32Status != nil {
		win32Status := *typedInput.Win32Status
		trigger.Win32Status = &win32Status
	}

	// No error
	return nil
}

// AssignProperties_From_StatusCodesBasedTrigger populates our StatusCodesBasedTrigger from the provided source StatusCodesBasedTrigger
func (trigger *StatusCodesBasedTrigger) AssignProperties_From_StatusCodesBasedTrigger(source *v1beta20220301s.StatusCodesBasedTrigger) error {

	// Count
	trigger.Count = genruntime.ClonePointerToInt(source.Count)

	// Path
	trigger.Path = genruntime.ClonePointerToString(source.Path)

	// Status
	trigger.Status = genruntime.ClonePointerToInt(source.Status)

	// SubStatus
	trigger.SubStatus = genruntime.ClonePointerToInt(source.SubStatus)

	// TimeInterval
	trigger.TimeInterval = genruntime.ClonePointerToString(source.TimeInterval)

	// Win32Status
	trigger.Win32Status = genruntime.ClonePointerToInt(source.Win32Status)

	// No error
	return nil
}

// AssignProperties_To_StatusCodesBasedTrigger populates the provided destination StatusCodesBasedTrigger from our StatusCodesBasedTrigger
func (trigger *StatusCodesBasedTrigger) AssignProperties_To_StatusCodesBasedTrigger(destination *v1beta20220301s.StatusCodesBasedTrigger) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Count
	destination.Count = genruntime.ClonePointerToInt(trigger.Count)

	// Path
	destination.Path = genruntime.ClonePointerToString(trigger.Path)

	// Status
	destination.Status = genruntime.ClonePointerToInt(trigger.Status)

	// SubStatus
	destination.SubStatus = genruntime.ClonePointerToInt(trigger.SubStatus)

	// TimeInterval
	destination.TimeInterval = genruntime.ClonePointerToString(trigger.TimeInterval)

	// Win32Status
	destination.Win32Status = genruntime.ClonePointerToInt(trigger.Win32Status)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of StatusCodesBasedTrigger_STATUS. Use v1api20220301.StatusCodesBasedTrigger_STATUS instead
type StatusCodesBasedTrigger_STATUS struct {
	Count        *int    `json:"count,omitempty"`
	Path         *string `json:"path,omitempty"`
	Status       *int    `json:"status,omitempty"`
	SubStatus    *int    `json:"subStatus,omitempty"`
	TimeInterval *string `json:"timeInterval,omitempty"`
	Win32Status  *int    `json:"win32Status,omitempty"`
}

var _ genruntime.FromARMConverter = &StatusCodesBasedTrigger_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (trigger *StatusCodesBasedTrigger_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &StatusCodesBasedTrigger_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (trigger *StatusCodesBasedTrigger_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(StatusCodesBasedTrigger_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected StatusCodesBasedTrigger_STATUS_ARM, got %T", armInput)
	}

	// Set property "Count":
	if typedInput.Count != nil {
		count := *typedInput.Count
		trigger.Count = &count
	}

	// Set property "Path":
	if typedInput.Path != nil {
		path := *typedInput.Path
		trigger.Path = &path
	}

	// Set property "Status":
	if typedInput.Status != nil {
		status := *typedInput.Status
		trigger.Status = &status
	}

	// Set property "SubStatus":
	if typedInput.SubStatus != nil {
		subStatus := *typedInput.SubStatus
		trigger.SubStatus = &subStatus
	}

	// Set property "TimeInterval":
	if typedInput.TimeInterval != nil {
		timeInterval := *typedInput.TimeInterval
		trigger.TimeInterval = &timeInterval
	}

	// Set property "Win32Status":
	if typedInput.Win32Status != nil {
		win32Status := *typedInput.Win32Status
		trigger.Win32Status = &win32Status
	}

	// No error
	return nil
}

// AssignProperties_From_StatusCodesBasedTrigger_STATUS populates our StatusCodesBasedTrigger_STATUS from the provided source StatusCodesBasedTrigger_STATUS
func (trigger *StatusCodesBasedTrigger_STATUS) AssignProperties_From_StatusCodesBasedTrigger_STATUS(source *v1beta20220301s.StatusCodesBasedTrigger_STATUS) error {

	// Count
	trigger.Count = genruntime.ClonePointerToInt(source.Count)

	// Path
	trigger.Path = genruntime.ClonePointerToString(source.Path)

	// Status
	trigger.Status = genruntime.ClonePointerToInt(source.Status)

	// SubStatus
	trigger.SubStatus = genruntime.ClonePointerToInt(source.SubStatus)

	// TimeInterval
	trigger.TimeInterval = genruntime.ClonePointerToString(source.TimeInterval)

	// Win32Status
	trigger.Win32Status = genruntime.ClonePointerToInt(source.Win32Status)

	// No error
	return nil
}

// AssignProperties_To_StatusCodesBasedTrigger_STATUS populates the provided destination StatusCodesBasedTrigger_STATUS from our StatusCodesBasedTrigger_STATUS
func (trigger *StatusCodesBasedTrigger_STATUS) AssignProperties_To_StatusCodesBasedTrigger_STATUS(destination *v1beta20220301s.StatusCodesBasedTrigger_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Count
	destination.Count = genruntime.ClonePointerToInt(trigger.Count)

	// Path
	destination.Path = genruntime.ClonePointerToString(trigger.Path)

	// Status
	destination.Status = genruntime.ClonePointerToInt(trigger.Status)

	// SubStatus
	destination.SubStatus = genruntime.ClonePointerToInt(trigger.SubStatus)

	// TimeInterval
	destination.TimeInterval = genruntime.ClonePointerToString(trigger.TimeInterval)

	// Win32Status
	destination.Win32Status = genruntime.ClonePointerToInt(trigger.Win32Status)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of StatusCodesRangeBasedTrigger. Use v1api20220301.StatusCodesRangeBasedTrigger instead
type StatusCodesRangeBasedTrigger struct {
	Count        *int    `json:"count,omitempty"`
	Path         *string `json:"path,omitempty"`
	StatusCodes  *string `json:"statusCodes,omitempty"`
	TimeInterval *string `json:"timeInterval,omitempty"`
}

var _ genruntime.ARMTransformer = &StatusCodesRangeBasedTrigger{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (trigger *StatusCodesRangeBasedTrigger) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if trigger == nil {
		return nil, nil
	}
	result := &StatusCodesRangeBasedTrigger_ARM{}

	// Set property "Count":
	if trigger.Count != nil {
		count := *trigger.Count
		result.Count = &count
	}

	// Set property "Path":
	if trigger.Path != nil {
		path := *trigger.Path
		result.Path = &path
	}

	// Set property "StatusCodes":
	if trigger.StatusCodes != nil {
		statusCodes := *trigger.StatusCodes
		result.StatusCodes = &statusCodes
	}

	// Set property "TimeInterval":
	if trigger.TimeInterval != nil {
		timeInterval := *trigger.TimeInterval
		result.TimeInterval = &timeInterval
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (trigger *StatusCodesRangeBasedTrigger) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &StatusCodesRangeBasedTrigger_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (trigger *StatusCodesRangeBasedTrigger) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(StatusCodesRangeBasedTrigger_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected StatusCodesRangeBasedTrigger_ARM, got %T", armInput)
	}

	// Set property "Count":
	if typedInput.Count != nil {
		count := *typedInput.Count
		trigger.Count = &count
	}

	// Set property "Path":
	if typedInput.Path != nil {
		path := *typedInput.Path
		trigger.Path = &path
	}

	// Set property "StatusCodes":
	if typedInput.StatusCodes != nil {
		statusCodes := *typedInput.StatusCodes
		trigger.StatusCodes = &statusCodes
	}

	// Set property "TimeInterval":
	if typedInput.TimeInterval != nil {
		timeInterval := *typedInput.TimeInterval
		trigger.TimeInterval = &timeInterval
	}

	// No error
	return nil
}

// AssignProperties_From_StatusCodesRangeBasedTrigger populates our StatusCodesRangeBasedTrigger from the provided source StatusCodesRangeBasedTrigger
func (trigger *StatusCodesRangeBasedTrigger) AssignProperties_From_StatusCodesRangeBasedTrigger(source *v1beta20220301s.StatusCodesRangeBasedTrigger) error {

	// Count
	trigger.Count = genruntime.ClonePointerToInt(source.Count)

	// Path
	trigger.Path = genruntime.ClonePointerToString(source.Path)

	// StatusCodes
	trigger.StatusCodes = genruntime.ClonePointerToString(source.StatusCodes)

	// TimeInterval
	trigger.TimeInterval = genruntime.ClonePointerToString(source.TimeInterval)

	// No error
	return nil
}

// AssignProperties_To_StatusCodesRangeBasedTrigger populates the provided destination StatusCodesRangeBasedTrigger from our StatusCodesRangeBasedTrigger
func (trigger *StatusCodesRangeBasedTrigger) AssignProperties_To_StatusCodesRangeBasedTrigger(destination *v1beta20220301s.StatusCodesRangeBasedTrigger) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Count
	destination.Count = genruntime.ClonePointerToInt(trigger.Count)

	// Path
	destination.Path = genruntime.ClonePointerToString(trigger.Path)

	// StatusCodes
	destination.StatusCodes = genruntime.ClonePointerToString(trigger.StatusCodes)

	// TimeInterval
	destination.TimeInterval = genruntime.ClonePointerToString(trigger.TimeInterval)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Deprecated version of StatusCodesRangeBasedTrigger_STATUS. Use v1api20220301.StatusCodesRangeBasedTrigger_STATUS instead
type StatusCodesRangeBasedTrigger_STATUS struct {
	Count        *int    `json:"count,omitempty"`
	Path         *string `json:"path,omitempty"`
	StatusCodes  *string `json:"statusCodes,omitempty"`
	TimeInterval *string `json:"timeInterval,omitempty"`
}

var _ genruntime.FromARMConverter = &StatusCodesRangeBasedTrigger_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (trigger *StatusCodesRangeBasedTrigger_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &StatusCodesRangeBasedTrigger_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (trigger *StatusCodesRangeBasedTrigger_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(StatusCodesRangeBasedTrigger_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected StatusCodesRangeBasedTrigger_STATUS_ARM, got %T", armInput)
	}

	// Set property "Count":
	if typedInput.Count != nil {
		count := *typedInput.Count
		trigger.Count = &count
	}

	// Set property "Path":
	if typedInput.Path != nil {
		path := *typedInput.Path
		trigger.Path = &path
	}

	// Set property "StatusCodes":
	if typedInput.StatusCodes != nil {
		statusCodes := *typedInput.StatusCodes
		trigger.StatusCodes = &statusCodes
	}

	// Set property "TimeInterval":
	if typedInput.TimeInterval != nil {
		timeInterval := *typedInput.TimeInterval
		trigger.TimeInterval = &timeInterval
	}

	// No error
	return nil
}

// AssignProperties_From_StatusCodesRangeBasedTrigger_STATUS populates our StatusCodesRangeBasedTrigger_STATUS from the provided source StatusCodesRangeBasedTrigger_STATUS
func (trigger *StatusCodesRangeBasedTrigger_STATUS) AssignProperties_From_StatusCodesRangeBasedTrigger_STATUS(source *v1beta20220301s.StatusCodesRangeBasedTrigger_STATUS) error {

	// Count
	trigger.Count = genruntime.ClonePointerToInt(source.Count)

	// Path
	trigger.Path = genruntime.ClonePointerToString(source.Path)

	// StatusCodes
	trigger.StatusCodes = genruntime.ClonePointerToString(source.StatusCodes)

	// TimeInterval
	trigger.TimeInterval = genruntime.ClonePointerToString(source.TimeInterval)

	// No error
	return nil
}

// AssignProperties_To_StatusCodesRangeBasedTrigger_STATUS populates the provided destination StatusCodesRangeBasedTrigger_STATUS from our StatusCodesRangeBasedTrigger_STATUS
func (trigger *StatusCodesRangeBasedTrigger_STATUS) AssignProperties_To_StatusCodesRangeBasedTrigger_STATUS(destination *v1beta20220301s.StatusCodesRangeBasedTrigger_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Count
	destination.Count = genruntime.ClonePointerToInt(trigger.Count)

	// Path
	destination.Path = genruntime.ClonePointerToString(trigger.Path)

	// StatusCodes
	destination.StatusCodes = genruntime.ClonePointerToString(trigger.StatusCodes)

	// TimeInterval
	destination.TimeInterval = genruntime.ClonePointerToString(trigger.TimeInterval)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&Site{}, &SiteList{})
}
