// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20220301

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_Site_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Site_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSite_STATUSARM, Site_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSite_STATUSARM runs a test to see if a specific instance of Site_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSite_STATUSARM(subject Site_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Site_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Site_STATUSARM instances for property testing - lazily instantiated by Site_STATUSARMGenerator()
var site_STATUSARMGenerator gopter.Gen

// Site_STATUSARMGenerator returns a generator of Site_STATUSARM instances for property testing.
// We first initialize site_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Site_STATUSARMGenerator() gopter.Gen {
	if site_STATUSARMGenerator != nil {
		return site_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSite_STATUSARM(generators)
	site_STATUSARMGenerator = gen.Struct(reflect.TypeOf(Site_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSite_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForSite_STATUSARM(generators)
	site_STATUSARMGenerator = gen.Struct(reflect.TypeOf(Site_STATUSARM{}), generators)

	return site_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForSite_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSite_STATUSARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSite_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSite_STATUSARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_STATUSARMGenerator())
	gens["Identity"] = gen.PtrOf(ManagedServiceIdentity_STATUSARMGenerator())
	gens["Properties"] = gen.PtrOf(Site_STATUS_PropertiesARMGenerator())
}

func Test_ManagedServiceIdentity_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentity_STATUSARM, ManagedServiceIdentity_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentity_STATUSARM runs a test to see if a specific instance of ManagedServiceIdentity_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentity_STATUSARM(subject ManagedServiceIdentity_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity_STATUSARM instances for property testing - lazily instantiated by
// ManagedServiceIdentity_STATUSARMGenerator()
var managedServiceIdentity_STATUSARMGenerator gopter.Gen

// ManagedServiceIdentity_STATUSARMGenerator returns a generator of ManagedServiceIdentity_STATUSARM instances for property testing.
// We first initialize managedServiceIdentity_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedServiceIdentity_STATUSARMGenerator() gopter.Gen {
	if managedServiceIdentity_STATUSARMGenerator != nil {
		return managedServiceIdentity_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity_STATUSARM(generators)
	managedServiceIdentity_STATUSARMGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForManagedServiceIdentity_STATUSARM(generators)
	managedServiceIdentity_STATUSARMGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_STATUSARM{}), generators)

	return managedServiceIdentity_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentity_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentity_STATUSARM(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ManagedServiceIdentity_STATUS_Type_None,
		ManagedServiceIdentity_STATUS_Type_SystemAssigned,
		ManagedServiceIdentity_STATUS_Type_SystemAssignedUserAssigned,
		ManagedServiceIdentity_STATUS_Type_UserAssigned))
}

// AddRelatedPropertyGeneratorsForManagedServiceIdentity_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedServiceIdentity_STATUSARM(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), UserAssignedIdentity_STATUSARMGenerator())
}

func Test_Site_STATUS_PropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Site_STATUS_PropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSite_STATUS_PropertiesARM, Site_STATUS_PropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSite_STATUS_PropertiesARM runs a test to see if a specific instance of Site_STATUS_PropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSite_STATUS_PropertiesARM(subject Site_STATUS_PropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Site_STATUS_PropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Site_STATUS_PropertiesARM instances for property testing - lazily instantiated by
// Site_STATUS_PropertiesARMGenerator()
var site_STATUS_PropertiesARMGenerator gopter.Gen

// Site_STATUS_PropertiesARMGenerator returns a generator of Site_STATUS_PropertiesARM instances for property testing.
// We first initialize site_STATUS_PropertiesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Site_STATUS_PropertiesARMGenerator() gopter.Gen {
	if site_STATUS_PropertiesARMGenerator != nil {
		return site_STATUS_PropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSite_STATUS_PropertiesARM(generators)
	site_STATUS_PropertiesARMGenerator = gen.Struct(reflect.TypeOf(Site_STATUS_PropertiesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSite_STATUS_PropertiesARM(generators)
	AddRelatedPropertyGeneratorsForSite_STATUS_PropertiesARM(generators)
	site_STATUS_PropertiesARMGenerator = gen.Struct(reflect.TypeOf(Site_STATUS_PropertiesARM{}), generators)

	return site_STATUS_PropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForSite_STATUS_PropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSite_STATUS_PropertiesARM(gens map[string]gopter.Gen) {
	gens["AvailabilityState"] = gen.PtrOf(gen.OneConstOf(Site_STATUS_Properties_AvailabilityState_DisasterRecoveryMode, Site_STATUS_Properties_AvailabilityState_Limited, Site_STATUS_Properties_AvailabilityState_Normal))
	gens["ClientAffinityEnabled"] = gen.PtrOf(gen.Bool())
	gens["ClientCertEnabled"] = gen.PtrOf(gen.Bool())
	gens["ClientCertExclusionPaths"] = gen.PtrOf(gen.AlphaString())
	gens["ClientCertMode"] = gen.PtrOf(gen.OneConstOf(Site_STATUS_Properties_ClientCertMode_Optional, Site_STATUS_Properties_ClientCertMode_OptionalInteractiveUser, Site_STATUS_Properties_ClientCertMode_Required))
	gens["ContainerSize"] = gen.PtrOf(gen.Int())
	gens["CustomDomainVerificationId"] = gen.PtrOf(gen.AlphaString())
	gens["DailyMemoryTimeQuota"] = gen.PtrOf(gen.Int())
	gens["DefaultHostName"] = gen.PtrOf(gen.AlphaString())
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["EnabledHostNames"] = gen.SliceOf(gen.AlphaString())
	gens["HostNames"] = gen.SliceOf(gen.AlphaString())
	gens["HostNamesDisabled"] = gen.PtrOf(gen.Bool())
	gens["HttpsOnly"] = gen.PtrOf(gen.Bool())
	gens["HyperV"] = gen.PtrOf(gen.Bool())
	gens["InProgressOperationId"] = gen.PtrOf(gen.AlphaString())
	gens["IsDefaultContainer"] = gen.PtrOf(gen.Bool())
	gens["IsXenon"] = gen.PtrOf(gen.Bool())
	gens["KeyVaultReferenceIdentity"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedTimeUtc"] = gen.PtrOf(gen.AlphaString())
	gens["MaxNumberOfWorkers"] = gen.PtrOf(gen.Int())
	gens["OutboundIpAddresses"] = gen.PtrOf(gen.AlphaString())
	gens["PossibleOutboundIpAddresses"] = gen.PtrOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.AlphaString())
	gens["RedundancyMode"] = gen.PtrOf(gen.OneConstOf(
		Site_STATUS_Properties_RedundancyMode_ActiveActive,
		Site_STATUS_Properties_RedundancyMode_Failover,
		Site_STATUS_Properties_RedundancyMode_GeoRedundant,
		Site_STATUS_Properties_RedundancyMode_Manual,
		Site_STATUS_Properties_RedundancyMode_None))
	gens["RepositorySiteName"] = gen.PtrOf(gen.AlphaString())
	gens["Reserved"] = gen.PtrOf(gen.Bool())
	gens["ResourceGroup"] = gen.PtrOf(gen.AlphaString())
	gens["ScmSiteAlsoStopped"] = gen.PtrOf(gen.Bool())
	gens["ServerFarmId"] = gen.PtrOf(gen.AlphaString())
	gens["State"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountRequired"] = gen.PtrOf(gen.Bool())
	gens["SuspendedTill"] = gen.PtrOf(gen.AlphaString())
	gens["TargetSwapSlot"] = gen.PtrOf(gen.AlphaString())
	gens["TrafficManagerHostNames"] = gen.SliceOf(gen.AlphaString())
	gens["UsageState"] = gen.PtrOf(gen.OneConstOf(Site_STATUS_Properties_UsageState_Exceeded, Site_STATUS_Properties_UsageState_Normal))
	gens["VirtualNetworkSubnetId"] = gen.PtrOf(gen.AlphaString())
	gens["VnetContentShareEnabled"] = gen.PtrOf(gen.Bool())
	gens["VnetImagePullEnabled"] = gen.PtrOf(gen.Bool())
	gens["VnetRouteAllEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForSite_STATUS_PropertiesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSite_STATUS_PropertiesARM(gens map[string]gopter.Gen) {
	gens["CloningInfo"] = gen.PtrOf(CloningInfo_STATUSARMGenerator())
	gens["HostNameSslStates"] = gen.SliceOf(HostNameSslState_STATUSARMGenerator())
	gens["HostingEnvironmentProfile"] = gen.PtrOf(HostingEnvironmentProfile_STATUSARMGenerator())
	gens["SiteConfig"] = gen.PtrOf(SiteConfig_STATUSARMGenerator())
	gens["SlotSwapStatus"] = gen.PtrOf(SlotSwapStatus_STATUSARMGenerator())
}

func Test_CloningInfo_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CloningInfo_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCloningInfo_STATUSARM, CloningInfo_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCloningInfo_STATUSARM runs a test to see if a specific instance of CloningInfo_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCloningInfo_STATUSARM(subject CloningInfo_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CloningInfo_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CloningInfo_STATUSARM instances for property testing - lazily instantiated by
// CloningInfo_STATUSARMGenerator()
var cloningInfo_STATUSARMGenerator gopter.Gen

// CloningInfo_STATUSARMGenerator returns a generator of CloningInfo_STATUSARM instances for property testing.
func CloningInfo_STATUSARMGenerator() gopter.Gen {
	if cloningInfo_STATUSARMGenerator != nil {
		return cloningInfo_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCloningInfo_STATUSARM(generators)
	cloningInfo_STATUSARMGenerator = gen.Struct(reflect.TypeOf(CloningInfo_STATUSARM{}), generators)

	return cloningInfo_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForCloningInfo_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCloningInfo_STATUSARM(gens map[string]gopter.Gen) {
	gens["AppSettingsOverrides"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["CloneCustomHostNames"] = gen.PtrOf(gen.Bool())
	gens["CloneSourceControl"] = gen.PtrOf(gen.Bool())
	gens["ConfigureLoadBalancing"] = gen.PtrOf(gen.Bool())
	gens["CorrelationId"] = gen.PtrOf(gen.AlphaString())
	gens["HostingEnvironment"] = gen.PtrOf(gen.AlphaString())
	gens["Overwrite"] = gen.PtrOf(gen.Bool())
	gens["SourceWebAppId"] = gen.PtrOf(gen.AlphaString())
	gens["SourceWebAppLocation"] = gen.PtrOf(gen.AlphaString())
	gens["TrafficManagerProfileId"] = gen.PtrOf(gen.AlphaString())
	gens["TrafficManagerProfileName"] = gen.PtrOf(gen.AlphaString())
}

func Test_HostNameSslState_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HostNameSslState_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHostNameSslState_STATUSARM, HostNameSslState_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHostNameSslState_STATUSARM runs a test to see if a specific instance of HostNameSslState_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHostNameSslState_STATUSARM(subject HostNameSslState_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HostNameSslState_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HostNameSslState_STATUSARM instances for property testing - lazily instantiated by
// HostNameSslState_STATUSARMGenerator()
var hostNameSslState_STATUSARMGenerator gopter.Gen

// HostNameSslState_STATUSARMGenerator returns a generator of HostNameSslState_STATUSARM instances for property testing.
func HostNameSslState_STATUSARMGenerator() gopter.Gen {
	if hostNameSslState_STATUSARMGenerator != nil {
		return hostNameSslState_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHostNameSslState_STATUSARM(generators)
	hostNameSslState_STATUSARMGenerator = gen.Struct(reflect.TypeOf(HostNameSslState_STATUSARM{}), generators)

	return hostNameSslState_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForHostNameSslState_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHostNameSslState_STATUSARM(gens map[string]gopter.Gen) {
	gens["HostType"] = gen.PtrOf(gen.OneConstOf(HostNameSslState_STATUS_HostType_Repository, HostNameSslState_STATUS_HostType_Standard))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["SslState"] = gen.PtrOf(gen.OneConstOf(HostNameSslState_STATUS_SslState_Disabled, HostNameSslState_STATUS_SslState_IpBasedEnabled, HostNameSslState_STATUS_SslState_SniEnabled))
	gens["Thumbprint"] = gen.PtrOf(gen.AlphaString())
	gens["ToUpdate"] = gen.PtrOf(gen.Bool())
	gens["VirtualIP"] = gen.PtrOf(gen.AlphaString())
}

func Test_SiteConfig_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SiteConfig_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSiteConfig_STATUSARM, SiteConfig_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSiteConfig_STATUSARM runs a test to see if a specific instance of SiteConfig_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSiteConfig_STATUSARM(subject SiteConfig_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SiteConfig_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SiteConfig_STATUSARM instances for property testing - lazily instantiated by
// SiteConfig_STATUSARMGenerator()
var siteConfig_STATUSARMGenerator gopter.Gen

// SiteConfig_STATUSARMGenerator returns a generator of SiteConfig_STATUSARM instances for property testing.
func SiteConfig_STATUSARMGenerator() gopter.Gen {
	if siteConfig_STATUSARMGenerator != nil {
		return siteConfig_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForSiteConfig_STATUSARM(generators)
	siteConfig_STATUSARMGenerator = gen.Struct(reflect.TypeOf(SiteConfig_STATUSARM{}), generators)

	return siteConfig_STATUSARMGenerator
}

// AddRelatedPropertyGeneratorsForSiteConfig_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSiteConfig_STATUSARM(gens map[string]gopter.Gen) {
	gens["ApiDefinition"] = gen.PtrOf(ApiDefinitionInfo_STATUSARMGenerator())
	gens["ApiManagementConfig"] = gen.PtrOf(ApiManagementConfig_STATUSARMGenerator())
	gens["AppSettings"] = gen.SliceOf(NameValuePair_STATUSARMGenerator())
	gens["AutoHealRules"] = gen.PtrOf(AutoHealRules_STATUSARMGenerator())
	gens["AzureStorageAccounts"] = gen.MapOf(gen.AlphaString(), AzureStorageInfoValue_STATUSARMGenerator())
	gens["ConnectionStrings"] = gen.SliceOf(ConnStringInfo_STATUSARMGenerator())
	gens["Cors"] = gen.PtrOf(CorsSettings_STATUSARMGenerator())
	gens["Experiments"] = gen.PtrOf(Experiments_STATUSARMGenerator())
	gens["HandlerMappings"] = gen.SliceOf(HandlerMapping_STATUSARMGenerator())
	gens["IpSecurityRestrictions"] = gen.SliceOf(IpSecurityRestriction_STATUSARMGenerator())
	gens["Limits"] = gen.PtrOf(SiteLimits_STATUSARMGenerator())
	gens["MachineKey"] = gen.PtrOf(SiteMachineKey_STATUSARMGenerator())
	gens["Push"] = gen.PtrOf(PushSettings_STATUSARMGenerator())
	gens["ScmIpSecurityRestrictions"] = gen.SliceOf(IpSecurityRestriction_STATUSARMGenerator())
	gens["VirtualApplications"] = gen.SliceOf(VirtualApplication_STATUSARMGenerator())
}

func Test_SlotSwapStatus_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SlotSwapStatus_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSlotSwapStatus_STATUSARM, SlotSwapStatus_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSlotSwapStatus_STATUSARM runs a test to see if a specific instance of SlotSwapStatus_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSlotSwapStatus_STATUSARM(subject SlotSwapStatus_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SlotSwapStatus_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SlotSwapStatus_STATUSARM instances for property testing - lazily instantiated by
// SlotSwapStatus_STATUSARMGenerator()
var slotSwapStatus_STATUSARMGenerator gopter.Gen

// SlotSwapStatus_STATUSARMGenerator returns a generator of SlotSwapStatus_STATUSARM instances for property testing.
func SlotSwapStatus_STATUSARMGenerator() gopter.Gen {
	if slotSwapStatus_STATUSARMGenerator != nil {
		return slotSwapStatus_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSlotSwapStatus_STATUSARM(generators)
	slotSwapStatus_STATUSARMGenerator = gen.Struct(reflect.TypeOf(SlotSwapStatus_STATUSARM{}), generators)

	return slotSwapStatus_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForSlotSwapStatus_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSlotSwapStatus_STATUSARM(gens map[string]gopter.Gen) {
	gens["DestinationSlotName"] = gen.PtrOf(gen.AlphaString())
	gens["SourceSlotName"] = gen.PtrOf(gen.AlphaString())
	gens["TimestampUtc"] = gen.PtrOf(gen.AlphaString())
}

func Test_UserAssignedIdentity_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentity_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentity_STATUSARM, UserAssignedIdentity_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentity_STATUSARM runs a test to see if a specific instance of UserAssignedIdentity_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentity_STATUSARM(subject UserAssignedIdentity_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentity_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentity_STATUSARM instances for property testing - lazily instantiated by
// UserAssignedIdentity_STATUSARMGenerator()
var userAssignedIdentity_STATUSARMGenerator gopter.Gen

// UserAssignedIdentity_STATUSARMGenerator returns a generator of UserAssignedIdentity_STATUSARM instances for property testing.
func UserAssignedIdentity_STATUSARMGenerator() gopter.Gen {
	if userAssignedIdentity_STATUSARMGenerator != nil {
		return userAssignedIdentity_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserAssignedIdentity_STATUSARM(generators)
	userAssignedIdentity_STATUSARMGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentity_STATUSARM{}), generators)

	return userAssignedIdentity_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForUserAssignedIdentity_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserAssignedIdentity_STATUSARM(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_ApiDefinitionInfo_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiDefinitionInfo_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiDefinitionInfo_STATUSARM, ApiDefinitionInfo_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiDefinitionInfo_STATUSARM runs a test to see if a specific instance of ApiDefinitionInfo_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForApiDefinitionInfo_STATUSARM(subject ApiDefinitionInfo_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiDefinitionInfo_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiDefinitionInfo_STATUSARM instances for property testing - lazily instantiated by
// ApiDefinitionInfo_STATUSARMGenerator()
var apiDefinitionInfo_STATUSARMGenerator gopter.Gen

// ApiDefinitionInfo_STATUSARMGenerator returns a generator of ApiDefinitionInfo_STATUSARM instances for property testing.
func ApiDefinitionInfo_STATUSARMGenerator() gopter.Gen {
	if apiDefinitionInfo_STATUSARMGenerator != nil {
		return apiDefinitionInfo_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiDefinitionInfo_STATUSARM(generators)
	apiDefinitionInfo_STATUSARMGenerator = gen.Struct(reflect.TypeOf(ApiDefinitionInfo_STATUSARM{}), generators)

	return apiDefinitionInfo_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForApiDefinitionInfo_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiDefinitionInfo_STATUSARM(gens map[string]gopter.Gen) {
	gens["Url"] = gen.PtrOf(gen.AlphaString())
}

func Test_ApiManagementConfig_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiManagementConfig_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiManagementConfig_STATUSARM, ApiManagementConfig_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiManagementConfig_STATUSARM runs a test to see if a specific instance of ApiManagementConfig_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForApiManagementConfig_STATUSARM(subject ApiManagementConfig_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiManagementConfig_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiManagementConfig_STATUSARM instances for property testing - lazily instantiated by
// ApiManagementConfig_STATUSARMGenerator()
var apiManagementConfig_STATUSARMGenerator gopter.Gen

// ApiManagementConfig_STATUSARMGenerator returns a generator of ApiManagementConfig_STATUSARM instances for property testing.
func ApiManagementConfig_STATUSARMGenerator() gopter.Gen {
	if apiManagementConfig_STATUSARMGenerator != nil {
		return apiManagementConfig_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiManagementConfig_STATUSARM(generators)
	apiManagementConfig_STATUSARMGenerator = gen.Struct(reflect.TypeOf(ApiManagementConfig_STATUSARM{}), generators)

	return apiManagementConfig_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForApiManagementConfig_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiManagementConfig_STATUSARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_AutoHealRules_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoHealRules_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoHealRules_STATUSARM, AutoHealRules_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoHealRules_STATUSARM runs a test to see if a specific instance of AutoHealRules_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoHealRules_STATUSARM(subject AutoHealRules_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoHealRules_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoHealRules_STATUSARM instances for property testing - lazily instantiated by
// AutoHealRules_STATUSARMGenerator()
var autoHealRules_STATUSARMGenerator gopter.Gen

// AutoHealRules_STATUSARMGenerator returns a generator of AutoHealRules_STATUSARM instances for property testing.
func AutoHealRules_STATUSARMGenerator() gopter.Gen {
	if autoHealRules_STATUSARMGenerator != nil {
		return autoHealRules_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForAutoHealRules_STATUSARM(generators)
	autoHealRules_STATUSARMGenerator = gen.Struct(reflect.TypeOf(AutoHealRules_STATUSARM{}), generators)

	return autoHealRules_STATUSARMGenerator
}

// AddRelatedPropertyGeneratorsForAutoHealRules_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoHealRules_STATUSARM(gens map[string]gopter.Gen) {
	gens["Actions"] = gen.PtrOf(AutoHealActions_STATUSARMGenerator())
	gens["Triggers"] = gen.PtrOf(AutoHealTriggers_STATUSARMGenerator())
}

func Test_AzureStorageInfoValue_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureStorageInfoValue_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureStorageInfoValue_STATUSARM, AzureStorageInfoValue_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureStorageInfoValue_STATUSARM runs a test to see if a specific instance of AzureStorageInfoValue_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureStorageInfoValue_STATUSARM(subject AzureStorageInfoValue_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureStorageInfoValue_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureStorageInfoValue_STATUSARM instances for property testing - lazily instantiated by
// AzureStorageInfoValue_STATUSARMGenerator()
var azureStorageInfoValue_STATUSARMGenerator gopter.Gen

// AzureStorageInfoValue_STATUSARMGenerator returns a generator of AzureStorageInfoValue_STATUSARM instances for property testing.
func AzureStorageInfoValue_STATUSARMGenerator() gopter.Gen {
	if azureStorageInfoValue_STATUSARMGenerator != nil {
		return azureStorageInfoValue_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureStorageInfoValue_STATUSARM(generators)
	azureStorageInfoValue_STATUSARMGenerator = gen.Struct(reflect.TypeOf(AzureStorageInfoValue_STATUSARM{}), generators)

	return azureStorageInfoValue_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForAzureStorageInfoValue_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureStorageInfoValue_STATUSARM(gens map[string]gopter.Gen) {
	gens["AccountName"] = gen.PtrOf(gen.AlphaString())
	gens["MountPath"] = gen.PtrOf(gen.AlphaString())
	gens["ShareName"] = gen.PtrOf(gen.AlphaString())
	gens["State"] = gen.PtrOf(gen.OneConstOf(
		AzureStorageInfoValue_STATUS_State_InvalidCredentials,
		AzureStorageInfoValue_STATUS_State_InvalidShare,
		AzureStorageInfoValue_STATUS_State_NotValidated,
		AzureStorageInfoValue_STATUS_State_Ok))
	gens["Type"] = gen.PtrOf(gen.OneConstOf(AzureStorageInfoValue_STATUS_Type_AzureBlob, AzureStorageInfoValue_STATUS_Type_AzureFiles))
}

func Test_ConnStringInfo_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ConnStringInfo_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForConnStringInfo_STATUSARM, ConnStringInfo_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForConnStringInfo_STATUSARM runs a test to see if a specific instance of ConnStringInfo_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForConnStringInfo_STATUSARM(subject ConnStringInfo_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ConnStringInfo_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ConnStringInfo_STATUSARM instances for property testing - lazily instantiated by
// ConnStringInfo_STATUSARMGenerator()
var connStringInfo_STATUSARMGenerator gopter.Gen

// ConnStringInfo_STATUSARMGenerator returns a generator of ConnStringInfo_STATUSARM instances for property testing.
func ConnStringInfo_STATUSARMGenerator() gopter.Gen {
	if connStringInfo_STATUSARMGenerator != nil {
		return connStringInfo_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForConnStringInfo_STATUSARM(generators)
	connStringInfo_STATUSARMGenerator = gen.Struct(reflect.TypeOf(ConnStringInfo_STATUSARM{}), generators)

	return connStringInfo_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForConnStringInfo_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForConnStringInfo_STATUSARM(gens map[string]gopter.Gen) {
	gens["ConnectionString"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ConnStringInfo_STATUS_Type_ApiHub,
		ConnStringInfo_STATUS_Type_Custom,
		ConnStringInfo_STATUS_Type_DocDb,
		ConnStringInfo_STATUS_Type_EventHub,
		ConnStringInfo_STATUS_Type_MySql,
		ConnStringInfo_STATUS_Type_NotificationHub,
		ConnStringInfo_STATUS_Type_PostgreSQL,
		ConnStringInfo_STATUS_Type_RedisCache,
		ConnStringInfo_STATUS_Type_SQLAzure,
		ConnStringInfo_STATUS_Type_SQLServer,
		ConnStringInfo_STATUS_Type_ServiceBus))
}

func Test_CorsSettings_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CorsSettings_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCorsSettings_STATUSARM, CorsSettings_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCorsSettings_STATUSARM runs a test to see if a specific instance of CorsSettings_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCorsSettings_STATUSARM(subject CorsSettings_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CorsSettings_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CorsSettings_STATUSARM instances for property testing - lazily instantiated by
// CorsSettings_STATUSARMGenerator()
var corsSettings_STATUSARMGenerator gopter.Gen

// CorsSettings_STATUSARMGenerator returns a generator of CorsSettings_STATUSARM instances for property testing.
func CorsSettings_STATUSARMGenerator() gopter.Gen {
	if corsSettings_STATUSARMGenerator != nil {
		return corsSettings_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCorsSettings_STATUSARM(generators)
	corsSettings_STATUSARMGenerator = gen.Struct(reflect.TypeOf(CorsSettings_STATUSARM{}), generators)

	return corsSettings_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForCorsSettings_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCorsSettings_STATUSARM(gens map[string]gopter.Gen) {
	gens["AllowedOrigins"] = gen.SliceOf(gen.AlphaString())
	gens["SupportCredentials"] = gen.PtrOf(gen.Bool())
}

func Test_Experiments_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Experiments_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExperiments_STATUSARM, Experiments_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExperiments_STATUSARM runs a test to see if a specific instance of Experiments_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForExperiments_STATUSARM(subject Experiments_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Experiments_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Experiments_STATUSARM instances for property testing - lazily instantiated by
// Experiments_STATUSARMGenerator()
var experiments_STATUSARMGenerator gopter.Gen

// Experiments_STATUSARMGenerator returns a generator of Experiments_STATUSARM instances for property testing.
func Experiments_STATUSARMGenerator() gopter.Gen {
	if experiments_STATUSARMGenerator != nil {
		return experiments_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForExperiments_STATUSARM(generators)
	experiments_STATUSARMGenerator = gen.Struct(reflect.TypeOf(Experiments_STATUSARM{}), generators)

	return experiments_STATUSARMGenerator
}

// AddRelatedPropertyGeneratorsForExperiments_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForExperiments_STATUSARM(gens map[string]gopter.Gen) {
	gens["RampUpRules"] = gen.SliceOf(RampUpRule_STATUSARMGenerator())
}

func Test_HandlerMapping_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HandlerMapping_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHandlerMapping_STATUSARM, HandlerMapping_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHandlerMapping_STATUSARM runs a test to see if a specific instance of HandlerMapping_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHandlerMapping_STATUSARM(subject HandlerMapping_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HandlerMapping_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HandlerMapping_STATUSARM instances for property testing - lazily instantiated by
// HandlerMapping_STATUSARMGenerator()
var handlerMapping_STATUSARMGenerator gopter.Gen

// HandlerMapping_STATUSARMGenerator returns a generator of HandlerMapping_STATUSARM instances for property testing.
func HandlerMapping_STATUSARMGenerator() gopter.Gen {
	if handlerMapping_STATUSARMGenerator != nil {
		return handlerMapping_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHandlerMapping_STATUSARM(generators)
	handlerMapping_STATUSARMGenerator = gen.Struct(reflect.TypeOf(HandlerMapping_STATUSARM{}), generators)

	return handlerMapping_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForHandlerMapping_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHandlerMapping_STATUSARM(gens map[string]gopter.Gen) {
	gens["Arguments"] = gen.PtrOf(gen.AlphaString())
	gens["Extension"] = gen.PtrOf(gen.AlphaString())
	gens["ScriptProcessor"] = gen.PtrOf(gen.AlphaString())
}

func Test_IpSecurityRestriction_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpSecurityRestriction_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpSecurityRestriction_STATUSARM, IpSecurityRestriction_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpSecurityRestriction_STATUSARM runs a test to see if a specific instance of IpSecurityRestriction_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIpSecurityRestriction_STATUSARM(subject IpSecurityRestriction_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpSecurityRestriction_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpSecurityRestriction_STATUSARM instances for property testing - lazily instantiated by
// IpSecurityRestriction_STATUSARMGenerator()
var ipSecurityRestriction_STATUSARMGenerator gopter.Gen

// IpSecurityRestriction_STATUSARMGenerator returns a generator of IpSecurityRestriction_STATUSARM instances for property testing.
func IpSecurityRestriction_STATUSARMGenerator() gopter.Gen {
	if ipSecurityRestriction_STATUSARMGenerator != nil {
		return ipSecurityRestriction_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpSecurityRestriction_STATUSARM(generators)
	ipSecurityRestriction_STATUSARMGenerator = gen.Struct(reflect.TypeOf(IpSecurityRestriction_STATUSARM{}), generators)

	return ipSecurityRestriction_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForIpSecurityRestriction_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpSecurityRestriction_STATUSARM(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.AlphaString())
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["Headers"] = gen.MapOf(gen.AlphaString(), gen.SliceOf(gen.AlphaString()))
	gens["IpAddress"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Priority"] = gen.PtrOf(gen.Int())
	gens["SubnetMask"] = gen.PtrOf(gen.AlphaString())
	gens["SubnetTrafficTag"] = gen.PtrOf(gen.Int())
	gens["Tag"] = gen.PtrOf(gen.OneConstOf(IpSecurityRestriction_STATUS_Tag_Default, IpSecurityRestriction_STATUS_Tag_ServiceTag, IpSecurityRestriction_STATUS_Tag_XffProxy))
	gens["VnetSubnetResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["VnetTrafficTag"] = gen.PtrOf(gen.Int())
}

func Test_NameValuePair_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NameValuePair_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNameValuePair_STATUSARM, NameValuePair_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNameValuePair_STATUSARM runs a test to see if a specific instance of NameValuePair_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNameValuePair_STATUSARM(subject NameValuePair_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NameValuePair_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NameValuePair_STATUSARM instances for property testing - lazily instantiated by
// NameValuePair_STATUSARMGenerator()
var nameValuePair_STATUSARMGenerator gopter.Gen

// NameValuePair_STATUSARMGenerator returns a generator of NameValuePair_STATUSARM instances for property testing.
func NameValuePair_STATUSARMGenerator() gopter.Gen {
	if nameValuePair_STATUSARMGenerator != nil {
		return nameValuePair_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNameValuePair_STATUSARM(generators)
	nameValuePair_STATUSARMGenerator = gen.Struct(reflect.TypeOf(NameValuePair_STATUSARM{}), generators)

	return nameValuePair_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForNameValuePair_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNameValuePair_STATUSARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_PushSettings_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PushSettings_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPushSettings_STATUSARM, PushSettings_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPushSettings_STATUSARM runs a test to see if a specific instance of PushSettings_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPushSettings_STATUSARM(subject PushSettings_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PushSettings_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PushSettings_STATUSARM instances for property testing - lazily instantiated by
// PushSettings_STATUSARMGenerator()
var pushSettings_STATUSARMGenerator gopter.Gen

// PushSettings_STATUSARMGenerator returns a generator of PushSettings_STATUSARM instances for property testing.
// We first initialize pushSettings_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PushSettings_STATUSARMGenerator() gopter.Gen {
	if pushSettings_STATUSARMGenerator != nil {
		return pushSettings_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPushSettings_STATUSARM(generators)
	pushSettings_STATUSARMGenerator = gen.Struct(reflect.TypeOf(PushSettings_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPushSettings_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForPushSettings_STATUSARM(generators)
	pushSettings_STATUSARMGenerator = gen.Struct(reflect.TypeOf(PushSettings_STATUSARM{}), generators)

	return pushSettings_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForPushSettings_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPushSettings_STATUSARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPushSettings_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPushSettings_STATUSARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(PushSettings_STATUS_PropertiesARMGenerator())
}

func Test_SiteLimits_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SiteLimits_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSiteLimits_STATUSARM, SiteLimits_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSiteLimits_STATUSARM runs a test to see if a specific instance of SiteLimits_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSiteLimits_STATUSARM(subject SiteLimits_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SiteLimits_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SiteLimits_STATUSARM instances for property testing - lazily instantiated by
// SiteLimits_STATUSARMGenerator()
var siteLimits_STATUSARMGenerator gopter.Gen

// SiteLimits_STATUSARMGenerator returns a generator of SiteLimits_STATUSARM instances for property testing.
func SiteLimits_STATUSARMGenerator() gopter.Gen {
	if siteLimits_STATUSARMGenerator != nil {
		return siteLimits_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSiteLimits_STATUSARM(generators)
	siteLimits_STATUSARMGenerator = gen.Struct(reflect.TypeOf(SiteLimits_STATUSARM{}), generators)

	return siteLimits_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForSiteLimits_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSiteLimits_STATUSARM(gens map[string]gopter.Gen) {
	gens["MaxDiskSizeInMb"] = gen.PtrOf(gen.Int())
	gens["MaxMemoryInMb"] = gen.PtrOf(gen.Int())
	gens["MaxPercentageCpu"] = gen.PtrOf(gen.Float64())
}

func Test_SiteMachineKey_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SiteMachineKey_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSiteMachineKey_STATUSARM, SiteMachineKey_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSiteMachineKey_STATUSARM runs a test to see if a specific instance of SiteMachineKey_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSiteMachineKey_STATUSARM(subject SiteMachineKey_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SiteMachineKey_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SiteMachineKey_STATUSARM instances for property testing - lazily instantiated by
// SiteMachineKey_STATUSARMGenerator()
var siteMachineKey_STATUSARMGenerator gopter.Gen

// SiteMachineKey_STATUSARMGenerator returns a generator of SiteMachineKey_STATUSARM instances for property testing.
func SiteMachineKey_STATUSARMGenerator() gopter.Gen {
	if siteMachineKey_STATUSARMGenerator != nil {
		return siteMachineKey_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSiteMachineKey_STATUSARM(generators)
	siteMachineKey_STATUSARMGenerator = gen.Struct(reflect.TypeOf(SiteMachineKey_STATUSARM{}), generators)

	return siteMachineKey_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForSiteMachineKey_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSiteMachineKey_STATUSARM(gens map[string]gopter.Gen) {
	gens["Decryption"] = gen.PtrOf(gen.AlphaString())
	gens["DecryptionKey"] = gen.PtrOf(gen.AlphaString())
	gens["Validation"] = gen.PtrOf(gen.AlphaString())
	gens["ValidationKey"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualApplication_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualApplication_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualApplication_STATUSARM, VirtualApplication_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualApplication_STATUSARM runs a test to see if a specific instance of VirtualApplication_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualApplication_STATUSARM(subject VirtualApplication_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualApplication_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualApplication_STATUSARM instances for property testing - lazily instantiated by
// VirtualApplication_STATUSARMGenerator()
var virtualApplication_STATUSARMGenerator gopter.Gen

// VirtualApplication_STATUSARMGenerator returns a generator of VirtualApplication_STATUSARM instances for property testing.
// We first initialize virtualApplication_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualApplication_STATUSARMGenerator() gopter.Gen {
	if virtualApplication_STATUSARMGenerator != nil {
		return virtualApplication_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualApplication_STATUSARM(generators)
	virtualApplication_STATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualApplication_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualApplication_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForVirtualApplication_STATUSARM(generators)
	virtualApplication_STATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualApplication_STATUSARM{}), generators)

	return virtualApplication_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualApplication_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualApplication_STATUSARM(gens map[string]gopter.Gen) {
	gens["PhysicalPath"] = gen.PtrOf(gen.AlphaString())
	gens["PreloadEnabled"] = gen.PtrOf(gen.Bool())
	gens["VirtualPath"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualApplication_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualApplication_STATUSARM(gens map[string]gopter.Gen) {
	gens["VirtualDirectories"] = gen.SliceOf(VirtualDirectory_STATUSARMGenerator())
}

func Test_AutoHealActions_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoHealActions_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoHealActions_STATUSARM, AutoHealActions_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoHealActions_STATUSARM runs a test to see if a specific instance of AutoHealActions_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoHealActions_STATUSARM(subject AutoHealActions_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoHealActions_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoHealActions_STATUSARM instances for property testing - lazily instantiated by
// AutoHealActions_STATUSARMGenerator()
var autoHealActions_STATUSARMGenerator gopter.Gen

// AutoHealActions_STATUSARMGenerator returns a generator of AutoHealActions_STATUSARM instances for property testing.
// We first initialize autoHealActions_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AutoHealActions_STATUSARMGenerator() gopter.Gen {
	if autoHealActions_STATUSARMGenerator != nil {
		return autoHealActions_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoHealActions_STATUSARM(generators)
	autoHealActions_STATUSARMGenerator = gen.Struct(reflect.TypeOf(AutoHealActions_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoHealActions_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForAutoHealActions_STATUSARM(generators)
	autoHealActions_STATUSARMGenerator = gen.Struct(reflect.TypeOf(AutoHealActions_STATUSARM{}), generators)

	return autoHealActions_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForAutoHealActions_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoHealActions_STATUSARM(gens map[string]gopter.Gen) {
	gens["ActionType"] = gen.PtrOf(gen.OneConstOf(AutoHealActions_STATUS_ActionType_CustomAction, AutoHealActions_STATUS_ActionType_LogEvent, AutoHealActions_STATUS_ActionType_Recycle))
	gens["MinProcessExecutionTime"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAutoHealActions_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoHealActions_STATUSARM(gens map[string]gopter.Gen) {
	gens["CustomAction"] = gen.PtrOf(AutoHealCustomAction_STATUSARMGenerator())
}

func Test_AutoHealTriggers_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoHealTriggers_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoHealTriggers_STATUSARM, AutoHealTriggers_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoHealTriggers_STATUSARM runs a test to see if a specific instance of AutoHealTriggers_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoHealTriggers_STATUSARM(subject AutoHealTriggers_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoHealTriggers_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoHealTriggers_STATUSARM instances for property testing - lazily instantiated by
// AutoHealTriggers_STATUSARMGenerator()
var autoHealTriggers_STATUSARMGenerator gopter.Gen

// AutoHealTriggers_STATUSARMGenerator returns a generator of AutoHealTriggers_STATUSARM instances for property testing.
// We first initialize autoHealTriggers_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AutoHealTriggers_STATUSARMGenerator() gopter.Gen {
	if autoHealTriggers_STATUSARMGenerator != nil {
		return autoHealTriggers_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoHealTriggers_STATUSARM(generators)
	autoHealTriggers_STATUSARMGenerator = gen.Struct(reflect.TypeOf(AutoHealTriggers_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoHealTriggers_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForAutoHealTriggers_STATUSARM(generators)
	autoHealTriggers_STATUSARMGenerator = gen.Struct(reflect.TypeOf(AutoHealTriggers_STATUSARM{}), generators)

	return autoHealTriggers_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForAutoHealTriggers_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoHealTriggers_STATUSARM(gens map[string]gopter.Gen) {
	gens["PrivateBytesInKB"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForAutoHealTriggers_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoHealTriggers_STATUSARM(gens map[string]gopter.Gen) {
	gens["Requests"] = gen.PtrOf(RequestsBasedTrigger_STATUSARMGenerator())
	gens["SlowRequests"] = gen.PtrOf(SlowRequestsBasedTrigger_STATUSARMGenerator())
	gens["SlowRequestsWithPath"] = gen.SliceOf(SlowRequestsBasedTrigger_STATUSARMGenerator())
	gens["StatusCodes"] = gen.SliceOf(StatusCodesBasedTrigger_STATUSARMGenerator())
	gens["StatusCodesRange"] = gen.SliceOf(StatusCodesRangeBasedTrigger_STATUSARMGenerator())
}

func Test_PushSettings_STATUS_PropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PushSettings_STATUS_PropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPushSettings_STATUS_PropertiesARM, PushSettings_STATUS_PropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPushSettings_STATUS_PropertiesARM runs a test to see if a specific instance of PushSettings_STATUS_PropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPushSettings_STATUS_PropertiesARM(subject PushSettings_STATUS_PropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PushSettings_STATUS_PropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PushSettings_STATUS_PropertiesARM instances for property testing - lazily instantiated by
// PushSettings_STATUS_PropertiesARMGenerator()
var pushSettings_STATUS_PropertiesARMGenerator gopter.Gen

// PushSettings_STATUS_PropertiesARMGenerator returns a generator of PushSettings_STATUS_PropertiesARM instances for property testing.
func PushSettings_STATUS_PropertiesARMGenerator() gopter.Gen {
	if pushSettings_STATUS_PropertiesARMGenerator != nil {
		return pushSettings_STATUS_PropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPushSettings_STATUS_PropertiesARM(generators)
	pushSettings_STATUS_PropertiesARMGenerator = gen.Struct(reflect.TypeOf(PushSettings_STATUS_PropertiesARM{}), generators)

	return pushSettings_STATUS_PropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForPushSettings_STATUS_PropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPushSettings_STATUS_PropertiesARM(gens map[string]gopter.Gen) {
	gens["DynamicTagsJson"] = gen.PtrOf(gen.AlphaString())
	gens["IsPushEnabled"] = gen.PtrOf(gen.Bool())
	gens["TagWhitelistJson"] = gen.PtrOf(gen.AlphaString())
	gens["TagsRequiringAuth"] = gen.PtrOf(gen.AlphaString())
}

func Test_RampUpRule_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RampUpRule_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRampUpRule_STATUSARM, RampUpRule_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRampUpRule_STATUSARM runs a test to see if a specific instance of RampUpRule_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRampUpRule_STATUSARM(subject RampUpRule_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RampUpRule_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RampUpRule_STATUSARM instances for property testing - lazily instantiated by
// RampUpRule_STATUSARMGenerator()
var rampUpRule_STATUSARMGenerator gopter.Gen

// RampUpRule_STATUSARMGenerator returns a generator of RampUpRule_STATUSARM instances for property testing.
func RampUpRule_STATUSARMGenerator() gopter.Gen {
	if rampUpRule_STATUSARMGenerator != nil {
		return rampUpRule_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRampUpRule_STATUSARM(generators)
	rampUpRule_STATUSARMGenerator = gen.Struct(reflect.TypeOf(RampUpRule_STATUSARM{}), generators)

	return rampUpRule_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForRampUpRule_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRampUpRule_STATUSARM(gens map[string]gopter.Gen) {
	gens["ActionHostName"] = gen.PtrOf(gen.AlphaString())
	gens["ChangeDecisionCallbackUrl"] = gen.PtrOf(gen.AlphaString())
	gens["ChangeIntervalInMinutes"] = gen.PtrOf(gen.Int())
	gens["ChangeStep"] = gen.PtrOf(gen.Float64())
	gens["MaxReroutePercentage"] = gen.PtrOf(gen.Float64())
	gens["MinReroutePercentage"] = gen.PtrOf(gen.Float64())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ReroutePercentage"] = gen.PtrOf(gen.Float64())
}

func Test_VirtualDirectory_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualDirectory_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualDirectory_STATUSARM, VirtualDirectory_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualDirectory_STATUSARM runs a test to see if a specific instance of VirtualDirectory_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualDirectory_STATUSARM(subject VirtualDirectory_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualDirectory_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualDirectory_STATUSARM instances for property testing - lazily instantiated by
// VirtualDirectory_STATUSARMGenerator()
var virtualDirectory_STATUSARMGenerator gopter.Gen

// VirtualDirectory_STATUSARMGenerator returns a generator of VirtualDirectory_STATUSARM instances for property testing.
func VirtualDirectory_STATUSARMGenerator() gopter.Gen {
	if virtualDirectory_STATUSARMGenerator != nil {
		return virtualDirectory_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualDirectory_STATUSARM(generators)
	virtualDirectory_STATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualDirectory_STATUSARM{}), generators)

	return virtualDirectory_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualDirectory_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualDirectory_STATUSARM(gens map[string]gopter.Gen) {
	gens["PhysicalPath"] = gen.PtrOf(gen.AlphaString())
	gens["VirtualPath"] = gen.PtrOf(gen.AlphaString())
}

func Test_AutoHealCustomAction_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoHealCustomAction_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoHealCustomAction_STATUSARM, AutoHealCustomAction_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoHealCustomAction_STATUSARM runs a test to see if a specific instance of AutoHealCustomAction_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoHealCustomAction_STATUSARM(subject AutoHealCustomAction_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoHealCustomAction_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoHealCustomAction_STATUSARM instances for property testing - lazily instantiated by
// AutoHealCustomAction_STATUSARMGenerator()
var autoHealCustomAction_STATUSARMGenerator gopter.Gen

// AutoHealCustomAction_STATUSARMGenerator returns a generator of AutoHealCustomAction_STATUSARM instances for property testing.
func AutoHealCustomAction_STATUSARMGenerator() gopter.Gen {
	if autoHealCustomAction_STATUSARMGenerator != nil {
		return autoHealCustomAction_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoHealCustomAction_STATUSARM(generators)
	autoHealCustomAction_STATUSARMGenerator = gen.Struct(reflect.TypeOf(AutoHealCustomAction_STATUSARM{}), generators)

	return autoHealCustomAction_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForAutoHealCustomAction_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoHealCustomAction_STATUSARM(gens map[string]gopter.Gen) {
	gens["Exe"] = gen.PtrOf(gen.AlphaString())
	gens["Parameters"] = gen.PtrOf(gen.AlphaString())
}

func Test_RequestsBasedTrigger_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RequestsBasedTrigger_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRequestsBasedTrigger_STATUSARM, RequestsBasedTrigger_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRequestsBasedTrigger_STATUSARM runs a test to see if a specific instance of RequestsBasedTrigger_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRequestsBasedTrigger_STATUSARM(subject RequestsBasedTrigger_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RequestsBasedTrigger_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RequestsBasedTrigger_STATUSARM instances for property testing - lazily instantiated by
// RequestsBasedTrigger_STATUSARMGenerator()
var requestsBasedTrigger_STATUSARMGenerator gopter.Gen

// RequestsBasedTrigger_STATUSARMGenerator returns a generator of RequestsBasedTrigger_STATUSARM instances for property testing.
func RequestsBasedTrigger_STATUSARMGenerator() gopter.Gen {
	if requestsBasedTrigger_STATUSARMGenerator != nil {
		return requestsBasedTrigger_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRequestsBasedTrigger_STATUSARM(generators)
	requestsBasedTrigger_STATUSARMGenerator = gen.Struct(reflect.TypeOf(RequestsBasedTrigger_STATUSARM{}), generators)

	return requestsBasedTrigger_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForRequestsBasedTrigger_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRequestsBasedTrigger_STATUSARM(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["TimeInterval"] = gen.PtrOf(gen.AlphaString())
}

func Test_SlowRequestsBasedTrigger_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SlowRequestsBasedTrigger_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSlowRequestsBasedTrigger_STATUSARM, SlowRequestsBasedTrigger_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSlowRequestsBasedTrigger_STATUSARM runs a test to see if a specific instance of SlowRequestsBasedTrigger_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSlowRequestsBasedTrigger_STATUSARM(subject SlowRequestsBasedTrigger_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SlowRequestsBasedTrigger_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SlowRequestsBasedTrigger_STATUSARM instances for property testing - lazily instantiated by
// SlowRequestsBasedTrigger_STATUSARMGenerator()
var slowRequestsBasedTrigger_STATUSARMGenerator gopter.Gen

// SlowRequestsBasedTrigger_STATUSARMGenerator returns a generator of SlowRequestsBasedTrigger_STATUSARM instances for property testing.
func SlowRequestsBasedTrigger_STATUSARMGenerator() gopter.Gen {
	if slowRequestsBasedTrigger_STATUSARMGenerator != nil {
		return slowRequestsBasedTrigger_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSlowRequestsBasedTrigger_STATUSARM(generators)
	slowRequestsBasedTrigger_STATUSARMGenerator = gen.Struct(reflect.TypeOf(SlowRequestsBasedTrigger_STATUSARM{}), generators)

	return slowRequestsBasedTrigger_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForSlowRequestsBasedTrigger_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSlowRequestsBasedTrigger_STATUSARM(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["TimeInterval"] = gen.PtrOf(gen.AlphaString())
	gens["TimeTaken"] = gen.PtrOf(gen.AlphaString())
}

func Test_StatusCodesBasedTrigger_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StatusCodesBasedTrigger_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStatusCodesBasedTrigger_STATUSARM, StatusCodesBasedTrigger_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStatusCodesBasedTrigger_STATUSARM runs a test to see if a specific instance of StatusCodesBasedTrigger_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStatusCodesBasedTrigger_STATUSARM(subject StatusCodesBasedTrigger_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StatusCodesBasedTrigger_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StatusCodesBasedTrigger_STATUSARM instances for property testing - lazily instantiated by
// StatusCodesBasedTrigger_STATUSARMGenerator()
var statusCodesBasedTrigger_STATUSARMGenerator gopter.Gen

// StatusCodesBasedTrigger_STATUSARMGenerator returns a generator of StatusCodesBasedTrigger_STATUSARM instances for property testing.
func StatusCodesBasedTrigger_STATUSARMGenerator() gopter.Gen {
	if statusCodesBasedTrigger_STATUSARMGenerator != nil {
		return statusCodesBasedTrigger_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStatusCodesBasedTrigger_STATUSARM(generators)
	statusCodesBasedTrigger_STATUSARMGenerator = gen.Struct(reflect.TypeOf(StatusCodesBasedTrigger_STATUSARM{}), generators)

	return statusCodesBasedTrigger_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForStatusCodesBasedTrigger_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStatusCodesBasedTrigger_STATUSARM(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.Int())
	gens["SubStatus"] = gen.PtrOf(gen.Int())
	gens["TimeInterval"] = gen.PtrOf(gen.AlphaString())
	gens["Win32Status"] = gen.PtrOf(gen.Int())
}

func Test_StatusCodesRangeBasedTrigger_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StatusCodesRangeBasedTrigger_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStatusCodesRangeBasedTrigger_STATUSARM, StatusCodesRangeBasedTrigger_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStatusCodesRangeBasedTrigger_STATUSARM runs a test to see if a specific instance of StatusCodesRangeBasedTrigger_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStatusCodesRangeBasedTrigger_STATUSARM(subject StatusCodesRangeBasedTrigger_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StatusCodesRangeBasedTrigger_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StatusCodesRangeBasedTrigger_STATUSARM instances for property testing - lazily instantiated by
// StatusCodesRangeBasedTrigger_STATUSARMGenerator()
var statusCodesRangeBasedTrigger_STATUSARMGenerator gopter.Gen

// StatusCodesRangeBasedTrigger_STATUSARMGenerator returns a generator of StatusCodesRangeBasedTrigger_STATUSARM instances for property testing.
func StatusCodesRangeBasedTrigger_STATUSARMGenerator() gopter.Gen {
	if statusCodesRangeBasedTrigger_STATUSARMGenerator != nil {
		return statusCodesRangeBasedTrigger_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStatusCodesRangeBasedTrigger_STATUSARM(generators)
	statusCodesRangeBasedTrigger_STATUSARMGenerator = gen.Struct(reflect.TypeOf(StatusCodesRangeBasedTrigger_STATUSARM{}), generators)

	return statusCodesRangeBasedTrigger_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForStatusCodesRangeBasedTrigger_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStatusCodesRangeBasedTrigger_STATUSARM(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["StatusCodes"] = gen.PtrOf(gen.AlphaString())
	gens["TimeInterval"] = gen.PtrOf(gen.AlphaString())
}
