// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20220301

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_Site_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Site_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSiteSTATUSARM, SiteSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSiteSTATUSARM runs a test to see if a specific instance of Site_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSiteSTATUSARM(subject Site_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Site_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Site_STATUSARM instances for property testing - lazily instantiated by SiteSTATUSARMGenerator()
var siteSTATUSARMGenerator gopter.Gen

// SiteSTATUSARMGenerator returns a generator of Site_STATUSARM instances for property testing.
// We first initialize siteSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SiteSTATUSARMGenerator() gopter.Gen {
	if siteSTATUSARMGenerator != nil {
		return siteSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSiteSTATUSARM(generators)
	siteSTATUSARMGenerator = gen.Struct(reflect.TypeOf(Site_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSiteSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForSiteSTATUSARM(generators)
	siteSTATUSARMGenerator = gen.Struct(reflect.TypeOf(Site_STATUSARM{}), generators)

	return siteSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForSiteSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSiteSTATUSARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSiteSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSiteSTATUSARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationSTATUSARMGenerator())
	gens["Identity"] = gen.PtrOf(ManagedServiceIdentitySTATUSARMGenerator())
	gens["Properties"] = gen.PtrOf(SiteSTATUSPropertiesARMGenerator())
}

func Test_ManagedServiceIdentity_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentitySTATUSARM, ManagedServiceIdentitySTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentitySTATUSARM runs a test to see if a specific instance of ManagedServiceIdentity_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentitySTATUSARM(subject ManagedServiceIdentity_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity_STATUSARM instances for property testing - lazily instantiated by
// ManagedServiceIdentitySTATUSARMGenerator()
var managedServiceIdentitySTATUSARMGenerator gopter.Gen

// ManagedServiceIdentitySTATUSARMGenerator returns a generator of ManagedServiceIdentity_STATUSARM instances for property testing.
// We first initialize managedServiceIdentitySTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedServiceIdentitySTATUSARMGenerator() gopter.Gen {
	if managedServiceIdentitySTATUSARMGenerator != nil {
		return managedServiceIdentitySTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentitySTATUSARM(generators)
	managedServiceIdentitySTATUSARMGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentitySTATUSARM(generators)
	AddRelatedPropertyGeneratorsForManagedServiceIdentitySTATUSARM(generators)
	managedServiceIdentitySTATUSARMGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_STATUSARM{}), generators)

	return managedServiceIdentitySTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentitySTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentitySTATUSARM(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ManagedServiceIdentitySTATUSType_None,
		ManagedServiceIdentitySTATUSType_SystemAssigned,
		ManagedServiceIdentitySTATUSType_SystemAssignedUserAssigned,
		ManagedServiceIdentitySTATUSType_UserAssigned))
}

// AddRelatedPropertyGeneratorsForManagedServiceIdentitySTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedServiceIdentitySTATUSARM(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), UserAssignedIdentitySTATUSARMGenerator())
}

func Test_Site_STATUS_PropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Site_STATUS_PropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSiteSTATUSPropertiesARM, SiteSTATUSPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSiteSTATUSPropertiesARM runs a test to see if a specific instance of Site_STATUS_PropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSiteSTATUSPropertiesARM(subject Site_STATUS_PropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Site_STATUS_PropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Site_STATUS_PropertiesARM instances for property testing - lazily instantiated by
// SiteSTATUSPropertiesARMGenerator()
var siteSTATUSPropertiesARMGenerator gopter.Gen

// SiteSTATUSPropertiesARMGenerator returns a generator of Site_STATUS_PropertiesARM instances for property testing.
// We first initialize siteSTATUSPropertiesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SiteSTATUSPropertiesARMGenerator() gopter.Gen {
	if siteSTATUSPropertiesARMGenerator != nil {
		return siteSTATUSPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSiteSTATUSPropertiesARM(generators)
	siteSTATUSPropertiesARMGenerator = gen.Struct(reflect.TypeOf(Site_STATUS_PropertiesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSiteSTATUSPropertiesARM(generators)
	AddRelatedPropertyGeneratorsForSiteSTATUSPropertiesARM(generators)
	siteSTATUSPropertiesARMGenerator = gen.Struct(reflect.TypeOf(Site_STATUS_PropertiesARM{}), generators)

	return siteSTATUSPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForSiteSTATUSPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSiteSTATUSPropertiesARM(gens map[string]gopter.Gen) {
	gens["AvailabilityState"] = gen.PtrOf(gen.OneConstOf(SiteSTATUSPropertiesAvailabilityState_DisasterRecoveryMode, SiteSTATUSPropertiesAvailabilityState_Limited, SiteSTATUSPropertiesAvailabilityState_Normal))
	gens["ClientAffinityEnabled"] = gen.PtrOf(gen.Bool())
	gens["ClientCertEnabled"] = gen.PtrOf(gen.Bool())
	gens["ClientCertExclusionPaths"] = gen.PtrOf(gen.AlphaString())
	gens["ClientCertMode"] = gen.PtrOf(gen.OneConstOf(SiteSTATUSPropertiesClientCertMode_Optional, SiteSTATUSPropertiesClientCertMode_OptionalInteractiveUser, SiteSTATUSPropertiesClientCertMode_Required))
	gens["ContainerSize"] = gen.PtrOf(gen.Int())
	gens["CustomDomainVerificationId"] = gen.PtrOf(gen.AlphaString())
	gens["DailyMemoryTimeQuota"] = gen.PtrOf(gen.Int())
	gens["DefaultHostName"] = gen.PtrOf(gen.AlphaString())
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["EnabledHostNames"] = gen.SliceOf(gen.AlphaString())
	gens["HostNames"] = gen.SliceOf(gen.AlphaString())
	gens["HostNamesDisabled"] = gen.PtrOf(gen.Bool())
	gens["HttpsOnly"] = gen.PtrOf(gen.Bool())
	gens["HyperV"] = gen.PtrOf(gen.Bool())
	gens["InProgressOperationId"] = gen.PtrOf(gen.AlphaString())
	gens["IsDefaultContainer"] = gen.PtrOf(gen.Bool())
	gens["IsXenon"] = gen.PtrOf(gen.Bool())
	gens["KeyVaultReferenceIdentity"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedTimeUtc"] = gen.PtrOf(gen.AlphaString())
	gens["MaxNumberOfWorkers"] = gen.PtrOf(gen.Int())
	gens["OutboundIpAddresses"] = gen.PtrOf(gen.AlphaString())
	gens["PossibleOutboundIpAddresses"] = gen.PtrOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.AlphaString())
	gens["RedundancyMode"] = gen.PtrOf(gen.OneConstOf(
		SiteSTATUSPropertiesRedundancyMode_ActiveActive,
		SiteSTATUSPropertiesRedundancyMode_Failover,
		SiteSTATUSPropertiesRedundancyMode_GeoRedundant,
		SiteSTATUSPropertiesRedundancyMode_Manual,
		SiteSTATUSPropertiesRedundancyMode_None))
	gens["RepositorySiteName"] = gen.PtrOf(gen.AlphaString())
	gens["Reserved"] = gen.PtrOf(gen.Bool())
	gens["ResourceGroup"] = gen.PtrOf(gen.AlphaString())
	gens["ScmSiteAlsoStopped"] = gen.PtrOf(gen.Bool())
	gens["ServerFarmId"] = gen.PtrOf(gen.AlphaString())
	gens["State"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountRequired"] = gen.PtrOf(gen.Bool())
	gens["SuspendedTill"] = gen.PtrOf(gen.AlphaString())
	gens["TargetSwapSlot"] = gen.PtrOf(gen.AlphaString())
	gens["TrafficManagerHostNames"] = gen.SliceOf(gen.AlphaString())
	gens["UsageState"] = gen.PtrOf(gen.OneConstOf(SiteSTATUSPropertiesUsageState_Exceeded, SiteSTATUSPropertiesUsageState_Normal))
	gens["VirtualNetworkSubnetId"] = gen.PtrOf(gen.AlphaString())
	gens["VnetContentShareEnabled"] = gen.PtrOf(gen.Bool())
	gens["VnetImagePullEnabled"] = gen.PtrOf(gen.Bool())
	gens["VnetRouteAllEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForSiteSTATUSPropertiesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSiteSTATUSPropertiesARM(gens map[string]gopter.Gen) {
	gens["CloningInfo"] = gen.PtrOf(CloningInfoSTATUSARMGenerator())
	gens["HostNameSslStates"] = gen.SliceOf(HostNameSslStateSTATUSARMGenerator())
	gens["HostingEnvironmentProfile"] = gen.PtrOf(HostingEnvironmentProfileSTATUSARMGenerator())
	gens["SiteConfig"] = gen.PtrOf(SiteConfigSTATUSARMGenerator())
	gens["SlotSwapStatus"] = gen.PtrOf(SlotSwapStatusSTATUSARMGenerator())
}

func Test_CloningInfo_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CloningInfo_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCloningInfoSTATUSARM, CloningInfoSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCloningInfoSTATUSARM runs a test to see if a specific instance of CloningInfo_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCloningInfoSTATUSARM(subject CloningInfo_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CloningInfo_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CloningInfo_STATUSARM instances for property testing - lazily instantiated by
// CloningInfoSTATUSARMGenerator()
var cloningInfoSTATUSARMGenerator gopter.Gen

// CloningInfoSTATUSARMGenerator returns a generator of CloningInfo_STATUSARM instances for property testing.
func CloningInfoSTATUSARMGenerator() gopter.Gen {
	if cloningInfoSTATUSARMGenerator != nil {
		return cloningInfoSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCloningInfoSTATUSARM(generators)
	cloningInfoSTATUSARMGenerator = gen.Struct(reflect.TypeOf(CloningInfo_STATUSARM{}), generators)

	return cloningInfoSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForCloningInfoSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCloningInfoSTATUSARM(gens map[string]gopter.Gen) {
	gens["AppSettingsOverrides"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["CloneCustomHostNames"] = gen.PtrOf(gen.Bool())
	gens["CloneSourceControl"] = gen.PtrOf(gen.Bool())
	gens["ConfigureLoadBalancing"] = gen.PtrOf(gen.Bool())
	gens["CorrelationId"] = gen.PtrOf(gen.AlphaString())
	gens["HostingEnvironment"] = gen.PtrOf(gen.AlphaString())
	gens["Overwrite"] = gen.PtrOf(gen.Bool())
	gens["SourceWebAppId"] = gen.PtrOf(gen.AlphaString())
	gens["SourceWebAppLocation"] = gen.PtrOf(gen.AlphaString())
	gens["TrafficManagerProfileId"] = gen.PtrOf(gen.AlphaString())
	gens["TrafficManagerProfileName"] = gen.PtrOf(gen.AlphaString())
}

func Test_HostNameSslState_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HostNameSslState_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHostNameSslStateSTATUSARM, HostNameSslStateSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHostNameSslStateSTATUSARM runs a test to see if a specific instance of HostNameSslState_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHostNameSslStateSTATUSARM(subject HostNameSslState_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HostNameSslState_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HostNameSslState_STATUSARM instances for property testing - lazily instantiated by
// HostNameSslStateSTATUSARMGenerator()
var hostNameSslStateSTATUSARMGenerator gopter.Gen

// HostNameSslStateSTATUSARMGenerator returns a generator of HostNameSslState_STATUSARM instances for property testing.
func HostNameSslStateSTATUSARMGenerator() gopter.Gen {
	if hostNameSslStateSTATUSARMGenerator != nil {
		return hostNameSslStateSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHostNameSslStateSTATUSARM(generators)
	hostNameSslStateSTATUSARMGenerator = gen.Struct(reflect.TypeOf(HostNameSslState_STATUSARM{}), generators)

	return hostNameSslStateSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForHostNameSslStateSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHostNameSslStateSTATUSARM(gens map[string]gopter.Gen) {
	gens["HostType"] = gen.PtrOf(gen.OneConstOf(HostNameSslStateSTATUSHostType_Repository, HostNameSslStateSTATUSHostType_Standard))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["SslState"] = gen.PtrOf(gen.OneConstOf(HostNameSslStateSTATUSSslState_Disabled, HostNameSslStateSTATUSSslState_IpBasedEnabled, HostNameSslStateSTATUSSslState_SniEnabled))
	gens["Thumbprint"] = gen.PtrOf(gen.AlphaString())
	gens["ToUpdate"] = gen.PtrOf(gen.Bool())
	gens["VirtualIP"] = gen.PtrOf(gen.AlphaString())
}

func Test_SiteConfig_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SiteConfig_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSiteConfigSTATUSARM, SiteConfigSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSiteConfigSTATUSARM runs a test to see if a specific instance of SiteConfig_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSiteConfigSTATUSARM(subject SiteConfig_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SiteConfig_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SiteConfig_STATUSARM instances for property testing - lazily instantiated by
// SiteConfigSTATUSARMGenerator()
var siteConfigSTATUSARMGenerator gopter.Gen

// SiteConfigSTATUSARMGenerator returns a generator of SiteConfig_STATUSARM instances for property testing.
// We first initialize siteConfigSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SiteConfigSTATUSARMGenerator() gopter.Gen {
	if siteConfigSTATUSARMGenerator != nil {
		return siteConfigSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSiteConfigSTATUSARM(generators)
	siteConfigSTATUSARMGenerator = gen.Struct(reflect.TypeOf(SiteConfig_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSiteConfigSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForSiteConfigSTATUSARM(generators)
	siteConfigSTATUSARMGenerator = gen.Struct(reflect.TypeOf(SiteConfig_STATUSARM{}), generators)

	return siteConfigSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForSiteConfigSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSiteConfigSTATUSARM(gens map[string]gopter.Gen) {
	gens["AcrUseManagedIdentityCreds"] = gen.PtrOf(gen.Bool())
	gens["AcrUserManagedIdentityID"] = gen.PtrOf(gen.AlphaString())
	gens["AlwaysOn"] = gen.PtrOf(gen.Bool())
	gens["AppCommandLine"] = gen.PtrOf(gen.AlphaString())
	gens["AutoHealEnabled"] = gen.PtrOf(gen.Bool())
	gens["AutoSwapSlotName"] = gen.PtrOf(gen.AlphaString())
	gens["DefaultDocuments"] = gen.SliceOf(gen.AlphaString())
	gens["DetailedErrorLoggingEnabled"] = gen.PtrOf(gen.Bool())
	gens["DocumentRoot"] = gen.PtrOf(gen.AlphaString())
	gens["FtpsState"] = gen.PtrOf(gen.OneConstOf(SiteConfigSTATUSFtpsState_AllAllowed, SiteConfigSTATUSFtpsState_Disabled, SiteConfigSTATUSFtpsState_FtpsOnly))
	gens["FunctionAppScaleLimit"] = gen.PtrOf(gen.Int())
	gens["FunctionsRuntimeScaleMonitoringEnabled"] = gen.PtrOf(gen.Bool())
	gens["HealthCheckPath"] = gen.PtrOf(gen.AlphaString())
	gens["Http20Enabled"] = gen.PtrOf(gen.Bool())
	gens["HttpLoggingEnabled"] = gen.PtrOf(gen.Bool())
	gens["JavaContainer"] = gen.PtrOf(gen.AlphaString())
	gens["JavaContainerVersion"] = gen.PtrOf(gen.AlphaString())
	gens["JavaVersion"] = gen.PtrOf(gen.AlphaString())
	gens["KeyVaultReferenceIdentity"] = gen.PtrOf(gen.AlphaString())
	gens["LinuxFxVersion"] = gen.PtrOf(gen.AlphaString())
	gens["LoadBalancing"] = gen.PtrOf(gen.OneConstOf(
		SiteConfigSTATUSLoadBalancing_LeastRequests,
		SiteConfigSTATUSLoadBalancing_LeastResponseTime,
		SiteConfigSTATUSLoadBalancing_PerSiteRoundRobin,
		SiteConfigSTATUSLoadBalancing_RequestHash,
		SiteConfigSTATUSLoadBalancing_WeightedRoundRobin,
		SiteConfigSTATUSLoadBalancing_WeightedTotalTraffic))
	gens["LocalMySqlEnabled"] = gen.PtrOf(gen.Bool())
	gens["LogsDirectorySizeLimit"] = gen.PtrOf(gen.Int())
	gens["ManagedPipelineMode"] = gen.PtrOf(gen.OneConstOf(SiteConfigSTATUSManagedPipelineMode_Classic, SiteConfigSTATUSManagedPipelineMode_Integrated))
	gens["ManagedServiceIdentityId"] = gen.PtrOf(gen.Int())
	gens["MinTlsVersion"] = gen.PtrOf(gen.OneConstOf(SiteConfigSTATUSMinTlsVersion_10, SiteConfigSTATUSMinTlsVersion_11, SiteConfigSTATUSMinTlsVersion_12))
	gens["MinimumElasticInstanceCount"] = gen.PtrOf(gen.Int())
	gens["NetFrameworkVersion"] = gen.PtrOf(gen.AlphaString())
	gens["NodeVersion"] = gen.PtrOf(gen.AlphaString())
	gens["NumberOfWorkers"] = gen.PtrOf(gen.Int())
	gens["PhpVersion"] = gen.PtrOf(gen.AlphaString())
	gens["PowerShellVersion"] = gen.PtrOf(gen.AlphaString())
	gens["PreWarmedInstanceCount"] = gen.PtrOf(gen.Int())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.AlphaString())
	gens["PublishingUsername"] = gen.PtrOf(gen.AlphaString())
	gens["PythonVersion"] = gen.PtrOf(gen.AlphaString())
	gens["RemoteDebuggingEnabled"] = gen.PtrOf(gen.Bool())
	gens["RemoteDebuggingVersion"] = gen.PtrOf(gen.AlphaString())
	gens["RequestTracingEnabled"] = gen.PtrOf(gen.Bool())
	gens["RequestTracingExpirationTime"] = gen.PtrOf(gen.AlphaString())
	gens["ScmIpSecurityRestrictionsUseMain"] = gen.PtrOf(gen.Bool())
	gens["ScmMinTlsVersion"] = gen.PtrOf(gen.OneConstOf(SiteConfigSTATUSScmMinTlsVersion_10, SiteConfigSTATUSScmMinTlsVersion_11, SiteConfigSTATUSScmMinTlsVersion_12))
	gens["ScmType"] = gen.PtrOf(gen.OneConstOf(
		SiteConfigSTATUSScmType_BitbucketGit,
		SiteConfigSTATUSScmType_BitbucketHg,
		SiteConfigSTATUSScmType_CodePlexGit,
		SiteConfigSTATUSScmType_CodePlexHg,
		SiteConfigSTATUSScmType_Dropbox,
		SiteConfigSTATUSScmType_ExternalGit,
		SiteConfigSTATUSScmType_ExternalHg,
		SiteConfigSTATUSScmType_GitHub,
		SiteConfigSTATUSScmType_LocalGit,
		SiteConfigSTATUSScmType_None,
		SiteConfigSTATUSScmType_OneDrive,
		SiteConfigSTATUSScmType_Tfs,
		SiteConfigSTATUSScmType_VSO,
		SiteConfigSTATUSScmType_VSTSRM))
	gens["TracingOptions"] = gen.PtrOf(gen.AlphaString())
	gens["Use32BitWorkerProcess"] = gen.PtrOf(gen.Bool())
	gens["VnetName"] = gen.PtrOf(gen.AlphaString())
	gens["VnetPrivatePortsCount"] = gen.PtrOf(gen.Int())
	gens["VnetRouteAllEnabled"] = gen.PtrOf(gen.Bool())
	gens["WebSocketsEnabled"] = gen.PtrOf(gen.Bool())
	gens["WebsiteTimeZone"] = gen.PtrOf(gen.AlphaString())
	gens["WindowsFxVersion"] = gen.PtrOf(gen.AlphaString())
	gens["XManagedServiceIdentityId"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForSiteConfigSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSiteConfigSTATUSARM(gens map[string]gopter.Gen) {
	gens["ApiDefinition"] = gen.PtrOf(ApiDefinitionInfoSTATUSARMGenerator())
	gens["ApiManagementConfig"] = gen.PtrOf(ApiManagementConfigSTATUSARMGenerator())
	gens["AppSettings"] = gen.SliceOf(NameValuePairSTATUSARMGenerator())
	gens["AutoHealRules"] = gen.PtrOf(AutoHealRulesSTATUSARMGenerator())
	gens["AzureStorageAccounts"] = gen.MapOf(gen.AlphaString(), AzureStorageInfoValueSTATUSARMGenerator())
	gens["ConnectionStrings"] = gen.SliceOf(ConnStringInfoSTATUSARMGenerator())
	gens["Cors"] = gen.PtrOf(CorsSettingsSTATUSARMGenerator())
	gens["Experiments"] = gen.PtrOf(ExperimentsSTATUSARMGenerator())
	gens["HandlerMappings"] = gen.SliceOf(HandlerMappingSTATUSARMGenerator())
	gens["IpSecurityRestrictions"] = gen.SliceOf(IpSecurityRestrictionSTATUSARMGenerator())
	gens["Limits"] = gen.PtrOf(SiteLimitsSTATUSARMGenerator())
	gens["MachineKey"] = gen.PtrOf(SiteMachineKeySTATUSARMGenerator())
	gens["Push"] = gen.PtrOf(PushSettingsSTATUSARMGenerator())
	gens["ScmIpSecurityRestrictions"] = gen.SliceOf(IpSecurityRestrictionSTATUSARMGenerator())
	gens["VirtualApplications"] = gen.SliceOf(VirtualApplicationSTATUSARMGenerator())
}

func Test_SlotSwapStatus_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SlotSwapStatus_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSlotSwapStatusSTATUSARM, SlotSwapStatusSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSlotSwapStatusSTATUSARM runs a test to see if a specific instance of SlotSwapStatus_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSlotSwapStatusSTATUSARM(subject SlotSwapStatus_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SlotSwapStatus_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SlotSwapStatus_STATUSARM instances for property testing - lazily instantiated by
// SlotSwapStatusSTATUSARMGenerator()
var slotSwapStatusSTATUSARMGenerator gopter.Gen

// SlotSwapStatusSTATUSARMGenerator returns a generator of SlotSwapStatus_STATUSARM instances for property testing.
func SlotSwapStatusSTATUSARMGenerator() gopter.Gen {
	if slotSwapStatusSTATUSARMGenerator != nil {
		return slotSwapStatusSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSlotSwapStatusSTATUSARM(generators)
	slotSwapStatusSTATUSARMGenerator = gen.Struct(reflect.TypeOf(SlotSwapStatus_STATUSARM{}), generators)

	return slotSwapStatusSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForSlotSwapStatusSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSlotSwapStatusSTATUSARM(gens map[string]gopter.Gen) {
	gens["DestinationSlotName"] = gen.PtrOf(gen.AlphaString())
	gens["SourceSlotName"] = gen.PtrOf(gen.AlphaString())
	gens["TimestampUtc"] = gen.PtrOf(gen.AlphaString())
}

func Test_UserAssignedIdentity_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentity_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentitySTATUSARM, UserAssignedIdentitySTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentitySTATUSARM runs a test to see if a specific instance of UserAssignedIdentity_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentitySTATUSARM(subject UserAssignedIdentity_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentity_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentity_STATUSARM instances for property testing - lazily instantiated by
// UserAssignedIdentitySTATUSARMGenerator()
var userAssignedIdentitySTATUSARMGenerator gopter.Gen

// UserAssignedIdentitySTATUSARMGenerator returns a generator of UserAssignedIdentity_STATUSARM instances for property testing.
func UserAssignedIdentitySTATUSARMGenerator() gopter.Gen {
	if userAssignedIdentitySTATUSARMGenerator != nil {
		return userAssignedIdentitySTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserAssignedIdentitySTATUSARM(generators)
	userAssignedIdentitySTATUSARMGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentity_STATUSARM{}), generators)

	return userAssignedIdentitySTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForUserAssignedIdentitySTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserAssignedIdentitySTATUSARM(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_ApiDefinitionInfo_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiDefinitionInfo_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiDefinitionInfoSTATUSARM, ApiDefinitionInfoSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiDefinitionInfoSTATUSARM runs a test to see if a specific instance of ApiDefinitionInfo_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForApiDefinitionInfoSTATUSARM(subject ApiDefinitionInfo_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiDefinitionInfo_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiDefinitionInfo_STATUSARM instances for property testing - lazily instantiated by
// ApiDefinitionInfoSTATUSARMGenerator()
var apiDefinitionInfoSTATUSARMGenerator gopter.Gen

// ApiDefinitionInfoSTATUSARMGenerator returns a generator of ApiDefinitionInfo_STATUSARM instances for property testing.
func ApiDefinitionInfoSTATUSARMGenerator() gopter.Gen {
	if apiDefinitionInfoSTATUSARMGenerator != nil {
		return apiDefinitionInfoSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiDefinitionInfoSTATUSARM(generators)
	apiDefinitionInfoSTATUSARMGenerator = gen.Struct(reflect.TypeOf(ApiDefinitionInfo_STATUSARM{}), generators)

	return apiDefinitionInfoSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForApiDefinitionInfoSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiDefinitionInfoSTATUSARM(gens map[string]gopter.Gen) {
	gens["Url"] = gen.PtrOf(gen.AlphaString())
}

func Test_ApiManagementConfig_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiManagementConfig_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiManagementConfigSTATUSARM, ApiManagementConfigSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiManagementConfigSTATUSARM runs a test to see if a specific instance of ApiManagementConfig_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForApiManagementConfigSTATUSARM(subject ApiManagementConfig_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiManagementConfig_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiManagementConfig_STATUSARM instances for property testing - lazily instantiated by
// ApiManagementConfigSTATUSARMGenerator()
var apiManagementConfigSTATUSARMGenerator gopter.Gen

// ApiManagementConfigSTATUSARMGenerator returns a generator of ApiManagementConfig_STATUSARM instances for property testing.
func ApiManagementConfigSTATUSARMGenerator() gopter.Gen {
	if apiManagementConfigSTATUSARMGenerator != nil {
		return apiManagementConfigSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiManagementConfigSTATUSARM(generators)
	apiManagementConfigSTATUSARMGenerator = gen.Struct(reflect.TypeOf(ApiManagementConfig_STATUSARM{}), generators)

	return apiManagementConfigSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForApiManagementConfigSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiManagementConfigSTATUSARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_AutoHealRules_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoHealRules_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoHealRulesSTATUSARM, AutoHealRulesSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoHealRulesSTATUSARM runs a test to see if a specific instance of AutoHealRules_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoHealRulesSTATUSARM(subject AutoHealRules_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoHealRules_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoHealRules_STATUSARM instances for property testing - lazily instantiated by
// AutoHealRulesSTATUSARMGenerator()
var autoHealRulesSTATUSARMGenerator gopter.Gen

// AutoHealRulesSTATUSARMGenerator returns a generator of AutoHealRules_STATUSARM instances for property testing.
func AutoHealRulesSTATUSARMGenerator() gopter.Gen {
	if autoHealRulesSTATUSARMGenerator != nil {
		return autoHealRulesSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForAutoHealRulesSTATUSARM(generators)
	autoHealRulesSTATUSARMGenerator = gen.Struct(reflect.TypeOf(AutoHealRules_STATUSARM{}), generators)

	return autoHealRulesSTATUSARMGenerator
}

// AddRelatedPropertyGeneratorsForAutoHealRulesSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoHealRulesSTATUSARM(gens map[string]gopter.Gen) {
	gens["Actions"] = gen.PtrOf(AutoHealActionsSTATUSARMGenerator())
	gens["Triggers"] = gen.PtrOf(AutoHealTriggersSTATUSARMGenerator())
}

func Test_AzureStorageInfoValue_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureStorageInfoValue_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureStorageInfoValueSTATUSARM, AzureStorageInfoValueSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureStorageInfoValueSTATUSARM runs a test to see if a specific instance of AzureStorageInfoValue_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureStorageInfoValueSTATUSARM(subject AzureStorageInfoValue_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureStorageInfoValue_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureStorageInfoValue_STATUSARM instances for property testing - lazily instantiated by
// AzureStorageInfoValueSTATUSARMGenerator()
var azureStorageInfoValueSTATUSARMGenerator gopter.Gen

// AzureStorageInfoValueSTATUSARMGenerator returns a generator of AzureStorageInfoValue_STATUSARM instances for property testing.
func AzureStorageInfoValueSTATUSARMGenerator() gopter.Gen {
	if azureStorageInfoValueSTATUSARMGenerator != nil {
		return azureStorageInfoValueSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureStorageInfoValueSTATUSARM(generators)
	azureStorageInfoValueSTATUSARMGenerator = gen.Struct(reflect.TypeOf(AzureStorageInfoValue_STATUSARM{}), generators)

	return azureStorageInfoValueSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForAzureStorageInfoValueSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureStorageInfoValueSTATUSARM(gens map[string]gopter.Gen) {
	gens["AccountName"] = gen.PtrOf(gen.AlphaString())
	gens["MountPath"] = gen.PtrOf(gen.AlphaString())
	gens["ShareName"] = gen.PtrOf(gen.AlphaString())
	gens["State"] = gen.PtrOf(gen.OneConstOf(
		AzureStorageInfoValueSTATUSState_InvalidCredentials,
		AzureStorageInfoValueSTATUSState_InvalidShare,
		AzureStorageInfoValueSTATUSState_NotValidated,
		AzureStorageInfoValueSTATUSState_Ok))
	gens["Type"] = gen.PtrOf(gen.OneConstOf(AzureStorageInfoValueSTATUSType_AzureBlob, AzureStorageInfoValueSTATUSType_AzureFiles))
}

func Test_ConnStringInfo_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ConnStringInfo_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForConnStringInfoSTATUSARM, ConnStringInfoSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForConnStringInfoSTATUSARM runs a test to see if a specific instance of ConnStringInfo_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForConnStringInfoSTATUSARM(subject ConnStringInfo_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ConnStringInfo_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ConnStringInfo_STATUSARM instances for property testing - lazily instantiated by
// ConnStringInfoSTATUSARMGenerator()
var connStringInfoSTATUSARMGenerator gopter.Gen

// ConnStringInfoSTATUSARMGenerator returns a generator of ConnStringInfo_STATUSARM instances for property testing.
func ConnStringInfoSTATUSARMGenerator() gopter.Gen {
	if connStringInfoSTATUSARMGenerator != nil {
		return connStringInfoSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForConnStringInfoSTATUSARM(generators)
	connStringInfoSTATUSARMGenerator = gen.Struct(reflect.TypeOf(ConnStringInfo_STATUSARM{}), generators)

	return connStringInfoSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForConnStringInfoSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForConnStringInfoSTATUSARM(gens map[string]gopter.Gen) {
	gens["ConnectionString"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ConnStringInfoSTATUSType_ApiHub,
		ConnStringInfoSTATUSType_Custom,
		ConnStringInfoSTATUSType_DocDb,
		ConnStringInfoSTATUSType_EventHub,
		ConnStringInfoSTATUSType_MySql,
		ConnStringInfoSTATUSType_NotificationHub,
		ConnStringInfoSTATUSType_PostgreSQL,
		ConnStringInfoSTATUSType_RedisCache,
		ConnStringInfoSTATUSType_SQLAzure,
		ConnStringInfoSTATUSType_SQLServer,
		ConnStringInfoSTATUSType_ServiceBus))
}

func Test_CorsSettings_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CorsSettings_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCorsSettingsSTATUSARM, CorsSettingsSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCorsSettingsSTATUSARM runs a test to see if a specific instance of CorsSettings_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCorsSettingsSTATUSARM(subject CorsSettings_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CorsSettings_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CorsSettings_STATUSARM instances for property testing - lazily instantiated by
// CorsSettingsSTATUSARMGenerator()
var corsSettingsSTATUSARMGenerator gopter.Gen

// CorsSettingsSTATUSARMGenerator returns a generator of CorsSettings_STATUSARM instances for property testing.
func CorsSettingsSTATUSARMGenerator() gopter.Gen {
	if corsSettingsSTATUSARMGenerator != nil {
		return corsSettingsSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCorsSettingsSTATUSARM(generators)
	corsSettingsSTATUSARMGenerator = gen.Struct(reflect.TypeOf(CorsSettings_STATUSARM{}), generators)

	return corsSettingsSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForCorsSettingsSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCorsSettingsSTATUSARM(gens map[string]gopter.Gen) {
	gens["AllowedOrigins"] = gen.SliceOf(gen.AlphaString())
	gens["SupportCredentials"] = gen.PtrOf(gen.Bool())
}

func Test_Experiments_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Experiments_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExperimentsSTATUSARM, ExperimentsSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExperimentsSTATUSARM runs a test to see if a specific instance of Experiments_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForExperimentsSTATUSARM(subject Experiments_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Experiments_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Experiments_STATUSARM instances for property testing - lazily instantiated by
// ExperimentsSTATUSARMGenerator()
var experimentsSTATUSARMGenerator gopter.Gen

// ExperimentsSTATUSARMGenerator returns a generator of Experiments_STATUSARM instances for property testing.
func ExperimentsSTATUSARMGenerator() gopter.Gen {
	if experimentsSTATUSARMGenerator != nil {
		return experimentsSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForExperimentsSTATUSARM(generators)
	experimentsSTATUSARMGenerator = gen.Struct(reflect.TypeOf(Experiments_STATUSARM{}), generators)

	return experimentsSTATUSARMGenerator
}

// AddRelatedPropertyGeneratorsForExperimentsSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForExperimentsSTATUSARM(gens map[string]gopter.Gen) {
	gens["RampUpRules"] = gen.SliceOf(RampUpRuleSTATUSARMGenerator())
}

func Test_HandlerMapping_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HandlerMapping_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHandlerMappingSTATUSARM, HandlerMappingSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHandlerMappingSTATUSARM runs a test to see if a specific instance of HandlerMapping_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHandlerMappingSTATUSARM(subject HandlerMapping_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HandlerMapping_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HandlerMapping_STATUSARM instances for property testing - lazily instantiated by
// HandlerMappingSTATUSARMGenerator()
var handlerMappingSTATUSARMGenerator gopter.Gen

// HandlerMappingSTATUSARMGenerator returns a generator of HandlerMapping_STATUSARM instances for property testing.
func HandlerMappingSTATUSARMGenerator() gopter.Gen {
	if handlerMappingSTATUSARMGenerator != nil {
		return handlerMappingSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHandlerMappingSTATUSARM(generators)
	handlerMappingSTATUSARMGenerator = gen.Struct(reflect.TypeOf(HandlerMapping_STATUSARM{}), generators)

	return handlerMappingSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForHandlerMappingSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHandlerMappingSTATUSARM(gens map[string]gopter.Gen) {
	gens["Arguments"] = gen.PtrOf(gen.AlphaString())
	gens["Extension"] = gen.PtrOf(gen.AlphaString())
	gens["ScriptProcessor"] = gen.PtrOf(gen.AlphaString())
}

func Test_IpSecurityRestriction_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpSecurityRestriction_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpSecurityRestrictionSTATUSARM, IpSecurityRestrictionSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpSecurityRestrictionSTATUSARM runs a test to see if a specific instance of IpSecurityRestriction_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIpSecurityRestrictionSTATUSARM(subject IpSecurityRestriction_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpSecurityRestriction_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpSecurityRestriction_STATUSARM instances for property testing - lazily instantiated by
// IpSecurityRestrictionSTATUSARMGenerator()
var ipSecurityRestrictionSTATUSARMGenerator gopter.Gen

// IpSecurityRestrictionSTATUSARMGenerator returns a generator of IpSecurityRestriction_STATUSARM instances for property testing.
func IpSecurityRestrictionSTATUSARMGenerator() gopter.Gen {
	if ipSecurityRestrictionSTATUSARMGenerator != nil {
		return ipSecurityRestrictionSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpSecurityRestrictionSTATUSARM(generators)
	ipSecurityRestrictionSTATUSARMGenerator = gen.Struct(reflect.TypeOf(IpSecurityRestriction_STATUSARM{}), generators)

	return ipSecurityRestrictionSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForIpSecurityRestrictionSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpSecurityRestrictionSTATUSARM(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.AlphaString())
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["Headers"] = gen.MapOf(gen.AlphaString(), gen.SliceOf(gen.AlphaString()))
	gens["IpAddress"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Priority"] = gen.PtrOf(gen.Int())
	gens["SubnetMask"] = gen.PtrOf(gen.AlphaString())
	gens["SubnetTrafficTag"] = gen.PtrOf(gen.Int())
	gens["Tag"] = gen.PtrOf(gen.OneConstOf(IpSecurityRestrictionSTATUSTag_Default, IpSecurityRestrictionSTATUSTag_ServiceTag, IpSecurityRestrictionSTATUSTag_XffProxy))
	gens["VnetSubnetResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["VnetTrafficTag"] = gen.PtrOf(gen.Int())
}

func Test_NameValuePair_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NameValuePair_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNameValuePairSTATUSARM, NameValuePairSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNameValuePairSTATUSARM runs a test to see if a specific instance of NameValuePair_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNameValuePairSTATUSARM(subject NameValuePair_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NameValuePair_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NameValuePair_STATUSARM instances for property testing - lazily instantiated by
// NameValuePairSTATUSARMGenerator()
var nameValuePairSTATUSARMGenerator gopter.Gen

// NameValuePairSTATUSARMGenerator returns a generator of NameValuePair_STATUSARM instances for property testing.
func NameValuePairSTATUSARMGenerator() gopter.Gen {
	if nameValuePairSTATUSARMGenerator != nil {
		return nameValuePairSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNameValuePairSTATUSARM(generators)
	nameValuePairSTATUSARMGenerator = gen.Struct(reflect.TypeOf(NameValuePair_STATUSARM{}), generators)

	return nameValuePairSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForNameValuePairSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNameValuePairSTATUSARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_PushSettings_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PushSettings_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPushSettingsSTATUSARM, PushSettingsSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPushSettingsSTATUSARM runs a test to see if a specific instance of PushSettings_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPushSettingsSTATUSARM(subject PushSettings_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PushSettings_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PushSettings_STATUSARM instances for property testing - lazily instantiated by
// PushSettingsSTATUSARMGenerator()
var pushSettingsSTATUSARMGenerator gopter.Gen

// PushSettingsSTATUSARMGenerator returns a generator of PushSettings_STATUSARM instances for property testing.
// We first initialize pushSettingsSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PushSettingsSTATUSARMGenerator() gopter.Gen {
	if pushSettingsSTATUSARMGenerator != nil {
		return pushSettingsSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPushSettingsSTATUSARM(generators)
	pushSettingsSTATUSARMGenerator = gen.Struct(reflect.TypeOf(PushSettings_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPushSettingsSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForPushSettingsSTATUSARM(generators)
	pushSettingsSTATUSARMGenerator = gen.Struct(reflect.TypeOf(PushSettings_STATUSARM{}), generators)

	return pushSettingsSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForPushSettingsSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPushSettingsSTATUSARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPushSettingsSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPushSettingsSTATUSARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(PushSettingsSTATUSPropertiesARMGenerator())
}

func Test_SiteLimits_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SiteLimits_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSiteLimitsSTATUSARM, SiteLimitsSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSiteLimitsSTATUSARM runs a test to see if a specific instance of SiteLimits_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSiteLimitsSTATUSARM(subject SiteLimits_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SiteLimits_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SiteLimits_STATUSARM instances for property testing - lazily instantiated by
// SiteLimitsSTATUSARMGenerator()
var siteLimitsSTATUSARMGenerator gopter.Gen

// SiteLimitsSTATUSARMGenerator returns a generator of SiteLimits_STATUSARM instances for property testing.
func SiteLimitsSTATUSARMGenerator() gopter.Gen {
	if siteLimitsSTATUSARMGenerator != nil {
		return siteLimitsSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSiteLimitsSTATUSARM(generators)
	siteLimitsSTATUSARMGenerator = gen.Struct(reflect.TypeOf(SiteLimits_STATUSARM{}), generators)

	return siteLimitsSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForSiteLimitsSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSiteLimitsSTATUSARM(gens map[string]gopter.Gen) {
	gens["MaxDiskSizeInMb"] = gen.PtrOf(gen.Int())
	gens["MaxMemoryInMb"] = gen.PtrOf(gen.Int())
	gens["MaxPercentageCpu"] = gen.PtrOf(gen.Float64())
}

func Test_SiteMachineKey_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SiteMachineKey_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSiteMachineKeySTATUSARM, SiteMachineKeySTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSiteMachineKeySTATUSARM runs a test to see if a specific instance of SiteMachineKey_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSiteMachineKeySTATUSARM(subject SiteMachineKey_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SiteMachineKey_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SiteMachineKey_STATUSARM instances for property testing - lazily instantiated by
// SiteMachineKeySTATUSARMGenerator()
var siteMachineKeySTATUSARMGenerator gopter.Gen

// SiteMachineKeySTATUSARMGenerator returns a generator of SiteMachineKey_STATUSARM instances for property testing.
func SiteMachineKeySTATUSARMGenerator() gopter.Gen {
	if siteMachineKeySTATUSARMGenerator != nil {
		return siteMachineKeySTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSiteMachineKeySTATUSARM(generators)
	siteMachineKeySTATUSARMGenerator = gen.Struct(reflect.TypeOf(SiteMachineKey_STATUSARM{}), generators)

	return siteMachineKeySTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForSiteMachineKeySTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSiteMachineKeySTATUSARM(gens map[string]gopter.Gen) {
	gens["Decryption"] = gen.PtrOf(gen.AlphaString())
	gens["DecryptionKey"] = gen.PtrOf(gen.AlphaString())
	gens["Validation"] = gen.PtrOf(gen.AlphaString())
	gens["ValidationKey"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualApplication_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualApplication_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualApplicationSTATUSARM, VirtualApplicationSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualApplicationSTATUSARM runs a test to see if a specific instance of VirtualApplication_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualApplicationSTATUSARM(subject VirtualApplication_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualApplication_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualApplication_STATUSARM instances for property testing - lazily instantiated by
// VirtualApplicationSTATUSARMGenerator()
var virtualApplicationSTATUSARMGenerator gopter.Gen

// VirtualApplicationSTATUSARMGenerator returns a generator of VirtualApplication_STATUSARM instances for property testing.
// We first initialize virtualApplicationSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualApplicationSTATUSARMGenerator() gopter.Gen {
	if virtualApplicationSTATUSARMGenerator != nil {
		return virtualApplicationSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualApplicationSTATUSARM(generators)
	virtualApplicationSTATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualApplication_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualApplicationSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForVirtualApplicationSTATUSARM(generators)
	virtualApplicationSTATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualApplication_STATUSARM{}), generators)

	return virtualApplicationSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualApplicationSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualApplicationSTATUSARM(gens map[string]gopter.Gen) {
	gens["PhysicalPath"] = gen.PtrOf(gen.AlphaString())
	gens["PreloadEnabled"] = gen.PtrOf(gen.Bool())
	gens["VirtualPath"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualApplicationSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualApplicationSTATUSARM(gens map[string]gopter.Gen) {
	gens["VirtualDirectories"] = gen.SliceOf(VirtualDirectorySTATUSARMGenerator())
}

func Test_AutoHealActions_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoHealActions_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoHealActionsSTATUSARM, AutoHealActionsSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoHealActionsSTATUSARM runs a test to see if a specific instance of AutoHealActions_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoHealActionsSTATUSARM(subject AutoHealActions_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoHealActions_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoHealActions_STATUSARM instances for property testing - lazily instantiated by
// AutoHealActionsSTATUSARMGenerator()
var autoHealActionsSTATUSARMGenerator gopter.Gen

// AutoHealActionsSTATUSARMGenerator returns a generator of AutoHealActions_STATUSARM instances for property testing.
// We first initialize autoHealActionsSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AutoHealActionsSTATUSARMGenerator() gopter.Gen {
	if autoHealActionsSTATUSARMGenerator != nil {
		return autoHealActionsSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoHealActionsSTATUSARM(generators)
	autoHealActionsSTATUSARMGenerator = gen.Struct(reflect.TypeOf(AutoHealActions_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoHealActionsSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForAutoHealActionsSTATUSARM(generators)
	autoHealActionsSTATUSARMGenerator = gen.Struct(reflect.TypeOf(AutoHealActions_STATUSARM{}), generators)

	return autoHealActionsSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForAutoHealActionsSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoHealActionsSTATUSARM(gens map[string]gopter.Gen) {
	gens["ActionType"] = gen.PtrOf(gen.OneConstOf(AutoHealActionsSTATUSActionType_CustomAction, AutoHealActionsSTATUSActionType_LogEvent, AutoHealActionsSTATUSActionType_Recycle))
	gens["MinProcessExecutionTime"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAutoHealActionsSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoHealActionsSTATUSARM(gens map[string]gopter.Gen) {
	gens["CustomAction"] = gen.PtrOf(AutoHealCustomActionSTATUSARMGenerator())
}

func Test_AutoHealTriggers_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoHealTriggers_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoHealTriggersSTATUSARM, AutoHealTriggersSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoHealTriggersSTATUSARM runs a test to see if a specific instance of AutoHealTriggers_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoHealTriggersSTATUSARM(subject AutoHealTriggers_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoHealTriggers_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoHealTriggers_STATUSARM instances for property testing - lazily instantiated by
// AutoHealTriggersSTATUSARMGenerator()
var autoHealTriggersSTATUSARMGenerator gopter.Gen

// AutoHealTriggersSTATUSARMGenerator returns a generator of AutoHealTriggers_STATUSARM instances for property testing.
// We first initialize autoHealTriggersSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AutoHealTriggersSTATUSARMGenerator() gopter.Gen {
	if autoHealTriggersSTATUSARMGenerator != nil {
		return autoHealTriggersSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoHealTriggersSTATUSARM(generators)
	autoHealTriggersSTATUSARMGenerator = gen.Struct(reflect.TypeOf(AutoHealTriggers_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoHealTriggersSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForAutoHealTriggersSTATUSARM(generators)
	autoHealTriggersSTATUSARMGenerator = gen.Struct(reflect.TypeOf(AutoHealTriggers_STATUSARM{}), generators)

	return autoHealTriggersSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForAutoHealTriggersSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoHealTriggersSTATUSARM(gens map[string]gopter.Gen) {
	gens["PrivateBytesInKB"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForAutoHealTriggersSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoHealTriggersSTATUSARM(gens map[string]gopter.Gen) {
	gens["Requests"] = gen.PtrOf(RequestsBasedTriggerSTATUSARMGenerator())
	gens["SlowRequests"] = gen.PtrOf(SlowRequestsBasedTriggerSTATUSARMGenerator())
	gens["SlowRequestsWithPath"] = gen.SliceOf(SlowRequestsBasedTriggerSTATUSARMGenerator())
	gens["StatusCodes"] = gen.SliceOf(StatusCodesBasedTriggerSTATUSARMGenerator())
	gens["StatusCodesRange"] = gen.SliceOf(StatusCodesRangeBasedTriggerSTATUSARMGenerator())
}

func Test_PushSettings_STATUS_PropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PushSettings_STATUS_PropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPushSettingsSTATUSPropertiesARM, PushSettingsSTATUSPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPushSettingsSTATUSPropertiesARM runs a test to see if a specific instance of PushSettings_STATUS_PropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPushSettingsSTATUSPropertiesARM(subject PushSettings_STATUS_PropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PushSettings_STATUS_PropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PushSettings_STATUS_PropertiesARM instances for property testing - lazily instantiated by
// PushSettingsSTATUSPropertiesARMGenerator()
var pushSettingsSTATUSPropertiesARMGenerator gopter.Gen

// PushSettingsSTATUSPropertiesARMGenerator returns a generator of PushSettings_STATUS_PropertiesARM instances for property testing.
func PushSettingsSTATUSPropertiesARMGenerator() gopter.Gen {
	if pushSettingsSTATUSPropertiesARMGenerator != nil {
		return pushSettingsSTATUSPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPushSettingsSTATUSPropertiesARM(generators)
	pushSettingsSTATUSPropertiesARMGenerator = gen.Struct(reflect.TypeOf(PushSettings_STATUS_PropertiesARM{}), generators)

	return pushSettingsSTATUSPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForPushSettingsSTATUSPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPushSettingsSTATUSPropertiesARM(gens map[string]gopter.Gen) {
	gens["DynamicTagsJson"] = gen.PtrOf(gen.AlphaString())
	gens["IsPushEnabled"] = gen.PtrOf(gen.Bool())
	gens["TagWhitelistJson"] = gen.PtrOf(gen.AlphaString())
	gens["TagsRequiringAuth"] = gen.PtrOf(gen.AlphaString())
}

func Test_RampUpRule_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RampUpRule_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRampUpRuleSTATUSARM, RampUpRuleSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRampUpRuleSTATUSARM runs a test to see if a specific instance of RampUpRule_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRampUpRuleSTATUSARM(subject RampUpRule_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RampUpRule_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RampUpRule_STATUSARM instances for property testing - lazily instantiated by
// RampUpRuleSTATUSARMGenerator()
var rampUpRuleSTATUSARMGenerator gopter.Gen

// RampUpRuleSTATUSARMGenerator returns a generator of RampUpRule_STATUSARM instances for property testing.
func RampUpRuleSTATUSARMGenerator() gopter.Gen {
	if rampUpRuleSTATUSARMGenerator != nil {
		return rampUpRuleSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRampUpRuleSTATUSARM(generators)
	rampUpRuleSTATUSARMGenerator = gen.Struct(reflect.TypeOf(RampUpRule_STATUSARM{}), generators)

	return rampUpRuleSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForRampUpRuleSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRampUpRuleSTATUSARM(gens map[string]gopter.Gen) {
	gens["ActionHostName"] = gen.PtrOf(gen.AlphaString())
	gens["ChangeDecisionCallbackUrl"] = gen.PtrOf(gen.AlphaString())
	gens["ChangeIntervalInMinutes"] = gen.PtrOf(gen.Int())
	gens["ChangeStep"] = gen.PtrOf(gen.Float64())
	gens["MaxReroutePercentage"] = gen.PtrOf(gen.Float64())
	gens["MinReroutePercentage"] = gen.PtrOf(gen.Float64())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ReroutePercentage"] = gen.PtrOf(gen.Float64())
}

func Test_VirtualDirectory_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualDirectory_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualDirectorySTATUSARM, VirtualDirectorySTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualDirectorySTATUSARM runs a test to see if a specific instance of VirtualDirectory_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualDirectorySTATUSARM(subject VirtualDirectory_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualDirectory_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualDirectory_STATUSARM instances for property testing - lazily instantiated by
// VirtualDirectorySTATUSARMGenerator()
var virtualDirectorySTATUSARMGenerator gopter.Gen

// VirtualDirectorySTATUSARMGenerator returns a generator of VirtualDirectory_STATUSARM instances for property testing.
func VirtualDirectorySTATUSARMGenerator() gopter.Gen {
	if virtualDirectorySTATUSARMGenerator != nil {
		return virtualDirectorySTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualDirectorySTATUSARM(generators)
	virtualDirectorySTATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualDirectory_STATUSARM{}), generators)

	return virtualDirectorySTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualDirectorySTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualDirectorySTATUSARM(gens map[string]gopter.Gen) {
	gens["PhysicalPath"] = gen.PtrOf(gen.AlphaString())
	gens["VirtualPath"] = gen.PtrOf(gen.AlphaString())
}

func Test_AutoHealCustomAction_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoHealCustomAction_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoHealCustomActionSTATUSARM, AutoHealCustomActionSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoHealCustomActionSTATUSARM runs a test to see if a specific instance of AutoHealCustomAction_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoHealCustomActionSTATUSARM(subject AutoHealCustomAction_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoHealCustomAction_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoHealCustomAction_STATUSARM instances for property testing - lazily instantiated by
// AutoHealCustomActionSTATUSARMGenerator()
var autoHealCustomActionSTATUSARMGenerator gopter.Gen

// AutoHealCustomActionSTATUSARMGenerator returns a generator of AutoHealCustomAction_STATUSARM instances for property testing.
func AutoHealCustomActionSTATUSARMGenerator() gopter.Gen {
	if autoHealCustomActionSTATUSARMGenerator != nil {
		return autoHealCustomActionSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoHealCustomActionSTATUSARM(generators)
	autoHealCustomActionSTATUSARMGenerator = gen.Struct(reflect.TypeOf(AutoHealCustomAction_STATUSARM{}), generators)

	return autoHealCustomActionSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForAutoHealCustomActionSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoHealCustomActionSTATUSARM(gens map[string]gopter.Gen) {
	gens["Exe"] = gen.PtrOf(gen.AlphaString())
	gens["Parameters"] = gen.PtrOf(gen.AlphaString())
}

func Test_RequestsBasedTrigger_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RequestsBasedTrigger_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRequestsBasedTriggerSTATUSARM, RequestsBasedTriggerSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRequestsBasedTriggerSTATUSARM runs a test to see if a specific instance of RequestsBasedTrigger_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRequestsBasedTriggerSTATUSARM(subject RequestsBasedTrigger_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RequestsBasedTrigger_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RequestsBasedTrigger_STATUSARM instances for property testing - lazily instantiated by
// RequestsBasedTriggerSTATUSARMGenerator()
var requestsBasedTriggerSTATUSARMGenerator gopter.Gen

// RequestsBasedTriggerSTATUSARMGenerator returns a generator of RequestsBasedTrigger_STATUSARM instances for property testing.
func RequestsBasedTriggerSTATUSARMGenerator() gopter.Gen {
	if requestsBasedTriggerSTATUSARMGenerator != nil {
		return requestsBasedTriggerSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRequestsBasedTriggerSTATUSARM(generators)
	requestsBasedTriggerSTATUSARMGenerator = gen.Struct(reflect.TypeOf(RequestsBasedTrigger_STATUSARM{}), generators)

	return requestsBasedTriggerSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForRequestsBasedTriggerSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRequestsBasedTriggerSTATUSARM(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["TimeInterval"] = gen.PtrOf(gen.AlphaString())
}

func Test_SlowRequestsBasedTrigger_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SlowRequestsBasedTrigger_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSlowRequestsBasedTriggerSTATUSARM, SlowRequestsBasedTriggerSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSlowRequestsBasedTriggerSTATUSARM runs a test to see if a specific instance of SlowRequestsBasedTrigger_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSlowRequestsBasedTriggerSTATUSARM(subject SlowRequestsBasedTrigger_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SlowRequestsBasedTrigger_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SlowRequestsBasedTrigger_STATUSARM instances for property testing - lazily instantiated by
// SlowRequestsBasedTriggerSTATUSARMGenerator()
var slowRequestsBasedTriggerSTATUSARMGenerator gopter.Gen

// SlowRequestsBasedTriggerSTATUSARMGenerator returns a generator of SlowRequestsBasedTrigger_STATUSARM instances for property testing.
func SlowRequestsBasedTriggerSTATUSARMGenerator() gopter.Gen {
	if slowRequestsBasedTriggerSTATUSARMGenerator != nil {
		return slowRequestsBasedTriggerSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSlowRequestsBasedTriggerSTATUSARM(generators)
	slowRequestsBasedTriggerSTATUSARMGenerator = gen.Struct(reflect.TypeOf(SlowRequestsBasedTrigger_STATUSARM{}), generators)

	return slowRequestsBasedTriggerSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForSlowRequestsBasedTriggerSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSlowRequestsBasedTriggerSTATUSARM(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["TimeInterval"] = gen.PtrOf(gen.AlphaString())
	gens["TimeTaken"] = gen.PtrOf(gen.AlphaString())
}

func Test_StatusCodesBasedTrigger_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StatusCodesBasedTrigger_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStatusCodesBasedTriggerSTATUSARM, StatusCodesBasedTriggerSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStatusCodesBasedTriggerSTATUSARM runs a test to see if a specific instance of StatusCodesBasedTrigger_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStatusCodesBasedTriggerSTATUSARM(subject StatusCodesBasedTrigger_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StatusCodesBasedTrigger_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StatusCodesBasedTrigger_STATUSARM instances for property testing - lazily instantiated by
// StatusCodesBasedTriggerSTATUSARMGenerator()
var statusCodesBasedTriggerSTATUSARMGenerator gopter.Gen

// StatusCodesBasedTriggerSTATUSARMGenerator returns a generator of StatusCodesBasedTrigger_STATUSARM instances for property testing.
func StatusCodesBasedTriggerSTATUSARMGenerator() gopter.Gen {
	if statusCodesBasedTriggerSTATUSARMGenerator != nil {
		return statusCodesBasedTriggerSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStatusCodesBasedTriggerSTATUSARM(generators)
	statusCodesBasedTriggerSTATUSARMGenerator = gen.Struct(reflect.TypeOf(StatusCodesBasedTrigger_STATUSARM{}), generators)

	return statusCodesBasedTriggerSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForStatusCodesBasedTriggerSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStatusCodesBasedTriggerSTATUSARM(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.Int())
	gens["SubStatus"] = gen.PtrOf(gen.Int())
	gens["TimeInterval"] = gen.PtrOf(gen.AlphaString())
	gens["Win32Status"] = gen.PtrOf(gen.Int())
}

func Test_StatusCodesRangeBasedTrigger_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StatusCodesRangeBasedTrigger_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStatusCodesRangeBasedTriggerSTATUSARM, StatusCodesRangeBasedTriggerSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStatusCodesRangeBasedTriggerSTATUSARM runs a test to see if a specific instance of StatusCodesRangeBasedTrigger_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStatusCodesRangeBasedTriggerSTATUSARM(subject StatusCodesRangeBasedTrigger_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StatusCodesRangeBasedTrigger_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StatusCodesRangeBasedTrigger_STATUSARM instances for property testing - lazily instantiated by
// StatusCodesRangeBasedTriggerSTATUSARMGenerator()
var statusCodesRangeBasedTriggerSTATUSARMGenerator gopter.Gen

// StatusCodesRangeBasedTriggerSTATUSARMGenerator returns a generator of StatusCodesRangeBasedTrigger_STATUSARM instances for property testing.
func StatusCodesRangeBasedTriggerSTATUSARMGenerator() gopter.Gen {
	if statusCodesRangeBasedTriggerSTATUSARMGenerator != nil {
		return statusCodesRangeBasedTriggerSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStatusCodesRangeBasedTriggerSTATUSARM(generators)
	statusCodesRangeBasedTriggerSTATUSARMGenerator = gen.Struct(reflect.TypeOf(StatusCodesRangeBasedTrigger_STATUSARM{}), generators)

	return statusCodesRangeBasedTriggerSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForStatusCodesRangeBasedTriggerSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStatusCodesRangeBasedTriggerSTATUSARM(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["StatusCodes"] = gen.PtrOf(gen.AlphaString())
	gens["TimeInterval"] = gen.PtrOf(gen.AlphaString())
}
