// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20230101

import (
	"encoding/json"
	v20230101s "github.com/Azure/azure-service-operator/v2/api/insights/v1api20230101storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_ActionGroup_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	parameters.MinSuccessfulTests = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ActionGroup to hub returns original",
		prop.ForAll(RunResourceConversionTestForActionGroup, ActionGroupGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForActionGroup tests if a specific instance of ActionGroup round trips to the hub storage version and back losslessly
func RunResourceConversionTestForActionGroup(subject ActionGroup) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v20230101s.ActionGroup
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual ActionGroup
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ActionGroup_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ActionGroup to ActionGroup via AssignProperties_To_ActionGroup & AssignProperties_From_ActionGroup returns original",
		prop.ForAll(RunPropertyAssignmentTestForActionGroup, ActionGroupGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForActionGroup tests if a specific instance of ActionGroup can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForActionGroup(subject ActionGroup) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230101s.ActionGroup
	err := copied.AssignProperties_To_ActionGroup(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ActionGroup
	err = actual.AssignProperties_From_ActionGroup(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ActionGroup_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ActionGroup via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForActionGroup, ActionGroupGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForActionGroup runs a test to see if a specific instance of ActionGroup round trips to JSON and back losslessly
func RunJSONSerializationTestForActionGroup(subject ActionGroup) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ActionGroup
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ActionGroup instances for property testing - lazily instantiated by ActionGroupGenerator()
var actionGroupGenerator gopter.Gen

// ActionGroupGenerator returns a generator of ActionGroup instances for property testing.
func ActionGroupGenerator() gopter.Gen {
	if actionGroupGenerator != nil {
		return actionGroupGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForActionGroup(generators)
	actionGroupGenerator = gen.Struct(reflect.TypeOf(ActionGroup{}), generators)

	return actionGroupGenerator
}

// AddRelatedPropertyGeneratorsForActionGroup is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForActionGroup(gens map[string]gopter.Gen) {
	gens["Spec"] = ActionGroup_SpecGenerator()
	gens["Status"] = ActionGroupResource_STATUSGenerator()
}

func Test_ActionGroup_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ActionGroup_Spec to ActionGroup_Spec via AssignProperties_To_ActionGroup_Spec & AssignProperties_From_ActionGroup_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForActionGroup_Spec, ActionGroup_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForActionGroup_Spec tests if a specific instance of ActionGroup_Spec can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForActionGroup_Spec(subject ActionGroup_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230101s.ActionGroup_Spec
	err := copied.AssignProperties_To_ActionGroup_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ActionGroup_Spec
	err = actual.AssignProperties_From_ActionGroup_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ActionGroup_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ActionGroup_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForActionGroup_Spec, ActionGroup_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForActionGroup_Spec runs a test to see if a specific instance of ActionGroup_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForActionGroup_Spec(subject ActionGroup_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ActionGroup_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ActionGroup_Spec instances for property testing - lazily instantiated by ActionGroup_SpecGenerator()
var actionGroup_SpecGenerator gopter.Gen

// ActionGroup_SpecGenerator returns a generator of ActionGroup_Spec instances for property testing.
// We first initialize actionGroup_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ActionGroup_SpecGenerator() gopter.Gen {
	if actionGroup_SpecGenerator != nil {
		return actionGroup_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForActionGroup_Spec(generators)
	actionGroup_SpecGenerator = gen.Struct(reflect.TypeOf(ActionGroup_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForActionGroup_Spec(generators)
	AddRelatedPropertyGeneratorsForActionGroup_Spec(generators)
	actionGroup_SpecGenerator = gen.Struct(reflect.TypeOf(ActionGroup_Spec{}), generators)

	return actionGroup_SpecGenerator
}

// AddIndependentPropertyGeneratorsForActionGroup_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForActionGroup_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["GroupShortName"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForActionGroup_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForActionGroup_Spec(gens map[string]gopter.Gen) {
	gens["ArmRoleReceivers"] = gen.SliceOf(ArmRoleReceiverGenerator())
	gens["AutomationRunbookReceivers"] = gen.SliceOf(AutomationRunbookReceiverGenerator())
	gens["AzureAppPushReceivers"] = gen.SliceOf(AzureAppPushReceiverGenerator())
	gens["AzureFunctionReceivers"] = gen.SliceOf(AzureFunctionReceiverGenerator())
	gens["EmailReceivers"] = gen.SliceOf(EmailReceiverGenerator())
	gens["EventHubReceivers"] = gen.SliceOf(EventHubReceiverGenerator())
	gens["ItsmReceivers"] = gen.SliceOf(ItsmReceiverGenerator())
	gens["LogicAppReceivers"] = gen.SliceOf(LogicAppReceiverGenerator())
	gens["SmsReceivers"] = gen.SliceOf(SmsReceiverGenerator())
	gens["VoiceReceivers"] = gen.SliceOf(VoiceReceiverGenerator())
	gens["WebhookReceivers"] = gen.SliceOf(WebhookReceiverGenerator())
}

func Test_ActionGroupResource_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ActionGroupResource_STATUS to ActionGroupResource_STATUS via AssignProperties_To_ActionGroupResource_STATUS & AssignProperties_From_ActionGroupResource_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForActionGroupResource_STATUS, ActionGroupResource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForActionGroupResource_STATUS tests if a specific instance of ActionGroupResource_STATUS can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForActionGroupResource_STATUS(subject ActionGroupResource_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230101s.ActionGroupResource_STATUS
	err := copied.AssignProperties_To_ActionGroupResource_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ActionGroupResource_STATUS
	err = actual.AssignProperties_From_ActionGroupResource_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ActionGroupResource_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ActionGroupResource_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForActionGroupResource_STATUS, ActionGroupResource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForActionGroupResource_STATUS runs a test to see if a specific instance of ActionGroupResource_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForActionGroupResource_STATUS(subject ActionGroupResource_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ActionGroupResource_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ActionGroupResource_STATUS instances for property testing - lazily instantiated by
// ActionGroupResource_STATUSGenerator()
var actionGroupResource_STATUSGenerator gopter.Gen

// ActionGroupResource_STATUSGenerator returns a generator of ActionGroupResource_STATUS instances for property testing.
// We first initialize actionGroupResource_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ActionGroupResource_STATUSGenerator() gopter.Gen {
	if actionGroupResource_STATUSGenerator != nil {
		return actionGroupResource_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForActionGroupResource_STATUS(generators)
	actionGroupResource_STATUSGenerator = gen.Struct(reflect.TypeOf(ActionGroupResource_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForActionGroupResource_STATUS(generators)
	AddRelatedPropertyGeneratorsForActionGroupResource_STATUS(generators)
	actionGroupResource_STATUSGenerator = gen.Struct(reflect.TypeOf(ActionGroupResource_STATUS{}), generators)

	return actionGroupResource_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForActionGroupResource_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForActionGroupResource_STATUS(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["GroupShortName"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForActionGroupResource_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForActionGroupResource_STATUS(gens map[string]gopter.Gen) {
	gens["ArmRoleReceivers"] = gen.SliceOf(ArmRoleReceiver_STATUSGenerator())
	gens["AutomationRunbookReceivers"] = gen.SliceOf(AutomationRunbookReceiver_STATUSGenerator())
	gens["AzureAppPushReceivers"] = gen.SliceOf(AzureAppPushReceiver_STATUSGenerator())
	gens["AzureFunctionReceivers"] = gen.SliceOf(AzureFunctionReceiver_STATUSGenerator())
	gens["EmailReceivers"] = gen.SliceOf(EmailReceiver_STATUSGenerator())
	gens["EventHubReceivers"] = gen.SliceOf(EventHubReceiver_STATUSGenerator())
	gens["ItsmReceivers"] = gen.SliceOf(ItsmReceiver_STATUSGenerator())
	gens["LogicAppReceivers"] = gen.SliceOf(LogicAppReceiver_STATUSGenerator())
	gens["SmsReceivers"] = gen.SliceOf(SmsReceiver_STATUSGenerator())
	gens["VoiceReceivers"] = gen.SliceOf(VoiceReceiver_STATUSGenerator())
	gens["WebhookReceivers"] = gen.SliceOf(WebhookReceiver_STATUSGenerator())
}

func Test_ArmRoleReceiver_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ArmRoleReceiver to ArmRoleReceiver via AssignProperties_To_ArmRoleReceiver & AssignProperties_From_ArmRoleReceiver returns original",
		prop.ForAll(RunPropertyAssignmentTestForArmRoleReceiver, ArmRoleReceiverGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForArmRoleReceiver tests if a specific instance of ArmRoleReceiver can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForArmRoleReceiver(subject ArmRoleReceiver) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230101s.ArmRoleReceiver
	err := copied.AssignProperties_To_ArmRoleReceiver(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ArmRoleReceiver
	err = actual.AssignProperties_From_ArmRoleReceiver(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ArmRoleReceiver_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ArmRoleReceiver via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForArmRoleReceiver, ArmRoleReceiverGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForArmRoleReceiver runs a test to see if a specific instance of ArmRoleReceiver round trips to JSON and back losslessly
func RunJSONSerializationTestForArmRoleReceiver(subject ArmRoleReceiver) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ArmRoleReceiver
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ArmRoleReceiver instances for property testing - lazily instantiated by ArmRoleReceiverGenerator()
var armRoleReceiverGenerator gopter.Gen

// ArmRoleReceiverGenerator returns a generator of ArmRoleReceiver instances for property testing.
func ArmRoleReceiverGenerator() gopter.Gen {
	if armRoleReceiverGenerator != nil {
		return armRoleReceiverGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForArmRoleReceiver(generators)
	armRoleReceiverGenerator = gen.Struct(reflect.TypeOf(ArmRoleReceiver{}), generators)

	return armRoleReceiverGenerator
}

// AddIndependentPropertyGeneratorsForArmRoleReceiver is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForArmRoleReceiver(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["RoleId"] = gen.PtrOf(gen.AlphaString())
	gens["UseCommonAlertSchema"] = gen.PtrOf(gen.Bool())
}

func Test_ArmRoleReceiver_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ArmRoleReceiver_STATUS to ArmRoleReceiver_STATUS via AssignProperties_To_ArmRoleReceiver_STATUS & AssignProperties_From_ArmRoleReceiver_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForArmRoleReceiver_STATUS, ArmRoleReceiver_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForArmRoleReceiver_STATUS tests if a specific instance of ArmRoleReceiver_STATUS can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForArmRoleReceiver_STATUS(subject ArmRoleReceiver_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230101s.ArmRoleReceiver_STATUS
	err := copied.AssignProperties_To_ArmRoleReceiver_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ArmRoleReceiver_STATUS
	err = actual.AssignProperties_From_ArmRoleReceiver_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ArmRoleReceiver_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ArmRoleReceiver_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForArmRoleReceiver_STATUS, ArmRoleReceiver_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForArmRoleReceiver_STATUS runs a test to see if a specific instance of ArmRoleReceiver_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForArmRoleReceiver_STATUS(subject ArmRoleReceiver_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ArmRoleReceiver_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ArmRoleReceiver_STATUS instances for property testing - lazily instantiated by
// ArmRoleReceiver_STATUSGenerator()
var armRoleReceiver_STATUSGenerator gopter.Gen

// ArmRoleReceiver_STATUSGenerator returns a generator of ArmRoleReceiver_STATUS instances for property testing.
func ArmRoleReceiver_STATUSGenerator() gopter.Gen {
	if armRoleReceiver_STATUSGenerator != nil {
		return armRoleReceiver_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForArmRoleReceiver_STATUS(generators)
	armRoleReceiver_STATUSGenerator = gen.Struct(reflect.TypeOf(ArmRoleReceiver_STATUS{}), generators)

	return armRoleReceiver_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForArmRoleReceiver_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForArmRoleReceiver_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["RoleId"] = gen.PtrOf(gen.AlphaString())
	gens["UseCommonAlertSchema"] = gen.PtrOf(gen.Bool())
}

func Test_AutomationRunbookReceiver_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AutomationRunbookReceiver to AutomationRunbookReceiver via AssignProperties_To_AutomationRunbookReceiver & AssignProperties_From_AutomationRunbookReceiver returns original",
		prop.ForAll(RunPropertyAssignmentTestForAutomationRunbookReceiver, AutomationRunbookReceiverGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAutomationRunbookReceiver tests if a specific instance of AutomationRunbookReceiver can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForAutomationRunbookReceiver(subject AutomationRunbookReceiver) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230101s.AutomationRunbookReceiver
	err := copied.AssignProperties_To_AutomationRunbookReceiver(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AutomationRunbookReceiver
	err = actual.AssignProperties_From_AutomationRunbookReceiver(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AutomationRunbookReceiver_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutomationRunbookReceiver via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutomationRunbookReceiver, AutomationRunbookReceiverGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutomationRunbookReceiver runs a test to see if a specific instance of AutomationRunbookReceiver round trips to JSON and back losslessly
func RunJSONSerializationTestForAutomationRunbookReceiver(subject AutomationRunbookReceiver) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutomationRunbookReceiver
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutomationRunbookReceiver instances for property testing - lazily instantiated by
// AutomationRunbookReceiverGenerator()
var automationRunbookReceiverGenerator gopter.Gen

// AutomationRunbookReceiverGenerator returns a generator of AutomationRunbookReceiver instances for property testing.
func AutomationRunbookReceiverGenerator() gopter.Gen {
	if automationRunbookReceiverGenerator != nil {
		return automationRunbookReceiverGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutomationRunbookReceiver(generators)
	automationRunbookReceiverGenerator = gen.Struct(reflect.TypeOf(AutomationRunbookReceiver{}), generators)

	return automationRunbookReceiverGenerator
}

// AddIndependentPropertyGeneratorsForAutomationRunbookReceiver is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutomationRunbookReceiver(gens map[string]gopter.Gen) {
	gens["AutomationAccountId"] = gen.PtrOf(gen.AlphaString())
	gens["IsGlobalRunbook"] = gen.PtrOf(gen.Bool())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["RunbookName"] = gen.PtrOf(gen.AlphaString())
	gens["ServiceUri"] = gen.PtrOf(gen.AlphaString())
	gens["UseCommonAlertSchema"] = gen.PtrOf(gen.Bool())
}

func Test_AutomationRunbookReceiver_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AutomationRunbookReceiver_STATUS to AutomationRunbookReceiver_STATUS via AssignProperties_To_AutomationRunbookReceiver_STATUS & AssignProperties_From_AutomationRunbookReceiver_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAutomationRunbookReceiver_STATUS, AutomationRunbookReceiver_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAutomationRunbookReceiver_STATUS tests if a specific instance of AutomationRunbookReceiver_STATUS can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForAutomationRunbookReceiver_STATUS(subject AutomationRunbookReceiver_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230101s.AutomationRunbookReceiver_STATUS
	err := copied.AssignProperties_To_AutomationRunbookReceiver_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AutomationRunbookReceiver_STATUS
	err = actual.AssignProperties_From_AutomationRunbookReceiver_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AutomationRunbookReceiver_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutomationRunbookReceiver_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutomationRunbookReceiver_STATUS, AutomationRunbookReceiver_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutomationRunbookReceiver_STATUS runs a test to see if a specific instance of AutomationRunbookReceiver_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAutomationRunbookReceiver_STATUS(subject AutomationRunbookReceiver_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutomationRunbookReceiver_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutomationRunbookReceiver_STATUS instances for property testing - lazily instantiated by
// AutomationRunbookReceiver_STATUSGenerator()
var automationRunbookReceiver_STATUSGenerator gopter.Gen

// AutomationRunbookReceiver_STATUSGenerator returns a generator of AutomationRunbookReceiver_STATUS instances for property testing.
func AutomationRunbookReceiver_STATUSGenerator() gopter.Gen {
	if automationRunbookReceiver_STATUSGenerator != nil {
		return automationRunbookReceiver_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutomationRunbookReceiver_STATUS(generators)
	automationRunbookReceiver_STATUSGenerator = gen.Struct(reflect.TypeOf(AutomationRunbookReceiver_STATUS{}), generators)

	return automationRunbookReceiver_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAutomationRunbookReceiver_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutomationRunbookReceiver_STATUS(gens map[string]gopter.Gen) {
	gens["AutomationAccountId"] = gen.PtrOf(gen.AlphaString())
	gens["IsGlobalRunbook"] = gen.PtrOf(gen.Bool())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["RunbookName"] = gen.PtrOf(gen.AlphaString())
	gens["ServiceUri"] = gen.PtrOf(gen.AlphaString())
	gens["UseCommonAlertSchema"] = gen.PtrOf(gen.Bool())
	gens["WebhookResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_AzureAppPushReceiver_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AzureAppPushReceiver to AzureAppPushReceiver via AssignProperties_To_AzureAppPushReceiver & AssignProperties_From_AzureAppPushReceiver returns original",
		prop.ForAll(RunPropertyAssignmentTestForAzureAppPushReceiver, AzureAppPushReceiverGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAzureAppPushReceiver tests if a specific instance of AzureAppPushReceiver can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForAzureAppPushReceiver(subject AzureAppPushReceiver) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230101s.AzureAppPushReceiver
	err := copied.AssignProperties_To_AzureAppPushReceiver(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AzureAppPushReceiver
	err = actual.AssignProperties_From_AzureAppPushReceiver(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AzureAppPushReceiver_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureAppPushReceiver via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureAppPushReceiver, AzureAppPushReceiverGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureAppPushReceiver runs a test to see if a specific instance of AzureAppPushReceiver round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureAppPushReceiver(subject AzureAppPushReceiver) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureAppPushReceiver
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureAppPushReceiver instances for property testing - lazily instantiated by
// AzureAppPushReceiverGenerator()
var azureAppPushReceiverGenerator gopter.Gen

// AzureAppPushReceiverGenerator returns a generator of AzureAppPushReceiver instances for property testing.
func AzureAppPushReceiverGenerator() gopter.Gen {
	if azureAppPushReceiverGenerator != nil {
		return azureAppPushReceiverGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureAppPushReceiver(generators)
	azureAppPushReceiverGenerator = gen.Struct(reflect.TypeOf(AzureAppPushReceiver{}), generators)

	return azureAppPushReceiverGenerator
}

// AddIndependentPropertyGeneratorsForAzureAppPushReceiver is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureAppPushReceiver(gens map[string]gopter.Gen) {
	gens["EmailAddress"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_AzureAppPushReceiver_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AzureAppPushReceiver_STATUS to AzureAppPushReceiver_STATUS via AssignProperties_To_AzureAppPushReceiver_STATUS & AssignProperties_From_AzureAppPushReceiver_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAzureAppPushReceiver_STATUS, AzureAppPushReceiver_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAzureAppPushReceiver_STATUS tests if a specific instance of AzureAppPushReceiver_STATUS can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForAzureAppPushReceiver_STATUS(subject AzureAppPushReceiver_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230101s.AzureAppPushReceiver_STATUS
	err := copied.AssignProperties_To_AzureAppPushReceiver_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AzureAppPushReceiver_STATUS
	err = actual.AssignProperties_From_AzureAppPushReceiver_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AzureAppPushReceiver_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureAppPushReceiver_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureAppPushReceiver_STATUS, AzureAppPushReceiver_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureAppPushReceiver_STATUS runs a test to see if a specific instance of AzureAppPushReceiver_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureAppPushReceiver_STATUS(subject AzureAppPushReceiver_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureAppPushReceiver_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureAppPushReceiver_STATUS instances for property testing - lazily instantiated by
// AzureAppPushReceiver_STATUSGenerator()
var azureAppPushReceiver_STATUSGenerator gopter.Gen

// AzureAppPushReceiver_STATUSGenerator returns a generator of AzureAppPushReceiver_STATUS instances for property testing.
func AzureAppPushReceiver_STATUSGenerator() gopter.Gen {
	if azureAppPushReceiver_STATUSGenerator != nil {
		return azureAppPushReceiver_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureAppPushReceiver_STATUS(generators)
	azureAppPushReceiver_STATUSGenerator = gen.Struct(reflect.TypeOf(AzureAppPushReceiver_STATUS{}), generators)

	return azureAppPushReceiver_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAzureAppPushReceiver_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureAppPushReceiver_STATUS(gens map[string]gopter.Gen) {
	gens["EmailAddress"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_AzureFunctionReceiver_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AzureFunctionReceiver to AzureFunctionReceiver via AssignProperties_To_AzureFunctionReceiver & AssignProperties_From_AzureFunctionReceiver returns original",
		prop.ForAll(RunPropertyAssignmentTestForAzureFunctionReceiver, AzureFunctionReceiverGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAzureFunctionReceiver tests if a specific instance of AzureFunctionReceiver can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForAzureFunctionReceiver(subject AzureFunctionReceiver) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230101s.AzureFunctionReceiver
	err := copied.AssignProperties_To_AzureFunctionReceiver(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AzureFunctionReceiver
	err = actual.AssignProperties_From_AzureFunctionReceiver(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AzureFunctionReceiver_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFunctionReceiver via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFunctionReceiver, AzureFunctionReceiverGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFunctionReceiver runs a test to see if a specific instance of AzureFunctionReceiver round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFunctionReceiver(subject AzureFunctionReceiver) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFunctionReceiver
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFunctionReceiver instances for property testing - lazily instantiated by
// AzureFunctionReceiverGenerator()
var azureFunctionReceiverGenerator gopter.Gen

// AzureFunctionReceiverGenerator returns a generator of AzureFunctionReceiver instances for property testing.
func AzureFunctionReceiverGenerator() gopter.Gen {
	if azureFunctionReceiverGenerator != nil {
		return azureFunctionReceiverGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFunctionReceiver(generators)
	azureFunctionReceiverGenerator = gen.Struct(reflect.TypeOf(AzureFunctionReceiver{}), generators)

	return azureFunctionReceiverGenerator
}

// AddIndependentPropertyGeneratorsForAzureFunctionReceiver is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFunctionReceiver(gens map[string]gopter.Gen) {
	gens["FunctionName"] = gen.PtrOf(gen.AlphaString())
	gens["HttpTriggerUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["UseCommonAlertSchema"] = gen.PtrOf(gen.Bool())
}

func Test_AzureFunctionReceiver_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AzureFunctionReceiver_STATUS to AzureFunctionReceiver_STATUS via AssignProperties_To_AzureFunctionReceiver_STATUS & AssignProperties_From_AzureFunctionReceiver_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAzureFunctionReceiver_STATUS, AzureFunctionReceiver_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAzureFunctionReceiver_STATUS tests if a specific instance of AzureFunctionReceiver_STATUS can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForAzureFunctionReceiver_STATUS(subject AzureFunctionReceiver_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230101s.AzureFunctionReceiver_STATUS
	err := copied.AssignProperties_To_AzureFunctionReceiver_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AzureFunctionReceiver_STATUS
	err = actual.AssignProperties_From_AzureFunctionReceiver_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AzureFunctionReceiver_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFunctionReceiver_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFunctionReceiver_STATUS, AzureFunctionReceiver_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFunctionReceiver_STATUS runs a test to see if a specific instance of AzureFunctionReceiver_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFunctionReceiver_STATUS(subject AzureFunctionReceiver_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFunctionReceiver_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFunctionReceiver_STATUS instances for property testing - lazily instantiated by
// AzureFunctionReceiver_STATUSGenerator()
var azureFunctionReceiver_STATUSGenerator gopter.Gen

// AzureFunctionReceiver_STATUSGenerator returns a generator of AzureFunctionReceiver_STATUS instances for property testing.
func AzureFunctionReceiver_STATUSGenerator() gopter.Gen {
	if azureFunctionReceiver_STATUSGenerator != nil {
		return azureFunctionReceiver_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFunctionReceiver_STATUS(generators)
	azureFunctionReceiver_STATUSGenerator = gen.Struct(reflect.TypeOf(AzureFunctionReceiver_STATUS{}), generators)

	return azureFunctionReceiver_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAzureFunctionReceiver_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFunctionReceiver_STATUS(gens map[string]gopter.Gen) {
	gens["FunctionAppResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["FunctionName"] = gen.PtrOf(gen.AlphaString())
	gens["HttpTriggerUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["UseCommonAlertSchema"] = gen.PtrOf(gen.Bool())
}

func Test_EmailReceiver_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EmailReceiver to EmailReceiver via AssignProperties_To_EmailReceiver & AssignProperties_From_EmailReceiver returns original",
		prop.ForAll(RunPropertyAssignmentTestForEmailReceiver, EmailReceiverGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEmailReceiver tests if a specific instance of EmailReceiver can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForEmailReceiver(subject EmailReceiver) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230101s.EmailReceiver
	err := copied.AssignProperties_To_EmailReceiver(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EmailReceiver
	err = actual.AssignProperties_From_EmailReceiver(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EmailReceiver_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EmailReceiver via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEmailReceiver, EmailReceiverGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEmailReceiver runs a test to see if a specific instance of EmailReceiver round trips to JSON and back losslessly
func RunJSONSerializationTestForEmailReceiver(subject EmailReceiver) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EmailReceiver
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EmailReceiver instances for property testing - lazily instantiated by EmailReceiverGenerator()
var emailReceiverGenerator gopter.Gen

// EmailReceiverGenerator returns a generator of EmailReceiver instances for property testing.
func EmailReceiverGenerator() gopter.Gen {
	if emailReceiverGenerator != nil {
		return emailReceiverGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEmailReceiver(generators)
	emailReceiverGenerator = gen.Struct(reflect.TypeOf(EmailReceiver{}), generators)

	return emailReceiverGenerator
}

// AddIndependentPropertyGeneratorsForEmailReceiver is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEmailReceiver(gens map[string]gopter.Gen) {
	gens["EmailAddress"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["UseCommonAlertSchema"] = gen.PtrOf(gen.Bool())
}

func Test_EmailReceiver_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EmailReceiver_STATUS to EmailReceiver_STATUS via AssignProperties_To_EmailReceiver_STATUS & AssignProperties_From_EmailReceiver_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForEmailReceiver_STATUS, EmailReceiver_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEmailReceiver_STATUS tests if a specific instance of EmailReceiver_STATUS can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForEmailReceiver_STATUS(subject EmailReceiver_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230101s.EmailReceiver_STATUS
	err := copied.AssignProperties_To_EmailReceiver_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EmailReceiver_STATUS
	err = actual.AssignProperties_From_EmailReceiver_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EmailReceiver_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EmailReceiver_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEmailReceiver_STATUS, EmailReceiver_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEmailReceiver_STATUS runs a test to see if a specific instance of EmailReceiver_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEmailReceiver_STATUS(subject EmailReceiver_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EmailReceiver_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EmailReceiver_STATUS instances for property testing - lazily instantiated by
// EmailReceiver_STATUSGenerator()
var emailReceiver_STATUSGenerator gopter.Gen

// EmailReceiver_STATUSGenerator returns a generator of EmailReceiver_STATUS instances for property testing.
func EmailReceiver_STATUSGenerator() gopter.Gen {
	if emailReceiver_STATUSGenerator != nil {
		return emailReceiver_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEmailReceiver_STATUS(generators)
	emailReceiver_STATUSGenerator = gen.Struct(reflect.TypeOf(EmailReceiver_STATUS{}), generators)

	return emailReceiver_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForEmailReceiver_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEmailReceiver_STATUS(gens map[string]gopter.Gen) {
	gens["EmailAddress"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(ReceiverStatus_STATUS_Disabled, ReceiverStatus_STATUS_Enabled, ReceiverStatus_STATUS_NotSpecified))
	gens["UseCommonAlertSchema"] = gen.PtrOf(gen.Bool())
}

func Test_EventHubReceiver_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EventHubReceiver to EventHubReceiver via AssignProperties_To_EventHubReceiver & AssignProperties_From_EventHubReceiver returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventHubReceiver, EventHubReceiverGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventHubReceiver tests if a specific instance of EventHubReceiver can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForEventHubReceiver(subject EventHubReceiver) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230101s.EventHubReceiver
	err := copied.AssignProperties_To_EventHubReceiver(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EventHubReceiver
	err = actual.AssignProperties_From_EventHubReceiver(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventHubReceiver_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventHubReceiver via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventHubReceiver, EventHubReceiverGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventHubReceiver runs a test to see if a specific instance of EventHubReceiver round trips to JSON and back losslessly
func RunJSONSerializationTestForEventHubReceiver(subject EventHubReceiver) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventHubReceiver
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventHubReceiver instances for property testing - lazily instantiated by EventHubReceiverGenerator()
var eventHubReceiverGenerator gopter.Gen

// EventHubReceiverGenerator returns a generator of EventHubReceiver instances for property testing.
func EventHubReceiverGenerator() gopter.Gen {
	if eventHubReceiverGenerator != nil {
		return eventHubReceiverGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventHubReceiver(generators)
	eventHubReceiverGenerator = gen.Struct(reflect.TypeOf(EventHubReceiver{}), generators)

	return eventHubReceiverGenerator
}

// AddIndependentPropertyGeneratorsForEventHubReceiver is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventHubReceiver(gens map[string]gopter.Gen) {
	gens["EventHubName"] = gen.PtrOf(gen.AlphaString())
	gens["EventHubNameSpace"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["SubscriptionId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["UseCommonAlertSchema"] = gen.PtrOf(gen.Bool())
}

func Test_EventHubReceiver_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EventHubReceiver_STATUS to EventHubReceiver_STATUS via AssignProperties_To_EventHubReceiver_STATUS & AssignProperties_From_EventHubReceiver_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventHubReceiver_STATUS, EventHubReceiver_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventHubReceiver_STATUS tests if a specific instance of EventHubReceiver_STATUS can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForEventHubReceiver_STATUS(subject EventHubReceiver_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230101s.EventHubReceiver_STATUS
	err := copied.AssignProperties_To_EventHubReceiver_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EventHubReceiver_STATUS
	err = actual.AssignProperties_From_EventHubReceiver_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventHubReceiver_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventHubReceiver_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventHubReceiver_STATUS, EventHubReceiver_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventHubReceiver_STATUS runs a test to see if a specific instance of EventHubReceiver_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEventHubReceiver_STATUS(subject EventHubReceiver_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventHubReceiver_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventHubReceiver_STATUS instances for property testing - lazily instantiated by
// EventHubReceiver_STATUSGenerator()
var eventHubReceiver_STATUSGenerator gopter.Gen

// EventHubReceiver_STATUSGenerator returns a generator of EventHubReceiver_STATUS instances for property testing.
func EventHubReceiver_STATUSGenerator() gopter.Gen {
	if eventHubReceiver_STATUSGenerator != nil {
		return eventHubReceiver_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventHubReceiver_STATUS(generators)
	eventHubReceiver_STATUSGenerator = gen.Struct(reflect.TypeOf(EventHubReceiver_STATUS{}), generators)

	return eventHubReceiver_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForEventHubReceiver_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventHubReceiver_STATUS(gens map[string]gopter.Gen) {
	gens["EventHubName"] = gen.PtrOf(gen.AlphaString())
	gens["EventHubNameSpace"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["SubscriptionId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["UseCommonAlertSchema"] = gen.PtrOf(gen.Bool())
}

func Test_ItsmReceiver_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ItsmReceiver to ItsmReceiver via AssignProperties_To_ItsmReceiver & AssignProperties_From_ItsmReceiver returns original",
		prop.ForAll(RunPropertyAssignmentTestForItsmReceiver, ItsmReceiverGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForItsmReceiver tests if a specific instance of ItsmReceiver can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForItsmReceiver(subject ItsmReceiver) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230101s.ItsmReceiver
	err := copied.AssignProperties_To_ItsmReceiver(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ItsmReceiver
	err = actual.AssignProperties_From_ItsmReceiver(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ItsmReceiver_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ItsmReceiver via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForItsmReceiver, ItsmReceiverGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForItsmReceiver runs a test to see if a specific instance of ItsmReceiver round trips to JSON and back losslessly
func RunJSONSerializationTestForItsmReceiver(subject ItsmReceiver) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ItsmReceiver
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ItsmReceiver instances for property testing - lazily instantiated by ItsmReceiverGenerator()
var itsmReceiverGenerator gopter.Gen

// ItsmReceiverGenerator returns a generator of ItsmReceiver instances for property testing.
func ItsmReceiverGenerator() gopter.Gen {
	if itsmReceiverGenerator != nil {
		return itsmReceiverGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForItsmReceiver(generators)
	itsmReceiverGenerator = gen.Struct(reflect.TypeOf(ItsmReceiver{}), generators)

	return itsmReceiverGenerator
}

// AddIndependentPropertyGeneratorsForItsmReceiver is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForItsmReceiver(gens map[string]gopter.Gen) {
	gens["ConnectionId"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Region"] = gen.PtrOf(gen.AlphaString())
	gens["TicketConfiguration"] = gen.PtrOf(gen.AlphaString())
	gens["WorkspaceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_ItsmReceiver_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ItsmReceiver_STATUS to ItsmReceiver_STATUS via AssignProperties_To_ItsmReceiver_STATUS & AssignProperties_From_ItsmReceiver_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForItsmReceiver_STATUS, ItsmReceiver_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForItsmReceiver_STATUS tests if a specific instance of ItsmReceiver_STATUS can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForItsmReceiver_STATUS(subject ItsmReceiver_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230101s.ItsmReceiver_STATUS
	err := copied.AssignProperties_To_ItsmReceiver_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ItsmReceiver_STATUS
	err = actual.AssignProperties_From_ItsmReceiver_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ItsmReceiver_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ItsmReceiver_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForItsmReceiver_STATUS, ItsmReceiver_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForItsmReceiver_STATUS runs a test to see if a specific instance of ItsmReceiver_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForItsmReceiver_STATUS(subject ItsmReceiver_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ItsmReceiver_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ItsmReceiver_STATUS instances for property testing - lazily instantiated by
// ItsmReceiver_STATUSGenerator()
var itsmReceiver_STATUSGenerator gopter.Gen

// ItsmReceiver_STATUSGenerator returns a generator of ItsmReceiver_STATUS instances for property testing.
func ItsmReceiver_STATUSGenerator() gopter.Gen {
	if itsmReceiver_STATUSGenerator != nil {
		return itsmReceiver_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForItsmReceiver_STATUS(generators)
	itsmReceiver_STATUSGenerator = gen.Struct(reflect.TypeOf(ItsmReceiver_STATUS{}), generators)

	return itsmReceiver_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForItsmReceiver_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForItsmReceiver_STATUS(gens map[string]gopter.Gen) {
	gens["ConnectionId"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Region"] = gen.PtrOf(gen.AlphaString())
	gens["TicketConfiguration"] = gen.PtrOf(gen.AlphaString())
	gens["WorkspaceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_LogicAppReceiver_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LogicAppReceiver to LogicAppReceiver via AssignProperties_To_LogicAppReceiver & AssignProperties_From_LogicAppReceiver returns original",
		prop.ForAll(RunPropertyAssignmentTestForLogicAppReceiver, LogicAppReceiverGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLogicAppReceiver tests if a specific instance of LogicAppReceiver can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForLogicAppReceiver(subject LogicAppReceiver) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230101s.LogicAppReceiver
	err := copied.AssignProperties_To_LogicAppReceiver(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LogicAppReceiver
	err = actual.AssignProperties_From_LogicAppReceiver(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LogicAppReceiver_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LogicAppReceiver via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLogicAppReceiver, LogicAppReceiverGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLogicAppReceiver runs a test to see if a specific instance of LogicAppReceiver round trips to JSON and back losslessly
func RunJSONSerializationTestForLogicAppReceiver(subject LogicAppReceiver) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LogicAppReceiver
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LogicAppReceiver instances for property testing - lazily instantiated by LogicAppReceiverGenerator()
var logicAppReceiverGenerator gopter.Gen

// LogicAppReceiverGenerator returns a generator of LogicAppReceiver instances for property testing.
func LogicAppReceiverGenerator() gopter.Gen {
	if logicAppReceiverGenerator != nil {
		return logicAppReceiverGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLogicAppReceiver(generators)
	logicAppReceiverGenerator = gen.Struct(reflect.TypeOf(LogicAppReceiver{}), generators)

	return logicAppReceiverGenerator
}

// AddIndependentPropertyGeneratorsForLogicAppReceiver is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLogicAppReceiver(gens map[string]gopter.Gen) {
	gens["CallbackUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["UseCommonAlertSchema"] = gen.PtrOf(gen.Bool())
}

func Test_LogicAppReceiver_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LogicAppReceiver_STATUS to LogicAppReceiver_STATUS via AssignProperties_To_LogicAppReceiver_STATUS & AssignProperties_From_LogicAppReceiver_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForLogicAppReceiver_STATUS, LogicAppReceiver_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLogicAppReceiver_STATUS tests if a specific instance of LogicAppReceiver_STATUS can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForLogicAppReceiver_STATUS(subject LogicAppReceiver_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230101s.LogicAppReceiver_STATUS
	err := copied.AssignProperties_To_LogicAppReceiver_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LogicAppReceiver_STATUS
	err = actual.AssignProperties_From_LogicAppReceiver_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LogicAppReceiver_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LogicAppReceiver_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLogicAppReceiver_STATUS, LogicAppReceiver_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLogicAppReceiver_STATUS runs a test to see if a specific instance of LogicAppReceiver_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForLogicAppReceiver_STATUS(subject LogicAppReceiver_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LogicAppReceiver_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LogicAppReceiver_STATUS instances for property testing - lazily instantiated by
// LogicAppReceiver_STATUSGenerator()
var logicAppReceiver_STATUSGenerator gopter.Gen

// LogicAppReceiver_STATUSGenerator returns a generator of LogicAppReceiver_STATUS instances for property testing.
func LogicAppReceiver_STATUSGenerator() gopter.Gen {
	if logicAppReceiver_STATUSGenerator != nil {
		return logicAppReceiver_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLogicAppReceiver_STATUS(generators)
	logicAppReceiver_STATUSGenerator = gen.Struct(reflect.TypeOf(LogicAppReceiver_STATUS{}), generators)

	return logicAppReceiver_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForLogicAppReceiver_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLogicAppReceiver_STATUS(gens map[string]gopter.Gen) {
	gens["CallbackUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["UseCommonAlertSchema"] = gen.PtrOf(gen.Bool())
}

func Test_SmsReceiver_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SmsReceiver to SmsReceiver via AssignProperties_To_SmsReceiver & AssignProperties_From_SmsReceiver returns original",
		prop.ForAll(RunPropertyAssignmentTestForSmsReceiver, SmsReceiverGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSmsReceiver tests if a specific instance of SmsReceiver can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForSmsReceiver(subject SmsReceiver) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230101s.SmsReceiver
	err := copied.AssignProperties_To_SmsReceiver(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SmsReceiver
	err = actual.AssignProperties_From_SmsReceiver(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SmsReceiver_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SmsReceiver via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSmsReceiver, SmsReceiverGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSmsReceiver runs a test to see if a specific instance of SmsReceiver round trips to JSON and back losslessly
func RunJSONSerializationTestForSmsReceiver(subject SmsReceiver) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SmsReceiver
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SmsReceiver instances for property testing - lazily instantiated by SmsReceiverGenerator()
var smsReceiverGenerator gopter.Gen

// SmsReceiverGenerator returns a generator of SmsReceiver instances for property testing.
func SmsReceiverGenerator() gopter.Gen {
	if smsReceiverGenerator != nil {
		return smsReceiverGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSmsReceiver(generators)
	smsReceiverGenerator = gen.Struct(reflect.TypeOf(SmsReceiver{}), generators)

	return smsReceiverGenerator
}

// AddIndependentPropertyGeneratorsForSmsReceiver is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSmsReceiver(gens map[string]gopter.Gen) {
	gens["CountryCode"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PhoneNumber"] = gen.PtrOf(gen.AlphaString())
}

func Test_SmsReceiver_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SmsReceiver_STATUS to SmsReceiver_STATUS via AssignProperties_To_SmsReceiver_STATUS & AssignProperties_From_SmsReceiver_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSmsReceiver_STATUS, SmsReceiver_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSmsReceiver_STATUS tests if a specific instance of SmsReceiver_STATUS can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForSmsReceiver_STATUS(subject SmsReceiver_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230101s.SmsReceiver_STATUS
	err := copied.AssignProperties_To_SmsReceiver_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SmsReceiver_STATUS
	err = actual.AssignProperties_From_SmsReceiver_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SmsReceiver_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SmsReceiver_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSmsReceiver_STATUS, SmsReceiver_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSmsReceiver_STATUS runs a test to see if a specific instance of SmsReceiver_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSmsReceiver_STATUS(subject SmsReceiver_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SmsReceiver_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SmsReceiver_STATUS instances for property testing - lazily instantiated by SmsReceiver_STATUSGenerator()
var smsReceiver_STATUSGenerator gopter.Gen

// SmsReceiver_STATUSGenerator returns a generator of SmsReceiver_STATUS instances for property testing.
func SmsReceiver_STATUSGenerator() gopter.Gen {
	if smsReceiver_STATUSGenerator != nil {
		return smsReceiver_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSmsReceiver_STATUS(generators)
	smsReceiver_STATUSGenerator = gen.Struct(reflect.TypeOf(SmsReceiver_STATUS{}), generators)

	return smsReceiver_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSmsReceiver_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSmsReceiver_STATUS(gens map[string]gopter.Gen) {
	gens["CountryCode"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PhoneNumber"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(ReceiverStatus_STATUS_Disabled, ReceiverStatus_STATUS_Enabled, ReceiverStatus_STATUS_NotSpecified))
}

func Test_VoiceReceiver_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VoiceReceiver to VoiceReceiver via AssignProperties_To_VoiceReceiver & AssignProperties_From_VoiceReceiver returns original",
		prop.ForAll(RunPropertyAssignmentTestForVoiceReceiver, VoiceReceiverGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVoiceReceiver tests if a specific instance of VoiceReceiver can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForVoiceReceiver(subject VoiceReceiver) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230101s.VoiceReceiver
	err := copied.AssignProperties_To_VoiceReceiver(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VoiceReceiver
	err = actual.AssignProperties_From_VoiceReceiver(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VoiceReceiver_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VoiceReceiver via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVoiceReceiver, VoiceReceiverGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVoiceReceiver runs a test to see if a specific instance of VoiceReceiver round trips to JSON and back losslessly
func RunJSONSerializationTestForVoiceReceiver(subject VoiceReceiver) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VoiceReceiver
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VoiceReceiver instances for property testing - lazily instantiated by VoiceReceiverGenerator()
var voiceReceiverGenerator gopter.Gen

// VoiceReceiverGenerator returns a generator of VoiceReceiver instances for property testing.
func VoiceReceiverGenerator() gopter.Gen {
	if voiceReceiverGenerator != nil {
		return voiceReceiverGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVoiceReceiver(generators)
	voiceReceiverGenerator = gen.Struct(reflect.TypeOf(VoiceReceiver{}), generators)

	return voiceReceiverGenerator
}

// AddIndependentPropertyGeneratorsForVoiceReceiver is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVoiceReceiver(gens map[string]gopter.Gen) {
	gens["CountryCode"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PhoneNumber"] = gen.PtrOf(gen.AlphaString())
}

func Test_VoiceReceiver_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VoiceReceiver_STATUS to VoiceReceiver_STATUS via AssignProperties_To_VoiceReceiver_STATUS & AssignProperties_From_VoiceReceiver_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForVoiceReceiver_STATUS, VoiceReceiver_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVoiceReceiver_STATUS tests if a specific instance of VoiceReceiver_STATUS can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForVoiceReceiver_STATUS(subject VoiceReceiver_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230101s.VoiceReceiver_STATUS
	err := copied.AssignProperties_To_VoiceReceiver_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VoiceReceiver_STATUS
	err = actual.AssignProperties_From_VoiceReceiver_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VoiceReceiver_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VoiceReceiver_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVoiceReceiver_STATUS, VoiceReceiver_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVoiceReceiver_STATUS runs a test to see if a specific instance of VoiceReceiver_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForVoiceReceiver_STATUS(subject VoiceReceiver_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VoiceReceiver_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VoiceReceiver_STATUS instances for property testing - lazily instantiated by
// VoiceReceiver_STATUSGenerator()
var voiceReceiver_STATUSGenerator gopter.Gen

// VoiceReceiver_STATUSGenerator returns a generator of VoiceReceiver_STATUS instances for property testing.
func VoiceReceiver_STATUSGenerator() gopter.Gen {
	if voiceReceiver_STATUSGenerator != nil {
		return voiceReceiver_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVoiceReceiver_STATUS(generators)
	voiceReceiver_STATUSGenerator = gen.Struct(reflect.TypeOf(VoiceReceiver_STATUS{}), generators)

	return voiceReceiver_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForVoiceReceiver_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVoiceReceiver_STATUS(gens map[string]gopter.Gen) {
	gens["CountryCode"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PhoneNumber"] = gen.PtrOf(gen.AlphaString())
}

func Test_WebhookReceiver_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WebhookReceiver to WebhookReceiver via AssignProperties_To_WebhookReceiver & AssignProperties_From_WebhookReceiver returns original",
		prop.ForAll(RunPropertyAssignmentTestForWebhookReceiver, WebhookReceiverGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWebhookReceiver tests if a specific instance of WebhookReceiver can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForWebhookReceiver(subject WebhookReceiver) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230101s.WebhookReceiver
	err := copied.AssignProperties_To_WebhookReceiver(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WebhookReceiver
	err = actual.AssignProperties_From_WebhookReceiver(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WebhookReceiver_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebhookReceiver via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebhookReceiver, WebhookReceiverGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebhookReceiver runs a test to see if a specific instance of WebhookReceiver round trips to JSON and back losslessly
func RunJSONSerializationTestForWebhookReceiver(subject WebhookReceiver) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebhookReceiver
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebhookReceiver instances for property testing - lazily instantiated by WebhookReceiverGenerator()
var webhookReceiverGenerator gopter.Gen

// WebhookReceiverGenerator returns a generator of WebhookReceiver instances for property testing.
func WebhookReceiverGenerator() gopter.Gen {
	if webhookReceiverGenerator != nil {
		return webhookReceiverGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebhookReceiver(generators)
	webhookReceiverGenerator = gen.Struct(reflect.TypeOf(WebhookReceiver{}), generators)

	return webhookReceiverGenerator
}

// AddIndependentPropertyGeneratorsForWebhookReceiver is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebhookReceiver(gens map[string]gopter.Gen) {
	gens["IdentifierUri"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ObjectId"] = gen.PtrOf(gen.AlphaString())
	gens["ServiceUri"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["UseAadAuth"] = gen.PtrOf(gen.Bool())
	gens["UseCommonAlertSchema"] = gen.PtrOf(gen.Bool())
}

func Test_WebhookReceiver_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WebhookReceiver_STATUS to WebhookReceiver_STATUS via AssignProperties_To_WebhookReceiver_STATUS & AssignProperties_From_WebhookReceiver_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForWebhookReceiver_STATUS, WebhookReceiver_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWebhookReceiver_STATUS tests if a specific instance of WebhookReceiver_STATUS can be assigned to v1api20230101storage and back losslessly
func RunPropertyAssignmentTestForWebhookReceiver_STATUS(subject WebhookReceiver_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230101s.WebhookReceiver_STATUS
	err := copied.AssignProperties_To_WebhookReceiver_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WebhookReceiver_STATUS
	err = actual.AssignProperties_From_WebhookReceiver_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WebhookReceiver_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebhookReceiver_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebhookReceiver_STATUS, WebhookReceiver_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebhookReceiver_STATUS runs a test to see if a specific instance of WebhookReceiver_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForWebhookReceiver_STATUS(subject WebhookReceiver_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebhookReceiver_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebhookReceiver_STATUS instances for property testing - lazily instantiated by
// WebhookReceiver_STATUSGenerator()
var webhookReceiver_STATUSGenerator gopter.Gen

// WebhookReceiver_STATUSGenerator returns a generator of WebhookReceiver_STATUS instances for property testing.
func WebhookReceiver_STATUSGenerator() gopter.Gen {
	if webhookReceiver_STATUSGenerator != nil {
		return webhookReceiver_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebhookReceiver_STATUS(generators)
	webhookReceiver_STATUSGenerator = gen.Struct(reflect.TypeOf(WebhookReceiver_STATUS{}), generators)

	return webhookReceiver_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForWebhookReceiver_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebhookReceiver_STATUS(gens map[string]gopter.Gen) {
	gens["IdentifierUri"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ObjectId"] = gen.PtrOf(gen.AlphaString())
	gens["ServiceUri"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["UseAadAuth"] = gen.PtrOf(gen.Bool())
	gens["UseCommonAlertSchema"] = gen.PtrOf(gen.Bool())
}
