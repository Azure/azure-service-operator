// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package arm

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_ActionGroupSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ActionGroupSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForActionGroupSpec, ActionGroupSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForActionGroupSpec runs a test to see if a specific instance of ActionGroupSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForActionGroupSpec(subject ActionGroupSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ActionGroupSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ActionGroupSpec instances for property testing - lazily instantiated by ActionGroupSpecGenerator()
var actionGroupSpecGenerator gopter.Gen

// ActionGroupSpecGenerator returns a generator of ActionGroupSpec instances for property testing.
// We first initialize actionGroupSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ActionGroupSpecGenerator() gopter.Gen {
	if actionGroupSpecGenerator != nil {
		return actionGroupSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForActionGroupSpec(generators)
	actionGroupSpecGenerator = gen.Struct(reflect.TypeOf(ActionGroupSpec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForActionGroupSpec(generators)
	AddRelatedPropertyGeneratorsForActionGroupSpec(generators)
	actionGroupSpecGenerator = gen.Struct(reflect.TypeOf(ActionGroupSpec{}), generators)

	return actionGroupSpecGenerator
}

// AddIndependentPropertyGeneratorsForActionGroupSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForActionGroupSpec(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["GroupShortName"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForActionGroupSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForActionGroupSpec(gens map[string]gopter.Gen) {
	gens["ArmRoleReceivers"] = gen.SliceOf(ArmRoleReceiverGenerator())
	gens["AutomationRunbookReceivers"] = gen.SliceOf(AutomationRunbookReceiverGenerator())
	gens["AzureAppPushReceivers"] = gen.SliceOf(AzureAppPushReceiverGenerator())
	gens["AzureFunctionReceivers"] = gen.SliceOf(AzureFunctionReceiverGenerator())
	gens["EmailReceivers"] = gen.SliceOf(EmailReceiverGenerator())
	gens["EventHubReceivers"] = gen.SliceOf(EventHubReceiverGenerator())
	gens["ItsmReceivers"] = gen.SliceOf(ItsmReceiverGenerator())
	gens["LogicAppReceivers"] = gen.SliceOf(LogicAppReceiverGenerator())
	gens["SmsReceivers"] = gen.SliceOf(SmsReceiverGenerator())
	gens["VoiceReceivers"] = gen.SliceOf(VoiceReceiverGenerator())
	gens["WebhookReceivers"] = gen.SliceOf(WebhookReceiverGenerator())
}

func Test_ActionGroup_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ActionGroup_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForActionGroup_Spec, ActionGroup_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForActionGroup_Spec runs a test to see if a specific instance of ActionGroup_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForActionGroup_Spec(subject ActionGroup_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ActionGroup_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ActionGroup_Spec instances for property testing - lazily instantiated by ActionGroup_SpecGenerator()
var actionGroup_SpecGenerator gopter.Gen

// ActionGroup_SpecGenerator returns a generator of ActionGroup_Spec instances for property testing.
// We first initialize actionGroup_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ActionGroup_SpecGenerator() gopter.Gen {
	if actionGroup_SpecGenerator != nil {
		return actionGroup_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForActionGroup_Spec(generators)
	actionGroup_SpecGenerator = gen.Struct(reflect.TypeOf(ActionGroup_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForActionGroup_Spec(generators)
	AddRelatedPropertyGeneratorsForActionGroup_Spec(generators)
	actionGroup_SpecGenerator = gen.Struct(reflect.TypeOf(ActionGroup_Spec{}), generators)

	return actionGroup_SpecGenerator
}

// AddIndependentPropertyGeneratorsForActionGroup_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForActionGroup_Spec(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForActionGroup_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForActionGroup_Spec(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(ActionGroupSpecGenerator())
}

func Test_ArmRoleReceiver_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ArmRoleReceiver via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForArmRoleReceiver, ArmRoleReceiverGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForArmRoleReceiver runs a test to see if a specific instance of ArmRoleReceiver round trips to JSON and back losslessly
func RunJSONSerializationTestForArmRoleReceiver(subject ArmRoleReceiver) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ArmRoleReceiver
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ArmRoleReceiver instances for property testing - lazily instantiated by ArmRoleReceiverGenerator()
var armRoleReceiverGenerator gopter.Gen

// ArmRoleReceiverGenerator returns a generator of ArmRoleReceiver instances for property testing.
func ArmRoleReceiverGenerator() gopter.Gen {
	if armRoleReceiverGenerator != nil {
		return armRoleReceiverGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForArmRoleReceiver(generators)
	armRoleReceiverGenerator = gen.Struct(reflect.TypeOf(ArmRoleReceiver{}), generators)

	return armRoleReceiverGenerator
}

// AddIndependentPropertyGeneratorsForArmRoleReceiver is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForArmRoleReceiver(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["RoleId"] = gen.PtrOf(gen.AlphaString())
	gens["UseCommonAlertSchema"] = gen.PtrOf(gen.Bool())
}

func Test_AutomationRunbookReceiver_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutomationRunbookReceiver via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutomationRunbookReceiver, AutomationRunbookReceiverGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutomationRunbookReceiver runs a test to see if a specific instance of AutomationRunbookReceiver round trips to JSON and back losslessly
func RunJSONSerializationTestForAutomationRunbookReceiver(subject AutomationRunbookReceiver) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutomationRunbookReceiver
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutomationRunbookReceiver instances for property testing - lazily instantiated by
// AutomationRunbookReceiverGenerator()
var automationRunbookReceiverGenerator gopter.Gen

// AutomationRunbookReceiverGenerator returns a generator of AutomationRunbookReceiver instances for property testing.
func AutomationRunbookReceiverGenerator() gopter.Gen {
	if automationRunbookReceiverGenerator != nil {
		return automationRunbookReceiverGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutomationRunbookReceiver(generators)
	automationRunbookReceiverGenerator = gen.Struct(reflect.TypeOf(AutomationRunbookReceiver{}), generators)

	return automationRunbookReceiverGenerator
}

// AddIndependentPropertyGeneratorsForAutomationRunbookReceiver is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutomationRunbookReceiver(gens map[string]gopter.Gen) {
	gens["AutomationAccountId"] = gen.PtrOf(gen.AlphaString())
	gens["IsGlobalRunbook"] = gen.PtrOf(gen.Bool())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["RunbookName"] = gen.PtrOf(gen.AlphaString())
	gens["ServiceUri"] = gen.PtrOf(gen.AlphaString())
	gens["UseCommonAlertSchema"] = gen.PtrOf(gen.Bool())
	gens["WebhookResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_AzureAppPushReceiver_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureAppPushReceiver via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureAppPushReceiver, AzureAppPushReceiverGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureAppPushReceiver runs a test to see if a specific instance of AzureAppPushReceiver round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureAppPushReceiver(subject AzureAppPushReceiver) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureAppPushReceiver
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureAppPushReceiver instances for property testing - lazily instantiated by
// AzureAppPushReceiverGenerator()
var azureAppPushReceiverGenerator gopter.Gen

// AzureAppPushReceiverGenerator returns a generator of AzureAppPushReceiver instances for property testing.
func AzureAppPushReceiverGenerator() gopter.Gen {
	if azureAppPushReceiverGenerator != nil {
		return azureAppPushReceiverGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureAppPushReceiver(generators)
	azureAppPushReceiverGenerator = gen.Struct(reflect.TypeOf(AzureAppPushReceiver{}), generators)

	return azureAppPushReceiverGenerator
}

// AddIndependentPropertyGeneratorsForAzureAppPushReceiver is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureAppPushReceiver(gens map[string]gopter.Gen) {
	gens["EmailAddress"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_AzureFunctionReceiver_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFunctionReceiver via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFunctionReceiver, AzureFunctionReceiverGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFunctionReceiver runs a test to see if a specific instance of AzureFunctionReceiver round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFunctionReceiver(subject AzureFunctionReceiver) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFunctionReceiver
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFunctionReceiver instances for property testing - lazily instantiated by
// AzureFunctionReceiverGenerator()
var azureFunctionReceiverGenerator gopter.Gen

// AzureFunctionReceiverGenerator returns a generator of AzureFunctionReceiver instances for property testing.
func AzureFunctionReceiverGenerator() gopter.Gen {
	if azureFunctionReceiverGenerator != nil {
		return azureFunctionReceiverGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFunctionReceiver(generators)
	azureFunctionReceiverGenerator = gen.Struct(reflect.TypeOf(AzureFunctionReceiver{}), generators)

	return azureFunctionReceiverGenerator
}

// AddIndependentPropertyGeneratorsForAzureFunctionReceiver is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFunctionReceiver(gens map[string]gopter.Gen) {
	gens["FunctionAppResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["FunctionName"] = gen.PtrOf(gen.AlphaString())
	gens["HttpTriggerUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["UseCommonAlertSchema"] = gen.PtrOf(gen.Bool())
}

func Test_EmailReceiver_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EmailReceiver via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEmailReceiver, EmailReceiverGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEmailReceiver runs a test to see if a specific instance of EmailReceiver round trips to JSON and back losslessly
func RunJSONSerializationTestForEmailReceiver(subject EmailReceiver) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EmailReceiver
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EmailReceiver instances for property testing - lazily instantiated by EmailReceiverGenerator()
var emailReceiverGenerator gopter.Gen

// EmailReceiverGenerator returns a generator of EmailReceiver instances for property testing.
func EmailReceiverGenerator() gopter.Gen {
	if emailReceiverGenerator != nil {
		return emailReceiverGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEmailReceiver(generators)
	emailReceiverGenerator = gen.Struct(reflect.TypeOf(EmailReceiver{}), generators)

	return emailReceiverGenerator
}

// AddIndependentPropertyGeneratorsForEmailReceiver is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEmailReceiver(gens map[string]gopter.Gen) {
	gens["EmailAddress"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["UseCommonAlertSchema"] = gen.PtrOf(gen.Bool())
}

func Test_EventHubReceiver_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventHubReceiver via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventHubReceiver, EventHubReceiverGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventHubReceiver runs a test to see if a specific instance of EventHubReceiver round trips to JSON and back losslessly
func RunJSONSerializationTestForEventHubReceiver(subject EventHubReceiver) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventHubReceiver
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventHubReceiver instances for property testing - lazily instantiated by EventHubReceiverGenerator()
var eventHubReceiverGenerator gopter.Gen

// EventHubReceiverGenerator returns a generator of EventHubReceiver instances for property testing.
func EventHubReceiverGenerator() gopter.Gen {
	if eventHubReceiverGenerator != nil {
		return eventHubReceiverGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventHubReceiver(generators)
	eventHubReceiverGenerator = gen.Struct(reflect.TypeOf(EventHubReceiver{}), generators)

	return eventHubReceiverGenerator
}

// AddIndependentPropertyGeneratorsForEventHubReceiver is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventHubReceiver(gens map[string]gopter.Gen) {
	gens["EventHubName"] = gen.PtrOf(gen.AlphaString())
	gens["EventHubNameSpace"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["SubscriptionId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["UseCommonAlertSchema"] = gen.PtrOf(gen.Bool())
}

func Test_ItsmReceiver_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ItsmReceiver via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForItsmReceiver, ItsmReceiverGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForItsmReceiver runs a test to see if a specific instance of ItsmReceiver round trips to JSON and back losslessly
func RunJSONSerializationTestForItsmReceiver(subject ItsmReceiver) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ItsmReceiver
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ItsmReceiver instances for property testing - lazily instantiated by ItsmReceiverGenerator()
var itsmReceiverGenerator gopter.Gen

// ItsmReceiverGenerator returns a generator of ItsmReceiver instances for property testing.
func ItsmReceiverGenerator() gopter.Gen {
	if itsmReceiverGenerator != nil {
		return itsmReceiverGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForItsmReceiver(generators)
	itsmReceiverGenerator = gen.Struct(reflect.TypeOf(ItsmReceiver{}), generators)

	return itsmReceiverGenerator
}

// AddIndependentPropertyGeneratorsForItsmReceiver is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForItsmReceiver(gens map[string]gopter.Gen) {
	gens["ConnectionId"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Region"] = gen.PtrOf(gen.AlphaString())
	gens["TicketConfiguration"] = gen.PtrOf(gen.AlphaString())
	gens["WorkspaceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_LogicAppReceiver_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LogicAppReceiver via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLogicAppReceiver, LogicAppReceiverGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLogicAppReceiver runs a test to see if a specific instance of LogicAppReceiver round trips to JSON and back losslessly
func RunJSONSerializationTestForLogicAppReceiver(subject LogicAppReceiver) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LogicAppReceiver
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LogicAppReceiver instances for property testing - lazily instantiated by LogicAppReceiverGenerator()
var logicAppReceiverGenerator gopter.Gen

// LogicAppReceiverGenerator returns a generator of LogicAppReceiver instances for property testing.
func LogicAppReceiverGenerator() gopter.Gen {
	if logicAppReceiverGenerator != nil {
		return logicAppReceiverGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLogicAppReceiver(generators)
	logicAppReceiverGenerator = gen.Struct(reflect.TypeOf(LogicAppReceiver{}), generators)

	return logicAppReceiverGenerator
}

// AddIndependentPropertyGeneratorsForLogicAppReceiver is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLogicAppReceiver(gens map[string]gopter.Gen) {
	gens["CallbackUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["UseCommonAlertSchema"] = gen.PtrOf(gen.Bool())
}

func Test_SmsReceiver_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SmsReceiver via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSmsReceiver, SmsReceiverGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSmsReceiver runs a test to see if a specific instance of SmsReceiver round trips to JSON and back losslessly
func RunJSONSerializationTestForSmsReceiver(subject SmsReceiver) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SmsReceiver
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SmsReceiver instances for property testing - lazily instantiated by SmsReceiverGenerator()
var smsReceiverGenerator gopter.Gen

// SmsReceiverGenerator returns a generator of SmsReceiver instances for property testing.
func SmsReceiverGenerator() gopter.Gen {
	if smsReceiverGenerator != nil {
		return smsReceiverGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSmsReceiver(generators)
	smsReceiverGenerator = gen.Struct(reflect.TypeOf(SmsReceiver{}), generators)

	return smsReceiverGenerator
}

// AddIndependentPropertyGeneratorsForSmsReceiver is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSmsReceiver(gens map[string]gopter.Gen) {
	gens["CountryCode"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PhoneNumber"] = gen.PtrOf(gen.AlphaString())
}

func Test_VoiceReceiver_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VoiceReceiver via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVoiceReceiver, VoiceReceiverGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVoiceReceiver runs a test to see if a specific instance of VoiceReceiver round trips to JSON and back losslessly
func RunJSONSerializationTestForVoiceReceiver(subject VoiceReceiver) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VoiceReceiver
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VoiceReceiver instances for property testing - lazily instantiated by VoiceReceiverGenerator()
var voiceReceiverGenerator gopter.Gen

// VoiceReceiverGenerator returns a generator of VoiceReceiver instances for property testing.
func VoiceReceiverGenerator() gopter.Gen {
	if voiceReceiverGenerator != nil {
		return voiceReceiverGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVoiceReceiver(generators)
	voiceReceiverGenerator = gen.Struct(reflect.TypeOf(VoiceReceiver{}), generators)

	return voiceReceiverGenerator
}

// AddIndependentPropertyGeneratorsForVoiceReceiver is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVoiceReceiver(gens map[string]gopter.Gen) {
	gens["CountryCode"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PhoneNumber"] = gen.PtrOf(gen.AlphaString())
}

func Test_WebhookReceiver_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebhookReceiver via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebhookReceiver, WebhookReceiverGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebhookReceiver runs a test to see if a specific instance of WebhookReceiver round trips to JSON and back losslessly
func RunJSONSerializationTestForWebhookReceiver(subject WebhookReceiver) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebhookReceiver
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebhookReceiver instances for property testing - lazily instantiated by WebhookReceiverGenerator()
var webhookReceiverGenerator gopter.Gen

// WebhookReceiverGenerator returns a generator of WebhookReceiver instances for property testing.
func WebhookReceiverGenerator() gopter.Gen {
	if webhookReceiverGenerator != nil {
		return webhookReceiverGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebhookReceiver(generators)
	webhookReceiverGenerator = gen.Struct(reflect.TypeOf(WebhookReceiver{}), generators)

	return webhookReceiverGenerator
}

// AddIndependentPropertyGeneratorsForWebhookReceiver is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebhookReceiver(gens map[string]gopter.Gen) {
	gens["IdentifierUri"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ObjectId"] = gen.PtrOf(gen.AlphaString())
	gens["ServiceUri"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["UseAadAuth"] = gen.PtrOf(gen.Bool())
	gens["UseCommonAlertSchema"] = gen.PtrOf(gen.Bool())
}
