// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20201001

import (
	"fmt"
	arm "github.com/Azure/azure-service-operator/v2/api/insights/v1api20201001/arm"
	storage "github.com/Azure/azure-service-operator/v2/api/insights/v1api20201001/storage"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/rotisserie/eris"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
)

// +kubebuilder:object:root=true
// +kubebuilder:resource:categories={azure,insights}
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /monitor/resource-manager/Microsoft.Insights/stable/2020-10-01/activityLogAlerts_API.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Insights/activityLogAlerts/{activityLogAlertName}
type ActivityLogAlert struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ActivityLogAlert_Spec   `json:"spec,omitempty"`
	Status            ActivityLogAlert_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &ActivityLogAlert{}

// GetConditions returns the conditions of the resource
func (alert *ActivityLogAlert) GetConditions() conditions.Conditions {
	return alert.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (alert *ActivityLogAlert) SetConditions(conditions conditions.Conditions) {
	alert.Status.Conditions = conditions
}

var _ conversion.Convertible = &ActivityLogAlert{}

// ConvertFrom populates our ActivityLogAlert from the provided hub ActivityLogAlert
func (alert *ActivityLogAlert) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*storage.ActivityLogAlert)
	if !ok {
		return fmt.Errorf("expected insights/v1api20201001/storage/ActivityLogAlert but received %T instead", hub)
	}

	return alert.AssignProperties_From_ActivityLogAlert(source)
}

// ConvertTo populates the provided hub ActivityLogAlert from our ActivityLogAlert
func (alert *ActivityLogAlert) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*storage.ActivityLogAlert)
	if !ok {
		return fmt.Errorf("expected insights/v1api20201001/storage/ActivityLogAlert but received %T instead", hub)
	}

	return alert.AssignProperties_To_ActivityLogAlert(destination)
}

var _ configmaps.Exporter = &ActivityLogAlert{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (alert *ActivityLogAlert) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if alert.Spec.OperatorSpec == nil {
		return nil
	}
	return alert.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &ActivityLogAlert{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (alert *ActivityLogAlert) SecretDestinationExpressions() []*core.DestinationExpression {
	if alert.Spec.OperatorSpec == nil {
		return nil
	}
	return alert.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.ImportableResource = &ActivityLogAlert{}

// InitializeSpec initializes the spec for this resource from the given status
func (alert *ActivityLogAlert) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*ActivityLogAlert_STATUS); ok {
		return alert.Spec.Initialize_From_ActivityLogAlert_STATUS(s)
	}

	return fmt.Errorf("expected Status of type ActivityLogAlert_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &ActivityLogAlert{}

// AzureName returns the Azure name of the resource
func (alert *ActivityLogAlert) AzureName() string {
	return alert.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2020-10-01"
func (alert ActivityLogAlert) GetAPIVersion() string {
	return "2020-10-01"
}

// GetResourceScope returns the scope of the resource
func (alert *ActivityLogAlert) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (alert *ActivityLogAlert) GetSpec() genruntime.ConvertibleSpec {
	return &alert.Spec
}

// GetStatus returns the status of this resource
func (alert *ActivityLogAlert) GetStatus() genruntime.ConvertibleStatus {
	return &alert.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (alert *ActivityLogAlert) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Insights/activityLogAlerts"
func (alert *ActivityLogAlert) GetType() string {
	return "Microsoft.Insights/activityLogAlerts"
}

// NewEmptyStatus returns a new empty (blank) status
func (alert *ActivityLogAlert) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &ActivityLogAlert_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (alert *ActivityLogAlert) Owner() *genruntime.ResourceReference {
	if alert.Spec.Owner == nil {
		return nil
	}

	group, kind := genruntime.LookupOwnerGroupKind(alert.Spec)
	return alert.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (alert *ActivityLogAlert) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*ActivityLogAlert_STATUS); ok {
		alert.Status = *st
		return nil
	}

	// Convert status to required version
	var st ActivityLogAlert_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return eris.Wrap(err, "failed to convert status")
	}

	alert.Status = st
	return nil
}

// AssignProperties_From_ActivityLogAlert populates our ActivityLogAlert from the provided source ActivityLogAlert
func (alert *ActivityLogAlert) AssignProperties_From_ActivityLogAlert(source *storage.ActivityLogAlert) error {

	// ObjectMeta
	alert.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec ActivityLogAlert_Spec
	err := spec.AssignProperties_From_ActivityLogAlert_Spec(&source.Spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_ActivityLogAlert_Spec() to populate field Spec")
	}
	alert.Spec = spec

	// Status
	var status ActivityLogAlert_STATUS
	err = status.AssignProperties_From_ActivityLogAlert_STATUS(&source.Status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_ActivityLogAlert_STATUS() to populate field Status")
	}
	alert.Status = status

	// No error
	return nil
}

// AssignProperties_To_ActivityLogAlert populates the provided destination ActivityLogAlert from our ActivityLogAlert
func (alert *ActivityLogAlert) AssignProperties_To_ActivityLogAlert(destination *storage.ActivityLogAlert) error {

	// ObjectMeta
	destination.ObjectMeta = *alert.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.ActivityLogAlert_Spec
	err := alert.Spec.AssignProperties_To_ActivityLogAlert_Spec(&spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_ActivityLogAlert_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.ActivityLogAlert_STATUS
	err = alert.Status.AssignProperties_To_ActivityLogAlert_STATUS(&status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_ActivityLogAlert_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (alert *ActivityLogAlert) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: alert.Spec.OriginalVersion(),
		Kind:    "ActivityLogAlert",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /monitor/resource-manager/Microsoft.Insights/stable/2020-10-01/activityLogAlerts_API.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Insights/activityLogAlerts/{activityLogAlertName}
type ActivityLogAlertList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ActivityLogAlert `json:"items"`
}

type ActivityLogAlert_Spec struct {
	// +kubebuilder:validation:Required
	// Actions: The actions that will activate when the condition is met.
	Actions *ActionList `json:"actions,omitempty"`

	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// +kubebuilder:validation:Required
	// Condition: The condition that will cause this alert to activate.
	Condition *AlertRuleAllOfCondition `json:"condition,omitempty"`

	// Description: A description of this Activity Log Alert rule.
	Description *string `json:"description,omitempty"`

	// Enabled: Indicates whether this Activity Log Alert rule is enabled. If an Activity Log Alert rule is not enabled, then
	// none of its actions will be activated.
	Enabled *bool `json:"enabled,omitempty"`

	// Location: The location of the resource. Azure Activity Log Alert rules are supported on Global, West Europe and North
	// Europe regions.
	Location *string `json:"location,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *ActivityLogAlertOperatorSpec `json:"operatorSpec,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`

	// +kubebuilder:validation:Required
	// ScopesReferences: A list of resource IDs that will be used as prefixes. The alert will only apply to Activity Log events
	// with resource IDs that fall under one of these prefixes. This list must include at least one item.
	ScopesReferences []genruntime.ResourceReference `armReference:"Scopes" json:"scopesReferences,omitempty"`

	// Tags: The tags of the resource.
	Tags map[string]string `json:"tags,omitempty"`
}

var _ genruntime.ARMTransformer = &ActivityLogAlert_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (alert *ActivityLogAlert_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if alert == nil {
		return nil, nil
	}
	result := &arm.ActivityLogAlert_Spec{}

	// Set property "Location":
	if alert.Location != nil {
		location := *alert.Location
		result.Location = &location
	}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if alert.Actions != nil ||
		alert.Condition != nil ||
		alert.Description != nil ||
		alert.Enabled != nil ||
		alert.ScopesReferences != nil {
		result.Properties = &arm.AlertRuleProperties{}
	}
	if alert.Actions != nil {
		actions_ARM, err := (*alert.Actions).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		actions := *actions_ARM.(*arm.ActionList)
		result.Properties.Actions = &actions
	}
	if alert.Condition != nil {
		condition_ARM, err := (*alert.Condition).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		condition := *condition_ARM.(*arm.AlertRuleAllOfCondition)
		result.Properties.Condition = &condition
	}
	if alert.Description != nil {
		description := *alert.Description
		result.Properties.Description = &description
	}
	if alert.Enabled != nil {
		enabled := *alert.Enabled
		result.Properties.Enabled = &enabled
	}
	for _, item := range alert.ScopesReferences {
		itemARMID, err := resolved.ResolvedReferences.Lookup(item)
		if err != nil {
			return nil, err
		}
		result.Properties.Scopes = append(result.Properties.Scopes, itemARMID)
	}

	// Set property "Tags":
	if alert.Tags != nil {
		result.Tags = make(map[string]string, len(alert.Tags))
		for key, value := range alert.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (alert *ActivityLogAlert_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ActivityLogAlert_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (alert *ActivityLogAlert_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ActivityLogAlert_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ActivityLogAlert_Spec, got %T", armInput)
	}

	// Set property "Actions":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Actions != nil {
			var actions1 ActionList
			err := actions1.PopulateFromARM(owner, *typedInput.Properties.Actions)
			if err != nil {
				return err
			}
			actions := actions1
			alert.Actions = &actions
		}
	}

	// Set property "AzureName":
	alert.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "Condition":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Condition != nil {
			var condition1 AlertRuleAllOfCondition
			err := condition1.PopulateFromARM(owner, *typedInput.Properties.Condition)
			if err != nil {
				return err
			}
			condition := condition1
			alert.Condition = &condition
		}
	}

	// Set property "Description":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Description != nil {
			description := *typedInput.Properties.Description
			alert.Description = &description
		}
	}

	// Set property "Enabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Enabled != nil {
			enabled := *typedInput.Properties.Enabled
			alert.Enabled = &enabled
		}
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		alert.Location = &location
	}

	// no assignment for property "OperatorSpec"

	// Set property "Owner":
	alert.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// no assignment for property "ScopesReferences"

	// Set property "Tags":
	if typedInput.Tags != nil {
		alert.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			alert.Tags[key] = value
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &ActivityLogAlert_Spec{}

// ConvertSpecFrom populates our ActivityLogAlert_Spec from the provided source
func (alert *ActivityLogAlert_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.ActivityLogAlert_Spec)
	if ok {
		// Populate our instance from source
		return alert.AssignProperties_From_ActivityLogAlert_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.ActivityLogAlert_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = alert.AssignProperties_From_ActivityLogAlert_Spec(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our ActivityLogAlert_Spec
func (alert *ActivityLogAlert_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.ActivityLogAlert_Spec)
	if ok {
		// Populate destination from our instance
		return alert.AssignProperties_To_ActivityLogAlert_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.ActivityLogAlert_Spec{}
	err := alert.AssignProperties_To_ActivityLogAlert_Spec(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_ActivityLogAlert_Spec populates our ActivityLogAlert_Spec from the provided source ActivityLogAlert_Spec
func (alert *ActivityLogAlert_Spec) AssignProperties_From_ActivityLogAlert_Spec(source *storage.ActivityLogAlert_Spec) error {

	// Actions
	if source.Actions != nil {
		var action ActionList
		err := action.AssignProperties_From_ActionList(source.Actions)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ActionList() to populate field Actions")
		}
		alert.Actions = &action
	} else {
		alert.Actions = nil
	}

	// AzureName
	alert.AzureName = source.AzureName

	// Condition
	if source.Condition != nil {
		var condition AlertRuleAllOfCondition
		err := condition.AssignProperties_From_AlertRuleAllOfCondition(source.Condition)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AlertRuleAllOfCondition() to populate field Condition")
		}
		alert.Condition = &condition
	} else {
		alert.Condition = nil
	}

	// Description
	alert.Description = genruntime.ClonePointerToString(source.Description)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		alert.Enabled = &enabled
	} else {
		alert.Enabled = nil
	}

	// Location
	alert.Location = genruntime.ClonePointerToString(source.Location)

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec ActivityLogAlertOperatorSpec
		err := operatorSpec.AssignProperties_From_ActivityLogAlertOperatorSpec(source.OperatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ActivityLogAlertOperatorSpec() to populate field OperatorSpec")
		}
		alert.OperatorSpec = &operatorSpec
	} else {
		alert.OperatorSpec = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		alert.Owner = &owner
	} else {
		alert.Owner = nil
	}

	// ScopesReferences
	if source.ScopesReferences != nil {
		scopesReferenceList := make([]genruntime.ResourceReference, len(source.ScopesReferences))
		for scopesReferenceIndex, scopesReferenceItem := range source.ScopesReferences {
			// Shadow the loop variable to avoid aliasing
			scopesReferenceItem := scopesReferenceItem
			scopesReferenceList[scopesReferenceIndex] = scopesReferenceItem.Copy()
		}
		alert.ScopesReferences = scopesReferenceList
	} else {
		alert.ScopesReferences = nil
	}

	// Tags
	alert.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// AssignProperties_To_ActivityLogAlert_Spec populates the provided destination ActivityLogAlert_Spec from our ActivityLogAlert_Spec
func (alert *ActivityLogAlert_Spec) AssignProperties_To_ActivityLogAlert_Spec(destination *storage.ActivityLogAlert_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Actions
	if alert.Actions != nil {
		var action storage.ActionList
		err := alert.Actions.AssignProperties_To_ActionList(&action)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ActionList() to populate field Actions")
		}
		destination.Actions = &action
	} else {
		destination.Actions = nil
	}

	// AzureName
	destination.AzureName = alert.AzureName

	// Condition
	if alert.Condition != nil {
		var condition storage.AlertRuleAllOfCondition
		err := alert.Condition.AssignProperties_To_AlertRuleAllOfCondition(&condition)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AlertRuleAllOfCondition() to populate field Condition")
		}
		destination.Condition = &condition
	} else {
		destination.Condition = nil
	}

	// Description
	destination.Description = genruntime.ClonePointerToString(alert.Description)

	// Enabled
	if alert.Enabled != nil {
		enabled := *alert.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(alert.Location)

	// OperatorSpec
	if alert.OperatorSpec != nil {
		var operatorSpec storage.ActivityLogAlertOperatorSpec
		err := alert.OperatorSpec.AssignProperties_To_ActivityLogAlertOperatorSpec(&operatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ActivityLogAlertOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = alert.OriginalVersion()

	// Owner
	if alert.Owner != nil {
		owner := alert.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// ScopesReferences
	if alert.ScopesReferences != nil {
		scopesReferenceList := make([]genruntime.ResourceReference, len(alert.ScopesReferences))
		for scopesReferenceIndex, scopesReferenceItem := range alert.ScopesReferences {
			// Shadow the loop variable to avoid aliasing
			scopesReferenceItem := scopesReferenceItem
			scopesReferenceList[scopesReferenceIndex] = scopesReferenceItem.Copy()
		}
		destination.ScopesReferences = scopesReferenceList
	} else {
		destination.ScopesReferences = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(alert.Tags)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ActivityLogAlert_STATUS populates our ActivityLogAlert_Spec from the provided source ActivityLogAlert_STATUS
func (alert *ActivityLogAlert_Spec) Initialize_From_ActivityLogAlert_STATUS(source *ActivityLogAlert_STATUS) error {

	// Actions
	if source.Actions != nil {
		var action ActionList
		err := action.Initialize_From_ActionList_STATUS(source.Actions)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ActionList_STATUS() to populate field Actions")
		}
		alert.Actions = &action
	} else {
		alert.Actions = nil
	}

	// Condition
	if source.Condition != nil {
		var condition AlertRuleAllOfCondition
		err := condition.Initialize_From_AlertRuleAllOfCondition_STATUS(source.Condition)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_AlertRuleAllOfCondition_STATUS() to populate field Condition")
		}
		alert.Condition = &condition
	} else {
		alert.Condition = nil
	}

	// Description
	alert.Description = genruntime.ClonePointerToString(source.Description)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		alert.Enabled = &enabled
	} else {
		alert.Enabled = nil
	}

	// Location
	alert.Location = genruntime.ClonePointerToString(source.Location)

	// Tags
	alert.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (alert *ActivityLogAlert_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (alert *ActivityLogAlert_Spec) SetAzureName(azureName string) { alert.AzureName = azureName }

type ActivityLogAlert_STATUS struct {
	// Actions: The actions that will activate when the condition is met.
	Actions *ActionList_STATUS `json:"actions,omitempty"`

	// Condition: The condition that will cause this alert to activate.
	Condition *AlertRuleAllOfCondition_STATUS `json:"condition,omitempty"`

	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// Description: A description of this Activity Log Alert rule.
	Description *string `json:"description,omitempty"`

	// Enabled: Indicates whether this Activity Log Alert rule is enabled. If an Activity Log Alert rule is not enabled, then
	// none of its actions will be activated.
	Enabled *bool `json:"enabled,omitempty"`

	// Id: The resource Id.
	Id *string `json:"id,omitempty"`

	// Location: The location of the resource. Azure Activity Log Alert rules are supported on Global, West Europe and North
	// Europe regions.
	Location *string `json:"location,omitempty"`

	// Name: The name of the resource.
	Name *string `json:"name,omitempty"`

	// Scopes: A list of resource IDs that will be used as prefixes. The alert will only apply to Activity Log events with
	// resource IDs that fall under one of these prefixes. This list must include at least one item.
	Scopes []string `json:"scopes,omitempty"`

	// Tags: The tags of the resource.
	Tags map[string]string `json:"tags,omitempty"`

	// Type: The type of the resource.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &ActivityLogAlert_STATUS{}

// ConvertStatusFrom populates our ActivityLogAlert_STATUS from the provided source
func (alert *ActivityLogAlert_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.ActivityLogAlert_STATUS)
	if ok {
		// Populate our instance from source
		return alert.AssignProperties_From_ActivityLogAlert_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.ActivityLogAlert_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = alert.AssignProperties_From_ActivityLogAlert_STATUS(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our ActivityLogAlert_STATUS
func (alert *ActivityLogAlert_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.ActivityLogAlert_STATUS)
	if ok {
		// Populate destination from our instance
		return alert.AssignProperties_To_ActivityLogAlert_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.ActivityLogAlert_STATUS{}
	err := alert.AssignProperties_To_ActivityLogAlert_STATUS(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &ActivityLogAlert_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (alert *ActivityLogAlert_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ActivityLogAlert_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (alert *ActivityLogAlert_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ActivityLogAlert_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ActivityLogAlert_STATUS, got %T", armInput)
	}

	// Set property "Actions":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Actions != nil {
			var actions1 ActionList_STATUS
			err := actions1.PopulateFromARM(owner, *typedInput.Properties.Actions)
			if err != nil {
				return err
			}
			actions := actions1
			alert.Actions = &actions
		}
	}

	// Set property "Condition":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Condition != nil {
			var condition1 AlertRuleAllOfCondition_STATUS
			err := condition1.PopulateFromARM(owner, *typedInput.Properties.Condition)
			if err != nil {
				return err
			}
			condition := condition1
			alert.Condition = &condition
		}
	}

	// no assignment for property "Conditions"

	// Set property "Description":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Description != nil {
			description := *typedInput.Properties.Description
			alert.Description = &description
		}
	}

	// Set property "Enabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Enabled != nil {
			enabled := *typedInput.Properties.Enabled
			alert.Enabled = &enabled
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		alert.Id = &id
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		alert.Location = &location
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		alert.Name = &name
	}

	// Set property "Scopes":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Scopes {
			alert.Scopes = append(alert.Scopes, item)
		}
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		alert.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			alert.Tags[key] = value
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		alert.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_ActivityLogAlert_STATUS populates our ActivityLogAlert_STATUS from the provided source ActivityLogAlert_STATUS
func (alert *ActivityLogAlert_STATUS) AssignProperties_From_ActivityLogAlert_STATUS(source *storage.ActivityLogAlert_STATUS) error {

	// Actions
	if source.Actions != nil {
		var action ActionList_STATUS
		err := action.AssignProperties_From_ActionList_STATUS(source.Actions)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ActionList_STATUS() to populate field Actions")
		}
		alert.Actions = &action
	} else {
		alert.Actions = nil
	}

	// Condition
	if source.Condition != nil {
		var condition AlertRuleAllOfCondition_STATUS
		err := condition.AssignProperties_From_AlertRuleAllOfCondition_STATUS(source.Condition)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AlertRuleAllOfCondition_STATUS() to populate field Condition")
		}
		alert.Condition = &condition
	} else {
		alert.Condition = nil
	}

	// Conditions
	alert.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// Description
	alert.Description = genruntime.ClonePointerToString(source.Description)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		alert.Enabled = &enabled
	} else {
		alert.Enabled = nil
	}

	// Id
	alert.Id = genruntime.ClonePointerToString(source.Id)

	// Location
	alert.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	alert.Name = genruntime.ClonePointerToString(source.Name)

	// Scopes
	alert.Scopes = genruntime.CloneSliceOfString(source.Scopes)

	// Tags
	alert.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	alert.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_ActivityLogAlert_STATUS populates the provided destination ActivityLogAlert_STATUS from our ActivityLogAlert_STATUS
func (alert *ActivityLogAlert_STATUS) AssignProperties_To_ActivityLogAlert_STATUS(destination *storage.ActivityLogAlert_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Actions
	if alert.Actions != nil {
		var action storage.ActionList_STATUS
		err := alert.Actions.AssignProperties_To_ActionList_STATUS(&action)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ActionList_STATUS() to populate field Actions")
		}
		destination.Actions = &action
	} else {
		destination.Actions = nil
	}

	// Condition
	if alert.Condition != nil {
		var condition storage.AlertRuleAllOfCondition_STATUS
		err := alert.Condition.AssignProperties_To_AlertRuleAllOfCondition_STATUS(&condition)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AlertRuleAllOfCondition_STATUS() to populate field Condition")
		}
		destination.Condition = &condition
	} else {
		destination.Condition = nil
	}

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(alert.Conditions)

	// Description
	destination.Description = genruntime.ClonePointerToString(alert.Description)

	// Enabled
	if alert.Enabled != nil {
		enabled := *alert.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(alert.Id)

	// Location
	destination.Location = genruntime.ClonePointerToString(alert.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(alert.Name)

	// Scopes
	destination.Scopes = genruntime.CloneSliceOfString(alert.Scopes)

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(alert.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(alert.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"2020-10-01"}
type APIVersion string

const APIVersion_Value = APIVersion("2020-10-01")

// A list of Activity Log Alert rule actions.
type ActionList struct {
	// ActionGroups: The list of the Action Groups.
	ActionGroups []ActionGroupReference `json:"actionGroups,omitempty"`
}

var _ genruntime.ARMTransformer = &ActionList{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (list *ActionList) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if list == nil {
		return nil, nil
	}
	result := &arm.ActionList{}

	// Set property "ActionGroups":
	for _, item := range list.ActionGroups {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.ActionGroups = append(result.ActionGroups, *item_ARM.(*arm.ActionGroupReference))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (list *ActionList) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ActionList{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (list *ActionList) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ActionList)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ActionList, got %T", armInput)
	}

	// Set property "ActionGroups":
	for _, item := range typedInput.ActionGroups {
		var item1 ActionGroupReference
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		list.ActionGroups = append(list.ActionGroups, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_ActionList populates our ActionList from the provided source ActionList
func (list *ActionList) AssignProperties_From_ActionList(source *storage.ActionList) error {

	// ActionGroups
	if source.ActionGroups != nil {
		actionGroupList := make([]ActionGroupReference, len(source.ActionGroups))
		for actionGroupIndex, actionGroupItem := range source.ActionGroups {
			// Shadow the loop variable to avoid aliasing
			actionGroupItem := actionGroupItem
			var actionGroup ActionGroupReference
			err := actionGroup.AssignProperties_From_ActionGroupReference(&actionGroupItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ActionGroupReference() to populate field ActionGroups")
			}
			actionGroupList[actionGroupIndex] = actionGroup
		}
		list.ActionGroups = actionGroupList
	} else {
		list.ActionGroups = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ActionList populates the provided destination ActionList from our ActionList
func (list *ActionList) AssignProperties_To_ActionList(destination *storage.ActionList) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ActionGroups
	if list.ActionGroups != nil {
		actionGroupList := make([]storage.ActionGroupReference, len(list.ActionGroups))
		for actionGroupIndex, actionGroupItem := range list.ActionGroups {
			// Shadow the loop variable to avoid aliasing
			actionGroupItem := actionGroupItem
			var actionGroup storage.ActionGroupReference
			err := actionGroupItem.AssignProperties_To_ActionGroupReference(&actionGroup)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ActionGroupReference() to populate field ActionGroups")
			}
			actionGroupList[actionGroupIndex] = actionGroup
		}
		destination.ActionGroups = actionGroupList
	} else {
		destination.ActionGroups = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ActionList_STATUS populates our ActionList from the provided source ActionList_STATUS
func (list *ActionList) Initialize_From_ActionList_STATUS(source *ActionList_STATUS) error {

	// ActionGroups
	if source.ActionGroups != nil {
		actionGroupList := make([]ActionGroupReference, len(source.ActionGroups))
		for actionGroupIndex, actionGroupItem := range source.ActionGroups {
			// Shadow the loop variable to avoid aliasing
			actionGroupItem := actionGroupItem
			var actionGroup ActionGroupReference
			err := actionGroup.Initialize_From_ActionGroup_STATUS(&actionGroupItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_ActionGroup_STATUS() to populate field ActionGroups")
			}
			actionGroupList[actionGroupIndex] = actionGroup
		}
		list.ActionGroups = actionGroupList
	} else {
		list.ActionGroups = nil
	}

	// No error
	return nil
}

// A list of Activity Log Alert rule actions.
type ActionList_STATUS struct {
	// ActionGroups: The list of the Action Groups.
	ActionGroups []ActionGroup_STATUS `json:"actionGroups,omitempty"`
}

var _ genruntime.FromARMConverter = &ActionList_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (list *ActionList_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ActionList_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (list *ActionList_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ActionList_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ActionList_STATUS, got %T", armInput)
	}

	// Set property "ActionGroups":
	for _, item := range typedInput.ActionGroups {
		var item1 ActionGroup_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		list.ActionGroups = append(list.ActionGroups, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_ActionList_STATUS populates our ActionList_STATUS from the provided source ActionList_STATUS
func (list *ActionList_STATUS) AssignProperties_From_ActionList_STATUS(source *storage.ActionList_STATUS) error {

	// ActionGroups
	if source.ActionGroups != nil {
		actionGroupList := make([]ActionGroup_STATUS, len(source.ActionGroups))
		for actionGroupIndex, actionGroupItem := range source.ActionGroups {
			// Shadow the loop variable to avoid aliasing
			actionGroupItem := actionGroupItem
			var actionGroup ActionGroup_STATUS
			err := actionGroup.AssignProperties_From_ActionGroup_STATUS(&actionGroupItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ActionGroup_STATUS() to populate field ActionGroups")
			}
			actionGroupList[actionGroupIndex] = actionGroup
		}
		list.ActionGroups = actionGroupList
	} else {
		list.ActionGroups = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ActionList_STATUS populates the provided destination ActionList_STATUS from our ActionList_STATUS
func (list *ActionList_STATUS) AssignProperties_To_ActionList_STATUS(destination *storage.ActionList_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ActionGroups
	if list.ActionGroups != nil {
		actionGroupList := make([]storage.ActionGroup_STATUS, len(list.ActionGroups))
		for actionGroupIndex, actionGroupItem := range list.ActionGroups {
			// Shadow the loop variable to avoid aliasing
			actionGroupItem := actionGroupItem
			var actionGroup storage.ActionGroup_STATUS
			err := actionGroupItem.AssignProperties_To_ActionGroup_STATUS(&actionGroup)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ActionGroup_STATUS() to populate field ActionGroups")
			}
			actionGroupList[actionGroupIndex] = actionGroup
		}
		destination.ActionGroups = actionGroupList
	} else {
		destination.ActionGroups = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type ActivityLogAlertOperatorSpec struct {
	// ConfigMapExpressions: configures where to place operator written dynamic ConfigMaps (created with CEL expressions).
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`

	// SecretExpressions: configures where to place operator written dynamic secrets (created with CEL expressions).
	SecretExpressions []*core.DestinationExpression `json:"secretExpressions,omitempty"`
}

// AssignProperties_From_ActivityLogAlertOperatorSpec populates our ActivityLogAlertOperatorSpec from the provided source ActivityLogAlertOperatorSpec
func (operator *ActivityLogAlertOperatorSpec) AssignProperties_From_ActivityLogAlertOperatorSpec(source *storage.ActivityLogAlertOperatorSpec) error {

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ActivityLogAlertOperatorSpec populates the provided destination ActivityLogAlertOperatorSpec from our ActivityLogAlertOperatorSpec
func (operator *ActivityLogAlertOperatorSpec) AssignProperties_To_ActivityLogAlertOperatorSpec(destination *storage.ActivityLogAlertOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// An Activity Log Alert rule condition that is met when all its member conditions are met.
type AlertRuleAllOfCondition struct {
	// +kubebuilder:validation:Required
	// AllOf: The list of Activity Log Alert rule conditions.
	AllOf []AlertRuleAnyOfOrLeafCondition `json:"allOf,omitempty"`
}

var _ genruntime.ARMTransformer = &AlertRuleAllOfCondition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (condition *AlertRuleAllOfCondition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if condition == nil {
		return nil, nil
	}
	result := &arm.AlertRuleAllOfCondition{}

	// Set property "AllOf":
	for _, item := range condition.AllOf {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.AllOf = append(result.AllOf, *item_ARM.(*arm.AlertRuleAnyOfOrLeafCondition))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *AlertRuleAllOfCondition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AlertRuleAllOfCondition{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *AlertRuleAllOfCondition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AlertRuleAllOfCondition)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AlertRuleAllOfCondition, got %T", armInput)
	}

	// Set property "AllOf":
	for _, item := range typedInput.AllOf {
		var item1 AlertRuleAnyOfOrLeafCondition
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		condition.AllOf = append(condition.AllOf, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_AlertRuleAllOfCondition populates our AlertRuleAllOfCondition from the provided source AlertRuleAllOfCondition
func (condition *AlertRuleAllOfCondition) AssignProperties_From_AlertRuleAllOfCondition(source *storage.AlertRuleAllOfCondition) error {

	// AllOf
	if source.AllOf != nil {
		allOfList := make([]AlertRuleAnyOfOrLeafCondition, len(source.AllOf))
		for allOfIndex, allOfItem := range source.AllOf {
			// Shadow the loop variable to avoid aliasing
			allOfItem := allOfItem
			var allOf AlertRuleAnyOfOrLeafCondition
			err := allOf.AssignProperties_From_AlertRuleAnyOfOrLeafCondition(&allOfItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_AlertRuleAnyOfOrLeafCondition() to populate field AllOf")
			}
			allOfList[allOfIndex] = allOf
		}
		condition.AllOf = allOfList
	} else {
		condition.AllOf = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AlertRuleAllOfCondition populates the provided destination AlertRuleAllOfCondition from our AlertRuleAllOfCondition
func (condition *AlertRuleAllOfCondition) AssignProperties_To_AlertRuleAllOfCondition(destination *storage.AlertRuleAllOfCondition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllOf
	if condition.AllOf != nil {
		allOfList := make([]storage.AlertRuleAnyOfOrLeafCondition, len(condition.AllOf))
		for allOfIndex, allOfItem := range condition.AllOf {
			// Shadow the loop variable to avoid aliasing
			allOfItem := allOfItem
			var allOf storage.AlertRuleAnyOfOrLeafCondition
			err := allOfItem.AssignProperties_To_AlertRuleAnyOfOrLeafCondition(&allOf)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_AlertRuleAnyOfOrLeafCondition() to populate field AllOf")
			}
			allOfList[allOfIndex] = allOf
		}
		destination.AllOf = allOfList
	} else {
		destination.AllOf = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AlertRuleAllOfCondition_STATUS populates our AlertRuleAllOfCondition from the provided source AlertRuleAllOfCondition_STATUS
func (condition *AlertRuleAllOfCondition) Initialize_From_AlertRuleAllOfCondition_STATUS(source *AlertRuleAllOfCondition_STATUS) error {

	// AllOf
	if source.AllOf != nil {
		allOfList := make([]AlertRuleAnyOfOrLeafCondition, len(source.AllOf))
		for allOfIndex, allOfItem := range source.AllOf {
			// Shadow the loop variable to avoid aliasing
			allOfItem := allOfItem
			var allOf AlertRuleAnyOfOrLeafCondition
			err := allOf.Initialize_From_AlertRuleAnyOfOrLeafCondition_STATUS(&allOfItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_AlertRuleAnyOfOrLeafCondition_STATUS() to populate field AllOf")
			}
			allOfList[allOfIndex] = allOf
		}
		condition.AllOf = allOfList
	} else {
		condition.AllOf = nil
	}

	// No error
	return nil
}

// An Activity Log Alert rule condition that is met when all its member conditions are met.
type AlertRuleAllOfCondition_STATUS struct {
	// AllOf: The list of Activity Log Alert rule conditions.
	AllOf []AlertRuleAnyOfOrLeafCondition_STATUS `json:"allOf,omitempty"`
}

var _ genruntime.FromARMConverter = &AlertRuleAllOfCondition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *AlertRuleAllOfCondition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AlertRuleAllOfCondition_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *AlertRuleAllOfCondition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AlertRuleAllOfCondition_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AlertRuleAllOfCondition_STATUS, got %T", armInput)
	}

	// Set property "AllOf":
	for _, item := range typedInput.AllOf {
		var item1 AlertRuleAnyOfOrLeafCondition_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		condition.AllOf = append(condition.AllOf, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_AlertRuleAllOfCondition_STATUS populates our AlertRuleAllOfCondition_STATUS from the provided source AlertRuleAllOfCondition_STATUS
func (condition *AlertRuleAllOfCondition_STATUS) AssignProperties_From_AlertRuleAllOfCondition_STATUS(source *storage.AlertRuleAllOfCondition_STATUS) error {

	// AllOf
	if source.AllOf != nil {
		allOfList := make([]AlertRuleAnyOfOrLeafCondition_STATUS, len(source.AllOf))
		for allOfIndex, allOfItem := range source.AllOf {
			// Shadow the loop variable to avoid aliasing
			allOfItem := allOfItem
			var allOf AlertRuleAnyOfOrLeafCondition_STATUS
			err := allOf.AssignProperties_From_AlertRuleAnyOfOrLeafCondition_STATUS(&allOfItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_AlertRuleAnyOfOrLeafCondition_STATUS() to populate field AllOf")
			}
			allOfList[allOfIndex] = allOf
		}
		condition.AllOf = allOfList
	} else {
		condition.AllOf = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AlertRuleAllOfCondition_STATUS populates the provided destination AlertRuleAllOfCondition_STATUS from our AlertRuleAllOfCondition_STATUS
func (condition *AlertRuleAllOfCondition_STATUS) AssignProperties_To_AlertRuleAllOfCondition_STATUS(destination *storage.AlertRuleAllOfCondition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllOf
	if condition.AllOf != nil {
		allOfList := make([]storage.AlertRuleAnyOfOrLeafCondition_STATUS, len(condition.AllOf))
		for allOfIndex, allOfItem := range condition.AllOf {
			// Shadow the loop variable to avoid aliasing
			allOfItem := allOfItem
			var allOf storage.AlertRuleAnyOfOrLeafCondition_STATUS
			err := allOfItem.AssignProperties_To_AlertRuleAnyOfOrLeafCondition_STATUS(&allOf)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_AlertRuleAnyOfOrLeafCondition_STATUS() to populate field AllOf")
			}
			allOfList[allOfIndex] = allOf
		}
		destination.AllOf = allOfList
	} else {
		destination.AllOf = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// A pointer to an Azure Action Group.
type ActionGroup_STATUS struct {
	// ActionGroupId: The resource ID of the Action Group. This cannot be null or empty.
	ActionGroupId *string `json:"actionGroupId,omitempty"`

	// WebhookProperties: the dictionary of custom properties to include with the post operation. These data are appended to
	// the webhook payload.
	WebhookProperties map[string]string `json:"webhookProperties,omitempty"`
}

var _ genruntime.FromARMConverter = &ActionGroup_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (group *ActionGroup_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ActionGroup_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (group *ActionGroup_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ActionGroup_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ActionGroup_STATUS, got %T", armInput)
	}

	// Set property "ActionGroupId":
	if typedInput.ActionGroupId != nil {
		actionGroupId := *typedInput.ActionGroupId
		group.ActionGroupId = &actionGroupId
	}

	// Set property "WebhookProperties":
	if typedInput.WebhookProperties != nil {
		group.WebhookProperties = make(map[string]string, len(typedInput.WebhookProperties))
		for key, value := range typedInput.WebhookProperties {
			group.WebhookProperties[key] = value
		}
	}

	// No error
	return nil
}

// AssignProperties_From_ActionGroup_STATUS populates our ActionGroup_STATUS from the provided source ActionGroup_STATUS
func (group *ActionGroup_STATUS) AssignProperties_From_ActionGroup_STATUS(source *storage.ActionGroup_STATUS) error {

	// ActionGroupId
	group.ActionGroupId = genruntime.ClonePointerToString(source.ActionGroupId)

	// WebhookProperties
	group.WebhookProperties = genruntime.CloneMapOfStringToString(source.WebhookProperties)

	// No error
	return nil
}

// AssignProperties_To_ActionGroup_STATUS populates the provided destination ActionGroup_STATUS from our ActionGroup_STATUS
func (group *ActionGroup_STATUS) AssignProperties_To_ActionGroup_STATUS(destination *storage.ActionGroup_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ActionGroupId
	destination.ActionGroupId = genruntime.ClonePointerToString(group.ActionGroupId)

	// WebhookProperties
	destination.WebhookProperties = genruntime.CloneMapOfStringToString(group.WebhookProperties)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// A pointer to an Azure Action Group.
type ActionGroupReference struct {
	// +kubebuilder:validation:Required
	// ActionGroupReference: The resource ID of the Action Group. This cannot be null or empty.
	ActionGroupReference *genruntime.ResourceReference `armReference:"ActionGroupId" json:"actionGroupReference,omitempty"`

	// WebhookProperties: the dictionary of custom properties to include with the post operation. These data are appended to
	// the webhook payload.
	WebhookProperties map[string]string `json:"webhookProperties,omitempty"`
}

var _ genruntime.ARMTransformer = &ActionGroupReference{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (reference *ActionGroupReference) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if reference == nil {
		return nil, nil
	}
	result := &arm.ActionGroupReference{}

	// Set property "ActionGroupId":
	if reference.ActionGroupReference != nil {
		actionGroupReferenceARMID, err := resolved.ResolvedReferences.Lookup(*reference.ActionGroupReference)
		if err != nil {
			return nil, err
		}
		actionGroupReference := actionGroupReferenceARMID
		result.ActionGroupId = &actionGroupReference
	}

	// Set property "WebhookProperties":
	if reference.WebhookProperties != nil {
		result.WebhookProperties = make(map[string]string, len(reference.WebhookProperties))
		for key, value := range reference.WebhookProperties {
			result.WebhookProperties[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (reference *ActionGroupReference) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ActionGroupReference{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (reference *ActionGroupReference) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ActionGroupReference)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ActionGroupReference, got %T", armInput)
	}

	// no assignment for property "ActionGroupReference"

	// Set property "WebhookProperties":
	if typedInput.WebhookProperties != nil {
		reference.WebhookProperties = make(map[string]string, len(typedInput.WebhookProperties))
		for key, value := range typedInput.WebhookProperties {
			reference.WebhookProperties[key] = value
		}
	}

	// No error
	return nil
}

// AssignProperties_From_ActionGroupReference populates our ActionGroupReference from the provided source ActionGroupReference
func (reference *ActionGroupReference) AssignProperties_From_ActionGroupReference(source *storage.ActionGroupReference) error {

	// ActionGroupReference
	if source.ActionGroupReference != nil {
		actionGroupReference := source.ActionGroupReference.Copy()
		reference.ActionGroupReference = &actionGroupReference
	} else {
		reference.ActionGroupReference = nil
	}

	// WebhookProperties
	reference.WebhookProperties = genruntime.CloneMapOfStringToString(source.WebhookProperties)

	// No error
	return nil
}

// AssignProperties_To_ActionGroupReference populates the provided destination ActionGroupReference from our ActionGroupReference
func (reference *ActionGroupReference) AssignProperties_To_ActionGroupReference(destination *storage.ActionGroupReference) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ActionGroupReference
	if reference.ActionGroupReference != nil {
		actionGroupReference := reference.ActionGroupReference.Copy()
		destination.ActionGroupReference = &actionGroupReference
	} else {
		destination.ActionGroupReference = nil
	}

	// WebhookProperties
	destination.WebhookProperties = genruntime.CloneMapOfStringToString(reference.WebhookProperties)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ActionGroup_STATUS populates our ActionGroupReference from the provided source ActionGroup_STATUS
func (reference *ActionGroupReference) Initialize_From_ActionGroup_STATUS(source *ActionGroup_STATUS) error {

	// ActionGroupReference
	if source.ActionGroupId != nil {
		actionGroupReference := genruntime.CreateResourceReferenceFromARMID(*source.ActionGroupId)
		reference.ActionGroupReference = &actionGroupReference
	} else {
		reference.ActionGroupReference = nil
	}

	// WebhookProperties
	reference.WebhookProperties = genruntime.CloneMapOfStringToString(source.WebhookProperties)

	// No error
	return nil
}

// An Activity Log Alert rule condition that is met when all its member conditions are met.
// Each condition can be of one of
// the following types:
// __Important__: Each type has its unique subset of properties. Properties from different types
// CANNOT exist in one condition.
// * __Leaf Condition -__ must contain 'field' and either 'equals' or 'containsAny'.
// _Please note, 'anyOf' should __not__ be set in a Leaf Condition._
// * __AnyOf Condition -__ must contain __only__
// 'anyOf' (which is an array of Leaf Conditions).
// _Please note, 'field', 'equals' and 'containsAny' should __not__ be
// set in an AnyOf Condition._
type AlertRuleAnyOfOrLeafCondition struct {
	// AnyOf: An Activity Log Alert rule condition that is met when at least one of its member leaf conditions are met.
	AnyOf []AlertRuleLeafCondition `json:"anyOf,omitempty"`

	// ContainsAny: The value of the event's field will be compared to the values in this array (case-insensitive) to determine
	// if the condition is met.
	ContainsAny []string `json:"containsAny,omitempty"`

	// Equals: The value of the event's field will be compared to this value (case-insensitive) to determine if the condition
	// is met.
	Equals *string `json:"equals,omitempty"`

	// Field: The name of the Activity Log event's field that this condition will examine.
	// The possible values for this field are (case-insensitive): 'resourceId', 'category', 'caller', 'level', 'operationName',
	// 'resourceGroup', 'resourceProvider', 'status', 'subStatus', 'resourceType', or anything beginning with 'properties'.
	Field *string `json:"field,omitempty"`
}

var _ genruntime.ARMTransformer = &AlertRuleAnyOfOrLeafCondition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (condition *AlertRuleAnyOfOrLeafCondition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if condition == nil {
		return nil, nil
	}
	result := &arm.AlertRuleAnyOfOrLeafCondition{}

	// Set property "AnyOf":
	for _, item := range condition.AnyOf {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.AnyOf = append(result.AnyOf, *item_ARM.(*arm.AlertRuleLeafCondition))
	}

	// Set property "ContainsAny":
	for _, item := range condition.ContainsAny {
		result.ContainsAny = append(result.ContainsAny, item)
	}

	// Set property "Equals":
	if condition.Equals != nil {
		equals := *condition.Equals
		result.Equals = &equals
	}

	// Set property "Field":
	if condition.Field != nil {
		field := *condition.Field
		result.Field = &field
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *AlertRuleAnyOfOrLeafCondition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AlertRuleAnyOfOrLeafCondition{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *AlertRuleAnyOfOrLeafCondition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AlertRuleAnyOfOrLeafCondition)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AlertRuleAnyOfOrLeafCondition, got %T", armInput)
	}

	// Set property "AnyOf":
	for _, item := range typedInput.AnyOf {
		var item1 AlertRuleLeafCondition
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		condition.AnyOf = append(condition.AnyOf, item1)
	}

	// Set property "ContainsAny":
	for _, item := range typedInput.ContainsAny {
		condition.ContainsAny = append(condition.ContainsAny, item)
	}

	// Set property "Equals":
	if typedInput.Equals != nil {
		equals := *typedInput.Equals
		condition.Equals = &equals
	}

	// Set property "Field":
	if typedInput.Field != nil {
		field := *typedInput.Field
		condition.Field = &field
	}

	// No error
	return nil
}

// AssignProperties_From_AlertRuleAnyOfOrLeafCondition populates our AlertRuleAnyOfOrLeafCondition from the provided source AlertRuleAnyOfOrLeafCondition
func (condition *AlertRuleAnyOfOrLeafCondition) AssignProperties_From_AlertRuleAnyOfOrLeafCondition(source *storage.AlertRuleAnyOfOrLeafCondition) error {

	// AnyOf
	if source.AnyOf != nil {
		anyOfList := make([]AlertRuleLeafCondition, len(source.AnyOf))
		for anyOfIndex, anyOfItem := range source.AnyOf {
			// Shadow the loop variable to avoid aliasing
			anyOfItem := anyOfItem
			var anyOf AlertRuleLeafCondition
			err := anyOf.AssignProperties_From_AlertRuleLeafCondition(&anyOfItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_AlertRuleLeafCondition() to populate field AnyOf")
			}
			anyOfList[anyOfIndex] = anyOf
		}
		condition.AnyOf = anyOfList
	} else {
		condition.AnyOf = nil
	}

	// ContainsAny
	condition.ContainsAny = genruntime.CloneSliceOfString(source.ContainsAny)

	// Equals
	condition.Equals = genruntime.ClonePointerToString(source.Equals)

	// Field
	condition.Field = genruntime.ClonePointerToString(source.Field)

	// No error
	return nil
}

// AssignProperties_To_AlertRuleAnyOfOrLeafCondition populates the provided destination AlertRuleAnyOfOrLeafCondition from our AlertRuleAnyOfOrLeafCondition
func (condition *AlertRuleAnyOfOrLeafCondition) AssignProperties_To_AlertRuleAnyOfOrLeafCondition(destination *storage.AlertRuleAnyOfOrLeafCondition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AnyOf
	if condition.AnyOf != nil {
		anyOfList := make([]storage.AlertRuleLeafCondition, len(condition.AnyOf))
		for anyOfIndex, anyOfItem := range condition.AnyOf {
			// Shadow the loop variable to avoid aliasing
			anyOfItem := anyOfItem
			var anyOf storage.AlertRuleLeafCondition
			err := anyOfItem.AssignProperties_To_AlertRuleLeafCondition(&anyOf)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_AlertRuleLeafCondition() to populate field AnyOf")
			}
			anyOfList[anyOfIndex] = anyOf
		}
		destination.AnyOf = anyOfList
	} else {
		destination.AnyOf = nil
	}

	// ContainsAny
	destination.ContainsAny = genruntime.CloneSliceOfString(condition.ContainsAny)

	// Equals
	destination.Equals = genruntime.ClonePointerToString(condition.Equals)

	// Field
	destination.Field = genruntime.ClonePointerToString(condition.Field)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AlertRuleAnyOfOrLeafCondition_STATUS populates our AlertRuleAnyOfOrLeafCondition from the provided source AlertRuleAnyOfOrLeafCondition_STATUS
func (condition *AlertRuleAnyOfOrLeafCondition) Initialize_From_AlertRuleAnyOfOrLeafCondition_STATUS(source *AlertRuleAnyOfOrLeafCondition_STATUS) error {

	// AnyOf
	if source.AnyOf != nil {
		anyOfList := make([]AlertRuleLeafCondition, len(source.AnyOf))
		for anyOfIndex, anyOfItem := range source.AnyOf {
			// Shadow the loop variable to avoid aliasing
			anyOfItem := anyOfItem
			var anyOf AlertRuleLeafCondition
			err := anyOf.Initialize_From_AlertRuleLeafCondition_STATUS(&anyOfItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_AlertRuleLeafCondition_STATUS() to populate field AnyOf")
			}
			anyOfList[anyOfIndex] = anyOf
		}
		condition.AnyOf = anyOfList
	} else {
		condition.AnyOf = nil
	}

	// ContainsAny
	condition.ContainsAny = genruntime.CloneSliceOfString(source.ContainsAny)

	// Equals
	condition.Equals = genruntime.ClonePointerToString(source.Equals)

	// Field
	condition.Field = genruntime.ClonePointerToString(source.Field)

	// No error
	return nil
}

// An Activity Log Alert rule condition that is met when all its member conditions are met.
// Each condition can be of one of
// the following types:
// __Important__: Each type has its unique subset of properties. Properties from different types
// CANNOT exist in one condition.
// * __Leaf Condition -__ must contain 'field' and either 'equals' or 'containsAny'.
// _Please note, 'anyOf' should __not__ be set in a Leaf Condition._
// * __AnyOf Condition -__ must contain __only__
// 'anyOf' (which is an array of Leaf Conditions).
// _Please note, 'field', 'equals' and 'containsAny' should __not__ be
// set in an AnyOf Condition._
type AlertRuleAnyOfOrLeafCondition_STATUS struct {
	// AnyOf: An Activity Log Alert rule condition that is met when at least one of its member leaf conditions are met.
	AnyOf []AlertRuleLeafCondition_STATUS `json:"anyOf,omitempty"`

	// ContainsAny: The value of the event's field will be compared to the values in this array (case-insensitive) to determine
	// if the condition is met.
	ContainsAny []string `json:"containsAny,omitempty"`

	// Equals: The value of the event's field will be compared to this value (case-insensitive) to determine if the condition
	// is met.
	Equals *string `json:"equals,omitempty"`

	// Field: The name of the Activity Log event's field that this condition will examine.
	// The possible values for this field are (case-insensitive): 'resourceId', 'category', 'caller', 'level', 'operationName',
	// 'resourceGroup', 'resourceProvider', 'status', 'subStatus', 'resourceType', or anything beginning with 'properties'.
	Field *string `json:"field,omitempty"`
}

var _ genruntime.FromARMConverter = &AlertRuleAnyOfOrLeafCondition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *AlertRuleAnyOfOrLeafCondition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AlertRuleAnyOfOrLeafCondition_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *AlertRuleAnyOfOrLeafCondition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AlertRuleAnyOfOrLeafCondition_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AlertRuleAnyOfOrLeafCondition_STATUS, got %T", armInput)
	}

	// Set property "AnyOf":
	for _, item := range typedInput.AnyOf {
		var item1 AlertRuleLeafCondition_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		condition.AnyOf = append(condition.AnyOf, item1)
	}

	// Set property "ContainsAny":
	for _, item := range typedInput.ContainsAny {
		condition.ContainsAny = append(condition.ContainsAny, item)
	}

	// Set property "Equals":
	if typedInput.Equals != nil {
		equals := *typedInput.Equals
		condition.Equals = &equals
	}

	// Set property "Field":
	if typedInput.Field != nil {
		field := *typedInput.Field
		condition.Field = &field
	}

	// No error
	return nil
}

// AssignProperties_From_AlertRuleAnyOfOrLeafCondition_STATUS populates our AlertRuleAnyOfOrLeafCondition_STATUS from the provided source AlertRuleAnyOfOrLeafCondition_STATUS
func (condition *AlertRuleAnyOfOrLeafCondition_STATUS) AssignProperties_From_AlertRuleAnyOfOrLeafCondition_STATUS(source *storage.AlertRuleAnyOfOrLeafCondition_STATUS) error {

	// AnyOf
	if source.AnyOf != nil {
		anyOfList := make([]AlertRuleLeafCondition_STATUS, len(source.AnyOf))
		for anyOfIndex, anyOfItem := range source.AnyOf {
			// Shadow the loop variable to avoid aliasing
			anyOfItem := anyOfItem
			var anyOf AlertRuleLeafCondition_STATUS
			err := anyOf.AssignProperties_From_AlertRuleLeafCondition_STATUS(&anyOfItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_AlertRuleLeafCondition_STATUS() to populate field AnyOf")
			}
			anyOfList[anyOfIndex] = anyOf
		}
		condition.AnyOf = anyOfList
	} else {
		condition.AnyOf = nil
	}

	// ContainsAny
	condition.ContainsAny = genruntime.CloneSliceOfString(source.ContainsAny)

	// Equals
	condition.Equals = genruntime.ClonePointerToString(source.Equals)

	// Field
	condition.Field = genruntime.ClonePointerToString(source.Field)

	// No error
	return nil
}

// AssignProperties_To_AlertRuleAnyOfOrLeafCondition_STATUS populates the provided destination AlertRuleAnyOfOrLeafCondition_STATUS from our AlertRuleAnyOfOrLeafCondition_STATUS
func (condition *AlertRuleAnyOfOrLeafCondition_STATUS) AssignProperties_To_AlertRuleAnyOfOrLeafCondition_STATUS(destination *storage.AlertRuleAnyOfOrLeafCondition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AnyOf
	if condition.AnyOf != nil {
		anyOfList := make([]storage.AlertRuleLeafCondition_STATUS, len(condition.AnyOf))
		for anyOfIndex, anyOfItem := range condition.AnyOf {
			// Shadow the loop variable to avoid aliasing
			anyOfItem := anyOfItem
			var anyOf storage.AlertRuleLeafCondition_STATUS
			err := anyOfItem.AssignProperties_To_AlertRuleLeafCondition_STATUS(&anyOf)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_AlertRuleLeafCondition_STATUS() to populate field AnyOf")
			}
			anyOfList[anyOfIndex] = anyOf
		}
		destination.AnyOf = anyOfList
	} else {
		destination.AnyOf = nil
	}

	// ContainsAny
	destination.ContainsAny = genruntime.CloneSliceOfString(condition.ContainsAny)

	// Equals
	destination.Equals = genruntime.ClonePointerToString(condition.Equals)

	// Field
	destination.Field = genruntime.ClonePointerToString(condition.Field)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// An Activity Log Alert rule condition that is met by comparing the field and value of an Activity Log event.
// This
// condition must contain 'field' and either 'equals' or 'containsAny'.
type AlertRuleLeafCondition struct {
	// ContainsAny: The value of the event's field will be compared to the values in this array (case-insensitive) to determine
	// if the condition is met.
	ContainsAny []string `json:"containsAny,omitempty"`

	// Equals: The value of the event's field will be compared to this value (case-insensitive) to determine if the condition
	// is met.
	Equals *string `json:"equals,omitempty"`

	// Field: The name of the Activity Log event's field that this condition will examine.
	// The possible values for this field are (case-insensitive): 'resourceId', 'category', 'caller', 'level', 'operationName',
	// 'resourceGroup', 'resourceProvider', 'status', 'subStatus', 'resourceType', or anything beginning with 'properties'.
	Field *string `json:"field,omitempty"`
}

var _ genruntime.ARMTransformer = &AlertRuleLeafCondition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (condition *AlertRuleLeafCondition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if condition == nil {
		return nil, nil
	}
	result := &arm.AlertRuleLeafCondition{}

	// Set property "ContainsAny":
	for _, item := range condition.ContainsAny {
		result.ContainsAny = append(result.ContainsAny, item)
	}

	// Set property "Equals":
	if condition.Equals != nil {
		equals := *condition.Equals
		result.Equals = &equals
	}

	// Set property "Field":
	if condition.Field != nil {
		field := *condition.Field
		result.Field = &field
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *AlertRuleLeafCondition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AlertRuleLeafCondition{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *AlertRuleLeafCondition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AlertRuleLeafCondition)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AlertRuleLeafCondition, got %T", armInput)
	}

	// Set property "ContainsAny":
	for _, item := range typedInput.ContainsAny {
		condition.ContainsAny = append(condition.ContainsAny, item)
	}

	// Set property "Equals":
	if typedInput.Equals != nil {
		equals := *typedInput.Equals
		condition.Equals = &equals
	}

	// Set property "Field":
	if typedInput.Field != nil {
		field := *typedInput.Field
		condition.Field = &field
	}

	// No error
	return nil
}

// AssignProperties_From_AlertRuleLeafCondition populates our AlertRuleLeafCondition from the provided source AlertRuleLeafCondition
func (condition *AlertRuleLeafCondition) AssignProperties_From_AlertRuleLeafCondition(source *storage.AlertRuleLeafCondition) error {

	// ContainsAny
	condition.ContainsAny = genruntime.CloneSliceOfString(source.ContainsAny)

	// Equals
	condition.Equals = genruntime.ClonePointerToString(source.Equals)

	// Field
	condition.Field = genruntime.ClonePointerToString(source.Field)

	// No error
	return nil
}

// AssignProperties_To_AlertRuleLeafCondition populates the provided destination AlertRuleLeafCondition from our AlertRuleLeafCondition
func (condition *AlertRuleLeafCondition) AssignProperties_To_AlertRuleLeafCondition(destination *storage.AlertRuleLeafCondition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ContainsAny
	destination.ContainsAny = genruntime.CloneSliceOfString(condition.ContainsAny)

	// Equals
	destination.Equals = genruntime.ClonePointerToString(condition.Equals)

	// Field
	destination.Field = genruntime.ClonePointerToString(condition.Field)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AlertRuleLeafCondition_STATUS populates our AlertRuleLeafCondition from the provided source AlertRuleLeafCondition_STATUS
func (condition *AlertRuleLeafCondition) Initialize_From_AlertRuleLeafCondition_STATUS(source *AlertRuleLeafCondition_STATUS) error {

	// ContainsAny
	condition.ContainsAny = genruntime.CloneSliceOfString(source.ContainsAny)

	// Equals
	condition.Equals = genruntime.ClonePointerToString(source.Equals)

	// Field
	condition.Field = genruntime.ClonePointerToString(source.Field)

	// No error
	return nil
}

// An Activity Log Alert rule condition that is met by comparing the field and value of an Activity Log event.
// This
// condition must contain 'field' and either 'equals' or 'containsAny'.
type AlertRuleLeafCondition_STATUS struct {
	// ContainsAny: The value of the event's field will be compared to the values in this array (case-insensitive) to determine
	// if the condition is met.
	ContainsAny []string `json:"containsAny,omitempty"`

	// Equals: The value of the event's field will be compared to this value (case-insensitive) to determine if the condition
	// is met.
	Equals *string `json:"equals,omitempty"`

	// Field: The name of the Activity Log event's field that this condition will examine.
	// The possible values for this field are (case-insensitive): 'resourceId', 'category', 'caller', 'level', 'operationName',
	// 'resourceGroup', 'resourceProvider', 'status', 'subStatus', 'resourceType', or anything beginning with 'properties'.
	Field *string `json:"field,omitempty"`
}

var _ genruntime.FromARMConverter = &AlertRuleLeafCondition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *AlertRuleLeafCondition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AlertRuleLeafCondition_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *AlertRuleLeafCondition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AlertRuleLeafCondition_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AlertRuleLeafCondition_STATUS, got %T", armInput)
	}

	// Set property "ContainsAny":
	for _, item := range typedInput.ContainsAny {
		condition.ContainsAny = append(condition.ContainsAny, item)
	}

	// Set property "Equals":
	if typedInput.Equals != nil {
		equals := *typedInput.Equals
		condition.Equals = &equals
	}

	// Set property "Field":
	if typedInput.Field != nil {
		field := *typedInput.Field
		condition.Field = &field
	}

	// No error
	return nil
}

// AssignProperties_From_AlertRuleLeafCondition_STATUS populates our AlertRuleLeafCondition_STATUS from the provided source AlertRuleLeafCondition_STATUS
func (condition *AlertRuleLeafCondition_STATUS) AssignProperties_From_AlertRuleLeafCondition_STATUS(source *storage.AlertRuleLeafCondition_STATUS) error {

	// ContainsAny
	condition.ContainsAny = genruntime.CloneSliceOfString(source.ContainsAny)

	// Equals
	condition.Equals = genruntime.ClonePointerToString(source.Equals)

	// Field
	condition.Field = genruntime.ClonePointerToString(source.Field)

	// No error
	return nil
}

// AssignProperties_To_AlertRuleLeafCondition_STATUS populates the provided destination AlertRuleLeafCondition_STATUS from our AlertRuleLeafCondition_STATUS
func (condition *AlertRuleLeafCondition_STATUS) AssignProperties_To_AlertRuleLeafCondition_STATUS(destination *storage.AlertRuleLeafCondition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ContainsAny
	destination.ContainsAny = genruntime.CloneSliceOfString(condition.ContainsAny)

	// Equals
	destination.Equals = genruntime.ClonePointerToString(condition.Equals)

	// Field
	destination.Field = genruntime.ClonePointerToString(condition.Field)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&ActivityLogAlert{}, &ActivityLogAlertList{})
}
