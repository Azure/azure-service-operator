// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20180501preview

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_Webtests_SPECARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Webtests_SPECARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebtestsSPECARM, WebtestsSPECARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebtestsSPECARM runs a test to see if a specific instance of Webtests_SPECARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWebtestsSPECARM(subject Webtests_SPECARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Webtests_SPECARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Webtests_SPECARM instances for property testing - lazily instantiated by WebtestsSPECARMGenerator()
var webtestsSPECARMGenerator gopter.Gen

// WebtestsSPECARMGenerator returns a generator of Webtests_SPECARM instances for property testing.
// We first initialize webtestsSPECARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WebtestsSPECARMGenerator() gopter.Gen {
	if webtestsSPECARMGenerator != nil {
		return webtestsSPECARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebtestsSPECARM(generators)
	webtestsSPECARMGenerator = gen.Struct(reflect.TypeOf(Webtests_SPECARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebtestsSPECARM(generators)
	AddRelatedPropertyGeneratorsForWebtestsSPECARM(generators)
	webtestsSPECARMGenerator = gen.Struct(reflect.TypeOf(Webtests_SPECARM{}), generators)

	return webtestsSPECARMGenerator
}

// AddIndependentPropertyGeneratorsForWebtestsSPECARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebtestsSPECARM(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Location"] = gen.AlphaString()
	gens["Name"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForWebtestsSPECARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWebtestsSPECARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(WebTestPropertiesSpecARMGenerator())
}

func Test_WebTestProperties_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebTestProperties_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebTestPropertiesSpecARM, WebTestPropertiesSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebTestPropertiesSpecARM runs a test to see if a specific instance of WebTestProperties_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWebTestPropertiesSpecARM(subject WebTestProperties_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebTestProperties_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebTestProperties_SpecARM instances for property testing - lazily instantiated by
//WebTestPropertiesSpecARMGenerator()
var webTestPropertiesSpecARMGenerator gopter.Gen

// WebTestPropertiesSpecARMGenerator returns a generator of WebTestProperties_SpecARM instances for property testing.
// We first initialize webTestPropertiesSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WebTestPropertiesSpecARMGenerator() gopter.Gen {
	if webTestPropertiesSpecARMGenerator != nil {
		return webTestPropertiesSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebTestPropertiesSpecARM(generators)
	webTestPropertiesSpecARMGenerator = gen.Struct(reflect.TypeOf(WebTestProperties_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebTestPropertiesSpecARM(generators)
	AddRelatedPropertyGeneratorsForWebTestPropertiesSpecARM(generators)
	webTestPropertiesSpecARMGenerator = gen.Struct(reflect.TypeOf(WebTestProperties_SpecARM{}), generators)

	return webTestPropertiesSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForWebTestPropertiesSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebTestPropertiesSpecARM(gens map[string]gopter.Gen) {
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["Frequency"] = gen.PtrOf(gen.Int())
	gens["Kind"] = gen.OneConstOf(
		WebTestPropertiesSpecKindBasic,
		WebTestPropertiesSpecKindMultistep,
		WebTestPropertiesSpecKindPing,
		WebTestPropertiesSpecKindStandard)
	gens["Name"] = gen.AlphaString()
	gens["RetryEnabled"] = gen.PtrOf(gen.Bool())
	gens["SyntheticMonitorId"] = gen.AlphaString()
	gens["Timeout"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForWebTestPropertiesSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWebTestPropertiesSpecARM(gens map[string]gopter.Gen) {
	gens["Configuration"] = gen.PtrOf(WebTestPropertiesSpecConfigurationARMGenerator())
	gens["Locations"] = gen.SliceOf(WebTestGeolocationSpecARMGenerator())
	gens["Request"] = gen.PtrOf(WebTestPropertiesSpecRequestARMGenerator())
	gens["ValidationRules"] = gen.PtrOf(WebTestPropertiesSpecValidationRulesARMGenerator())
}

func Test_WebTestGeolocation_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebTestGeolocation_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebTestGeolocationSpecARM, WebTestGeolocationSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebTestGeolocationSpecARM runs a test to see if a specific instance of WebTestGeolocation_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWebTestGeolocationSpecARM(subject WebTestGeolocation_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebTestGeolocation_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebTestGeolocation_SpecARM instances for property testing - lazily instantiated by
//WebTestGeolocationSpecARMGenerator()
var webTestGeolocationSpecARMGenerator gopter.Gen

// WebTestGeolocationSpecARMGenerator returns a generator of WebTestGeolocation_SpecARM instances for property testing.
func WebTestGeolocationSpecARMGenerator() gopter.Gen {
	if webTestGeolocationSpecARMGenerator != nil {
		return webTestGeolocationSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebTestGeolocationSpecARM(generators)
	webTestGeolocationSpecARMGenerator = gen.Struct(reflect.TypeOf(WebTestGeolocation_SpecARM{}), generators)

	return webTestGeolocationSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForWebTestGeolocationSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebTestGeolocationSpecARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_WebTestProperties_Spec_ConfigurationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebTestProperties_Spec_ConfigurationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebTestPropertiesSpecConfigurationARM, WebTestPropertiesSpecConfigurationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebTestPropertiesSpecConfigurationARM runs a test to see if a specific instance of WebTestProperties_Spec_ConfigurationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWebTestPropertiesSpecConfigurationARM(subject WebTestProperties_Spec_ConfigurationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebTestProperties_Spec_ConfigurationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebTestProperties_Spec_ConfigurationARM instances for property testing - lazily instantiated by
//WebTestPropertiesSpecConfigurationARMGenerator()
var webTestPropertiesSpecConfigurationARMGenerator gopter.Gen

// WebTestPropertiesSpecConfigurationARMGenerator returns a generator of WebTestProperties_Spec_ConfigurationARM instances for property testing.
func WebTestPropertiesSpecConfigurationARMGenerator() gopter.Gen {
	if webTestPropertiesSpecConfigurationARMGenerator != nil {
		return webTestPropertiesSpecConfigurationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebTestPropertiesSpecConfigurationARM(generators)
	webTestPropertiesSpecConfigurationARMGenerator = gen.Struct(reflect.TypeOf(WebTestProperties_Spec_ConfigurationARM{}), generators)

	return webTestPropertiesSpecConfigurationARMGenerator
}

// AddIndependentPropertyGeneratorsForWebTestPropertiesSpecConfigurationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebTestPropertiesSpecConfigurationARM(gens map[string]gopter.Gen) {
	gens["WebTest"] = gen.PtrOf(gen.AlphaString())
}

func Test_WebTestProperties_Spec_RequestARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebTestProperties_Spec_RequestARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebTestPropertiesSpecRequestARM, WebTestPropertiesSpecRequestARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebTestPropertiesSpecRequestARM runs a test to see if a specific instance of WebTestProperties_Spec_RequestARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWebTestPropertiesSpecRequestARM(subject WebTestProperties_Spec_RequestARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebTestProperties_Spec_RequestARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebTestProperties_Spec_RequestARM instances for property testing - lazily instantiated by
//WebTestPropertiesSpecRequestARMGenerator()
var webTestPropertiesSpecRequestARMGenerator gopter.Gen

// WebTestPropertiesSpecRequestARMGenerator returns a generator of WebTestProperties_Spec_RequestARM instances for property testing.
// We first initialize webTestPropertiesSpecRequestARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WebTestPropertiesSpecRequestARMGenerator() gopter.Gen {
	if webTestPropertiesSpecRequestARMGenerator != nil {
		return webTestPropertiesSpecRequestARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebTestPropertiesSpecRequestARM(generators)
	webTestPropertiesSpecRequestARMGenerator = gen.Struct(reflect.TypeOf(WebTestProperties_Spec_RequestARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebTestPropertiesSpecRequestARM(generators)
	AddRelatedPropertyGeneratorsForWebTestPropertiesSpecRequestARM(generators)
	webTestPropertiesSpecRequestARMGenerator = gen.Struct(reflect.TypeOf(WebTestProperties_Spec_RequestARM{}), generators)

	return webTestPropertiesSpecRequestARMGenerator
}

// AddIndependentPropertyGeneratorsForWebTestPropertiesSpecRequestARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebTestPropertiesSpecRequestARM(gens map[string]gopter.Gen) {
	gens["FollowRedirects"] = gen.PtrOf(gen.Bool())
	gens["HttpVerb"] = gen.PtrOf(gen.AlphaString())
	gens["ParseDependentRequests"] = gen.PtrOf(gen.Bool())
	gens["RequestBody"] = gen.PtrOf(gen.AlphaString())
	gens["RequestUrl"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForWebTestPropertiesSpecRequestARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWebTestPropertiesSpecRequestARM(gens map[string]gopter.Gen) {
	gens["Headers"] = gen.SliceOf(HeaderFieldSpecARMGenerator())
}

func Test_WebTestProperties_Spec_ValidationRulesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebTestProperties_Spec_ValidationRulesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebTestPropertiesSpecValidationRulesARM, WebTestPropertiesSpecValidationRulesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebTestPropertiesSpecValidationRulesARM runs a test to see if a specific instance of WebTestProperties_Spec_ValidationRulesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWebTestPropertiesSpecValidationRulesARM(subject WebTestProperties_Spec_ValidationRulesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebTestProperties_Spec_ValidationRulesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebTestProperties_Spec_ValidationRulesARM instances for property testing - lazily instantiated by
//WebTestPropertiesSpecValidationRulesARMGenerator()
var webTestPropertiesSpecValidationRulesARMGenerator gopter.Gen

// WebTestPropertiesSpecValidationRulesARMGenerator returns a generator of WebTestProperties_Spec_ValidationRulesARM instances for property testing.
// We first initialize webTestPropertiesSpecValidationRulesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WebTestPropertiesSpecValidationRulesARMGenerator() gopter.Gen {
	if webTestPropertiesSpecValidationRulesARMGenerator != nil {
		return webTestPropertiesSpecValidationRulesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebTestPropertiesSpecValidationRulesARM(generators)
	webTestPropertiesSpecValidationRulesARMGenerator = gen.Struct(reflect.TypeOf(WebTestProperties_Spec_ValidationRulesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebTestPropertiesSpecValidationRulesARM(generators)
	AddRelatedPropertyGeneratorsForWebTestPropertiesSpecValidationRulesARM(generators)
	webTestPropertiesSpecValidationRulesARMGenerator = gen.Struct(reflect.TypeOf(WebTestProperties_Spec_ValidationRulesARM{}), generators)

	return webTestPropertiesSpecValidationRulesARMGenerator
}

// AddIndependentPropertyGeneratorsForWebTestPropertiesSpecValidationRulesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebTestPropertiesSpecValidationRulesARM(gens map[string]gopter.Gen) {
	gens["ExpectedHttpStatusCode"] = gen.PtrOf(gen.Int())
	gens["IgnoreHttpsStatusCode"] = gen.PtrOf(gen.Bool())
	gens["SSLCertRemainingLifetimeCheck"] = gen.PtrOf(gen.Int())
	gens["SSLCheck"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForWebTestPropertiesSpecValidationRulesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWebTestPropertiesSpecValidationRulesARM(gens map[string]gopter.Gen) {
	gens["ContentValidation"] = gen.PtrOf(WebTestPropertiesSpecValidationRulesContentValidationARMGenerator())
}

func Test_HeaderField_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HeaderField_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHeaderFieldSpecARM, HeaderFieldSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHeaderFieldSpecARM runs a test to see if a specific instance of HeaderField_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHeaderFieldSpecARM(subject HeaderField_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HeaderField_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HeaderField_SpecARM instances for property testing - lazily instantiated by HeaderFieldSpecARMGenerator()
var headerFieldSpecARMGenerator gopter.Gen

// HeaderFieldSpecARMGenerator returns a generator of HeaderField_SpecARM instances for property testing.
func HeaderFieldSpecARMGenerator() gopter.Gen {
	if headerFieldSpecARMGenerator != nil {
		return headerFieldSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHeaderFieldSpecARM(generators)
	headerFieldSpecARMGenerator = gen.Struct(reflect.TypeOf(HeaderField_SpecARM{}), generators)

	return headerFieldSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForHeaderFieldSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHeaderFieldSpecARM(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_WebTestProperties_Spec_ValidationRules_ContentValidationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebTestProperties_Spec_ValidationRules_ContentValidationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebTestPropertiesSpecValidationRulesContentValidationARM, WebTestPropertiesSpecValidationRulesContentValidationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebTestPropertiesSpecValidationRulesContentValidationARM runs a test to see if a specific instance of WebTestProperties_Spec_ValidationRules_ContentValidationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWebTestPropertiesSpecValidationRulesContentValidationARM(subject WebTestProperties_Spec_ValidationRules_ContentValidationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebTestProperties_Spec_ValidationRules_ContentValidationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebTestProperties_Spec_ValidationRules_ContentValidationARM instances for property testing - lazily
//instantiated by WebTestPropertiesSpecValidationRulesContentValidationARMGenerator()
var webTestPropertiesSpecValidationRulesContentValidationARMGenerator gopter.Gen

// WebTestPropertiesSpecValidationRulesContentValidationARMGenerator returns a generator of WebTestProperties_Spec_ValidationRules_ContentValidationARM instances for property testing.
func WebTestPropertiesSpecValidationRulesContentValidationARMGenerator() gopter.Gen {
	if webTestPropertiesSpecValidationRulesContentValidationARMGenerator != nil {
		return webTestPropertiesSpecValidationRulesContentValidationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebTestPropertiesSpecValidationRulesContentValidationARM(generators)
	webTestPropertiesSpecValidationRulesContentValidationARMGenerator = gen.Struct(reflect.TypeOf(WebTestProperties_Spec_ValidationRules_ContentValidationARM{}), generators)

	return webTestPropertiesSpecValidationRulesContentValidationARMGenerator
}

// AddIndependentPropertyGeneratorsForWebTestPropertiesSpecValidationRulesContentValidationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebTestPropertiesSpecValidationRulesContentValidationARM(gens map[string]gopter.Gen) {
	gens["ContentMatch"] = gen.PtrOf(gen.AlphaString())
	gens["IgnoreCase"] = gen.PtrOf(gen.Bool())
	gens["PassIfTextFound"] = gen.PtrOf(gen.Bool())
}
