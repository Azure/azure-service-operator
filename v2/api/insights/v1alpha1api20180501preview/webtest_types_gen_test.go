// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20180501preview

import (
	"encoding/json"
	"github.com/Azure/azure-service-operator/v2/api/insights/v1alpha1api20180501previewstorage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_Webtest_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Webtest to hub returns original",
		prop.ForAll(RunResourceConversionTestForWebtest, WebtestGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForWebtest tests if a specific instance of Webtest round trips to the hub storage version and back losslessly
func RunResourceConversionTestForWebtest(subject Webtest) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v1alpha1api20180501previewstorage.Webtest
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual Webtest
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Webtest_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Webtest to Webtest via AssignPropertiesToWebtest & AssignPropertiesFromWebtest returns original",
		prop.ForAll(RunPropertyAssignmentTestForWebtest, WebtestGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWebtest tests if a specific instance of Webtest can be assigned to v1alpha1api20180501previewstorage and back losslessly
func RunPropertyAssignmentTestForWebtest(subject Webtest) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20180501previewstorage.Webtest
	err := copied.AssignPropertiesToWebtest(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Webtest
	err = actual.AssignPropertiesFromWebtest(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Webtest_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Webtest via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebtest, WebtestGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebtest runs a test to see if a specific instance of Webtest round trips to JSON and back losslessly
func RunJSONSerializationTestForWebtest(subject Webtest) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Webtest
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Webtest instances for property testing - lazily instantiated by WebtestGenerator()
var webtestGenerator gopter.Gen

// WebtestGenerator returns a generator of Webtest instances for property testing.
func WebtestGenerator() gopter.Gen {
	if webtestGenerator != nil {
		return webtestGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForWebtest(generators)
	webtestGenerator = gen.Struct(reflect.TypeOf(Webtest{}), generators)

	return webtestGenerator
}

// AddRelatedPropertyGeneratorsForWebtest is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWebtest(gens map[string]gopter.Gen) {
	gens["Spec"] = Webtests_SPECGenerator()
	gens["Status"] = WebTest_StatusGenerator()
}

func Test_WebTest_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WebTest_Status to WebTest_Status via AssignPropertiesToWebTest_Status & AssignPropertiesFromWebTest_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForWebTest_Status, WebTest_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWebTest_Status tests if a specific instance of WebTest_Status can be assigned to v1alpha1api20180501previewstorage and back losslessly
func RunPropertyAssignmentTestForWebTest_Status(subject WebTest_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20180501previewstorage.WebTest_Status
	err := copied.AssignPropertiesToWebTest_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WebTest_Status
	err = actual.AssignPropertiesFromWebTest_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WebTest_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebTest_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebTest_Status, WebTest_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebTest_Status runs a test to see if a specific instance of WebTest_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForWebTest_Status(subject WebTest_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebTest_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebTest_Status instances for property testing - lazily instantiated by WebTest_StatusGenerator()
var webTest_statusGenerator gopter.Gen

// WebTest_StatusGenerator returns a generator of WebTest_Status instances for property testing.
// We first initialize webTest_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WebTest_StatusGenerator() gopter.Gen {
	if webTest_statusGenerator != nil {
		return webTest_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebTest_Status(generators)
	webTest_statusGenerator = gen.Struct(reflect.TypeOf(WebTest_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebTest_Status(generators)
	AddRelatedPropertyGeneratorsForWebTest_Status(generators)
	webTest_statusGenerator = gen.Struct(reflect.TypeOf(WebTest_Status{}), generators)

	return webTest_statusGenerator
}

// AddIndependentPropertyGeneratorsForWebTest_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebTest_Status(gens map[string]gopter.Gen) {
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["Frequency"] = gen.PtrOf(gen.Int())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(
		WebTestProperties_Kind_StatusBasic,
		WebTestProperties_Kind_StatusMultistep,
		WebTestProperties_Kind_StatusPing,
		WebTestProperties_Kind_StatusStandard))
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PropertiesName"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["RetryEnabled"] = gen.PtrOf(gen.Bool())
	gens["SyntheticMonitorId"] = gen.PtrOf(gen.AlphaString())
	gens["Timeout"] = gen.PtrOf(gen.Int())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForWebTest_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWebTest_Status(gens map[string]gopter.Gen) {
	gens["Configuration"] = gen.PtrOf(WebTestProperties_Configuration_StatusGenerator())
	gens["Locations"] = gen.SliceOf(WebTestGeolocation_StatusGenerator())
	gens["Request"] = gen.PtrOf(WebTestProperties_Request_StatusGenerator())
	gens["ValidationRules"] = gen.PtrOf(WebTestProperties_ValidationRules_StatusGenerator())
}

func Test_Webtests_SPEC_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Webtests_SPEC to Webtests_SPEC via AssignPropertiesToWebtests_SPEC & AssignPropertiesFromWebtests_SPEC returns original",
		prop.ForAll(RunPropertyAssignmentTestForWebtests_SPEC, Webtests_SPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWebtests_SPEC tests if a specific instance of Webtests_SPEC can be assigned to v1alpha1api20180501previewstorage and back losslessly
func RunPropertyAssignmentTestForWebtests_SPEC(subject Webtests_SPEC) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20180501previewstorage.Webtests_SPEC
	err := copied.AssignPropertiesToWebtests_SPEC(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Webtests_SPEC
	err = actual.AssignPropertiesFromWebtests_SPEC(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Webtests_SPEC_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Webtests_SPEC via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebtests_SPEC, Webtests_SPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebtests_SPEC runs a test to see if a specific instance of Webtests_SPEC round trips to JSON and back losslessly
func RunJSONSerializationTestForWebtests_SPEC(subject Webtests_SPEC) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Webtests_SPEC
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Webtests_SPEC instances for property testing - lazily instantiated by Webtests_SPECGenerator()
var webtests_specGenerator gopter.Gen

// Webtests_SPECGenerator returns a generator of Webtests_SPEC instances for property testing.
// We first initialize webtests_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Webtests_SPECGenerator() gopter.Gen {
	if webtests_specGenerator != nil {
		return webtests_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebtests_SPEC(generators)
	webtests_specGenerator = gen.Struct(reflect.TypeOf(Webtests_SPEC{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebtests_SPEC(generators)
	AddRelatedPropertyGeneratorsForWebtests_SPEC(generators)
	webtests_specGenerator = gen.Struct(reflect.TypeOf(Webtests_SPEC{}), generators)

	return webtests_specGenerator
}

// AddIndependentPropertyGeneratorsForWebtests_SPEC is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebtests_SPEC(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["Frequency"] = gen.PtrOf(gen.Int())
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(
		WebTestProperties_Kind_SpecBasic,
		WebTestProperties_Kind_SpecMultistep,
		WebTestProperties_Kind_SpecPing,
		WebTestProperties_Kind_SpecStandard))
	gens["Location"] = gen.AlphaString()
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["RetryEnabled"] = gen.PtrOf(gen.Bool())
	gens["SyntheticMonitorId"] = gen.PtrOf(gen.AlphaString())
	gens["Timeout"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForWebtests_SPEC is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWebtests_SPEC(gens map[string]gopter.Gen) {
	gens["Configuration"] = gen.PtrOf(WebTestProperties_Configuration_SpecGenerator())
	gens["Locations"] = gen.SliceOf(WebTestGeolocation_SpecGenerator())
	gens["Request"] = gen.PtrOf(WebTestProperties_Request_SpecGenerator())
	gens["ValidationRules"] = gen.PtrOf(WebTestProperties_ValidationRules_SpecGenerator())
}

func Test_WebTestGeolocation_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WebTestGeolocation_Spec to WebTestGeolocation_Spec via AssignPropertiesToWebTestGeolocation_Spec & AssignPropertiesFromWebTestGeolocation_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForWebTestGeolocation_Spec, WebTestGeolocation_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWebTestGeolocation_Spec tests if a specific instance of WebTestGeolocation_Spec can be assigned to v1alpha1api20180501previewstorage and back losslessly
func RunPropertyAssignmentTestForWebTestGeolocation_Spec(subject WebTestGeolocation_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20180501previewstorage.WebTestGeolocation_Spec
	err := copied.AssignPropertiesToWebTestGeolocation_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WebTestGeolocation_Spec
	err = actual.AssignPropertiesFromWebTestGeolocation_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WebTestGeolocation_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebTestGeolocation_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebTestGeolocation_Spec, WebTestGeolocation_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebTestGeolocation_Spec runs a test to see if a specific instance of WebTestGeolocation_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForWebTestGeolocation_Spec(subject WebTestGeolocation_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebTestGeolocation_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebTestGeolocation_Spec instances for property testing - lazily instantiated by
//WebTestGeolocation_SpecGenerator()
var webTestGeolocation_specGenerator gopter.Gen

// WebTestGeolocation_SpecGenerator returns a generator of WebTestGeolocation_Spec instances for property testing.
func WebTestGeolocation_SpecGenerator() gopter.Gen {
	if webTestGeolocation_specGenerator != nil {
		return webTestGeolocation_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebTestGeolocation_Spec(generators)
	webTestGeolocation_specGenerator = gen.Struct(reflect.TypeOf(WebTestGeolocation_Spec{}), generators)

	return webTestGeolocation_specGenerator
}

// AddIndependentPropertyGeneratorsForWebTestGeolocation_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebTestGeolocation_Spec(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_WebTestGeolocation_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WebTestGeolocation_Status to WebTestGeolocation_Status via AssignPropertiesToWebTestGeolocation_Status & AssignPropertiesFromWebTestGeolocation_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForWebTestGeolocation_Status, WebTestGeolocation_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWebTestGeolocation_Status tests if a specific instance of WebTestGeolocation_Status can be assigned to v1alpha1api20180501previewstorage and back losslessly
func RunPropertyAssignmentTestForWebTestGeolocation_Status(subject WebTestGeolocation_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20180501previewstorage.WebTestGeolocation_Status
	err := copied.AssignPropertiesToWebTestGeolocation_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WebTestGeolocation_Status
	err = actual.AssignPropertiesFromWebTestGeolocation_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WebTestGeolocation_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebTestGeolocation_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebTestGeolocation_Status, WebTestGeolocation_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebTestGeolocation_Status runs a test to see if a specific instance of WebTestGeolocation_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForWebTestGeolocation_Status(subject WebTestGeolocation_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebTestGeolocation_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebTestGeolocation_Status instances for property testing - lazily instantiated by
//WebTestGeolocation_StatusGenerator()
var webTestGeolocation_statusGenerator gopter.Gen

// WebTestGeolocation_StatusGenerator returns a generator of WebTestGeolocation_Status instances for property testing.
func WebTestGeolocation_StatusGenerator() gopter.Gen {
	if webTestGeolocation_statusGenerator != nil {
		return webTestGeolocation_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebTestGeolocation_Status(generators)
	webTestGeolocation_statusGenerator = gen.Struct(reflect.TypeOf(WebTestGeolocation_Status{}), generators)

	return webTestGeolocation_statusGenerator
}

// AddIndependentPropertyGeneratorsForWebTestGeolocation_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebTestGeolocation_Status(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_WebTestProperties_Configuration_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WebTestProperties_Configuration_Spec to WebTestProperties_Configuration_Spec via AssignPropertiesToWebTestProperties_Configuration_Spec & AssignPropertiesFromWebTestProperties_Configuration_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForWebTestProperties_Configuration_Spec, WebTestProperties_Configuration_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWebTestProperties_Configuration_Spec tests if a specific instance of WebTestProperties_Configuration_Spec can be assigned to v1alpha1api20180501previewstorage and back losslessly
func RunPropertyAssignmentTestForWebTestProperties_Configuration_Spec(subject WebTestProperties_Configuration_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20180501previewstorage.WebTestProperties_Configuration_Spec
	err := copied.AssignPropertiesToWebTestProperties_Configuration_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WebTestProperties_Configuration_Spec
	err = actual.AssignPropertiesFromWebTestProperties_Configuration_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WebTestProperties_Configuration_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebTestProperties_Configuration_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebTestProperties_Configuration_Spec, WebTestProperties_Configuration_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebTestProperties_Configuration_Spec runs a test to see if a specific instance of WebTestProperties_Configuration_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForWebTestProperties_Configuration_Spec(subject WebTestProperties_Configuration_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebTestProperties_Configuration_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebTestProperties_Configuration_Spec instances for property testing - lazily instantiated by
//WebTestProperties_Configuration_SpecGenerator()
var webTestProperties_configuration_specGenerator gopter.Gen

// WebTestProperties_Configuration_SpecGenerator returns a generator of WebTestProperties_Configuration_Spec instances for property testing.
func WebTestProperties_Configuration_SpecGenerator() gopter.Gen {
	if webTestProperties_configuration_specGenerator != nil {
		return webTestProperties_configuration_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebTestProperties_Configuration_Spec(generators)
	webTestProperties_configuration_specGenerator = gen.Struct(reflect.TypeOf(WebTestProperties_Configuration_Spec{}), generators)

	return webTestProperties_configuration_specGenerator
}

// AddIndependentPropertyGeneratorsForWebTestProperties_Configuration_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebTestProperties_Configuration_Spec(gens map[string]gopter.Gen) {
	gens["WebTest"] = gen.PtrOf(gen.AlphaString())
}

func Test_WebTestProperties_Configuration_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WebTestProperties_Configuration_Status to WebTestProperties_Configuration_Status via AssignPropertiesToWebTestProperties_Configuration_Status & AssignPropertiesFromWebTestProperties_Configuration_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForWebTestProperties_Configuration_Status, WebTestProperties_Configuration_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWebTestProperties_Configuration_Status tests if a specific instance of WebTestProperties_Configuration_Status can be assigned to v1alpha1api20180501previewstorage and back losslessly
func RunPropertyAssignmentTestForWebTestProperties_Configuration_Status(subject WebTestProperties_Configuration_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20180501previewstorage.WebTestProperties_Configuration_Status
	err := copied.AssignPropertiesToWebTestProperties_Configuration_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WebTestProperties_Configuration_Status
	err = actual.AssignPropertiesFromWebTestProperties_Configuration_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WebTestProperties_Configuration_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebTestProperties_Configuration_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebTestProperties_Configuration_Status, WebTestProperties_Configuration_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebTestProperties_Configuration_Status runs a test to see if a specific instance of WebTestProperties_Configuration_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForWebTestProperties_Configuration_Status(subject WebTestProperties_Configuration_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebTestProperties_Configuration_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebTestProperties_Configuration_Status instances for property testing - lazily instantiated by
//WebTestProperties_Configuration_StatusGenerator()
var webTestProperties_configuration_statusGenerator gopter.Gen

// WebTestProperties_Configuration_StatusGenerator returns a generator of WebTestProperties_Configuration_Status instances for property testing.
func WebTestProperties_Configuration_StatusGenerator() gopter.Gen {
	if webTestProperties_configuration_statusGenerator != nil {
		return webTestProperties_configuration_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebTestProperties_Configuration_Status(generators)
	webTestProperties_configuration_statusGenerator = gen.Struct(reflect.TypeOf(WebTestProperties_Configuration_Status{}), generators)

	return webTestProperties_configuration_statusGenerator
}

// AddIndependentPropertyGeneratorsForWebTestProperties_Configuration_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebTestProperties_Configuration_Status(gens map[string]gopter.Gen) {
	gens["WebTest"] = gen.PtrOf(gen.AlphaString())
}

func Test_WebTestProperties_Request_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WebTestProperties_Request_Spec to WebTestProperties_Request_Spec via AssignPropertiesToWebTestProperties_Request_Spec & AssignPropertiesFromWebTestProperties_Request_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForWebTestProperties_Request_Spec, WebTestProperties_Request_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWebTestProperties_Request_Spec tests if a specific instance of WebTestProperties_Request_Spec can be assigned to v1alpha1api20180501previewstorage and back losslessly
func RunPropertyAssignmentTestForWebTestProperties_Request_Spec(subject WebTestProperties_Request_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20180501previewstorage.WebTestProperties_Request_Spec
	err := copied.AssignPropertiesToWebTestProperties_Request_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WebTestProperties_Request_Spec
	err = actual.AssignPropertiesFromWebTestProperties_Request_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WebTestProperties_Request_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebTestProperties_Request_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebTestProperties_Request_Spec, WebTestProperties_Request_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebTestProperties_Request_Spec runs a test to see if a specific instance of WebTestProperties_Request_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForWebTestProperties_Request_Spec(subject WebTestProperties_Request_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebTestProperties_Request_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebTestProperties_Request_Spec instances for property testing - lazily instantiated by
//WebTestProperties_Request_SpecGenerator()
var webTestProperties_request_specGenerator gopter.Gen

// WebTestProperties_Request_SpecGenerator returns a generator of WebTestProperties_Request_Spec instances for property testing.
// We first initialize webTestProperties_request_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WebTestProperties_Request_SpecGenerator() gopter.Gen {
	if webTestProperties_request_specGenerator != nil {
		return webTestProperties_request_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebTestProperties_Request_Spec(generators)
	webTestProperties_request_specGenerator = gen.Struct(reflect.TypeOf(WebTestProperties_Request_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebTestProperties_Request_Spec(generators)
	AddRelatedPropertyGeneratorsForWebTestProperties_Request_Spec(generators)
	webTestProperties_request_specGenerator = gen.Struct(reflect.TypeOf(WebTestProperties_Request_Spec{}), generators)

	return webTestProperties_request_specGenerator
}

// AddIndependentPropertyGeneratorsForWebTestProperties_Request_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebTestProperties_Request_Spec(gens map[string]gopter.Gen) {
	gens["FollowRedirects"] = gen.PtrOf(gen.Bool())
	gens["HttpVerb"] = gen.PtrOf(gen.AlphaString())
	gens["ParseDependentRequests"] = gen.PtrOf(gen.Bool())
	gens["RequestBody"] = gen.PtrOf(gen.AlphaString())
	gens["RequestUrl"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForWebTestProperties_Request_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWebTestProperties_Request_Spec(gens map[string]gopter.Gen) {
	gens["Headers"] = gen.SliceOf(HeaderField_SpecGenerator())
}

func Test_WebTestProperties_Request_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WebTestProperties_Request_Status to WebTestProperties_Request_Status via AssignPropertiesToWebTestProperties_Request_Status & AssignPropertiesFromWebTestProperties_Request_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForWebTestProperties_Request_Status, WebTestProperties_Request_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWebTestProperties_Request_Status tests if a specific instance of WebTestProperties_Request_Status can be assigned to v1alpha1api20180501previewstorage and back losslessly
func RunPropertyAssignmentTestForWebTestProperties_Request_Status(subject WebTestProperties_Request_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20180501previewstorage.WebTestProperties_Request_Status
	err := copied.AssignPropertiesToWebTestProperties_Request_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WebTestProperties_Request_Status
	err = actual.AssignPropertiesFromWebTestProperties_Request_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WebTestProperties_Request_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebTestProperties_Request_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebTestProperties_Request_Status, WebTestProperties_Request_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebTestProperties_Request_Status runs a test to see if a specific instance of WebTestProperties_Request_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForWebTestProperties_Request_Status(subject WebTestProperties_Request_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebTestProperties_Request_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebTestProperties_Request_Status instances for property testing - lazily instantiated by
//WebTestProperties_Request_StatusGenerator()
var webTestProperties_request_statusGenerator gopter.Gen

// WebTestProperties_Request_StatusGenerator returns a generator of WebTestProperties_Request_Status instances for property testing.
// We first initialize webTestProperties_request_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WebTestProperties_Request_StatusGenerator() gopter.Gen {
	if webTestProperties_request_statusGenerator != nil {
		return webTestProperties_request_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebTestProperties_Request_Status(generators)
	webTestProperties_request_statusGenerator = gen.Struct(reflect.TypeOf(WebTestProperties_Request_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebTestProperties_Request_Status(generators)
	AddRelatedPropertyGeneratorsForWebTestProperties_Request_Status(generators)
	webTestProperties_request_statusGenerator = gen.Struct(reflect.TypeOf(WebTestProperties_Request_Status{}), generators)

	return webTestProperties_request_statusGenerator
}

// AddIndependentPropertyGeneratorsForWebTestProperties_Request_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebTestProperties_Request_Status(gens map[string]gopter.Gen) {
	gens["FollowRedirects"] = gen.PtrOf(gen.Bool())
	gens["HttpVerb"] = gen.PtrOf(gen.AlphaString())
	gens["ParseDependentRequests"] = gen.PtrOf(gen.Bool())
	gens["RequestBody"] = gen.PtrOf(gen.AlphaString())
	gens["RequestUrl"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForWebTestProperties_Request_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWebTestProperties_Request_Status(gens map[string]gopter.Gen) {
	gens["Headers"] = gen.SliceOf(HeaderField_StatusGenerator())
}

func Test_WebTestProperties_ValidationRules_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WebTestProperties_ValidationRules_Spec to WebTestProperties_ValidationRules_Spec via AssignPropertiesToWebTestProperties_ValidationRules_Spec & AssignPropertiesFromWebTestProperties_ValidationRules_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForWebTestProperties_ValidationRules_Spec, WebTestProperties_ValidationRules_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWebTestProperties_ValidationRules_Spec tests if a specific instance of WebTestProperties_ValidationRules_Spec can be assigned to v1alpha1api20180501previewstorage and back losslessly
func RunPropertyAssignmentTestForWebTestProperties_ValidationRules_Spec(subject WebTestProperties_ValidationRules_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20180501previewstorage.WebTestProperties_ValidationRules_Spec
	err := copied.AssignPropertiesToWebTestProperties_ValidationRules_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WebTestProperties_ValidationRules_Spec
	err = actual.AssignPropertiesFromWebTestProperties_ValidationRules_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WebTestProperties_ValidationRules_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebTestProperties_ValidationRules_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebTestProperties_ValidationRules_Spec, WebTestProperties_ValidationRules_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebTestProperties_ValidationRules_Spec runs a test to see if a specific instance of WebTestProperties_ValidationRules_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForWebTestProperties_ValidationRules_Spec(subject WebTestProperties_ValidationRules_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebTestProperties_ValidationRules_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebTestProperties_ValidationRules_Spec instances for property testing - lazily instantiated by
//WebTestProperties_ValidationRules_SpecGenerator()
var webTestProperties_validationRules_specGenerator gopter.Gen

// WebTestProperties_ValidationRules_SpecGenerator returns a generator of WebTestProperties_ValidationRules_Spec instances for property testing.
// We first initialize webTestProperties_validationRules_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WebTestProperties_ValidationRules_SpecGenerator() gopter.Gen {
	if webTestProperties_validationRules_specGenerator != nil {
		return webTestProperties_validationRules_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebTestProperties_ValidationRules_Spec(generators)
	webTestProperties_validationRules_specGenerator = gen.Struct(reflect.TypeOf(WebTestProperties_ValidationRules_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebTestProperties_ValidationRules_Spec(generators)
	AddRelatedPropertyGeneratorsForWebTestProperties_ValidationRules_Spec(generators)
	webTestProperties_validationRules_specGenerator = gen.Struct(reflect.TypeOf(WebTestProperties_ValidationRules_Spec{}), generators)

	return webTestProperties_validationRules_specGenerator
}

// AddIndependentPropertyGeneratorsForWebTestProperties_ValidationRules_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebTestProperties_ValidationRules_Spec(gens map[string]gopter.Gen) {
	gens["ExpectedHttpStatusCode"] = gen.PtrOf(gen.Int())
	gens["IgnoreHttpsStatusCode"] = gen.PtrOf(gen.Bool())
	gens["SSLCertRemainingLifetimeCheck"] = gen.PtrOf(gen.Int())
	gens["SSLCheck"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForWebTestProperties_ValidationRules_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWebTestProperties_ValidationRules_Spec(gens map[string]gopter.Gen) {
	gens["ContentValidation"] = gen.PtrOf(WebTestProperties_ValidationRules_ContentValidation_SpecGenerator())
}

func Test_WebTestProperties_ValidationRules_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WebTestProperties_ValidationRules_Status to WebTestProperties_ValidationRules_Status via AssignPropertiesToWebTestProperties_ValidationRules_Status & AssignPropertiesFromWebTestProperties_ValidationRules_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForWebTestProperties_ValidationRules_Status, WebTestProperties_ValidationRules_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWebTestProperties_ValidationRules_Status tests if a specific instance of WebTestProperties_ValidationRules_Status can be assigned to v1alpha1api20180501previewstorage and back losslessly
func RunPropertyAssignmentTestForWebTestProperties_ValidationRules_Status(subject WebTestProperties_ValidationRules_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20180501previewstorage.WebTestProperties_ValidationRules_Status
	err := copied.AssignPropertiesToWebTestProperties_ValidationRules_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WebTestProperties_ValidationRules_Status
	err = actual.AssignPropertiesFromWebTestProperties_ValidationRules_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WebTestProperties_ValidationRules_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebTestProperties_ValidationRules_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebTestProperties_ValidationRules_Status, WebTestProperties_ValidationRules_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebTestProperties_ValidationRules_Status runs a test to see if a specific instance of WebTestProperties_ValidationRules_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForWebTestProperties_ValidationRules_Status(subject WebTestProperties_ValidationRules_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebTestProperties_ValidationRules_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebTestProperties_ValidationRules_Status instances for property testing - lazily instantiated by
//WebTestProperties_ValidationRules_StatusGenerator()
var webTestProperties_validationRules_statusGenerator gopter.Gen

// WebTestProperties_ValidationRules_StatusGenerator returns a generator of WebTestProperties_ValidationRules_Status instances for property testing.
// We first initialize webTestProperties_validationRules_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WebTestProperties_ValidationRules_StatusGenerator() gopter.Gen {
	if webTestProperties_validationRules_statusGenerator != nil {
		return webTestProperties_validationRules_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebTestProperties_ValidationRules_Status(generators)
	webTestProperties_validationRules_statusGenerator = gen.Struct(reflect.TypeOf(WebTestProperties_ValidationRules_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebTestProperties_ValidationRules_Status(generators)
	AddRelatedPropertyGeneratorsForWebTestProperties_ValidationRules_Status(generators)
	webTestProperties_validationRules_statusGenerator = gen.Struct(reflect.TypeOf(WebTestProperties_ValidationRules_Status{}), generators)

	return webTestProperties_validationRules_statusGenerator
}

// AddIndependentPropertyGeneratorsForWebTestProperties_ValidationRules_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebTestProperties_ValidationRules_Status(gens map[string]gopter.Gen) {
	gens["ExpectedHttpStatusCode"] = gen.PtrOf(gen.Int())
	gens["IgnoreHttpsStatusCode"] = gen.PtrOf(gen.Bool())
	gens["SSLCertRemainingLifetimeCheck"] = gen.PtrOf(gen.Int())
	gens["SSLCheck"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForWebTestProperties_ValidationRules_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWebTestProperties_ValidationRules_Status(gens map[string]gopter.Gen) {
	gens["ContentValidation"] = gen.PtrOf(WebTestProperties_ValidationRules_ContentValidation_StatusGenerator())
}

func Test_HeaderField_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HeaderField_Spec to HeaderField_Spec via AssignPropertiesToHeaderField_Spec & AssignPropertiesFromHeaderField_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForHeaderField_Spec, HeaderField_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHeaderField_Spec tests if a specific instance of HeaderField_Spec can be assigned to v1alpha1api20180501previewstorage and back losslessly
func RunPropertyAssignmentTestForHeaderField_Spec(subject HeaderField_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20180501previewstorage.HeaderField_Spec
	err := copied.AssignPropertiesToHeaderField_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HeaderField_Spec
	err = actual.AssignPropertiesFromHeaderField_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HeaderField_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HeaderField_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHeaderField_Spec, HeaderField_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHeaderField_Spec runs a test to see if a specific instance of HeaderField_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForHeaderField_Spec(subject HeaderField_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HeaderField_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HeaderField_Spec instances for property testing - lazily instantiated by HeaderField_SpecGenerator()
var headerField_specGenerator gopter.Gen

// HeaderField_SpecGenerator returns a generator of HeaderField_Spec instances for property testing.
func HeaderField_SpecGenerator() gopter.Gen {
	if headerField_specGenerator != nil {
		return headerField_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHeaderField_Spec(generators)
	headerField_specGenerator = gen.Struct(reflect.TypeOf(HeaderField_Spec{}), generators)

	return headerField_specGenerator
}

// AddIndependentPropertyGeneratorsForHeaderField_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHeaderField_Spec(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_HeaderField_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HeaderField_Status to HeaderField_Status via AssignPropertiesToHeaderField_Status & AssignPropertiesFromHeaderField_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForHeaderField_Status, HeaderField_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHeaderField_Status tests if a specific instance of HeaderField_Status can be assigned to v1alpha1api20180501previewstorage and back losslessly
func RunPropertyAssignmentTestForHeaderField_Status(subject HeaderField_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20180501previewstorage.HeaderField_Status
	err := copied.AssignPropertiesToHeaderField_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HeaderField_Status
	err = actual.AssignPropertiesFromHeaderField_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HeaderField_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HeaderField_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHeaderField_Status, HeaderField_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHeaderField_Status runs a test to see if a specific instance of HeaderField_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForHeaderField_Status(subject HeaderField_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HeaderField_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HeaderField_Status instances for property testing - lazily instantiated by HeaderField_StatusGenerator()
var headerField_statusGenerator gopter.Gen

// HeaderField_StatusGenerator returns a generator of HeaderField_Status instances for property testing.
func HeaderField_StatusGenerator() gopter.Gen {
	if headerField_statusGenerator != nil {
		return headerField_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHeaderField_Status(generators)
	headerField_statusGenerator = gen.Struct(reflect.TypeOf(HeaderField_Status{}), generators)

	return headerField_statusGenerator
}

// AddIndependentPropertyGeneratorsForHeaderField_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHeaderField_Status(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_WebTestProperties_ValidationRules_ContentValidation_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WebTestProperties_ValidationRules_ContentValidation_Spec to WebTestProperties_ValidationRules_ContentValidation_Spec via AssignPropertiesToWebTestProperties_ValidationRules_ContentValidation_Spec & AssignPropertiesFromWebTestProperties_ValidationRules_ContentValidation_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForWebTestProperties_ValidationRules_ContentValidation_Spec, WebTestProperties_ValidationRules_ContentValidation_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWebTestProperties_ValidationRules_ContentValidation_Spec tests if a specific instance of WebTestProperties_ValidationRules_ContentValidation_Spec can be assigned to v1alpha1api20180501previewstorage and back losslessly
func RunPropertyAssignmentTestForWebTestProperties_ValidationRules_ContentValidation_Spec(subject WebTestProperties_ValidationRules_ContentValidation_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20180501previewstorage.WebTestProperties_ValidationRules_ContentValidation_Spec
	err := copied.AssignPropertiesToWebTestProperties_ValidationRules_ContentValidation_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WebTestProperties_ValidationRules_ContentValidation_Spec
	err = actual.AssignPropertiesFromWebTestProperties_ValidationRules_ContentValidation_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WebTestProperties_ValidationRules_ContentValidation_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebTestProperties_ValidationRules_ContentValidation_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebTestProperties_ValidationRules_ContentValidation_Spec, WebTestProperties_ValidationRules_ContentValidation_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebTestProperties_ValidationRules_ContentValidation_Spec runs a test to see if a specific instance of WebTestProperties_ValidationRules_ContentValidation_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForWebTestProperties_ValidationRules_ContentValidation_Spec(subject WebTestProperties_ValidationRules_ContentValidation_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebTestProperties_ValidationRules_ContentValidation_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebTestProperties_ValidationRules_ContentValidation_Spec instances for property testing - lazily
//instantiated by WebTestProperties_ValidationRules_ContentValidation_SpecGenerator()
var webTestProperties_validationRules_contentValidation_specGenerator gopter.Gen

// WebTestProperties_ValidationRules_ContentValidation_SpecGenerator returns a generator of WebTestProperties_ValidationRules_ContentValidation_Spec instances for property testing.
func WebTestProperties_ValidationRules_ContentValidation_SpecGenerator() gopter.Gen {
	if webTestProperties_validationRules_contentValidation_specGenerator != nil {
		return webTestProperties_validationRules_contentValidation_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebTestProperties_ValidationRules_ContentValidation_Spec(generators)
	webTestProperties_validationRules_contentValidation_specGenerator = gen.Struct(reflect.TypeOf(WebTestProperties_ValidationRules_ContentValidation_Spec{}), generators)

	return webTestProperties_validationRules_contentValidation_specGenerator
}

// AddIndependentPropertyGeneratorsForWebTestProperties_ValidationRules_ContentValidation_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebTestProperties_ValidationRules_ContentValidation_Spec(gens map[string]gopter.Gen) {
	gens["ContentMatch"] = gen.PtrOf(gen.AlphaString())
	gens["IgnoreCase"] = gen.PtrOf(gen.Bool())
	gens["PassIfTextFound"] = gen.PtrOf(gen.Bool())
}

func Test_WebTestProperties_ValidationRules_ContentValidation_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WebTestProperties_ValidationRules_ContentValidation_Status to WebTestProperties_ValidationRules_ContentValidation_Status via AssignPropertiesToWebTestProperties_ValidationRules_ContentValidation_Status & AssignPropertiesFromWebTestProperties_ValidationRules_ContentValidation_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForWebTestProperties_ValidationRules_ContentValidation_Status, WebTestProperties_ValidationRules_ContentValidation_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWebTestProperties_ValidationRules_ContentValidation_Status tests if a specific instance of WebTestProperties_ValidationRules_ContentValidation_Status can be assigned to v1alpha1api20180501previewstorage and back losslessly
func RunPropertyAssignmentTestForWebTestProperties_ValidationRules_ContentValidation_Status(subject WebTestProperties_ValidationRules_ContentValidation_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20180501previewstorage.WebTestProperties_ValidationRules_ContentValidation_Status
	err := copied.AssignPropertiesToWebTestProperties_ValidationRules_ContentValidation_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WebTestProperties_ValidationRules_ContentValidation_Status
	err = actual.AssignPropertiesFromWebTestProperties_ValidationRules_ContentValidation_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WebTestProperties_ValidationRules_ContentValidation_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebTestProperties_ValidationRules_ContentValidation_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebTestProperties_ValidationRules_ContentValidation_Status, WebTestProperties_ValidationRules_ContentValidation_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebTestProperties_ValidationRules_ContentValidation_Status runs a test to see if a specific instance of WebTestProperties_ValidationRules_ContentValidation_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForWebTestProperties_ValidationRules_ContentValidation_Status(subject WebTestProperties_ValidationRules_ContentValidation_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebTestProperties_ValidationRules_ContentValidation_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebTestProperties_ValidationRules_ContentValidation_Status instances for property testing - lazily
//instantiated by WebTestProperties_ValidationRules_ContentValidation_StatusGenerator()
var webTestProperties_validationRules_contentValidation_statusGenerator gopter.Gen

// WebTestProperties_ValidationRules_ContentValidation_StatusGenerator returns a generator of WebTestProperties_ValidationRules_ContentValidation_Status instances for property testing.
func WebTestProperties_ValidationRules_ContentValidation_StatusGenerator() gopter.Gen {
	if webTestProperties_validationRules_contentValidation_statusGenerator != nil {
		return webTestProperties_validationRules_contentValidation_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebTestProperties_ValidationRules_ContentValidation_Status(generators)
	webTestProperties_validationRules_contentValidation_statusGenerator = gen.Struct(reflect.TypeOf(WebTestProperties_ValidationRules_ContentValidation_Status{}), generators)

	return webTestProperties_validationRules_contentValidation_statusGenerator
}

// AddIndependentPropertyGeneratorsForWebTestProperties_ValidationRules_ContentValidation_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebTestProperties_ValidationRules_ContentValidation_Status(gens map[string]gopter.Gen) {
	gens["ContentMatch"] = gen.PtrOf(gen.AlphaString())
	gens["IgnoreCase"] = gen.PtrOf(gen.Bool())
	gens["PassIfTextFound"] = gen.PtrOf(gen.Bool())
}
