// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package storage

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_DynamicMetricCriteria_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DynamicMetricCriteria via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDynamicMetricCriteria, DynamicMetricCriteriaGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDynamicMetricCriteria runs a test to see if a specific instance of DynamicMetricCriteria round trips to JSON and back losslessly
func RunJSONSerializationTestForDynamicMetricCriteria(subject DynamicMetricCriteria) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DynamicMetricCriteria
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DynamicMetricCriteria instances for property testing - lazily instantiated by
// DynamicMetricCriteriaGenerator()
var dynamicMetricCriteriaGenerator gopter.Gen

// DynamicMetricCriteriaGenerator returns a generator of DynamicMetricCriteria instances for property testing.
// We first initialize dynamicMetricCriteriaGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DynamicMetricCriteriaGenerator() gopter.Gen {
	if dynamicMetricCriteriaGenerator != nil {
		return dynamicMetricCriteriaGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDynamicMetricCriteria(generators)
	dynamicMetricCriteriaGenerator = gen.Struct(reflect.TypeOf(DynamicMetricCriteria{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDynamicMetricCriteria(generators)
	AddRelatedPropertyGeneratorsForDynamicMetricCriteria(generators)
	dynamicMetricCriteriaGenerator = gen.Struct(reflect.TypeOf(DynamicMetricCriteria{}), generators)

	return dynamicMetricCriteriaGenerator
}

// AddIndependentPropertyGeneratorsForDynamicMetricCriteria is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDynamicMetricCriteria(gens map[string]gopter.Gen) {
	gens["AlertSensitivity"] = gen.PtrOf(gen.AlphaString())
	gens["CriterionType"] = gen.PtrOf(gen.AlphaString())
	gens["IgnoreDataBefore"] = gen.PtrOf(gen.AlphaString())
	gens["MetricName"] = gen.PtrOf(gen.AlphaString())
	gens["MetricNamespace"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Operator"] = gen.PtrOf(gen.AlphaString())
	gens["SkipMetricValidation"] = gen.PtrOf(gen.Bool())
	gens["TimeAggregation"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDynamicMetricCriteria is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDynamicMetricCriteria(gens map[string]gopter.Gen) {
	gens["Dimensions"] = gen.SliceOf(MetricDimensionGenerator())
	gens["FailingPeriods"] = gen.PtrOf(DynamicThresholdFailingPeriodsGenerator())
}

func Test_DynamicMetricCriteria_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DynamicMetricCriteria_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDynamicMetricCriteria_STATUS, DynamicMetricCriteria_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDynamicMetricCriteria_STATUS runs a test to see if a specific instance of DynamicMetricCriteria_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDynamicMetricCriteria_STATUS(subject DynamicMetricCriteria_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DynamicMetricCriteria_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DynamicMetricCriteria_STATUS instances for property testing - lazily instantiated by
// DynamicMetricCriteria_STATUSGenerator()
var dynamicMetricCriteria_STATUSGenerator gopter.Gen

// DynamicMetricCriteria_STATUSGenerator returns a generator of DynamicMetricCriteria_STATUS instances for property testing.
// We first initialize dynamicMetricCriteria_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DynamicMetricCriteria_STATUSGenerator() gopter.Gen {
	if dynamicMetricCriteria_STATUSGenerator != nil {
		return dynamicMetricCriteria_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDynamicMetricCriteria_STATUS(generators)
	dynamicMetricCriteria_STATUSGenerator = gen.Struct(reflect.TypeOf(DynamicMetricCriteria_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDynamicMetricCriteria_STATUS(generators)
	AddRelatedPropertyGeneratorsForDynamicMetricCriteria_STATUS(generators)
	dynamicMetricCriteria_STATUSGenerator = gen.Struct(reflect.TypeOf(DynamicMetricCriteria_STATUS{}), generators)

	return dynamicMetricCriteria_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDynamicMetricCriteria_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDynamicMetricCriteria_STATUS(gens map[string]gopter.Gen) {
	gens["AlertSensitivity"] = gen.PtrOf(gen.AlphaString())
	gens["CriterionType"] = gen.PtrOf(gen.AlphaString())
	gens["IgnoreDataBefore"] = gen.PtrOf(gen.AlphaString())
	gens["MetricName"] = gen.PtrOf(gen.AlphaString())
	gens["MetricNamespace"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Operator"] = gen.PtrOf(gen.AlphaString())
	gens["SkipMetricValidation"] = gen.PtrOf(gen.Bool())
	gens["TimeAggregation"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDynamicMetricCriteria_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDynamicMetricCriteria_STATUS(gens map[string]gopter.Gen) {
	gens["Dimensions"] = gen.SliceOf(MetricDimension_STATUSGenerator())
	gens["FailingPeriods"] = gen.PtrOf(DynamicThresholdFailingPeriods_STATUSGenerator())
}

func Test_DynamicThresholdFailingPeriods_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DynamicThresholdFailingPeriods via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDynamicThresholdFailingPeriods, DynamicThresholdFailingPeriodsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDynamicThresholdFailingPeriods runs a test to see if a specific instance of DynamicThresholdFailingPeriods round trips to JSON and back losslessly
func RunJSONSerializationTestForDynamicThresholdFailingPeriods(subject DynamicThresholdFailingPeriods) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DynamicThresholdFailingPeriods
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DynamicThresholdFailingPeriods instances for property testing - lazily instantiated by
// DynamicThresholdFailingPeriodsGenerator()
var dynamicThresholdFailingPeriodsGenerator gopter.Gen

// DynamicThresholdFailingPeriodsGenerator returns a generator of DynamicThresholdFailingPeriods instances for property testing.
func DynamicThresholdFailingPeriodsGenerator() gopter.Gen {
	if dynamicThresholdFailingPeriodsGenerator != nil {
		return dynamicThresholdFailingPeriodsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDynamicThresholdFailingPeriods(generators)
	dynamicThresholdFailingPeriodsGenerator = gen.Struct(reflect.TypeOf(DynamicThresholdFailingPeriods{}), generators)

	return dynamicThresholdFailingPeriodsGenerator
}

// AddIndependentPropertyGeneratorsForDynamicThresholdFailingPeriods is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDynamicThresholdFailingPeriods(gens map[string]gopter.Gen) {
	gens["MinFailingPeriodsToAlert"] = gen.PtrOf(gen.Float64())
	gens["NumberOfEvaluationPeriods"] = gen.PtrOf(gen.Float64())
}

func Test_DynamicThresholdFailingPeriods_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DynamicThresholdFailingPeriods_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDynamicThresholdFailingPeriods_STATUS, DynamicThresholdFailingPeriods_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDynamicThresholdFailingPeriods_STATUS runs a test to see if a specific instance of DynamicThresholdFailingPeriods_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDynamicThresholdFailingPeriods_STATUS(subject DynamicThresholdFailingPeriods_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DynamicThresholdFailingPeriods_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DynamicThresholdFailingPeriods_STATUS instances for property testing - lazily instantiated by
// DynamicThresholdFailingPeriods_STATUSGenerator()
var dynamicThresholdFailingPeriods_STATUSGenerator gopter.Gen

// DynamicThresholdFailingPeriods_STATUSGenerator returns a generator of DynamicThresholdFailingPeriods_STATUS instances for property testing.
func DynamicThresholdFailingPeriods_STATUSGenerator() gopter.Gen {
	if dynamicThresholdFailingPeriods_STATUSGenerator != nil {
		return dynamicThresholdFailingPeriods_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDynamicThresholdFailingPeriods_STATUS(generators)
	dynamicThresholdFailingPeriods_STATUSGenerator = gen.Struct(reflect.TypeOf(DynamicThresholdFailingPeriods_STATUS{}), generators)

	return dynamicThresholdFailingPeriods_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDynamicThresholdFailingPeriods_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDynamicThresholdFailingPeriods_STATUS(gens map[string]gopter.Gen) {
	gens["MinFailingPeriodsToAlert"] = gen.PtrOf(gen.Float64())
	gens["NumberOfEvaluationPeriods"] = gen.PtrOf(gen.Float64())
}

func Test_MetricAlert_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MetricAlert via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMetricAlert, MetricAlertGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMetricAlert runs a test to see if a specific instance of MetricAlert round trips to JSON and back losslessly
func RunJSONSerializationTestForMetricAlert(subject MetricAlert) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MetricAlert
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MetricAlert instances for property testing - lazily instantiated by MetricAlertGenerator()
var metricAlertGenerator gopter.Gen

// MetricAlertGenerator returns a generator of MetricAlert instances for property testing.
func MetricAlertGenerator() gopter.Gen {
	if metricAlertGenerator != nil {
		return metricAlertGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForMetricAlert(generators)
	metricAlertGenerator = gen.Struct(reflect.TypeOf(MetricAlert{}), generators)

	return metricAlertGenerator
}

// AddRelatedPropertyGeneratorsForMetricAlert is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMetricAlert(gens map[string]gopter.Gen) {
	gens["Spec"] = MetricAlert_SpecGenerator()
	gens["Status"] = MetricAlert_STATUSGenerator()
}

func Test_MetricAlertAction_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MetricAlertAction via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMetricAlertAction, MetricAlertActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMetricAlertAction runs a test to see if a specific instance of MetricAlertAction round trips to JSON and back losslessly
func RunJSONSerializationTestForMetricAlertAction(subject MetricAlertAction) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MetricAlertAction
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MetricAlertAction instances for property testing - lazily instantiated by MetricAlertActionGenerator()
var metricAlertActionGenerator gopter.Gen

// MetricAlertActionGenerator returns a generator of MetricAlertAction instances for property testing.
func MetricAlertActionGenerator() gopter.Gen {
	if metricAlertActionGenerator != nil {
		return metricAlertActionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricAlertAction(generators)
	metricAlertActionGenerator = gen.Struct(reflect.TypeOf(MetricAlertAction{}), generators)

	return metricAlertActionGenerator
}

// AddIndependentPropertyGeneratorsForMetricAlertAction is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMetricAlertAction(gens map[string]gopter.Gen) {
	gens["ActionGroupId"] = gen.PtrOf(gen.AlphaString())
	gens["WebHookProperties"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

func Test_MetricAlertAction_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MetricAlertAction_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMetricAlertAction_STATUS, MetricAlertAction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMetricAlertAction_STATUS runs a test to see if a specific instance of MetricAlertAction_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForMetricAlertAction_STATUS(subject MetricAlertAction_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MetricAlertAction_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MetricAlertAction_STATUS instances for property testing - lazily instantiated by
// MetricAlertAction_STATUSGenerator()
var metricAlertAction_STATUSGenerator gopter.Gen

// MetricAlertAction_STATUSGenerator returns a generator of MetricAlertAction_STATUS instances for property testing.
func MetricAlertAction_STATUSGenerator() gopter.Gen {
	if metricAlertAction_STATUSGenerator != nil {
		return metricAlertAction_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricAlertAction_STATUS(generators)
	metricAlertAction_STATUSGenerator = gen.Struct(reflect.TypeOf(MetricAlertAction_STATUS{}), generators)

	return metricAlertAction_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForMetricAlertAction_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMetricAlertAction_STATUS(gens map[string]gopter.Gen) {
	gens["ActionGroupId"] = gen.PtrOf(gen.AlphaString())
	gens["WebHookProperties"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

func Test_MetricAlertCriteria_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MetricAlertCriteria via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMetricAlertCriteria, MetricAlertCriteriaGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMetricAlertCriteria runs a test to see if a specific instance of MetricAlertCriteria round trips to JSON and back losslessly
func RunJSONSerializationTestForMetricAlertCriteria(subject MetricAlertCriteria) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MetricAlertCriteria
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MetricAlertCriteria instances for property testing - lazily instantiated by
// MetricAlertCriteriaGenerator()
var metricAlertCriteriaGenerator gopter.Gen

// MetricAlertCriteriaGenerator returns a generator of MetricAlertCriteria instances for property testing.
func MetricAlertCriteriaGenerator() gopter.Gen {
	if metricAlertCriteriaGenerator != nil {
		return metricAlertCriteriaGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForMetricAlertCriteria(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(MetricAlertCriteria{}), map[string]gopter.Gen{propName: propGen}))
	}
	metricAlertCriteriaGenerator = gen.OneGenOf(gens...)

	return metricAlertCriteriaGenerator
}

// AddRelatedPropertyGeneratorsForMetricAlertCriteria is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMetricAlertCriteria(gens map[string]gopter.Gen) {
	gens["MicrosoftAzureMonitorMultipleResourceMultipleMetric"] = MetricAlertMultipleResourceMultipleMetricCriteriaGenerator().Map(func(it MetricAlertMultipleResourceMultipleMetricCriteria) *MetricAlertMultipleResourceMultipleMetricCriteria {
		return &it
	}) // generate one case for OneOf type
	gens["MicrosoftAzureMonitorSingleResourceMultipleMetric"] = MetricAlertSingleResourceMultipleMetricCriteriaGenerator().Map(func(it MetricAlertSingleResourceMultipleMetricCriteria) *MetricAlertSingleResourceMultipleMetricCriteria {
		return &it
	}) // generate one case for OneOf type
	gens["MicrosoftAzureMonitorWebtestLocationAvailability"] = WebtestLocationAvailabilityCriteriaGenerator().Map(func(it WebtestLocationAvailabilityCriteria) *WebtestLocationAvailabilityCriteria {
		return &it
	}) // generate one case for OneOf type
}

func Test_MetricAlertCriteria_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MetricAlertCriteria_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMetricAlertCriteria_STATUS, MetricAlertCriteria_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMetricAlertCriteria_STATUS runs a test to see if a specific instance of MetricAlertCriteria_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForMetricAlertCriteria_STATUS(subject MetricAlertCriteria_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MetricAlertCriteria_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MetricAlertCriteria_STATUS instances for property testing - lazily instantiated by
// MetricAlertCriteria_STATUSGenerator()
var metricAlertCriteria_STATUSGenerator gopter.Gen

// MetricAlertCriteria_STATUSGenerator returns a generator of MetricAlertCriteria_STATUS instances for property testing.
func MetricAlertCriteria_STATUSGenerator() gopter.Gen {
	if metricAlertCriteria_STATUSGenerator != nil {
		return metricAlertCriteria_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForMetricAlertCriteria_STATUS(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(MetricAlertCriteria_STATUS{}), map[string]gopter.Gen{propName: propGen}))
	}
	metricAlertCriteria_STATUSGenerator = gen.OneGenOf(gens...)

	return metricAlertCriteria_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForMetricAlertCriteria_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMetricAlertCriteria_STATUS(gens map[string]gopter.Gen) {
	gens["MicrosoftAzureMonitorMultipleResourceMultipleMetric"] = MetricAlertMultipleResourceMultipleMetricCriteria_STATUSGenerator().Map(func(it MetricAlertMultipleResourceMultipleMetricCriteria_STATUS) *MetricAlertMultipleResourceMultipleMetricCriteria_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["MicrosoftAzureMonitorSingleResourceMultipleMetric"] = MetricAlertSingleResourceMultipleMetricCriteria_STATUSGenerator().Map(func(it MetricAlertSingleResourceMultipleMetricCriteria_STATUS) *MetricAlertSingleResourceMultipleMetricCriteria_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["MicrosoftAzureMonitorWebtestLocationAvailability"] = WebtestLocationAvailabilityCriteria_STATUSGenerator().Map(func(it WebtestLocationAvailabilityCriteria_STATUS) *WebtestLocationAvailabilityCriteria_STATUS {
		return &it
	}) // generate one case for OneOf type
}

func Test_MetricAlertMultipleResourceMultipleMetricCriteria_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MetricAlertMultipleResourceMultipleMetricCriteria via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMetricAlertMultipleResourceMultipleMetricCriteria, MetricAlertMultipleResourceMultipleMetricCriteriaGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMetricAlertMultipleResourceMultipleMetricCriteria runs a test to see if a specific instance of MetricAlertMultipleResourceMultipleMetricCriteria round trips to JSON and back losslessly
func RunJSONSerializationTestForMetricAlertMultipleResourceMultipleMetricCriteria(subject MetricAlertMultipleResourceMultipleMetricCriteria) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MetricAlertMultipleResourceMultipleMetricCriteria
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MetricAlertMultipleResourceMultipleMetricCriteria instances for property testing - lazily instantiated
// by MetricAlertMultipleResourceMultipleMetricCriteriaGenerator()
var metricAlertMultipleResourceMultipleMetricCriteriaGenerator gopter.Gen

// MetricAlertMultipleResourceMultipleMetricCriteriaGenerator returns a generator of MetricAlertMultipleResourceMultipleMetricCriteria instances for property testing.
// We first initialize metricAlertMultipleResourceMultipleMetricCriteriaGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func MetricAlertMultipleResourceMultipleMetricCriteriaGenerator() gopter.Gen {
	if metricAlertMultipleResourceMultipleMetricCriteriaGenerator != nil {
		return metricAlertMultipleResourceMultipleMetricCriteriaGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricAlertMultipleResourceMultipleMetricCriteria(generators)
	metricAlertMultipleResourceMultipleMetricCriteriaGenerator = gen.Struct(reflect.TypeOf(MetricAlertMultipleResourceMultipleMetricCriteria{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricAlertMultipleResourceMultipleMetricCriteria(generators)
	AddRelatedPropertyGeneratorsForMetricAlertMultipleResourceMultipleMetricCriteria(generators)
	metricAlertMultipleResourceMultipleMetricCriteriaGenerator = gen.Struct(reflect.TypeOf(MetricAlertMultipleResourceMultipleMetricCriteria{}), generators)

	return metricAlertMultipleResourceMultipleMetricCriteriaGenerator
}

// AddIndependentPropertyGeneratorsForMetricAlertMultipleResourceMultipleMetricCriteria is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMetricAlertMultipleResourceMultipleMetricCriteria(gens map[string]gopter.Gen) {
	gens["OdataType"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForMetricAlertMultipleResourceMultipleMetricCriteria is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMetricAlertMultipleResourceMultipleMetricCriteria(gens map[string]gopter.Gen) {
	gens["AllOf"] = gen.SliceOf(MultiMetricCriteriaGenerator())
}

func Test_MetricAlertMultipleResourceMultipleMetricCriteria_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MetricAlertMultipleResourceMultipleMetricCriteria_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMetricAlertMultipleResourceMultipleMetricCriteria_STATUS, MetricAlertMultipleResourceMultipleMetricCriteria_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMetricAlertMultipleResourceMultipleMetricCriteria_STATUS runs a test to see if a specific instance of MetricAlertMultipleResourceMultipleMetricCriteria_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForMetricAlertMultipleResourceMultipleMetricCriteria_STATUS(subject MetricAlertMultipleResourceMultipleMetricCriteria_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MetricAlertMultipleResourceMultipleMetricCriteria_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MetricAlertMultipleResourceMultipleMetricCriteria_STATUS instances for property testing - lazily
// instantiated by MetricAlertMultipleResourceMultipleMetricCriteria_STATUSGenerator()
var metricAlertMultipleResourceMultipleMetricCriteria_STATUSGenerator gopter.Gen

// MetricAlertMultipleResourceMultipleMetricCriteria_STATUSGenerator returns a generator of MetricAlertMultipleResourceMultipleMetricCriteria_STATUS instances for property testing.
// We first initialize metricAlertMultipleResourceMultipleMetricCriteria_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func MetricAlertMultipleResourceMultipleMetricCriteria_STATUSGenerator() gopter.Gen {
	if metricAlertMultipleResourceMultipleMetricCriteria_STATUSGenerator != nil {
		return metricAlertMultipleResourceMultipleMetricCriteria_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricAlertMultipleResourceMultipleMetricCriteria_STATUS(generators)
	metricAlertMultipleResourceMultipleMetricCriteria_STATUSGenerator = gen.Struct(reflect.TypeOf(MetricAlertMultipleResourceMultipleMetricCriteria_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricAlertMultipleResourceMultipleMetricCriteria_STATUS(generators)
	AddRelatedPropertyGeneratorsForMetricAlertMultipleResourceMultipleMetricCriteria_STATUS(generators)
	metricAlertMultipleResourceMultipleMetricCriteria_STATUSGenerator = gen.Struct(reflect.TypeOf(MetricAlertMultipleResourceMultipleMetricCriteria_STATUS{}), generators)

	return metricAlertMultipleResourceMultipleMetricCriteria_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForMetricAlertMultipleResourceMultipleMetricCriteria_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMetricAlertMultipleResourceMultipleMetricCriteria_STATUS(gens map[string]gopter.Gen) {
	gens["OdataType"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForMetricAlertMultipleResourceMultipleMetricCriteria_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMetricAlertMultipleResourceMultipleMetricCriteria_STATUS(gens map[string]gopter.Gen) {
	gens["AllOf"] = gen.SliceOf(MultiMetricCriteria_STATUSGenerator())
}

func Test_MetricAlertSingleResourceMultipleMetricCriteria_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MetricAlertSingleResourceMultipleMetricCriteria via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMetricAlertSingleResourceMultipleMetricCriteria, MetricAlertSingleResourceMultipleMetricCriteriaGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMetricAlertSingleResourceMultipleMetricCriteria runs a test to see if a specific instance of MetricAlertSingleResourceMultipleMetricCriteria round trips to JSON and back losslessly
func RunJSONSerializationTestForMetricAlertSingleResourceMultipleMetricCriteria(subject MetricAlertSingleResourceMultipleMetricCriteria) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MetricAlertSingleResourceMultipleMetricCriteria
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MetricAlertSingleResourceMultipleMetricCriteria instances for property testing - lazily instantiated by
// MetricAlertSingleResourceMultipleMetricCriteriaGenerator()
var metricAlertSingleResourceMultipleMetricCriteriaGenerator gopter.Gen

// MetricAlertSingleResourceMultipleMetricCriteriaGenerator returns a generator of MetricAlertSingleResourceMultipleMetricCriteria instances for property testing.
// We first initialize metricAlertSingleResourceMultipleMetricCriteriaGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func MetricAlertSingleResourceMultipleMetricCriteriaGenerator() gopter.Gen {
	if metricAlertSingleResourceMultipleMetricCriteriaGenerator != nil {
		return metricAlertSingleResourceMultipleMetricCriteriaGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricAlertSingleResourceMultipleMetricCriteria(generators)
	metricAlertSingleResourceMultipleMetricCriteriaGenerator = gen.Struct(reflect.TypeOf(MetricAlertSingleResourceMultipleMetricCriteria{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricAlertSingleResourceMultipleMetricCriteria(generators)
	AddRelatedPropertyGeneratorsForMetricAlertSingleResourceMultipleMetricCriteria(generators)
	metricAlertSingleResourceMultipleMetricCriteriaGenerator = gen.Struct(reflect.TypeOf(MetricAlertSingleResourceMultipleMetricCriteria{}), generators)

	return metricAlertSingleResourceMultipleMetricCriteriaGenerator
}

// AddIndependentPropertyGeneratorsForMetricAlertSingleResourceMultipleMetricCriteria is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMetricAlertSingleResourceMultipleMetricCriteria(gens map[string]gopter.Gen) {
	gens["OdataType"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForMetricAlertSingleResourceMultipleMetricCriteria is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMetricAlertSingleResourceMultipleMetricCriteria(gens map[string]gopter.Gen) {
	gens["AllOf"] = gen.SliceOf(MetricCriteriaGenerator())
}

func Test_MetricAlertSingleResourceMultipleMetricCriteria_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MetricAlertSingleResourceMultipleMetricCriteria_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMetricAlertSingleResourceMultipleMetricCriteria_STATUS, MetricAlertSingleResourceMultipleMetricCriteria_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMetricAlertSingleResourceMultipleMetricCriteria_STATUS runs a test to see if a specific instance of MetricAlertSingleResourceMultipleMetricCriteria_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForMetricAlertSingleResourceMultipleMetricCriteria_STATUS(subject MetricAlertSingleResourceMultipleMetricCriteria_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MetricAlertSingleResourceMultipleMetricCriteria_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MetricAlertSingleResourceMultipleMetricCriteria_STATUS instances for property testing - lazily
// instantiated by MetricAlertSingleResourceMultipleMetricCriteria_STATUSGenerator()
var metricAlertSingleResourceMultipleMetricCriteria_STATUSGenerator gopter.Gen

// MetricAlertSingleResourceMultipleMetricCriteria_STATUSGenerator returns a generator of MetricAlertSingleResourceMultipleMetricCriteria_STATUS instances for property testing.
// We first initialize metricAlertSingleResourceMultipleMetricCriteria_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func MetricAlertSingleResourceMultipleMetricCriteria_STATUSGenerator() gopter.Gen {
	if metricAlertSingleResourceMultipleMetricCriteria_STATUSGenerator != nil {
		return metricAlertSingleResourceMultipleMetricCriteria_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricAlertSingleResourceMultipleMetricCriteria_STATUS(generators)
	metricAlertSingleResourceMultipleMetricCriteria_STATUSGenerator = gen.Struct(reflect.TypeOf(MetricAlertSingleResourceMultipleMetricCriteria_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricAlertSingleResourceMultipleMetricCriteria_STATUS(generators)
	AddRelatedPropertyGeneratorsForMetricAlertSingleResourceMultipleMetricCriteria_STATUS(generators)
	metricAlertSingleResourceMultipleMetricCriteria_STATUSGenerator = gen.Struct(reflect.TypeOf(MetricAlertSingleResourceMultipleMetricCriteria_STATUS{}), generators)

	return metricAlertSingleResourceMultipleMetricCriteria_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForMetricAlertSingleResourceMultipleMetricCriteria_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMetricAlertSingleResourceMultipleMetricCriteria_STATUS(gens map[string]gopter.Gen) {
	gens["OdataType"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForMetricAlertSingleResourceMultipleMetricCriteria_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMetricAlertSingleResourceMultipleMetricCriteria_STATUS(gens map[string]gopter.Gen) {
	gens["AllOf"] = gen.SliceOf(MetricCriteria_STATUSGenerator())
}

func Test_MetricAlert_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MetricAlert_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMetricAlert_STATUS, MetricAlert_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMetricAlert_STATUS runs a test to see if a specific instance of MetricAlert_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForMetricAlert_STATUS(subject MetricAlert_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MetricAlert_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MetricAlert_STATUS instances for property testing - lazily instantiated by MetricAlert_STATUSGenerator()
var metricAlert_STATUSGenerator gopter.Gen

// MetricAlert_STATUSGenerator returns a generator of MetricAlert_STATUS instances for property testing.
// We first initialize metricAlert_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func MetricAlert_STATUSGenerator() gopter.Gen {
	if metricAlert_STATUSGenerator != nil {
		return metricAlert_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricAlert_STATUS(generators)
	metricAlert_STATUSGenerator = gen.Struct(reflect.TypeOf(MetricAlert_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricAlert_STATUS(generators)
	AddRelatedPropertyGeneratorsForMetricAlert_STATUS(generators)
	metricAlert_STATUSGenerator = gen.Struct(reflect.TypeOf(MetricAlert_STATUS{}), generators)

	return metricAlert_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForMetricAlert_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMetricAlert_STATUS(gens map[string]gopter.Gen) {
	gens["AutoMitigate"] = gen.PtrOf(gen.Bool())
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["EvaluationFrequency"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IsMigrated"] = gen.PtrOf(gen.Bool())
	gens["LastUpdatedTime"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Scopes"] = gen.SliceOf(gen.AlphaString())
	gens["Severity"] = gen.PtrOf(gen.Int())
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["TargetResourceRegion"] = gen.PtrOf(gen.AlphaString())
	gens["TargetResourceType"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["WindowSize"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForMetricAlert_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMetricAlert_STATUS(gens map[string]gopter.Gen) {
	gens["Actions"] = gen.SliceOf(MetricAlertAction_STATUSGenerator())
	gens["Criteria"] = gen.PtrOf(MetricAlertCriteria_STATUSGenerator())
}

func Test_MetricAlert_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MetricAlert_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMetricAlert_Spec, MetricAlert_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMetricAlert_Spec runs a test to see if a specific instance of MetricAlert_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForMetricAlert_Spec(subject MetricAlert_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MetricAlert_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MetricAlert_Spec instances for property testing - lazily instantiated by MetricAlert_SpecGenerator()
var metricAlert_SpecGenerator gopter.Gen

// MetricAlert_SpecGenerator returns a generator of MetricAlert_Spec instances for property testing.
// We first initialize metricAlert_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func MetricAlert_SpecGenerator() gopter.Gen {
	if metricAlert_SpecGenerator != nil {
		return metricAlert_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricAlert_Spec(generators)
	metricAlert_SpecGenerator = gen.Struct(reflect.TypeOf(MetricAlert_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricAlert_Spec(generators)
	AddRelatedPropertyGeneratorsForMetricAlert_Spec(generators)
	metricAlert_SpecGenerator = gen.Struct(reflect.TypeOf(MetricAlert_Spec{}), generators)

	return metricAlert_SpecGenerator
}

// AddIndependentPropertyGeneratorsForMetricAlert_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMetricAlert_Spec(gens map[string]gopter.Gen) {
	gens["AutoMitigate"] = gen.PtrOf(gen.Bool())
	gens["AzureName"] = gen.AlphaString()
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["EvaluationFrequency"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["OriginalVersion"] = gen.AlphaString()
	gens["Severity"] = gen.PtrOf(gen.Int())
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["TargetResourceRegion"] = gen.PtrOf(gen.AlphaString())
	gens["TargetResourceType"] = gen.PtrOf(gen.AlphaString())
	gens["WindowSize"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForMetricAlert_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMetricAlert_Spec(gens map[string]gopter.Gen) {
	gens["Actions"] = gen.SliceOf(MetricAlertActionGenerator())
	gens["Criteria"] = gen.PtrOf(MetricAlertCriteriaGenerator())
}

func Test_MetricCriteria_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MetricCriteria via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMetricCriteria, MetricCriteriaGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMetricCriteria runs a test to see if a specific instance of MetricCriteria round trips to JSON and back losslessly
func RunJSONSerializationTestForMetricCriteria(subject MetricCriteria) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MetricCriteria
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MetricCriteria instances for property testing - lazily instantiated by MetricCriteriaGenerator()
var metricCriteriaGenerator gopter.Gen

// MetricCriteriaGenerator returns a generator of MetricCriteria instances for property testing.
// We first initialize metricCriteriaGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func MetricCriteriaGenerator() gopter.Gen {
	if metricCriteriaGenerator != nil {
		return metricCriteriaGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricCriteria(generators)
	metricCriteriaGenerator = gen.Struct(reflect.TypeOf(MetricCriteria{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricCriteria(generators)
	AddRelatedPropertyGeneratorsForMetricCriteria(generators)
	metricCriteriaGenerator = gen.Struct(reflect.TypeOf(MetricCriteria{}), generators)

	return metricCriteriaGenerator
}

// AddIndependentPropertyGeneratorsForMetricCriteria is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMetricCriteria(gens map[string]gopter.Gen) {
	gens["CriterionType"] = gen.PtrOf(gen.AlphaString())
	gens["MetricName"] = gen.PtrOf(gen.AlphaString())
	gens["MetricNamespace"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Operator"] = gen.PtrOf(gen.AlphaString())
	gens["SkipMetricValidation"] = gen.PtrOf(gen.Bool())
	gens["Threshold"] = gen.PtrOf(gen.Float64())
	gens["TimeAggregation"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForMetricCriteria is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMetricCriteria(gens map[string]gopter.Gen) {
	gens["Dimensions"] = gen.SliceOf(MetricDimensionGenerator())
}

func Test_MetricCriteria_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MetricCriteria_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMetricCriteria_STATUS, MetricCriteria_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMetricCriteria_STATUS runs a test to see if a specific instance of MetricCriteria_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForMetricCriteria_STATUS(subject MetricCriteria_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MetricCriteria_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MetricCriteria_STATUS instances for property testing - lazily instantiated by
// MetricCriteria_STATUSGenerator()
var metricCriteria_STATUSGenerator gopter.Gen

// MetricCriteria_STATUSGenerator returns a generator of MetricCriteria_STATUS instances for property testing.
// We first initialize metricCriteria_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func MetricCriteria_STATUSGenerator() gopter.Gen {
	if metricCriteria_STATUSGenerator != nil {
		return metricCriteria_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricCriteria_STATUS(generators)
	metricCriteria_STATUSGenerator = gen.Struct(reflect.TypeOf(MetricCriteria_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricCriteria_STATUS(generators)
	AddRelatedPropertyGeneratorsForMetricCriteria_STATUS(generators)
	metricCriteria_STATUSGenerator = gen.Struct(reflect.TypeOf(MetricCriteria_STATUS{}), generators)

	return metricCriteria_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForMetricCriteria_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMetricCriteria_STATUS(gens map[string]gopter.Gen) {
	gens["CriterionType"] = gen.PtrOf(gen.AlphaString())
	gens["MetricName"] = gen.PtrOf(gen.AlphaString())
	gens["MetricNamespace"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Operator"] = gen.PtrOf(gen.AlphaString())
	gens["SkipMetricValidation"] = gen.PtrOf(gen.Bool())
	gens["Threshold"] = gen.PtrOf(gen.Float64())
	gens["TimeAggregation"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForMetricCriteria_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMetricCriteria_STATUS(gens map[string]gopter.Gen) {
	gens["Dimensions"] = gen.SliceOf(MetricDimension_STATUSGenerator())
}

func Test_MetricDimension_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MetricDimension via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMetricDimension, MetricDimensionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMetricDimension runs a test to see if a specific instance of MetricDimension round trips to JSON and back losslessly
func RunJSONSerializationTestForMetricDimension(subject MetricDimension) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MetricDimension
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MetricDimension instances for property testing - lazily instantiated by MetricDimensionGenerator()
var metricDimensionGenerator gopter.Gen

// MetricDimensionGenerator returns a generator of MetricDimension instances for property testing.
func MetricDimensionGenerator() gopter.Gen {
	if metricDimensionGenerator != nil {
		return metricDimensionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricDimension(generators)
	metricDimensionGenerator = gen.Struct(reflect.TypeOf(MetricDimension{}), generators)

	return metricDimensionGenerator
}

// AddIndependentPropertyGeneratorsForMetricDimension is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMetricDimension(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Operator"] = gen.PtrOf(gen.AlphaString())
	gens["Values"] = gen.SliceOf(gen.AlphaString())
}

func Test_MetricDimension_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MetricDimension_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMetricDimension_STATUS, MetricDimension_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMetricDimension_STATUS runs a test to see if a specific instance of MetricDimension_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForMetricDimension_STATUS(subject MetricDimension_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MetricDimension_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MetricDimension_STATUS instances for property testing - lazily instantiated by
// MetricDimension_STATUSGenerator()
var metricDimension_STATUSGenerator gopter.Gen

// MetricDimension_STATUSGenerator returns a generator of MetricDimension_STATUS instances for property testing.
func MetricDimension_STATUSGenerator() gopter.Gen {
	if metricDimension_STATUSGenerator != nil {
		return metricDimension_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricDimension_STATUS(generators)
	metricDimension_STATUSGenerator = gen.Struct(reflect.TypeOf(MetricDimension_STATUS{}), generators)

	return metricDimension_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForMetricDimension_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMetricDimension_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Operator"] = gen.PtrOf(gen.AlphaString())
	gens["Values"] = gen.SliceOf(gen.AlphaString())
}

func Test_MultiMetricCriteria_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MultiMetricCriteria via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMultiMetricCriteria, MultiMetricCriteriaGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMultiMetricCriteria runs a test to see if a specific instance of MultiMetricCriteria round trips to JSON and back losslessly
func RunJSONSerializationTestForMultiMetricCriteria(subject MultiMetricCriteria) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MultiMetricCriteria
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MultiMetricCriteria instances for property testing - lazily instantiated by
// MultiMetricCriteriaGenerator()
var multiMetricCriteriaGenerator gopter.Gen

// MultiMetricCriteriaGenerator returns a generator of MultiMetricCriteria instances for property testing.
func MultiMetricCriteriaGenerator() gopter.Gen {
	if multiMetricCriteriaGenerator != nil {
		return multiMetricCriteriaGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForMultiMetricCriteria(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(MultiMetricCriteria{}), map[string]gopter.Gen{propName: propGen}))
	}
	multiMetricCriteriaGenerator = gen.OneGenOf(gens...)

	return multiMetricCriteriaGenerator
}

// AddRelatedPropertyGeneratorsForMultiMetricCriteria is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMultiMetricCriteria(gens map[string]gopter.Gen) {
	gens["Dynamic"] = DynamicMetricCriteriaGenerator().Map(func(it DynamicMetricCriteria) *DynamicMetricCriteria {
		return &it
	}) // generate one case for OneOf type
	gens["Static"] = MetricCriteriaGenerator().Map(func(it MetricCriteria) *MetricCriteria {
		return &it
	}) // generate one case for OneOf type
}

func Test_MultiMetricCriteria_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MultiMetricCriteria_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMultiMetricCriteria_STATUS, MultiMetricCriteria_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMultiMetricCriteria_STATUS runs a test to see if a specific instance of MultiMetricCriteria_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForMultiMetricCriteria_STATUS(subject MultiMetricCriteria_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MultiMetricCriteria_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MultiMetricCriteria_STATUS instances for property testing - lazily instantiated by
// MultiMetricCriteria_STATUSGenerator()
var multiMetricCriteria_STATUSGenerator gopter.Gen

// MultiMetricCriteria_STATUSGenerator returns a generator of MultiMetricCriteria_STATUS instances for property testing.
func MultiMetricCriteria_STATUSGenerator() gopter.Gen {
	if multiMetricCriteria_STATUSGenerator != nil {
		return multiMetricCriteria_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForMultiMetricCriteria_STATUS(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(MultiMetricCriteria_STATUS{}), map[string]gopter.Gen{propName: propGen}))
	}
	multiMetricCriteria_STATUSGenerator = gen.OneGenOf(gens...)

	return multiMetricCriteria_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForMultiMetricCriteria_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMultiMetricCriteria_STATUS(gens map[string]gopter.Gen) {
	gens["Dynamic"] = DynamicMetricCriteria_STATUSGenerator().Map(func(it DynamicMetricCriteria_STATUS) *DynamicMetricCriteria_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["Static"] = MetricCriteria_STATUSGenerator().Map(func(it MetricCriteria_STATUS) *MetricCriteria_STATUS {
		return &it
	}) // generate one case for OneOf type
}

func Test_WebtestLocationAvailabilityCriteria_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebtestLocationAvailabilityCriteria via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebtestLocationAvailabilityCriteria, WebtestLocationAvailabilityCriteriaGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebtestLocationAvailabilityCriteria runs a test to see if a specific instance of WebtestLocationAvailabilityCriteria round trips to JSON and back losslessly
func RunJSONSerializationTestForWebtestLocationAvailabilityCriteria(subject WebtestLocationAvailabilityCriteria) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebtestLocationAvailabilityCriteria
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebtestLocationAvailabilityCriteria instances for property testing - lazily instantiated by
// WebtestLocationAvailabilityCriteriaGenerator()
var webtestLocationAvailabilityCriteriaGenerator gopter.Gen

// WebtestLocationAvailabilityCriteriaGenerator returns a generator of WebtestLocationAvailabilityCriteria instances for property testing.
func WebtestLocationAvailabilityCriteriaGenerator() gopter.Gen {
	if webtestLocationAvailabilityCriteriaGenerator != nil {
		return webtestLocationAvailabilityCriteriaGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebtestLocationAvailabilityCriteria(generators)
	webtestLocationAvailabilityCriteriaGenerator = gen.Struct(reflect.TypeOf(WebtestLocationAvailabilityCriteria{}), generators)

	return webtestLocationAvailabilityCriteriaGenerator
}

// AddIndependentPropertyGeneratorsForWebtestLocationAvailabilityCriteria is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebtestLocationAvailabilityCriteria(gens map[string]gopter.Gen) {
	gens["FailedLocationCount"] = gen.PtrOf(gen.Float64())
	gens["OdataType"] = gen.PtrOf(gen.AlphaString())
	gens["WebTestId"] = gen.PtrOf(gen.AlphaString())
}

func Test_WebtestLocationAvailabilityCriteria_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebtestLocationAvailabilityCriteria_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebtestLocationAvailabilityCriteria_STATUS, WebtestLocationAvailabilityCriteria_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebtestLocationAvailabilityCriteria_STATUS runs a test to see if a specific instance of WebtestLocationAvailabilityCriteria_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForWebtestLocationAvailabilityCriteria_STATUS(subject WebtestLocationAvailabilityCriteria_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebtestLocationAvailabilityCriteria_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebtestLocationAvailabilityCriteria_STATUS instances for property testing - lazily instantiated by
// WebtestLocationAvailabilityCriteria_STATUSGenerator()
var webtestLocationAvailabilityCriteria_STATUSGenerator gopter.Gen

// WebtestLocationAvailabilityCriteria_STATUSGenerator returns a generator of WebtestLocationAvailabilityCriteria_STATUS instances for property testing.
func WebtestLocationAvailabilityCriteria_STATUSGenerator() gopter.Gen {
	if webtestLocationAvailabilityCriteria_STATUSGenerator != nil {
		return webtestLocationAvailabilityCriteria_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebtestLocationAvailabilityCriteria_STATUS(generators)
	webtestLocationAvailabilityCriteria_STATUSGenerator = gen.Struct(reflect.TypeOf(WebtestLocationAvailabilityCriteria_STATUS{}), generators)

	return webtestLocationAvailabilityCriteria_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForWebtestLocationAvailabilityCriteria_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebtestLocationAvailabilityCriteria_STATUS(gens map[string]gopter.Gen) {
	gens["ComponentId"] = gen.PtrOf(gen.AlphaString())
	gens["FailedLocationCount"] = gen.PtrOf(gen.Float64())
	gens["OdataType"] = gen.PtrOf(gen.AlphaString())
	gens["WebTestId"] = gen.PtrOf(gen.AlphaString())
}
