// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20180301

import (
	"encoding/json"
	storage "github.com/Azure/azure-service-operator/v2/api/insights/v1api20180301/storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_DynamicMetricCriteria_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DynamicMetricCriteria to DynamicMetricCriteria via AssignProperties_To_DynamicMetricCriteria & AssignProperties_From_DynamicMetricCriteria returns original",
		prop.ForAll(RunPropertyAssignmentTestForDynamicMetricCriteria, DynamicMetricCriteriaGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDynamicMetricCriteria tests if a specific instance of DynamicMetricCriteria can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForDynamicMetricCriteria(subject DynamicMetricCriteria) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.DynamicMetricCriteria
	err := copied.AssignProperties_To_DynamicMetricCriteria(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DynamicMetricCriteria
	err = actual.AssignProperties_From_DynamicMetricCriteria(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DynamicMetricCriteria_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DynamicMetricCriteria via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDynamicMetricCriteria, DynamicMetricCriteriaGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDynamicMetricCriteria runs a test to see if a specific instance of DynamicMetricCriteria round trips to JSON and back losslessly
func RunJSONSerializationTestForDynamicMetricCriteria(subject DynamicMetricCriteria) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DynamicMetricCriteria
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DynamicMetricCriteria instances for property testing - lazily instantiated by
// DynamicMetricCriteriaGenerator()
var dynamicMetricCriteriaGenerator gopter.Gen

// DynamicMetricCriteriaGenerator returns a generator of DynamicMetricCriteria instances for property testing.
// We first initialize dynamicMetricCriteriaGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DynamicMetricCriteriaGenerator() gopter.Gen {
	if dynamicMetricCriteriaGenerator != nil {
		return dynamicMetricCriteriaGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDynamicMetricCriteria(generators)
	dynamicMetricCriteriaGenerator = gen.Struct(reflect.TypeOf(DynamicMetricCriteria{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDynamicMetricCriteria(generators)
	AddRelatedPropertyGeneratorsForDynamicMetricCriteria(generators)
	dynamicMetricCriteriaGenerator = gen.Struct(reflect.TypeOf(DynamicMetricCriteria{}), generators)

	return dynamicMetricCriteriaGenerator
}

// AddIndependentPropertyGeneratorsForDynamicMetricCriteria is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDynamicMetricCriteria(gens map[string]gopter.Gen) {
	gens["AlertSensitivity"] = gen.PtrOf(gen.OneConstOf(DynamicMetricCriteria_AlertSensitivity_High, DynamicMetricCriteria_AlertSensitivity_Low, DynamicMetricCriteria_AlertSensitivity_Medium))
	gens["CriterionType"] = gen.PtrOf(gen.OneConstOf(DynamicMetricCriteria_CriterionType_DynamicThresholdCriterion))
	gens["IgnoreDataBefore"] = gen.PtrOf(gen.AlphaString())
	gens["MetricName"] = gen.PtrOf(gen.AlphaString())
	gens["MetricNamespace"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(DynamicMetricCriteria_Operator_GreaterOrLessThan, DynamicMetricCriteria_Operator_GreaterThan, DynamicMetricCriteria_Operator_LessThan))
	gens["SkipMetricValidation"] = gen.PtrOf(gen.Bool())
	gens["TimeAggregation"] = gen.PtrOf(gen.OneConstOf(
		DynamicMetricCriteria_TimeAggregation_Average,
		DynamicMetricCriteria_TimeAggregation_Count,
		DynamicMetricCriteria_TimeAggregation_Maximum,
		DynamicMetricCriteria_TimeAggregation_Minimum,
		DynamicMetricCriteria_TimeAggregation_Total))
}

// AddRelatedPropertyGeneratorsForDynamicMetricCriteria is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDynamicMetricCriteria(gens map[string]gopter.Gen) {
	gens["Dimensions"] = gen.SliceOf(MetricDimensionGenerator())
	gens["FailingPeriods"] = gen.PtrOf(DynamicThresholdFailingPeriodsGenerator())
}

func Test_DynamicMetricCriteria_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DynamicMetricCriteria_STATUS to DynamicMetricCriteria_STATUS via AssignProperties_To_DynamicMetricCriteria_STATUS & AssignProperties_From_DynamicMetricCriteria_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDynamicMetricCriteria_STATUS, DynamicMetricCriteria_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDynamicMetricCriteria_STATUS tests if a specific instance of DynamicMetricCriteria_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForDynamicMetricCriteria_STATUS(subject DynamicMetricCriteria_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.DynamicMetricCriteria_STATUS
	err := copied.AssignProperties_To_DynamicMetricCriteria_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DynamicMetricCriteria_STATUS
	err = actual.AssignProperties_From_DynamicMetricCriteria_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DynamicMetricCriteria_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DynamicMetricCriteria_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDynamicMetricCriteria_STATUS, DynamicMetricCriteria_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDynamicMetricCriteria_STATUS runs a test to see if a specific instance of DynamicMetricCriteria_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDynamicMetricCriteria_STATUS(subject DynamicMetricCriteria_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DynamicMetricCriteria_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DynamicMetricCriteria_STATUS instances for property testing - lazily instantiated by
// DynamicMetricCriteria_STATUSGenerator()
var dynamicMetricCriteria_STATUSGenerator gopter.Gen

// DynamicMetricCriteria_STATUSGenerator returns a generator of DynamicMetricCriteria_STATUS instances for property testing.
// We first initialize dynamicMetricCriteria_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DynamicMetricCriteria_STATUSGenerator() gopter.Gen {
	if dynamicMetricCriteria_STATUSGenerator != nil {
		return dynamicMetricCriteria_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDynamicMetricCriteria_STATUS(generators)
	dynamicMetricCriteria_STATUSGenerator = gen.Struct(reflect.TypeOf(DynamicMetricCriteria_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDynamicMetricCriteria_STATUS(generators)
	AddRelatedPropertyGeneratorsForDynamicMetricCriteria_STATUS(generators)
	dynamicMetricCriteria_STATUSGenerator = gen.Struct(reflect.TypeOf(DynamicMetricCriteria_STATUS{}), generators)

	return dynamicMetricCriteria_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDynamicMetricCriteria_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDynamicMetricCriteria_STATUS(gens map[string]gopter.Gen) {
	gens["AlertSensitivity"] = gen.PtrOf(gen.OneConstOf(DynamicMetricCriteria_AlertSensitivity_STATUS_High, DynamicMetricCriteria_AlertSensitivity_STATUS_Low, DynamicMetricCriteria_AlertSensitivity_STATUS_Medium))
	gens["CriterionType"] = gen.PtrOf(gen.OneConstOf(DynamicMetricCriteria_CriterionType_STATUS_DynamicThresholdCriterion))
	gens["IgnoreDataBefore"] = gen.PtrOf(gen.AlphaString())
	gens["MetricName"] = gen.PtrOf(gen.AlphaString())
	gens["MetricNamespace"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(DynamicMetricCriteria_Operator_STATUS_GreaterOrLessThan, DynamicMetricCriteria_Operator_STATUS_GreaterThan, DynamicMetricCriteria_Operator_STATUS_LessThan))
	gens["SkipMetricValidation"] = gen.PtrOf(gen.Bool())
	gens["TimeAggregation"] = gen.PtrOf(gen.OneConstOf(
		DynamicMetricCriteria_TimeAggregation_STATUS_Average,
		DynamicMetricCriteria_TimeAggregation_STATUS_Count,
		DynamicMetricCriteria_TimeAggregation_STATUS_Maximum,
		DynamicMetricCriteria_TimeAggregation_STATUS_Minimum,
		DynamicMetricCriteria_TimeAggregation_STATUS_Total))
}

// AddRelatedPropertyGeneratorsForDynamicMetricCriteria_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDynamicMetricCriteria_STATUS(gens map[string]gopter.Gen) {
	gens["Dimensions"] = gen.SliceOf(MetricDimension_STATUSGenerator())
	gens["FailingPeriods"] = gen.PtrOf(DynamicThresholdFailingPeriods_STATUSGenerator())
}

func Test_DynamicThresholdFailingPeriods_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DynamicThresholdFailingPeriods to DynamicThresholdFailingPeriods via AssignProperties_To_DynamicThresholdFailingPeriods & AssignProperties_From_DynamicThresholdFailingPeriods returns original",
		prop.ForAll(RunPropertyAssignmentTestForDynamicThresholdFailingPeriods, DynamicThresholdFailingPeriodsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDynamicThresholdFailingPeriods tests if a specific instance of DynamicThresholdFailingPeriods can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForDynamicThresholdFailingPeriods(subject DynamicThresholdFailingPeriods) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.DynamicThresholdFailingPeriods
	err := copied.AssignProperties_To_DynamicThresholdFailingPeriods(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DynamicThresholdFailingPeriods
	err = actual.AssignProperties_From_DynamicThresholdFailingPeriods(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DynamicThresholdFailingPeriods_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DynamicThresholdFailingPeriods via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDynamicThresholdFailingPeriods, DynamicThresholdFailingPeriodsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDynamicThresholdFailingPeriods runs a test to see if a specific instance of DynamicThresholdFailingPeriods round trips to JSON and back losslessly
func RunJSONSerializationTestForDynamicThresholdFailingPeriods(subject DynamicThresholdFailingPeriods) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DynamicThresholdFailingPeriods
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DynamicThresholdFailingPeriods instances for property testing - lazily instantiated by
// DynamicThresholdFailingPeriodsGenerator()
var dynamicThresholdFailingPeriodsGenerator gopter.Gen

// DynamicThresholdFailingPeriodsGenerator returns a generator of DynamicThresholdFailingPeriods instances for property testing.
func DynamicThresholdFailingPeriodsGenerator() gopter.Gen {
	if dynamicThresholdFailingPeriodsGenerator != nil {
		return dynamicThresholdFailingPeriodsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDynamicThresholdFailingPeriods(generators)
	dynamicThresholdFailingPeriodsGenerator = gen.Struct(reflect.TypeOf(DynamicThresholdFailingPeriods{}), generators)

	return dynamicThresholdFailingPeriodsGenerator
}

// AddIndependentPropertyGeneratorsForDynamicThresholdFailingPeriods is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDynamicThresholdFailingPeriods(gens map[string]gopter.Gen) {
	gens["MinFailingPeriodsToAlert"] = gen.PtrOf(gen.Float64())
	gens["NumberOfEvaluationPeriods"] = gen.PtrOf(gen.Float64())
}

func Test_DynamicThresholdFailingPeriods_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DynamicThresholdFailingPeriods_STATUS to DynamicThresholdFailingPeriods_STATUS via AssignProperties_To_DynamicThresholdFailingPeriods_STATUS & AssignProperties_From_DynamicThresholdFailingPeriods_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDynamicThresholdFailingPeriods_STATUS, DynamicThresholdFailingPeriods_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDynamicThresholdFailingPeriods_STATUS tests if a specific instance of DynamicThresholdFailingPeriods_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForDynamicThresholdFailingPeriods_STATUS(subject DynamicThresholdFailingPeriods_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.DynamicThresholdFailingPeriods_STATUS
	err := copied.AssignProperties_To_DynamicThresholdFailingPeriods_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DynamicThresholdFailingPeriods_STATUS
	err = actual.AssignProperties_From_DynamicThresholdFailingPeriods_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DynamicThresholdFailingPeriods_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DynamicThresholdFailingPeriods_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDynamicThresholdFailingPeriods_STATUS, DynamicThresholdFailingPeriods_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDynamicThresholdFailingPeriods_STATUS runs a test to see if a specific instance of DynamicThresholdFailingPeriods_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDynamicThresholdFailingPeriods_STATUS(subject DynamicThresholdFailingPeriods_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DynamicThresholdFailingPeriods_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DynamicThresholdFailingPeriods_STATUS instances for property testing - lazily instantiated by
// DynamicThresholdFailingPeriods_STATUSGenerator()
var dynamicThresholdFailingPeriods_STATUSGenerator gopter.Gen

// DynamicThresholdFailingPeriods_STATUSGenerator returns a generator of DynamicThresholdFailingPeriods_STATUS instances for property testing.
func DynamicThresholdFailingPeriods_STATUSGenerator() gopter.Gen {
	if dynamicThresholdFailingPeriods_STATUSGenerator != nil {
		return dynamicThresholdFailingPeriods_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDynamicThresholdFailingPeriods_STATUS(generators)
	dynamicThresholdFailingPeriods_STATUSGenerator = gen.Struct(reflect.TypeOf(DynamicThresholdFailingPeriods_STATUS{}), generators)

	return dynamicThresholdFailingPeriods_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDynamicThresholdFailingPeriods_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDynamicThresholdFailingPeriods_STATUS(gens map[string]gopter.Gen) {
	gens["MinFailingPeriodsToAlert"] = gen.PtrOf(gen.Float64())
	gens["NumberOfEvaluationPeriods"] = gen.PtrOf(gen.Float64())
}

func Test_MetricAlert_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	parameters.MinSuccessfulTests = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MetricAlert to hub returns original",
		prop.ForAll(RunResourceConversionTestForMetricAlert, MetricAlertGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForMetricAlert tests if a specific instance of MetricAlert round trips to the hub storage version and back losslessly
func RunResourceConversionTestForMetricAlert(subject MetricAlert) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub storage.MetricAlert
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual MetricAlert
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MetricAlert_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MetricAlert to MetricAlert via AssignProperties_To_MetricAlert & AssignProperties_From_MetricAlert returns original",
		prop.ForAll(RunPropertyAssignmentTestForMetricAlert, MetricAlertGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMetricAlert tests if a specific instance of MetricAlert can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForMetricAlert(subject MetricAlert) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.MetricAlert
	err := copied.AssignProperties_To_MetricAlert(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual MetricAlert
	err = actual.AssignProperties_From_MetricAlert(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MetricAlert_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MetricAlert via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMetricAlert, MetricAlertGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMetricAlert runs a test to see if a specific instance of MetricAlert round trips to JSON and back losslessly
func RunJSONSerializationTestForMetricAlert(subject MetricAlert) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MetricAlert
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MetricAlert instances for property testing - lazily instantiated by MetricAlertGenerator()
var metricAlertGenerator gopter.Gen

// MetricAlertGenerator returns a generator of MetricAlert instances for property testing.
func MetricAlertGenerator() gopter.Gen {
	if metricAlertGenerator != nil {
		return metricAlertGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForMetricAlert(generators)
	metricAlertGenerator = gen.Struct(reflect.TypeOf(MetricAlert{}), generators)

	return metricAlertGenerator
}

// AddRelatedPropertyGeneratorsForMetricAlert is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMetricAlert(gens map[string]gopter.Gen) {
	gens["Spec"] = MetricAlert_SpecGenerator()
	gens["Status"] = MetricAlert_STATUSGenerator()
}

func Test_MetricAlertAction_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MetricAlertAction to MetricAlertAction via AssignProperties_To_MetricAlertAction & AssignProperties_From_MetricAlertAction returns original",
		prop.ForAll(RunPropertyAssignmentTestForMetricAlertAction, MetricAlertActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMetricAlertAction tests if a specific instance of MetricAlertAction can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForMetricAlertAction(subject MetricAlertAction) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.MetricAlertAction
	err := copied.AssignProperties_To_MetricAlertAction(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual MetricAlertAction
	err = actual.AssignProperties_From_MetricAlertAction(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MetricAlertAction_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MetricAlertAction via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMetricAlertAction, MetricAlertActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMetricAlertAction runs a test to see if a specific instance of MetricAlertAction round trips to JSON and back losslessly
func RunJSONSerializationTestForMetricAlertAction(subject MetricAlertAction) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MetricAlertAction
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MetricAlertAction instances for property testing - lazily instantiated by MetricAlertActionGenerator()
var metricAlertActionGenerator gopter.Gen

// MetricAlertActionGenerator returns a generator of MetricAlertAction instances for property testing.
func MetricAlertActionGenerator() gopter.Gen {
	if metricAlertActionGenerator != nil {
		return metricAlertActionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricAlertAction(generators)
	metricAlertActionGenerator = gen.Struct(reflect.TypeOf(MetricAlertAction{}), generators)

	return metricAlertActionGenerator
}

// AddIndependentPropertyGeneratorsForMetricAlertAction is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMetricAlertAction(gens map[string]gopter.Gen) {
	gens["ActionGroupId"] = gen.PtrOf(gen.AlphaString())
	gens["WebHookProperties"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

func Test_MetricAlertAction_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MetricAlertAction_STATUS to MetricAlertAction_STATUS via AssignProperties_To_MetricAlertAction_STATUS & AssignProperties_From_MetricAlertAction_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForMetricAlertAction_STATUS, MetricAlertAction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMetricAlertAction_STATUS tests if a specific instance of MetricAlertAction_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForMetricAlertAction_STATUS(subject MetricAlertAction_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.MetricAlertAction_STATUS
	err := copied.AssignProperties_To_MetricAlertAction_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual MetricAlertAction_STATUS
	err = actual.AssignProperties_From_MetricAlertAction_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MetricAlertAction_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MetricAlertAction_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMetricAlertAction_STATUS, MetricAlertAction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMetricAlertAction_STATUS runs a test to see if a specific instance of MetricAlertAction_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForMetricAlertAction_STATUS(subject MetricAlertAction_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MetricAlertAction_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MetricAlertAction_STATUS instances for property testing - lazily instantiated by
// MetricAlertAction_STATUSGenerator()
var metricAlertAction_STATUSGenerator gopter.Gen

// MetricAlertAction_STATUSGenerator returns a generator of MetricAlertAction_STATUS instances for property testing.
func MetricAlertAction_STATUSGenerator() gopter.Gen {
	if metricAlertAction_STATUSGenerator != nil {
		return metricAlertAction_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricAlertAction_STATUS(generators)
	metricAlertAction_STATUSGenerator = gen.Struct(reflect.TypeOf(MetricAlertAction_STATUS{}), generators)

	return metricAlertAction_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForMetricAlertAction_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMetricAlertAction_STATUS(gens map[string]gopter.Gen) {
	gens["ActionGroupId"] = gen.PtrOf(gen.AlphaString())
	gens["WebHookProperties"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

func Test_MetricAlertCriteria_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MetricAlertCriteria to MetricAlertCriteria via AssignProperties_To_MetricAlertCriteria & AssignProperties_From_MetricAlertCriteria returns original",
		prop.ForAll(RunPropertyAssignmentTestForMetricAlertCriteria, MetricAlertCriteriaGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMetricAlertCriteria tests if a specific instance of MetricAlertCriteria can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForMetricAlertCriteria(subject MetricAlertCriteria) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.MetricAlertCriteria
	err := copied.AssignProperties_To_MetricAlertCriteria(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual MetricAlertCriteria
	err = actual.AssignProperties_From_MetricAlertCriteria(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MetricAlertCriteria_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MetricAlertCriteria via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMetricAlertCriteria, MetricAlertCriteriaGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMetricAlertCriteria runs a test to see if a specific instance of MetricAlertCriteria round trips to JSON and back losslessly
func RunJSONSerializationTestForMetricAlertCriteria(subject MetricAlertCriteria) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MetricAlertCriteria
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MetricAlertCriteria instances for property testing - lazily instantiated by
// MetricAlertCriteriaGenerator()
var metricAlertCriteriaGenerator gopter.Gen

// MetricAlertCriteriaGenerator returns a generator of MetricAlertCriteria instances for property testing.
func MetricAlertCriteriaGenerator() gopter.Gen {
	if metricAlertCriteriaGenerator != nil {
		return metricAlertCriteriaGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForMetricAlertCriteria(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(MetricAlertCriteria{}), map[string]gopter.Gen{propName: propGen}))
	}
	metricAlertCriteriaGenerator = gen.OneGenOf(gens...)

	return metricAlertCriteriaGenerator
}

// AddRelatedPropertyGeneratorsForMetricAlertCriteria is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMetricAlertCriteria(gens map[string]gopter.Gen) {
	gens["MicrosoftAzureMonitorMultipleResourceMultipleMetric"] = MetricAlertMultipleResourceMultipleMetricCriteriaGenerator().Map(func(it MetricAlertMultipleResourceMultipleMetricCriteria) *MetricAlertMultipleResourceMultipleMetricCriteria {
		return &it
	}) // generate one case for OneOf type
	gens["MicrosoftAzureMonitorSingleResourceMultipleMetric"] = MetricAlertSingleResourceMultipleMetricCriteriaGenerator().Map(func(it MetricAlertSingleResourceMultipleMetricCriteria) *MetricAlertSingleResourceMultipleMetricCriteria {
		return &it
	}) // generate one case for OneOf type
	gens["MicrosoftAzureMonitorWebtestLocationAvailability"] = WebtestLocationAvailabilityCriteriaGenerator().Map(func(it WebtestLocationAvailabilityCriteria) *WebtestLocationAvailabilityCriteria {
		return &it
	}) // generate one case for OneOf type
}

func Test_MetricAlertCriteria_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MetricAlertCriteria_STATUS to MetricAlertCriteria_STATUS via AssignProperties_To_MetricAlertCriteria_STATUS & AssignProperties_From_MetricAlertCriteria_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForMetricAlertCriteria_STATUS, MetricAlertCriteria_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMetricAlertCriteria_STATUS tests if a specific instance of MetricAlertCriteria_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForMetricAlertCriteria_STATUS(subject MetricAlertCriteria_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.MetricAlertCriteria_STATUS
	err := copied.AssignProperties_To_MetricAlertCriteria_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual MetricAlertCriteria_STATUS
	err = actual.AssignProperties_From_MetricAlertCriteria_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MetricAlertCriteria_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MetricAlertCriteria_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMetricAlertCriteria_STATUS, MetricAlertCriteria_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMetricAlertCriteria_STATUS runs a test to see if a specific instance of MetricAlertCriteria_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForMetricAlertCriteria_STATUS(subject MetricAlertCriteria_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MetricAlertCriteria_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MetricAlertCriteria_STATUS instances for property testing - lazily instantiated by
// MetricAlertCriteria_STATUSGenerator()
var metricAlertCriteria_STATUSGenerator gopter.Gen

// MetricAlertCriteria_STATUSGenerator returns a generator of MetricAlertCriteria_STATUS instances for property testing.
func MetricAlertCriteria_STATUSGenerator() gopter.Gen {
	if metricAlertCriteria_STATUSGenerator != nil {
		return metricAlertCriteria_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForMetricAlertCriteria_STATUS(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(MetricAlertCriteria_STATUS{}), map[string]gopter.Gen{propName: propGen}))
	}
	metricAlertCriteria_STATUSGenerator = gen.OneGenOf(gens...)

	return metricAlertCriteria_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForMetricAlertCriteria_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMetricAlertCriteria_STATUS(gens map[string]gopter.Gen) {
	gens["MicrosoftAzureMonitorMultipleResourceMultipleMetric"] = MetricAlertMultipleResourceMultipleMetricCriteria_STATUSGenerator().Map(func(it MetricAlertMultipleResourceMultipleMetricCriteria_STATUS) *MetricAlertMultipleResourceMultipleMetricCriteria_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["MicrosoftAzureMonitorSingleResourceMultipleMetric"] = MetricAlertSingleResourceMultipleMetricCriteria_STATUSGenerator().Map(func(it MetricAlertSingleResourceMultipleMetricCriteria_STATUS) *MetricAlertSingleResourceMultipleMetricCriteria_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["MicrosoftAzureMonitorWebtestLocationAvailability"] = WebtestLocationAvailabilityCriteria_STATUSGenerator().Map(func(it WebtestLocationAvailabilityCriteria_STATUS) *WebtestLocationAvailabilityCriteria_STATUS {
		return &it
	}) // generate one case for OneOf type
}

func Test_MetricAlertMultipleResourceMultipleMetricCriteria_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MetricAlertMultipleResourceMultipleMetricCriteria to MetricAlertMultipleResourceMultipleMetricCriteria via AssignProperties_To_MetricAlertMultipleResourceMultipleMetricCriteria & AssignProperties_From_MetricAlertMultipleResourceMultipleMetricCriteria returns original",
		prop.ForAll(RunPropertyAssignmentTestForMetricAlertMultipleResourceMultipleMetricCriteria, MetricAlertMultipleResourceMultipleMetricCriteriaGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMetricAlertMultipleResourceMultipleMetricCriteria tests if a specific instance of MetricAlertMultipleResourceMultipleMetricCriteria can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForMetricAlertMultipleResourceMultipleMetricCriteria(subject MetricAlertMultipleResourceMultipleMetricCriteria) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.MetricAlertMultipleResourceMultipleMetricCriteria
	err := copied.AssignProperties_To_MetricAlertMultipleResourceMultipleMetricCriteria(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual MetricAlertMultipleResourceMultipleMetricCriteria
	err = actual.AssignProperties_From_MetricAlertMultipleResourceMultipleMetricCriteria(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MetricAlertMultipleResourceMultipleMetricCriteria_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MetricAlertMultipleResourceMultipleMetricCriteria via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMetricAlertMultipleResourceMultipleMetricCriteria, MetricAlertMultipleResourceMultipleMetricCriteriaGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMetricAlertMultipleResourceMultipleMetricCriteria runs a test to see if a specific instance of MetricAlertMultipleResourceMultipleMetricCriteria round trips to JSON and back losslessly
func RunJSONSerializationTestForMetricAlertMultipleResourceMultipleMetricCriteria(subject MetricAlertMultipleResourceMultipleMetricCriteria) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MetricAlertMultipleResourceMultipleMetricCriteria
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MetricAlertMultipleResourceMultipleMetricCriteria instances for property testing - lazily instantiated
// by MetricAlertMultipleResourceMultipleMetricCriteriaGenerator()
var metricAlertMultipleResourceMultipleMetricCriteriaGenerator gopter.Gen

// MetricAlertMultipleResourceMultipleMetricCriteriaGenerator returns a generator of MetricAlertMultipleResourceMultipleMetricCriteria instances for property testing.
// We first initialize metricAlertMultipleResourceMultipleMetricCriteriaGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func MetricAlertMultipleResourceMultipleMetricCriteriaGenerator() gopter.Gen {
	if metricAlertMultipleResourceMultipleMetricCriteriaGenerator != nil {
		return metricAlertMultipleResourceMultipleMetricCriteriaGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricAlertMultipleResourceMultipleMetricCriteria(generators)
	metricAlertMultipleResourceMultipleMetricCriteriaGenerator = gen.Struct(reflect.TypeOf(MetricAlertMultipleResourceMultipleMetricCriteria{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricAlertMultipleResourceMultipleMetricCriteria(generators)
	AddRelatedPropertyGeneratorsForMetricAlertMultipleResourceMultipleMetricCriteria(generators)
	metricAlertMultipleResourceMultipleMetricCriteriaGenerator = gen.Struct(reflect.TypeOf(MetricAlertMultipleResourceMultipleMetricCriteria{}), generators)

	return metricAlertMultipleResourceMultipleMetricCriteriaGenerator
}

// AddIndependentPropertyGeneratorsForMetricAlertMultipleResourceMultipleMetricCriteria is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMetricAlertMultipleResourceMultipleMetricCriteria(gens map[string]gopter.Gen) {
	gens["OdataType"] = gen.PtrOf(gen.OneConstOf(MetricAlertMultipleResourceMultipleMetricCriteria_OdataType_MicrosoftAzureMonitorMultipleResourceMultipleMetricCriteria))
}

// AddRelatedPropertyGeneratorsForMetricAlertMultipleResourceMultipleMetricCriteria is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMetricAlertMultipleResourceMultipleMetricCriteria(gens map[string]gopter.Gen) {
	gens["AllOf"] = gen.SliceOf(MultiMetricCriteriaGenerator())
}

func Test_MetricAlertMultipleResourceMultipleMetricCriteria_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MetricAlertMultipleResourceMultipleMetricCriteria_STATUS to MetricAlertMultipleResourceMultipleMetricCriteria_STATUS via AssignProperties_To_MetricAlertMultipleResourceMultipleMetricCriteria_STATUS & AssignProperties_From_MetricAlertMultipleResourceMultipleMetricCriteria_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForMetricAlertMultipleResourceMultipleMetricCriteria_STATUS, MetricAlertMultipleResourceMultipleMetricCriteria_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMetricAlertMultipleResourceMultipleMetricCriteria_STATUS tests if a specific instance of MetricAlertMultipleResourceMultipleMetricCriteria_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForMetricAlertMultipleResourceMultipleMetricCriteria_STATUS(subject MetricAlertMultipleResourceMultipleMetricCriteria_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.MetricAlertMultipleResourceMultipleMetricCriteria_STATUS
	err := copied.AssignProperties_To_MetricAlertMultipleResourceMultipleMetricCriteria_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual MetricAlertMultipleResourceMultipleMetricCriteria_STATUS
	err = actual.AssignProperties_From_MetricAlertMultipleResourceMultipleMetricCriteria_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MetricAlertMultipleResourceMultipleMetricCriteria_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MetricAlertMultipleResourceMultipleMetricCriteria_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMetricAlertMultipleResourceMultipleMetricCriteria_STATUS, MetricAlertMultipleResourceMultipleMetricCriteria_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMetricAlertMultipleResourceMultipleMetricCriteria_STATUS runs a test to see if a specific instance of MetricAlertMultipleResourceMultipleMetricCriteria_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForMetricAlertMultipleResourceMultipleMetricCriteria_STATUS(subject MetricAlertMultipleResourceMultipleMetricCriteria_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MetricAlertMultipleResourceMultipleMetricCriteria_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MetricAlertMultipleResourceMultipleMetricCriteria_STATUS instances for property testing - lazily
// instantiated by MetricAlertMultipleResourceMultipleMetricCriteria_STATUSGenerator()
var metricAlertMultipleResourceMultipleMetricCriteria_STATUSGenerator gopter.Gen

// MetricAlertMultipleResourceMultipleMetricCriteria_STATUSGenerator returns a generator of MetricAlertMultipleResourceMultipleMetricCriteria_STATUS instances for property testing.
// We first initialize metricAlertMultipleResourceMultipleMetricCriteria_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func MetricAlertMultipleResourceMultipleMetricCriteria_STATUSGenerator() gopter.Gen {
	if metricAlertMultipleResourceMultipleMetricCriteria_STATUSGenerator != nil {
		return metricAlertMultipleResourceMultipleMetricCriteria_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricAlertMultipleResourceMultipleMetricCriteria_STATUS(generators)
	metricAlertMultipleResourceMultipleMetricCriteria_STATUSGenerator = gen.Struct(reflect.TypeOf(MetricAlertMultipleResourceMultipleMetricCriteria_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricAlertMultipleResourceMultipleMetricCriteria_STATUS(generators)
	AddRelatedPropertyGeneratorsForMetricAlertMultipleResourceMultipleMetricCriteria_STATUS(generators)
	metricAlertMultipleResourceMultipleMetricCriteria_STATUSGenerator = gen.Struct(reflect.TypeOf(MetricAlertMultipleResourceMultipleMetricCriteria_STATUS{}), generators)

	return metricAlertMultipleResourceMultipleMetricCriteria_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForMetricAlertMultipleResourceMultipleMetricCriteria_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMetricAlertMultipleResourceMultipleMetricCriteria_STATUS(gens map[string]gopter.Gen) {
	gens["OdataType"] = gen.PtrOf(gen.OneConstOf(MetricAlertMultipleResourceMultipleMetricCriteria_OdataType_STATUS_MicrosoftAzureMonitorMultipleResourceMultipleMetricCriteria))
}

// AddRelatedPropertyGeneratorsForMetricAlertMultipleResourceMultipleMetricCriteria_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMetricAlertMultipleResourceMultipleMetricCriteria_STATUS(gens map[string]gopter.Gen) {
	gens["AllOf"] = gen.SliceOf(MultiMetricCriteria_STATUSGenerator())
}

func Test_MetricAlertOperatorSpec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MetricAlertOperatorSpec to MetricAlertOperatorSpec via AssignProperties_To_MetricAlertOperatorSpec & AssignProperties_From_MetricAlertOperatorSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForMetricAlertOperatorSpec, MetricAlertOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMetricAlertOperatorSpec tests if a specific instance of MetricAlertOperatorSpec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForMetricAlertOperatorSpec(subject MetricAlertOperatorSpec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.MetricAlertOperatorSpec
	err := copied.AssignProperties_To_MetricAlertOperatorSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual MetricAlertOperatorSpec
	err = actual.AssignProperties_From_MetricAlertOperatorSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MetricAlertOperatorSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MetricAlertOperatorSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMetricAlertOperatorSpec, MetricAlertOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMetricAlertOperatorSpec runs a test to see if a specific instance of MetricAlertOperatorSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForMetricAlertOperatorSpec(subject MetricAlertOperatorSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MetricAlertOperatorSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MetricAlertOperatorSpec instances for property testing - lazily instantiated by
// MetricAlertOperatorSpecGenerator()
var metricAlertOperatorSpecGenerator gopter.Gen

// MetricAlertOperatorSpecGenerator returns a generator of MetricAlertOperatorSpec instances for property testing.
func MetricAlertOperatorSpecGenerator() gopter.Gen {
	if metricAlertOperatorSpecGenerator != nil {
		return metricAlertOperatorSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	metricAlertOperatorSpecGenerator = gen.Struct(reflect.TypeOf(MetricAlertOperatorSpec{}), generators)

	return metricAlertOperatorSpecGenerator
}

func Test_MetricAlertSingleResourceMultipleMetricCriteria_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MetricAlertSingleResourceMultipleMetricCriteria to MetricAlertSingleResourceMultipleMetricCriteria via AssignProperties_To_MetricAlertSingleResourceMultipleMetricCriteria & AssignProperties_From_MetricAlertSingleResourceMultipleMetricCriteria returns original",
		prop.ForAll(RunPropertyAssignmentTestForMetricAlertSingleResourceMultipleMetricCriteria, MetricAlertSingleResourceMultipleMetricCriteriaGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMetricAlertSingleResourceMultipleMetricCriteria tests if a specific instance of MetricAlertSingleResourceMultipleMetricCriteria can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForMetricAlertSingleResourceMultipleMetricCriteria(subject MetricAlertSingleResourceMultipleMetricCriteria) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.MetricAlertSingleResourceMultipleMetricCriteria
	err := copied.AssignProperties_To_MetricAlertSingleResourceMultipleMetricCriteria(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual MetricAlertSingleResourceMultipleMetricCriteria
	err = actual.AssignProperties_From_MetricAlertSingleResourceMultipleMetricCriteria(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MetricAlertSingleResourceMultipleMetricCriteria_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MetricAlertSingleResourceMultipleMetricCriteria via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMetricAlertSingleResourceMultipleMetricCriteria, MetricAlertSingleResourceMultipleMetricCriteriaGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMetricAlertSingleResourceMultipleMetricCriteria runs a test to see if a specific instance of MetricAlertSingleResourceMultipleMetricCriteria round trips to JSON and back losslessly
func RunJSONSerializationTestForMetricAlertSingleResourceMultipleMetricCriteria(subject MetricAlertSingleResourceMultipleMetricCriteria) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MetricAlertSingleResourceMultipleMetricCriteria
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MetricAlertSingleResourceMultipleMetricCriteria instances for property testing - lazily instantiated by
// MetricAlertSingleResourceMultipleMetricCriteriaGenerator()
var metricAlertSingleResourceMultipleMetricCriteriaGenerator gopter.Gen

// MetricAlertSingleResourceMultipleMetricCriteriaGenerator returns a generator of MetricAlertSingleResourceMultipleMetricCriteria instances for property testing.
// We first initialize metricAlertSingleResourceMultipleMetricCriteriaGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func MetricAlertSingleResourceMultipleMetricCriteriaGenerator() gopter.Gen {
	if metricAlertSingleResourceMultipleMetricCriteriaGenerator != nil {
		return metricAlertSingleResourceMultipleMetricCriteriaGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricAlertSingleResourceMultipleMetricCriteria(generators)
	metricAlertSingleResourceMultipleMetricCriteriaGenerator = gen.Struct(reflect.TypeOf(MetricAlertSingleResourceMultipleMetricCriteria{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricAlertSingleResourceMultipleMetricCriteria(generators)
	AddRelatedPropertyGeneratorsForMetricAlertSingleResourceMultipleMetricCriteria(generators)
	metricAlertSingleResourceMultipleMetricCriteriaGenerator = gen.Struct(reflect.TypeOf(MetricAlertSingleResourceMultipleMetricCriteria{}), generators)

	return metricAlertSingleResourceMultipleMetricCriteriaGenerator
}

// AddIndependentPropertyGeneratorsForMetricAlertSingleResourceMultipleMetricCriteria is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMetricAlertSingleResourceMultipleMetricCriteria(gens map[string]gopter.Gen) {
	gens["OdataType"] = gen.PtrOf(gen.OneConstOf(MetricAlertSingleResourceMultipleMetricCriteria_OdataType_MicrosoftAzureMonitorSingleResourceMultipleMetricCriteria))
}

// AddRelatedPropertyGeneratorsForMetricAlertSingleResourceMultipleMetricCriteria is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMetricAlertSingleResourceMultipleMetricCriteria(gens map[string]gopter.Gen) {
	gens["AllOf"] = gen.SliceOf(MetricCriteriaGenerator())
}

func Test_MetricAlertSingleResourceMultipleMetricCriteria_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MetricAlertSingleResourceMultipleMetricCriteria_STATUS to MetricAlertSingleResourceMultipleMetricCriteria_STATUS via AssignProperties_To_MetricAlertSingleResourceMultipleMetricCriteria_STATUS & AssignProperties_From_MetricAlertSingleResourceMultipleMetricCriteria_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForMetricAlertSingleResourceMultipleMetricCriteria_STATUS, MetricAlertSingleResourceMultipleMetricCriteria_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMetricAlertSingleResourceMultipleMetricCriteria_STATUS tests if a specific instance of MetricAlertSingleResourceMultipleMetricCriteria_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForMetricAlertSingleResourceMultipleMetricCriteria_STATUS(subject MetricAlertSingleResourceMultipleMetricCriteria_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.MetricAlertSingleResourceMultipleMetricCriteria_STATUS
	err := copied.AssignProperties_To_MetricAlertSingleResourceMultipleMetricCriteria_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual MetricAlertSingleResourceMultipleMetricCriteria_STATUS
	err = actual.AssignProperties_From_MetricAlertSingleResourceMultipleMetricCriteria_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MetricAlertSingleResourceMultipleMetricCriteria_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MetricAlertSingleResourceMultipleMetricCriteria_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMetricAlertSingleResourceMultipleMetricCriteria_STATUS, MetricAlertSingleResourceMultipleMetricCriteria_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMetricAlertSingleResourceMultipleMetricCriteria_STATUS runs a test to see if a specific instance of MetricAlertSingleResourceMultipleMetricCriteria_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForMetricAlertSingleResourceMultipleMetricCriteria_STATUS(subject MetricAlertSingleResourceMultipleMetricCriteria_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MetricAlertSingleResourceMultipleMetricCriteria_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MetricAlertSingleResourceMultipleMetricCriteria_STATUS instances for property testing - lazily
// instantiated by MetricAlertSingleResourceMultipleMetricCriteria_STATUSGenerator()
var metricAlertSingleResourceMultipleMetricCriteria_STATUSGenerator gopter.Gen

// MetricAlertSingleResourceMultipleMetricCriteria_STATUSGenerator returns a generator of MetricAlertSingleResourceMultipleMetricCriteria_STATUS instances for property testing.
// We first initialize metricAlertSingleResourceMultipleMetricCriteria_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func MetricAlertSingleResourceMultipleMetricCriteria_STATUSGenerator() gopter.Gen {
	if metricAlertSingleResourceMultipleMetricCriteria_STATUSGenerator != nil {
		return metricAlertSingleResourceMultipleMetricCriteria_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricAlertSingleResourceMultipleMetricCriteria_STATUS(generators)
	metricAlertSingleResourceMultipleMetricCriteria_STATUSGenerator = gen.Struct(reflect.TypeOf(MetricAlertSingleResourceMultipleMetricCriteria_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricAlertSingleResourceMultipleMetricCriteria_STATUS(generators)
	AddRelatedPropertyGeneratorsForMetricAlertSingleResourceMultipleMetricCriteria_STATUS(generators)
	metricAlertSingleResourceMultipleMetricCriteria_STATUSGenerator = gen.Struct(reflect.TypeOf(MetricAlertSingleResourceMultipleMetricCriteria_STATUS{}), generators)

	return metricAlertSingleResourceMultipleMetricCriteria_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForMetricAlertSingleResourceMultipleMetricCriteria_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMetricAlertSingleResourceMultipleMetricCriteria_STATUS(gens map[string]gopter.Gen) {
	gens["OdataType"] = gen.PtrOf(gen.OneConstOf(MetricAlertSingleResourceMultipleMetricCriteria_OdataType_STATUS_MicrosoftAzureMonitorSingleResourceMultipleMetricCriteria))
}

// AddRelatedPropertyGeneratorsForMetricAlertSingleResourceMultipleMetricCriteria_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMetricAlertSingleResourceMultipleMetricCriteria_STATUS(gens map[string]gopter.Gen) {
	gens["AllOf"] = gen.SliceOf(MetricCriteria_STATUSGenerator())
}

func Test_MetricAlert_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MetricAlert_STATUS to MetricAlert_STATUS via AssignProperties_To_MetricAlert_STATUS & AssignProperties_From_MetricAlert_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForMetricAlert_STATUS, MetricAlert_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMetricAlert_STATUS tests if a specific instance of MetricAlert_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForMetricAlert_STATUS(subject MetricAlert_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.MetricAlert_STATUS
	err := copied.AssignProperties_To_MetricAlert_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual MetricAlert_STATUS
	err = actual.AssignProperties_From_MetricAlert_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MetricAlert_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MetricAlert_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMetricAlert_STATUS, MetricAlert_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMetricAlert_STATUS runs a test to see if a specific instance of MetricAlert_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForMetricAlert_STATUS(subject MetricAlert_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MetricAlert_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MetricAlert_STATUS instances for property testing - lazily instantiated by MetricAlert_STATUSGenerator()
var metricAlert_STATUSGenerator gopter.Gen

// MetricAlert_STATUSGenerator returns a generator of MetricAlert_STATUS instances for property testing.
// We first initialize metricAlert_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func MetricAlert_STATUSGenerator() gopter.Gen {
	if metricAlert_STATUSGenerator != nil {
		return metricAlert_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricAlert_STATUS(generators)
	metricAlert_STATUSGenerator = gen.Struct(reflect.TypeOf(MetricAlert_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricAlert_STATUS(generators)
	AddRelatedPropertyGeneratorsForMetricAlert_STATUS(generators)
	metricAlert_STATUSGenerator = gen.Struct(reflect.TypeOf(MetricAlert_STATUS{}), generators)

	return metricAlert_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForMetricAlert_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMetricAlert_STATUS(gens map[string]gopter.Gen) {
	gens["AutoMitigate"] = gen.PtrOf(gen.Bool())
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["EvaluationFrequency"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IsMigrated"] = gen.PtrOf(gen.Bool())
	gens["LastUpdatedTime"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Scopes"] = gen.SliceOf(gen.AlphaString())
	gens["Severity"] = gen.PtrOf(gen.Int())
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["TargetResourceRegion"] = gen.PtrOf(gen.AlphaString())
	gens["TargetResourceType"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["WindowSize"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForMetricAlert_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMetricAlert_STATUS(gens map[string]gopter.Gen) {
	gens["Actions"] = gen.SliceOf(MetricAlertAction_STATUSGenerator())
	gens["Criteria"] = gen.PtrOf(MetricAlertCriteria_STATUSGenerator())
}

func Test_MetricAlert_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MetricAlert_Spec to MetricAlert_Spec via AssignProperties_To_MetricAlert_Spec & AssignProperties_From_MetricAlert_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForMetricAlert_Spec, MetricAlert_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMetricAlert_Spec tests if a specific instance of MetricAlert_Spec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForMetricAlert_Spec(subject MetricAlert_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.MetricAlert_Spec
	err := copied.AssignProperties_To_MetricAlert_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual MetricAlert_Spec
	err = actual.AssignProperties_From_MetricAlert_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MetricAlert_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MetricAlert_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMetricAlert_Spec, MetricAlert_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMetricAlert_Spec runs a test to see if a specific instance of MetricAlert_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForMetricAlert_Spec(subject MetricAlert_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MetricAlert_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MetricAlert_Spec instances for property testing - lazily instantiated by MetricAlert_SpecGenerator()
var metricAlert_SpecGenerator gopter.Gen

// MetricAlert_SpecGenerator returns a generator of MetricAlert_Spec instances for property testing.
// We first initialize metricAlert_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func MetricAlert_SpecGenerator() gopter.Gen {
	if metricAlert_SpecGenerator != nil {
		return metricAlert_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricAlert_Spec(generators)
	metricAlert_SpecGenerator = gen.Struct(reflect.TypeOf(MetricAlert_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricAlert_Spec(generators)
	AddRelatedPropertyGeneratorsForMetricAlert_Spec(generators)
	metricAlert_SpecGenerator = gen.Struct(reflect.TypeOf(MetricAlert_Spec{}), generators)

	return metricAlert_SpecGenerator
}

// AddIndependentPropertyGeneratorsForMetricAlert_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMetricAlert_Spec(gens map[string]gopter.Gen) {
	gens["AutoMitigate"] = gen.PtrOf(gen.Bool())
	gens["AzureName"] = gen.AlphaString()
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["EvaluationFrequency"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Severity"] = gen.PtrOf(gen.Int())
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["TargetResourceRegion"] = gen.PtrOf(gen.AlphaString())
	gens["TargetResourceType"] = gen.PtrOf(gen.AlphaString())
	gens["WindowSize"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForMetricAlert_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMetricAlert_Spec(gens map[string]gopter.Gen) {
	gens["Actions"] = gen.SliceOf(MetricAlertActionGenerator())
	gens["Criteria"] = gen.PtrOf(MetricAlertCriteriaGenerator())
	gens["OperatorSpec"] = gen.PtrOf(MetricAlertOperatorSpecGenerator())
}

func Test_MetricCriteria_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MetricCriteria to MetricCriteria via AssignProperties_To_MetricCriteria & AssignProperties_From_MetricCriteria returns original",
		prop.ForAll(RunPropertyAssignmentTestForMetricCriteria, MetricCriteriaGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMetricCriteria tests if a specific instance of MetricCriteria can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForMetricCriteria(subject MetricCriteria) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.MetricCriteria
	err := copied.AssignProperties_To_MetricCriteria(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual MetricCriteria
	err = actual.AssignProperties_From_MetricCriteria(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MetricCriteria_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MetricCriteria via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMetricCriteria, MetricCriteriaGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMetricCriteria runs a test to see if a specific instance of MetricCriteria round trips to JSON and back losslessly
func RunJSONSerializationTestForMetricCriteria(subject MetricCriteria) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MetricCriteria
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MetricCriteria instances for property testing - lazily instantiated by MetricCriteriaGenerator()
var metricCriteriaGenerator gopter.Gen

// MetricCriteriaGenerator returns a generator of MetricCriteria instances for property testing.
// We first initialize metricCriteriaGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func MetricCriteriaGenerator() gopter.Gen {
	if metricCriteriaGenerator != nil {
		return metricCriteriaGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricCriteria(generators)
	metricCriteriaGenerator = gen.Struct(reflect.TypeOf(MetricCriteria{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricCriteria(generators)
	AddRelatedPropertyGeneratorsForMetricCriteria(generators)
	metricCriteriaGenerator = gen.Struct(reflect.TypeOf(MetricCriteria{}), generators)

	return metricCriteriaGenerator
}

// AddIndependentPropertyGeneratorsForMetricCriteria is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMetricCriteria(gens map[string]gopter.Gen) {
	gens["CriterionType"] = gen.PtrOf(gen.OneConstOf(MetricCriteria_CriterionType_StaticThresholdCriterion))
	gens["MetricName"] = gen.PtrOf(gen.AlphaString())
	gens["MetricNamespace"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		MetricCriteria_Operator_Equals,
		MetricCriteria_Operator_GreaterThan,
		MetricCriteria_Operator_GreaterThanOrEqual,
		MetricCriteria_Operator_LessThan,
		MetricCriteria_Operator_LessThanOrEqual))
	gens["SkipMetricValidation"] = gen.PtrOf(gen.Bool())
	gens["Threshold"] = gen.PtrOf(gen.Float64())
	gens["TimeAggregation"] = gen.PtrOf(gen.OneConstOf(
		MetricCriteria_TimeAggregation_Average,
		MetricCriteria_TimeAggregation_Count,
		MetricCriteria_TimeAggregation_Maximum,
		MetricCriteria_TimeAggregation_Minimum,
		MetricCriteria_TimeAggregation_Total))
}

// AddRelatedPropertyGeneratorsForMetricCriteria is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMetricCriteria(gens map[string]gopter.Gen) {
	gens["Dimensions"] = gen.SliceOf(MetricDimensionGenerator())
}

func Test_MetricCriteria_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MetricCriteria_STATUS to MetricCriteria_STATUS via AssignProperties_To_MetricCriteria_STATUS & AssignProperties_From_MetricCriteria_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForMetricCriteria_STATUS, MetricCriteria_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMetricCriteria_STATUS tests if a specific instance of MetricCriteria_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForMetricCriteria_STATUS(subject MetricCriteria_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.MetricCriteria_STATUS
	err := copied.AssignProperties_To_MetricCriteria_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual MetricCriteria_STATUS
	err = actual.AssignProperties_From_MetricCriteria_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MetricCriteria_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MetricCriteria_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMetricCriteria_STATUS, MetricCriteria_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMetricCriteria_STATUS runs a test to see if a specific instance of MetricCriteria_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForMetricCriteria_STATUS(subject MetricCriteria_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MetricCriteria_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MetricCriteria_STATUS instances for property testing - lazily instantiated by
// MetricCriteria_STATUSGenerator()
var metricCriteria_STATUSGenerator gopter.Gen

// MetricCriteria_STATUSGenerator returns a generator of MetricCriteria_STATUS instances for property testing.
// We first initialize metricCriteria_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func MetricCriteria_STATUSGenerator() gopter.Gen {
	if metricCriteria_STATUSGenerator != nil {
		return metricCriteria_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricCriteria_STATUS(generators)
	metricCriteria_STATUSGenerator = gen.Struct(reflect.TypeOf(MetricCriteria_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricCriteria_STATUS(generators)
	AddRelatedPropertyGeneratorsForMetricCriteria_STATUS(generators)
	metricCriteria_STATUSGenerator = gen.Struct(reflect.TypeOf(MetricCriteria_STATUS{}), generators)

	return metricCriteria_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForMetricCriteria_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMetricCriteria_STATUS(gens map[string]gopter.Gen) {
	gens["CriterionType"] = gen.PtrOf(gen.OneConstOf(MetricCriteria_CriterionType_STATUS_StaticThresholdCriterion))
	gens["MetricName"] = gen.PtrOf(gen.AlphaString())
	gens["MetricNamespace"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		MetricCriteria_Operator_STATUS_Equals,
		MetricCriteria_Operator_STATUS_GreaterThan,
		MetricCriteria_Operator_STATUS_GreaterThanOrEqual,
		MetricCriteria_Operator_STATUS_LessThan,
		MetricCriteria_Operator_STATUS_LessThanOrEqual))
	gens["SkipMetricValidation"] = gen.PtrOf(gen.Bool())
	gens["Threshold"] = gen.PtrOf(gen.Float64())
	gens["TimeAggregation"] = gen.PtrOf(gen.OneConstOf(
		MetricCriteria_TimeAggregation_STATUS_Average,
		MetricCriteria_TimeAggregation_STATUS_Count,
		MetricCriteria_TimeAggregation_STATUS_Maximum,
		MetricCriteria_TimeAggregation_STATUS_Minimum,
		MetricCriteria_TimeAggregation_STATUS_Total))
}

// AddRelatedPropertyGeneratorsForMetricCriteria_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMetricCriteria_STATUS(gens map[string]gopter.Gen) {
	gens["Dimensions"] = gen.SliceOf(MetricDimension_STATUSGenerator())
}

func Test_MetricDimension_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MetricDimension to MetricDimension via AssignProperties_To_MetricDimension & AssignProperties_From_MetricDimension returns original",
		prop.ForAll(RunPropertyAssignmentTestForMetricDimension, MetricDimensionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMetricDimension tests if a specific instance of MetricDimension can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForMetricDimension(subject MetricDimension) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.MetricDimension
	err := copied.AssignProperties_To_MetricDimension(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual MetricDimension
	err = actual.AssignProperties_From_MetricDimension(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MetricDimension_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MetricDimension via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMetricDimension, MetricDimensionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMetricDimension runs a test to see if a specific instance of MetricDimension round trips to JSON and back losslessly
func RunJSONSerializationTestForMetricDimension(subject MetricDimension) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MetricDimension
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MetricDimension instances for property testing - lazily instantiated by MetricDimensionGenerator()
var metricDimensionGenerator gopter.Gen

// MetricDimensionGenerator returns a generator of MetricDimension instances for property testing.
func MetricDimensionGenerator() gopter.Gen {
	if metricDimensionGenerator != nil {
		return metricDimensionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricDimension(generators)
	metricDimensionGenerator = gen.Struct(reflect.TypeOf(MetricDimension{}), generators)

	return metricDimensionGenerator
}

// AddIndependentPropertyGeneratorsForMetricDimension is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMetricDimension(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Operator"] = gen.PtrOf(gen.AlphaString())
	gens["Values"] = gen.SliceOf(gen.AlphaString())
}

func Test_MetricDimension_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MetricDimension_STATUS to MetricDimension_STATUS via AssignProperties_To_MetricDimension_STATUS & AssignProperties_From_MetricDimension_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForMetricDimension_STATUS, MetricDimension_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMetricDimension_STATUS tests if a specific instance of MetricDimension_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForMetricDimension_STATUS(subject MetricDimension_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.MetricDimension_STATUS
	err := copied.AssignProperties_To_MetricDimension_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual MetricDimension_STATUS
	err = actual.AssignProperties_From_MetricDimension_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MetricDimension_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MetricDimension_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMetricDimension_STATUS, MetricDimension_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMetricDimension_STATUS runs a test to see if a specific instance of MetricDimension_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForMetricDimension_STATUS(subject MetricDimension_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MetricDimension_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MetricDimension_STATUS instances for property testing - lazily instantiated by
// MetricDimension_STATUSGenerator()
var metricDimension_STATUSGenerator gopter.Gen

// MetricDimension_STATUSGenerator returns a generator of MetricDimension_STATUS instances for property testing.
func MetricDimension_STATUSGenerator() gopter.Gen {
	if metricDimension_STATUSGenerator != nil {
		return metricDimension_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricDimension_STATUS(generators)
	metricDimension_STATUSGenerator = gen.Struct(reflect.TypeOf(MetricDimension_STATUS{}), generators)

	return metricDimension_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForMetricDimension_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMetricDimension_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Operator"] = gen.PtrOf(gen.AlphaString())
	gens["Values"] = gen.SliceOf(gen.AlphaString())
}

func Test_MultiMetricCriteria_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MultiMetricCriteria to MultiMetricCriteria via AssignProperties_To_MultiMetricCriteria & AssignProperties_From_MultiMetricCriteria returns original",
		prop.ForAll(RunPropertyAssignmentTestForMultiMetricCriteria, MultiMetricCriteriaGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMultiMetricCriteria tests if a specific instance of MultiMetricCriteria can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForMultiMetricCriteria(subject MultiMetricCriteria) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.MultiMetricCriteria
	err := copied.AssignProperties_To_MultiMetricCriteria(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual MultiMetricCriteria
	err = actual.AssignProperties_From_MultiMetricCriteria(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MultiMetricCriteria_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MultiMetricCriteria via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMultiMetricCriteria, MultiMetricCriteriaGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMultiMetricCriteria runs a test to see if a specific instance of MultiMetricCriteria round trips to JSON and back losslessly
func RunJSONSerializationTestForMultiMetricCriteria(subject MultiMetricCriteria) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MultiMetricCriteria
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MultiMetricCriteria instances for property testing - lazily instantiated by
// MultiMetricCriteriaGenerator()
var multiMetricCriteriaGenerator gopter.Gen

// MultiMetricCriteriaGenerator returns a generator of MultiMetricCriteria instances for property testing.
func MultiMetricCriteriaGenerator() gopter.Gen {
	if multiMetricCriteriaGenerator != nil {
		return multiMetricCriteriaGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForMultiMetricCriteria(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(MultiMetricCriteria{}), map[string]gopter.Gen{propName: propGen}))
	}
	multiMetricCriteriaGenerator = gen.OneGenOf(gens...)

	return multiMetricCriteriaGenerator
}

// AddRelatedPropertyGeneratorsForMultiMetricCriteria is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMultiMetricCriteria(gens map[string]gopter.Gen) {
	gens["Dynamic"] = DynamicMetricCriteriaGenerator().Map(func(it DynamicMetricCriteria) *DynamicMetricCriteria {
		return &it
	}) // generate one case for OneOf type
	gens["Static"] = MetricCriteriaGenerator().Map(func(it MetricCriteria) *MetricCriteria {
		return &it
	}) // generate one case for OneOf type
}

func Test_MultiMetricCriteria_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MultiMetricCriteria_STATUS to MultiMetricCriteria_STATUS via AssignProperties_To_MultiMetricCriteria_STATUS & AssignProperties_From_MultiMetricCriteria_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForMultiMetricCriteria_STATUS, MultiMetricCriteria_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMultiMetricCriteria_STATUS tests if a specific instance of MultiMetricCriteria_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForMultiMetricCriteria_STATUS(subject MultiMetricCriteria_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.MultiMetricCriteria_STATUS
	err := copied.AssignProperties_To_MultiMetricCriteria_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual MultiMetricCriteria_STATUS
	err = actual.AssignProperties_From_MultiMetricCriteria_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MultiMetricCriteria_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MultiMetricCriteria_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMultiMetricCriteria_STATUS, MultiMetricCriteria_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMultiMetricCriteria_STATUS runs a test to see if a specific instance of MultiMetricCriteria_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForMultiMetricCriteria_STATUS(subject MultiMetricCriteria_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MultiMetricCriteria_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MultiMetricCriteria_STATUS instances for property testing - lazily instantiated by
// MultiMetricCriteria_STATUSGenerator()
var multiMetricCriteria_STATUSGenerator gopter.Gen

// MultiMetricCriteria_STATUSGenerator returns a generator of MultiMetricCriteria_STATUS instances for property testing.
func MultiMetricCriteria_STATUSGenerator() gopter.Gen {
	if multiMetricCriteria_STATUSGenerator != nil {
		return multiMetricCriteria_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForMultiMetricCriteria_STATUS(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(MultiMetricCriteria_STATUS{}), map[string]gopter.Gen{propName: propGen}))
	}
	multiMetricCriteria_STATUSGenerator = gen.OneGenOf(gens...)

	return multiMetricCriteria_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForMultiMetricCriteria_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMultiMetricCriteria_STATUS(gens map[string]gopter.Gen) {
	gens["Dynamic"] = DynamicMetricCriteria_STATUSGenerator().Map(func(it DynamicMetricCriteria_STATUS) *DynamicMetricCriteria_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["Static"] = MetricCriteria_STATUSGenerator().Map(func(it MetricCriteria_STATUS) *MetricCriteria_STATUS {
		return &it
	}) // generate one case for OneOf type
}

func Test_WebtestLocationAvailabilityCriteria_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WebtestLocationAvailabilityCriteria to WebtestLocationAvailabilityCriteria via AssignProperties_To_WebtestLocationAvailabilityCriteria & AssignProperties_From_WebtestLocationAvailabilityCriteria returns original",
		prop.ForAll(RunPropertyAssignmentTestForWebtestLocationAvailabilityCriteria, WebtestLocationAvailabilityCriteriaGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWebtestLocationAvailabilityCriteria tests if a specific instance of WebtestLocationAvailabilityCriteria can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWebtestLocationAvailabilityCriteria(subject WebtestLocationAvailabilityCriteria) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.WebtestLocationAvailabilityCriteria
	err := copied.AssignProperties_To_WebtestLocationAvailabilityCriteria(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WebtestLocationAvailabilityCriteria
	err = actual.AssignProperties_From_WebtestLocationAvailabilityCriteria(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WebtestLocationAvailabilityCriteria_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebtestLocationAvailabilityCriteria via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebtestLocationAvailabilityCriteria, WebtestLocationAvailabilityCriteriaGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebtestLocationAvailabilityCriteria runs a test to see if a specific instance of WebtestLocationAvailabilityCriteria round trips to JSON and back losslessly
func RunJSONSerializationTestForWebtestLocationAvailabilityCriteria(subject WebtestLocationAvailabilityCriteria) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebtestLocationAvailabilityCriteria
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebtestLocationAvailabilityCriteria instances for property testing - lazily instantiated by
// WebtestLocationAvailabilityCriteriaGenerator()
var webtestLocationAvailabilityCriteriaGenerator gopter.Gen

// WebtestLocationAvailabilityCriteriaGenerator returns a generator of WebtestLocationAvailabilityCriteria instances for property testing.
func WebtestLocationAvailabilityCriteriaGenerator() gopter.Gen {
	if webtestLocationAvailabilityCriteriaGenerator != nil {
		return webtestLocationAvailabilityCriteriaGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebtestLocationAvailabilityCriteria(generators)
	webtestLocationAvailabilityCriteriaGenerator = gen.Struct(reflect.TypeOf(WebtestLocationAvailabilityCriteria{}), generators)

	return webtestLocationAvailabilityCriteriaGenerator
}

// AddIndependentPropertyGeneratorsForWebtestLocationAvailabilityCriteria is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebtestLocationAvailabilityCriteria(gens map[string]gopter.Gen) {
	gens["FailedLocationCount"] = gen.PtrOf(gen.Float64())
	gens["OdataType"] = gen.PtrOf(gen.OneConstOf(WebtestLocationAvailabilityCriteria_OdataType_MicrosoftAzureMonitorWebtestLocationAvailabilityCriteria))
	gens["WebTestId"] = gen.PtrOf(gen.AlphaString())
}

func Test_WebtestLocationAvailabilityCriteria_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WebtestLocationAvailabilityCriteria_STATUS to WebtestLocationAvailabilityCriteria_STATUS via AssignProperties_To_WebtestLocationAvailabilityCriteria_STATUS & AssignProperties_From_WebtestLocationAvailabilityCriteria_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForWebtestLocationAvailabilityCriteria_STATUS, WebtestLocationAvailabilityCriteria_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWebtestLocationAvailabilityCriteria_STATUS tests if a specific instance of WebtestLocationAvailabilityCriteria_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWebtestLocationAvailabilityCriteria_STATUS(subject WebtestLocationAvailabilityCriteria_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.WebtestLocationAvailabilityCriteria_STATUS
	err := copied.AssignProperties_To_WebtestLocationAvailabilityCriteria_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WebtestLocationAvailabilityCriteria_STATUS
	err = actual.AssignProperties_From_WebtestLocationAvailabilityCriteria_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WebtestLocationAvailabilityCriteria_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebtestLocationAvailabilityCriteria_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebtestLocationAvailabilityCriteria_STATUS, WebtestLocationAvailabilityCriteria_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebtestLocationAvailabilityCriteria_STATUS runs a test to see if a specific instance of WebtestLocationAvailabilityCriteria_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForWebtestLocationAvailabilityCriteria_STATUS(subject WebtestLocationAvailabilityCriteria_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebtestLocationAvailabilityCriteria_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebtestLocationAvailabilityCriteria_STATUS instances for property testing - lazily instantiated by
// WebtestLocationAvailabilityCriteria_STATUSGenerator()
var webtestLocationAvailabilityCriteria_STATUSGenerator gopter.Gen

// WebtestLocationAvailabilityCriteria_STATUSGenerator returns a generator of WebtestLocationAvailabilityCriteria_STATUS instances for property testing.
func WebtestLocationAvailabilityCriteria_STATUSGenerator() gopter.Gen {
	if webtestLocationAvailabilityCriteria_STATUSGenerator != nil {
		return webtestLocationAvailabilityCriteria_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebtestLocationAvailabilityCriteria_STATUS(generators)
	webtestLocationAvailabilityCriteria_STATUSGenerator = gen.Struct(reflect.TypeOf(WebtestLocationAvailabilityCriteria_STATUS{}), generators)

	return webtestLocationAvailabilityCriteria_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForWebtestLocationAvailabilityCriteria_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebtestLocationAvailabilityCriteria_STATUS(gens map[string]gopter.Gen) {
	gens["ComponentId"] = gen.PtrOf(gen.AlphaString())
	gens["FailedLocationCount"] = gen.PtrOf(gen.Float64())
	gens["OdataType"] = gen.PtrOf(gen.OneConstOf(WebtestLocationAvailabilityCriteria_OdataType_STATUS_MicrosoftAzureMonitorWebtestLocationAvailabilityCriteria))
	gens["WebTestId"] = gen.PtrOf(gen.AlphaString())
}
