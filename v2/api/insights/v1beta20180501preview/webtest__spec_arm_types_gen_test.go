// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20180501preview

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_Webtest_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Webtest_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebtest_SpecARM, Webtest_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebtest_SpecARM runs a test to see if a specific instance of Webtest_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWebtest_SpecARM(subject Webtest_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Webtest_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Webtest_SpecARM instances for property testing - lazily instantiated by Webtest_SpecARMGenerator()
var webtest_SpecARMGenerator gopter.Gen

// Webtest_SpecARMGenerator returns a generator of Webtest_SpecARM instances for property testing.
// We first initialize webtest_SpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Webtest_SpecARMGenerator() gopter.Gen {
	if webtest_SpecARMGenerator != nil {
		return webtest_SpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebtest_SpecARM(generators)
	webtest_SpecARMGenerator = gen.Struct(reflect.TypeOf(Webtest_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebtest_SpecARM(generators)
	AddRelatedPropertyGeneratorsForWebtest_SpecARM(generators)
	webtest_SpecARMGenerator = gen.Struct(reflect.TypeOf(Webtest_SpecARM{}), generators)

	return webtest_SpecARMGenerator
}

// AddIndependentPropertyGeneratorsForWebtest_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebtest_SpecARM(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(Webtest_Spec_KindMultistep, Webtest_Spec_KindPing))
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForWebtest_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWebtest_SpecARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(WebTestPropertiesARMGenerator())
}

func Test_WebTestPropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebTestPropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebTestPropertiesARM, WebTestPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebTestPropertiesARM runs a test to see if a specific instance of WebTestPropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWebTestPropertiesARM(subject WebTestPropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebTestPropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebTestPropertiesARM instances for property testing - lazily instantiated by
// WebTestPropertiesARMGenerator()
var webTestPropertiesARMGenerator gopter.Gen

// WebTestPropertiesARMGenerator returns a generator of WebTestPropertiesARM instances for property testing.
// We first initialize webTestPropertiesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WebTestPropertiesARMGenerator() gopter.Gen {
	if webTestPropertiesARMGenerator != nil {
		return webTestPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebTestPropertiesARM(generators)
	webTestPropertiesARMGenerator = gen.Struct(reflect.TypeOf(WebTestPropertiesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebTestPropertiesARM(generators)
	AddRelatedPropertyGeneratorsForWebTestPropertiesARM(generators)
	webTestPropertiesARMGenerator = gen.Struct(reflect.TypeOf(WebTestPropertiesARM{}), generators)

	return webTestPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForWebTestPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebTestPropertiesARM(gens map[string]gopter.Gen) {
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["Frequency"] = gen.PtrOf(gen.Int())
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(
		WebTestProperties_KindBasic,
		WebTestProperties_KindMultistep,
		WebTestProperties_KindPing,
		WebTestProperties_KindStandard))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["RetryEnabled"] = gen.PtrOf(gen.Bool())
	gens["SyntheticMonitorId"] = gen.PtrOf(gen.AlphaString())
	gens["Timeout"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForWebTestPropertiesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWebTestPropertiesARM(gens map[string]gopter.Gen) {
	gens["Configuration"] = gen.PtrOf(WebTestProperties_ConfigurationARMGenerator())
	gens["Locations"] = gen.SliceOf(WebTestGeolocationARMGenerator())
	gens["Request"] = gen.PtrOf(WebTestProperties_RequestARMGenerator())
	gens["ValidationRules"] = gen.PtrOf(WebTestProperties_ValidationRulesARMGenerator())
}

func Test_WebTestGeolocationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebTestGeolocationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebTestGeolocationARM, WebTestGeolocationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebTestGeolocationARM runs a test to see if a specific instance of WebTestGeolocationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWebTestGeolocationARM(subject WebTestGeolocationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebTestGeolocationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebTestGeolocationARM instances for property testing - lazily instantiated by
// WebTestGeolocationARMGenerator()
var webTestGeolocationARMGenerator gopter.Gen

// WebTestGeolocationARMGenerator returns a generator of WebTestGeolocationARM instances for property testing.
func WebTestGeolocationARMGenerator() gopter.Gen {
	if webTestGeolocationARMGenerator != nil {
		return webTestGeolocationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebTestGeolocationARM(generators)
	webTestGeolocationARMGenerator = gen.Struct(reflect.TypeOf(WebTestGeolocationARM{}), generators)

	return webTestGeolocationARMGenerator
}

// AddIndependentPropertyGeneratorsForWebTestGeolocationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebTestGeolocationARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_WebTestProperties_ConfigurationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebTestProperties_ConfigurationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebTestProperties_ConfigurationARM, WebTestProperties_ConfigurationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebTestProperties_ConfigurationARM runs a test to see if a specific instance of WebTestProperties_ConfigurationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWebTestProperties_ConfigurationARM(subject WebTestProperties_ConfigurationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebTestProperties_ConfigurationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebTestProperties_ConfigurationARM instances for property testing - lazily instantiated by
// WebTestProperties_ConfigurationARMGenerator()
var webTestProperties_ConfigurationARMGenerator gopter.Gen

// WebTestProperties_ConfigurationARMGenerator returns a generator of WebTestProperties_ConfigurationARM instances for property testing.
func WebTestProperties_ConfigurationARMGenerator() gopter.Gen {
	if webTestProperties_ConfigurationARMGenerator != nil {
		return webTestProperties_ConfigurationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebTestProperties_ConfigurationARM(generators)
	webTestProperties_ConfigurationARMGenerator = gen.Struct(reflect.TypeOf(WebTestProperties_ConfigurationARM{}), generators)

	return webTestProperties_ConfigurationARMGenerator
}

// AddIndependentPropertyGeneratorsForWebTestProperties_ConfigurationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebTestProperties_ConfigurationARM(gens map[string]gopter.Gen) {
	gens["WebTest"] = gen.PtrOf(gen.AlphaString())
}

func Test_WebTestProperties_RequestARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebTestProperties_RequestARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebTestProperties_RequestARM, WebTestProperties_RequestARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebTestProperties_RequestARM runs a test to see if a specific instance of WebTestProperties_RequestARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWebTestProperties_RequestARM(subject WebTestProperties_RequestARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebTestProperties_RequestARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebTestProperties_RequestARM instances for property testing - lazily instantiated by
// WebTestProperties_RequestARMGenerator()
var webTestProperties_RequestARMGenerator gopter.Gen

// WebTestProperties_RequestARMGenerator returns a generator of WebTestProperties_RequestARM instances for property testing.
// We first initialize webTestProperties_RequestARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WebTestProperties_RequestARMGenerator() gopter.Gen {
	if webTestProperties_RequestARMGenerator != nil {
		return webTestProperties_RequestARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebTestProperties_RequestARM(generators)
	webTestProperties_RequestARMGenerator = gen.Struct(reflect.TypeOf(WebTestProperties_RequestARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebTestProperties_RequestARM(generators)
	AddRelatedPropertyGeneratorsForWebTestProperties_RequestARM(generators)
	webTestProperties_RequestARMGenerator = gen.Struct(reflect.TypeOf(WebTestProperties_RequestARM{}), generators)

	return webTestProperties_RequestARMGenerator
}

// AddIndependentPropertyGeneratorsForWebTestProperties_RequestARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebTestProperties_RequestARM(gens map[string]gopter.Gen) {
	gens["FollowRedirects"] = gen.PtrOf(gen.Bool())
	gens["HttpVerb"] = gen.PtrOf(gen.AlphaString())
	gens["ParseDependentRequests"] = gen.PtrOf(gen.Bool())
	gens["RequestBody"] = gen.PtrOf(gen.AlphaString())
	gens["RequestUrl"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForWebTestProperties_RequestARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWebTestProperties_RequestARM(gens map[string]gopter.Gen) {
	gens["Headers"] = gen.SliceOf(HeaderFieldARMGenerator())
}

func Test_WebTestProperties_ValidationRulesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebTestProperties_ValidationRulesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebTestProperties_ValidationRulesARM, WebTestProperties_ValidationRulesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebTestProperties_ValidationRulesARM runs a test to see if a specific instance of WebTestProperties_ValidationRulesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWebTestProperties_ValidationRulesARM(subject WebTestProperties_ValidationRulesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebTestProperties_ValidationRulesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebTestProperties_ValidationRulesARM instances for property testing - lazily instantiated by
// WebTestProperties_ValidationRulesARMGenerator()
var webTestProperties_ValidationRulesARMGenerator gopter.Gen

// WebTestProperties_ValidationRulesARMGenerator returns a generator of WebTestProperties_ValidationRulesARM instances for property testing.
// We first initialize webTestProperties_ValidationRulesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WebTestProperties_ValidationRulesARMGenerator() gopter.Gen {
	if webTestProperties_ValidationRulesARMGenerator != nil {
		return webTestProperties_ValidationRulesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebTestProperties_ValidationRulesARM(generators)
	webTestProperties_ValidationRulesARMGenerator = gen.Struct(reflect.TypeOf(WebTestProperties_ValidationRulesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebTestProperties_ValidationRulesARM(generators)
	AddRelatedPropertyGeneratorsForWebTestProperties_ValidationRulesARM(generators)
	webTestProperties_ValidationRulesARMGenerator = gen.Struct(reflect.TypeOf(WebTestProperties_ValidationRulesARM{}), generators)

	return webTestProperties_ValidationRulesARMGenerator
}

// AddIndependentPropertyGeneratorsForWebTestProperties_ValidationRulesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebTestProperties_ValidationRulesARM(gens map[string]gopter.Gen) {
	gens["ExpectedHttpStatusCode"] = gen.PtrOf(gen.Int())
	gens["IgnoreHttpsStatusCode"] = gen.PtrOf(gen.Bool())
	gens["SSLCertRemainingLifetimeCheck"] = gen.PtrOf(gen.Int())
	gens["SSLCheck"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForWebTestProperties_ValidationRulesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWebTestProperties_ValidationRulesARM(gens map[string]gopter.Gen) {
	gens["ContentValidation"] = gen.PtrOf(WebTestProperties_ValidationRules_ContentValidationARMGenerator())
}

func Test_HeaderFieldARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HeaderFieldARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHeaderFieldARM, HeaderFieldARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHeaderFieldARM runs a test to see if a specific instance of HeaderFieldARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHeaderFieldARM(subject HeaderFieldARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HeaderFieldARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HeaderFieldARM instances for property testing - lazily instantiated by HeaderFieldARMGenerator()
var headerFieldARMGenerator gopter.Gen

// HeaderFieldARMGenerator returns a generator of HeaderFieldARM instances for property testing.
func HeaderFieldARMGenerator() gopter.Gen {
	if headerFieldARMGenerator != nil {
		return headerFieldARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHeaderFieldARM(generators)
	headerFieldARMGenerator = gen.Struct(reflect.TypeOf(HeaderFieldARM{}), generators)

	return headerFieldARMGenerator
}

// AddIndependentPropertyGeneratorsForHeaderFieldARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHeaderFieldARM(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_WebTestProperties_ValidationRules_ContentValidationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebTestProperties_ValidationRules_ContentValidationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebTestProperties_ValidationRules_ContentValidationARM, WebTestProperties_ValidationRules_ContentValidationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebTestProperties_ValidationRules_ContentValidationARM runs a test to see if a specific instance of WebTestProperties_ValidationRules_ContentValidationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWebTestProperties_ValidationRules_ContentValidationARM(subject WebTestProperties_ValidationRules_ContentValidationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebTestProperties_ValidationRules_ContentValidationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebTestProperties_ValidationRules_ContentValidationARM instances for property testing - lazily
// instantiated by WebTestProperties_ValidationRules_ContentValidationARMGenerator()
var webTestProperties_ValidationRules_ContentValidationARMGenerator gopter.Gen

// WebTestProperties_ValidationRules_ContentValidationARMGenerator returns a generator of WebTestProperties_ValidationRules_ContentValidationARM instances for property testing.
func WebTestProperties_ValidationRules_ContentValidationARMGenerator() gopter.Gen {
	if webTestProperties_ValidationRules_ContentValidationARMGenerator != nil {
		return webTestProperties_ValidationRules_ContentValidationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebTestProperties_ValidationRules_ContentValidationARM(generators)
	webTestProperties_ValidationRules_ContentValidationARMGenerator = gen.Struct(reflect.TypeOf(WebTestProperties_ValidationRules_ContentValidationARM{}), generators)

	return webTestProperties_ValidationRules_ContentValidationARMGenerator
}

// AddIndependentPropertyGeneratorsForWebTestProperties_ValidationRules_ContentValidationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebTestProperties_ValidationRules_ContentValidationARM(gens map[string]gopter.Gen) {
	gens["ContentMatch"] = gen.PtrOf(gen.AlphaString())
	gens["IgnoreCase"] = gen.PtrOf(gen.Bool())
	gens["PassIfTextFound"] = gen.PtrOf(gen.Bool())
}
