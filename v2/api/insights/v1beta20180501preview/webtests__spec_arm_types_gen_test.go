// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20180501preview

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_Webtests_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Webtests_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebtestsSpecARM, WebtestsSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebtestsSpecARM runs a test to see if a specific instance of Webtests_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWebtestsSpecARM(subject Webtests_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Webtests_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Webtests_SpecARM instances for property testing - lazily instantiated by WebtestsSpecARMGenerator()
var webtestsSpecARMGenerator gopter.Gen

// WebtestsSpecARMGenerator returns a generator of Webtests_SpecARM instances for property testing.
// We first initialize webtestsSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WebtestsSpecARMGenerator() gopter.Gen {
	if webtestsSpecARMGenerator != nil {
		return webtestsSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebtestsSpecARM(generators)
	webtestsSpecARMGenerator = gen.Struct(reflect.TypeOf(Webtests_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebtestsSpecARM(generators)
	AddRelatedPropertyGeneratorsForWebtestsSpecARM(generators)
	webtestsSpecARMGenerator = gen.Struct(reflect.TypeOf(Webtests_SpecARM{}), generators)

	return webtestsSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForWebtestsSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebtestsSpecARM(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForWebtestsSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWebtestsSpecARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(WebTestPropertiesARMGenerator())
}

func Test_WebTestPropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebTestPropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebTestPropertiesARM, WebTestPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebTestPropertiesARM runs a test to see if a specific instance of WebTestPropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWebTestPropertiesARM(subject WebTestPropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebTestPropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebTestPropertiesARM instances for property testing - lazily instantiated by
// WebTestPropertiesARMGenerator()
var webTestPropertiesARMGenerator gopter.Gen

// WebTestPropertiesARMGenerator returns a generator of WebTestPropertiesARM instances for property testing.
// We first initialize webTestPropertiesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WebTestPropertiesARMGenerator() gopter.Gen {
	if webTestPropertiesARMGenerator != nil {
		return webTestPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebTestPropertiesARM(generators)
	webTestPropertiesARMGenerator = gen.Struct(reflect.TypeOf(WebTestPropertiesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebTestPropertiesARM(generators)
	AddRelatedPropertyGeneratorsForWebTestPropertiesARM(generators)
	webTestPropertiesARMGenerator = gen.Struct(reflect.TypeOf(WebTestPropertiesARM{}), generators)

	return webTestPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForWebTestPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebTestPropertiesARM(gens map[string]gopter.Gen) {
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["Frequency"] = gen.PtrOf(gen.Int())
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(
		WebTestPropertiesKindBasic,
		WebTestPropertiesKindMultistep,
		WebTestPropertiesKindPing,
		WebTestPropertiesKindStandard))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["RetryEnabled"] = gen.PtrOf(gen.Bool())
	gens["SyntheticMonitorId"] = gen.PtrOf(gen.AlphaString())
	gens["Timeout"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForWebTestPropertiesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWebTestPropertiesARM(gens map[string]gopter.Gen) {
	gens["Configuration"] = gen.PtrOf(WebTestPropertiesConfigurationARMGenerator())
	gens["Locations"] = gen.SliceOf(WebTestGeolocationARMGenerator())
	gens["Request"] = gen.PtrOf(WebTestPropertiesRequestARMGenerator())
	gens["ValidationRules"] = gen.PtrOf(WebTestPropertiesValidationRulesARMGenerator())
}

func Test_WebTestGeolocationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebTestGeolocationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebTestGeolocationARM, WebTestGeolocationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebTestGeolocationARM runs a test to see if a specific instance of WebTestGeolocationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWebTestGeolocationARM(subject WebTestGeolocationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebTestGeolocationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebTestGeolocationARM instances for property testing - lazily instantiated by
// WebTestGeolocationARMGenerator()
var webTestGeolocationARMGenerator gopter.Gen

// WebTestGeolocationARMGenerator returns a generator of WebTestGeolocationARM instances for property testing.
func WebTestGeolocationARMGenerator() gopter.Gen {
	if webTestGeolocationARMGenerator != nil {
		return webTestGeolocationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebTestGeolocationARM(generators)
	webTestGeolocationARMGenerator = gen.Struct(reflect.TypeOf(WebTestGeolocationARM{}), generators)

	return webTestGeolocationARMGenerator
}

// AddIndependentPropertyGeneratorsForWebTestGeolocationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebTestGeolocationARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_WebTestPropertiesConfigurationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebTestPropertiesConfigurationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebTestPropertiesConfigurationARM, WebTestPropertiesConfigurationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebTestPropertiesConfigurationARM runs a test to see if a specific instance of WebTestPropertiesConfigurationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWebTestPropertiesConfigurationARM(subject WebTestPropertiesConfigurationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebTestPropertiesConfigurationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebTestPropertiesConfigurationARM instances for property testing - lazily instantiated by
// WebTestPropertiesConfigurationARMGenerator()
var webTestPropertiesConfigurationARMGenerator gopter.Gen

// WebTestPropertiesConfigurationARMGenerator returns a generator of WebTestPropertiesConfigurationARM instances for property testing.
func WebTestPropertiesConfigurationARMGenerator() gopter.Gen {
	if webTestPropertiesConfigurationARMGenerator != nil {
		return webTestPropertiesConfigurationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebTestPropertiesConfigurationARM(generators)
	webTestPropertiesConfigurationARMGenerator = gen.Struct(reflect.TypeOf(WebTestPropertiesConfigurationARM{}), generators)

	return webTestPropertiesConfigurationARMGenerator
}

// AddIndependentPropertyGeneratorsForWebTestPropertiesConfigurationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebTestPropertiesConfigurationARM(gens map[string]gopter.Gen) {
	gens["WebTest"] = gen.PtrOf(gen.AlphaString())
}

func Test_WebTestPropertiesRequestARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebTestPropertiesRequestARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebTestPropertiesRequestARM, WebTestPropertiesRequestARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebTestPropertiesRequestARM runs a test to see if a specific instance of WebTestPropertiesRequestARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWebTestPropertiesRequestARM(subject WebTestPropertiesRequestARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebTestPropertiesRequestARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebTestPropertiesRequestARM instances for property testing - lazily instantiated by
// WebTestPropertiesRequestARMGenerator()
var webTestPropertiesRequestARMGenerator gopter.Gen

// WebTestPropertiesRequestARMGenerator returns a generator of WebTestPropertiesRequestARM instances for property testing.
// We first initialize webTestPropertiesRequestARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WebTestPropertiesRequestARMGenerator() gopter.Gen {
	if webTestPropertiesRequestARMGenerator != nil {
		return webTestPropertiesRequestARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebTestPropertiesRequestARM(generators)
	webTestPropertiesRequestARMGenerator = gen.Struct(reflect.TypeOf(WebTestPropertiesRequestARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebTestPropertiesRequestARM(generators)
	AddRelatedPropertyGeneratorsForWebTestPropertiesRequestARM(generators)
	webTestPropertiesRequestARMGenerator = gen.Struct(reflect.TypeOf(WebTestPropertiesRequestARM{}), generators)

	return webTestPropertiesRequestARMGenerator
}

// AddIndependentPropertyGeneratorsForWebTestPropertiesRequestARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebTestPropertiesRequestARM(gens map[string]gopter.Gen) {
	gens["FollowRedirects"] = gen.PtrOf(gen.Bool())
	gens["HttpVerb"] = gen.PtrOf(gen.AlphaString())
	gens["ParseDependentRequests"] = gen.PtrOf(gen.Bool())
	gens["RequestBody"] = gen.PtrOf(gen.AlphaString())
	gens["RequestUrl"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForWebTestPropertiesRequestARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWebTestPropertiesRequestARM(gens map[string]gopter.Gen) {
	gens["Headers"] = gen.SliceOf(HeaderFieldARMGenerator())
}

func Test_WebTestPropertiesValidationRulesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebTestPropertiesValidationRulesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebTestPropertiesValidationRulesARM, WebTestPropertiesValidationRulesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebTestPropertiesValidationRulesARM runs a test to see if a specific instance of WebTestPropertiesValidationRulesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWebTestPropertiesValidationRulesARM(subject WebTestPropertiesValidationRulesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebTestPropertiesValidationRulesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebTestPropertiesValidationRulesARM instances for property testing - lazily instantiated by
// WebTestPropertiesValidationRulesARMGenerator()
var webTestPropertiesValidationRulesARMGenerator gopter.Gen

// WebTestPropertiesValidationRulesARMGenerator returns a generator of WebTestPropertiesValidationRulesARM instances for property testing.
// We first initialize webTestPropertiesValidationRulesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WebTestPropertiesValidationRulesARMGenerator() gopter.Gen {
	if webTestPropertiesValidationRulesARMGenerator != nil {
		return webTestPropertiesValidationRulesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebTestPropertiesValidationRulesARM(generators)
	webTestPropertiesValidationRulesARMGenerator = gen.Struct(reflect.TypeOf(WebTestPropertiesValidationRulesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebTestPropertiesValidationRulesARM(generators)
	AddRelatedPropertyGeneratorsForWebTestPropertiesValidationRulesARM(generators)
	webTestPropertiesValidationRulesARMGenerator = gen.Struct(reflect.TypeOf(WebTestPropertiesValidationRulesARM{}), generators)

	return webTestPropertiesValidationRulesARMGenerator
}

// AddIndependentPropertyGeneratorsForWebTestPropertiesValidationRulesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebTestPropertiesValidationRulesARM(gens map[string]gopter.Gen) {
	gens["ExpectedHttpStatusCode"] = gen.PtrOf(gen.Int())
	gens["IgnoreHttpsStatusCode"] = gen.PtrOf(gen.Bool())
	gens["SSLCertRemainingLifetimeCheck"] = gen.PtrOf(gen.Int())
	gens["SSLCheck"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForWebTestPropertiesValidationRulesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWebTestPropertiesValidationRulesARM(gens map[string]gopter.Gen) {
	gens["ContentValidation"] = gen.PtrOf(WebTestPropertiesValidationRulesContentValidationARMGenerator())
}

func Test_HeaderFieldARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HeaderFieldARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHeaderFieldARM, HeaderFieldARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHeaderFieldARM runs a test to see if a specific instance of HeaderFieldARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHeaderFieldARM(subject HeaderFieldARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HeaderFieldARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HeaderFieldARM instances for property testing - lazily instantiated by HeaderFieldARMGenerator()
var headerFieldARMGenerator gopter.Gen

// HeaderFieldARMGenerator returns a generator of HeaderFieldARM instances for property testing.
func HeaderFieldARMGenerator() gopter.Gen {
	if headerFieldARMGenerator != nil {
		return headerFieldARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHeaderFieldARM(generators)
	headerFieldARMGenerator = gen.Struct(reflect.TypeOf(HeaderFieldARM{}), generators)

	return headerFieldARMGenerator
}

// AddIndependentPropertyGeneratorsForHeaderFieldARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHeaderFieldARM(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_WebTestPropertiesValidationRulesContentValidationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebTestPropertiesValidationRulesContentValidationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebTestPropertiesValidationRulesContentValidationARM, WebTestPropertiesValidationRulesContentValidationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebTestPropertiesValidationRulesContentValidationARM runs a test to see if a specific instance of WebTestPropertiesValidationRulesContentValidationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWebTestPropertiesValidationRulesContentValidationARM(subject WebTestPropertiesValidationRulesContentValidationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebTestPropertiesValidationRulesContentValidationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebTestPropertiesValidationRulesContentValidationARM instances for property testing - lazily
// instantiated by WebTestPropertiesValidationRulesContentValidationARMGenerator()
var webTestPropertiesValidationRulesContentValidationARMGenerator gopter.Gen

// WebTestPropertiesValidationRulesContentValidationARMGenerator returns a generator of WebTestPropertiesValidationRulesContentValidationARM instances for property testing.
func WebTestPropertiesValidationRulesContentValidationARMGenerator() gopter.Gen {
	if webTestPropertiesValidationRulesContentValidationARMGenerator != nil {
		return webTestPropertiesValidationRulesContentValidationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebTestPropertiesValidationRulesContentValidationARM(generators)
	webTestPropertiesValidationRulesContentValidationARMGenerator = gen.Struct(reflect.TypeOf(WebTestPropertiesValidationRulesContentValidationARM{}), generators)

	return webTestPropertiesValidationRulesContentValidationARMGenerator
}

// AddIndependentPropertyGeneratorsForWebTestPropertiesValidationRulesContentValidationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebTestPropertiesValidationRulesContentValidationARM(gens map[string]gopter.Gen) {
	gens["ContentMatch"] = gen.PtrOf(gen.AlphaString())
	gens["IgnoreCase"] = gen.PtrOf(gen.Bool())
	gens["PassIfTextFound"] = gen.PtrOf(gen.Bool())
}
