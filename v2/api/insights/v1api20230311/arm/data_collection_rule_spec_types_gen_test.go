// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package arm

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_AdxDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdxDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdxDestination, AdxDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdxDestination runs a test to see if a specific instance of AdxDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForAdxDestination(subject AdxDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdxDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdxDestination instances for property testing - lazily instantiated by AdxDestinationGenerator()
var adxDestinationGenerator gopter.Gen

// AdxDestinationGenerator returns a generator of AdxDestination instances for property testing.
func AdxDestinationGenerator() gopter.Gen {
	if adxDestinationGenerator != nil {
		return adxDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdxDestination(generators)
	adxDestinationGenerator = gen.Struct(reflect.TypeOf(AdxDestination{}), generators)

	return adxDestinationGenerator
}

// AddIndependentPropertyGeneratorsForAdxDestination is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdxDestination(gens map[string]gopter.Gen) {
	gens["DatabaseName"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_AgentSetting_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AgentSetting via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAgentSetting, AgentSettingGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAgentSetting runs a test to see if a specific instance of AgentSetting round trips to JSON and back losslessly
func RunJSONSerializationTestForAgentSetting(subject AgentSetting) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AgentSetting
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AgentSetting instances for property testing - lazily instantiated by AgentSettingGenerator()
var agentSettingGenerator gopter.Gen

// AgentSettingGenerator returns a generator of AgentSetting instances for property testing.
func AgentSettingGenerator() gopter.Gen {
	if agentSettingGenerator != nil {
		return agentSettingGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAgentSetting(generators)
	agentSettingGenerator = gen.Struct(reflect.TypeOf(AgentSetting{}), generators)

	return agentSettingGenerator
}

// AddIndependentPropertyGeneratorsForAgentSetting is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAgentSetting(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(AgentSetting_Name_MaxDiskQuotaInMB, AgentSetting_Name_UseTimeReceivedForForwardedEvents))
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_AgentSettingsSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AgentSettingsSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAgentSettingsSpec, AgentSettingsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAgentSettingsSpec runs a test to see if a specific instance of AgentSettingsSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForAgentSettingsSpec(subject AgentSettingsSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AgentSettingsSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AgentSettingsSpec instances for property testing - lazily instantiated by AgentSettingsSpecGenerator()
var agentSettingsSpecGenerator gopter.Gen

// AgentSettingsSpecGenerator returns a generator of AgentSettingsSpec instances for property testing.
func AgentSettingsSpecGenerator() gopter.Gen {
	if agentSettingsSpecGenerator != nil {
		return agentSettingsSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForAgentSettingsSpec(generators)
	agentSettingsSpecGenerator = gen.Struct(reflect.TypeOf(AgentSettingsSpec{}), generators)

	return agentSettingsSpecGenerator
}

// AddRelatedPropertyGeneratorsForAgentSettingsSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAgentSettingsSpec(gens map[string]gopter.Gen) {
	gens["Logs"] = gen.SliceOf(AgentSettingGenerator())
}

func Test_AzureMonitorMetricsDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureMonitorMetricsDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureMonitorMetricsDestination, AzureMonitorMetricsDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureMonitorMetricsDestination runs a test to see if a specific instance of AzureMonitorMetricsDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureMonitorMetricsDestination(subject AzureMonitorMetricsDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureMonitorMetricsDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureMonitorMetricsDestination instances for property testing - lazily instantiated by
// AzureMonitorMetricsDestinationGenerator()
var azureMonitorMetricsDestinationGenerator gopter.Gen

// AzureMonitorMetricsDestinationGenerator returns a generator of AzureMonitorMetricsDestination instances for property testing.
func AzureMonitorMetricsDestinationGenerator() gopter.Gen {
	if azureMonitorMetricsDestinationGenerator != nil {
		return azureMonitorMetricsDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureMonitorMetricsDestination(generators)
	azureMonitorMetricsDestinationGenerator = gen.Struct(reflect.TypeOf(AzureMonitorMetricsDestination{}), generators)

	return azureMonitorMetricsDestinationGenerator
}

// AddIndependentPropertyGeneratorsForAzureMonitorMetricsDestination is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureMonitorMetricsDestination(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_ColumnDefinition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ColumnDefinition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForColumnDefinition, ColumnDefinitionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForColumnDefinition runs a test to see if a specific instance of ColumnDefinition round trips to JSON and back losslessly
func RunJSONSerializationTestForColumnDefinition(subject ColumnDefinition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ColumnDefinition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ColumnDefinition instances for property testing - lazily instantiated by ColumnDefinitionGenerator()
var columnDefinitionGenerator gopter.Gen

// ColumnDefinitionGenerator returns a generator of ColumnDefinition instances for property testing.
func ColumnDefinitionGenerator() gopter.Gen {
	if columnDefinitionGenerator != nil {
		return columnDefinitionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForColumnDefinition(generators)
	columnDefinitionGenerator = gen.Struct(reflect.TypeOf(ColumnDefinition{}), generators)

	return columnDefinitionGenerator
}

// AddIndependentPropertyGeneratorsForColumnDefinition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForColumnDefinition(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ColumnDefinition_Type_Boolean,
		ColumnDefinition_Type_Datetime,
		ColumnDefinition_Type_Dynamic,
		ColumnDefinition_Type_Int,
		ColumnDefinition_Type_Long,
		ColumnDefinition_Type_Real,
		ColumnDefinition_Type_String))
}

func Test_DataCollectionRuleSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataCollectionRuleSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataCollectionRuleSpec, DataCollectionRuleSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataCollectionRuleSpec runs a test to see if a specific instance of DataCollectionRuleSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForDataCollectionRuleSpec(subject DataCollectionRuleSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataCollectionRuleSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataCollectionRuleSpec instances for property testing - lazily instantiated by
// DataCollectionRuleSpecGenerator()
var dataCollectionRuleSpecGenerator gopter.Gen

// DataCollectionRuleSpecGenerator returns a generator of DataCollectionRuleSpec instances for property testing.
// We first initialize dataCollectionRuleSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DataCollectionRuleSpecGenerator() gopter.Gen {
	if dataCollectionRuleSpecGenerator != nil {
		return dataCollectionRuleSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataCollectionRuleSpec(generators)
	dataCollectionRuleSpecGenerator = gen.Struct(reflect.TypeOf(DataCollectionRuleSpec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataCollectionRuleSpec(generators)
	AddRelatedPropertyGeneratorsForDataCollectionRuleSpec(generators)
	dataCollectionRuleSpecGenerator = gen.Struct(reflect.TypeOf(DataCollectionRuleSpec{}), generators)

	return dataCollectionRuleSpecGenerator
}

// AddIndependentPropertyGeneratorsForDataCollectionRuleSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDataCollectionRuleSpec(gens map[string]gopter.Gen) {
	gens["DataCollectionEndpointId"] = gen.PtrOf(gen.AlphaString())
	gens["Description"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDataCollectionRuleSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataCollectionRuleSpec(gens map[string]gopter.Gen) {
	gens["AgentSettings"] = gen.PtrOf(AgentSettingsSpecGenerator())
	gens["DataFlows"] = gen.SliceOf(DataFlowGenerator())
	gens["DataSources"] = gen.PtrOf(DataSourcesSpecGenerator())
	gens["Destinations"] = gen.PtrOf(DestinationsSpecGenerator())
	gens["References"] = gen.PtrOf(ReferencesSpecGenerator())
	gens["StreamDeclarations"] = gen.MapOf(
		gen.AlphaString(),
		StreamDeclarationGenerator())
}

func Test_DataCollectionRule_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataCollectionRule_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataCollectionRule_Spec, DataCollectionRule_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataCollectionRule_Spec runs a test to see if a specific instance of DataCollectionRule_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForDataCollectionRule_Spec(subject DataCollectionRule_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataCollectionRule_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataCollectionRule_Spec instances for property testing - lazily instantiated by
// DataCollectionRule_SpecGenerator()
var dataCollectionRule_SpecGenerator gopter.Gen

// DataCollectionRule_SpecGenerator returns a generator of DataCollectionRule_Spec instances for property testing.
// We first initialize dataCollectionRule_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DataCollectionRule_SpecGenerator() gopter.Gen {
	if dataCollectionRule_SpecGenerator != nil {
		return dataCollectionRule_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataCollectionRule_Spec(generators)
	dataCollectionRule_SpecGenerator = gen.Struct(reflect.TypeOf(DataCollectionRule_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataCollectionRule_Spec(generators)
	AddRelatedPropertyGeneratorsForDataCollectionRule_Spec(generators)
	dataCollectionRule_SpecGenerator = gen.Struct(reflect.TypeOf(DataCollectionRule_Spec{}), generators)

	return dataCollectionRule_SpecGenerator
}

// AddIndependentPropertyGeneratorsForDataCollectionRule_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDataCollectionRule_Spec(gens map[string]gopter.Gen) {
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(DataCollectionRule_Kind_Spec_Linux, DataCollectionRule_Kind_Spec_Windows))
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDataCollectionRule_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataCollectionRule_Spec(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedServiceIdentityGenerator())
	gens["Properties"] = gen.PtrOf(DataCollectionRuleSpecGenerator())
}

func Test_DataFlow_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataFlow via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataFlow, DataFlowGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataFlow runs a test to see if a specific instance of DataFlow round trips to JSON and back losslessly
func RunJSONSerializationTestForDataFlow(subject DataFlow) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataFlow
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataFlow instances for property testing - lazily instantiated by DataFlowGenerator()
var dataFlowGenerator gopter.Gen

// DataFlowGenerator returns a generator of DataFlow instances for property testing.
func DataFlowGenerator() gopter.Gen {
	if dataFlowGenerator != nil {
		return dataFlowGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataFlow(generators)
	dataFlowGenerator = gen.Struct(reflect.TypeOf(DataFlow{}), generators)

	return dataFlowGenerator
}

// AddIndependentPropertyGeneratorsForDataFlow is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDataFlow(gens map[string]gopter.Gen) {
	gens["BuiltInTransform"] = gen.PtrOf(gen.AlphaString())
	gens["CaptureOverflow"] = gen.PtrOf(gen.Bool())
	gens["Destinations"] = gen.SliceOf(gen.AlphaString())
	gens["OutputStream"] = gen.PtrOf(gen.AlphaString())
	gens["Streams"] = gen.SliceOf(gen.OneConstOf(
		DataFlow_Streams_MicrosoftEvent,
		DataFlow_Streams_MicrosoftInsightsMetrics,
		DataFlow_Streams_MicrosoftPerf,
		DataFlow_Streams_MicrosoftSyslog,
		DataFlow_Streams_MicrosoftWindowsEvent))
	gens["TransformKql"] = gen.PtrOf(gen.AlphaString())
}

func Test_DataImportSources_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataImportSources via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataImportSources, DataImportSourcesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataImportSources runs a test to see if a specific instance of DataImportSources round trips to JSON and back losslessly
func RunJSONSerializationTestForDataImportSources(subject DataImportSources) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataImportSources
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataImportSources instances for property testing - lazily instantiated by DataImportSourcesGenerator()
var dataImportSourcesGenerator gopter.Gen

// DataImportSourcesGenerator returns a generator of DataImportSources instances for property testing.
func DataImportSourcesGenerator() gopter.Gen {
	if dataImportSourcesGenerator != nil {
		return dataImportSourcesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDataImportSources(generators)
	dataImportSourcesGenerator = gen.Struct(reflect.TypeOf(DataImportSources{}), generators)

	return dataImportSourcesGenerator
}

// AddRelatedPropertyGeneratorsForDataImportSources is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataImportSources(gens map[string]gopter.Gen) {
	gens["EventHub"] = gen.PtrOf(EventHubDataSourceGenerator())
}

func Test_DataSourcesSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataSourcesSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataSourcesSpec, DataSourcesSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataSourcesSpec runs a test to see if a specific instance of DataSourcesSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForDataSourcesSpec(subject DataSourcesSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataSourcesSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataSourcesSpec instances for property testing - lazily instantiated by DataSourcesSpecGenerator()
var dataSourcesSpecGenerator gopter.Gen

// DataSourcesSpecGenerator returns a generator of DataSourcesSpec instances for property testing.
func DataSourcesSpecGenerator() gopter.Gen {
	if dataSourcesSpecGenerator != nil {
		return dataSourcesSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDataSourcesSpec(generators)
	dataSourcesSpecGenerator = gen.Struct(reflect.TypeOf(DataSourcesSpec{}), generators)

	return dataSourcesSpecGenerator
}

// AddRelatedPropertyGeneratorsForDataSourcesSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataSourcesSpec(gens map[string]gopter.Gen) {
	gens["DataImports"] = gen.PtrOf(DataImportSourcesGenerator())
	gens["Extensions"] = gen.SliceOf(ExtensionDataSourceGenerator())
	gens["IisLogs"] = gen.SliceOf(IisLogsDataSourceGenerator())
	gens["LogFiles"] = gen.SliceOf(LogFilesDataSourceGenerator())
	gens["PerformanceCounters"] = gen.SliceOf(PerfCounterDataSourceGenerator())
	gens["PlatformTelemetry"] = gen.SliceOf(PlatformTelemetryDataSourceGenerator())
	gens["PrometheusForwarder"] = gen.SliceOf(PrometheusForwarderDataSourceGenerator())
	gens["Syslog"] = gen.SliceOf(SyslogDataSourceGenerator())
	gens["WindowsEventLogs"] = gen.SliceOf(WindowsEventLogDataSourceGenerator())
	gens["WindowsFirewallLogs"] = gen.SliceOf(WindowsFirewallLogsDataSourceGenerator())
}

func Test_DestinationsSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DestinationsSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDestinationsSpec, DestinationsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDestinationsSpec runs a test to see if a specific instance of DestinationsSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForDestinationsSpec(subject DestinationsSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DestinationsSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DestinationsSpec instances for property testing - lazily instantiated by DestinationsSpecGenerator()
var destinationsSpecGenerator gopter.Gen

// DestinationsSpecGenerator returns a generator of DestinationsSpec instances for property testing.
func DestinationsSpecGenerator() gopter.Gen {
	if destinationsSpecGenerator != nil {
		return destinationsSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDestinationsSpec(generators)
	destinationsSpecGenerator = gen.Struct(reflect.TypeOf(DestinationsSpec{}), generators)

	return destinationsSpecGenerator
}

// AddRelatedPropertyGeneratorsForDestinationsSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDestinationsSpec(gens map[string]gopter.Gen) {
	gens["AzureDataExplorer"] = gen.SliceOf(AdxDestinationGenerator())
	gens["AzureMonitorMetrics"] = gen.PtrOf(AzureMonitorMetricsDestinationGenerator())
	gens["EventHubs"] = gen.SliceOf(EventHubDestinationGenerator())
	gens["EventHubsDirect"] = gen.SliceOf(EventHubDirectDestinationGenerator())
	gens["LogAnalytics"] = gen.SliceOf(LogAnalyticsDestinationGenerator())
	gens["MicrosoftFabric"] = gen.SliceOf(MicrosoftFabricDestinationGenerator())
	gens["MonitoringAccounts"] = gen.SliceOf(MonitoringAccountDestinationGenerator())
	gens["StorageAccounts"] = gen.SliceOf(StorageBlobDestinationGenerator())
	gens["StorageBlobsDirect"] = gen.SliceOf(StorageBlobDestinationGenerator())
	gens["StorageTablesDirect"] = gen.SliceOf(StorageTableDestinationGenerator())
}

func Test_EnrichmentData_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EnrichmentData via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEnrichmentData, EnrichmentDataGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEnrichmentData runs a test to see if a specific instance of EnrichmentData round trips to JSON and back losslessly
func RunJSONSerializationTestForEnrichmentData(subject EnrichmentData) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EnrichmentData
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EnrichmentData instances for property testing - lazily instantiated by EnrichmentDataGenerator()
var enrichmentDataGenerator gopter.Gen

// EnrichmentDataGenerator returns a generator of EnrichmentData instances for property testing.
func EnrichmentDataGenerator() gopter.Gen {
	if enrichmentDataGenerator != nil {
		return enrichmentDataGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForEnrichmentData(generators)
	enrichmentDataGenerator = gen.Struct(reflect.TypeOf(EnrichmentData{}), generators)

	return enrichmentDataGenerator
}

// AddRelatedPropertyGeneratorsForEnrichmentData is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEnrichmentData(gens map[string]gopter.Gen) {
	gens["StorageBlobs"] = gen.SliceOf(StorageBlobGenerator())
}

func Test_EventHubDataSource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventHubDataSource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventHubDataSource, EventHubDataSourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventHubDataSource runs a test to see if a specific instance of EventHubDataSource round trips to JSON and back losslessly
func RunJSONSerializationTestForEventHubDataSource(subject EventHubDataSource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventHubDataSource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventHubDataSource instances for property testing - lazily instantiated by EventHubDataSourceGenerator()
var eventHubDataSourceGenerator gopter.Gen

// EventHubDataSourceGenerator returns a generator of EventHubDataSource instances for property testing.
func EventHubDataSourceGenerator() gopter.Gen {
	if eventHubDataSourceGenerator != nil {
		return eventHubDataSourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventHubDataSource(generators)
	eventHubDataSourceGenerator = gen.Struct(reflect.TypeOf(EventHubDataSource{}), generators)

	return eventHubDataSourceGenerator
}

// AddIndependentPropertyGeneratorsForEventHubDataSource is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventHubDataSource(gens map[string]gopter.Gen) {
	gens["ConsumerGroup"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Stream"] = gen.PtrOf(gen.AlphaString())
}

func Test_EventHubDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventHubDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventHubDestination, EventHubDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventHubDestination runs a test to see if a specific instance of EventHubDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForEventHubDestination(subject EventHubDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventHubDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventHubDestination instances for property testing - lazily instantiated by
// EventHubDestinationGenerator()
var eventHubDestinationGenerator gopter.Gen

// EventHubDestinationGenerator returns a generator of EventHubDestination instances for property testing.
func EventHubDestinationGenerator() gopter.Gen {
	if eventHubDestinationGenerator != nil {
		return eventHubDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventHubDestination(generators)
	eventHubDestinationGenerator = gen.Struct(reflect.TypeOf(EventHubDestination{}), generators)

	return eventHubDestinationGenerator
}

// AddIndependentPropertyGeneratorsForEventHubDestination is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventHubDestination(gens map[string]gopter.Gen) {
	gens["EventHubResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_EventHubDirectDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventHubDirectDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventHubDirectDestination, EventHubDirectDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventHubDirectDestination runs a test to see if a specific instance of EventHubDirectDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForEventHubDirectDestination(subject EventHubDirectDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventHubDirectDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventHubDirectDestination instances for property testing - lazily instantiated by
// EventHubDirectDestinationGenerator()
var eventHubDirectDestinationGenerator gopter.Gen

// EventHubDirectDestinationGenerator returns a generator of EventHubDirectDestination instances for property testing.
func EventHubDirectDestinationGenerator() gopter.Gen {
	if eventHubDirectDestinationGenerator != nil {
		return eventHubDirectDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventHubDirectDestination(generators)
	eventHubDirectDestinationGenerator = gen.Struct(reflect.TypeOf(EventHubDirectDestination{}), generators)

	return eventHubDirectDestinationGenerator
}

// AddIndependentPropertyGeneratorsForEventHubDirectDestination is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventHubDirectDestination(gens map[string]gopter.Gen) {
	gens["EventHubResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_ExtensionDataSource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtensionDataSource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtensionDataSource, ExtensionDataSourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtensionDataSource runs a test to see if a specific instance of ExtensionDataSource round trips to JSON and back losslessly
func RunJSONSerializationTestForExtensionDataSource(subject ExtensionDataSource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtensionDataSource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtensionDataSource instances for property testing - lazily instantiated by
// ExtensionDataSourceGenerator()
var extensionDataSourceGenerator gopter.Gen

// ExtensionDataSourceGenerator returns a generator of ExtensionDataSource instances for property testing.
func ExtensionDataSourceGenerator() gopter.Gen {
	if extensionDataSourceGenerator != nil {
		return extensionDataSourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtensionDataSource(generators)
	extensionDataSourceGenerator = gen.Struct(reflect.TypeOf(ExtensionDataSource{}), generators)

	return extensionDataSourceGenerator
}

// AddIndependentPropertyGeneratorsForExtensionDataSource is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtensionDataSource(gens map[string]gopter.Gen) {
	gens["ExtensionName"] = gen.PtrOf(gen.AlphaString())
	gens["InputDataSources"] = gen.SliceOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Streams"] = gen.SliceOf(gen.OneConstOf(
		ExtensionDataSource_Streams_MicrosoftEvent,
		ExtensionDataSource_Streams_MicrosoftInsightsMetrics,
		ExtensionDataSource_Streams_MicrosoftPerf,
		ExtensionDataSource_Streams_MicrosoftSyslog,
		ExtensionDataSource_Streams_MicrosoftWindowsEvent))
}

func Test_IisLogsDataSource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IisLogsDataSource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIisLogsDataSource, IisLogsDataSourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIisLogsDataSource runs a test to see if a specific instance of IisLogsDataSource round trips to JSON and back losslessly
func RunJSONSerializationTestForIisLogsDataSource(subject IisLogsDataSource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IisLogsDataSource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IisLogsDataSource instances for property testing - lazily instantiated by IisLogsDataSourceGenerator()
var iisLogsDataSourceGenerator gopter.Gen

// IisLogsDataSourceGenerator returns a generator of IisLogsDataSource instances for property testing.
func IisLogsDataSourceGenerator() gopter.Gen {
	if iisLogsDataSourceGenerator != nil {
		return iisLogsDataSourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIisLogsDataSource(generators)
	iisLogsDataSourceGenerator = gen.Struct(reflect.TypeOf(IisLogsDataSource{}), generators)

	return iisLogsDataSourceGenerator
}

// AddIndependentPropertyGeneratorsForIisLogsDataSource is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIisLogsDataSource(gens map[string]gopter.Gen) {
	gens["LogDirectories"] = gen.SliceOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Streams"] = gen.SliceOf(gen.AlphaString())
	gens["TransformKql"] = gen.PtrOf(gen.AlphaString())
}

func Test_LogAnalyticsDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LogAnalyticsDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLogAnalyticsDestination, LogAnalyticsDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLogAnalyticsDestination runs a test to see if a specific instance of LogAnalyticsDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForLogAnalyticsDestination(subject LogAnalyticsDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LogAnalyticsDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LogAnalyticsDestination instances for property testing - lazily instantiated by
// LogAnalyticsDestinationGenerator()
var logAnalyticsDestinationGenerator gopter.Gen

// LogAnalyticsDestinationGenerator returns a generator of LogAnalyticsDestination instances for property testing.
func LogAnalyticsDestinationGenerator() gopter.Gen {
	if logAnalyticsDestinationGenerator != nil {
		return logAnalyticsDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLogAnalyticsDestination(generators)
	logAnalyticsDestinationGenerator = gen.Struct(reflect.TypeOf(LogAnalyticsDestination{}), generators)

	return logAnalyticsDestinationGenerator
}

// AddIndependentPropertyGeneratorsForLogAnalyticsDestination is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLogAnalyticsDestination(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["WorkspaceResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_LogFileSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LogFileSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLogFileSettings, LogFileSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLogFileSettings runs a test to see if a specific instance of LogFileSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForLogFileSettings(subject LogFileSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LogFileSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LogFileSettings instances for property testing - lazily instantiated by LogFileSettingsGenerator()
var logFileSettingsGenerator gopter.Gen

// LogFileSettingsGenerator returns a generator of LogFileSettings instances for property testing.
func LogFileSettingsGenerator() gopter.Gen {
	if logFileSettingsGenerator != nil {
		return logFileSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForLogFileSettings(generators)
	logFileSettingsGenerator = gen.Struct(reflect.TypeOf(LogFileSettings{}), generators)

	return logFileSettingsGenerator
}

// AddRelatedPropertyGeneratorsForLogFileSettings is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLogFileSettings(gens map[string]gopter.Gen) {
	gens["Text"] = gen.PtrOf(LogFileTextSettingsGenerator())
}

func Test_LogFileTextSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LogFileTextSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLogFileTextSettings, LogFileTextSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLogFileTextSettings runs a test to see if a specific instance of LogFileTextSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForLogFileTextSettings(subject LogFileTextSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LogFileTextSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LogFileTextSettings instances for property testing - lazily instantiated by
// LogFileTextSettingsGenerator()
var logFileTextSettingsGenerator gopter.Gen

// LogFileTextSettingsGenerator returns a generator of LogFileTextSettings instances for property testing.
func LogFileTextSettingsGenerator() gopter.Gen {
	if logFileTextSettingsGenerator != nil {
		return logFileTextSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLogFileTextSettings(generators)
	logFileTextSettingsGenerator = gen.Struct(reflect.TypeOf(LogFileTextSettings{}), generators)

	return logFileTextSettingsGenerator
}

// AddIndependentPropertyGeneratorsForLogFileTextSettings is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLogFileTextSettings(gens map[string]gopter.Gen) {
	gens["RecordStartTimestampFormat"] = gen.PtrOf(gen.OneConstOf(
		LogFileTextSettings_RecordStartTimestampFormat_DdMMMYyyyHHMmSsZzz,
		LogFileTextSettings_RecordStartTimestampFormat_DdMMyyHHMmSs,
		LogFileTextSettings_RecordStartTimestampFormat_ISO8601,
		LogFileTextSettings_RecordStartTimestampFormat_MDYYYYHHMMSSAMPM,
		LogFileTextSettings_RecordStartTimestampFormat_MMMDHhMmSs,
		LogFileTextSettings_RecordStartTimestampFormat_MonDDYYYYHHMMSS,
		LogFileTextSettings_RecordStartTimestampFormat_YYYYMMDDHHMMSS,
		LogFileTextSettings_RecordStartTimestampFormat_YyMMddHHMmSs,
		LogFileTextSettings_RecordStartTimestampFormat_YyyyMMDdTHHMmSsK))
}

func Test_LogFilesDataSource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LogFilesDataSource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLogFilesDataSource, LogFilesDataSourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLogFilesDataSource runs a test to see if a specific instance of LogFilesDataSource round trips to JSON and back losslessly
func RunJSONSerializationTestForLogFilesDataSource(subject LogFilesDataSource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LogFilesDataSource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LogFilesDataSource instances for property testing - lazily instantiated by LogFilesDataSourceGenerator()
var logFilesDataSourceGenerator gopter.Gen

// LogFilesDataSourceGenerator returns a generator of LogFilesDataSource instances for property testing.
// We first initialize logFilesDataSourceGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LogFilesDataSourceGenerator() gopter.Gen {
	if logFilesDataSourceGenerator != nil {
		return logFilesDataSourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLogFilesDataSource(generators)
	logFilesDataSourceGenerator = gen.Struct(reflect.TypeOf(LogFilesDataSource{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLogFilesDataSource(generators)
	AddRelatedPropertyGeneratorsForLogFilesDataSource(generators)
	logFilesDataSourceGenerator = gen.Struct(reflect.TypeOf(LogFilesDataSource{}), generators)

	return logFilesDataSourceGenerator
}

// AddIndependentPropertyGeneratorsForLogFilesDataSource is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLogFilesDataSource(gens map[string]gopter.Gen) {
	gens["FilePatterns"] = gen.SliceOf(gen.AlphaString())
	gens["Format"] = gen.PtrOf(gen.OneConstOf(LogFilesDataSource_Format_Json, LogFilesDataSource_Format_Text))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Streams"] = gen.SliceOf(gen.AlphaString())
	gens["TransformKql"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLogFilesDataSource is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLogFilesDataSource(gens map[string]gopter.Gen) {
	gens["Settings"] = gen.PtrOf(LogFileSettingsGenerator())
}

func Test_ManagedServiceIdentity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentity, ManagedServiceIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentity runs a test to see if a specific instance of ManagedServiceIdentity round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentity(subject ManagedServiceIdentity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity instances for property testing - lazily instantiated by
// ManagedServiceIdentityGenerator()
var managedServiceIdentityGenerator gopter.Gen

// ManagedServiceIdentityGenerator returns a generator of ManagedServiceIdentity instances for property testing.
// We first initialize managedServiceIdentityGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedServiceIdentityGenerator() gopter.Gen {
	if managedServiceIdentityGenerator != nil {
		return managedServiceIdentityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity(generators)
	managedServiceIdentityGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity(generators)
	AddRelatedPropertyGeneratorsForManagedServiceIdentity(generators)
	managedServiceIdentityGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity{}), generators)

	return managedServiceIdentityGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentity is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentity(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ManagedServiceIdentityType_None,
		ManagedServiceIdentityType_SystemAssigned,
		ManagedServiceIdentityType_SystemAssignedUserAssigned,
		ManagedServiceIdentityType_UserAssigned))
}

// AddRelatedPropertyGeneratorsForManagedServiceIdentity is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedServiceIdentity(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(
		gen.AlphaString(),
		UserAssignedIdentityDetailsGenerator())
}

func Test_MicrosoftFabricDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MicrosoftFabricDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMicrosoftFabricDestination, MicrosoftFabricDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMicrosoftFabricDestination runs a test to see if a specific instance of MicrosoftFabricDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForMicrosoftFabricDestination(subject MicrosoftFabricDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MicrosoftFabricDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MicrosoftFabricDestination instances for property testing - lazily instantiated by
// MicrosoftFabricDestinationGenerator()
var microsoftFabricDestinationGenerator gopter.Gen

// MicrosoftFabricDestinationGenerator returns a generator of MicrosoftFabricDestination instances for property testing.
func MicrosoftFabricDestinationGenerator() gopter.Gen {
	if microsoftFabricDestinationGenerator != nil {
		return microsoftFabricDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMicrosoftFabricDestination(generators)
	microsoftFabricDestinationGenerator = gen.Struct(reflect.TypeOf(MicrosoftFabricDestination{}), generators)

	return microsoftFabricDestinationGenerator
}

// AddIndependentPropertyGeneratorsForMicrosoftFabricDestination is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMicrosoftFabricDestination(gens map[string]gopter.Gen) {
	gens["ArtifactId"] = gen.PtrOf(gen.AlphaString())
	gens["DatabaseName"] = gen.PtrOf(gen.AlphaString())
	gens["IngestionUri"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
}

func Test_MonitoringAccountDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MonitoringAccountDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMonitoringAccountDestination, MonitoringAccountDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMonitoringAccountDestination runs a test to see if a specific instance of MonitoringAccountDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForMonitoringAccountDestination(subject MonitoringAccountDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MonitoringAccountDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MonitoringAccountDestination instances for property testing - lazily instantiated by
// MonitoringAccountDestinationGenerator()
var monitoringAccountDestinationGenerator gopter.Gen

// MonitoringAccountDestinationGenerator returns a generator of MonitoringAccountDestination instances for property testing.
func MonitoringAccountDestinationGenerator() gopter.Gen {
	if monitoringAccountDestinationGenerator != nil {
		return monitoringAccountDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMonitoringAccountDestination(generators)
	monitoringAccountDestinationGenerator = gen.Struct(reflect.TypeOf(MonitoringAccountDestination{}), generators)

	return monitoringAccountDestinationGenerator
}

// AddIndependentPropertyGeneratorsForMonitoringAccountDestination is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMonitoringAccountDestination(gens map[string]gopter.Gen) {
	gens["AccountResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_PerfCounterDataSource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PerfCounterDataSource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPerfCounterDataSource, PerfCounterDataSourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPerfCounterDataSource runs a test to see if a specific instance of PerfCounterDataSource round trips to JSON and back losslessly
func RunJSONSerializationTestForPerfCounterDataSource(subject PerfCounterDataSource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PerfCounterDataSource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PerfCounterDataSource instances for property testing - lazily instantiated by
// PerfCounterDataSourceGenerator()
var perfCounterDataSourceGenerator gopter.Gen

// PerfCounterDataSourceGenerator returns a generator of PerfCounterDataSource instances for property testing.
func PerfCounterDataSourceGenerator() gopter.Gen {
	if perfCounterDataSourceGenerator != nil {
		return perfCounterDataSourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPerfCounterDataSource(generators)
	perfCounterDataSourceGenerator = gen.Struct(reflect.TypeOf(PerfCounterDataSource{}), generators)

	return perfCounterDataSourceGenerator
}

// AddIndependentPropertyGeneratorsForPerfCounterDataSource is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPerfCounterDataSource(gens map[string]gopter.Gen) {
	gens["CounterSpecifiers"] = gen.SliceOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["SamplingFrequencyInSeconds"] = gen.PtrOf(gen.Int())
	gens["Streams"] = gen.SliceOf(gen.OneConstOf(PerfCounterDataSource_Streams_MicrosoftInsightsMetrics, PerfCounterDataSource_Streams_MicrosoftPerf))
	gens["TransformKql"] = gen.PtrOf(gen.AlphaString())
}

func Test_PlatformTelemetryDataSource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PlatformTelemetryDataSource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPlatformTelemetryDataSource, PlatformTelemetryDataSourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPlatformTelemetryDataSource runs a test to see if a specific instance of PlatformTelemetryDataSource round trips to JSON and back losslessly
func RunJSONSerializationTestForPlatformTelemetryDataSource(subject PlatformTelemetryDataSource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PlatformTelemetryDataSource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PlatformTelemetryDataSource instances for property testing - lazily instantiated by
// PlatformTelemetryDataSourceGenerator()
var platformTelemetryDataSourceGenerator gopter.Gen

// PlatformTelemetryDataSourceGenerator returns a generator of PlatformTelemetryDataSource instances for property testing.
func PlatformTelemetryDataSourceGenerator() gopter.Gen {
	if platformTelemetryDataSourceGenerator != nil {
		return platformTelemetryDataSourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPlatformTelemetryDataSource(generators)
	platformTelemetryDataSourceGenerator = gen.Struct(reflect.TypeOf(PlatformTelemetryDataSource{}), generators)

	return platformTelemetryDataSourceGenerator
}

// AddIndependentPropertyGeneratorsForPlatformTelemetryDataSource is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPlatformTelemetryDataSource(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Streams"] = gen.SliceOf(gen.AlphaString())
}

func Test_PrometheusForwarderDataSource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrometheusForwarderDataSource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrometheusForwarderDataSource, PrometheusForwarderDataSourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrometheusForwarderDataSource runs a test to see if a specific instance of PrometheusForwarderDataSource round trips to JSON and back losslessly
func RunJSONSerializationTestForPrometheusForwarderDataSource(subject PrometheusForwarderDataSource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrometheusForwarderDataSource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrometheusForwarderDataSource instances for property testing - lazily instantiated by
// PrometheusForwarderDataSourceGenerator()
var prometheusForwarderDataSourceGenerator gopter.Gen

// PrometheusForwarderDataSourceGenerator returns a generator of PrometheusForwarderDataSource instances for property testing.
func PrometheusForwarderDataSourceGenerator() gopter.Gen {
	if prometheusForwarderDataSourceGenerator != nil {
		return prometheusForwarderDataSourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrometheusForwarderDataSource(generators)
	prometheusForwarderDataSourceGenerator = gen.Struct(reflect.TypeOf(PrometheusForwarderDataSource{}), generators)

	return prometheusForwarderDataSourceGenerator
}

// AddIndependentPropertyGeneratorsForPrometheusForwarderDataSource is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrometheusForwarderDataSource(gens map[string]gopter.Gen) {
	gens["LabelIncludeFilter"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Streams"] = gen.SliceOf(gen.OneConstOf(PrometheusForwarderDataSource_Streams_MicrosoftPrometheusMetrics))
}

func Test_ReferencesSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ReferencesSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForReferencesSpec, ReferencesSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForReferencesSpec runs a test to see if a specific instance of ReferencesSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForReferencesSpec(subject ReferencesSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ReferencesSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ReferencesSpec instances for property testing - lazily instantiated by ReferencesSpecGenerator()
var referencesSpecGenerator gopter.Gen

// ReferencesSpecGenerator returns a generator of ReferencesSpec instances for property testing.
func ReferencesSpecGenerator() gopter.Gen {
	if referencesSpecGenerator != nil {
		return referencesSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForReferencesSpec(generators)
	referencesSpecGenerator = gen.Struct(reflect.TypeOf(ReferencesSpec{}), generators)

	return referencesSpecGenerator
}

// AddRelatedPropertyGeneratorsForReferencesSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForReferencesSpec(gens map[string]gopter.Gen) {
	gens["EnrichmentData"] = gen.PtrOf(EnrichmentDataGenerator())
}

func Test_StorageBlob_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageBlob via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageBlob, StorageBlobGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageBlob runs a test to see if a specific instance of StorageBlob round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageBlob(subject StorageBlob) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageBlob
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageBlob instances for property testing - lazily instantiated by StorageBlobGenerator()
var storageBlobGenerator gopter.Gen

// StorageBlobGenerator returns a generator of StorageBlob instances for property testing.
func StorageBlobGenerator() gopter.Gen {
	if storageBlobGenerator != nil {
		return storageBlobGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageBlob(generators)
	storageBlobGenerator = gen.Struct(reflect.TypeOf(StorageBlob{}), generators)

	return storageBlobGenerator
}

// AddIndependentPropertyGeneratorsForStorageBlob is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageBlob(gens map[string]gopter.Gen) {
	gens["BlobUrl"] = gen.PtrOf(gen.AlphaString())
	gens["LookupType"] = gen.PtrOf(gen.OneConstOf(StorageBlob_LookupType_Cidr, StorageBlob_LookupType_String))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_StorageBlobDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageBlobDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageBlobDestination, StorageBlobDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageBlobDestination runs a test to see if a specific instance of StorageBlobDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageBlobDestination(subject StorageBlobDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageBlobDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageBlobDestination instances for property testing - lazily instantiated by
// StorageBlobDestinationGenerator()
var storageBlobDestinationGenerator gopter.Gen

// StorageBlobDestinationGenerator returns a generator of StorageBlobDestination instances for property testing.
func StorageBlobDestinationGenerator() gopter.Gen {
	if storageBlobDestinationGenerator != nil {
		return storageBlobDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageBlobDestination(generators)
	storageBlobDestinationGenerator = gen.Struct(reflect.TypeOf(StorageBlobDestination{}), generators)

	return storageBlobDestinationGenerator
}

// AddIndependentPropertyGeneratorsForStorageBlobDestination is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageBlobDestination(gens map[string]gopter.Gen) {
	gens["ContainerName"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_StorageTableDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageTableDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageTableDestination, StorageTableDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageTableDestination runs a test to see if a specific instance of StorageTableDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageTableDestination(subject StorageTableDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageTableDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageTableDestination instances for property testing - lazily instantiated by
// StorageTableDestinationGenerator()
var storageTableDestinationGenerator gopter.Gen

// StorageTableDestinationGenerator returns a generator of StorageTableDestination instances for property testing.
func StorageTableDestinationGenerator() gopter.Gen {
	if storageTableDestinationGenerator != nil {
		return storageTableDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageTableDestination(generators)
	storageTableDestinationGenerator = gen.Struct(reflect.TypeOf(StorageTableDestination{}), generators)

	return storageTableDestinationGenerator
}

// AddIndependentPropertyGeneratorsForStorageTableDestination is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageTableDestination(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["TableName"] = gen.PtrOf(gen.AlphaString())
}

func Test_StreamDeclaration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StreamDeclaration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStreamDeclaration, StreamDeclarationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStreamDeclaration runs a test to see if a specific instance of StreamDeclaration round trips to JSON and back losslessly
func RunJSONSerializationTestForStreamDeclaration(subject StreamDeclaration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StreamDeclaration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StreamDeclaration instances for property testing - lazily instantiated by StreamDeclarationGenerator()
var streamDeclarationGenerator gopter.Gen

// StreamDeclarationGenerator returns a generator of StreamDeclaration instances for property testing.
func StreamDeclarationGenerator() gopter.Gen {
	if streamDeclarationGenerator != nil {
		return streamDeclarationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForStreamDeclaration(generators)
	streamDeclarationGenerator = gen.Struct(reflect.TypeOf(StreamDeclaration{}), generators)

	return streamDeclarationGenerator
}

// AddRelatedPropertyGeneratorsForStreamDeclaration is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStreamDeclaration(gens map[string]gopter.Gen) {
	gens["Columns"] = gen.SliceOf(ColumnDefinitionGenerator())
}

func Test_SyslogDataSource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SyslogDataSource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSyslogDataSource, SyslogDataSourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSyslogDataSource runs a test to see if a specific instance of SyslogDataSource round trips to JSON and back losslessly
func RunJSONSerializationTestForSyslogDataSource(subject SyslogDataSource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SyslogDataSource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SyslogDataSource instances for property testing - lazily instantiated by SyslogDataSourceGenerator()
var syslogDataSourceGenerator gopter.Gen

// SyslogDataSourceGenerator returns a generator of SyslogDataSource instances for property testing.
func SyslogDataSourceGenerator() gopter.Gen {
	if syslogDataSourceGenerator != nil {
		return syslogDataSourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSyslogDataSource(generators)
	syslogDataSourceGenerator = gen.Struct(reflect.TypeOf(SyslogDataSource{}), generators)

	return syslogDataSourceGenerator
}

// AddIndependentPropertyGeneratorsForSyslogDataSource is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSyslogDataSource(gens map[string]gopter.Gen) {
	gens["FacilityNames"] = gen.SliceOf(gen.OneConstOf(
		SyslogDataSource_FacilityNames_Alert,
		SyslogDataSource_FacilityNames_Audit,
		SyslogDataSource_FacilityNames_Auth,
		SyslogDataSource_FacilityNames_Authpriv,
		SyslogDataSource_FacilityNames_Clock,
		SyslogDataSource_FacilityNames_Cron,
		SyslogDataSource_FacilityNames_Daemon,
		SyslogDataSource_FacilityNames_Ftp,
		SyslogDataSource_FacilityNames_Kern,
		SyslogDataSource_FacilityNames_Local0,
		SyslogDataSource_FacilityNames_Local1,
		SyslogDataSource_FacilityNames_Local2,
		SyslogDataSource_FacilityNames_Local3,
		SyslogDataSource_FacilityNames_Local4,
		SyslogDataSource_FacilityNames_Local5,
		SyslogDataSource_FacilityNames_Local6,
		SyslogDataSource_FacilityNames_Local7,
		SyslogDataSource_FacilityNames_Lpr,
		SyslogDataSource_FacilityNames_Mail,
		SyslogDataSource_FacilityNames_Mark,
		SyslogDataSource_FacilityNames_News,
		SyslogDataSource_FacilityNames_Nopri,
		SyslogDataSource_FacilityNames_Ntp,
		SyslogDataSource_FacilityNames_Star,
		SyslogDataSource_FacilityNames_Syslog,
		SyslogDataSource_FacilityNames_User,
		SyslogDataSource_FacilityNames_Uucp))
	gens["LogLevels"] = gen.SliceOf(gen.OneConstOf(
		SyslogDataSource_LogLevels_Alert,
		SyslogDataSource_LogLevels_Critical,
		SyslogDataSource_LogLevels_Debug,
		SyslogDataSource_LogLevels_Emergency,
		SyslogDataSource_LogLevels_Error,
		SyslogDataSource_LogLevels_Info,
		SyslogDataSource_LogLevels_Notice,
		SyslogDataSource_LogLevels_Star,
		SyslogDataSource_LogLevels_Warning))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Streams"] = gen.SliceOf(gen.OneConstOf(SyslogDataSource_Streams_MicrosoftSyslog))
	gens["TransformKql"] = gen.PtrOf(gen.AlphaString())
}

func Test_UserAssignedIdentityDetails_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentityDetails via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentityDetails, UserAssignedIdentityDetailsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentityDetails runs a test to see if a specific instance of UserAssignedIdentityDetails round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentityDetails(subject UserAssignedIdentityDetails) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentityDetails
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentityDetails instances for property testing - lazily instantiated by
// UserAssignedIdentityDetailsGenerator()
var userAssignedIdentityDetailsGenerator gopter.Gen

// UserAssignedIdentityDetailsGenerator returns a generator of UserAssignedIdentityDetails instances for property testing.
func UserAssignedIdentityDetailsGenerator() gopter.Gen {
	if userAssignedIdentityDetailsGenerator != nil {
		return userAssignedIdentityDetailsGenerator
	}

	generators := make(map[string]gopter.Gen)
	userAssignedIdentityDetailsGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentityDetails{}), generators)

	return userAssignedIdentityDetailsGenerator
}

func Test_WindowsEventLogDataSource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WindowsEventLogDataSource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWindowsEventLogDataSource, WindowsEventLogDataSourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWindowsEventLogDataSource runs a test to see if a specific instance of WindowsEventLogDataSource round trips to JSON and back losslessly
func RunJSONSerializationTestForWindowsEventLogDataSource(subject WindowsEventLogDataSource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WindowsEventLogDataSource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WindowsEventLogDataSource instances for property testing - lazily instantiated by
// WindowsEventLogDataSourceGenerator()
var windowsEventLogDataSourceGenerator gopter.Gen

// WindowsEventLogDataSourceGenerator returns a generator of WindowsEventLogDataSource instances for property testing.
func WindowsEventLogDataSourceGenerator() gopter.Gen {
	if windowsEventLogDataSourceGenerator != nil {
		return windowsEventLogDataSourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsEventLogDataSource(generators)
	windowsEventLogDataSourceGenerator = gen.Struct(reflect.TypeOf(WindowsEventLogDataSource{}), generators)

	return windowsEventLogDataSourceGenerator
}

// AddIndependentPropertyGeneratorsForWindowsEventLogDataSource is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWindowsEventLogDataSource(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Streams"] = gen.SliceOf(gen.OneConstOf(WindowsEventLogDataSource_Streams_MicrosoftEvent, WindowsEventLogDataSource_Streams_MicrosoftWindowsEvent))
	gens["TransformKql"] = gen.PtrOf(gen.AlphaString())
	gens["XPathQueries"] = gen.SliceOf(gen.AlphaString())
}

func Test_WindowsFirewallLogsDataSource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WindowsFirewallLogsDataSource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWindowsFirewallLogsDataSource, WindowsFirewallLogsDataSourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWindowsFirewallLogsDataSource runs a test to see if a specific instance of WindowsFirewallLogsDataSource round trips to JSON and back losslessly
func RunJSONSerializationTestForWindowsFirewallLogsDataSource(subject WindowsFirewallLogsDataSource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WindowsFirewallLogsDataSource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WindowsFirewallLogsDataSource instances for property testing - lazily instantiated by
// WindowsFirewallLogsDataSourceGenerator()
var windowsFirewallLogsDataSourceGenerator gopter.Gen

// WindowsFirewallLogsDataSourceGenerator returns a generator of WindowsFirewallLogsDataSource instances for property testing.
func WindowsFirewallLogsDataSourceGenerator() gopter.Gen {
	if windowsFirewallLogsDataSourceGenerator != nil {
		return windowsFirewallLogsDataSourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsFirewallLogsDataSource(generators)
	windowsFirewallLogsDataSourceGenerator = gen.Struct(reflect.TypeOf(WindowsFirewallLogsDataSource{}), generators)

	return windowsFirewallLogsDataSourceGenerator
}

// AddIndependentPropertyGeneratorsForWindowsFirewallLogsDataSource is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWindowsFirewallLogsDataSource(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ProfileFilter"] = gen.SliceOf(gen.OneConstOf(WindowsFirewallLogsDataSource_ProfileFilter_Domain, WindowsFirewallLogsDataSource_ProfileFilter_Private, WindowsFirewallLogsDataSource_ProfileFilter_Public))
	gens["Streams"] = gen.SliceOf(gen.AlphaString())
}
