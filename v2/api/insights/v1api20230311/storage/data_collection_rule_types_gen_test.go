// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package storage

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_AdxDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdxDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdxDestination, AdxDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdxDestination runs a test to see if a specific instance of AdxDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForAdxDestination(subject AdxDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdxDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdxDestination instances for property testing - lazily instantiated by AdxDestinationGenerator()
var adxDestinationGenerator gopter.Gen

// AdxDestinationGenerator returns a generator of AdxDestination instances for property testing.
func AdxDestinationGenerator() gopter.Gen {
	if adxDestinationGenerator != nil {
		return adxDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdxDestination(generators)
	adxDestinationGenerator = gen.Struct(reflect.TypeOf(AdxDestination{}), generators)

	return adxDestinationGenerator
}

// AddIndependentPropertyGeneratorsForAdxDestination is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdxDestination(gens map[string]gopter.Gen) {
	gens["DatabaseName"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_AdxDestination_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdxDestination_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdxDestination_STATUS, AdxDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdxDestination_STATUS runs a test to see if a specific instance of AdxDestination_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAdxDestination_STATUS(subject AdxDestination_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdxDestination_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdxDestination_STATUS instances for property testing - lazily instantiated by
// AdxDestination_STATUSGenerator()
var adxDestination_STATUSGenerator gopter.Gen

// AdxDestination_STATUSGenerator returns a generator of AdxDestination_STATUS instances for property testing.
func AdxDestination_STATUSGenerator() gopter.Gen {
	if adxDestination_STATUSGenerator != nil {
		return adxDestination_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdxDestination_STATUS(generators)
	adxDestination_STATUSGenerator = gen.Struct(reflect.TypeOf(AdxDestination_STATUS{}), generators)

	return adxDestination_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAdxDestination_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdxDestination_STATUS(gens map[string]gopter.Gen) {
	gens["DatabaseName"] = gen.PtrOf(gen.AlphaString())
	gens["IngestionUri"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_AgentSetting_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AgentSetting via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAgentSetting, AgentSettingGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAgentSetting runs a test to see if a specific instance of AgentSetting round trips to JSON and back losslessly
func RunJSONSerializationTestForAgentSetting(subject AgentSetting) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AgentSetting
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AgentSetting instances for property testing - lazily instantiated by AgentSettingGenerator()
var agentSettingGenerator gopter.Gen

// AgentSettingGenerator returns a generator of AgentSetting instances for property testing.
func AgentSettingGenerator() gopter.Gen {
	if agentSettingGenerator != nil {
		return agentSettingGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAgentSetting(generators)
	agentSettingGenerator = gen.Struct(reflect.TypeOf(AgentSetting{}), generators)

	return agentSettingGenerator
}

// AddIndependentPropertyGeneratorsForAgentSetting is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAgentSetting(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_AgentSetting_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AgentSetting_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAgentSetting_STATUS, AgentSetting_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAgentSetting_STATUS runs a test to see if a specific instance of AgentSetting_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAgentSetting_STATUS(subject AgentSetting_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AgentSetting_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AgentSetting_STATUS instances for property testing - lazily instantiated by
// AgentSetting_STATUSGenerator()
var agentSetting_STATUSGenerator gopter.Gen

// AgentSetting_STATUSGenerator returns a generator of AgentSetting_STATUS instances for property testing.
func AgentSetting_STATUSGenerator() gopter.Gen {
	if agentSetting_STATUSGenerator != nil {
		return agentSetting_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAgentSetting_STATUS(generators)
	agentSetting_STATUSGenerator = gen.Struct(reflect.TypeOf(AgentSetting_STATUS{}), generators)

	return agentSetting_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAgentSetting_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAgentSetting_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_AgentSettingsSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AgentSettingsSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAgentSettingsSpec, AgentSettingsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAgentSettingsSpec runs a test to see if a specific instance of AgentSettingsSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForAgentSettingsSpec(subject AgentSettingsSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AgentSettingsSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AgentSettingsSpec instances for property testing - lazily instantiated by AgentSettingsSpecGenerator()
var agentSettingsSpecGenerator gopter.Gen

// AgentSettingsSpecGenerator returns a generator of AgentSettingsSpec instances for property testing.
func AgentSettingsSpecGenerator() gopter.Gen {
	if agentSettingsSpecGenerator != nil {
		return agentSettingsSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForAgentSettingsSpec(generators)
	agentSettingsSpecGenerator = gen.Struct(reflect.TypeOf(AgentSettingsSpec{}), generators)

	return agentSettingsSpecGenerator
}

// AddRelatedPropertyGeneratorsForAgentSettingsSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAgentSettingsSpec(gens map[string]gopter.Gen) {
	gens["Logs"] = gen.SliceOf(AgentSettingGenerator())
}

func Test_AgentSettingsSpec_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AgentSettingsSpec_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAgentSettingsSpec_STATUS, AgentSettingsSpec_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAgentSettingsSpec_STATUS runs a test to see if a specific instance of AgentSettingsSpec_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAgentSettingsSpec_STATUS(subject AgentSettingsSpec_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AgentSettingsSpec_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AgentSettingsSpec_STATUS instances for property testing - lazily instantiated by
// AgentSettingsSpec_STATUSGenerator()
var agentSettingsSpec_STATUSGenerator gopter.Gen

// AgentSettingsSpec_STATUSGenerator returns a generator of AgentSettingsSpec_STATUS instances for property testing.
func AgentSettingsSpec_STATUSGenerator() gopter.Gen {
	if agentSettingsSpec_STATUSGenerator != nil {
		return agentSettingsSpec_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForAgentSettingsSpec_STATUS(generators)
	agentSettingsSpec_STATUSGenerator = gen.Struct(reflect.TypeOf(AgentSettingsSpec_STATUS{}), generators)

	return agentSettingsSpec_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForAgentSettingsSpec_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAgentSettingsSpec_STATUS(gens map[string]gopter.Gen) {
	gens["Logs"] = gen.SliceOf(AgentSetting_STATUSGenerator())
}

func Test_AzureMonitorMetricsDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureMonitorMetricsDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureMonitorMetricsDestination, AzureMonitorMetricsDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureMonitorMetricsDestination runs a test to see if a specific instance of AzureMonitorMetricsDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureMonitorMetricsDestination(subject AzureMonitorMetricsDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureMonitorMetricsDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureMonitorMetricsDestination instances for property testing - lazily instantiated by
// AzureMonitorMetricsDestinationGenerator()
var azureMonitorMetricsDestinationGenerator gopter.Gen

// AzureMonitorMetricsDestinationGenerator returns a generator of AzureMonitorMetricsDestination instances for property testing.
func AzureMonitorMetricsDestinationGenerator() gopter.Gen {
	if azureMonitorMetricsDestinationGenerator != nil {
		return azureMonitorMetricsDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureMonitorMetricsDestination(generators)
	azureMonitorMetricsDestinationGenerator = gen.Struct(reflect.TypeOf(AzureMonitorMetricsDestination{}), generators)

	return azureMonitorMetricsDestinationGenerator
}

// AddIndependentPropertyGeneratorsForAzureMonitorMetricsDestination is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureMonitorMetricsDestination(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_AzureMonitorMetricsDestination_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureMonitorMetricsDestination_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureMonitorMetricsDestination_STATUS, AzureMonitorMetricsDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureMonitorMetricsDestination_STATUS runs a test to see if a specific instance of AzureMonitorMetricsDestination_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureMonitorMetricsDestination_STATUS(subject AzureMonitorMetricsDestination_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureMonitorMetricsDestination_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureMonitorMetricsDestination_STATUS instances for property testing - lazily instantiated by
// AzureMonitorMetricsDestination_STATUSGenerator()
var azureMonitorMetricsDestination_STATUSGenerator gopter.Gen

// AzureMonitorMetricsDestination_STATUSGenerator returns a generator of AzureMonitorMetricsDestination_STATUS instances for property testing.
func AzureMonitorMetricsDestination_STATUSGenerator() gopter.Gen {
	if azureMonitorMetricsDestination_STATUSGenerator != nil {
		return azureMonitorMetricsDestination_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureMonitorMetricsDestination_STATUS(generators)
	azureMonitorMetricsDestination_STATUSGenerator = gen.Struct(reflect.TypeOf(AzureMonitorMetricsDestination_STATUS{}), generators)

	return azureMonitorMetricsDestination_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAzureMonitorMetricsDestination_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureMonitorMetricsDestination_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_ColumnDefinition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ColumnDefinition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForColumnDefinition, ColumnDefinitionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForColumnDefinition runs a test to see if a specific instance of ColumnDefinition round trips to JSON and back losslessly
func RunJSONSerializationTestForColumnDefinition(subject ColumnDefinition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ColumnDefinition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ColumnDefinition instances for property testing - lazily instantiated by ColumnDefinitionGenerator()
var columnDefinitionGenerator gopter.Gen

// ColumnDefinitionGenerator returns a generator of ColumnDefinition instances for property testing.
func ColumnDefinitionGenerator() gopter.Gen {
	if columnDefinitionGenerator != nil {
		return columnDefinitionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForColumnDefinition(generators)
	columnDefinitionGenerator = gen.Struct(reflect.TypeOf(ColumnDefinition{}), generators)

	return columnDefinitionGenerator
}

// AddIndependentPropertyGeneratorsForColumnDefinition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForColumnDefinition(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_ColumnDefinition_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ColumnDefinition_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForColumnDefinition_STATUS, ColumnDefinition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForColumnDefinition_STATUS runs a test to see if a specific instance of ColumnDefinition_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForColumnDefinition_STATUS(subject ColumnDefinition_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ColumnDefinition_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ColumnDefinition_STATUS instances for property testing - lazily instantiated by
// ColumnDefinition_STATUSGenerator()
var columnDefinition_STATUSGenerator gopter.Gen

// ColumnDefinition_STATUSGenerator returns a generator of ColumnDefinition_STATUS instances for property testing.
func ColumnDefinition_STATUSGenerator() gopter.Gen {
	if columnDefinition_STATUSGenerator != nil {
		return columnDefinition_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForColumnDefinition_STATUS(generators)
	columnDefinition_STATUSGenerator = gen.Struct(reflect.TypeOf(ColumnDefinition_STATUS{}), generators)

	return columnDefinition_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForColumnDefinition_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForColumnDefinition_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_DataCollectionRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataCollectionRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataCollectionRule, DataCollectionRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataCollectionRule runs a test to see if a specific instance of DataCollectionRule round trips to JSON and back losslessly
func RunJSONSerializationTestForDataCollectionRule(subject DataCollectionRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataCollectionRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataCollectionRule instances for property testing - lazily instantiated by DataCollectionRuleGenerator()
var dataCollectionRuleGenerator gopter.Gen

// DataCollectionRuleGenerator returns a generator of DataCollectionRule instances for property testing.
func DataCollectionRuleGenerator() gopter.Gen {
	if dataCollectionRuleGenerator != nil {
		return dataCollectionRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDataCollectionRule(generators)
	dataCollectionRuleGenerator = gen.Struct(reflect.TypeOf(DataCollectionRule{}), generators)

	return dataCollectionRuleGenerator
}

// AddRelatedPropertyGeneratorsForDataCollectionRule is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataCollectionRule(gens map[string]gopter.Gen) {
	gens["Spec"] = DataCollectionRule_SpecGenerator()
	gens["Status"] = DataCollectionRuleResource_STATUSGenerator()
}

func Test_DataCollectionRuleOperatorSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataCollectionRuleOperatorSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataCollectionRuleOperatorSpec, DataCollectionRuleOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataCollectionRuleOperatorSpec runs a test to see if a specific instance of DataCollectionRuleOperatorSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForDataCollectionRuleOperatorSpec(subject DataCollectionRuleOperatorSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataCollectionRuleOperatorSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataCollectionRuleOperatorSpec instances for property testing - lazily instantiated by
// DataCollectionRuleOperatorSpecGenerator()
var dataCollectionRuleOperatorSpecGenerator gopter.Gen

// DataCollectionRuleOperatorSpecGenerator returns a generator of DataCollectionRuleOperatorSpec instances for property testing.
func DataCollectionRuleOperatorSpecGenerator() gopter.Gen {
	if dataCollectionRuleOperatorSpecGenerator != nil {
		return dataCollectionRuleOperatorSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	dataCollectionRuleOperatorSpecGenerator = gen.Struct(reflect.TypeOf(DataCollectionRuleOperatorSpec{}), generators)

	return dataCollectionRuleOperatorSpecGenerator
}

func Test_DataCollectionRuleResource_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataCollectionRuleResource_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataCollectionRuleResource_STATUS, DataCollectionRuleResource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataCollectionRuleResource_STATUS runs a test to see if a specific instance of DataCollectionRuleResource_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDataCollectionRuleResource_STATUS(subject DataCollectionRuleResource_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataCollectionRuleResource_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataCollectionRuleResource_STATUS instances for property testing - lazily instantiated by
// DataCollectionRuleResource_STATUSGenerator()
var dataCollectionRuleResource_STATUSGenerator gopter.Gen

// DataCollectionRuleResource_STATUSGenerator returns a generator of DataCollectionRuleResource_STATUS instances for property testing.
// We first initialize dataCollectionRuleResource_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DataCollectionRuleResource_STATUSGenerator() gopter.Gen {
	if dataCollectionRuleResource_STATUSGenerator != nil {
		return dataCollectionRuleResource_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataCollectionRuleResource_STATUS(generators)
	dataCollectionRuleResource_STATUSGenerator = gen.Struct(reflect.TypeOf(DataCollectionRuleResource_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataCollectionRuleResource_STATUS(generators)
	AddRelatedPropertyGeneratorsForDataCollectionRuleResource_STATUS(generators)
	dataCollectionRuleResource_STATUSGenerator = gen.Struct(reflect.TypeOf(DataCollectionRuleResource_STATUS{}), generators)

	return dataCollectionRuleResource_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDataCollectionRuleResource_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDataCollectionRuleResource_STATUS(gens map[string]gopter.Gen) {
	gens["DataCollectionEndpointId"] = gen.PtrOf(gen.AlphaString())
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["ImmutableId"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDataCollectionRuleResource_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataCollectionRuleResource_STATUS(gens map[string]gopter.Gen) {
	gens["AgentSettings"] = gen.PtrOf(AgentSettingsSpec_STATUSGenerator())
	gens["DataFlows"] = gen.SliceOf(DataFlow_STATUSGenerator())
	gens["DataSources"] = gen.PtrOf(DataSourcesSpec_STATUSGenerator())
	gens["Destinations"] = gen.PtrOf(DestinationsSpec_STATUSGenerator())
	gens["Endpoints"] = gen.PtrOf(EndpointsSpec_STATUSGenerator())
	gens["Identity"] = gen.PtrOf(ManagedServiceIdentity_STATUSGenerator())
	gens["Metadata"] = gen.PtrOf(Metadata_STATUSGenerator())
	gens["References"] = gen.PtrOf(ReferencesSpec_STATUSGenerator())
	gens["StreamDeclarations"] = gen.MapOf(
		gen.AlphaString(),
		StreamDeclaration_STATUSGenerator())
	gens["SystemData"] = gen.PtrOf(SystemData_STATUSGenerator())
}

func Test_DataCollectionRule_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataCollectionRule_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataCollectionRule_Spec, DataCollectionRule_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataCollectionRule_Spec runs a test to see if a specific instance of DataCollectionRule_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForDataCollectionRule_Spec(subject DataCollectionRule_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataCollectionRule_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataCollectionRule_Spec instances for property testing - lazily instantiated by
// DataCollectionRule_SpecGenerator()
var dataCollectionRule_SpecGenerator gopter.Gen

// DataCollectionRule_SpecGenerator returns a generator of DataCollectionRule_Spec instances for property testing.
// We first initialize dataCollectionRule_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DataCollectionRule_SpecGenerator() gopter.Gen {
	if dataCollectionRule_SpecGenerator != nil {
		return dataCollectionRule_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataCollectionRule_Spec(generators)
	dataCollectionRule_SpecGenerator = gen.Struct(reflect.TypeOf(DataCollectionRule_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataCollectionRule_Spec(generators)
	AddRelatedPropertyGeneratorsForDataCollectionRule_Spec(generators)
	dataCollectionRule_SpecGenerator = gen.Struct(reflect.TypeOf(DataCollectionRule_Spec{}), generators)

	return dataCollectionRule_SpecGenerator
}

// AddIndependentPropertyGeneratorsForDataCollectionRule_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDataCollectionRule_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["OriginalVersion"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDataCollectionRule_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataCollectionRule_Spec(gens map[string]gopter.Gen) {
	gens["AgentSettings"] = gen.PtrOf(AgentSettingsSpecGenerator())
	gens["DataFlows"] = gen.SliceOf(DataFlowGenerator())
	gens["DataSources"] = gen.PtrOf(DataSourcesSpecGenerator())
	gens["Destinations"] = gen.PtrOf(DestinationsSpecGenerator())
	gens["Identity"] = gen.PtrOf(ManagedServiceIdentityGenerator())
	gens["OperatorSpec"] = gen.PtrOf(DataCollectionRuleOperatorSpecGenerator())
	gens["References"] = gen.PtrOf(ReferencesSpecGenerator())
	gens["StreamDeclarations"] = gen.MapOf(
		gen.AlphaString(),
		StreamDeclarationGenerator())
}

func Test_DataFlow_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataFlow via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataFlow, DataFlowGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataFlow runs a test to see if a specific instance of DataFlow round trips to JSON and back losslessly
func RunJSONSerializationTestForDataFlow(subject DataFlow) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataFlow
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataFlow instances for property testing - lazily instantiated by DataFlowGenerator()
var dataFlowGenerator gopter.Gen

// DataFlowGenerator returns a generator of DataFlow instances for property testing.
func DataFlowGenerator() gopter.Gen {
	if dataFlowGenerator != nil {
		return dataFlowGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataFlow(generators)
	dataFlowGenerator = gen.Struct(reflect.TypeOf(DataFlow{}), generators)

	return dataFlowGenerator
}

// AddIndependentPropertyGeneratorsForDataFlow is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDataFlow(gens map[string]gopter.Gen) {
	gens["BuiltInTransform"] = gen.PtrOf(gen.AlphaString())
	gens["CaptureOverflow"] = gen.PtrOf(gen.Bool())
	gens["Destinations"] = gen.SliceOf(gen.AlphaString())
	gens["OutputStream"] = gen.PtrOf(gen.AlphaString())
	gens["Streams"] = gen.SliceOf(gen.AlphaString())
	gens["TransformKql"] = gen.PtrOf(gen.AlphaString())
}

func Test_DataFlow_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataFlow_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataFlow_STATUS, DataFlow_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataFlow_STATUS runs a test to see if a specific instance of DataFlow_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDataFlow_STATUS(subject DataFlow_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataFlow_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataFlow_STATUS instances for property testing - lazily instantiated by DataFlow_STATUSGenerator()
var dataFlow_STATUSGenerator gopter.Gen

// DataFlow_STATUSGenerator returns a generator of DataFlow_STATUS instances for property testing.
func DataFlow_STATUSGenerator() gopter.Gen {
	if dataFlow_STATUSGenerator != nil {
		return dataFlow_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataFlow_STATUS(generators)
	dataFlow_STATUSGenerator = gen.Struct(reflect.TypeOf(DataFlow_STATUS{}), generators)

	return dataFlow_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDataFlow_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDataFlow_STATUS(gens map[string]gopter.Gen) {
	gens["BuiltInTransform"] = gen.PtrOf(gen.AlphaString())
	gens["CaptureOverflow"] = gen.PtrOf(gen.Bool())
	gens["Destinations"] = gen.SliceOf(gen.AlphaString())
	gens["OutputStream"] = gen.PtrOf(gen.AlphaString())
	gens["Streams"] = gen.SliceOf(gen.AlphaString())
	gens["TransformKql"] = gen.PtrOf(gen.AlphaString())
}

func Test_DataImportSources_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataImportSources via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataImportSources, DataImportSourcesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataImportSources runs a test to see if a specific instance of DataImportSources round trips to JSON and back losslessly
func RunJSONSerializationTestForDataImportSources(subject DataImportSources) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataImportSources
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataImportSources instances for property testing - lazily instantiated by DataImportSourcesGenerator()
var dataImportSourcesGenerator gopter.Gen

// DataImportSourcesGenerator returns a generator of DataImportSources instances for property testing.
func DataImportSourcesGenerator() gopter.Gen {
	if dataImportSourcesGenerator != nil {
		return dataImportSourcesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDataImportSources(generators)
	dataImportSourcesGenerator = gen.Struct(reflect.TypeOf(DataImportSources{}), generators)

	return dataImportSourcesGenerator
}

// AddRelatedPropertyGeneratorsForDataImportSources is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataImportSources(gens map[string]gopter.Gen) {
	gens["EventHub"] = gen.PtrOf(EventHubDataSourceGenerator())
}

func Test_DataImportSources_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataImportSources_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataImportSources_STATUS, DataImportSources_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataImportSources_STATUS runs a test to see if a specific instance of DataImportSources_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDataImportSources_STATUS(subject DataImportSources_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataImportSources_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataImportSources_STATUS instances for property testing - lazily instantiated by
// DataImportSources_STATUSGenerator()
var dataImportSources_STATUSGenerator gopter.Gen

// DataImportSources_STATUSGenerator returns a generator of DataImportSources_STATUS instances for property testing.
func DataImportSources_STATUSGenerator() gopter.Gen {
	if dataImportSources_STATUSGenerator != nil {
		return dataImportSources_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDataImportSources_STATUS(generators)
	dataImportSources_STATUSGenerator = gen.Struct(reflect.TypeOf(DataImportSources_STATUS{}), generators)

	return dataImportSources_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForDataImportSources_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataImportSources_STATUS(gens map[string]gopter.Gen) {
	gens["EventHub"] = gen.PtrOf(EventHubDataSource_STATUSGenerator())
}

func Test_DataSourcesSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataSourcesSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataSourcesSpec, DataSourcesSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataSourcesSpec runs a test to see if a specific instance of DataSourcesSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForDataSourcesSpec(subject DataSourcesSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataSourcesSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataSourcesSpec instances for property testing - lazily instantiated by DataSourcesSpecGenerator()
var dataSourcesSpecGenerator gopter.Gen

// DataSourcesSpecGenerator returns a generator of DataSourcesSpec instances for property testing.
func DataSourcesSpecGenerator() gopter.Gen {
	if dataSourcesSpecGenerator != nil {
		return dataSourcesSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDataSourcesSpec(generators)
	dataSourcesSpecGenerator = gen.Struct(reflect.TypeOf(DataSourcesSpec{}), generators)

	return dataSourcesSpecGenerator
}

// AddRelatedPropertyGeneratorsForDataSourcesSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataSourcesSpec(gens map[string]gopter.Gen) {
	gens["DataImports"] = gen.PtrOf(DataImportSourcesGenerator())
	gens["Extensions"] = gen.SliceOf(ExtensionDataSourceGenerator())
	gens["IisLogs"] = gen.SliceOf(IisLogsDataSourceGenerator())
	gens["LogFiles"] = gen.SliceOf(LogFilesDataSourceGenerator())
	gens["PerformanceCounters"] = gen.SliceOf(PerfCounterDataSourceGenerator())
	gens["PlatformTelemetry"] = gen.SliceOf(PlatformTelemetryDataSourceGenerator())
	gens["PrometheusForwarder"] = gen.SliceOf(PrometheusForwarderDataSourceGenerator())
	gens["Syslog"] = gen.SliceOf(SyslogDataSourceGenerator())
	gens["WindowsEventLogs"] = gen.SliceOf(WindowsEventLogDataSourceGenerator())
	gens["WindowsFirewallLogs"] = gen.SliceOf(WindowsFirewallLogsDataSourceGenerator())
}

func Test_DataSourcesSpec_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataSourcesSpec_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataSourcesSpec_STATUS, DataSourcesSpec_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataSourcesSpec_STATUS runs a test to see if a specific instance of DataSourcesSpec_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDataSourcesSpec_STATUS(subject DataSourcesSpec_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataSourcesSpec_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataSourcesSpec_STATUS instances for property testing - lazily instantiated by
// DataSourcesSpec_STATUSGenerator()
var dataSourcesSpec_STATUSGenerator gopter.Gen

// DataSourcesSpec_STATUSGenerator returns a generator of DataSourcesSpec_STATUS instances for property testing.
func DataSourcesSpec_STATUSGenerator() gopter.Gen {
	if dataSourcesSpec_STATUSGenerator != nil {
		return dataSourcesSpec_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDataSourcesSpec_STATUS(generators)
	dataSourcesSpec_STATUSGenerator = gen.Struct(reflect.TypeOf(DataSourcesSpec_STATUS{}), generators)

	return dataSourcesSpec_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForDataSourcesSpec_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataSourcesSpec_STATUS(gens map[string]gopter.Gen) {
	gens["DataImports"] = gen.PtrOf(DataImportSources_STATUSGenerator())
	gens["Extensions"] = gen.SliceOf(ExtensionDataSource_STATUSGenerator())
	gens["IisLogs"] = gen.SliceOf(IisLogsDataSource_STATUSGenerator())
	gens["LogFiles"] = gen.SliceOf(LogFilesDataSource_STATUSGenerator())
	gens["PerformanceCounters"] = gen.SliceOf(PerfCounterDataSource_STATUSGenerator())
	gens["PlatformTelemetry"] = gen.SliceOf(PlatformTelemetryDataSource_STATUSGenerator())
	gens["PrometheusForwarder"] = gen.SliceOf(PrometheusForwarderDataSource_STATUSGenerator())
	gens["Syslog"] = gen.SliceOf(SyslogDataSource_STATUSGenerator())
	gens["WindowsEventLogs"] = gen.SliceOf(WindowsEventLogDataSource_STATUSGenerator())
	gens["WindowsFirewallLogs"] = gen.SliceOf(WindowsFirewallLogsDataSource_STATUSGenerator())
}

func Test_DestinationsSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DestinationsSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDestinationsSpec, DestinationsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDestinationsSpec runs a test to see if a specific instance of DestinationsSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForDestinationsSpec(subject DestinationsSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DestinationsSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DestinationsSpec instances for property testing - lazily instantiated by DestinationsSpecGenerator()
var destinationsSpecGenerator gopter.Gen

// DestinationsSpecGenerator returns a generator of DestinationsSpec instances for property testing.
func DestinationsSpecGenerator() gopter.Gen {
	if destinationsSpecGenerator != nil {
		return destinationsSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDestinationsSpec(generators)
	destinationsSpecGenerator = gen.Struct(reflect.TypeOf(DestinationsSpec{}), generators)

	return destinationsSpecGenerator
}

// AddRelatedPropertyGeneratorsForDestinationsSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDestinationsSpec(gens map[string]gopter.Gen) {
	gens["AzureDataExplorer"] = gen.SliceOf(AdxDestinationGenerator())
	gens["AzureMonitorMetrics"] = gen.PtrOf(AzureMonitorMetricsDestinationGenerator())
	gens["EventHubs"] = gen.SliceOf(EventHubDestinationGenerator())
	gens["EventHubsDirect"] = gen.SliceOf(EventHubDirectDestinationGenerator())
	gens["LogAnalytics"] = gen.SliceOf(LogAnalyticsDestinationGenerator())
	gens["MicrosoftFabric"] = gen.SliceOf(MicrosoftFabricDestinationGenerator())
	gens["MonitoringAccounts"] = gen.SliceOf(MonitoringAccountDestinationGenerator())
	gens["StorageAccounts"] = gen.SliceOf(StorageBlobDestinationGenerator())
	gens["StorageBlobsDirect"] = gen.SliceOf(StorageBlobDestinationGenerator())
	gens["StorageTablesDirect"] = gen.SliceOf(StorageTableDestinationGenerator())
}

func Test_DestinationsSpec_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DestinationsSpec_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDestinationsSpec_STATUS, DestinationsSpec_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDestinationsSpec_STATUS runs a test to see if a specific instance of DestinationsSpec_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDestinationsSpec_STATUS(subject DestinationsSpec_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DestinationsSpec_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DestinationsSpec_STATUS instances for property testing - lazily instantiated by
// DestinationsSpec_STATUSGenerator()
var destinationsSpec_STATUSGenerator gopter.Gen

// DestinationsSpec_STATUSGenerator returns a generator of DestinationsSpec_STATUS instances for property testing.
func DestinationsSpec_STATUSGenerator() gopter.Gen {
	if destinationsSpec_STATUSGenerator != nil {
		return destinationsSpec_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDestinationsSpec_STATUS(generators)
	destinationsSpec_STATUSGenerator = gen.Struct(reflect.TypeOf(DestinationsSpec_STATUS{}), generators)

	return destinationsSpec_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForDestinationsSpec_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDestinationsSpec_STATUS(gens map[string]gopter.Gen) {
	gens["AzureDataExplorer"] = gen.SliceOf(AdxDestination_STATUSGenerator())
	gens["AzureMonitorMetrics"] = gen.PtrOf(AzureMonitorMetricsDestination_STATUSGenerator())
	gens["EventHubs"] = gen.SliceOf(EventHubDestination_STATUSGenerator())
	gens["EventHubsDirect"] = gen.SliceOf(EventHubDirectDestination_STATUSGenerator())
	gens["LogAnalytics"] = gen.SliceOf(LogAnalyticsDestination_STATUSGenerator())
	gens["MicrosoftFabric"] = gen.SliceOf(MicrosoftFabricDestination_STATUSGenerator())
	gens["MonitoringAccounts"] = gen.SliceOf(MonitoringAccountDestination_STATUSGenerator())
	gens["StorageAccounts"] = gen.SliceOf(StorageBlobDestination_STATUSGenerator())
	gens["StorageBlobsDirect"] = gen.SliceOf(StorageBlobDestination_STATUSGenerator())
	gens["StorageTablesDirect"] = gen.SliceOf(StorageTableDestination_STATUSGenerator())
}

func Test_EndpointsSpec_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EndpointsSpec_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEndpointsSpec_STATUS, EndpointsSpec_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEndpointsSpec_STATUS runs a test to see if a specific instance of EndpointsSpec_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEndpointsSpec_STATUS(subject EndpointsSpec_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EndpointsSpec_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EndpointsSpec_STATUS instances for property testing - lazily instantiated by
// EndpointsSpec_STATUSGenerator()
var endpointsSpec_STATUSGenerator gopter.Gen

// EndpointsSpec_STATUSGenerator returns a generator of EndpointsSpec_STATUS instances for property testing.
func EndpointsSpec_STATUSGenerator() gopter.Gen {
	if endpointsSpec_STATUSGenerator != nil {
		return endpointsSpec_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEndpointsSpec_STATUS(generators)
	endpointsSpec_STATUSGenerator = gen.Struct(reflect.TypeOf(EndpointsSpec_STATUS{}), generators)

	return endpointsSpec_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForEndpointsSpec_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEndpointsSpec_STATUS(gens map[string]gopter.Gen) {
	gens["LogsIngestion"] = gen.PtrOf(gen.AlphaString())
	gens["MetricsIngestion"] = gen.PtrOf(gen.AlphaString())
}

func Test_EnrichmentData_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EnrichmentData via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEnrichmentData, EnrichmentDataGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEnrichmentData runs a test to see if a specific instance of EnrichmentData round trips to JSON and back losslessly
func RunJSONSerializationTestForEnrichmentData(subject EnrichmentData) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EnrichmentData
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EnrichmentData instances for property testing - lazily instantiated by EnrichmentDataGenerator()
var enrichmentDataGenerator gopter.Gen

// EnrichmentDataGenerator returns a generator of EnrichmentData instances for property testing.
func EnrichmentDataGenerator() gopter.Gen {
	if enrichmentDataGenerator != nil {
		return enrichmentDataGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForEnrichmentData(generators)
	enrichmentDataGenerator = gen.Struct(reflect.TypeOf(EnrichmentData{}), generators)

	return enrichmentDataGenerator
}

// AddRelatedPropertyGeneratorsForEnrichmentData is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEnrichmentData(gens map[string]gopter.Gen) {
	gens["StorageBlobs"] = gen.SliceOf(StorageBlobGenerator())
}

func Test_EnrichmentData_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EnrichmentData_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEnrichmentData_STATUS, EnrichmentData_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEnrichmentData_STATUS runs a test to see if a specific instance of EnrichmentData_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEnrichmentData_STATUS(subject EnrichmentData_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EnrichmentData_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EnrichmentData_STATUS instances for property testing - lazily instantiated by
// EnrichmentData_STATUSGenerator()
var enrichmentData_STATUSGenerator gopter.Gen

// EnrichmentData_STATUSGenerator returns a generator of EnrichmentData_STATUS instances for property testing.
func EnrichmentData_STATUSGenerator() gopter.Gen {
	if enrichmentData_STATUSGenerator != nil {
		return enrichmentData_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForEnrichmentData_STATUS(generators)
	enrichmentData_STATUSGenerator = gen.Struct(reflect.TypeOf(EnrichmentData_STATUS{}), generators)

	return enrichmentData_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForEnrichmentData_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEnrichmentData_STATUS(gens map[string]gopter.Gen) {
	gens["StorageBlobs"] = gen.SliceOf(StorageBlob_STATUSGenerator())
}

func Test_EventHubDataSource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventHubDataSource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventHubDataSource, EventHubDataSourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventHubDataSource runs a test to see if a specific instance of EventHubDataSource round trips to JSON and back losslessly
func RunJSONSerializationTestForEventHubDataSource(subject EventHubDataSource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventHubDataSource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventHubDataSource instances for property testing - lazily instantiated by EventHubDataSourceGenerator()
var eventHubDataSourceGenerator gopter.Gen

// EventHubDataSourceGenerator returns a generator of EventHubDataSource instances for property testing.
func EventHubDataSourceGenerator() gopter.Gen {
	if eventHubDataSourceGenerator != nil {
		return eventHubDataSourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventHubDataSource(generators)
	eventHubDataSourceGenerator = gen.Struct(reflect.TypeOf(EventHubDataSource{}), generators)

	return eventHubDataSourceGenerator
}

// AddIndependentPropertyGeneratorsForEventHubDataSource is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventHubDataSource(gens map[string]gopter.Gen) {
	gens["ConsumerGroup"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Stream"] = gen.PtrOf(gen.AlphaString())
}

func Test_EventHubDataSource_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventHubDataSource_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventHubDataSource_STATUS, EventHubDataSource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventHubDataSource_STATUS runs a test to see if a specific instance of EventHubDataSource_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEventHubDataSource_STATUS(subject EventHubDataSource_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventHubDataSource_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventHubDataSource_STATUS instances for property testing - lazily instantiated by
// EventHubDataSource_STATUSGenerator()
var eventHubDataSource_STATUSGenerator gopter.Gen

// EventHubDataSource_STATUSGenerator returns a generator of EventHubDataSource_STATUS instances for property testing.
func EventHubDataSource_STATUSGenerator() gopter.Gen {
	if eventHubDataSource_STATUSGenerator != nil {
		return eventHubDataSource_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventHubDataSource_STATUS(generators)
	eventHubDataSource_STATUSGenerator = gen.Struct(reflect.TypeOf(EventHubDataSource_STATUS{}), generators)

	return eventHubDataSource_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForEventHubDataSource_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventHubDataSource_STATUS(gens map[string]gopter.Gen) {
	gens["ConsumerGroup"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Stream"] = gen.PtrOf(gen.AlphaString())
}

func Test_EventHubDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventHubDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventHubDestination, EventHubDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventHubDestination runs a test to see if a specific instance of EventHubDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForEventHubDestination(subject EventHubDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventHubDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventHubDestination instances for property testing - lazily instantiated by
// EventHubDestinationGenerator()
var eventHubDestinationGenerator gopter.Gen

// EventHubDestinationGenerator returns a generator of EventHubDestination instances for property testing.
func EventHubDestinationGenerator() gopter.Gen {
	if eventHubDestinationGenerator != nil {
		return eventHubDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventHubDestination(generators)
	eventHubDestinationGenerator = gen.Struct(reflect.TypeOf(EventHubDestination{}), generators)

	return eventHubDestinationGenerator
}

// AddIndependentPropertyGeneratorsForEventHubDestination is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventHubDestination(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_EventHubDestination_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventHubDestination_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventHubDestination_STATUS, EventHubDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventHubDestination_STATUS runs a test to see if a specific instance of EventHubDestination_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEventHubDestination_STATUS(subject EventHubDestination_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventHubDestination_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventHubDestination_STATUS instances for property testing - lazily instantiated by
// EventHubDestination_STATUSGenerator()
var eventHubDestination_STATUSGenerator gopter.Gen

// EventHubDestination_STATUSGenerator returns a generator of EventHubDestination_STATUS instances for property testing.
func EventHubDestination_STATUSGenerator() gopter.Gen {
	if eventHubDestination_STATUSGenerator != nil {
		return eventHubDestination_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventHubDestination_STATUS(generators)
	eventHubDestination_STATUSGenerator = gen.Struct(reflect.TypeOf(EventHubDestination_STATUS{}), generators)

	return eventHubDestination_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForEventHubDestination_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventHubDestination_STATUS(gens map[string]gopter.Gen) {
	gens["EventHubResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_EventHubDirectDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventHubDirectDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventHubDirectDestination, EventHubDirectDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventHubDirectDestination runs a test to see if a specific instance of EventHubDirectDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForEventHubDirectDestination(subject EventHubDirectDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventHubDirectDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventHubDirectDestination instances for property testing - lazily instantiated by
// EventHubDirectDestinationGenerator()
var eventHubDirectDestinationGenerator gopter.Gen

// EventHubDirectDestinationGenerator returns a generator of EventHubDirectDestination instances for property testing.
func EventHubDirectDestinationGenerator() gopter.Gen {
	if eventHubDirectDestinationGenerator != nil {
		return eventHubDirectDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventHubDirectDestination(generators)
	eventHubDirectDestinationGenerator = gen.Struct(reflect.TypeOf(EventHubDirectDestination{}), generators)

	return eventHubDirectDestinationGenerator
}

// AddIndependentPropertyGeneratorsForEventHubDirectDestination is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventHubDirectDestination(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_EventHubDirectDestination_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventHubDirectDestination_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventHubDirectDestination_STATUS, EventHubDirectDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventHubDirectDestination_STATUS runs a test to see if a specific instance of EventHubDirectDestination_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEventHubDirectDestination_STATUS(subject EventHubDirectDestination_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventHubDirectDestination_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventHubDirectDestination_STATUS instances for property testing - lazily instantiated by
// EventHubDirectDestination_STATUSGenerator()
var eventHubDirectDestination_STATUSGenerator gopter.Gen

// EventHubDirectDestination_STATUSGenerator returns a generator of EventHubDirectDestination_STATUS instances for property testing.
func EventHubDirectDestination_STATUSGenerator() gopter.Gen {
	if eventHubDirectDestination_STATUSGenerator != nil {
		return eventHubDirectDestination_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventHubDirectDestination_STATUS(generators)
	eventHubDirectDestination_STATUSGenerator = gen.Struct(reflect.TypeOf(EventHubDirectDestination_STATUS{}), generators)

	return eventHubDirectDestination_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForEventHubDirectDestination_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventHubDirectDestination_STATUS(gens map[string]gopter.Gen) {
	gens["EventHubResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_ExtensionDataSource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtensionDataSource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtensionDataSource, ExtensionDataSourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtensionDataSource runs a test to see if a specific instance of ExtensionDataSource round trips to JSON and back losslessly
func RunJSONSerializationTestForExtensionDataSource(subject ExtensionDataSource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtensionDataSource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtensionDataSource instances for property testing - lazily instantiated by
// ExtensionDataSourceGenerator()
var extensionDataSourceGenerator gopter.Gen

// ExtensionDataSourceGenerator returns a generator of ExtensionDataSource instances for property testing.
func ExtensionDataSourceGenerator() gopter.Gen {
	if extensionDataSourceGenerator != nil {
		return extensionDataSourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtensionDataSource(generators)
	extensionDataSourceGenerator = gen.Struct(reflect.TypeOf(ExtensionDataSource{}), generators)

	return extensionDataSourceGenerator
}

// AddIndependentPropertyGeneratorsForExtensionDataSource is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtensionDataSource(gens map[string]gopter.Gen) {
	gens["ExtensionName"] = gen.PtrOf(gen.AlphaString())
	gens["InputDataSources"] = gen.SliceOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Streams"] = gen.SliceOf(gen.AlphaString())
}

func Test_ExtensionDataSource_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtensionDataSource_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtensionDataSource_STATUS, ExtensionDataSource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtensionDataSource_STATUS runs a test to see if a specific instance of ExtensionDataSource_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForExtensionDataSource_STATUS(subject ExtensionDataSource_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtensionDataSource_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtensionDataSource_STATUS instances for property testing - lazily instantiated by
// ExtensionDataSource_STATUSGenerator()
var extensionDataSource_STATUSGenerator gopter.Gen

// ExtensionDataSource_STATUSGenerator returns a generator of ExtensionDataSource_STATUS instances for property testing.
func ExtensionDataSource_STATUSGenerator() gopter.Gen {
	if extensionDataSource_STATUSGenerator != nil {
		return extensionDataSource_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtensionDataSource_STATUS(generators)
	extensionDataSource_STATUSGenerator = gen.Struct(reflect.TypeOf(ExtensionDataSource_STATUS{}), generators)

	return extensionDataSource_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForExtensionDataSource_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtensionDataSource_STATUS(gens map[string]gopter.Gen) {
	gens["ExtensionName"] = gen.PtrOf(gen.AlphaString())
	gens["InputDataSources"] = gen.SliceOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Streams"] = gen.SliceOf(gen.AlphaString())
}

func Test_IisLogsDataSource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IisLogsDataSource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIisLogsDataSource, IisLogsDataSourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIisLogsDataSource runs a test to see if a specific instance of IisLogsDataSource round trips to JSON and back losslessly
func RunJSONSerializationTestForIisLogsDataSource(subject IisLogsDataSource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IisLogsDataSource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IisLogsDataSource instances for property testing - lazily instantiated by IisLogsDataSourceGenerator()
var iisLogsDataSourceGenerator gopter.Gen

// IisLogsDataSourceGenerator returns a generator of IisLogsDataSource instances for property testing.
func IisLogsDataSourceGenerator() gopter.Gen {
	if iisLogsDataSourceGenerator != nil {
		return iisLogsDataSourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIisLogsDataSource(generators)
	iisLogsDataSourceGenerator = gen.Struct(reflect.TypeOf(IisLogsDataSource{}), generators)

	return iisLogsDataSourceGenerator
}

// AddIndependentPropertyGeneratorsForIisLogsDataSource is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIisLogsDataSource(gens map[string]gopter.Gen) {
	gens["LogDirectories"] = gen.SliceOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Streams"] = gen.SliceOf(gen.AlphaString())
	gens["TransformKql"] = gen.PtrOf(gen.AlphaString())
}

func Test_IisLogsDataSource_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IisLogsDataSource_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIisLogsDataSource_STATUS, IisLogsDataSource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIisLogsDataSource_STATUS runs a test to see if a specific instance of IisLogsDataSource_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForIisLogsDataSource_STATUS(subject IisLogsDataSource_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IisLogsDataSource_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IisLogsDataSource_STATUS instances for property testing - lazily instantiated by
// IisLogsDataSource_STATUSGenerator()
var iisLogsDataSource_STATUSGenerator gopter.Gen

// IisLogsDataSource_STATUSGenerator returns a generator of IisLogsDataSource_STATUS instances for property testing.
func IisLogsDataSource_STATUSGenerator() gopter.Gen {
	if iisLogsDataSource_STATUSGenerator != nil {
		return iisLogsDataSource_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIisLogsDataSource_STATUS(generators)
	iisLogsDataSource_STATUSGenerator = gen.Struct(reflect.TypeOf(IisLogsDataSource_STATUS{}), generators)

	return iisLogsDataSource_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForIisLogsDataSource_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIisLogsDataSource_STATUS(gens map[string]gopter.Gen) {
	gens["LogDirectories"] = gen.SliceOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Streams"] = gen.SliceOf(gen.AlphaString())
	gens["TransformKql"] = gen.PtrOf(gen.AlphaString())
}

func Test_LogAnalyticsDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LogAnalyticsDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLogAnalyticsDestination, LogAnalyticsDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLogAnalyticsDestination runs a test to see if a specific instance of LogAnalyticsDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForLogAnalyticsDestination(subject LogAnalyticsDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LogAnalyticsDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LogAnalyticsDestination instances for property testing - lazily instantiated by
// LogAnalyticsDestinationGenerator()
var logAnalyticsDestinationGenerator gopter.Gen

// LogAnalyticsDestinationGenerator returns a generator of LogAnalyticsDestination instances for property testing.
func LogAnalyticsDestinationGenerator() gopter.Gen {
	if logAnalyticsDestinationGenerator != nil {
		return logAnalyticsDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLogAnalyticsDestination(generators)
	logAnalyticsDestinationGenerator = gen.Struct(reflect.TypeOf(LogAnalyticsDestination{}), generators)

	return logAnalyticsDestinationGenerator
}

// AddIndependentPropertyGeneratorsForLogAnalyticsDestination is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLogAnalyticsDestination(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_LogAnalyticsDestination_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LogAnalyticsDestination_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLogAnalyticsDestination_STATUS, LogAnalyticsDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLogAnalyticsDestination_STATUS runs a test to see if a specific instance of LogAnalyticsDestination_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForLogAnalyticsDestination_STATUS(subject LogAnalyticsDestination_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LogAnalyticsDestination_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LogAnalyticsDestination_STATUS instances for property testing - lazily instantiated by
// LogAnalyticsDestination_STATUSGenerator()
var logAnalyticsDestination_STATUSGenerator gopter.Gen

// LogAnalyticsDestination_STATUSGenerator returns a generator of LogAnalyticsDestination_STATUS instances for property testing.
func LogAnalyticsDestination_STATUSGenerator() gopter.Gen {
	if logAnalyticsDestination_STATUSGenerator != nil {
		return logAnalyticsDestination_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLogAnalyticsDestination_STATUS(generators)
	logAnalyticsDestination_STATUSGenerator = gen.Struct(reflect.TypeOf(LogAnalyticsDestination_STATUS{}), generators)

	return logAnalyticsDestination_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForLogAnalyticsDestination_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLogAnalyticsDestination_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["WorkspaceId"] = gen.PtrOf(gen.AlphaString())
	gens["WorkspaceResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_LogFileSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LogFileSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLogFileSettings, LogFileSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLogFileSettings runs a test to see if a specific instance of LogFileSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForLogFileSettings(subject LogFileSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LogFileSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LogFileSettings instances for property testing - lazily instantiated by LogFileSettingsGenerator()
var logFileSettingsGenerator gopter.Gen

// LogFileSettingsGenerator returns a generator of LogFileSettings instances for property testing.
func LogFileSettingsGenerator() gopter.Gen {
	if logFileSettingsGenerator != nil {
		return logFileSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForLogFileSettings(generators)
	logFileSettingsGenerator = gen.Struct(reflect.TypeOf(LogFileSettings{}), generators)

	return logFileSettingsGenerator
}

// AddRelatedPropertyGeneratorsForLogFileSettings is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLogFileSettings(gens map[string]gopter.Gen) {
	gens["Text"] = gen.PtrOf(LogFileTextSettingsGenerator())
}

func Test_LogFileSettings_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LogFileSettings_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLogFileSettings_STATUS, LogFileSettings_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLogFileSettings_STATUS runs a test to see if a specific instance of LogFileSettings_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForLogFileSettings_STATUS(subject LogFileSettings_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LogFileSettings_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LogFileSettings_STATUS instances for property testing - lazily instantiated by
// LogFileSettings_STATUSGenerator()
var logFileSettings_STATUSGenerator gopter.Gen

// LogFileSettings_STATUSGenerator returns a generator of LogFileSettings_STATUS instances for property testing.
func LogFileSettings_STATUSGenerator() gopter.Gen {
	if logFileSettings_STATUSGenerator != nil {
		return logFileSettings_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForLogFileSettings_STATUS(generators)
	logFileSettings_STATUSGenerator = gen.Struct(reflect.TypeOf(LogFileSettings_STATUS{}), generators)

	return logFileSettings_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForLogFileSettings_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLogFileSettings_STATUS(gens map[string]gopter.Gen) {
	gens["Text"] = gen.PtrOf(LogFileTextSettings_STATUSGenerator())
}

func Test_LogFileTextSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LogFileTextSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLogFileTextSettings, LogFileTextSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLogFileTextSettings runs a test to see if a specific instance of LogFileTextSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForLogFileTextSettings(subject LogFileTextSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LogFileTextSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LogFileTextSettings instances for property testing - lazily instantiated by
// LogFileTextSettingsGenerator()
var logFileTextSettingsGenerator gopter.Gen

// LogFileTextSettingsGenerator returns a generator of LogFileTextSettings instances for property testing.
func LogFileTextSettingsGenerator() gopter.Gen {
	if logFileTextSettingsGenerator != nil {
		return logFileTextSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLogFileTextSettings(generators)
	logFileTextSettingsGenerator = gen.Struct(reflect.TypeOf(LogFileTextSettings{}), generators)

	return logFileTextSettingsGenerator
}

// AddIndependentPropertyGeneratorsForLogFileTextSettings is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLogFileTextSettings(gens map[string]gopter.Gen) {
	gens["RecordStartTimestampFormat"] = gen.PtrOf(gen.AlphaString())
}

func Test_LogFileTextSettings_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LogFileTextSettings_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLogFileTextSettings_STATUS, LogFileTextSettings_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLogFileTextSettings_STATUS runs a test to see if a specific instance of LogFileTextSettings_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForLogFileTextSettings_STATUS(subject LogFileTextSettings_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LogFileTextSettings_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LogFileTextSettings_STATUS instances for property testing - lazily instantiated by
// LogFileTextSettings_STATUSGenerator()
var logFileTextSettings_STATUSGenerator gopter.Gen

// LogFileTextSettings_STATUSGenerator returns a generator of LogFileTextSettings_STATUS instances for property testing.
func LogFileTextSettings_STATUSGenerator() gopter.Gen {
	if logFileTextSettings_STATUSGenerator != nil {
		return logFileTextSettings_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLogFileTextSettings_STATUS(generators)
	logFileTextSettings_STATUSGenerator = gen.Struct(reflect.TypeOf(LogFileTextSettings_STATUS{}), generators)

	return logFileTextSettings_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForLogFileTextSettings_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLogFileTextSettings_STATUS(gens map[string]gopter.Gen) {
	gens["RecordStartTimestampFormat"] = gen.PtrOf(gen.AlphaString())
}

func Test_LogFilesDataSource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LogFilesDataSource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLogFilesDataSource, LogFilesDataSourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLogFilesDataSource runs a test to see if a specific instance of LogFilesDataSource round trips to JSON and back losslessly
func RunJSONSerializationTestForLogFilesDataSource(subject LogFilesDataSource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LogFilesDataSource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LogFilesDataSource instances for property testing - lazily instantiated by LogFilesDataSourceGenerator()
var logFilesDataSourceGenerator gopter.Gen

// LogFilesDataSourceGenerator returns a generator of LogFilesDataSource instances for property testing.
// We first initialize logFilesDataSourceGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LogFilesDataSourceGenerator() gopter.Gen {
	if logFilesDataSourceGenerator != nil {
		return logFilesDataSourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLogFilesDataSource(generators)
	logFilesDataSourceGenerator = gen.Struct(reflect.TypeOf(LogFilesDataSource{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLogFilesDataSource(generators)
	AddRelatedPropertyGeneratorsForLogFilesDataSource(generators)
	logFilesDataSourceGenerator = gen.Struct(reflect.TypeOf(LogFilesDataSource{}), generators)

	return logFilesDataSourceGenerator
}

// AddIndependentPropertyGeneratorsForLogFilesDataSource is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLogFilesDataSource(gens map[string]gopter.Gen) {
	gens["FilePatterns"] = gen.SliceOf(gen.AlphaString())
	gens["Format"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Streams"] = gen.SliceOf(gen.AlphaString())
	gens["TransformKql"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLogFilesDataSource is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLogFilesDataSource(gens map[string]gopter.Gen) {
	gens["Settings"] = gen.PtrOf(LogFileSettingsGenerator())
}

func Test_LogFilesDataSource_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LogFilesDataSource_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLogFilesDataSource_STATUS, LogFilesDataSource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLogFilesDataSource_STATUS runs a test to see if a specific instance of LogFilesDataSource_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForLogFilesDataSource_STATUS(subject LogFilesDataSource_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LogFilesDataSource_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LogFilesDataSource_STATUS instances for property testing - lazily instantiated by
// LogFilesDataSource_STATUSGenerator()
var logFilesDataSource_STATUSGenerator gopter.Gen

// LogFilesDataSource_STATUSGenerator returns a generator of LogFilesDataSource_STATUS instances for property testing.
// We first initialize logFilesDataSource_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LogFilesDataSource_STATUSGenerator() gopter.Gen {
	if logFilesDataSource_STATUSGenerator != nil {
		return logFilesDataSource_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLogFilesDataSource_STATUS(generators)
	logFilesDataSource_STATUSGenerator = gen.Struct(reflect.TypeOf(LogFilesDataSource_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLogFilesDataSource_STATUS(generators)
	AddRelatedPropertyGeneratorsForLogFilesDataSource_STATUS(generators)
	logFilesDataSource_STATUSGenerator = gen.Struct(reflect.TypeOf(LogFilesDataSource_STATUS{}), generators)

	return logFilesDataSource_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForLogFilesDataSource_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLogFilesDataSource_STATUS(gens map[string]gopter.Gen) {
	gens["FilePatterns"] = gen.SliceOf(gen.AlphaString())
	gens["Format"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Streams"] = gen.SliceOf(gen.AlphaString())
	gens["TransformKql"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLogFilesDataSource_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLogFilesDataSource_STATUS(gens map[string]gopter.Gen) {
	gens["Settings"] = gen.PtrOf(LogFileSettings_STATUSGenerator())
}

func Test_ManagedServiceIdentity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentity, ManagedServiceIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentity runs a test to see if a specific instance of ManagedServiceIdentity round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentity(subject ManagedServiceIdentity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity instances for property testing - lazily instantiated by
// ManagedServiceIdentityGenerator()
var managedServiceIdentityGenerator gopter.Gen

// ManagedServiceIdentityGenerator returns a generator of ManagedServiceIdentity instances for property testing.
// We first initialize managedServiceIdentityGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedServiceIdentityGenerator() gopter.Gen {
	if managedServiceIdentityGenerator != nil {
		return managedServiceIdentityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity(generators)
	managedServiceIdentityGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity(generators)
	AddRelatedPropertyGeneratorsForManagedServiceIdentity(generators)
	managedServiceIdentityGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity{}), generators)

	return managedServiceIdentityGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentity is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentity(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForManagedServiceIdentity is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedServiceIdentity(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.SliceOf(UserAssignedIdentityDetailsGenerator())
}

func Test_ManagedServiceIdentity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentity_STATUS, ManagedServiceIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentity_STATUS runs a test to see if a specific instance of ManagedServiceIdentity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentity_STATUS(subject ManagedServiceIdentity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity_STATUS instances for property testing - lazily instantiated by
// ManagedServiceIdentity_STATUSGenerator()
var managedServiceIdentity_STATUSGenerator gopter.Gen

// ManagedServiceIdentity_STATUSGenerator returns a generator of ManagedServiceIdentity_STATUS instances for property testing.
// We first initialize managedServiceIdentity_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedServiceIdentity_STATUSGenerator() gopter.Gen {
	if managedServiceIdentity_STATUSGenerator != nil {
		return managedServiceIdentity_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity_STATUS(generators)
	managedServiceIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity_STATUS(generators)
	AddRelatedPropertyGeneratorsForManagedServiceIdentity_STATUS(generators)
	managedServiceIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_STATUS{}), generators)

	return managedServiceIdentity_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentity_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForManagedServiceIdentity_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedServiceIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(
		gen.AlphaString(),
		UserAssignedIdentity_STATUSGenerator())
}

func Test_Metadata_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Metadata_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMetadata_STATUS, Metadata_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMetadata_STATUS runs a test to see if a specific instance of Metadata_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForMetadata_STATUS(subject Metadata_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Metadata_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Metadata_STATUS instances for property testing - lazily instantiated by Metadata_STATUSGenerator()
var metadata_STATUSGenerator gopter.Gen

// Metadata_STATUSGenerator returns a generator of Metadata_STATUS instances for property testing.
func Metadata_STATUSGenerator() gopter.Gen {
	if metadata_STATUSGenerator != nil {
		return metadata_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetadata_STATUS(generators)
	metadata_STATUSGenerator = gen.Struct(reflect.TypeOf(Metadata_STATUS{}), generators)

	return metadata_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForMetadata_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMetadata_STATUS(gens map[string]gopter.Gen) {
	gens["ProvisionedBy"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisionedByImmutableId"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisionedByResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_MicrosoftFabricDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MicrosoftFabricDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMicrosoftFabricDestination, MicrosoftFabricDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMicrosoftFabricDestination runs a test to see if a specific instance of MicrosoftFabricDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForMicrosoftFabricDestination(subject MicrosoftFabricDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MicrosoftFabricDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MicrosoftFabricDestination instances for property testing - lazily instantiated by
// MicrosoftFabricDestinationGenerator()
var microsoftFabricDestinationGenerator gopter.Gen

// MicrosoftFabricDestinationGenerator returns a generator of MicrosoftFabricDestination instances for property testing.
func MicrosoftFabricDestinationGenerator() gopter.Gen {
	if microsoftFabricDestinationGenerator != nil {
		return microsoftFabricDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMicrosoftFabricDestination(generators)
	microsoftFabricDestinationGenerator = gen.Struct(reflect.TypeOf(MicrosoftFabricDestination{}), generators)

	return microsoftFabricDestinationGenerator
}

// AddIndependentPropertyGeneratorsForMicrosoftFabricDestination is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMicrosoftFabricDestination(gens map[string]gopter.Gen) {
	gens["ArtifactId"] = gen.PtrOf(gen.AlphaString())
	gens["DatabaseName"] = gen.PtrOf(gen.AlphaString())
	gens["IngestionUri"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
}

func Test_MicrosoftFabricDestination_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MicrosoftFabricDestination_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMicrosoftFabricDestination_STATUS, MicrosoftFabricDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMicrosoftFabricDestination_STATUS runs a test to see if a specific instance of MicrosoftFabricDestination_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForMicrosoftFabricDestination_STATUS(subject MicrosoftFabricDestination_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MicrosoftFabricDestination_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MicrosoftFabricDestination_STATUS instances for property testing - lazily instantiated by
// MicrosoftFabricDestination_STATUSGenerator()
var microsoftFabricDestination_STATUSGenerator gopter.Gen

// MicrosoftFabricDestination_STATUSGenerator returns a generator of MicrosoftFabricDestination_STATUS instances for property testing.
func MicrosoftFabricDestination_STATUSGenerator() gopter.Gen {
	if microsoftFabricDestination_STATUSGenerator != nil {
		return microsoftFabricDestination_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMicrosoftFabricDestination_STATUS(generators)
	microsoftFabricDestination_STATUSGenerator = gen.Struct(reflect.TypeOf(MicrosoftFabricDestination_STATUS{}), generators)

	return microsoftFabricDestination_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForMicrosoftFabricDestination_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMicrosoftFabricDestination_STATUS(gens map[string]gopter.Gen) {
	gens["ArtifactId"] = gen.PtrOf(gen.AlphaString())
	gens["DatabaseName"] = gen.PtrOf(gen.AlphaString())
	gens["IngestionUri"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
}

func Test_MonitoringAccountDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MonitoringAccountDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMonitoringAccountDestination, MonitoringAccountDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMonitoringAccountDestination runs a test to see if a specific instance of MonitoringAccountDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForMonitoringAccountDestination(subject MonitoringAccountDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MonitoringAccountDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MonitoringAccountDestination instances for property testing - lazily instantiated by
// MonitoringAccountDestinationGenerator()
var monitoringAccountDestinationGenerator gopter.Gen

// MonitoringAccountDestinationGenerator returns a generator of MonitoringAccountDestination instances for property testing.
func MonitoringAccountDestinationGenerator() gopter.Gen {
	if monitoringAccountDestinationGenerator != nil {
		return monitoringAccountDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMonitoringAccountDestination(generators)
	monitoringAccountDestinationGenerator = gen.Struct(reflect.TypeOf(MonitoringAccountDestination{}), generators)

	return monitoringAccountDestinationGenerator
}

// AddIndependentPropertyGeneratorsForMonitoringAccountDestination is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMonitoringAccountDestination(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_MonitoringAccountDestination_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MonitoringAccountDestination_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMonitoringAccountDestination_STATUS, MonitoringAccountDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMonitoringAccountDestination_STATUS runs a test to see if a specific instance of MonitoringAccountDestination_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForMonitoringAccountDestination_STATUS(subject MonitoringAccountDestination_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MonitoringAccountDestination_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MonitoringAccountDestination_STATUS instances for property testing - lazily instantiated by
// MonitoringAccountDestination_STATUSGenerator()
var monitoringAccountDestination_STATUSGenerator gopter.Gen

// MonitoringAccountDestination_STATUSGenerator returns a generator of MonitoringAccountDestination_STATUS instances for property testing.
func MonitoringAccountDestination_STATUSGenerator() gopter.Gen {
	if monitoringAccountDestination_STATUSGenerator != nil {
		return monitoringAccountDestination_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMonitoringAccountDestination_STATUS(generators)
	monitoringAccountDestination_STATUSGenerator = gen.Struct(reflect.TypeOf(MonitoringAccountDestination_STATUS{}), generators)

	return monitoringAccountDestination_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForMonitoringAccountDestination_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMonitoringAccountDestination_STATUS(gens map[string]gopter.Gen) {
	gens["AccountId"] = gen.PtrOf(gen.AlphaString())
	gens["AccountResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_PerfCounterDataSource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PerfCounterDataSource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPerfCounterDataSource, PerfCounterDataSourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPerfCounterDataSource runs a test to see if a specific instance of PerfCounterDataSource round trips to JSON and back losslessly
func RunJSONSerializationTestForPerfCounterDataSource(subject PerfCounterDataSource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PerfCounterDataSource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PerfCounterDataSource instances for property testing - lazily instantiated by
// PerfCounterDataSourceGenerator()
var perfCounterDataSourceGenerator gopter.Gen

// PerfCounterDataSourceGenerator returns a generator of PerfCounterDataSource instances for property testing.
func PerfCounterDataSourceGenerator() gopter.Gen {
	if perfCounterDataSourceGenerator != nil {
		return perfCounterDataSourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPerfCounterDataSource(generators)
	perfCounterDataSourceGenerator = gen.Struct(reflect.TypeOf(PerfCounterDataSource{}), generators)

	return perfCounterDataSourceGenerator
}

// AddIndependentPropertyGeneratorsForPerfCounterDataSource is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPerfCounterDataSource(gens map[string]gopter.Gen) {
	gens["CounterSpecifiers"] = gen.SliceOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["SamplingFrequencyInSeconds"] = gen.PtrOf(gen.Int())
	gens["Streams"] = gen.SliceOf(gen.AlphaString())
	gens["TransformKql"] = gen.PtrOf(gen.AlphaString())
}

func Test_PerfCounterDataSource_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PerfCounterDataSource_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPerfCounterDataSource_STATUS, PerfCounterDataSource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPerfCounterDataSource_STATUS runs a test to see if a specific instance of PerfCounterDataSource_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPerfCounterDataSource_STATUS(subject PerfCounterDataSource_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PerfCounterDataSource_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PerfCounterDataSource_STATUS instances for property testing - lazily instantiated by
// PerfCounterDataSource_STATUSGenerator()
var perfCounterDataSource_STATUSGenerator gopter.Gen

// PerfCounterDataSource_STATUSGenerator returns a generator of PerfCounterDataSource_STATUS instances for property testing.
func PerfCounterDataSource_STATUSGenerator() gopter.Gen {
	if perfCounterDataSource_STATUSGenerator != nil {
		return perfCounterDataSource_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPerfCounterDataSource_STATUS(generators)
	perfCounterDataSource_STATUSGenerator = gen.Struct(reflect.TypeOf(PerfCounterDataSource_STATUS{}), generators)

	return perfCounterDataSource_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForPerfCounterDataSource_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPerfCounterDataSource_STATUS(gens map[string]gopter.Gen) {
	gens["CounterSpecifiers"] = gen.SliceOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["SamplingFrequencyInSeconds"] = gen.PtrOf(gen.Int())
	gens["Streams"] = gen.SliceOf(gen.AlphaString())
	gens["TransformKql"] = gen.PtrOf(gen.AlphaString())
}

func Test_PlatformTelemetryDataSource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PlatformTelemetryDataSource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPlatformTelemetryDataSource, PlatformTelemetryDataSourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPlatformTelemetryDataSource runs a test to see if a specific instance of PlatformTelemetryDataSource round trips to JSON and back losslessly
func RunJSONSerializationTestForPlatformTelemetryDataSource(subject PlatformTelemetryDataSource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PlatformTelemetryDataSource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PlatformTelemetryDataSource instances for property testing - lazily instantiated by
// PlatformTelemetryDataSourceGenerator()
var platformTelemetryDataSourceGenerator gopter.Gen

// PlatformTelemetryDataSourceGenerator returns a generator of PlatformTelemetryDataSource instances for property testing.
func PlatformTelemetryDataSourceGenerator() gopter.Gen {
	if platformTelemetryDataSourceGenerator != nil {
		return platformTelemetryDataSourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPlatformTelemetryDataSource(generators)
	platformTelemetryDataSourceGenerator = gen.Struct(reflect.TypeOf(PlatformTelemetryDataSource{}), generators)

	return platformTelemetryDataSourceGenerator
}

// AddIndependentPropertyGeneratorsForPlatformTelemetryDataSource is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPlatformTelemetryDataSource(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Streams"] = gen.SliceOf(gen.AlphaString())
}

func Test_PlatformTelemetryDataSource_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PlatformTelemetryDataSource_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPlatformTelemetryDataSource_STATUS, PlatformTelemetryDataSource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPlatformTelemetryDataSource_STATUS runs a test to see if a specific instance of PlatformTelemetryDataSource_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPlatformTelemetryDataSource_STATUS(subject PlatformTelemetryDataSource_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PlatformTelemetryDataSource_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PlatformTelemetryDataSource_STATUS instances for property testing - lazily instantiated by
// PlatformTelemetryDataSource_STATUSGenerator()
var platformTelemetryDataSource_STATUSGenerator gopter.Gen

// PlatformTelemetryDataSource_STATUSGenerator returns a generator of PlatformTelemetryDataSource_STATUS instances for property testing.
func PlatformTelemetryDataSource_STATUSGenerator() gopter.Gen {
	if platformTelemetryDataSource_STATUSGenerator != nil {
		return platformTelemetryDataSource_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPlatformTelemetryDataSource_STATUS(generators)
	platformTelemetryDataSource_STATUSGenerator = gen.Struct(reflect.TypeOf(PlatformTelemetryDataSource_STATUS{}), generators)

	return platformTelemetryDataSource_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForPlatformTelemetryDataSource_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPlatformTelemetryDataSource_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Streams"] = gen.SliceOf(gen.AlphaString())
}

func Test_PrometheusForwarderDataSource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrometheusForwarderDataSource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrometheusForwarderDataSource, PrometheusForwarderDataSourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrometheusForwarderDataSource runs a test to see if a specific instance of PrometheusForwarderDataSource round trips to JSON and back losslessly
func RunJSONSerializationTestForPrometheusForwarderDataSource(subject PrometheusForwarderDataSource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrometheusForwarderDataSource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrometheusForwarderDataSource instances for property testing - lazily instantiated by
// PrometheusForwarderDataSourceGenerator()
var prometheusForwarderDataSourceGenerator gopter.Gen

// PrometheusForwarderDataSourceGenerator returns a generator of PrometheusForwarderDataSource instances for property testing.
func PrometheusForwarderDataSourceGenerator() gopter.Gen {
	if prometheusForwarderDataSourceGenerator != nil {
		return prometheusForwarderDataSourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrometheusForwarderDataSource(generators)
	prometheusForwarderDataSourceGenerator = gen.Struct(reflect.TypeOf(PrometheusForwarderDataSource{}), generators)

	return prometheusForwarderDataSourceGenerator
}

// AddIndependentPropertyGeneratorsForPrometheusForwarderDataSource is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrometheusForwarderDataSource(gens map[string]gopter.Gen) {
	gens["LabelIncludeFilter"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Streams"] = gen.SliceOf(gen.AlphaString())
}

func Test_PrometheusForwarderDataSource_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrometheusForwarderDataSource_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrometheusForwarderDataSource_STATUS, PrometheusForwarderDataSource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrometheusForwarderDataSource_STATUS runs a test to see if a specific instance of PrometheusForwarderDataSource_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPrometheusForwarderDataSource_STATUS(subject PrometheusForwarderDataSource_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrometheusForwarderDataSource_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrometheusForwarderDataSource_STATUS instances for property testing - lazily instantiated by
// PrometheusForwarderDataSource_STATUSGenerator()
var prometheusForwarderDataSource_STATUSGenerator gopter.Gen

// PrometheusForwarderDataSource_STATUSGenerator returns a generator of PrometheusForwarderDataSource_STATUS instances for property testing.
func PrometheusForwarderDataSource_STATUSGenerator() gopter.Gen {
	if prometheusForwarderDataSource_STATUSGenerator != nil {
		return prometheusForwarderDataSource_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrometheusForwarderDataSource_STATUS(generators)
	prometheusForwarderDataSource_STATUSGenerator = gen.Struct(reflect.TypeOf(PrometheusForwarderDataSource_STATUS{}), generators)

	return prometheusForwarderDataSource_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForPrometheusForwarderDataSource_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrometheusForwarderDataSource_STATUS(gens map[string]gopter.Gen) {
	gens["LabelIncludeFilter"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Streams"] = gen.SliceOf(gen.AlphaString())
}

func Test_ReferencesSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ReferencesSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForReferencesSpec, ReferencesSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForReferencesSpec runs a test to see if a specific instance of ReferencesSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForReferencesSpec(subject ReferencesSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ReferencesSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ReferencesSpec instances for property testing - lazily instantiated by ReferencesSpecGenerator()
var referencesSpecGenerator gopter.Gen

// ReferencesSpecGenerator returns a generator of ReferencesSpec instances for property testing.
func ReferencesSpecGenerator() gopter.Gen {
	if referencesSpecGenerator != nil {
		return referencesSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForReferencesSpec(generators)
	referencesSpecGenerator = gen.Struct(reflect.TypeOf(ReferencesSpec{}), generators)

	return referencesSpecGenerator
}

// AddRelatedPropertyGeneratorsForReferencesSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForReferencesSpec(gens map[string]gopter.Gen) {
	gens["EnrichmentData"] = gen.PtrOf(EnrichmentDataGenerator())
}

func Test_ReferencesSpec_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ReferencesSpec_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForReferencesSpec_STATUS, ReferencesSpec_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForReferencesSpec_STATUS runs a test to see if a specific instance of ReferencesSpec_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForReferencesSpec_STATUS(subject ReferencesSpec_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ReferencesSpec_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ReferencesSpec_STATUS instances for property testing - lazily instantiated by
// ReferencesSpec_STATUSGenerator()
var referencesSpec_STATUSGenerator gopter.Gen

// ReferencesSpec_STATUSGenerator returns a generator of ReferencesSpec_STATUS instances for property testing.
func ReferencesSpec_STATUSGenerator() gopter.Gen {
	if referencesSpec_STATUSGenerator != nil {
		return referencesSpec_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForReferencesSpec_STATUS(generators)
	referencesSpec_STATUSGenerator = gen.Struct(reflect.TypeOf(ReferencesSpec_STATUS{}), generators)

	return referencesSpec_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForReferencesSpec_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForReferencesSpec_STATUS(gens map[string]gopter.Gen) {
	gens["EnrichmentData"] = gen.PtrOf(EnrichmentData_STATUSGenerator())
}

func Test_StorageBlob_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageBlob via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageBlob, StorageBlobGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageBlob runs a test to see if a specific instance of StorageBlob round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageBlob(subject StorageBlob) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageBlob
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageBlob instances for property testing - lazily instantiated by StorageBlobGenerator()
var storageBlobGenerator gopter.Gen

// StorageBlobGenerator returns a generator of StorageBlob instances for property testing.
func StorageBlobGenerator() gopter.Gen {
	if storageBlobGenerator != nil {
		return storageBlobGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageBlob(generators)
	storageBlobGenerator = gen.Struct(reflect.TypeOf(StorageBlob{}), generators)

	return storageBlobGenerator
}

// AddIndependentPropertyGeneratorsForStorageBlob is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageBlob(gens map[string]gopter.Gen) {
	gens["BlobUrl"] = gen.PtrOf(gen.AlphaString())
	gens["LookupType"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_StorageBlobDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageBlobDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageBlobDestination, StorageBlobDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageBlobDestination runs a test to see if a specific instance of StorageBlobDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageBlobDestination(subject StorageBlobDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageBlobDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageBlobDestination instances for property testing - lazily instantiated by
// StorageBlobDestinationGenerator()
var storageBlobDestinationGenerator gopter.Gen

// StorageBlobDestinationGenerator returns a generator of StorageBlobDestination instances for property testing.
func StorageBlobDestinationGenerator() gopter.Gen {
	if storageBlobDestinationGenerator != nil {
		return storageBlobDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageBlobDestination(generators)
	storageBlobDestinationGenerator = gen.Struct(reflect.TypeOf(StorageBlobDestination{}), generators)

	return storageBlobDestinationGenerator
}

// AddIndependentPropertyGeneratorsForStorageBlobDestination is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageBlobDestination(gens map[string]gopter.Gen) {
	gens["ContainerName"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_StorageBlobDestination_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageBlobDestination_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageBlobDestination_STATUS, StorageBlobDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageBlobDestination_STATUS runs a test to see if a specific instance of StorageBlobDestination_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageBlobDestination_STATUS(subject StorageBlobDestination_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageBlobDestination_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageBlobDestination_STATUS instances for property testing - lazily instantiated by
// StorageBlobDestination_STATUSGenerator()
var storageBlobDestination_STATUSGenerator gopter.Gen

// StorageBlobDestination_STATUSGenerator returns a generator of StorageBlobDestination_STATUS instances for property testing.
func StorageBlobDestination_STATUSGenerator() gopter.Gen {
	if storageBlobDestination_STATUSGenerator != nil {
		return storageBlobDestination_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageBlobDestination_STATUS(generators)
	storageBlobDestination_STATUSGenerator = gen.Struct(reflect.TypeOf(StorageBlobDestination_STATUS{}), generators)

	return storageBlobDestination_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForStorageBlobDestination_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageBlobDestination_STATUS(gens map[string]gopter.Gen) {
	gens["ContainerName"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_StorageBlob_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageBlob_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageBlob_STATUS, StorageBlob_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageBlob_STATUS runs a test to see if a specific instance of StorageBlob_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageBlob_STATUS(subject StorageBlob_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageBlob_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageBlob_STATUS instances for property testing - lazily instantiated by StorageBlob_STATUSGenerator()
var storageBlob_STATUSGenerator gopter.Gen

// StorageBlob_STATUSGenerator returns a generator of StorageBlob_STATUS instances for property testing.
func StorageBlob_STATUSGenerator() gopter.Gen {
	if storageBlob_STATUSGenerator != nil {
		return storageBlob_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageBlob_STATUS(generators)
	storageBlob_STATUSGenerator = gen.Struct(reflect.TypeOf(StorageBlob_STATUS{}), generators)

	return storageBlob_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForStorageBlob_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageBlob_STATUS(gens map[string]gopter.Gen) {
	gens["BlobUrl"] = gen.PtrOf(gen.AlphaString())
	gens["LookupType"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_StorageTableDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageTableDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageTableDestination, StorageTableDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageTableDestination runs a test to see if a specific instance of StorageTableDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageTableDestination(subject StorageTableDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageTableDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageTableDestination instances for property testing - lazily instantiated by
// StorageTableDestinationGenerator()
var storageTableDestinationGenerator gopter.Gen

// StorageTableDestinationGenerator returns a generator of StorageTableDestination instances for property testing.
func StorageTableDestinationGenerator() gopter.Gen {
	if storageTableDestinationGenerator != nil {
		return storageTableDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageTableDestination(generators)
	storageTableDestinationGenerator = gen.Struct(reflect.TypeOf(StorageTableDestination{}), generators)

	return storageTableDestinationGenerator
}

// AddIndependentPropertyGeneratorsForStorageTableDestination is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageTableDestination(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["TableName"] = gen.PtrOf(gen.AlphaString())
}

func Test_StorageTableDestination_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageTableDestination_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageTableDestination_STATUS, StorageTableDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageTableDestination_STATUS runs a test to see if a specific instance of StorageTableDestination_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageTableDestination_STATUS(subject StorageTableDestination_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageTableDestination_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageTableDestination_STATUS instances for property testing - lazily instantiated by
// StorageTableDestination_STATUSGenerator()
var storageTableDestination_STATUSGenerator gopter.Gen

// StorageTableDestination_STATUSGenerator returns a generator of StorageTableDestination_STATUS instances for property testing.
func StorageTableDestination_STATUSGenerator() gopter.Gen {
	if storageTableDestination_STATUSGenerator != nil {
		return storageTableDestination_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageTableDestination_STATUS(generators)
	storageTableDestination_STATUSGenerator = gen.Struct(reflect.TypeOf(StorageTableDestination_STATUS{}), generators)

	return storageTableDestination_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForStorageTableDestination_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageTableDestination_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["TableName"] = gen.PtrOf(gen.AlphaString())
}

func Test_StreamDeclaration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StreamDeclaration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStreamDeclaration, StreamDeclarationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStreamDeclaration runs a test to see if a specific instance of StreamDeclaration round trips to JSON and back losslessly
func RunJSONSerializationTestForStreamDeclaration(subject StreamDeclaration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StreamDeclaration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StreamDeclaration instances for property testing - lazily instantiated by StreamDeclarationGenerator()
var streamDeclarationGenerator gopter.Gen

// StreamDeclarationGenerator returns a generator of StreamDeclaration instances for property testing.
func StreamDeclarationGenerator() gopter.Gen {
	if streamDeclarationGenerator != nil {
		return streamDeclarationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForStreamDeclaration(generators)
	streamDeclarationGenerator = gen.Struct(reflect.TypeOf(StreamDeclaration{}), generators)

	return streamDeclarationGenerator
}

// AddRelatedPropertyGeneratorsForStreamDeclaration is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStreamDeclaration(gens map[string]gopter.Gen) {
	gens["Columns"] = gen.SliceOf(ColumnDefinitionGenerator())
}

func Test_StreamDeclaration_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StreamDeclaration_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStreamDeclaration_STATUS, StreamDeclaration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStreamDeclaration_STATUS runs a test to see if a specific instance of StreamDeclaration_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForStreamDeclaration_STATUS(subject StreamDeclaration_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StreamDeclaration_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StreamDeclaration_STATUS instances for property testing - lazily instantiated by
// StreamDeclaration_STATUSGenerator()
var streamDeclaration_STATUSGenerator gopter.Gen

// StreamDeclaration_STATUSGenerator returns a generator of StreamDeclaration_STATUS instances for property testing.
func StreamDeclaration_STATUSGenerator() gopter.Gen {
	if streamDeclaration_STATUSGenerator != nil {
		return streamDeclaration_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForStreamDeclaration_STATUS(generators)
	streamDeclaration_STATUSGenerator = gen.Struct(reflect.TypeOf(StreamDeclaration_STATUS{}), generators)

	return streamDeclaration_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForStreamDeclaration_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStreamDeclaration_STATUS(gens map[string]gopter.Gen) {
	gens["Columns"] = gen.SliceOf(ColumnDefinition_STATUSGenerator())
}

func Test_SyslogDataSource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SyslogDataSource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSyslogDataSource, SyslogDataSourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSyslogDataSource runs a test to see if a specific instance of SyslogDataSource round trips to JSON and back losslessly
func RunJSONSerializationTestForSyslogDataSource(subject SyslogDataSource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SyslogDataSource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SyslogDataSource instances for property testing - lazily instantiated by SyslogDataSourceGenerator()
var syslogDataSourceGenerator gopter.Gen

// SyslogDataSourceGenerator returns a generator of SyslogDataSource instances for property testing.
func SyslogDataSourceGenerator() gopter.Gen {
	if syslogDataSourceGenerator != nil {
		return syslogDataSourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSyslogDataSource(generators)
	syslogDataSourceGenerator = gen.Struct(reflect.TypeOf(SyslogDataSource{}), generators)

	return syslogDataSourceGenerator
}

// AddIndependentPropertyGeneratorsForSyslogDataSource is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSyslogDataSource(gens map[string]gopter.Gen) {
	gens["FacilityNames"] = gen.SliceOf(gen.AlphaString())
	gens["LogLevels"] = gen.SliceOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Streams"] = gen.SliceOf(gen.AlphaString())
	gens["TransformKql"] = gen.PtrOf(gen.AlphaString())
}

func Test_SyslogDataSource_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SyslogDataSource_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSyslogDataSource_STATUS, SyslogDataSource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSyslogDataSource_STATUS runs a test to see if a specific instance of SyslogDataSource_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSyslogDataSource_STATUS(subject SyslogDataSource_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SyslogDataSource_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SyslogDataSource_STATUS instances for property testing - lazily instantiated by
// SyslogDataSource_STATUSGenerator()
var syslogDataSource_STATUSGenerator gopter.Gen

// SyslogDataSource_STATUSGenerator returns a generator of SyslogDataSource_STATUS instances for property testing.
func SyslogDataSource_STATUSGenerator() gopter.Gen {
	if syslogDataSource_STATUSGenerator != nil {
		return syslogDataSource_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSyslogDataSource_STATUS(generators)
	syslogDataSource_STATUSGenerator = gen.Struct(reflect.TypeOf(SyslogDataSource_STATUS{}), generators)

	return syslogDataSource_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSyslogDataSource_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSyslogDataSource_STATUS(gens map[string]gopter.Gen) {
	gens["FacilityNames"] = gen.SliceOf(gen.AlphaString())
	gens["LogLevels"] = gen.SliceOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Streams"] = gen.SliceOf(gen.AlphaString())
	gens["TransformKql"] = gen.PtrOf(gen.AlphaString())
}

func Test_SystemData_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SystemData_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSystemData_STATUS, SystemData_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSystemData_STATUS runs a test to see if a specific instance of SystemData_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSystemData_STATUS(subject SystemData_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SystemData_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SystemData_STATUS instances for property testing - lazily instantiated by SystemData_STATUSGenerator()
var systemData_STATUSGenerator gopter.Gen

// SystemData_STATUSGenerator returns a generator of SystemData_STATUS instances for property testing.
func SystemData_STATUSGenerator() gopter.Gen {
	if systemData_STATUSGenerator != nil {
		return systemData_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSystemData_STATUS(generators)
	systemData_STATUSGenerator = gen.Struct(reflect.TypeOf(SystemData_STATUS{}), generators)

	return systemData_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSystemData_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSystemData_STATUS(gens map[string]gopter.Gen) {
	gens["CreatedAt"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedBy"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedByType"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedAt"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedBy"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedByType"] = gen.PtrOf(gen.AlphaString())
}

func Test_UserAssignedIdentityDetails_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentityDetails via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentityDetails, UserAssignedIdentityDetailsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentityDetails runs a test to see if a specific instance of UserAssignedIdentityDetails round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentityDetails(subject UserAssignedIdentityDetails) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentityDetails
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentityDetails instances for property testing - lazily instantiated by
// UserAssignedIdentityDetailsGenerator()
var userAssignedIdentityDetailsGenerator gopter.Gen

// UserAssignedIdentityDetailsGenerator returns a generator of UserAssignedIdentityDetails instances for property testing.
func UserAssignedIdentityDetailsGenerator() gopter.Gen {
	if userAssignedIdentityDetailsGenerator != nil {
		return userAssignedIdentityDetailsGenerator
	}

	generators := make(map[string]gopter.Gen)
	userAssignedIdentityDetailsGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentityDetails{}), generators)

	return userAssignedIdentityDetailsGenerator
}

func Test_UserAssignedIdentity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentity_STATUS, UserAssignedIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentity_STATUS runs a test to see if a specific instance of UserAssignedIdentity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentity_STATUS(subject UserAssignedIdentity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentity_STATUS instances for property testing - lazily instantiated by
// UserAssignedIdentity_STATUSGenerator()
var userAssignedIdentity_STATUSGenerator gopter.Gen

// UserAssignedIdentity_STATUSGenerator returns a generator of UserAssignedIdentity_STATUS instances for property testing.
func UserAssignedIdentity_STATUSGenerator() gopter.Gen {
	if userAssignedIdentity_STATUSGenerator != nil {
		return userAssignedIdentity_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserAssignedIdentity_STATUS(generators)
	userAssignedIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentity_STATUS{}), generators)

	return userAssignedIdentity_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForUserAssignedIdentity_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserAssignedIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_WindowsEventLogDataSource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WindowsEventLogDataSource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWindowsEventLogDataSource, WindowsEventLogDataSourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWindowsEventLogDataSource runs a test to see if a specific instance of WindowsEventLogDataSource round trips to JSON and back losslessly
func RunJSONSerializationTestForWindowsEventLogDataSource(subject WindowsEventLogDataSource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WindowsEventLogDataSource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WindowsEventLogDataSource instances for property testing - lazily instantiated by
// WindowsEventLogDataSourceGenerator()
var windowsEventLogDataSourceGenerator gopter.Gen

// WindowsEventLogDataSourceGenerator returns a generator of WindowsEventLogDataSource instances for property testing.
func WindowsEventLogDataSourceGenerator() gopter.Gen {
	if windowsEventLogDataSourceGenerator != nil {
		return windowsEventLogDataSourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsEventLogDataSource(generators)
	windowsEventLogDataSourceGenerator = gen.Struct(reflect.TypeOf(WindowsEventLogDataSource{}), generators)

	return windowsEventLogDataSourceGenerator
}

// AddIndependentPropertyGeneratorsForWindowsEventLogDataSource is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWindowsEventLogDataSource(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Streams"] = gen.SliceOf(gen.AlphaString())
	gens["TransformKql"] = gen.PtrOf(gen.AlphaString())
	gens["XPathQueries"] = gen.SliceOf(gen.AlphaString())
}

func Test_WindowsEventLogDataSource_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WindowsEventLogDataSource_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWindowsEventLogDataSource_STATUS, WindowsEventLogDataSource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWindowsEventLogDataSource_STATUS runs a test to see if a specific instance of WindowsEventLogDataSource_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForWindowsEventLogDataSource_STATUS(subject WindowsEventLogDataSource_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WindowsEventLogDataSource_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WindowsEventLogDataSource_STATUS instances for property testing - lazily instantiated by
// WindowsEventLogDataSource_STATUSGenerator()
var windowsEventLogDataSource_STATUSGenerator gopter.Gen

// WindowsEventLogDataSource_STATUSGenerator returns a generator of WindowsEventLogDataSource_STATUS instances for property testing.
func WindowsEventLogDataSource_STATUSGenerator() gopter.Gen {
	if windowsEventLogDataSource_STATUSGenerator != nil {
		return windowsEventLogDataSource_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsEventLogDataSource_STATUS(generators)
	windowsEventLogDataSource_STATUSGenerator = gen.Struct(reflect.TypeOf(WindowsEventLogDataSource_STATUS{}), generators)

	return windowsEventLogDataSource_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForWindowsEventLogDataSource_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWindowsEventLogDataSource_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Streams"] = gen.SliceOf(gen.AlphaString())
	gens["TransformKql"] = gen.PtrOf(gen.AlphaString())
	gens["XPathQueries"] = gen.SliceOf(gen.AlphaString())
}

func Test_WindowsFirewallLogsDataSource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WindowsFirewallLogsDataSource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWindowsFirewallLogsDataSource, WindowsFirewallLogsDataSourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWindowsFirewallLogsDataSource runs a test to see if a specific instance of WindowsFirewallLogsDataSource round trips to JSON and back losslessly
func RunJSONSerializationTestForWindowsFirewallLogsDataSource(subject WindowsFirewallLogsDataSource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WindowsFirewallLogsDataSource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WindowsFirewallLogsDataSource instances for property testing - lazily instantiated by
// WindowsFirewallLogsDataSourceGenerator()
var windowsFirewallLogsDataSourceGenerator gopter.Gen

// WindowsFirewallLogsDataSourceGenerator returns a generator of WindowsFirewallLogsDataSource instances for property testing.
func WindowsFirewallLogsDataSourceGenerator() gopter.Gen {
	if windowsFirewallLogsDataSourceGenerator != nil {
		return windowsFirewallLogsDataSourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsFirewallLogsDataSource(generators)
	windowsFirewallLogsDataSourceGenerator = gen.Struct(reflect.TypeOf(WindowsFirewallLogsDataSource{}), generators)

	return windowsFirewallLogsDataSourceGenerator
}

// AddIndependentPropertyGeneratorsForWindowsFirewallLogsDataSource is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWindowsFirewallLogsDataSource(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ProfileFilter"] = gen.SliceOf(gen.AlphaString())
	gens["Streams"] = gen.SliceOf(gen.AlphaString())
}

func Test_WindowsFirewallLogsDataSource_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WindowsFirewallLogsDataSource_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWindowsFirewallLogsDataSource_STATUS, WindowsFirewallLogsDataSource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWindowsFirewallLogsDataSource_STATUS runs a test to see if a specific instance of WindowsFirewallLogsDataSource_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForWindowsFirewallLogsDataSource_STATUS(subject WindowsFirewallLogsDataSource_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WindowsFirewallLogsDataSource_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WindowsFirewallLogsDataSource_STATUS instances for property testing - lazily instantiated by
// WindowsFirewallLogsDataSource_STATUSGenerator()
var windowsFirewallLogsDataSource_STATUSGenerator gopter.Gen

// WindowsFirewallLogsDataSource_STATUSGenerator returns a generator of WindowsFirewallLogsDataSource_STATUS instances for property testing.
func WindowsFirewallLogsDataSource_STATUSGenerator() gopter.Gen {
	if windowsFirewallLogsDataSource_STATUSGenerator != nil {
		return windowsFirewallLogsDataSource_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsFirewallLogsDataSource_STATUS(generators)
	windowsFirewallLogsDataSource_STATUSGenerator = gen.Struct(reflect.TypeOf(WindowsFirewallLogsDataSource_STATUS{}), generators)

	return windowsFirewallLogsDataSource_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForWindowsFirewallLogsDataSource_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWindowsFirewallLogsDataSource_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ProfileFilter"] = gen.SliceOf(gen.AlphaString())
	gens["Streams"] = gen.SliceOf(gen.AlphaString())
}
