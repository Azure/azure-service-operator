// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package storage

import (
	"fmt"
	v20230601s "github.com/Azure/azure-service-operator/v2/api/insights/v1api20230601/storage"
	v20240311s "github.com/Azure/azure-service-operator/v2/api/insights/v1api20240311/storage"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/rotisserie/eris"
	"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
)

// +kubebuilder:object:root=true
// +kubebuilder:resource:categories={azure,insights}
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Storage version of v1api20230311.DataCollectionRule
// Generator information:
// - Generated from: /monitor/resource-manager/Microsoft.Insights/stable/2023-03-11/dataCollectionRules_API.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Insights/dataCollectionRules/{dataCollectionRuleName}
type DataCollectionRule struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              DataCollectionRule_Spec           `json:"spec,omitempty"`
	Status            DataCollectionRuleResource_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &DataCollectionRule{}

// GetConditions returns the conditions of the resource
func (rule *DataCollectionRule) GetConditions() conditions.Conditions {
	return rule.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (rule *DataCollectionRule) SetConditions(conditions conditions.Conditions) {
	rule.Status.Conditions = conditions
}

var _ conversion.Convertible = &DataCollectionRule{}

// ConvertFrom populates our DataCollectionRule from the provided hub DataCollectionRule
func (rule *DataCollectionRule) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*v20240311s.DataCollectionRule)
	if !ok {
		return fmt.Errorf("expected insights/v1api20240311/storage/DataCollectionRule but received %T instead", hub)
	}

	return rule.AssignProperties_From_DataCollectionRule(source)
}

// ConvertTo populates the provided hub DataCollectionRule from our DataCollectionRule
func (rule *DataCollectionRule) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*v20240311s.DataCollectionRule)
	if !ok {
		return fmt.Errorf("expected insights/v1api20240311/storage/DataCollectionRule but received %T instead", hub)
	}

	return rule.AssignProperties_To_DataCollectionRule(destination)
}

var _ configmaps.Exporter = &DataCollectionRule{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (rule *DataCollectionRule) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if rule.Spec.OperatorSpec == nil {
		return nil
	}
	return rule.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &DataCollectionRule{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (rule *DataCollectionRule) SecretDestinationExpressions() []*core.DestinationExpression {
	if rule.Spec.OperatorSpec == nil {
		return nil
	}
	return rule.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.KubernetesResource = &DataCollectionRule{}

// AzureName returns the Azure name of the resource
func (rule *DataCollectionRule) AzureName() string {
	return rule.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2023-03-11"
func (rule DataCollectionRule) GetAPIVersion() string {
	return "2023-03-11"
}

// GetResourceScope returns the scope of the resource
func (rule *DataCollectionRule) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (rule *DataCollectionRule) GetSpec() genruntime.ConvertibleSpec {
	return &rule.Spec
}

// GetStatus returns the status of this resource
func (rule *DataCollectionRule) GetStatus() genruntime.ConvertibleStatus {
	return &rule.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (rule *DataCollectionRule) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Insights/dataCollectionRules"
func (rule *DataCollectionRule) GetType() string {
	return "Microsoft.Insights/dataCollectionRules"
}

// NewEmptyStatus returns a new empty (blank) status
func (rule *DataCollectionRule) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &DataCollectionRuleResource_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (rule *DataCollectionRule) Owner() *genruntime.ResourceReference {
	if rule.Spec.Owner == nil {
		return nil
	}

	group, kind := genruntime.LookupOwnerGroupKind(rule.Spec)
	return rule.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (rule *DataCollectionRule) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*DataCollectionRuleResource_STATUS); ok {
		rule.Status = *st
		return nil
	}

	// Convert status to required version
	var st DataCollectionRuleResource_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return eris.Wrap(err, "failed to convert status")
	}

	rule.Status = st
	return nil
}

// AssignProperties_From_DataCollectionRule populates our DataCollectionRule from the provided source DataCollectionRule
func (rule *DataCollectionRule) AssignProperties_From_DataCollectionRule(source *v20240311s.DataCollectionRule) error {

	// ObjectMeta
	rule.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec DataCollectionRule_Spec
	err := spec.AssignProperties_From_DataCollectionRule_Spec(&source.Spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_DataCollectionRule_Spec() to populate field Spec")
	}
	rule.Spec = spec

	// Status
	var status DataCollectionRuleResource_STATUS
	err = status.AssignProperties_From_DataCollectionRuleResource_STATUS(&source.Status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_DataCollectionRuleResource_STATUS() to populate field Status")
	}
	rule.Status = status

	// Invoke the augmentConversionForDataCollectionRule interface (if implemented) to customize the conversion
	var ruleAsAny any = rule
	if augmentedRule, ok := ruleAsAny.(augmentConversionForDataCollectionRule); ok {
		err := augmentedRule.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DataCollectionRule populates the provided destination DataCollectionRule from our DataCollectionRule
func (rule *DataCollectionRule) AssignProperties_To_DataCollectionRule(destination *v20240311s.DataCollectionRule) error {

	// ObjectMeta
	destination.ObjectMeta = *rule.ObjectMeta.DeepCopy()

	// Spec
	var spec v20240311s.DataCollectionRule_Spec
	err := rule.Spec.AssignProperties_To_DataCollectionRule_Spec(&spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_DataCollectionRule_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status v20240311s.DataCollectionRuleResource_STATUS
	err = rule.Status.AssignProperties_To_DataCollectionRuleResource_STATUS(&status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_DataCollectionRuleResource_STATUS() to populate field Status")
	}
	destination.Status = status

	// Invoke the augmentConversionForDataCollectionRule interface (if implemented) to customize the conversion
	var ruleAsAny any = rule
	if augmentedRule, ok := ruleAsAny.(augmentConversionForDataCollectionRule); ok {
		err := augmentedRule.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (rule *DataCollectionRule) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: rule.Spec.OriginalVersion,
		Kind:    "DataCollectionRule",
	}
}

// +kubebuilder:object:root=true
// Storage version of v1api20230311.DataCollectionRule
// Generator information:
// - Generated from: /monitor/resource-manager/Microsoft.Insights/stable/2023-03-11/dataCollectionRules_API.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Insights/dataCollectionRules/{dataCollectionRuleName}
type DataCollectionRuleList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []DataCollectionRule `json:"items"`
}

type augmentConversionForDataCollectionRule interface {
	AssignPropertiesFrom(src *v20240311s.DataCollectionRule) error
	AssignPropertiesTo(dst *v20240311s.DataCollectionRule) error
}

// Storage version of v1api20230311.DataCollectionRule_Spec
type DataCollectionRule_Spec struct {
	AgentSettings *AgentSettingsSpec `json:"agentSettings,omitempty"`

	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// DataCollectionEndpointReference: The resource ID of the data collection endpoint that this rule can be used with.
	DataCollectionEndpointReference *genruntime.ResourceReference   `armReference:"DataCollectionEndpointId" json:"dataCollectionEndpointReference,omitempty"`
	DataFlows                       []DataFlow                      `json:"dataFlows,omitempty"`
	DataSources                     *DataSourcesSpec                `json:"dataSources,omitempty"`
	Description                     *string                         `json:"description,omitempty"`
	Destinations                    *DestinationsSpec               `json:"destinations,omitempty"`
	Identity                        *ManagedServiceIdentity         `json:"identity,omitempty"`
	Kind                            *string                         `json:"kind,omitempty"`
	Location                        *string                         `json:"location,omitempty"`
	OperatorSpec                    *DataCollectionRuleOperatorSpec `json:"operatorSpec,omitempty"`
	OriginalVersion                 string                          `json:"originalVersion,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner              *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`
	PropertyBag        genruntime.PropertyBag             `json:"$propertyBag,omitempty"`
	References         *ReferencesSpec                    `json:"references,omitempty"`
	StreamDeclarations map[string]StreamDeclaration       `json:"streamDeclarations,omitempty"`
	Tags               map[string]string                  `json:"tags,omitempty"`
}

var _ genruntime.ConvertibleSpec = &DataCollectionRule_Spec{}

// ConvertSpecFrom populates our DataCollectionRule_Spec from the provided source
func (rule *DataCollectionRule_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v20240311s.DataCollectionRule_Spec)
	if ok {
		// Populate our instance from source
		return rule.AssignProperties_From_DataCollectionRule_Spec(src)
	}

	// Convert to an intermediate form
	src = &v20240311s.DataCollectionRule_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = rule.AssignProperties_From_DataCollectionRule_Spec(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our DataCollectionRule_Spec
func (rule *DataCollectionRule_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v20240311s.DataCollectionRule_Spec)
	if ok {
		// Populate destination from our instance
		return rule.AssignProperties_To_DataCollectionRule_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &v20240311s.DataCollectionRule_Spec{}
	err := rule.AssignProperties_To_DataCollectionRule_Spec(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_DataCollectionRule_Spec populates our DataCollectionRule_Spec from the provided source DataCollectionRule_Spec
func (rule *DataCollectionRule_Spec) AssignProperties_From_DataCollectionRule_Spec(source *v20240311s.DataCollectionRule_Spec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AgentSettings
	if source.AgentSettings != nil {
		var agentSetting AgentSettingsSpec
		err := agentSetting.AssignProperties_From_AgentSettingsSpec(source.AgentSettings)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AgentSettingsSpec() to populate field AgentSettings")
		}
		rule.AgentSettings = &agentSetting
	} else {
		rule.AgentSettings = nil
	}

	// AzureName
	rule.AzureName = source.AzureName

	// DataCollectionEndpointReference
	if source.DataCollectionEndpointReference != nil {
		dataCollectionEndpointReference := source.DataCollectionEndpointReference.Copy()
		rule.DataCollectionEndpointReference = &dataCollectionEndpointReference
	} else {
		rule.DataCollectionEndpointReference = nil
	}

	// DataFlows
	if source.DataFlows != nil {
		dataFlowList := make([]DataFlow, len(source.DataFlows))
		for dataFlowIndex, dataFlowItem := range source.DataFlows {
			var dataFlow DataFlow
			err := dataFlow.AssignProperties_From_DataFlow(&dataFlowItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_DataFlow() to populate field DataFlows")
			}
			dataFlowList[dataFlowIndex] = dataFlow
		}
		rule.DataFlows = dataFlowList
	} else {
		rule.DataFlows = nil
	}

	// DataSources
	if source.DataSources != nil {
		var dataSource DataSourcesSpec
		err := dataSource.AssignProperties_From_DataSourcesSpec(source.DataSources)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DataSourcesSpec() to populate field DataSources")
		}
		rule.DataSources = &dataSource
	} else {
		rule.DataSources = nil
	}

	// Description
	rule.Description = genruntime.ClonePointerToString(source.Description)

	// Destinations
	if source.Destinations != nil {
		var destination DestinationsSpec
		err := destination.AssignProperties_From_DestinationsSpec(source.Destinations)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DestinationsSpec() to populate field Destinations")
		}
		rule.Destinations = &destination
	} else {
		rule.Destinations = nil
	}

	// DirectDataSources
	if source.DirectDataSources != nil {
		propertyBag.Add("DirectDataSources", *source.DirectDataSources)
	} else {
		propertyBag.Remove("DirectDataSources")
	}

	// Identity
	if source.Identity != nil {
		var managedServiceIdentityStash v20230601s.ManagedServiceIdentity
		err := managedServiceIdentityStash.AssignProperties_From_ManagedServiceIdentity(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedServiceIdentity() to populate field ManagedServiceIdentityStash from Identity")
		}
		var identity ManagedServiceIdentity
		err = identity.AssignProperties_From_ManagedServiceIdentity(&managedServiceIdentityStash)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedServiceIdentity() to populate field Identity from ManagedServiceIdentityStash")
		}
		rule.Identity = &identity
	} else {
		rule.Identity = nil
	}

	// Kind
	rule.Kind = genruntime.ClonePointerToString(source.Kind)

	// Location
	rule.Location = genruntime.ClonePointerToString(source.Location)

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec DataCollectionRuleOperatorSpec
		err := operatorSpec.AssignProperties_From_DataCollectionRuleOperatorSpec(source.OperatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DataCollectionRuleOperatorSpec() to populate field OperatorSpec")
		}
		rule.OperatorSpec = &operatorSpec
	} else {
		rule.OperatorSpec = nil
	}

	// OriginalVersion
	rule.OriginalVersion = source.OriginalVersion

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		rule.Owner = &owner
	} else {
		rule.Owner = nil
	}

	// References
	if source.References != nil {
		var reference ReferencesSpec
		err := reference.AssignProperties_From_ReferencesSpec(source.References)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ReferencesSpec() to populate field References")
		}
		rule.References = &reference
	} else {
		rule.References = nil
	}

	// Sku
	if source.Sku != nil {
		propertyBag.Add("Sku", *source.Sku)
	} else {
		propertyBag.Remove("Sku")
	}

	// StreamDeclarations
	if source.StreamDeclarations != nil {
		streamDeclarationMap := make(map[string]StreamDeclaration, len(source.StreamDeclarations))
		for streamDeclarationKey, streamDeclarationValue := range source.StreamDeclarations {
			var streamDeclaration StreamDeclaration
			err := streamDeclaration.AssignProperties_From_StreamDeclaration(&streamDeclarationValue)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_StreamDeclaration() to populate field StreamDeclarations")
			}
			streamDeclarationMap[streamDeclarationKey] = streamDeclaration
		}
		rule.StreamDeclarations = streamDeclarationMap
	} else {
		rule.StreamDeclarations = nil
	}

	// Tags
	rule.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Update the property bag
	if len(propertyBag) > 0 {
		rule.PropertyBag = propertyBag
	} else {
		rule.PropertyBag = nil
	}

	// Invoke the augmentConversionForDataCollectionRule_Spec interface (if implemented) to customize the conversion
	var ruleAsAny any = rule
	if augmentedRule, ok := ruleAsAny.(augmentConversionForDataCollectionRule_Spec); ok {
		err := augmentedRule.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DataCollectionRule_Spec populates the provided destination DataCollectionRule_Spec from our DataCollectionRule_Spec
func (rule *DataCollectionRule_Spec) AssignProperties_To_DataCollectionRule_Spec(destination *v20240311s.DataCollectionRule_Spec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(rule.PropertyBag)

	// AgentSettings
	if rule.AgentSettings != nil {
		var agentSetting v20240311s.AgentSettingsSpec
		err := rule.AgentSettings.AssignProperties_To_AgentSettingsSpec(&agentSetting)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AgentSettingsSpec() to populate field AgentSettings")
		}
		destination.AgentSettings = &agentSetting
	} else {
		destination.AgentSettings = nil
	}

	// AzureName
	destination.AzureName = rule.AzureName

	// DataCollectionEndpointReference
	if rule.DataCollectionEndpointReference != nil {
		dataCollectionEndpointReference := rule.DataCollectionEndpointReference.Copy()
		destination.DataCollectionEndpointReference = &dataCollectionEndpointReference
	} else {
		destination.DataCollectionEndpointReference = nil
	}

	// DataFlows
	if rule.DataFlows != nil {
		dataFlowList := make([]v20240311s.DataFlow, len(rule.DataFlows))
		for dataFlowIndex, dataFlowItem := range rule.DataFlows {
			var dataFlow v20240311s.DataFlow
			err := dataFlowItem.AssignProperties_To_DataFlow(&dataFlow)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_DataFlow() to populate field DataFlows")
			}
			dataFlowList[dataFlowIndex] = dataFlow
		}
		destination.DataFlows = dataFlowList
	} else {
		destination.DataFlows = nil
	}

	// DataSources
	if rule.DataSources != nil {
		var dataSource v20240311s.DataSourcesSpec
		err := rule.DataSources.AssignProperties_To_DataSourcesSpec(&dataSource)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DataSourcesSpec() to populate field DataSources")
		}
		destination.DataSources = &dataSource
	} else {
		destination.DataSources = nil
	}

	// Description
	destination.Description = genruntime.ClonePointerToString(rule.Description)

	// Destinations
	if rule.Destinations != nil {
		var destinationLocal v20240311s.DestinationsSpec
		err := rule.Destinations.AssignProperties_To_DestinationsSpec(&destinationLocal)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DestinationsSpec() to populate field Destinations")
		}
		destination.Destinations = &destinationLocal
	} else {
		destination.Destinations = nil
	}

	// DirectDataSources
	if propertyBag.Contains("DirectDataSources") {
		var directDataSource v20240311s.DirectDataSourcesSpec
		err := propertyBag.Pull("DirectDataSources", &directDataSource)
		if err != nil {
			return eris.Wrap(err, "pulling 'DirectDataSources' from propertyBag")
		}

		destination.DirectDataSources = &directDataSource
	} else {
		destination.DirectDataSources = nil
	}

	// Identity
	if rule.Identity != nil {
		var managedServiceIdentityStash v20230601s.ManagedServiceIdentity
		err := rule.Identity.AssignProperties_To_ManagedServiceIdentity(&managedServiceIdentityStash)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedServiceIdentity() to populate field ManagedServiceIdentityStash from Identity")
		}
		var identity v20240311s.ManagedServiceIdentity
		err = managedServiceIdentityStash.AssignProperties_To_ManagedServiceIdentity(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedServiceIdentity() to populate field Identity from ManagedServiceIdentityStash")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Kind
	destination.Kind = genruntime.ClonePointerToString(rule.Kind)

	// Location
	destination.Location = genruntime.ClonePointerToString(rule.Location)

	// OperatorSpec
	if rule.OperatorSpec != nil {
		var operatorSpec v20240311s.DataCollectionRuleOperatorSpec
		err := rule.OperatorSpec.AssignProperties_To_DataCollectionRuleOperatorSpec(&operatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DataCollectionRuleOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = rule.OriginalVersion

	// Owner
	if rule.Owner != nil {
		owner := rule.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// References
	if rule.References != nil {
		var reference v20240311s.ReferencesSpec
		err := rule.References.AssignProperties_To_ReferencesSpec(&reference)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ReferencesSpec() to populate field References")
		}
		destination.References = &reference
	} else {
		destination.References = nil
	}

	// Sku
	if propertyBag.Contains("Sku") {
		var sku v20240311s.Sku
		err := propertyBag.Pull("Sku", &sku)
		if err != nil {
			return eris.Wrap(err, "pulling 'Sku' from propertyBag")
		}

		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// StreamDeclarations
	if rule.StreamDeclarations != nil {
		streamDeclarationMap := make(map[string]v20240311s.StreamDeclaration, len(rule.StreamDeclarations))
		for streamDeclarationKey, streamDeclarationValue := range rule.StreamDeclarations {
			var streamDeclaration v20240311s.StreamDeclaration
			err := streamDeclarationValue.AssignProperties_To_StreamDeclaration(&streamDeclaration)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_StreamDeclaration() to populate field StreamDeclarations")
			}
			streamDeclarationMap[streamDeclarationKey] = streamDeclaration
		}
		destination.StreamDeclarations = streamDeclarationMap
	} else {
		destination.StreamDeclarations = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(rule.Tags)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDataCollectionRule_Spec interface (if implemented) to customize the conversion
	var ruleAsAny any = rule
	if augmentedRule, ok := ruleAsAny.(augmentConversionForDataCollectionRule_Spec); ok {
		err := augmentedRule.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.DataCollectionRuleResource_STATUS
// Definition of ARM tracked top level resource.
type DataCollectionRuleResource_STATUS struct {
	AgentSettings            *AgentSettingsSpec_STATUS           `json:"agentSettings,omitempty"`
	Conditions               []conditions.Condition              `json:"conditions,omitempty"`
	DataCollectionEndpointId *string                             `json:"dataCollectionEndpointId,omitempty"`
	DataFlows                []DataFlow_STATUS                   `json:"dataFlows,omitempty"`
	DataSources              *DataSourcesSpec_STATUS             `json:"dataSources,omitempty"`
	Description              *string                             `json:"description,omitempty"`
	Destinations             *DestinationsSpec_STATUS            `json:"destinations,omitempty"`
	Endpoints                *EndpointsSpec_STATUS               `json:"endpoints,omitempty"`
	Etag                     *string                             `json:"etag,omitempty"`
	Id                       *string                             `json:"id,omitempty"`
	Identity                 *ManagedServiceIdentity_STATUS      `json:"identity,omitempty"`
	ImmutableId              *string                             `json:"immutableId,omitempty"`
	Kind                     *string                             `json:"kind,omitempty"`
	Location                 *string                             `json:"location,omitempty"`
	Metadata                 *Metadata_STATUS                    `json:"metadata,omitempty"`
	Name                     *string                             `json:"name,omitempty"`
	PropertyBag              genruntime.PropertyBag              `json:"$propertyBag,omitempty"`
	ProvisioningState        *string                             `json:"provisioningState,omitempty"`
	References               *ReferencesSpec_STATUS              `json:"references,omitempty"`
	StreamDeclarations       map[string]StreamDeclaration_STATUS `json:"streamDeclarations,omitempty"`
	SystemData               *SystemData_STATUS                  `json:"systemData,omitempty"`
	Tags                     map[string]string                   `json:"tags,omitempty"`
	Type                     *string                             `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &DataCollectionRuleResource_STATUS{}

// ConvertStatusFrom populates our DataCollectionRuleResource_STATUS from the provided source
func (resource *DataCollectionRuleResource_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v20240311s.DataCollectionRuleResource_STATUS)
	if ok {
		// Populate our instance from source
		return resource.AssignProperties_From_DataCollectionRuleResource_STATUS(src)
	}

	// Convert to an intermediate form
	src = &v20240311s.DataCollectionRuleResource_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = resource.AssignProperties_From_DataCollectionRuleResource_STATUS(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our DataCollectionRuleResource_STATUS
func (resource *DataCollectionRuleResource_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v20240311s.DataCollectionRuleResource_STATUS)
	if ok {
		// Populate destination from our instance
		return resource.AssignProperties_To_DataCollectionRuleResource_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &v20240311s.DataCollectionRuleResource_STATUS{}
	err := resource.AssignProperties_To_DataCollectionRuleResource_STATUS(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

// AssignProperties_From_DataCollectionRuleResource_STATUS populates our DataCollectionRuleResource_STATUS from the provided source DataCollectionRuleResource_STATUS
func (resource *DataCollectionRuleResource_STATUS) AssignProperties_From_DataCollectionRuleResource_STATUS(source *v20240311s.DataCollectionRuleResource_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AgentSettings
	if source.AgentSettings != nil {
		var agentSetting AgentSettingsSpec_STATUS
		err := agentSetting.AssignProperties_From_AgentSettingsSpec_STATUS(source.AgentSettings)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AgentSettingsSpec_STATUS() to populate field AgentSettings")
		}
		resource.AgentSettings = &agentSetting
	} else {
		resource.AgentSettings = nil
	}

	// Conditions
	resource.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// DataCollectionEndpointId
	resource.DataCollectionEndpointId = genruntime.ClonePointerToString(source.DataCollectionEndpointId)

	// DataFlows
	if source.DataFlows != nil {
		dataFlowList := make([]DataFlow_STATUS, len(source.DataFlows))
		for dataFlowIndex, dataFlowItem := range source.DataFlows {
			var dataFlow DataFlow_STATUS
			err := dataFlow.AssignProperties_From_DataFlow_STATUS(&dataFlowItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_DataFlow_STATUS() to populate field DataFlows")
			}
			dataFlowList[dataFlowIndex] = dataFlow
		}
		resource.DataFlows = dataFlowList
	} else {
		resource.DataFlows = nil
	}

	// DataSources
	if source.DataSources != nil {
		var dataSource DataSourcesSpec_STATUS
		err := dataSource.AssignProperties_From_DataSourcesSpec_STATUS(source.DataSources)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DataSourcesSpec_STATUS() to populate field DataSources")
		}
		resource.DataSources = &dataSource
	} else {
		resource.DataSources = nil
	}

	// Description
	resource.Description = genruntime.ClonePointerToString(source.Description)

	// Destinations
	if source.Destinations != nil {
		var destination DestinationsSpec_STATUS
		err := destination.AssignProperties_From_DestinationsSpec_STATUS(source.Destinations)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DestinationsSpec_STATUS() to populate field Destinations")
		}
		resource.Destinations = &destination
	} else {
		resource.Destinations = nil
	}

	// DirectDataSources
	if source.DirectDataSources != nil {
		propertyBag.Add("DirectDataSources", *source.DirectDataSources)
	} else {
		propertyBag.Remove("DirectDataSources")
	}

	// Endpoints
	if source.Endpoints != nil {
		var endpoint EndpointsSpec_STATUS
		err := endpoint.AssignProperties_From_EndpointsSpec_STATUS(source.Endpoints)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_EndpointsSpec_STATUS() to populate field Endpoints")
		}
		resource.Endpoints = &endpoint
	} else {
		resource.Endpoints = nil
	}

	// Etag
	resource.Etag = genruntime.ClonePointerToString(source.Etag)

	// Id
	resource.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var managedServiceIdentitySTATUSStash v20230601s.ManagedServiceIdentity_STATUS
		err := managedServiceIdentitySTATUSStash.AssignProperties_From_ManagedServiceIdentity_STATUS(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedServiceIdentity_STATUS() to populate field ManagedServiceIdentity_STATUSStash from Identity")
		}
		var identity ManagedServiceIdentity_STATUS
		err = identity.AssignProperties_From_ManagedServiceIdentity_STATUS(&managedServiceIdentitySTATUSStash)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedServiceIdentity_STATUS() to populate field Identity from ManagedServiceIdentity_STATUSStash")
		}
		resource.Identity = &identity
	} else {
		resource.Identity = nil
	}

	// ImmutableId
	resource.ImmutableId = genruntime.ClonePointerToString(source.ImmutableId)

	// IngestionQuotas
	if source.IngestionQuotas != nil {
		propertyBag.Add("IngestionQuotas", *source.IngestionQuotas)
	} else {
		propertyBag.Remove("IngestionQuotas")
	}

	// Kind
	resource.Kind = genruntime.ClonePointerToString(source.Kind)

	// Location
	resource.Location = genruntime.ClonePointerToString(source.Location)

	// Metadata
	if source.Metadata != nil {
		var metadatum Metadata_STATUS
		err := metadatum.AssignProperties_From_Metadata_STATUS(source.Metadata)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Metadata_STATUS() to populate field Metadata")
		}
		resource.Metadata = &metadatum
	} else {
		resource.Metadata = nil
	}

	// Name
	resource.Name = genruntime.ClonePointerToString(source.Name)

	// ProvisioningState
	resource.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// References
	if source.References != nil {
		var reference ReferencesSpec_STATUS
		err := reference.AssignProperties_From_ReferencesSpec_STATUS(source.References)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ReferencesSpec_STATUS() to populate field References")
		}
		resource.References = &reference
	} else {
		resource.References = nil
	}

	// Sku
	if source.Sku != nil {
		propertyBag.Add("Sku", *source.Sku)
	} else {
		propertyBag.Remove("Sku")
	}

	// StreamDeclarations
	if source.StreamDeclarations != nil {
		streamDeclarationMap := make(map[string]StreamDeclaration_STATUS, len(source.StreamDeclarations))
		for streamDeclarationKey, streamDeclarationValue := range source.StreamDeclarations {
			var streamDeclaration StreamDeclaration_STATUS
			err := streamDeclaration.AssignProperties_From_StreamDeclaration_STATUS(&streamDeclarationValue)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_StreamDeclaration_STATUS() to populate field StreamDeclarations")
			}
			streamDeclarationMap[streamDeclarationKey] = streamDeclaration
		}
		resource.StreamDeclarations = streamDeclarationMap
	} else {
		resource.StreamDeclarations = nil
	}

	// SystemData
	if source.SystemData != nil {
		var systemDataSTATUSStash v20230601s.SystemData_STATUS
		err := systemDataSTATUSStash.AssignProperties_From_SystemData_STATUS(source.SystemData)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SystemData_STATUS() to populate field SystemData_STATUSStash from SystemData")
		}
		var systemDatum SystemData_STATUS
		err = systemDatum.AssignProperties_From_SystemData_STATUS(&systemDataSTATUSStash)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SystemData_STATUS() to populate field SystemData from SystemData_STATUSStash")
		}
		resource.SystemData = &systemDatum
	} else {
		resource.SystemData = nil
	}

	// Tags
	resource.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	resource.Type = genruntime.ClonePointerToString(source.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		resource.PropertyBag = propertyBag
	} else {
		resource.PropertyBag = nil
	}

	// Invoke the augmentConversionForDataCollectionRuleResource_STATUS interface (if implemented) to customize the conversion
	var resourceAsAny any = resource
	if augmentedResource, ok := resourceAsAny.(augmentConversionForDataCollectionRuleResource_STATUS); ok {
		err := augmentedResource.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DataCollectionRuleResource_STATUS populates the provided destination DataCollectionRuleResource_STATUS from our DataCollectionRuleResource_STATUS
func (resource *DataCollectionRuleResource_STATUS) AssignProperties_To_DataCollectionRuleResource_STATUS(destination *v20240311s.DataCollectionRuleResource_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(resource.PropertyBag)

	// AgentSettings
	if resource.AgentSettings != nil {
		var agentSetting v20240311s.AgentSettingsSpec_STATUS
		err := resource.AgentSettings.AssignProperties_To_AgentSettingsSpec_STATUS(&agentSetting)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AgentSettingsSpec_STATUS() to populate field AgentSettings")
		}
		destination.AgentSettings = &agentSetting
	} else {
		destination.AgentSettings = nil
	}

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(resource.Conditions)

	// DataCollectionEndpointId
	destination.DataCollectionEndpointId = genruntime.ClonePointerToString(resource.DataCollectionEndpointId)

	// DataFlows
	if resource.DataFlows != nil {
		dataFlowList := make([]v20240311s.DataFlow_STATUS, len(resource.DataFlows))
		for dataFlowIndex, dataFlowItem := range resource.DataFlows {
			var dataFlow v20240311s.DataFlow_STATUS
			err := dataFlowItem.AssignProperties_To_DataFlow_STATUS(&dataFlow)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_DataFlow_STATUS() to populate field DataFlows")
			}
			dataFlowList[dataFlowIndex] = dataFlow
		}
		destination.DataFlows = dataFlowList
	} else {
		destination.DataFlows = nil
	}

	// DataSources
	if resource.DataSources != nil {
		var dataSource v20240311s.DataSourcesSpec_STATUS
		err := resource.DataSources.AssignProperties_To_DataSourcesSpec_STATUS(&dataSource)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DataSourcesSpec_STATUS() to populate field DataSources")
		}
		destination.DataSources = &dataSource
	} else {
		destination.DataSources = nil
	}

	// Description
	destination.Description = genruntime.ClonePointerToString(resource.Description)

	// Destinations
	if resource.Destinations != nil {
		var destinationLocal v20240311s.DestinationsSpec_STATUS
		err := resource.Destinations.AssignProperties_To_DestinationsSpec_STATUS(&destinationLocal)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DestinationsSpec_STATUS() to populate field Destinations")
		}
		destination.Destinations = &destinationLocal
	} else {
		destination.Destinations = nil
	}

	// DirectDataSources
	if propertyBag.Contains("DirectDataSources") {
		var directDataSource v20240311s.DirectDataSourcesSpec_STATUS
		err := propertyBag.Pull("DirectDataSources", &directDataSource)
		if err != nil {
			return eris.Wrap(err, "pulling 'DirectDataSources' from propertyBag")
		}

		destination.DirectDataSources = &directDataSource
	} else {
		destination.DirectDataSources = nil
	}

	// Endpoints
	if resource.Endpoints != nil {
		var endpoint v20240311s.EndpointsSpec_STATUS
		err := resource.Endpoints.AssignProperties_To_EndpointsSpec_STATUS(&endpoint)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_EndpointsSpec_STATUS() to populate field Endpoints")
		}
		destination.Endpoints = &endpoint
	} else {
		destination.Endpoints = nil
	}

	// Etag
	destination.Etag = genruntime.ClonePointerToString(resource.Etag)

	// Id
	destination.Id = genruntime.ClonePointerToString(resource.Id)

	// Identity
	if resource.Identity != nil {
		var managedServiceIdentitySTATUSStash v20230601s.ManagedServiceIdentity_STATUS
		err := resource.Identity.AssignProperties_To_ManagedServiceIdentity_STATUS(&managedServiceIdentitySTATUSStash)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedServiceIdentity_STATUS() to populate field ManagedServiceIdentity_STATUSStash from Identity")
		}
		var identity v20240311s.ManagedServiceIdentity_STATUS
		err = managedServiceIdentitySTATUSStash.AssignProperties_To_ManagedServiceIdentity_STATUS(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedServiceIdentity_STATUS() to populate field Identity from ManagedServiceIdentity_STATUSStash")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// ImmutableId
	destination.ImmutableId = genruntime.ClonePointerToString(resource.ImmutableId)

	// IngestionQuotas
	if propertyBag.Contains("IngestionQuotas") {
		var ingestionQuota v20240311s.IngestionQuotas_STATUS
		err := propertyBag.Pull("IngestionQuotas", &ingestionQuota)
		if err != nil {
			return eris.Wrap(err, "pulling 'IngestionQuotas' from propertyBag")
		}

		destination.IngestionQuotas = &ingestionQuota
	} else {
		destination.IngestionQuotas = nil
	}

	// Kind
	destination.Kind = genruntime.ClonePointerToString(resource.Kind)

	// Location
	destination.Location = genruntime.ClonePointerToString(resource.Location)

	// Metadata
	if resource.Metadata != nil {
		var metadatum v20240311s.Metadata_STATUS
		err := resource.Metadata.AssignProperties_To_Metadata_STATUS(&metadatum)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Metadata_STATUS() to populate field Metadata")
		}
		destination.Metadata = &metadatum
	} else {
		destination.Metadata = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(resource.Name)

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(resource.ProvisioningState)

	// References
	if resource.References != nil {
		var reference v20240311s.ReferencesSpec_STATUS
		err := resource.References.AssignProperties_To_ReferencesSpec_STATUS(&reference)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ReferencesSpec_STATUS() to populate field References")
		}
		destination.References = &reference
	} else {
		destination.References = nil
	}

	// Sku
	if propertyBag.Contains("Sku") {
		var sku v20240311s.Sku_STATUS
		err := propertyBag.Pull("Sku", &sku)
		if err != nil {
			return eris.Wrap(err, "pulling 'Sku' from propertyBag")
		}

		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// StreamDeclarations
	if resource.StreamDeclarations != nil {
		streamDeclarationMap := make(map[string]v20240311s.StreamDeclaration_STATUS, len(resource.StreamDeclarations))
		for streamDeclarationKey, streamDeclarationValue := range resource.StreamDeclarations {
			var streamDeclaration v20240311s.StreamDeclaration_STATUS
			err := streamDeclarationValue.AssignProperties_To_StreamDeclaration_STATUS(&streamDeclaration)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_StreamDeclaration_STATUS() to populate field StreamDeclarations")
			}
			streamDeclarationMap[streamDeclarationKey] = streamDeclaration
		}
		destination.StreamDeclarations = streamDeclarationMap
	} else {
		destination.StreamDeclarations = nil
	}

	// SystemData
	if resource.SystemData != nil {
		var systemDataSTATUSStash v20230601s.SystemData_STATUS
		err := resource.SystemData.AssignProperties_To_SystemData_STATUS(&systemDataSTATUSStash)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SystemData_STATUS() to populate field SystemData_STATUSStash from SystemData")
		}
		var systemDatum v20240311s.SystemData_STATUS
		err = systemDataSTATUSStash.AssignProperties_To_SystemData_STATUS(&systemDatum)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SystemData_STATUS() to populate field SystemData from SystemData_STATUSStash")
		}
		destination.SystemData = &systemDatum
	} else {
		destination.SystemData = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(resource.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(resource.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDataCollectionRuleResource_STATUS interface (if implemented) to customize the conversion
	var resourceAsAny any = resource
	if augmentedResource, ok := resourceAsAny.(augmentConversionForDataCollectionRuleResource_STATUS); ok {
		err := augmentedResource.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.AgentSettingsSpec
// An agent setting
type AgentSettingsSpec struct {
	Logs        []AgentSetting         `json:"logs,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_AgentSettingsSpec populates our AgentSettingsSpec from the provided source AgentSettingsSpec
func (settings *AgentSettingsSpec) AssignProperties_From_AgentSettingsSpec(source *v20240311s.AgentSettingsSpec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Logs
	if source.Logs != nil {
		logList := make([]AgentSetting, len(source.Logs))
		for logIndex, logItem := range source.Logs {
			var log AgentSetting
			err := log.AssignProperties_From_AgentSetting(&logItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_AgentSetting() to populate field Logs")
			}
			logList[logIndex] = log
		}
		settings.Logs = logList
	} else {
		settings.Logs = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// Invoke the augmentConversionForAgentSettingsSpec interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForAgentSettingsSpec); ok {
		err := augmentedSettings.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AgentSettingsSpec populates the provided destination AgentSettingsSpec from our AgentSettingsSpec
func (settings *AgentSettingsSpec) AssignProperties_To_AgentSettingsSpec(destination *v20240311s.AgentSettingsSpec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// Logs
	if settings.Logs != nil {
		logList := make([]v20240311s.AgentSetting, len(settings.Logs))
		for logIndex, logItem := range settings.Logs {
			var log v20240311s.AgentSetting
			err := logItem.AssignProperties_To_AgentSetting(&log)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_AgentSetting() to populate field Logs")
			}
			logList[logIndex] = log
		}
		destination.Logs = logList
	} else {
		destination.Logs = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAgentSettingsSpec interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForAgentSettingsSpec); ok {
		err := augmentedSettings.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.AgentSettingsSpec_STATUS
// An agent setting
type AgentSettingsSpec_STATUS struct {
	Logs        []AgentSetting_STATUS  `json:"logs,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_AgentSettingsSpec_STATUS populates our AgentSettingsSpec_STATUS from the provided source AgentSettingsSpec_STATUS
func (settings *AgentSettingsSpec_STATUS) AssignProperties_From_AgentSettingsSpec_STATUS(source *v20240311s.AgentSettingsSpec_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Logs
	if source.Logs != nil {
		logList := make([]AgentSetting_STATUS, len(source.Logs))
		for logIndex, logItem := range source.Logs {
			var log AgentSetting_STATUS
			err := log.AssignProperties_From_AgentSetting_STATUS(&logItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_AgentSetting_STATUS() to populate field Logs")
			}
			logList[logIndex] = log
		}
		settings.Logs = logList
	} else {
		settings.Logs = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// Invoke the augmentConversionForAgentSettingsSpec_STATUS interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForAgentSettingsSpec_STATUS); ok {
		err := augmentedSettings.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AgentSettingsSpec_STATUS populates the provided destination AgentSettingsSpec_STATUS from our AgentSettingsSpec_STATUS
func (settings *AgentSettingsSpec_STATUS) AssignProperties_To_AgentSettingsSpec_STATUS(destination *v20240311s.AgentSettingsSpec_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// Logs
	if settings.Logs != nil {
		logList := make([]v20240311s.AgentSetting_STATUS, len(settings.Logs))
		for logIndex, logItem := range settings.Logs {
			var log v20240311s.AgentSetting_STATUS
			err := logItem.AssignProperties_To_AgentSetting_STATUS(&log)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_AgentSetting_STATUS() to populate field Logs")
			}
			logList[logIndex] = log
		}
		destination.Logs = logList
	} else {
		destination.Logs = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAgentSettingsSpec_STATUS interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForAgentSettingsSpec_STATUS); ok {
		err := augmentedSettings.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForDataCollectionRule_Spec interface {
	AssignPropertiesFrom(src *v20240311s.DataCollectionRule_Spec) error
	AssignPropertiesTo(dst *v20240311s.DataCollectionRule_Spec) error
}

type augmentConversionForDataCollectionRuleResource_STATUS interface {
	AssignPropertiesFrom(src *v20240311s.DataCollectionRuleResource_STATUS) error
	AssignPropertiesTo(dst *v20240311s.DataCollectionRuleResource_STATUS) error
}

// Storage version of v1api20230311.DataCollectionRuleOperatorSpec
// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type DataCollectionRuleOperatorSpec struct {
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`
	PropertyBag          genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
	SecretExpressions    []*core.DestinationExpression `json:"secretExpressions,omitempty"`
}

// AssignProperties_From_DataCollectionRuleOperatorSpec populates our DataCollectionRuleOperatorSpec from the provided source DataCollectionRuleOperatorSpec
func (operator *DataCollectionRuleOperatorSpec) AssignProperties_From_DataCollectionRuleOperatorSpec(source *v20240311s.DataCollectionRuleOperatorSpec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		operator.PropertyBag = propertyBag
	} else {
		operator.PropertyBag = nil
	}

	// Invoke the augmentConversionForDataCollectionRuleOperatorSpec interface (if implemented) to customize the conversion
	var operatorAsAny any = operator
	if augmentedOperator, ok := operatorAsAny.(augmentConversionForDataCollectionRuleOperatorSpec); ok {
		err := augmentedOperator.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DataCollectionRuleOperatorSpec populates the provided destination DataCollectionRuleOperatorSpec from our DataCollectionRuleOperatorSpec
func (operator *DataCollectionRuleOperatorSpec) AssignProperties_To_DataCollectionRuleOperatorSpec(destination *v20240311s.DataCollectionRuleOperatorSpec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(operator.PropertyBag)

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDataCollectionRuleOperatorSpec interface (if implemented) to customize the conversion
	var operatorAsAny any = operator
	if augmentedOperator, ok := operatorAsAny.(augmentConversionForDataCollectionRuleOperatorSpec); ok {
		err := augmentedOperator.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.DataFlow
// Definition of which streams are sent to which destinations.
type DataFlow struct {
	BuiltInTransform *string                `json:"builtInTransform,omitempty"`
	CaptureOverflow  *bool                  `json:"captureOverflow,omitempty"`
	Destinations     []string               `json:"destinations,omitempty"`
	OutputStream     *string                `json:"outputStream,omitempty"`
	PropertyBag      genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Streams          []string               `json:"streams,omitempty"`
	TransformKql     *string                `json:"transformKql,omitempty"`
}

// AssignProperties_From_DataFlow populates our DataFlow from the provided source DataFlow
func (flow *DataFlow) AssignProperties_From_DataFlow(source *v20240311s.DataFlow) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// BuiltInTransform
	flow.BuiltInTransform = genruntime.ClonePointerToString(source.BuiltInTransform)

	// CaptureOverflow
	if source.CaptureOverflow != nil {
		captureOverflow := *source.CaptureOverflow
		flow.CaptureOverflow = &captureOverflow
	} else {
		flow.CaptureOverflow = nil
	}

	// Destinations
	flow.Destinations = genruntime.CloneSliceOfString(source.Destinations)

	// OutputStream
	flow.OutputStream = genruntime.ClonePointerToString(source.OutputStream)

	// Streams
	flow.Streams = genruntime.CloneSliceOfString(source.Streams)

	// TransformKql
	flow.TransformKql = genruntime.ClonePointerToString(source.TransformKql)

	// Update the property bag
	if len(propertyBag) > 0 {
		flow.PropertyBag = propertyBag
	} else {
		flow.PropertyBag = nil
	}

	// Invoke the augmentConversionForDataFlow interface (if implemented) to customize the conversion
	var flowAsAny any = flow
	if augmentedFlow, ok := flowAsAny.(augmentConversionForDataFlow); ok {
		err := augmentedFlow.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DataFlow populates the provided destination DataFlow from our DataFlow
func (flow *DataFlow) AssignProperties_To_DataFlow(destination *v20240311s.DataFlow) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(flow.PropertyBag)

	// BuiltInTransform
	destination.BuiltInTransform = genruntime.ClonePointerToString(flow.BuiltInTransform)

	// CaptureOverflow
	if flow.CaptureOverflow != nil {
		captureOverflow := *flow.CaptureOverflow
		destination.CaptureOverflow = &captureOverflow
	} else {
		destination.CaptureOverflow = nil
	}

	// Destinations
	destination.Destinations = genruntime.CloneSliceOfString(flow.Destinations)

	// OutputStream
	destination.OutputStream = genruntime.ClonePointerToString(flow.OutputStream)

	// Streams
	destination.Streams = genruntime.CloneSliceOfString(flow.Streams)

	// TransformKql
	destination.TransformKql = genruntime.ClonePointerToString(flow.TransformKql)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDataFlow interface (if implemented) to customize the conversion
	var flowAsAny any = flow
	if augmentedFlow, ok := flowAsAny.(augmentConversionForDataFlow); ok {
		err := augmentedFlow.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.DataFlow_STATUS
// Definition of which streams are sent to which destinations.
type DataFlow_STATUS struct {
	BuiltInTransform *string                `json:"builtInTransform,omitempty"`
	CaptureOverflow  *bool                  `json:"captureOverflow,omitempty"`
	Destinations     []string               `json:"destinations,omitempty"`
	OutputStream     *string                `json:"outputStream,omitempty"`
	PropertyBag      genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Streams          []string               `json:"streams,omitempty"`
	TransformKql     *string                `json:"transformKql,omitempty"`
}

// AssignProperties_From_DataFlow_STATUS populates our DataFlow_STATUS from the provided source DataFlow_STATUS
func (flow *DataFlow_STATUS) AssignProperties_From_DataFlow_STATUS(source *v20240311s.DataFlow_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// BuiltInTransform
	flow.BuiltInTransform = genruntime.ClonePointerToString(source.BuiltInTransform)

	// CaptureOverflow
	if source.CaptureOverflow != nil {
		captureOverflow := *source.CaptureOverflow
		flow.CaptureOverflow = &captureOverflow
	} else {
		flow.CaptureOverflow = nil
	}

	// Destinations
	flow.Destinations = genruntime.CloneSliceOfString(source.Destinations)

	// OutputStream
	flow.OutputStream = genruntime.ClonePointerToString(source.OutputStream)

	// Streams
	flow.Streams = genruntime.CloneSliceOfString(source.Streams)

	// TransformKql
	flow.TransformKql = genruntime.ClonePointerToString(source.TransformKql)

	// Update the property bag
	if len(propertyBag) > 0 {
		flow.PropertyBag = propertyBag
	} else {
		flow.PropertyBag = nil
	}

	// Invoke the augmentConversionForDataFlow_STATUS interface (if implemented) to customize the conversion
	var flowAsAny any = flow
	if augmentedFlow, ok := flowAsAny.(augmentConversionForDataFlow_STATUS); ok {
		err := augmentedFlow.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DataFlow_STATUS populates the provided destination DataFlow_STATUS from our DataFlow_STATUS
func (flow *DataFlow_STATUS) AssignProperties_To_DataFlow_STATUS(destination *v20240311s.DataFlow_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(flow.PropertyBag)

	// BuiltInTransform
	destination.BuiltInTransform = genruntime.ClonePointerToString(flow.BuiltInTransform)

	// CaptureOverflow
	if flow.CaptureOverflow != nil {
		captureOverflow := *flow.CaptureOverflow
		destination.CaptureOverflow = &captureOverflow
	} else {
		destination.CaptureOverflow = nil
	}

	// Destinations
	destination.Destinations = genruntime.CloneSliceOfString(flow.Destinations)

	// OutputStream
	destination.OutputStream = genruntime.ClonePointerToString(flow.OutputStream)

	// Streams
	destination.Streams = genruntime.CloneSliceOfString(flow.Streams)

	// TransformKql
	destination.TransformKql = genruntime.ClonePointerToString(flow.TransformKql)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDataFlow_STATUS interface (if implemented) to customize the conversion
	var flowAsAny any = flow
	if augmentedFlow, ok := flowAsAny.(augmentConversionForDataFlow_STATUS); ok {
		err := augmentedFlow.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.DataSourcesSpec
// Specification of data sources that will be collected.
type DataSourcesSpec struct {
	DataImports         *DataImportSources              `json:"dataImports,omitempty"`
	Extensions          []ExtensionDataSource           `json:"extensions,omitempty"`
	IisLogs             []IisLogsDataSource             `json:"iisLogs,omitempty"`
	LogFiles            []LogFilesDataSource            `json:"logFiles,omitempty"`
	PerformanceCounters []PerfCounterDataSource         `json:"performanceCounters,omitempty"`
	PlatformTelemetry   []PlatformTelemetryDataSource   `json:"platformTelemetry,omitempty"`
	PrometheusForwarder []PrometheusForwarderDataSource `json:"prometheusForwarder,omitempty"`
	PropertyBag         genruntime.PropertyBag          `json:"$propertyBag,omitempty"`
	Syslog              []SyslogDataSource              `json:"syslog,omitempty"`
	WindowsEventLogs    []WindowsEventLogDataSource     `json:"windowsEventLogs,omitempty"`
	WindowsFirewallLogs []WindowsFirewallLogsDataSource `json:"windowsFirewallLogs,omitempty"`
}

// AssignProperties_From_DataSourcesSpec populates our DataSourcesSpec from the provided source DataSourcesSpec
func (sources *DataSourcesSpec) AssignProperties_From_DataSourcesSpec(source *v20240311s.DataSourcesSpec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DataImports
	if source.DataImports != nil {
		var dataImport DataImportSources
		err := dataImport.AssignProperties_From_DataImportSources(source.DataImports)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DataImportSources() to populate field DataImports")
		}
		sources.DataImports = &dataImport
	} else {
		sources.DataImports = nil
	}

	// EtwProviders
	if len(source.EtwProviders) > 0 {
		propertyBag.Add("EtwProviders", source.EtwProviders)
	} else {
		propertyBag.Remove("EtwProviders")
	}

	// Extensions
	if source.Extensions != nil {
		extensionList := make([]ExtensionDataSource, len(source.Extensions))
		for extensionIndex, extensionItem := range source.Extensions {
			var extension ExtensionDataSource
			err := extension.AssignProperties_From_ExtensionDataSource(&extensionItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ExtensionDataSource() to populate field Extensions")
			}
			extensionList[extensionIndex] = extension
		}
		sources.Extensions = extensionList
	} else {
		sources.Extensions = nil
	}

	// IisLogs
	if source.IisLogs != nil {
		iisLogList := make([]IisLogsDataSource, len(source.IisLogs))
		for iisLogIndex, iisLogItem := range source.IisLogs {
			var iisLog IisLogsDataSource
			err := iisLog.AssignProperties_From_IisLogsDataSource(&iisLogItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_IisLogsDataSource() to populate field IisLogs")
			}
			iisLogList[iisLogIndex] = iisLog
		}
		sources.IisLogs = iisLogList
	} else {
		sources.IisLogs = nil
	}

	// LogFiles
	if source.LogFiles != nil {
		logFileList := make([]LogFilesDataSource, len(source.LogFiles))
		for logFileIndex, logFileItem := range source.LogFiles {
			var logFile LogFilesDataSource
			err := logFile.AssignProperties_From_LogFilesDataSource(&logFileItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_LogFilesDataSource() to populate field LogFiles")
			}
			logFileList[logFileIndex] = logFile
		}
		sources.LogFiles = logFileList
	} else {
		sources.LogFiles = nil
	}

	// OtelLogs
	if len(source.OtelLogs) > 0 {
		propertyBag.Add("OtelLogs", source.OtelLogs)
	} else {
		propertyBag.Remove("OtelLogs")
	}

	// OtelMetrics
	if len(source.OtelMetrics) > 0 {
		propertyBag.Add("OtelMetrics", source.OtelMetrics)
	} else {
		propertyBag.Remove("OtelMetrics")
	}

	// OtelTraces
	if len(source.OtelTraces) > 0 {
		propertyBag.Add("OtelTraces", source.OtelTraces)
	} else {
		propertyBag.Remove("OtelTraces")
	}

	// PerformanceCounters
	if source.PerformanceCounters != nil {
		performanceCounterList := make([]PerfCounterDataSource, len(source.PerformanceCounters))
		for performanceCounterIndex, performanceCounterItem := range source.PerformanceCounters {
			var performanceCounter PerfCounterDataSource
			err := performanceCounter.AssignProperties_From_PerfCounterDataSource(&performanceCounterItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_PerfCounterDataSource() to populate field PerformanceCounters")
			}
			performanceCounterList[performanceCounterIndex] = performanceCounter
		}
		sources.PerformanceCounters = performanceCounterList
	} else {
		sources.PerformanceCounters = nil
	}

	// PerformanceCountersOTel
	if len(source.PerformanceCountersOTel) > 0 {
		propertyBag.Add("PerformanceCountersOTel", source.PerformanceCountersOTel)
	} else {
		propertyBag.Remove("PerformanceCountersOTel")
	}

	// PlatformTelemetry
	if source.PlatformTelemetry != nil {
		platformTelemetryList := make([]PlatformTelemetryDataSource, len(source.PlatformTelemetry))
		for platformTelemetryIndex, platformTelemetryItem := range source.PlatformTelemetry {
			var platformTelemetry PlatformTelemetryDataSource
			err := platformTelemetry.AssignProperties_From_PlatformTelemetryDataSource(&platformTelemetryItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_PlatformTelemetryDataSource() to populate field PlatformTelemetry")
			}
			platformTelemetryList[platformTelemetryIndex] = platformTelemetry
		}
		sources.PlatformTelemetry = platformTelemetryList
	} else {
		sources.PlatformTelemetry = nil
	}

	// PrometheusForwarder
	if source.PrometheusForwarder != nil {
		prometheusForwarderList := make([]PrometheusForwarderDataSource, len(source.PrometheusForwarder))
		for prometheusForwarderIndex, prometheusForwarderItem := range source.PrometheusForwarder {
			var prometheusForwarder PrometheusForwarderDataSource
			err := prometheusForwarder.AssignProperties_From_PrometheusForwarderDataSource(&prometheusForwarderItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_PrometheusForwarderDataSource() to populate field PrometheusForwarder")
			}
			prometheusForwarderList[prometheusForwarderIndex] = prometheusForwarder
		}
		sources.PrometheusForwarder = prometheusForwarderList
	} else {
		sources.PrometheusForwarder = nil
	}

	// Syslog
	if source.Syslog != nil {
		syslogList := make([]SyslogDataSource, len(source.Syslog))
		for syslogIndex, syslogItem := range source.Syslog {
			var syslog SyslogDataSource
			err := syslog.AssignProperties_From_SyslogDataSource(&syslogItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_SyslogDataSource() to populate field Syslog")
			}
			syslogList[syslogIndex] = syslog
		}
		sources.Syslog = syslogList
	} else {
		sources.Syslog = nil
	}

	// WindowsEventLogs
	if source.WindowsEventLogs != nil {
		windowsEventLogList := make([]WindowsEventLogDataSource, len(source.WindowsEventLogs))
		for windowsEventLogIndex, windowsEventLogItem := range source.WindowsEventLogs {
			var windowsEventLog WindowsEventLogDataSource
			err := windowsEventLog.AssignProperties_From_WindowsEventLogDataSource(&windowsEventLogItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_WindowsEventLogDataSource() to populate field WindowsEventLogs")
			}
			windowsEventLogList[windowsEventLogIndex] = windowsEventLog
		}
		sources.WindowsEventLogs = windowsEventLogList
	} else {
		sources.WindowsEventLogs = nil
	}

	// WindowsFirewallLogs
	if source.WindowsFirewallLogs != nil {
		windowsFirewallLogList := make([]WindowsFirewallLogsDataSource, len(source.WindowsFirewallLogs))
		for windowsFirewallLogIndex, windowsFirewallLogItem := range source.WindowsFirewallLogs {
			var windowsFirewallLog WindowsFirewallLogsDataSource
			err := windowsFirewallLog.AssignProperties_From_WindowsFirewallLogsDataSource(&windowsFirewallLogItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_WindowsFirewallLogsDataSource() to populate field WindowsFirewallLogs")
			}
			windowsFirewallLogList[windowsFirewallLogIndex] = windowsFirewallLog
		}
		sources.WindowsFirewallLogs = windowsFirewallLogList
	} else {
		sources.WindowsFirewallLogs = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		sources.PropertyBag = propertyBag
	} else {
		sources.PropertyBag = nil
	}

	// Invoke the augmentConversionForDataSourcesSpec interface (if implemented) to customize the conversion
	var sourcesAsAny any = sources
	if augmentedSources, ok := sourcesAsAny.(augmentConversionForDataSourcesSpec); ok {
		err := augmentedSources.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DataSourcesSpec populates the provided destination DataSourcesSpec from our DataSourcesSpec
func (sources *DataSourcesSpec) AssignProperties_To_DataSourcesSpec(destination *v20240311s.DataSourcesSpec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(sources.PropertyBag)

	// DataImports
	if sources.DataImports != nil {
		var dataImport v20240311s.DataImportSources
		err := sources.DataImports.AssignProperties_To_DataImportSources(&dataImport)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DataImportSources() to populate field DataImports")
		}
		destination.DataImports = &dataImport
	} else {
		destination.DataImports = nil
	}

	// EtwProviders
	if propertyBag.Contains("EtwProviders") {
		var etwProvider []v20240311s.EtwProviderDataSource
		err := propertyBag.Pull("EtwProviders", &etwProvider)
		if err != nil {
			return eris.Wrap(err, "pulling 'EtwProviders' from propertyBag")
		}

		destination.EtwProviders = etwProvider
	} else {
		destination.EtwProviders = nil
	}

	// Extensions
	if sources.Extensions != nil {
		extensionList := make([]v20240311s.ExtensionDataSource, len(sources.Extensions))
		for extensionIndex, extensionItem := range sources.Extensions {
			var extension v20240311s.ExtensionDataSource
			err := extensionItem.AssignProperties_To_ExtensionDataSource(&extension)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ExtensionDataSource() to populate field Extensions")
			}
			extensionList[extensionIndex] = extension
		}
		destination.Extensions = extensionList
	} else {
		destination.Extensions = nil
	}

	// IisLogs
	if sources.IisLogs != nil {
		iisLogList := make([]v20240311s.IisLogsDataSource, len(sources.IisLogs))
		for iisLogIndex, iisLogItem := range sources.IisLogs {
			var iisLog v20240311s.IisLogsDataSource
			err := iisLogItem.AssignProperties_To_IisLogsDataSource(&iisLog)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_IisLogsDataSource() to populate field IisLogs")
			}
			iisLogList[iisLogIndex] = iisLog
		}
		destination.IisLogs = iisLogList
	} else {
		destination.IisLogs = nil
	}

	// LogFiles
	if sources.LogFiles != nil {
		logFileList := make([]v20240311s.LogFilesDataSource, len(sources.LogFiles))
		for logFileIndex, logFileItem := range sources.LogFiles {
			var logFile v20240311s.LogFilesDataSource
			err := logFileItem.AssignProperties_To_LogFilesDataSource(&logFile)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_LogFilesDataSource() to populate field LogFiles")
			}
			logFileList[logFileIndex] = logFile
		}
		destination.LogFiles = logFileList
	} else {
		destination.LogFiles = nil
	}

	// OtelLogs
	if propertyBag.Contains("OtelLogs") {
		var otelLog []v20240311s.OtelLogsDataSource
		err := propertyBag.Pull("OtelLogs", &otelLog)
		if err != nil {
			return eris.Wrap(err, "pulling 'OtelLogs' from propertyBag")
		}

		destination.OtelLogs = otelLog
	} else {
		destination.OtelLogs = nil
	}

	// OtelMetrics
	if propertyBag.Contains("OtelMetrics") {
		var otelMetric []v20240311s.OtelMetricsDataSource
		err := propertyBag.Pull("OtelMetrics", &otelMetric)
		if err != nil {
			return eris.Wrap(err, "pulling 'OtelMetrics' from propertyBag")
		}

		destination.OtelMetrics = otelMetric
	} else {
		destination.OtelMetrics = nil
	}

	// OtelTraces
	if propertyBag.Contains("OtelTraces") {
		var otelTrace []v20240311s.OtelTracesDataSource
		err := propertyBag.Pull("OtelTraces", &otelTrace)
		if err != nil {
			return eris.Wrap(err, "pulling 'OtelTraces' from propertyBag")
		}

		destination.OtelTraces = otelTrace
	} else {
		destination.OtelTraces = nil
	}

	// PerformanceCounters
	if sources.PerformanceCounters != nil {
		performanceCounterList := make([]v20240311s.PerfCounterDataSource, len(sources.PerformanceCounters))
		for performanceCounterIndex, performanceCounterItem := range sources.PerformanceCounters {
			var performanceCounter v20240311s.PerfCounterDataSource
			err := performanceCounterItem.AssignProperties_To_PerfCounterDataSource(&performanceCounter)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_PerfCounterDataSource() to populate field PerformanceCounters")
			}
			performanceCounterList[performanceCounterIndex] = performanceCounter
		}
		destination.PerformanceCounters = performanceCounterList
	} else {
		destination.PerformanceCounters = nil
	}

	// PerformanceCountersOTel
	if propertyBag.Contains("PerformanceCountersOTel") {
		var performanceCountersOTel []v20240311s.PerformanceCountersOTelDataSource
		err := propertyBag.Pull("PerformanceCountersOTel", &performanceCountersOTel)
		if err != nil {
			return eris.Wrap(err, "pulling 'PerformanceCountersOTel' from propertyBag")
		}

		destination.PerformanceCountersOTel = performanceCountersOTel
	} else {
		destination.PerformanceCountersOTel = nil
	}

	// PlatformTelemetry
	if sources.PlatformTelemetry != nil {
		platformTelemetryList := make([]v20240311s.PlatformTelemetryDataSource, len(sources.PlatformTelemetry))
		for platformTelemetryIndex, platformTelemetryItem := range sources.PlatformTelemetry {
			var platformTelemetry v20240311s.PlatformTelemetryDataSource
			err := platformTelemetryItem.AssignProperties_To_PlatformTelemetryDataSource(&platformTelemetry)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_PlatformTelemetryDataSource() to populate field PlatformTelemetry")
			}
			platformTelemetryList[platformTelemetryIndex] = platformTelemetry
		}
		destination.PlatformTelemetry = platformTelemetryList
	} else {
		destination.PlatformTelemetry = nil
	}

	// PrometheusForwarder
	if sources.PrometheusForwarder != nil {
		prometheusForwarderList := make([]v20240311s.PrometheusForwarderDataSource, len(sources.PrometheusForwarder))
		for prometheusForwarderIndex, prometheusForwarderItem := range sources.PrometheusForwarder {
			var prometheusForwarder v20240311s.PrometheusForwarderDataSource
			err := prometheusForwarderItem.AssignProperties_To_PrometheusForwarderDataSource(&prometheusForwarder)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_PrometheusForwarderDataSource() to populate field PrometheusForwarder")
			}
			prometheusForwarderList[prometheusForwarderIndex] = prometheusForwarder
		}
		destination.PrometheusForwarder = prometheusForwarderList
	} else {
		destination.PrometheusForwarder = nil
	}

	// Syslog
	if sources.Syslog != nil {
		syslogList := make([]v20240311s.SyslogDataSource, len(sources.Syslog))
		for syslogIndex, syslogItem := range sources.Syslog {
			var syslog v20240311s.SyslogDataSource
			err := syslogItem.AssignProperties_To_SyslogDataSource(&syslog)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_SyslogDataSource() to populate field Syslog")
			}
			syslogList[syslogIndex] = syslog
		}
		destination.Syslog = syslogList
	} else {
		destination.Syslog = nil
	}

	// WindowsEventLogs
	if sources.WindowsEventLogs != nil {
		windowsEventLogList := make([]v20240311s.WindowsEventLogDataSource, len(sources.WindowsEventLogs))
		for windowsEventLogIndex, windowsEventLogItem := range sources.WindowsEventLogs {
			var windowsEventLog v20240311s.WindowsEventLogDataSource
			err := windowsEventLogItem.AssignProperties_To_WindowsEventLogDataSource(&windowsEventLog)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_WindowsEventLogDataSource() to populate field WindowsEventLogs")
			}
			windowsEventLogList[windowsEventLogIndex] = windowsEventLog
		}
		destination.WindowsEventLogs = windowsEventLogList
	} else {
		destination.WindowsEventLogs = nil
	}

	// WindowsFirewallLogs
	if sources.WindowsFirewallLogs != nil {
		windowsFirewallLogList := make([]v20240311s.WindowsFirewallLogsDataSource, len(sources.WindowsFirewallLogs))
		for windowsFirewallLogIndex, windowsFirewallLogItem := range sources.WindowsFirewallLogs {
			var windowsFirewallLog v20240311s.WindowsFirewallLogsDataSource
			err := windowsFirewallLogItem.AssignProperties_To_WindowsFirewallLogsDataSource(&windowsFirewallLog)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_WindowsFirewallLogsDataSource() to populate field WindowsFirewallLogs")
			}
			windowsFirewallLogList[windowsFirewallLogIndex] = windowsFirewallLog
		}
		destination.WindowsFirewallLogs = windowsFirewallLogList
	} else {
		destination.WindowsFirewallLogs = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDataSourcesSpec interface (if implemented) to customize the conversion
	var sourcesAsAny any = sources
	if augmentedSources, ok := sourcesAsAny.(augmentConversionForDataSourcesSpec); ok {
		err := augmentedSources.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.DataSourcesSpec_STATUS
// Specification of data sources that will be collected.
type DataSourcesSpec_STATUS struct {
	DataImports         *DataImportSources_STATUS              `json:"dataImports,omitempty"`
	Extensions          []ExtensionDataSource_STATUS           `json:"extensions,omitempty"`
	IisLogs             []IisLogsDataSource_STATUS             `json:"iisLogs,omitempty"`
	LogFiles            []LogFilesDataSource_STATUS            `json:"logFiles,omitempty"`
	PerformanceCounters []PerfCounterDataSource_STATUS         `json:"performanceCounters,omitempty"`
	PlatformTelemetry   []PlatformTelemetryDataSource_STATUS   `json:"platformTelemetry,omitempty"`
	PrometheusForwarder []PrometheusForwarderDataSource_STATUS `json:"prometheusForwarder,omitempty"`
	PropertyBag         genruntime.PropertyBag                 `json:"$propertyBag,omitempty"`
	Syslog              []SyslogDataSource_STATUS              `json:"syslog,omitempty"`
	WindowsEventLogs    []WindowsEventLogDataSource_STATUS     `json:"windowsEventLogs,omitempty"`
	WindowsFirewallLogs []WindowsFirewallLogsDataSource_STATUS `json:"windowsFirewallLogs,omitempty"`
}

// AssignProperties_From_DataSourcesSpec_STATUS populates our DataSourcesSpec_STATUS from the provided source DataSourcesSpec_STATUS
func (sources *DataSourcesSpec_STATUS) AssignProperties_From_DataSourcesSpec_STATUS(source *v20240311s.DataSourcesSpec_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DataImports
	if source.DataImports != nil {
		var dataImport DataImportSources_STATUS
		err := dataImport.AssignProperties_From_DataImportSources_STATUS(source.DataImports)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DataImportSources_STATUS() to populate field DataImports")
		}
		sources.DataImports = &dataImport
	} else {
		sources.DataImports = nil
	}

	// EtwProviders
	if len(source.EtwProviders) > 0 {
		propertyBag.Add("EtwProviders", source.EtwProviders)
	} else {
		propertyBag.Remove("EtwProviders")
	}

	// Extensions
	if source.Extensions != nil {
		extensionList := make([]ExtensionDataSource_STATUS, len(source.Extensions))
		for extensionIndex, extensionItem := range source.Extensions {
			var extension ExtensionDataSource_STATUS
			err := extension.AssignProperties_From_ExtensionDataSource_STATUS(&extensionItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ExtensionDataSource_STATUS() to populate field Extensions")
			}
			extensionList[extensionIndex] = extension
		}
		sources.Extensions = extensionList
	} else {
		sources.Extensions = nil
	}

	// IisLogs
	if source.IisLogs != nil {
		iisLogList := make([]IisLogsDataSource_STATUS, len(source.IisLogs))
		for iisLogIndex, iisLogItem := range source.IisLogs {
			var iisLog IisLogsDataSource_STATUS
			err := iisLog.AssignProperties_From_IisLogsDataSource_STATUS(&iisLogItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_IisLogsDataSource_STATUS() to populate field IisLogs")
			}
			iisLogList[iisLogIndex] = iisLog
		}
		sources.IisLogs = iisLogList
	} else {
		sources.IisLogs = nil
	}

	// LogFiles
	if source.LogFiles != nil {
		logFileList := make([]LogFilesDataSource_STATUS, len(source.LogFiles))
		for logFileIndex, logFileItem := range source.LogFiles {
			var logFile LogFilesDataSource_STATUS
			err := logFile.AssignProperties_From_LogFilesDataSource_STATUS(&logFileItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_LogFilesDataSource_STATUS() to populate field LogFiles")
			}
			logFileList[logFileIndex] = logFile
		}
		sources.LogFiles = logFileList
	} else {
		sources.LogFiles = nil
	}

	// OtelLogs
	if len(source.OtelLogs) > 0 {
		propertyBag.Add("OtelLogs", source.OtelLogs)
	} else {
		propertyBag.Remove("OtelLogs")
	}

	// OtelMetrics
	if len(source.OtelMetrics) > 0 {
		propertyBag.Add("OtelMetrics", source.OtelMetrics)
	} else {
		propertyBag.Remove("OtelMetrics")
	}

	// OtelTraces
	if len(source.OtelTraces) > 0 {
		propertyBag.Add("OtelTraces", source.OtelTraces)
	} else {
		propertyBag.Remove("OtelTraces")
	}

	// PerformanceCounters
	if source.PerformanceCounters != nil {
		performanceCounterList := make([]PerfCounterDataSource_STATUS, len(source.PerformanceCounters))
		for performanceCounterIndex, performanceCounterItem := range source.PerformanceCounters {
			var performanceCounter PerfCounterDataSource_STATUS
			err := performanceCounter.AssignProperties_From_PerfCounterDataSource_STATUS(&performanceCounterItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_PerfCounterDataSource_STATUS() to populate field PerformanceCounters")
			}
			performanceCounterList[performanceCounterIndex] = performanceCounter
		}
		sources.PerformanceCounters = performanceCounterList
	} else {
		sources.PerformanceCounters = nil
	}

	// PerformanceCountersOTel
	if len(source.PerformanceCountersOTel) > 0 {
		propertyBag.Add("PerformanceCountersOTel", source.PerformanceCountersOTel)
	} else {
		propertyBag.Remove("PerformanceCountersOTel")
	}

	// PlatformTelemetry
	if source.PlatformTelemetry != nil {
		platformTelemetryList := make([]PlatformTelemetryDataSource_STATUS, len(source.PlatformTelemetry))
		for platformTelemetryIndex, platformTelemetryItem := range source.PlatformTelemetry {
			var platformTelemetry PlatformTelemetryDataSource_STATUS
			err := platformTelemetry.AssignProperties_From_PlatformTelemetryDataSource_STATUS(&platformTelemetryItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_PlatformTelemetryDataSource_STATUS() to populate field PlatformTelemetry")
			}
			platformTelemetryList[platformTelemetryIndex] = platformTelemetry
		}
		sources.PlatformTelemetry = platformTelemetryList
	} else {
		sources.PlatformTelemetry = nil
	}

	// PrometheusForwarder
	if source.PrometheusForwarder != nil {
		prometheusForwarderList := make([]PrometheusForwarderDataSource_STATUS, len(source.PrometheusForwarder))
		for prometheusForwarderIndex, prometheusForwarderItem := range source.PrometheusForwarder {
			var prometheusForwarder PrometheusForwarderDataSource_STATUS
			err := prometheusForwarder.AssignProperties_From_PrometheusForwarderDataSource_STATUS(&prometheusForwarderItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_PrometheusForwarderDataSource_STATUS() to populate field PrometheusForwarder")
			}
			prometheusForwarderList[prometheusForwarderIndex] = prometheusForwarder
		}
		sources.PrometheusForwarder = prometheusForwarderList
	} else {
		sources.PrometheusForwarder = nil
	}

	// Syslog
	if source.Syslog != nil {
		syslogList := make([]SyslogDataSource_STATUS, len(source.Syslog))
		for syslogIndex, syslogItem := range source.Syslog {
			var syslog SyslogDataSource_STATUS
			err := syslog.AssignProperties_From_SyslogDataSource_STATUS(&syslogItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_SyslogDataSource_STATUS() to populate field Syslog")
			}
			syslogList[syslogIndex] = syslog
		}
		sources.Syslog = syslogList
	} else {
		sources.Syslog = nil
	}

	// WindowsEventLogs
	if source.WindowsEventLogs != nil {
		windowsEventLogList := make([]WindowsEventLogDataSource_STATUS, len(source.WindowsEventLogs))
		for windowsEventLogIndex, windowsEventLogItem := range source.WindowsEventLogs {
			var windowsEventLog WindowsEventLogDataSource_STATUS
			err := windowsEventLog.AssignProperties_From_WindowsEventLogDataSource_STATUS(&windowsEventLogItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_WindowsEventLogDataSource_STATUS() to populate field WindowsEventLogs")
			}
			windowsEventLogList[windowsEventLogIndex] = windowsEventLog
		}
		sources.WindowsEventLogs = windowsEventLogList
	} else {
		sources.WindowsEventLogs = nil
	}

	// WindowsFirewallLogs
	if source.WindowsFirewallLogs != nil {
		windowsFirewallLogList := make([]WindowsFirewallLogsDataSource_STATUS, len(source.WindowsFirewallLogs))
		for windowsFirewallLogIndex, windowsFirewallLogItem := range source.WindowsFirewallLogs {
			var windowsFirewallLog WindowsFirewallLogsDataSource_STATUS
			err := windowsFirewallLog.AssignProperties_From_WindowsFirewallLogsDataSource_STATUS(&windowsFirewallLogItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_WindowsFirewallLogsDataSource_STATUS() to populate field WindowsFirewallLogs")
			}
			windowsFirewallLogList[windowsFirewallLogIndex] = windowsFirewallLog
		}
		sources.WindowsFirewallLogs = windowsFirewallLogList
	} else {
		sources.WindowsFirewallLogs = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		sources.PropertyBag = propertyBag
	} else {
		sources.PropertyBag = nil
	}

	// Invoke the augmentConversionForDataSourcesSpec_STATUS interface (if implemented) to customize the conversion
	var sourcesAsAny any = sources
	if augmentedSources, ok := sourcesAsAny.(augmentConversionForDataSourcesSpec_STATUS); ok {
		err := augmentedSources.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DataSourcesSpec_STATUS populates the provided destination DataSourcesSpec_STATUS from our DataSourcesSpec_STATUS
func (sources *DataSourcesSpec_STATUS) AssignProperties_To_DataSourcesSpec_STATUS(destination *v20240311s.DataSourcesSpec_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(sources.PropertyBag)

	// DataImports
	if sources.DataImports != nil {
		var dataImport v20240311s.DataImportSources_STATUS
		err := sources.DataImports.AssignProperties_To_DataImportSources_STATUS(&dataImport)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DataImportSources_STATUS() to populate field DataImports")
		}
		destination.DataImports = &dataImport
	} else {
		destination.DataImports = nil
	}

	// EtwProviders
	if propertyBag.Contains("EtwProviders") {
		var etwProvider []v20240311s.EtwProviderDataSource_STATUS
		err := propertyBag.Pull("EtwProviders", &etwProvider)
		if err != nil {
			return eris.Wrap(err, "pulling 'EtwProviders' from propertyBag")
		}

		destination.EtwProviders = etwProvider
	} else {
		destination.EtwProviders = nil
	}

	// Extensions
	if sources.Extensions != nil {
		extensionList := make([]v20240311s.ExtensionDataSource_STATUS, len(sources.Extensions))
		for extensionIndex, extensionItem := range sources.Extensions {
			var extension v20240311s.ExtensionDataSource_STATUS
			err := extensionItem.AssignProperties_To_ExtensionDataSource_STATUS(&extension)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ExtensionDataSource_STATUS() to populate field Extensions")
			}
			extensionList[extensionIndex] = extension
		}
		destination.Extensions = extensionList
	} else {
		destination.Extensions = nil
	}

	// IisLogs
	if sources.IisLogs != nil {
		iisLogList := make([]v20240311s.IisLogsDataSource_STATUS, len(sources.IisLogs))
		for iisLogIndex, iisLogItem := range sources.IisLogs {
			var iisLog v20240311s.IisLogsDataSource_STATUS
			err := iisLogItem.AssignProperties_To_IisLogsDataSource_STATUS(&iisLog)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_IisLogsDataSource_STATUS() to populate field IisLogs")
			}
			iisLogList[iisLogIndex] = iisLog
		}
		destination.IisLogs = iisLogList
	} else {
		destination.IisLogs = nil
	}

	// LogFiles
	if sources.LogFiles != nil {
		logFileList := make([]v20240311s.LogFilesDataSource_STATUS, len(sources.LogFiles))
		for logFileIndex, logFileItem := range sources.LogFiles {
			var logFile v20240311s.LogFilesDataSource_STATUS
			err := logFileItem.AssignProperties_To_LogFilesDataSource_STATUS(&logFile)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_LogFilesDataSource_STATUS() to populate field LogFiles")
			}
			logFileList[logFileIndex] = logFile
		}
		destination.LogFiles = logFileList
	} else {
		destination.LogFiles = nil
	}

	// OtelLogs
	if propertyBag.Contains("OtelLogs") {
		var otelLog []v20240311s.OtelLogsDataSource_STATUS
		err := propertyBag.Pull("OtelLogs", &otelLog)
		if err != nil {
			return eris.Wrap(err, "pulling 'OtelLogs' from propertyBag")
		}

		destination.OtelLogs = otelLog
	} else {
		destination.OtelLogs = nil
	}

	// OtelMetrics
	if propertyBag.Contains("OtelMetrics") {
		var otelMetric []v20240311s.OtelMetricsDataSource_STATUS
		err := propertyBag.Pull("OtelMetrics", &otelMetric)
		if err != nil {
			return eris.Wrap(err, "pulling 'OtelMetrics' from propertyBag")
		}

		destination.OtelMetrics = otelMetric
	} else {
		destination.OtelMetrics = nil
	}

	// OtelTraces
	if propertyBag.Contains("OtelTraces") {
		var otelTrace []v20240311s.OtelTracesDataSource_STATUS
		err := propertyBag.Pull("OtelTraces", &otelTrace)
		if err != nil {
			return eris.Wrap(err, "pulling 'OtelTraces' from propertyBag")
		}

		destination.OtelTraces = otelTrace
	} else {
		destination.OtelTraces = nil
	}

	// PerformanceCounters
	if sources.PerformanceCounters != nil {
		performanceCounterList := make([]v20240311s.PerfCounterDataSource_STATUS, len(sources.PerformanceCounters))
		for performanceCounterIndex, performanceCounterItem := range sources.PerformanceCounters {
			var performanceCounter v20240311s.PerfCounterDataSource_STATUS
			err := performanceCounterItem.AssignProperties_To_PerfCounterDataSource_STATUS(&performanceCounter)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_PerfCounterDataSource_STATUS() to populate field PerformanceCounters")
			}
			performanceCounterList[performanceCounterIndex] = performanceCounter
		}
		destination.PerformanceCounters = performanceCounterList
	} else {
		destination.PerformanceCounters = nil
	}

	// PerformanceCountersOTel
	if propertyBag.Contains("PerformanceCountersOTel") {
		var performanceCountersOTel []v20240311s.PerformanceCountersOTelDataSource_STATUS
		err := propertyBag.Pull("PerformanceCountersOTel", &performanceCountersOTel)
		if err != nil {
			return eris.Wrap(err, "pulling 'PerformanceCountersOTel' from propertyBag")
		}

		destination.PerformanceCountersOTel = performanceCountersOTel
	} else {
		destination.PerformanceCountersOTel = nil
	}

	// PlatformTelemetry
	if sources.PlatformTelemetry != nil {
		platformTelemetryList := make([]v20240311s.PlatformTelemetryDataSource_STATUS, len(sources.PlatformTelemetry))
		for platformTelemetryIndex, platformTelemetryItem := range sources.PlatformTelemetry {
			var platformTelemetry v20240311s.PlatformTelemetryDataSource_STATUS
			err := platformTelemetryItem.AssignProperties_To_PlatformTelemetryDataSource_STATUS(&platformTelemetry)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_PlatformTelemetryDataSource_STATUS() to populate field PlatformTelemetry")
			}
			platformTelemetryList[platformTelemetryIndex] = platformTelemetry
		}
		destination.PlatformTelemetry = platformTelemetryList
	} else {
		destination.PlatformTelemetry = nil
	}

	// PrometheusForwarder
	if sources.PrometheusForwarder != nil {
		prometheusForwarderList := make([]v20240311s.PrometheusForwarderDataSource_STATUS, len(sources.PrometheusForwarder))
		for prometheusForwarderIndex, prometheusForwarderItem := range sources.PrometheusForwarder {
			var prometheusForwarder v20240311s.PrometheusForwarderDataSource_STATUS
			err := prometheusForwarderItem.AssignProperties_To_PrometheusForwarderDataSource_STATUS(&prometheusForwarder)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_PrometheusForwarderDataSource_STATUS() to populate field PrometheusForwarder")
			}
			prometheusForwarderList[prometheusForwarderIndex] = prometheusForwarder
		}
		destination.PrometheusForwarder = prometheusForwarderList
	} else {
		destination.PrometheusForwarder = nil
	}

	// Syslog
	if sources.Syslog != nil {
		syslogList := make([]v20240311s.SyslogDataSource_STATUS, len(sources.Syslog))
		for syslogIndex, syslogItem := range sources.Syslog {
			var syslog v20240311s.SyslogDataSource_STATUS
			err := syslogItem.AssignProperties_To_SyslogDataSource_STATUS(&syslog)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_SyslogDataSource_STATUS() to populate field Syslog")
			}
			syslogList[syslogIndex] = syslog
		}
		destination.Syslog = syslogList
	} else {
		destination.Syslog = nil
	}

	// WindowsEventLogs
	if sources.WindowsEventLogs != nil {
		windowsEventLogList := make([]v20240311s.WindowsEventLogDataSource_STATUS, len(sources.WindowsEventLogs))
		for windowsEventLogIndex, windowsEventLogItem := range sources.WindowsEventLogs {
			var windowsEventLog v20240311s.WindowsEventLogDataSource_STATUS
			err := windowsEventLogItem.AssignProperties_To_WindowsEventLogDataSource_STATUS(&windowsEventLog)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_WindowsEventLogDataSource_STATUS() to populate field WindowsEventLogs")
			}
			windowsEventLogList[windowsEventLogIndex] = windowsEventLog
		}
		destination.WindowsEventLogs = windowsEventLogList
	} else {
		destination.WindowsEventLogs = nil
	}

	// WindowsFirewallLogs
	if sources.WindowsFirewallLogs != nil {
		windowsFirewallLogList := make([]v20240311s.WindowsFirewallLogsDataSource_STATUS, len(sources.WindowsFirewallLogs))
		for windowsFirewallLogIndex, windowsFirewallLogItem := range sources.WindowsFirewallLogs {
			var windowsFirewallLog v20240311s.WindowsFirewallLogsDataSource_STATUS
			err := windowsFirewallLogItem.AssignProperties_To_WindowsFirewallLogsDataSource_STATUS(&windowsFirewallLog)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_WindowsFirewallLogsDataSource_STATUS() to populate field WindowsFirewallLogs")
			}
			windowsFirewallLogList[windowsFirewallLogIndex] = windowsFirewallLog
		}
		destination.WindowsFirewallLogs = windowsFirewallLogList
	} else {
		destination.WindowsFirewallLogs = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDataSourcesSpec_STATUS interface (if implemented) to customize the conversion
	var sourcesAsAny any = sources
	if augmentedSources, ok := sourcesAsAny.(augmentConversionForDataSourcesSpec_STATUS); ok {
		err := augmentedSources.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.DestinationsSpec
// Specification of destinations that can be used in data flows.
type DestinationsSpec struct {
	AzureDataExplorer   []AdxDestination                `json:"azureDataExplorer,omitempty"`
	AzureMonitorMetrics *AzureMonitorMetricsDestination `json:"azureMonitorMetrics,omitempty"`
	EventHubs           []EventHubDestination           `json:"eventHubs,omitempty"`
	EventHubsDirect     []EventHubDirectDestination     `json:"eventHubsDirect,omitempty"`
	LogAnalytics        []LogAnalyticsDestination       `json:"logAnalytics,omitempty"`
	MicrosoftFabric     []MicrosoftFabricDestination    `json:"microsoftFabric,omitempty"`
	MonitoringAccounts  []MonitoringAccountDestination  `json:"monitoringAccounts,omitempty"`
	PropertyBag         genruntime.PropertyBag          `json:"$propertyBag,omitempty"`
	StorageAccounts     []StorageBlobDestination        `json:"storageAccounts,omitempty"`
	StorageBlobsDirect  []StorageBlobDestination        `json:"storageBlobsDirect,omitempty"`
	StorageTablesDirect []StorageTableDestination       `json:"storageTablesDirect,omitempty"`
}

// AssignProperties_From_DestinationsSpec populates our DestinationsSpec from the provided source DestinationsSpec
func (destinations *DestinationsSpec) AssignProperties_From_DestinationsSpec(source *v20240311s.DestinationsSpec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AzureDataExplorer
	if source.AzureDataExplorer != nil {
		azureDataExplorerList := make([]AdxDestination, len(source.AzureDataExplorer))
		for azureDataExplorerIndex, azureDataExplorerItem := range source.AzureDataExplorer {
			var azureDataExplorer AdxDestination
			err := azureDataExplorer.AssignProperties_From_AdxDestination(&azureDataExplorerItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_AdxDestination() to populate field AzureDataExplorer")
			}
			azureDataExplorerList[azureDataExplorerIndex] = azureDataExplorer
		}
		destinations.AzureDataExplorer = azureDataExplorerList
	} else {
		destinations.AzureDataExplorer = nil
	}

	// AzureMonitorMetrics
	if source.AzureMonitorMetrics != nil {
		var azureMonitorMetric AzureMonitorMetricsDestination
		err := azureMonitorMetric.AssignProperties_From_AzureMonitorMetricsDestination(source.AzureMonitorMetrics)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AzureMonitorMetricsDestination() to populate field AzureMonitorMetrics")
		}
		destinations.AzureMonitorMetrics = &azureMonitorMetric
	} else {
		destinations.AzureMonitorMetrics = nil
	}

	// EventHubs
	if source.EventHubs != nil {
		eventHubList := make([]EventHubDestination, len(source.EventHubs))
		for eventHubIndex, eventHubItem := range source.EventHubs {
			var eventHub EventHubDestination
			err := eventHub.AssignProperties_From_EventHubDestination(&eventHubItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_EventHubDestination() to populate field EventHubs")
			}
			eventHubList[eventHubIndex] = eventHub
		}
		destinations.EventHubs = eventHubList
	} else {
		destinations.EventHubs = nil
	}

	// EventHubsDirect
	if source.EventHubsDirect != nil {
		eventHubsDirectList := make([]EventHubDirectDestination, len(source.EventHubsDirect))
		for eventHubsDirectIndex, eventHubsDirectItem := range source.EventHubsDirect {
			var eventHubsDirect EventHubDirectDestination
			err := eventHubsDirect.AssignProperties_From_EventHubDirectDestination(&eventHubsDirectItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_EventHubDirectDestination() to populate field EventHubsDirect")
			}
			eventHubsDirectList[eventHubsDirectIndex] = eventHubsDirect
		}
		destinations.EventHubsDirect = eventHubsDirectList
	} else {
		destinations.EventHubsDirect = nil
	}

	// LogAnalytics
	if source.LogAnalytics != nil {
		logAnalyticList := make([]LogAnalyticsDestination, len(source.LogAnalytics))
		for logAnalyticIndex, logAnalyticItem := range source.LogAnalytics {
			var logAnalytic LogAnalyticsDestination
			err := logAnalytic.AssignProperties_From_LogAnalyticsDestination(&logAnalyticItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_LogAnalyticsDestination() to populate field LogAnalytics")
			}
			logAnalyticList[logAnalyticIndex] = logAnalytic
		}
		destinations.LogAnalytics = logAnalyticList
	} else {
		destinations.LogAnalytics = nil
	}

	// MicrosoftFabric
	if source.MicrosoftFabric != nil {
		microsoftFabricList := make([]MicrosoftFabricDestination, len(source.MicrosoftFabric))
		for microsoftFabricIndex, microsoftFabricItem := range source.MicrosoftFabric {
			var microsoftFabric MicrosoftFabricDestination
			err := microsoftFabric.AssignProperties_From_MicrosoftFabricDestination(&microsoftFabricItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_MicrosoftFabricDestination() to populate field MicrosoftFabric")
			}
			microsoftFabricList[microsoftFabricIndex] = microsoftFabric
		}
		destinations.MicrosoftFabric = microsoftFabricList
	} else {
		destinations.MicrosoftFabric = nil
	}

	// MonitoringAccounts
	if source.MonitoringAccounts != nil {
		monitoringAccountList := make([]MonitoringAccountDestination, len(source.MonitoringAccounts))
		for monitoringAccountIndex, monitoringAccountItem := range source.MonitoringAccounts {
			var monitoringAccount MonitoringAccountDestination
			err := monitoringAccount.AssignProperties_From_MonitoringAccountDestination(&monitoringAccountItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_MonitoringAccountDestination() to populate field MonitoringAccounts")
			}
			monitoringAccountList[monitoringAccountIndex] = monitoringAccount
		}
		destinations.MonitoringAccounts = monitoringAccountList
	} else {
		destinations.MonitoringAccounts = nil
	}

	// StorageAccounts
	if source.StorageAccounts != nil {
		storageAccountList := make([]StorageBlobDestination, len(source.StorageAccounts))
		for storageAccountIndex, storageAccountItem := range source.StorageAccounts {
			var storageAccount StorageBlobDestination
			err := storageAccount.AssignProperties_From_StorageBlobDestination(&storageAccountItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_StorageBlobDestination() to populate field StorageAccounts")
			}
			storageAccountList[storageAccountIndex] = storageAccount
		}
		destinations.StorageAccounts = storageAccountList
	} else {
		destinations.StorageAccounts = nil
	}

	// StorageBlobsDirect
	if source.StorageBlobsDirect != nil {
		storageBlobsDirectList := make([]StorageBlobDestination, len(source.StorageBlobsDirect))
		for storageBlobsDirectIndex, storageBlobsDirectItem := range source.StorageBlobsDirect {
			var storageBlobsDirect StorageBlobDestination
			err := storageBlobsDirect.AssignProperties_From_StorageBlobDestination(&storageBlobsDirectItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_StorageBlobDestination() to populate field StorageBlobsDirect")
			}
			storageBlobsDirectList[storageBlobsDirectIndex] = storageBlobsDirect
		}
		destinations.StorageBlobsDirect = storageBlobsDirectList
	} else {
		destinations.StorageBlobsDirect = nil
	}

	// StorageTablesDirect
	if source.StorageTablesDirect != nil {
		storageTablesDirectList := make([]StorageTableDestination, len(source.StorageTablesDirect))
		for storageTablesDirectIndex, storageTablesDirectItem := range source.StorageTablesDirect {
			var storageTablesDirect StorageTableDestination
			err := storageTablesDirect.AssignProperties_From_StorageTableDestination(&storageTablesDirectItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_StorageTableDestination() to populate field StorageTablesDirect")
			}
			storageTablesDirectList[storageTablesDirectIndex] = storageTablesDirect
		}
		destinations.StorageTablesDirect = storageTablesDirectList
	} else {
		destinations.StorageTablesDirect = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destinations.PropertyBag = propertyBag
	} else {
		destinations.PropertyBag = nil
	}

	// Invoke the augmentConversionForDestinationsSpec interface (if implemented) to customize the conversion
	var destinationsAsAny any = destinations
	if augmentedDestinations, ok := destinationsAsAny.(augmentConversionForDestinationsSpec); ok {
		err := augmentedDestinations.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DestinationsSpec populates the provided destination DestinationsSpec from our DestinationsSpec
func (destinations *DestinationsSpec) AssignProperties_To_DestinationsSpec(destination *v20240311s.DestinationsSpec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(destinations.PropertyBag)

	// AzureDataExplorer
	if destinations.AzureDataExplorer != nil {
		azureDataExplorerList := make([]v20240311s.AdxDestination, len(destinations.AzureDataExplorer))
		for azureDataExplorerIndex, azureDataExplorerItem := range destinations.AzureDataExplorer {
			var azureDataExplorer v20240311s.AdxDestination
			err := azureDataExplorerItem.AssignProperties_To_AdxDestination(&azureDataExplorer)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_AdxDestination() to populate field AzureDataExplorer")
			}
			azureDataExplorerList[azureDataExplorerIndex] = azureDataExplorer
		}
		destination.AzureDataExplorer = azureDataExplorerList
	} else {
		destination.AzureDataExplorer = nil
	}

	// AzureMonitorMetrics
	if destinations.AzureMonitorMetrics != nil {
		var azureMonitorMetric v20240311s.AzureMonitorMetricsDestination
		err := destinations.AzureMonitorMetrics.AssignProperties_To_AzureMonitorMetricsDestination(&azureMonitorMetric)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AzureMonitorMetricsDestination() to populate field AzureMonitorMetrics")
		}
		destination.AzureMonitorMetrics = &azureMonitorMetric
	} else {
		destination.AzureMonitorMetrics = nil
	}

	// EventHubs
	if destinations.EventHubs != nil {
		eventHubList := make([]v20240311s.EventHubDestination, len(destinations.EventHubs))
		for eventHubIndex, eventHubItem := range destinations.EventHubs {
			var eventHub v20240311s.EventHubDestination
			err := eventHubItem.AssignProperties_To_EventHubDestination(&eventHub)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_EventHubDestination() to populate field EventHubs")
			}
			eventHubList[eventHubIndex] = eventHub
		}
		destination.EventHubs = eventHubList
	} else {
		destination.EventHubs = nil
	}

	// EventHubsDirect
	if destinations.EventHubsDirect != nil {
		eventHubsDirectList := make([]v20240311s.EventHubDirectDestination, len(destinations.EventHubsDirect))
		for eventHubsDirectIndex, eventHubsDirectItem := range destinations.EventHubsDirect {
			var eventHubsDirect v20240311s.EventHubDirectDestination
			err := eventHubsDirectItem.AssignProperties_To_EventHubDirectDestination(&eventHubsDirect)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_EventHubDirectDestination() to populate field EventHubsDirect")
			}
			eventHubsDirectList[eventHubsDirectIndex] = eventHubsDirect
		}
		destination.EventHubsDirect = eventHubsDirectList
	} else {
		destination.EventHubsDirect = nil
	}

	// LogAnalytics
	if destinations.LogAnalytics != nil {
		logAnalyticList := make([]v20240311s.LogAnalyticsDestination, len(destinations.LogAnalytics))
		for logAnalyticIndex, logAnalyticItem := range destinations.LogAnalytics {
			var logAnalytic v20240311s.LogAnalyticsDestination
			err := logAnalyticItem.AssignProperties_To_LogAnalyticsDestination(&logAnalytic)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_LogAnalyticsDestination() to populate field LogAnalytics")
			}
			logAnalyticList[logAnalyticIndex] = logAnalytic
		}
		destination.LogAnalytics = logAnalyticList
	} else {
		destination.LogAnalytics = nil
	}

	// MicrosoftFabric
	if destinations.MicrosoftFabric != nil {
		microsoftFabricList := make([]v20240311s.MicrosoftFabricDestination, len(destinations.MicrosoftFabric))
		for microsoftFabricIndex, microsoftFabricItem := range destinations.MicrosoftFabric {
			var microsoftFabric v20240311s.MicrosoftFabricDestination
			err := microsoftFabricItem.AssignProperties_To_MicrosoftFabricDestination(&microsoftFabric)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_MicrosoftFabricDestination() to populate field MicrosoftFabric")
			}
			microsoftFabricList[microsoftFabricIndex] = microsoftFabric
		}
		destination.MicrosoftFabric = microsoftFabricList
	} else {
		destination.MicrosoftFabric = nil
	}

	// MonitoringAccounts
	if destinations.MonitoringAccounts != nil {
		monitoringAccountList := make([]v20240311s.MonitoringAccountDestination, len(destinations.MonitoringAccounts))
		for monitoringAccountIndex, monitoringAccountItem := range destinations.MonitoringAccounts {
			var monitoringAccount v20240311s.MonitoringAccountDestination
			err := monitoringAccountItem.AssignProperties_To_MonitoringAccountDestination(&monitoringAccount)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_MonitoringAccountDestination() to populate field MonitoringAccounts")
			}
			monitoringAccountList[monitoringAccountIndex] = monitoringAccount
		}
		destination.MonitoringAccounts = monitoringAccountList
	} else {
		destination.MonitoringAccounts = nil
	}

	// StorageAccounts
	if destinations.StorageAccounts != nil {
		storageAccountList := make([]v20240311s.StorageBlobDestination, len(destinations.StorageAccounts))
		for storageAccountIndex, storageAccountItem := range destinations.StorageAccounts {
			var storageAccount v20240311s.StorageBlobDestination
			err := storageAccountItem.AssignProperties_To_StorageBlobDestination(&storageAccount)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_StorageBlobDestination() to populate field StorageAccounts")
			}
			storageAccountList[storageAccountIndex] = storageAccount
		}
		destination.StorageAccounts = storageAccountList
	} else {
		destination.StorageAccounts = nil
	}

	// StorageBlobsDirect
	if destinations.StorageBlobsDirect != nil {
		storageBlobsDirectList := make([]v20240311s.StorageBlobDestination, len(destinations.StorageBlobsDirect))
		for storageBlobsDirectIndex, storageBlobsDirectItem := range destinations.StorageBlobsDirect {
			var storageBlobsDirect v20240311s.StorageBlobDestination
			err := storageBlobsDirectItem.AssignProperties_To_StorageBlobDestination(&storageBlobsDirect)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_StorageBlobDestination() to populate field StorageBlobsDirect")
			}
			storageBlobsDirectList[storageBlobsDirectIndex] = storageBlobsDirect
		}
		destination.StorageBlobsDirect = storageBlobsDirectList
	} else {
		destination.StorageBlobsDirect = nil
	}

	// StorageTablesDirect
	if destinations.StorageTablesDirect != nil {
		storageTablesDirectList := make([]v20240311s.StorageTableDestination, len(destinations.StorageTablesDirect))
		for storageTablesDirectIndex, storageTablesDirectItem := range destinations.StorageTablesDirect {
			var storageTablesDirect v20240311s.StorageTableDestination
			err := storageTablesDirectItem.AssignProperties_To_StorageTableDestination(&storageTablesDirect)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_StorageTableDestination() to populate field StorageTablesDirect")
			}
			storageTablesDirectList[storageTablesDirectIndex] = storageTablesDirect
		}
		destination.StorageTablesDirect = storageTablesDirectList
	} else {
		destination.StorageTablesDirect = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDestinationsSpec interface (if implemented) to customize the conversion
	var destinationsAsAny any = destinations
	if augmentedDestinations, ok := destinationsAsAny.(augmentConversionForDestinationsSpec); ok {
		err := augmentedDestinations.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.DestinationsSpec_STATUS
// Specification of destinations that can be used in data flows.
type DestinationsSpec_STATUS struct {
	AzureDataExplorer   []AdxDestination_STATUS                `json:"azureDataExplorer,omitempty"`
	AzureMonitorMetrics *AzureMonitorMetricsDestination_STATUS `json:"azureMonitorMetrics,omitempty"`
	EventHubs           []EventHubDestination_STATUS           `json:"eventHubs,omitempty"`
	EventHubsDirect     []EventHubDirectDestination_STATUS     `json:"eventHubsDirect,omitempty"`
	LogAnalytics        []LogAnalyticsDestination_STATUS       `json:"logAnalytics,omitempty"`
	MicrosoftFabric     []MicrosoftFabricDestination_STATUS    `json:"microsoftFabric,omitempty"`
	MonitoringAccounts  []MonitoringAccountDestination_STATUS  `json:"monitoringAccounts,omitempty"`
	PropertyBag         genruntime.PropertyBag                 `json:"$propertyBag,omitempty"`
	StorageAccounts     []StorageBlobDestination_STATUS        `json:"storageAccounts,omitempty"`
	StorageBlobsDirect  []StorageBlobDestination_STATUS        `json:"storageBlobsDirect,omitempty"`
	StorageTablesDirect []StorageTableDestination_STATUS       `json:"storageTablesDirect,omitempty"`
}

// AssignProperties_From_DestinationsSpec_STATUS populates our DestinationsSpec_STATUS from the provided source DestinationsSpec_STATUS
func (destinations *DestinationsSpec_STATUS) AssignProperties_From_DestinationsSpec_STATUS(source *v20240311s.DestinationsSpec_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AzureDataExplorer
	if source.AzureDataExplorer != nil {
		azureDataExplorerList := make([]AdxDestination_STATUS, len(source.AzureDataExplorer))
		for azureDataExplorerIndex, azureDataExplorerItem := range source.AzureDataExplorer {
			var azureDataExplorer AdxDestination_STATUS
			err := azureDataExplorer.AssignProperties_From_AdxDestination_STATUS(&azureDataExplorerItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_AdxDestination_STATUS() to populate field AzureDataExplorer")
			}
			azureDataExplorerList[azureDataExplorerIndex] = azureDataExplorer
		}
		destinations.AzureDataExplorer = azureDataExplorerList
	} else {
		destinations.AzureDataExplorer = nil
	}

	// AzureMonitorMetrics
	if source.AzureMonitorMetrics != nil {
		var azureMonitorMetric AzureMonitorMetricsDestination_STATUS
		err := azureMonitorMetric.AssignProperties_From_AzureMonitorMetricsDestination_STATUS(source.AzureMonitorMetrics)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AzureMonitorMetricsDestination_STATUS() to populate field AzureMonitorMetrics")
		}
		destinations.AzureMonitorMetrics = &azureMonitorMetric
	} else {
		destinations.AzureMonitorMetrics = nil
	}

	// EventHubs
	if source.EventHubs != nil {
		eventHubList := make([]EventHubDestination_STATUS, len(source.EventHubs))
		for eventHubIndex, eventHubItem := range source.EventHubs {
			var eventHub EventHubDestination_STATUS
			err := eventHub.AssignProperties_From_EventHubDestination_STATUS(&eventHubItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_EventHubDestination_STATUS() to populate field EventHubs")
			}
			eventHubList[eventHubIndex] = eventHub
		}
		destinations.EventHubs = eventHubList
	} else {
		destinations.EventHubs = nil
	}

	// EventHubsDirect
	if source.EventHubsDirect != nil {
		eventHubsDirectList := make([]EventHubDirectDestination_STATUS, len(source.EventHubsDirect))
		for eventHubsDirectIndex, eventHubsDirectItem := range source.EventHubsDirect {
			var eventHubsDirect EventHubDirectDestination_STATUS
			err := eventHubsDirect.AssignProperties_From_EventHubDirectDestination_STATUS(&eventHubsDirectItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_EventHubDirectDestination_STATUS() to populate field EventHubsDirect")
			}
			eventHubsDirectList[eventHubsDirectIndex] = eventHubsDirect
		}
		destinations.EventHubsDirect = eventHubsDirectList
	} else {
		destinations.EventHubsDirect = nil
	}

	// LogAnalytics
	if source.LogAnalytics != nil {
		logAnalyticList := make([]LogAnalyticsDestination_STATUS, len(source.LogAnalytics))
		for logAnalyticIndex, logAnalyticItem := range source.LogAnalytics {
			var logAnalytic LogAnalyticsDestination_STATUS
			err := logAnalytic.AssignProperties_From_LogAnalyticsDestination_STATUS(&logAnalyticItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_LogAnalyticsDestination_STATUS() to populate field LogAnalytics")
			}
			logAnalyticList[logAnalyticIndex] = logAnalytic
		}
		destinations.LogAnalytics = logAnalyticList
	} else {
		destinations.LogAnalytics = nil
	}

	// MicrosoftFabric
	if source.MicrosoftFabric != nil {
		microsoftFabricList := make([]MicrosoftFabricDestination_STATUS, len(source.MicrosoftFabric))
		for microsoftFabricIndex, microsoftFabricItem := range source.MicrosoftFabric {
			var microsoftFabric MicrosoftFabricDestination_STATUS
			err := microsoftFabric.AssignProperties_From_MicrosoftFabricDestination_STATUS(&microsoftFabricItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_MicrosoftFabricDestination_STATUS() to populate field MicrosoftFabric")
			}
			microsoftFabricList[microsoftFabricIndex] = microsoftFabric
		}
		destinations.MicrosoftFabric = microsoftFabricList
	} else {
		destinations.MicrosoftFabric = nil
	}

	// MonitoringAccounts
	if source.MonitoringAccounts != nil {
		monitoringAccountList := make([]MonitoringAccountDestination_STATUS, len(source.MonitoringAccounts))
		for monitoringAccountIndex, monitoringAccountItem := range source.MonitoringAccounts {
			var monitoringAccount MonitoringAccountDestination_STATUS
			err := monitoringAccount.AssignProperties_From_MonitoringAccountDestination_STATUS(&monitoringAccountItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_MonitoringAccountDestination_STATUS() to populate field MonitoringAccounts")
			}
			monitoringAccountList[monitoringAccountIndex] = monitoringAccount
		}
		destinations.MonitoringAccounts = monitoringAccountList
	} else {
		destinations.MonitoringAccounts = nil
	}

	// StorageAccounts
	if source.StorageAccounts != nil {
		storageAccountList := make([]StorageBlobDestination_STATUS, len(source.StorageAccounts))
		for storageAccountIndex, storageAccountItem := range source.StorageAccounts {
			var storageAccount StorageBlobDestination_STATUS
			err := storageAccount.AssignProperties_From_StorageBlobDestination_STATUS(&storageAccountItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_StorageBlobDestination_STATUS() to populate field StorageAccounts")
			}
			storageAccountList[storageAccountIndex] = storageAccount
		}
		destinations.StorageAccounts = storageAccountList
	} else {
		destinations.StorageAccounts = nil
	}

	// StorageBlobsDirect
	if source.StorageBlobsDirect != nil {
		storageBlobsDirectList := make([]StorageBlobDestination_STATUS, len(source.StorageBlobsDirect))
		for storageBlobsDirectIndex, storageBlobsDirectItem := range source.StorageBlobsDirect {
			var storageBlobsDirect StorageBlobDestination_STATUS
			err := storageBlobsDirect.AssignProperties_From_StorageBlobDestination_STATUS(&storageBlobsDirectItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_StorageBlobDestination_STATUS() to populate field StorageBlobsDirect")
			}
			storageBlobsDirectList[storageBlobsDirectIndex] = storageBlobsDirect
		}
		destinations.StorageBlobsDirect = storageBlobsDirectList
	} else {
		destinations.StorageBlobsDirect = nil
	}

	// StorageTablesDirect
	if source.StorageTablesDirect != nil {
		storageTablesDirectList := make([]StorageTableDestination_STATUS, len(source.StorageTablesDirect))
		for storageTablesDirectIndex, storageTablesDirectItem := range source.StorageTablesDirect {
			var storageTablesDirect StorageTableDestination_STATUS
			err := storageTablesDirect.AssignProperties_From_StorageTableDestination_STATUS(&storageTablesDirectItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_StorageTableDestination_STATUS() to populate field StorageTablesDirect")
			}
			storageTablesDirectList[storageTablesDirectIndex] = storageTablesDirect
		}
		destinations.StorageTablesDirect = storageTablesDirectList
	} else {
		destinations.StorageTablesDirect = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destinations.PropertyBag = propertyBag
	} else {
		destinations.PropertyBag = nil
	}

	// Invoke the augmentConversionForDestinationsSpec_STATUS interface (if implemented) to customize the conversion
	var destinationsAsAny any = destinations
	if augmentedDestinations, ok := destinationsAsAny.(augmentConversionForDestinationsSpec_STATUS); ok {
		err := augmentedDestinations.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DestinationsSpec_STATUS populates the provided destination DestinationsSpec_STATUS from our DestinationsSpec_STATUS
func (destinations *DestinationsSpec_STATUS) AssignProperties_To_DestinationsSpec_STATUS(destination *v20240311s.DestinationsSpec_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(destinations.PropertyBag)

	// AzureDataExplorer
	if destinations.AzureDataExplorer != nil {
		azureDataExplorerList := make([]v20240311s.AdxDestination_STATUS, len(destinations.AzureDataExplorer))
		for azureDataExplorerIndex, azureDataExplorerItem := range destinations.AzureDataExplorer {
			var azureDataExplorer v20240311s.AdxDestination_STATUS
			err := azureDataExplorerItem.AssignProperties_To_AdxDestination_STATUS(&azureDataExplorer)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_AdxDestination_STATUS() to populate field AzureDataExplorer")
			}
			azureDataExplorerList[azureDataExplorerIndex] = azureDataExplorer
		}
		destination.AzureDataExplorer = azureDataExplorerList
	} else {
		destination.AzureDataExplorer = nil
	}

	// AzureMonitorMetrics
	if destinations.AzureMonitorMetrics != nil {
		var azureMonitorMetric v20240311s.AzureMonitorMetricsDestination_STATUS
		err := destinations.AzureMonitorMetrics.AssignProperties_To_AzureMonitorMetricsDestination_STATUS(&azureMonitorMetric)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AzureMonitorMetricsDestination_STATUS() to populate field AzureMonitorMetrics")
		}
		destination.AzureMonitorMetrics = &azureMonitorMetric
	} else {
		destination.AzureMonitorMetrics = nil
	}

	// EventHubs
	if destinations.EventHubs != nil {
		eventHubList := make([]v20240311s.EventHubDestination_STATUS, len(destinations.EventHubs))
		for eventHubIndex, eventHubItem := range destinations.EventHubs {
			var eventHub v20240311s.EventHubDestination_STATUS
			err := eventHubItem.AssignProperties_To_EventHubDestination_STATUS(&eventHub)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_EventHubDestination_STATUS() to populate field EventHubs")
			}
			eventHubList[eventHubIndex] = eventHub
		}
		destination.EventHubs = eventHubList
	} else {
		destination.EventHubs = nil
	}

	// EventHubsDirect
	if destinations.EventHubsDirect != nil {
		eventHubsDirectList := make([]v20240311s.EventHubDirectDestination_STATUS, len(destinations.EventHubsDirect))
		for eventHubsDirectIndex, eventHubsDirectItem := range destinations.EventHubsDirect {
			var eventHubsDirect v20240311s.EventHubDirectDestination_STATUS
			err := eventHubsDirectItem.AssignProperties_To_EventHubDirectDestination_STATUS(&eventHubsDirect)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_EventHubDirectDestination_STATUS() to populate field EventHubsDirect")
			}
			eventHubsDirectList[eventHubsDirectIndex] = eventHubsDirect
		}
		destination.EventHubsDirect = eventHubsDirectList
	} else {
		destination.EventHubsDirect = nil
	}

	// LogAnalytics
	if destinations.LogAnalytics != nil {
		logAnalyticList := make([]v20240311s.LogAnalyticsDestination_STATUS, len(destinations.LogAnalytics))
		for logAnalyticIndex, logAnalyticItem := range destinations.LogAnalytics {
			var logAnalytic v20240311s.LogAnalyticsDestination_STATUS
			err := logAnalyticItem.AssignProperties_To_LogAnalyticsDestination_STATUS(&logAnalytic)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_LogAnalyticsDestination_STATUS() to populate field LogAnalytics")
			}
			logAnalyticList[logAnalyticIndex] = logAnalytic
		}
		destination.LogAnalytics = logAnalyticList
	} else {
		destination.LogAnalytics = nil
	}

	// MicrosoftFabric
	if destinations.MicrosoftFabric != nil {
		microsoftFabricList := make([]v20240311s.MicrosoftFabricDestination_STATUS, len(destinations.MicrosoftFabric))
		for microsoftFabricIndex, microsoftFabricItem := range destinations.MicrosoftFabric {
			var microsoftFabric v20240311s.MicrosoftFabricDestination_STATUS
			err := microsoftFabricItem.AssignProperties_To_MicrosoftFabricDestination_STATUS(&microsoftFabric)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_MicrosoftFabricDestination_STATUS() to populate field MicrosoftFabric")
			}
			microsoftFabricList[microsoftFabricIndex] = microsoftFabric
		}
		destination.MicrosoftFabric = microsoftFabricList
	} else {
		destination.MicrosoftFabric = nil
	}

	// MonitoringAccounts
	if destinations.MonitoringAccounts != nil {
		monitoringAccountList := make([]v20240311s.MonitoringAccountDestination_STATUS, len(destinations.MonitoringAccounts))
		for monitoringAccountIndex, monitoringAccountItem := range destinations.MonitoringAccounts {
			var monitoringAccount v20240311s.MonitoringAccountDestination_STATUS
			err := monitoringAccountItem.AssignProperties_To_MonitoringAccountDestination_STATUS(&monitoringAccount)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_MonitoringAccountDestination_STATUS() to populate field MonitoringAccounts")
			}
			monitoringAccountList[monitoringAccountIndex] = monitoringAccount
		}
		destination.MonitoringAccounts = monitoringAccountList
	} else {
		destination.MonitoringAccounts = nil
	}

	// StorageAccounts
	if destinations.StorageAccounts != nil {
		storageAccountList := make([]v20240311s.StorageBlobDestination_STATUS, len(destinations.StorageAccounts))
		for storageAccountIndex, storageAccountItem := range destinations.StorageAccounts {
			var storageAccount v20240311s.StorageBlobDestination_STATUS
			err := storageAccountItem.AssignProperties_To_StorageBlobDestination_STATUS(&storageAccount)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_StorageBlobDestination_STATUS() to populate field StorageAccounts")
			}
			storageAccountList[storageAccountIndex] = storageAccount
		}
		destination.StorageAccounts = storageAccountList
	} else {
		destination.StorageAccounts = nil
	}

	// StorageBlobsDirect
	if destinations.StorageBlobsDirect != nil {
		storageBlobsDirectList := make([]v20240311s.StorageBlobDestination_STATUS, len(destinations.StorageBlobsDirect))
		for storageBlobsDirectIndex, storageBlobsDirectItem := range destinations.StorageBlobsDirect {
			var storageBlobsDirect v20240311s.StorageBlobDestination_STATUS
			err := storageBlobsDirectItem.AssignProperties_To_StorageBlobDestination_STATUS(&storageBlobsDirect)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_StorageBlobDestination_STATUS() to populate field StorageBlobsDirect")
			}
			storageBlobsDirectList[storageBlobsDirectIndex] = storageBlobsDirect
		}
		destination.StorageBlobsDirect = storageBlobsDirectList
	} else {
		destination.StorageBlobsDirect = nil
	}

	// StorageTablesDirect
	if destinations.StorageTablesDirect != nil {
		storageTablesDirectList := make([]v20240311s.StorageTableDestination_STATUS, len(destinations.StorageTablesDirect))
		for storageTablesDirectIndex, storageTablesDirectItem := range destinations.StorageTablesDirect {
			var storageTablesDirect v20240311s.StorageTableDestination_STATUS
			err := storageTablesDirectItem.AssignProperties_To_StorageTableDestination_STATUS(&storageTablesDirect)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_StorageTableDestination_STATUS() to populate field StorageTablesDirect")
			}
			storageTablesDirectList[storageTablesDirectIndex] = storageTablesDirect
		}
		destination.StorageTablesDirect = storageTablesDirectList
	} else {
		destination.StorageTablesDirect = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDestinationsSpec_STATUS interface (if implemented) to customize the conversion
	var destinationsAsAny any = destinations
	if augmentedDestinations, ok := destinationsAsAny.(augmentConversionForDestinationsSpec_STATUS); ok {
		err := augmentedDestinations.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.EndpointsSpec_STATUS
// This defines all the ingestion endpoints that can be used by this rule
type EndpointsSpec_STATUS struct {
	LogsIngestion    *string                `json:"logsIngestion,omitempty"`
	MetricsIngestion *string                `json:"metricsIngestion,omitempty"`
	PropertyBag      genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_EndpointsSpec_STATUS populates our EndpointsSpec_STATUS from the provided source EndpointsSpec_STATUS
func (endpoints *EndpointsSpec_STATUS) AssignProperties_From_EndpointsSpec_STATUS(source *v20240311s.EndpointsSpec_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// LogsIngestion
	endpoints.LogsIngestion = genruntime.ClonePointerToString(source.LogsIngestion)

	// MetricsIngestion
	endpoints.MetricsIngestion = genruntime.ClonePointerToString(source.MetricsIngestion)

	// Update the property bag
	if len(propertyBag) > 0 {
		endpoints.PropertyBag = propertyBag
	} else {
		endpoints.PropertyBag = nil
	}

	// Invoke the augmentConversionForEndpointsSpec_STATUS interface (if implemented) to customize the conversion
	var endpointsAsAny any = endpoints
	if augmentedEndpoints, ok := endpointsAsAny.(augmentConversionForEndpointsSpec_STATUS); ok {
		err := augmentedEndpoints.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_EndpointsSpec_STATUS populates the provided destination EndpointsSpec_STATUS from our EndpointsSpec_STATUS
func (endpoints *EndpointsSpec_STATUS) AssignProperties_To_EndpointsSpec_STATUS(destination *v20240311s.EndpointsSpec_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(endpoints.PropertyBag)

	// LogsIngestion
	destination.LogsIngestion = genruntime.ClonePointerToString(endpoints.LogsIngestion)

	// MetricsIngestion
	destination.MetricsIngestion = genruntime.ClonePointerToString(endpoints.MetricsIngestion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForEndpointsSpec_STATUS interface (if implemented) to customize the conversion
	var endpointsAsAny any = endpoints
	if augmentedEndpoints, ok := endpointsAsAny.(augmentConversionForEndpointsSpec_STATUS); ok {
		err := augmentedEndpoints.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.ReferencesSpec
// This section defines all the references that may be used in other sections of the DCR
type ReferencesSpec struct {
	EnrichmentData *EnrichmentData        `json:"enrichmentData,omitempty"`
	PropertyBag    genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_ReferencesSpec populates our ReferencesSpec from the provided source ReferencesSpec
func (references *ReferencesSpec) AssignProperties_From_ReferencesSpec(source *v20240311s.ReferencesSpec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ApplicationInsights
	if len(source.ApplicationInsights) > 0 {
		propertyBag.Add("ApplicationInsights", source.ApplicationInsights)
	} else {
		propertyBag.Remove("ApplicationInsights")
	}

	// EnrichmentData
	if source.EnrichmentData != nil {
		var enrichmentDatum EnrichmentData
		err := enrichmentDatum.AssignProperties_From_EnrichmentData(source.EnrichmentData)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_EnrichmentData() to populate field EnrichmentData")
		}
		references.EnrichmentData = &enrichmentDatum
	} else {
		references.EnrichmentData = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		references.PropertyBag = propertyBag
	} else {
		references.PropertyBag = nil
	}

	// Invoke the augmentConversionForReferencesSpec interface (if implemented) to customize the conversion
	var referencesAsAny any = references
	if augmentedReferences, ok := referencesAsAny.(augmentConversionForReferencesSpec); ok {
		err := augmentedReferences.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ReferencesSpec populates the provided destination ReferencesSpec from our ReferencesSpec
func (references *ReferencesSpec) AssignProperties_To_ReferencesSpec(destination *v20240311s.ReferencesSpec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(references.PropertyBag)

	// ApplicationInsights
	if propertyBag.Contains("ApplicationInsights") {
		var applicationInsight []v20240311s.ApplicationInsights
		err := propertyBag.Pull("ApplicationInsights", &applicationInsight)
		if err != nil {
			return eris.Wrap(err, "pulling 'ApplicationInsights' from propertyBag")
		}

		destination.ApplicationInsights = applicationInsight
	} else {
		destination.ApplicationInsights = nil
	}

	// EnrichmentData
	if references.EnrichmentData != nil {
		var enrichmentDatum v20240311s.EnrichmentData
		err := references.EnrichmentData.AssignProperties_To_EnrichmentData(&enrichmentDatum)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_EnrichmentData() to populate field EnrichmentData")
		}
		destination.EnrichmentData = &enrichmentDatum
	} else {
		destination.EnrichmentData = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForReferencesSpec interface (if implemented) to customize the conversion
	var referencesAsAny any = references
	if augmentedReferences, ok := referencesAsAny.(augmentConversionForReferencesSpec); ok {
		err := augmentedReferences.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.ReferencesSpec_STATUS
// This section defines all the references that may be used in other sections of the DCR
type ReferencesSpec_STATUS struct {
	EnrichmentData *EnrichmentData_STATUS `json:"enrichmentData,omitempty"`
	PropertyBag    genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_ReferencesSpec_STATUS populates our ReferencesSpec_STATUS from the provided source ReferencesSpec_STATUS
func (references *ReferencesSpec_STATUS) AssignProperties_From_ReferencesSpec_STATUS(source *v20240311s.ReferencesSpec_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ApplicationInsights
	if len(source.ApplicationInsights) > 0 {
		propertyBag.Add("ApplicationInsights", source.ApplicationInsights)
	} else {
		propertyBag.Remove("ApplicationInsights")
	}

	// EnrichmentData
	if source.EnrichmentData != nil {
		var enrichmentDatum EnrichmentData_STATUS
		err := enrichmentDatum.AssignProperties_From_EnrichmentData_STATUS(source.EnrichmentData)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_EnrichmentData_STATUS() to populate field EnrichmentData")
		}
		references.EnrichmentData = &enrichmentDatum
	} else {
		references.EnrichmentData = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		references.PropertyBag = propertyBag
	} else {
		references.PropertyBag = nil
	}

	// Invoke the augmentConversionForReferencesSpec_STATUS interface (if implemented) to customize the conversion
	var referencesAsAny any = references
	if augmentedReferences, ok := referencesAsAny.(augmentConversionForReferencesSpec_STATUS); ok {
		err := augmentedReferences.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ReferencesSpec_STATUS populates the provided destination ReferencesSpec_STATUS from our ReferencesSpec_STATUS
func (references *ReferencesSpec_STATUS) AssignProperties_To_ReferencesSpec_STATUS(destination *v20240311s.ReferencesSpec_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(references.PropertyBag)

	// ApplicationInsights
	if propertyBag.Contains("ApplicationInsights") {
		var applicationInsight []v20240311s.ApplicationInsights_STATUS
		err := propertyBag.Pull("ApplicationInsights", &applicationInsight)
		if err != nil {
			return eris.Wrap(err, "pulling 'ApplicationInsights' from propertyBag")
		}

		destination.ApplicationInsights = applicationInsight
	} else {
		destination.ApplicationInsights = nil
	}

	// EnrichmentData
	if references.EnrichmentData != nil {
		var enrichmentDatum v20240311s.EnrichmentData_STATUS
		err := references.EnrichmentData.AssignProperties_To_EnrichmentData_STATUS(&enrichmentDatum)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_EnrichmentData_STATUS() to populate field EnrichmentData")
		}
		destination.EnrichmentData = &enrichmentDatum
	} else {
		destination.EnrichmentData = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForReferencesSpec_STATUS interface (if implemented) to customize the conversion
	var referencesAsAny any = references
	if augmentedReferences, ok := referencesAsAny.(augmentConversionForReferencesSpec_STATUS); ok {
		err := augmentedReferences.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.StreamDeclaration
// Declaration of a custom stream.
type StreamDeclaration struct {
	Columns     []ColumnDefinition     `json:"columns,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_StreamDeclaration populates our StreamDeclaration from the provided source StreamDeclaration
func (declaration *StreamDeclaration) AssignProperties_From_StreamDeclaration(source *v20240311s.StreamDeclaration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Columns
	if source.Columns != nil {
		columnList := make([]ColumnDefinition, len(source.Columns))
		for columnIndex, columnItem := range source.Columns {
			var column ColumnDefinition
			err := column.AssignProperties_From_ColumnDefinition(&columnItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ColumnDefinition() to populate field Columns")
			}
			columnList[columnIndex] = column
		}
		declaration.Columns = columnList
	} else {
		declaration.Columns = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		declaration.PropertyBag = propertyBag
	} else {
		declaration.PropertyBag = nil
	}

	// Invoke the augmentConversionForStreamDeclaration interface (if implemented) to customize the conversion
	var declarationAsAny any = declaration
	if augmentedDeclaration, ok := declarationAsAny.(augmentConversionForStreamDeclaration); ok {
		err := augmentedDeclaration.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_StreamDeclaration populates the provided destination StreamDeclaration from our StreamDeclaration
func (declaration *StreamDeclaration) AssignProperties_To_StreamDeclaration(destination *v20240311s.StreamDeclaration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(declaration.PropertyBag)

	// Columns
	if declaration.Columns != nil {
		columnList := make([]v20240311s.ColumnDefinition, len(declaration.Columns))
		for columnIndex, columnItem := range declaration.Columns {
			var column v20240311s.ColumnDefinition
			err := columnItem.AssignProperties_To_ColumnDefinition(&column)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ColumnDefinition() to populate field Columns")
			}
			columnList[columnIndex] = column
		}
		destination.Columns = columnList
	} else {
		destination.Columns = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForStreamDeclaration interface (if implemented) to customize the conversion
	var declarationAsAny any = declaration
	if augmentedDeclaration, ok := declarationAsAny.(augmentConversionForStreamDeclaration); ok {
		err := augmentedDeclaration.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.StreamDeclaration_STATUS
// Declaration of a custom stream.
type StreamDeclaration_STATUS struct {
	Columns     []ColumnDefinition_STATUS `json:"columns,omitempty"`
	PropertyBag genruntime.PropertyBag    `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_StreamDeclaration_STATUS populates our StreamDeclaration_STATUS from the provided source StreamDeclaration_STATUS
func (declaration *StreamDeclaration_STATUS) AssignProperties_From_StreamDeclaration_STATUS(source *v20240311s.StreamDeclaration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Columns
	if source.Columns != nil {
		columnList := make([]ColumnDefinition_STATUS, len(source.Columns))
		for columnIndex, columnItem := range source.Columns {
			var column ColumnDefinition_STATUS
			err := column.AssignProperties_From_ColumnDefinition_STATUS(&columnItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ColumnDefinition_STATUS() to populate field Columns")
			}
			columnList[columnIndex] = column
		}
		declaration.Columns = columnList
	} else {
		declaration.Columns = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		declaration.PropertyBag = propertyBag
	} else {
		declaration.PropertyBag = nil
	}

	// Invoke the augmentConversionForStreamDeclaration_STATUS interface (if implemented) to customize the conversion
	var declarationAsAny any = declaration
	if augmentedDeclaration, ok := declarationAsAny.(augmentConversionForStreamDeclaration_STATUS); ok {
		err := augmentedDeclaration.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_StreamDeclaration_STATUS populates the provided destination StreamDeclaration_STATUS from our StreamDeclaration_STATUS
func (declaration *StreamDeclaration_STATUS) AssignProperties_To_StreamDeclaration_STATUS(destination *v20240311s.StreamDeclaration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(declaration.PropertyBag)

	// Columns
	if declaration.Columns != nil {
		columnList := make([]v20240311s.ColumnDefinition_STATUS, len(declaration.Columns))
		for columnIndex, columnItem := range declaration.Columns {
			var column v20240311s.ColumnDefinition_STATUS
			err := columnItem.AssignProperties_To_ColumnDefinition_STATUS(&column)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ColumnDefinition_STATUS() to populate field Columns")
			}
			columnList[columnIndex] = column
		}
		destination.Columns = columnList
	} else {
		destination.Columns = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForStreamDeclaration_STATUS interface (if implemented) to customize the conversion
	var declarationAsAny any = declaration
	if augmentedDeclaration, ok := declarationAsAny.(augmentConversionForStreamDeclaration_STATUS); ok {
		err := augmentedDeclaration.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.AdxDestination
// Azure Data Explorer (Adx) destination.
type AdxDestination struct {
	DatabaseName *string                `json:"databaseName,omitempty"`
	Name         *string                `json:"name,omitempty"`
	PropertyBag  genruntime.PropertyBag `json:"$propertyBag,omitempty"`

	// ResourceReference: The ARM resource id of the Adx resource.
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceId" json:"resourceReference,omitempty"`
}

// AssignProperties_From_AdxDestination populates our AdxDestination from the provided source AdxDestination
func (destination *AdxDestination) AssignProperties_From_AdxDestination(source *v20240311s.AdxDestination) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DatabaseName
	destination.DatabaseName = genruntime.ClonePointerToString(source.DatabaseName)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAdxDestination interface (if implemented) to customize the conversion
	var destinationAsAny any = destination
	if augmentedDestination, ok := destinationAsAny.(augmentConversionForAdxDestination); ok {
		err := augmentedDestination.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AdxDestination populates the provided destination AdxDestination from our AdxDestination
func (destination *AdxDestination) AssignProperties_To_AdxDestination(target *v20240311s.AdxDestination) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(destination.PropertyBag)

	// DatabaseName
	target.DatabaseName = genruntime.ClonePointerToString(destination.DatabaseName)

	// Name
	target.Name = genruntime.ClonePointerToString(destination.Name)

	// ResourceReference
	if destination.ResourceReference != nil {
		resourceReference := destination.ResourceReference.Copy()
		target.ResourceReference = &resourceReference
	} else {
		target.ResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		target.PropertyBag = propertyBag
	} else {
		target.PropertyBag = nil
	}

	// Invoke the augmentConversionForAdxDestination interface (if implemented) to customize the conversion
	var destinationAsAny any = destination
	if augmentedDestination, ok := destinationAsAny.(augmentConversionForAdxDestination); ok {
		err := augmentedDestination.AssignPropertiesTo(target)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.AdxDestination_STATUS
// Azure Data Explorer (Adx) destination.
type AdxDestination_STATUS struct {
	DatabaseName *string                `json:"databaseName,omitempty"`
	IngestionUri *string                `json:"ingestionUri,omitempty"`
	Name         *string                `json:"name,omitempty"`
	PropertyBag  genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	ResourceId   *string                `json:"resourceId,omitempty"`
}

// AssignProperties_From_AdxDestination_STATUS populates our AdxDestination_STATUS from the provided source AdxDestination_STATUS
func (destination *AdxDestination_STATUS) AssignProperties_From_AdxDestination_STATUS(source *v20240311s.AdxDestination_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DatabaseName
	destination.DatabaseName = genruntime.ClonePointerToString(source.DatabaseName)

	// IngestionUri
	destination.IngestionUri = genruntime.ClonePointerToString(source.IngestionUri)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// ResourceId
	destination.ResourceId = genruntime.ClonePointerToString(source.ResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAdxDestination_STATUS interface (if implemented) to customize the conversion
	var destinationAsAny any = destination
	if augmentedDestination, ok := destinationAsAny.(augmentConversionForAdxDestination_STATUS); ok {
		err := augmentedDestination.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AdxDestination_STATUS populates the provided destination AdxDestination_STATUS from our AdxDestination_STATUS
func (destination *AdxDestination_STATUS) AssignProperties_To_AdxDestination_STATUS(target *v20240311s.AdxDestination_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(destination.PropertyBag)

	// DatabaseName
	target.DatabaseName = genruntime.ClonePointerToString(destination.DatabaseName)

	// IngestionUri
	target.IngestionUri = genruntime.ClonePointerToString(destination.IngestionUri)

	// Name
	target.Name = genruntime.ClonePointerToString(destination.Name)

	// ResourceId
	target.ResourceId = genruntime.ClonePointerToString(destination.ResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		target.PropertyBag = propertyBag
	} else {
		target.PropertyBag = nil
	}

	// Invoke the augmentConversionForAdxDestination_STATUS interface (if implemented) to customize the conversion
	var destinationAsAny any = destination
	if augmentedDestination, ok := destinationAsAny.(augmentConversionForAdxDestination_STATUS); ok {
		err := augmentedDestination.AssignPropertiesTo(target)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.AgentSetting
// A setting used to control an agent behavior on a host machine
type AgentSetting struct {
	Name        *string                `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Value       *string                `json:"value,omitempty"`
}

// AssignProperties_From_AgentSetting populates our AgentSetting from the provided source AgentSetting
func (setting *AgentSetting) AssignProperties_From_AgentSetting(source *v20240311s.AgentSetting) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	setting.Name = genruntime.ClonePointerToString(source.Name)

	// Value
	setting.Value = genruntime.ClonePointerToString(source.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		setting.PropertyBag = propertyBag
	} else {
		setting.PropertyBag = nil
	}

	// Invoke the augmentConversionForAgentSetting interface (if implemented) to customize the conversion
	var settingAsAny any = setting
	if augmentedSetting, ok := settingAsAny.(augmentConversionForAgentSetting); ok {
		err := augmentedSetting.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AgentSetting populates the provided destination AgentSetting from our AgentSetting
func (setting *AgentSetting) AssignProperties_To_AgentSetting(destination *v20240311s.AgentSetting) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(setting.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(setting.Name)

	// Value
	destination.Value = genruntime.ClonePointerToString(setting.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAgentSetting interface (if implemented) to customize the conversion
	var settingAsAny any = setting
	if augmentedSetting, ok := settingAsAny.(augmentConversionForAgentSetting); ok {
		err := augmentedSetting.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.AgentSetting_STATUS
// A setting used to control an agent behavior on a host machine
type AgentSetting_STATUS struct {
	Name        *string                `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Value       *string                `json:"value,omitempty"`
}

// AssignProperties_From_AgentSetting_STATUS populates our AgentSetting_STATUS from the provided source AgentSetting_STATUS
func (setting *AgentSetting_STATUS) AssignProperties_From_AgentSetting_STATUS(source *v20240311s.AgentSetting_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	setting.Name = genruntime.ClonePointerToString(source.Name)

	// Value
	setting.Value = genruntime.ClonePointerToString(source.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		setting.PropertyBag = propertyBag
	} else {
		setting.PropertyBag = nil
	}

	// Invoke the augmentConversionForAgentSetting_STATUS interface (if implemented) to customize the conversion
	var settingAsAny any = setting
	if augmentedSetting, ok := settingAsAny.(augmentConversionForAgentSetting_STATUS); ok {
		err := augmentedSetting.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AgentSetting_STATUS populates the provided destination AgentSetting_STATUS from our AgentSetting_STATUS
func (setting *AgentSetting_STATUS) AssignProperties_To_AgentSetting_STATUS(destination *v20240311s.AgentSetting_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(setting.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(setting.Name)

	// Value
	destination.Value = genruntime.ClonePointerToString(setting.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAgentSetting_STATUS interface (if implemented) to customize the conversion
	var settingAsAny any = setting
	if augmentedSetting, ok := settingAsAny.(augmentConversionForAgentSetting_STATUS); ok {
		err := augmentedSetting.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForAgentSettingsSpec interface {
	AssignPropertiesFrom(src *v20240311s.AgentSettingsSpec) error
	AssignPropertiesTo(dst *v20240311s.AgentSettingsSpec) error
}

type augmentConversionForAgentSettingsSpec_STATUS interface {
	AssignPropertiesFrom(src *v20240311s.AgentSettingsSpec_STATUS) error
	AssignPropertiesTo(dst *v20240311s.AgentSettingsSpec_STATUS) error
}

type augmentConversionForDataCollectionRuleOperatorSpec interface {
	AssignPropertiesFrom(src *v20240311s.DataCollectionRuleOperatorSpec) error
	AssignPropertiesTo(dst *v20240311s.DataCollectionRuleOperatorSpec) error
}

type augmentConversionForDataFlow interface {
	AssignPropertiesFrom(src *v20240311s.DataFlow) error
	AssignPropertiesTo(dst *v20240311s.DataFlow) error
}

type augmentConversionForDataFlow_STATUS interface {
	AssignPropertiesFrom(src *v20240311s.DataFlow_STATUS) error
	AssignPropertiesTo(dst *v20240311s.DataFlow_STATUS) error
}

type augmentConversionForDataSourcesSpec interface {
	AssignPropertiesFrom(src *v20240311s.DataSourcesSpec) error
	AssignPropertiesTo(dst *v20240311s.DataSourcesSpec) error
}

type augmentConversionForDataSourcesSpec_STATUS interface {
	AssignPropertiesFrom(src *v20240311s.DataSourcesSpec_STATUS) error
	AssignPropertiesTo(dst *v20240311s.DataSourcesSpec_STATUS) error
}

type augmentConversionForDestinationsSpec interface {
	AssignPropertiesFrom(src *v20240311s.DestinationsSpec) error
	AssignPropertiesTo(dst *v20240311s.DestinationsSpec) error
}

type augmentConversionForDestinationsSpec_STATUS interface {
	AssignPropertiesFrom(src *v20240311s.DestinationsSpec_STATUS) error
	AssignPropertiesTo(dst *v20240311s.DestinationsSpec_STATUS) error
}

type augmentConversionForEndpointsSpec_STATUS interface {
	AssignPropertiesFrom(src *v20240311s.EndpointsSpec_STATUS) error
	AssignPropertiesTo(dst *v20240311s.EndpointsSpec_STATUS) error
}

type augmentConversionForReferencesSpec interface {
	AssignPropertiesFrom(src *v20240311s.ReferencesSpec) error
	AssignPropertiesTo(dst *v20240311s.ReferencesSpec) error
}

type augmentConversionForReferencesSpec_STATUS interface {
	AssignPropertiesFrom(src *v20240311s.ReferencesSpec_STATUS) error
	AssignPropertiesTo(dst *v20240311s.ReferencesSpec_STATUS) error
}

type augmentConversionForStreamDeclaration interface {
	AssignPropertiesFrom(src *v20240311s.StreamDeclaration) error
	AssignPropertiesTo(dst *v20240311s.StreamDeclaration) error
}

type augmentConversionForStreamDeclaration_STATUS interface {
	AssignPropertiesFrom(src *v20240311s.StreamDeclaration_STATUS) error
	AssignPropertiesTo(dst *v20240311s.StreamDeclaration_STATUS) error
}

// Storage version of v1api20230311.AzureMonitorMetricsDestination
// Azure Monitor Metrics destination.
type AzureMonitorMetricsDestination struct {
	Name        *string                `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_AzureMonitorMetricsDestination populates our AzureMonitorMetricsDestination from the provided source AzureMonitorMetricsDestination
func (destination *AzureMonitorMetricsDestination) AssignProperties_From_AzureMonitorMetricsDestination(source *v20240311s.AzureMonitorMetricsDestination) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAzureMonitorMetricsDestination interface (if implemented) to customize the conversion
	var destinationAsAny any = destination
	if augmentedDestination, ok := destinationAsAny.(augmentConversionForAzureMonitorMetricsDestination); ok {
		err := augmentedDestination.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AzureMonitorMetricsDestination populates the provided destination AzureMonitorMetricsDestination from our AzureMonitorMetricsDestination
func (destination *AzureMonitorMetricsDestination) AssignProperties_To_AzureMonitorMetricsDestination(target *v20240311s.AzureMonitorMetricsDestination) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(destination.PropertyBag)

	// Name
	target.Name = genruntime.ClonePointerToString(destination.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		target.PropertyBag = propertyBag
	} else {
		target.PropertyBag = nil
	}

	// Invoke the augmentConversionForAzureMonitorMetricsDestination interface (if implemented) to customize the conversion
	var destinationAsAny any = destination
	if augmentedDestination, ok := destinationAsAny.(augmentConversionForAzureMonitorMetricsDestination); ok {
		err := augmentedDestination.AssignPropertiesTo(target)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.AzureMonitorMetricsDestination_STATUS
// Azure Monitor Metrics destination.
type AzureMonitorMetricsDestination_STATUS struct {
	Name        *string                `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_AzureMonitorMetricsDestination_STATUS populates our AzureMonitorMetricsDestination_STATUS from the provided source AzureMonitorMetricsDestination_STATUS
func (destination *AzureMonitorMetricsDestination_STATUS) AssignProperties_From_AzureMonitorMetricsDestination_STATUS(source *v20240311s.AzureMonitorMetricsDestination_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAzureMonitorMetricsDestination_STATUS interface (if implemented) to customize the conversion
	var destinationAsAny any = destination
	if augmentedDestination, ok := destinationAsAny.(augmentConversionForAzureMonitorMetricsDestination_STATUS); ok {
		err := augmentedDestination.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AzureMonitorMetricsDestination_STATUS populates the provided destination AzureMonitorMetricsDestination_STATUS from our AzureMonitorMetricsDestination_STATUS
func (destination *AzureMonitorMetricsDestination_STATUS) AssignProperties_To_AzureMonitorMetricsDestination_STATUS(target *v20240311s.AzureMonitorMetricsDestination_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(destination.PropertyBag)

	// Name
	target.Name = genruntime.ClonePointerToString(destination.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		target.PropertyBag = propertyBag
	} else {
		target.PropertyBag = nil
	}

	// Invoke the augmentConversionForAzureMonitorMetricsDestination_STATUS interface (if implemented) to customize the conversion
	var destinationAsAny any = destination
	if augmentedDestination, ok := destinationAsAny.(augmentConversionForAzureMonitorMetricsDestination_STATUS); ok {
		err := augmentedDestination.AssignPropertiesTo(target)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.ColumnDefinition
// Definition of custom data column.
type ColumnDefinition struct {
	Name        *string                `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Type        *string                `json:"type,omitempty"`
}

// AssignProperties_From_ColumnDefinition populates our ColumnDefinition from the provided source ColumnDefinition
func (definition *ColumnDefinition) AssignProperties_From_ColumnDefinition(source *v20240311s.ColumnDefinition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	definition.Name = genruntime.ClonePointerToString(source.Name)

	// Type
	definition.Type = genruntime.ClonePointerToString(source.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		definition.PropertyBag = propertyBag
	} else {
		definition.PropertyBag = nil
	}

	// Invoke the augmentConversionForColumnDefinition interface (if implemented) to customize the conversion
	var definitionAsAny any = definition
	if augmentedDefinition, ok := definitionAsAny.(augmentConversionForColumnDefinition); ok {
		err := augmentedDefinition.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ColumnDefinition populates the provided destination ColumnDefinition from our ColumnDefinition
func (definition *ColumnDefinition) AssignProperties_To_ColumnDefinition(destination *v20240311s.ColumnDefinition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(definition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(definition.Name)

	// Type
	destination.Type = genruntime.ClonePointerToString(definition.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForColumnDefinition interface (if implemented) to customize the conversion
	var definitionAsAny any = definition
	if augmentedDefinition, ok := definitionAsAny.(augmentConversionForColumnDefinition); ok {
		err := augmentedDefinition.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.ColumnDefinition_STATUS
// Definition of custom data column.
type ColumnDefinition_STATUS struct {
	Name        *string                `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Type        *string                `json:"type,omitempty"`
}

// AssignProperties_From_ColumnDefinition_STATUS populates our ColumnDefinition_STATUS from the provided source ColumnDefinition_STATUS
func (definition *ColumnDefinition_STATUS) AssignProperties_From_ColumnDefinition_STATUS(source *v20240311s.ColumnDefinition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	definition.Name = genruntime.ClonePointerToString(source.Name)

	// Type
	definition.Type = genruntime.ClonePointerToString(source.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		definition.PropertyBag = propertyBag
	} else {
		definition.PropertyBag = nil
	}

	// Invoke the augmentConversionForColumnDefinition_STATUS interface (if implemented) to customize the conversion
	var definitionAsAny any = definition
	if augmentedDefinition, ok := definitionAsAny.(augmentConversionForColumnDefinition_STATUS); ok {
		err := augmentedDefinition.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ColumnDefinition_STATUS populates the provided destination ColumnDefinition_STATUS from our ColumnDefinition_STATUS
func (definition *ColumnDefinition_STATUS) AssignProperties_To_ColumnDefinition_STATUS(destination *v20240311s.ColumnDefinition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(definition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(definition.Name)

	// Type
	destination.Type = genruntime.ClonePointerToString(definition.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForColumnDefinition_STATUS interface (if implemented) to customize the conversion
	var definitionAsAny any = definition
	if augmentedDefinition, ok := definitionAsAny.(augmentConversionForColumnDefinition_STATUS); ok {
		err := augmentedDefinition.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.DataImportSources
type DataImportSources struct {
	EventHub    *EventHubDataSource    `json:"eventHub,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DataImportSources populates our DataImportSources from the provided source DataImportSources
func (sources *DataImportSources) AssignProperties_From_DataImportSources(source *v20240311s.DataImportSources) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// EventHub
	if source.EventHub != nil {
		var eventHub EventHubDataSource
		err := eventHub.AssignProperties_From_EventHubDataSource(source.EventHub)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_EventHubDataSource() to populate field EventHub")
		}
		sources.EventHub = &eventHub
	} else {
		sources.EventHub = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		sources.PropertyBag = propertyBag
	} else {
		sources.PropertyBag = nil
	}

	// Invoke the augmentConversionForDataImportSources interface (if implemented) to customize the conversion
	var sourcesAsAny any = sources
	if augmentedSources, ok := sourcesAsAny.(augmentConversionForDataImportSources); ok {
		err := augmentedSources.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DataImportSources populates the provided destination DataImportSources from our DataImportSources
func (sources *DataImportSources) AssignProperties_To_DataImportSources(destination *v20240311s.DataImportSources) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(sources.PropertyBag)

	// EventHub
	if sources.EventHub != nil {
		var eventHub v20240311s.EventHubDataSource
		err := sources.EventHub.AssignProperties_To_EventHubDataSource(&eventHub)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_EventHubDataSource() to populate field EventHub")
		}
		destination.EventHub = &eventHub
	} else {
		destination.EventHub = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDataImportSources interface (if implemented) to customize the conversion
	var sourcesAsAny any = sources
	if augmentedSources, ok := sourcesAsAny.(augmentConversionForDataImportSources); ok {
		err := augmentedSources.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.DataImportSources_STATUS
type DataImportSources_STATUS struct {
	EventHub    *EventHubDataSource_STATUS `json:"eventHub,omitempty"`
	PropertyBag genruntime.PropertyBag     `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DataImportSources_STATUS populates our DataImportSources_STATUS from the provided source DataImportSources_STATUS
func (sources *DataImportSources_STATUS) AssignProperties_From_DataImportSources_STATUS(source *v20240311s.DataImportSources_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// EventHub
	if source.EventHub != nil {
		var eventHub EventHubDataSource_STATUS
		err := eventHub.AssignProperties_From_EventHubDataSource_STATUS(source.EventHub)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_EventHubDataSource_STATUS() to populate field EventHub")
		}
		sources.EventHub = &eventHub
	} else {
		sources.EventHub = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		sources.PropertyBag = propertyBag
	} else {
		sources.PropertyBag = nil
	}

	// Invoke the augmentConversionForDataImportSources_STATUS interface (if implemented) to customize the conversion
	var sourcesAsAny any = sources
	if augmentedSources, ok := sourcesAsAny.(augmentConversionForDataImportSources_STATUS); ok {
		err := augmentedSources.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DataImportSources_STATUS populates the provided destination DataImportSources_STATUS from our DataImportSources_STATUS
func (sources *DataImportSources_STATUS) AssignProperties_To_DataImportSources_STATUS(destination *v20240311s.DataImportSources_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(sources.PropertyBag)

	// EventHub
	if sources.EventHub != nil {
		var eventHub v20240311s.EventHubDataSource_STATUS
		err := sources.EventHub.AssignProperties_To_EventHubDataSource_STATUS(&eventHub)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_EventHubDataSource_STATUS() to populate field EventHub")
		}
		destination.EventHub = &eventHub
	} else {
		destination.EventHub = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDataImportSources_STATUS interface (if implemented) to customize the conversion
	var sourcesAsAny any = sources
	if augmentedSources, ok := sourcesAsAny.(augmentConversionForDataImportSources_STATUS); ok {
		err := augmentedSources.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.EnrichmentData
// All the enrichment data sources referenced in data flows
type EnrichmentData struct {
	PropertyBag  genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	StorageBlobs []StorageBlob          `json:"storageBlobs,omitempty"`
}

// AssignProperties_From_EnrichmentData populates our EnrichmentData from the provided source EnrichmentData
func (data *EnrichmentData) AssignProperties_From_EnrichmentData(source *v20240311s.EnrichmentData) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// StorageBlobs
	if source.StorageBlobs != nil {
		storageBlobList := make([]StorageBlob, len(source.StorageBlobs))
		for storageBlobIndex, storageBlobItem := range source.StorageBlobs {
			var storageBlob StorageBlob
			err := storageBlob.AssignProperties_From_StorageBlob(&storageBlobItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_StorageBlob() to populate field StorageBlobs")
			}
			storageBlobList[storageBlobIndex] = storageBlob
		}
		data.StorageBlobs = storageBlobList
	} else {
		data.StorageBlobs = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		data.PropertyBag = propertyBag
	} else {
		data.PropertyBag = nil
	}

	// Invoke the augmentConversionForEnrichmentData interface (if implemented) to customize the conversion
	var dataAsAny any = data
	if augmentedData, ok := dataAsAny.(augmentConversionForEnrichmentData); ok {
		err := augmentedData.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_EnrichmentData populates the provided destination EnrichmentData from our EnrichmentData
func (data *EnrichmentData) AssignProperties_To_EnrichmentData(destination *v20240311s.EnrichmentData) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(data.PropertyBag)

	// StorageBlobs
	if data.StorageBlobs != nil {
		storageBlobList := make([]v20240311s.StorageBlob, len(data.StorageBlobs))
		for storageBlobIndex, storageBlobItem := range data.StorageBlobs {
			var storageBlob v20240311s.StorageBlob
			err := storageBlobItem.AssignProperties_To_StorageBlob(&storageBlob)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_StorageBlob() to populate field StorageBlobs")
			}
			storageBlobList[storageBlobIndex] = storageBlob
		}
		destination.StorageBlobs = storageBlobList
	} else {
		destination.StorageBlobs = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForEnrichmentData interface (if implemented) to customize the conversion
	var dataAsAny any = data
	if augmentedData, ok := dataAsAny.(augmentConversionForEnrichmentData); ok {
		err := augmentedData.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.EnrichmentData_STATUS
// All the enrichment data sources referenced in data flows
type EnrichmentData_STATUS struct {
	PropertyBag  genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	StorageBlobs []StorageBlob_STATUS   `json:"storageBlobs,omitempty"`
}

// AssignProperties_From_EnrichmentData_STATUS populates our EnrichmentData_STATUS from the provided source EnrichmentData_STATUS
func (data *EnrichmentData_STATUS) AssignProperties_From_EnrichmentData_STATUS(source *v20240311s.EnrichmentData_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// StorageBlobs
	if source.StorageBlobs != nil {
		storageBlobList := make([]StorageBlob_STATUS, len(source.StorageBlobs))
		for storageBlobIndex, storageBlobItem := range source.StorageBlobs {
			var storageBlob StorageBlob_STATUS
			err := storageBlob.AssignProperties_From_StorageBlob_STATUS(&storageBlobItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_StorageBlob_STATUS() to populate field StorageBlobs")
			}
			storageBlobList[storageBlobIndex] = storageBlob
		}
		data.StorageBlobs = storageBlobList
	} else {
		data.StorageBlobs = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		data.PropertyBag = propertyBag
	} else {
		data.PropertyBag = nil
	}

	// Invoke the augmentConversionForEnrichmentData_STATUS interface (if implemented) to customize the conversion
	var dataAsAny any = data
	if augmentedData, ok := dataAsAny.(augmentConversionForEnrichmentData_STATUS); ok {
		err := augmentedData.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_EnrichmentData_STATUS populates the provided destination EnrichmentData_STATUS from our EnrichmentData_STATUS
func (data *EnrichmentData_STATUS) AssignProperties_To_EnrichmentData_STATUS(destination *v20240311s.EnrichmentData_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(data.PropertyBag)

	// StorageBlobs
	if data.StorageBlobs != nil {
		storageBlobList := make([]v20240311s.StorageBlob_STATUS, len(data.StorageBlobs))
		for storageBlobIndex, storageBlobItem := range data.StorageBlobs {
			var storageBlob v20240311s.StorageBlob_STATUS
			err := storageBlobItem.AssignProperties_To_StorageBlob_STATUS(&storageBlob)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_StorageBlob_STATUS() to populate field StorageBlobs")
			}
			storageBlobList[storageBlobIndex] = storageBlob
		}
		destination.StorageBlobs = storageBlobList
	} else {
		destination.StorageBlobs = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForEnrichmentData_STATUS interface (if implemented) to customize the conversion
	var dataAsAny any = data
	if augmentedData, ok := dataAsAny.(augmentConversionForEnrichmentData_STATUS); ok {
		err := augmentedData.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.EventHubDestination
type EventHubDestination struct {
	// EventHubResourceReference: The resource ID of the event hub.
	EventHubResourceReference *genruntime.ResourceReference `armReference:"EventHubResourceId" json:"eventHubResourceReference,omitempty"`
	Name                      *string                       `json:"name,omitempty"`
	PropertyBag               genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_EventHubDestination populates our EventHubDestination from the provided source EventHubDestination
func (destination *EventHubDestination) AssignProperties_From_EventHubDestination(source *v20240311s.EventHubDestination) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// EventHubResourceReference
	if source.EventHubResourceReference != nil {
		eventHubResourceReference := source.EventHubResourceReference.Copy()
		destination.EventHubResourceReference = &eventHubResourceReference
	} else {
		destination.EventHubResourceReference = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForEventHubDestination interface (if implemented) to customize the conversion
	var destinationAsAny any = destination
	if augmentedDestination, ok := destinationAsAny.(augmentConversionForEventHubDestination); ok {
		err := augmentedDestination.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_EventHubDestination populates the provided destination EventHubDestination from our EventHubDestination
func (destination *EventHubDestination) AssignProperties_To_EventHubDestination(target *v20240311s.EventHubDestination) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(destination.PropertyBag)

	// EventHubResourceReference
	if destination.EventHubResourceReference != nil {
		eventHubResourceReference := destination.EventHubResourceReference.Copy()
		target.EventHubResourceReference = &eventHubResourceReference
	} else {
		target.EventHubResourceReference = nil
	}

	// Name
	target.Name = genruntime.ClonePointerToString(destination.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		target.PropertyBag = propertyBag
	} else {
		target.PropertyBag = nil
	}

	// Invoke the augmentConversionForEventHubDestination interface (if implemented) to customize the conversion
	var destinationAsAny any = destination
	if augmentedDestination, ok := destinationAsAny.(augmentConversionForEventHubDestination); ok {
		err := augmentedDestination.AssignPropertiesTo(target)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.EventHubDestination_STATUS
type EventHubDestination_STATUS struct {
	EventHubResourceId *string                `json:"eventHubResourceId,omitempty"`
	Name               *string                `json:"name,omitempty"`
	PropertyBag        genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_EventHubDestination_STATUS populates our EventHubDestination_STATUS from the provided source EventHubDestination_STATUS
func (destination *EventHubDestination_STATUS) AssignProperties_From_EventHubDestination_STATUS(source *v20240311s.EventHubDestination_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// EventHubResourceId
	destination.EventHubResourceId = genruntime.ClonePointerToString(source.EventHubResourceId)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForEventHubDestination_STATUS interface (if implemented) to customize the conversion
	var destinationAsAny any = destination
	if augmentedDestination, ok := destinationAsAny.(augmentConversionForEventHubDestination_STATUS); ok {
		err := augmentedDestination.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_EventHubDestination_STATUS populates the provided destination EventHubDestination_STATUS from our EventHubDestination_STATUS
func (destination *EventHubDestination_STATUS) AssignProperties_To_EventHubDestination_STATUS(target *v20240311s.EventHubDestination_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(destination.PropertyBag)

	// EventHubResourceId
	target.EventHubResourceId = genruntime.ClonePointerToString(destination.EventHubResourceId)

	// Name
	target.Name = genruntime.ClonePointerToString(destination.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		target.PropertyBag = propertyBag
	} else {
		target.PropertyBag = nil
	}

	// Invoke the augmentConversionForEventHubDestination_STATUS interface (if implemented) to customize the conversion
	var destinationAsAny any = destination
	if augmentedDestination, ok := destinationAsAny.(augmentConversionForEventHubDestination_STATUS); ok {
		err := augmentedDestination.AssignPropertiesTo(target)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.EventHubDirectDestination
type EventHubDirectDestination struct {
	// EventHubResourceReference: The resource ID of the event hub.
	EventHubResourceReference *genruntime.ResourceReference `armReference:"EventHubResourceId" json:"eventHubResourceReference,omitempty"`
	Name                      *string                       `json:"name,omitempty"`
	PropertyBag               genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_EventHubDirectDestination populates our EventHubDirectDestination from the provided source EventHubDirectDestination
func (destination *EventHubDirectDestination) AssignProperties_From_EventHubDirectDestination(source *v20240311s.EventHubDirectDestination) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// EventHubResourceReference
	if source.EventHubResourceReference != nil {
		eventHubResourceReference := source.EventHubResourceReference.Copy()
		destination.EventHubResourceReference = &eventHubResourceReference
	} else {
		destination.EventHubResourceReference = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForEventHubDirectDestination interface (if implemented) to customize the conversion
	var destinationAsAny any = destination
	if augmentedDestination, ok := destinationAsAny.(augmentConversionForEventHubDirectDestination); ok {
		err := augmentedDestination.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_EventHubDirectDestination populates the provided destination EventHubDirectDestination from our EventHubDirectDestination
func (destination *EventHubDirectDestination) AssignProperties_To_EventHubDirectDestination(target *v20240311s.EventHubDirectDestination) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(destination.PropertyBag)

	// EventHubResourceReference
	if destination.EventHubResourceReference != nil {
		eventHubResourceReference := destination.EventHubResourceReference.Copy()
		target.EventHubResourceReference = &eventHubResourceReference
	} else {
		target.EventHubResourceReference = nil
	}

	// Name
	target.Name = genruntime.ClonePointerToString(destination.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		target.PropertyBag = propertyBag
	} else {
		target.PropertyBag = nil
	}

	// Invoke the augmentConversionForEventHubDirectDestination interface (if implemented) to customize the conversion
	var destinationAsAny any = destination
	if augmentedDestination, ok := destinationAsAny.(augmentConversionForEventHubDirectDestination); ok {
		err := augmentedDestination.AssignPropertiesTo(target)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.EventHubDirectDestination_STATUS
type EventHubDirectDestination_STATUS struct {
	EventHubResourceId *string                `json:"eventHubResourceId,omitempty"`
	Name               *string                `json:"name,omitempty"`
	PropertyBag        genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_EventHubDirectDestination_STATUS populates our EventHubDirectDestination_STATUS from the provided source EventHubDirectDestination_STATUS
func (destination *EventHubDirectDestination_STATUS) AssignProperties_From_EventHubDirectDestination_STATUS(source *v20240311s.EventHubDirectDestination_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// EventHubResourceId
	destination.EventHubResourceId = genruntime.ClonePointerToString(source.EventHubResourceId)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForEventHubDirectDestination_STATUS interface (if implemented) to customize the conversion
	var destinationAsAny any = destination
	if augmentedDestination, ok := destinationAsAny.(augmentConversionForEventHubDirectDestination_STATUS); ok {
		err := augmentedDestination.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_EventHubDirectDestination_STATUS populates the provided destination EventHubDirectDestination_STATUS from our EventHubDirectDestination_STATUS
func (destination *EventHubDirectDestination_STATUS) AssignProperties_To_EventHubDirectDestination_STATUS(target *v20240311s.EventHubDirectDestination_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(destination.PropertyBag)

	// EventHubResourceId
	target.EventHubResourceId = genruntime.ClonePointerToString(destination.EventHubResourceId)

	// Name
	target.Name = genruntime.ClonePointerToString(destination.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		target.PropertyBag = propertyBag
	} else {
		target.PropertyBag = nil
	}

	// Invoke the augmentConversionForEventHubDirectDestination_STATUS interface (if implemented) to customize the conversion
	var destinationAsAny any = destination
	if augmentedDestination, ok := destinationAsAny.(augmentConversionForEventHubDirectDestination_STATUS); ok {
		err := augmentedDestination.AssignPropertiesTo(target)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.ExtensionDataSource
// Definition of which data will be collected from a separate VM extension that integrates with the Azure Monitor
// Agent.
// Collected from either Windows and Linux machines, depending on which extension is defined.
type ExtensionDataSource struct {
	ExtensionName     *string                `json:"extensionName,omitempty"`
	ExtensionSettings map[string]v1.JSON     `json:"extensionSettings,omitempty"`
	InputDataSources  []string               `json:"inputDataSources,omitempty"`
	Name              *string                `json:"name,omitempty"`
	PropertyBag       genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Streams           []string               `json:"streams,omitempty"`
}

// AssignProperties_From_ExtensionDataSource populates our ExtensionDataSource from the provided source ExtensionDataSource
func (source *ExtensionDataSource) AssignProperties_From_ExtensionDataSource(origin *v20240311s.ExtensionDataSource) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(origin.PropertyBag)

	// ExtensionName
	source.ExtensionName = genruntime.ClonePointerToString(origin.ExtensionName)

	// ExtensionSettings
	if origin.ExtensionSettings != nil {
		extensionSettingMap := make(map[string]v1.JSON, len(origin.ExtensionSettings))
		for extensionSettingKey, extensionSettingValue := range origin.ExtensionSettings {
			extensionSettingMap[extensionSettingKey] = *extensionSettingValue.DeepCopy()
		}
		source.ExtensionSettings = extensionSettingMap
	} else {
		source.ExtensionSettings = nil
	}

	// InputDataSources
	source.InputDataSources = genruntime.CloneSliceOfString(origin.InputDataSources)

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// Streams
	source.Streams = genruntime.CloneSliceOfString(origin.Streams)

	// Update the property bag
	if len(propertyBag) > 0 {
		source.PropertyBag = propertyBag
	} else {
		source.PropertyBag = nil
	}

	// Invoke the augmentConversionForExtensionDataSource interface (if implemented) to customize the conversion
	var sourceAsAny any = source
	if augmentedSource, ok := sourceAsAny.(augmentConversionForExtensionDataSource); ok {
		err := augmentedSource.AssignPropertiesFrom(origin)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ExtensionDataSource populates the provided destination ExtensionDataSource from our ExtensionDataSource
func (source *ExtensionDataSource) AssignProperties_To_ExtensionDataSource(destination *v20240311s.ExtensionDataSource) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ExtensionName
	destination.ExtensionName = genruntime.ClonePointerToString(source.ExtensionName)

	// ExtensionSettings
	if source.ExtensionSettings != nil {
		extensionSettingMap := make(map[string]v1.JSON, len(source.ExtensionSettings))
		for extensionSettingKey, extensionSettingValue := range source.ExtensionSettings {
			extensionSettingMap[extensionSettingKey] = *extensionSettingValue.DeepCopy()
		}
		destination.ExtensionSettings = extensionSettingMap
	} else {
		destination.ExtensionSettings = nil
	}

	// InputDataSources
	destination.InputDataSources = genruntime.CloneSliceOfString(source.InputDataSources)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// Streams
	destination.Streams = genruntime.CloneSliceOfString(source.Streams)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForExtensionDataSource interface (if implemented) to customize the conversion
	var sourceAsAny any = source
	if augmentedSource, ok := sourceAsAny.(augmentConversionForExtensionDataSource); ok {
		err := augmentedSource.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.ExtensionDataSource_STATUS
// Definition of which data will be collected from a separate VM extension that integrates with the Azure Monitor
// Agent.
// Collected from either Windows and Linux machines, depending on which extension is defined.
type ExtensionDataSource_STATUS struct {
	ExtensionName     *string                `json:"extensionName,omitempty"`
	ExtensionSettings map[string]v1.JSON     `json:"extensionSettings,omitempty"`
	InputDataSources  []string               `json:"inputDataSources,omitempty"`
	Name              *string                `json:"name,omitempty"`
	PropertyBag       genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Streams           []string               `json:"streams,omitempty"`
}

// AssignProperties_From_ExtensionDataSource_STATUS populates our ExtensionDataSource_STATUS from the provided source ExtensionDataSource_STATUS
func (source *ExtensionDataSource_STATUS) AssignProperties_From_ExtensionDataSource_STATUS(origin *v20240311s.ExtensionDataSource_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(origin.PropertyBag)

	// ExtensionName
	source.ExtensionName = genruntime.ClonePointerToString(origin.ExtensionName)

	// ExtensionSettings
	if origin.ExtensionSettings != nil {
		extensionSettingMap := make(map[string]v1.JSON, len(origin.ExtensionSettings))
		for extensionSettingKey, extensionSettingValue := range origin.ExtensionSettings {
			extensionSettingMap[extensionSettingKey] = *extensionSettingValue.DeepCopy()
		}
		source.ExtensionSettings = extensionSettingMap
	} else {
		source.ExtensionSettings = nil
	}

	// InputDataSources
	source.InputDataSources = genruntime.CloneSliceOfString(origin.InputDataSources)

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// Streams
	source.Streams = genruntime.CloneSliceOfString(origin.Streams)

	// Update the property bag
	if len(propertyBag) > 0 {
		source.PropertyBag = propertyBag
	} else {
		source.PropertyBag = nil
	}

	// Invoke the augmentConversionForExtensionDataSource_STATUS interface (if implemented) to customize the conversion
	var sourceAsAny any = source
	if augmentedSource, ok := sourceAsAny.(augmentConversionForExtensionDataSource_STATUS); ok {
		err := augmentedSource.AssignPropertiesFrom(origin)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ExtensionDataSource_STATUS populates the provided destination ExtensionDataSource_STATUS from our ExtensionDataSource_STATUS
func (source *ExtensionDataSource_STATUS) AssignProperties_To_ExtensionDataSource_STATUS(destination *v20240311s.ExtensionDataSource_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ExtensionName
	destination.ExtensionName = genruntime.ClonePointerToString(source.ExtensionName)

	// ExtensionSettings
	if source.ExtensionSettings != nil {
		extensionSettingMap := make(map[string]v1.JSON, len(source.ExtensionSettings))
		for extensionSettingKey, extensionSettingValue := range source.ExtensionSettings {
			extensionSettingMap[extensionSettingKey] = *extensionSettingValue.DeepCopy()
		}
		destination.ExtensionSettings = extensionSettingMap
	} else {
		destination.ExtensionSettings = nil
	}

	// InputDataSources
	destination.InputDataSources = genruntime.CloneSliceOfString(source.InputDataSources)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// Streams
	destination.Streams = genruntime.CloneSliceOfString(source.Streams)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForExtensionDataSource_STATUS interface (if implemented) to customize the conversion
	var sourceAsAny any = source
	if augmentedSource, ok := sourceAsAny.(augmentConversionForExtensionDataSource_STATUS); ok {
		err := augmentedSource.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.IisLogsDataSource
// Enables IIS logs to be collected by this data collection rule.
type IisLogsDataSource struct {
	LogDirectories []string               `json:"logDirectories,omitempty"`
	Name           *string                `json:"name,omitempty"`
	PropertyBag    genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Streams        []string               `json:"streams,omitempty"`
	TransformKql   *string                `json:"transformKql,omitempty"`
}

// AssignProperties_From_IisLogsDataSource populates our IisLogsDataSource from the provided source IisLogsDataSource
func (source *IisLogsDataSource) AssignProperties_From_IisLogsDataSource(origin *v20240311s.IisLogsDataSource) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(origin.PropertyBag)

	// LogDirectories
	source.LogDirectories = genruntime.CloneSliceOfString(origin.LogDirectories)

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// Streams
	source.Streams = genruntime.CloneSliceOfString(origin.Streams)

	// TransformKql
	source.TransformKql = genruntime.ClonePointerToString(origin.TransformKql)

	// Update the property bag
	if len(propertyBag) > 0 {
		source.PropertyBag = propertyBag
	} else {
		source.PropertyBag = nil
	}

	// Invoke the augmentConversionForIisLogsDataSource interface (if implemented) to customize the conversion
	var sourceAsAny any = source
	if augmentedSource, ok := sourceAsAny.(augmentConversionForIisLogsDataSource); ok {
		err := augmentedSource.AssignPropertiesFrom(origin)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_IisLogsDataSource populates the provided destination IisLogsDataSource from our IisLogsDataSource
func (source *IisLogsDataSource) AssignProperties_To_IisLogsDataSource(destination *v20240311s.IisLogsDataSource) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// LogDirectories
	destination.LogDirectories = genruntime.CloneSliceOfString(source.LogDirectories)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// Streams
	destination.Streams = genruntime.CloneSliceOfString(source.Streams)

	// TransformKql
	destination.TransformKql = genruntime.ClonePointerToString(source.TransformKql)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForIisLogsDataSource interface (if implemented) to customize the conversion
	var sourceAsAny any = source
	if augmentedSource, ok := sourceAsAny.(augmentConversionForIisLogsDataSource); ok {
		err := augmentedSource.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.IisLogsDataSource_STATUS
// Enables IIS logs to be collected by this data collection rule.
type IisLogsDataSource_STATUS struct {
	LogDirectories []string               `json:"logDirectories,omitempty"`
	Name           *string                `json:"name,omitempty"`
	PropertyBag    genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Streams        []string               `json:"streams,omitempty"`
	TransformKql   *string                `json:"transformKql,omitempty"`
}

// AssignProperties_From_IisLogsDataSource_STATUS populates our IisLogsDataSource_STATUS from the provided source IisLogsDataSource_STATUS
func (source *IisLogsDataSource_STATUS) AssignProperties_From_IisLogsDataSource_STATUS(origin *v20240311s.IisLogsDataSource_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(origin.PropertyBag)

	// LogDirectories
	source.LogDirectories = genruntime.CloneSliceOfString(origin.LogDirectories)

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// Streams
	source.Streams = genruntime.CloneSliceOfString(origin.Streams)

	// TransformKql
	source.TransformKql = genruntime.ClonePointerToString(origin.TransformKql)

	// Update the property bag
	if len(propertyBag) > 0 {
		source.PropertyBag = propertyBag
	} else {
		source.PropertyBag = nil
	}

	// Invoke the augmentConversionForIisLogsDataSource_STATUS interface (if implemented) to customize the conversion
	var sourceAsAny any = source
	if augmentedSource, ok := sourceAsAny.(augmentConversionForIisLogsDataSource_STATUS); ok {
		err := augmentedSource.AssignPropertiesFrom(origin)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_IisLogsDataSource_STATUS populates the provided destination IisLogsDataSource_STATUS from our IisLogsDataSource_STATUS
func (source *IisLogsDataSource_STATUS) AssignProperties_To_IisLogsDataSource_STATUS(destination *v20240311s.IisLogsDataSource_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// LogDirectories
	destination.LogDirectories = genruntime.CloneSliceOfString(source.LogDirectories)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// Streams
	destination.Streams = genruntime.CloneSliceOfString(source.Streams)

	// TransformKql
	destination.TransformKql = genruntime.ClonePointerToString(source.TransformKql)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForIisLogsDataSource_STATUS interface (if implemented) to customize the conversion
	var sourceAsAny any = source
	if augmentedSource, ok := sourceAsAny.(augmentConversionForIisLogsDataSource_STATUS); ok {
		err := augmentedSource.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.LogAnalyticsDestination
// Log Analytics destination.
type LogAnalyticsDestination struct {
	Name        *string                `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`

	// WorkspaceResourceReference: The resource ID of the Log Analytics workspace.
	WorkspaceResourceReference *genruntime.ResourceReference `armReference:"WorkspaceResourceId" json:"workspaceResourceReference,omitempty"`
}

// AssignProperties_From_LogAnalyticsDestination populates our LogAnalyticsDestination from the provided source LogAnalyticsDestination
func (destination *LogAnalyticsDestination) AssignProperties_From_LogAnalyticsDestination(source *v20240311s.LogAnalyticsDestination) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// WorkspaceResourceReference
	if source.WorkspaceResourceReference != nil {
		workspaceResourceReference := source.WorkspaceResourceReference.Copy()
		destination.WorkspaceResourceReference = &workspaceResourceReference
	} else {
		destination.WorkspaceResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForLogAnalyticsDestination interface (if implemented) to customize the conversion
	var destinationAsAny any = destination
	if augmentedDestination, ok := destinationAsAny.(augmentConversionForLogAnalyticsDestination); ok {
		err := augmentedDestination.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_LogAnalyticsDestination populates the provided destination LogAnalyticsDestination from our LogAnalyticsDestination
func (destination *LogAnalyticsDestination) AssignProperties_To_LogAnalyticsDestination(target *v20240311s.LogAnalyticsDestination) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(destination.PropertyBag)

	// Name
	target.Name = genruntime.ClonePointerToString(destination.Name)

	// WorkspaceResourceReference
	if destination.WorkspaceResourceReference != nil {
		workspaceResourceReference := destination.WorkspaceResourceReference.Copy()
		target.WorkspaceResourceReference = &workspaceResourceReference
	} else {
		target.WorkspaceResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		target.PropertyBag = propertyBag
	} else {
		target.PropertyBag = nil
	}

	// Invoke the augmentConversionForLogAnalyticsDestination interface (if implemented) to customize the conversion
	var destinationAsAny any = destination
	if augmentedDestination, ok := destinationAsAny.(augmentConversionForLogAnalyticsDestination); ok {
		err := augmentedDestination.AssignPropertiesTo(target)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.LogAnalyticsDestination_STATUS
// Log Analytics destination.
type LogAnalyticsDestination_STATUS struct {
	Name                *string                `json:"name,omitempty"`
	PropertyBag         genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	WorkspaceId         *string                `json:"workspaceId,omitempty"`
	WorkspaceResourceId *string                `json:"workspaceResourceId,omitempty"`
}

// AssignProperties_From_LogAnalyticsDestination_STATUS populates our LogAnalyticsDestination_STATUS from the provided source LogAnalyticsDestination_STATUS
func (destination *LogAnalyticsDestination_STATUS) AssignProperties_From_LogAnalyticsDestination_STATUS(source *v20240311s.LogAnalyticsDestination_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// WorkspaceId
	destination.WorkspaceId = genruntime.ClonePointerToString(source.WorkspaceId)

	// WorkspaceResourceId
	destination.WorkspaceResourceId = genruntime.ClonePointerToString(source.WorkspaceResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForLogAnalyticsDestination_STATUS interface (if implemented) to customize the conversion
	var destinationAsAny any = destination
	if augmentedDestination, ok := destinationAsAny.(augmentConversionForLogAnalyticsDestination_STATUS); ok {
		err := augmentedDestination.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_LogAnalyticsDestination_STATUS populates the provided destination LogAnalyticsDestination_STATUS from our LogAnalyticsDestination_STATUS
func (destination *LogAnalyticsDestination_STATUS) AssignProperties_To_LogAnalyticsDestination_STATUS(target *v20240311s.LogAnalyticsDestination_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(destination.PropertyBag)

	// Name
	target.Name = genruntime.ClonePointerToString(destination.Name)

	// WorkspaceId
	target.WorkspaceId = genruntime.ClonePointerToString(destination.WorkspaceId)

	// WorkspaceResourceId
	target.WorkspaceResourceId = genruntime.ClonePointerToString(destination.WorkspaceResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		target.PropertyBag = propertyBag
	} else {
		target.PropertyBag = nil
	}

	// Invoke the augmentConversionForLogAnalyticsDestination_STATUS interface (if implemented) to customize the conversion
	var destinationAsAny any = destination
	if augmentedDestination, ok := destinationAsAny.(augmentConversionForLogAnalyticsDestination_STATUS); ok {
		err := augmentedDestination.AssignPropertiesTo(target)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.LogFilesDataSource
// Definition of which custom log files will be collected by this data collection rule
type LogFilesDataSource struct {
	FilePatterns []string               `json:"filePatterns,omitempty"`
	Format       *string                `json:"format,omitempty"`
	Name         *string                `json:"name,omitempty"`
	PropertyBag  genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Settings     *LogFileSettings       `json:"settings,omitempty"`
	Streams      []string               `json:"streams,omitempty"`
	TransformKql *string                `json:"transformKql,omitempty"`
}

// AssignProperties_From_LogFilesDataSource populates our LogFilesDataSource from the provided source LogFilesDataSource
func (source *LogFilesDataSource) AssignProperties_From_LogFilesDataSource(origin *v20240311s.LogFilesDataSource) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(origin.PropertyBag)

	// FilePatterns
	source.FilePatterns = genruntime.CloneSliceOfString(origin.FilePatterns)

	// Format
	source.Format = genruntime.ClonePointerToString(origin.Format)

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// Settings
	if origin.Settings != nil {
		var setting LogFileSettings
		err := setting.AssignProperties_From_LogFileSettings(origin.Settings)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_LogFileSettings() to populate field Settings")
		}
		source.Settings = &setting
	} else {
		source.Settings = nil
	}

	// Streams
	source.Streams = genruntime.CloneSliceOfString(origin.Streams)

	// TransformKql
	source.TransformKql = genruntime.ClonePointerToString(origin.TransformKql)

	// Update the property bag
	if len(propertyBag) > 0 {
		source.PropertyBag = propertyBag
	} else {
		source.PropertyBag = nil
	}

	// Invoke the augmentConversionForLogFilesDataSource interface (if implemented) to customize the conversion
	var sourceAsAny any = source
	if augmentedSource, ok := sourceAsAny.(augmentConversionForLogFilesDataSource); ok {
		err := augmentedSource.AssignPropertiesFrom(origin)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_LogFilesDataSource populates the provided destination LogFilesDataSource from our LogFilesDataSource
func (source *LogFilesDataSource) AssignProperties_To_LogFilesDataSource(destination *v20240311s.LogFilesDataSource) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// FilePatterns
	destination.FilePatterns = genruntime.CloneSliceOfString(source.FilePatterns)

	// Format
	destination.Format = genruntime.ClonePointerToString(source.Format)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// Settings
	if source.Settings != nil {
		var setting v20240311s.LogFileSettings
		err := source.Settings.AssignProperties_To_LogFileSettings(&setting)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_LogFileSettings() to populate field Settings")
		}
		destination.Settings = &setting
	} else {
		destination.Settings = nil
	}

	// Streams
	destination.Streams = genruntime.CloneSliceOfString(source.Streams)

	// TransformKql
	destination.TransformKql = genruntime.ClonePointerToString(source.TransformKql)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForLogFilesDataSource interface (if implemented) to customize the conversion
	var sourceAsAny any = source
	if augmentedSource, ok := sourceAsAny.(augmentConversionForLogFilesDataSource); ok {
		err := augmentedSource.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.LogFilesDataSource_STATUS
// Definition of which custom log files will be collected by this data collection rule
type LogFilesDataSource_STATUS struct {
	FilePatterns []string                `json:"filePatterns,omitempty"`
	Format       *string                 `json:"format,omitempty"`
	Name         *string                 `json:"name,omitempty"`
	PropertyBag  genruntime.PropertyBag  `json:"$propertyBag,omitempty"`
	Settings     *LogFileSettings_STATUS `json:"settings,omitempty"`
	Streams      []string                `json:"streams,omitempty"`
	TransformKql *string                 `json:"transformKql,omitempty"`
}

// AssignProperties_From_LogFilesDataSource_STATUS populates our LogFilesDataSource_STATUS from the provided source LogFilesDataSource_STATUS
func (source *LogFilesDataSource_STATUS) AssignProperties_From_LogFilesDataSource_STATUS(origin *v20240311s.LogFilesDataSource_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(origin.PropertyBag)

	// FilePatterns
	source.FilePatterns = genruntime.CloneSliceOfString(origin.FilePatterns)

	// Format
	source.Format = genruntime.ClonePointerToString(origin.Format)

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// Settings
	if origin.Settings != nil {
		var setting LogFileSettings_STATUS
		err := setting.AssignProperties_From_LogFileSettings_STATUS(origin.Settings)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_LogFileSettings_STATUS() to populate field Settings")
		}
		source.Settings = &setting
	} else {
		source.Settings = nil
	}

	// Streams
	source.Streams = genruntime.CloneSliceOfString(origin.Streams)

	// TransformKql
	source.TransformKql = genruntime.ClonePointerToString(origin.TransformKql)

	// Update the property bag
	if len(propertyBag) > 0 {
		source.PropertyBag = propertyBag
	} else {
		source.PropertyBag = nil
	}

	// Invoke the augmentConversionForLogFilesDataSource_STATUS interface (if implemented) to customize the conversion
	var sourceAsAny any = source
	if augmentedSource, ok := sourceAsAny.(augmentConversionForLogFilesDataSource_STATUS); ok {
		err := augmentedSource.AssignPropertiesFrom(origin)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_LogFilesDataSource_STATUS populates the provided destination LogFilesDataSource_STATUS from our LogFilesDataSource_STATUS
func (source *LogFilesDataSource_STATUS) AssignProperties_To_LogFilesDataSource_STATUS(destination *v20240311s.LogFilesDataSource_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// FilePatterns
	destination.FilePatterns = genruntime.CloneSliceOfString(source.FilePatterns)

	// Format
	destination.Format = genruntime.ClonePointerToString(source.Format)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// Settings
	if source.Settings != nil {
		var setting v20240311s.LogFileSettings_STATUS
		err := source.Settings.AssignProperties_To_LogFileSettings_STATUS(&setting)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_LogFileSettings_STATUS() to populate field Settings")
		}
		destination.Settings = &setting
	} else {
		destination.Settings = nil
	}

	// Streams
	destination.Streams = genruntime.CloneSliceOfString(source.Streams)

	// TransformKql
	destination.TransformKql = genruntime.ClonePointerToString(source.TransformKql)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForLogFilesDataSource_STATUS interface (if implemented) to customize the conversion
	var sourceAsAny any = source
	if augmentedSource, ok := sourceAsAny.(augmentConversionForLogFilesDataSource_STATUS); ok {
		err := augmentedSource.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.MicrosoftFabricDestination
// Microsoft Fabric destination (non-Azure).
type MicrosoftFabricDestination struct {
	ArtifactId   *string                `json:"artifactId,omitempty"`
	DatabaseName *string                `json:"databaseName,omitempty"`
	IngestionUri *string                `json:"ingestionUri,omitempty"`
	Name         *string                `json:"name,omitempty"`
	PropertyBag  genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	TenantId     *string                `json:"tenantId,omitempty"`
}

// AssignProperties_From_MicrosoftFabricDestination populates our MicrosoftFabricDestination from the provided source MicrosoftFabricDestination
func (destination *MicrosoftFabricDestination) AssignProperties_From_MicrosoftFabricDestination(source *v20240311s.MicrosoftFabricDestination) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ArtifactId
	destination.ArtifactId = genruntime.ClonePointerToString(source.ArtifactId)

	// DatabaseName
	destination.DatabaseName = genruntime.ClonePointerToString(source.DatabaseName)

	// IngestionUri
	destination.IngestionUri = genruntime.ClonePointerToString(source.IngestionUri)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForMicrosoftFabricDestination interface (if implemented) to customize the conversion
	var destinationAsAny any = destination
	if augmentedDestination, ok := destinationAsAny.(augmentConversionForMicrosoftFabricDestination); ok {
		err := augmentedDestination.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_MicrosoftFabricDestination populates the provided destination MicrosoftFabricDestination from our MicrosoftFabricDestination
func (destination *MicrosoftFabricDestination) AssignProperties_To_MicrosoftFabricDestination(target *v20240311s.MicrosoftFabricDestination) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(destination.PropertyBag)

	// ArtifactId
	target.ArtifactId = genruntime.ClonePointerToString(destination.ArtifactId)

	// DatabaseName
	target.DatabaseName = genruntime.ClonePointerToString(destination.DatabaseName)

	// IngestionUri
	target.IngestionUri = genruntime.ClonePointerToString(destination.IngestionUri)

	// Name
	target.Name = genruntime.ClonePointerToString(destination.Name)

	// TenantId
	target.TenantId = genruntime.ClonePointerToString(destination.TenantId)

	// Update the property bag
	if len(propertyBag) > 0 {
		target.PropertyBag = propertyBag
	} else {
		target.PropertyBag = nil
	}

	// Invoke the augmentConversionForMicrosoftFabricDestination interface (if implemented) to customize the conversion
	var destinationAsAny any = destination
	if augmentedDestination, ok := destinationAsAny.(augmentConversionForMicrosoftFabricDestination); ok {
		err := augmentedDestination.AssignPropertiesTo(target)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.MicrosoftFabricDestination_STATUS
// Microsoft Fabric destination (non-Azure).
type MicrosoftFabricDestination_STATUS struct {
	ArtifactId   *string                `json:"artifactId,omitempty"`
	DatabaseName *string                `json:"databaseName,omitempty"`
	IngestionUri *string                `json:"ingestionUri,omitempty"`
	Name         *string                `json:"name,omitempty"`
	PropertyBag  genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	TenantId     *string                `json:"tenantId,omitempty"`
}

// AssignProperties_From_MicrosoftFabricDestination_STATUS populates our MicrosoftFabricDestination_STATUS from the provided source MicrosoftFabricDestination_STATUS
func (destination *MicrosoftFabricDestination_STATUS) AssignProperties_From_MicrosoftFabricDestination_STATUS(source *v20240311s.MicrosoftFabricDestination_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ArtifactId
	destination.ArtifactId = genruntime.ClonePointerToString(source.ArtifactId)

	// DatabaseName
	destination.DatabaseName = genruntime.ClonePointerToString(source.DatabaseName)

	// IngestionUri
	destination.IngestionUri = genruntime.ClonePointerToString(source.IngestionUri)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForMicrosoftFabricDestination_STATUS interface (if implemented) to customize the conversion
	var destinationAsAny any = destination
	if augmentedDestination, ok := destinationAsAny.(augmentConversionForMicrosoftFabricDestination_STATUS); ok {
		err := augmentedDestination.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_MicrosoftFabricDestination_STATUS populates the provided destination MicrosoftFabricDestination_STATUS from our MicrosoftFabricDestination_STATUS
func (destination *MicrosoftFabricDestination_STATUS) AssignProperties_To_MicrosoftFabricDestination_STATUS(target *v20240311s.MicrosoftFabricDestination_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(destination.PropertyBag)

	// ArtifactId
	target.ArtifactId = genruntime.ClonePointerToString(destination.ArtifactId)

	// DatabaseName
	target.DatabaseName = genruntime.ClonePointerToString(destination.DatabaseName)

	// IngestionUri
	target.IngestionUri = genruntime.ClonePointerToString(destination.IngestionUri)

	// Name
	target.Name = genruntime.ClonePointerToString(destination.Name)

	// TenantId
	target.TenantId = genruntime.ClonePointerToString(destination.TenantId)

	// Update the property bag
	if len(propertyBag) > 0 {
		target.PropertyBag = propertyBag
	} else {
		target.PropertyBag = nil
	}

	// Invoke the augmentConversionForMicrosoftFabricDestination_STATUS interface (if implemented) to customize the conversion
	var destinationAsAny any = destination
	if augmentedDestination, ok := destinationAsAny.(augmentConversionForMicrosoftFabricDestination_STATUS); ok {
		err := augmentedDestination.AssignPropertiesTo(target)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.MonitoringAccountDestination
// Monitoring account destination.
type MonitoringAccountDestination struct {
	// AccountResourceReference: The resource ID of the monitoring account.
	AccountResourceReference *genruntime.ResourceReference `armReference:"AccountResourceId" json:"accountResourceReference,omitempty"`
	Name                     *string                       `json:"name,omitempty"`
	PropertyBag              genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_MonitoringAccountDestination populates our MonitoringAccountDestination from the provided source MonitoringAccountDestination
func (destination *MonitoringAccountDestination) AssignProperties_From_MonitoringAccountDestination(source *v20240311s.MonitoringAccountDestination) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AccountResourceReference
	if source.AccountResourceReference != nil {
		accountResourceReference := source.AccountResourceReference.Copy()
		destination.AccountResourceReference = &accountResourceReference
	} else {
		destination.AccountResourceReference = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForMonitoringAccountDestination interface (if implemented) to customize the conversion
	var destinationAsAny any = destination
	if augmentedDestination, ok := destinationAsAny.(augmentConversionForMonitoringAccountDestination); ok {
		err := augmentedDestination.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_MonitoringAccountDestination populates the provided destination MonitoringAccountDestination from our MonitoringAccountDestination
func (destination *MonitoringAccountDestination) AssignProperties_To_MonitoringAccountDestination(target *v20240311s.MonitoringAccountDestination) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(destination.PropertyBag)

	// AccountResourceReference
	if destination.AccountResourceReference != nil {
		accountResourceReference := destination.AccountResourceReference.Copy()
		target.AccountResourceReference = &accountResourceReference
	} else {
		target.AccountResourceReference = nil
	}

	// Name
	target.Name = genruntime.ClonePointerToString(destination.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		target.PropertyBag = propertyBag
	} else {
		target.PropertyBag = nil
	}

	// Invoke the augmentConversionForMonitoringAccountDestination interface (if implemented) to customize the conversion
	var destinationAsAny any = destination
	if augmentedDestination, ok := destinationAsAny.(augmentConversionForMonitoringAccountDestination); ok {
		err := augmentedDestination.AssignPropertiesTo(target)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.MonitoringAccountDestination_STATUS
// Monitoring account destination.
type MonitoringAccountDestination_STATUS struct {
	AccountId         *string                `json:"accountId,omitempty"`
	AccountResourceId *string                `json:"accountResourceId,omitempty"`
	Name              *string                `json:"name,omitempty"`
	PropertyBag       genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_MonitoringAccountDestination_STATUS populates our MonitoringAccountDestination_STATUS from the provided source MonitoringAccountDestination_STATUS
func (destination *MonitoringAccountDestination_STATUS) AssignProperties_From_MonitoringAccountDestination_STATUS(source *v20240311s.MonitoringAccountDestination_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AccountId
	destination.AccountId = genruntime.ClonePointerToString(source.AccountId)

	// AccountResourceId
	destination.AccountResourceId = genruntime.ClonePointerToString(source.AccountResourceId)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForMonitoringAccountDestination_STATUS interface (if implemented) to customize the conversion
	var destinationAsAny any = destination
	if augmentedDestination, ok := destinationAsAny.(augmentConversionForMonitoringAccountDestination_STATUS); ok {
		err := augmentedDestination.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_MonitoringAccountDestination_STATUS populates the provided destination MonitoringAccountDestination_STATUS from our MonitoringAccountDestination_STATUS
func (destination *MonitoringAccountDestination_STATUS) AssignProperties_To_MonitoringAccountDestination_STATUS(target *v20240311s.MonitoringAccountDestination_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(destination.PropertyBag)

	// AccountId
	target.AccountId = genruntime.ClonePointerToString(destination.AccountId)

	// AccountResourceId
	target.AccountResourceId = genruntime.ClonePointerToString(destination.AccountResourceId)

	// Name
	target.Name = genruntime.ClonePointerToString(destination.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		target.PropertyBag = propertyBag
	} else {
		target.PropertyBag = nil
	}

	// Invoke the augmentConversionForMonitoringAccountDestination_STATUS interface (if implemented) to customize the conversion
	var destinationAsAny any = destination
	if augmentedDestination, ok := destinationAsAny.(augmentConversionForMonitoringAccountDestination_STATUS); ok {
		err := augmentedDestination.AssignPropertiesTo(target)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.PerfCounterDataSource
// Definition of which performance counters will be collected and how they will be collected by this data collection
// rule.
// Collected from both Windows and Linux machines where the counter is present.
type PerfCounterDataSource struct {
	CounterSpecifiers          []string               `json:"counterSpecifiers,omitempty"`
	Name                       *string                `json:"name,omitempty"`
	PropertyBag                genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SamplingFrequencyInSeconds *int                   `json:"samplingFrequencyInSeconds,omitempty"`
	Streams                    []string               `json:"streams,omitempty"`
	TransformKql               *string                `json:"transformKql,omitempty"`
}

// AssignProperties_From_PerfCounterDataSource populates our PerfCounterDataSource from the provided source PerfCounterDataSource
func (source *PerfCounterDataSource) AssignProperties_From_PerfCounterDataSource(origin *v20240311s.PerfCounterDataSource) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(origin.PropertyBag)

	// CounterSpecifiers
	source.CounterSpecifiers = genruntime.CloneSliceOfString(origin.CounterSpecifiers)

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// SamplingFrequencyInSeconds
	source.SamplingFrequencyInSeconds = genruntime.ClonePointerToInt(origin.SamplingFrequencyInSeconds)

	// Streams
	source.Streams = genruntime.CloneSliceOfString(origin.Streams)

	// TransformKql
	source.TransformKql = genruntime.ClonePointerToString(origin.TransformKql)

	// Update the property bag
	if len(propertyBag) > 0 {
		source.PropertyBag = propertyBag
	} else {
		source.PropertyBag = nil
	}

	// Invoke the augmentConversionForPerfCounterDataSource interface (if implemented) to customize the conversion
	var sourceAsAny any = source
	if augmentedSource, ok := sourceAsAny.(augmentConversionForPerfCounterDataSource); ok {
		err := augmentedSource.AssignPropertiesFrom(origin)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_PerfCounterDataSource populates the provided destination PerfCounterDataSource from our PerfCounterDataSource
func (source *PerfCounterDataSource) AssignProperties_To_PerfCounterDataSource(destination *v20240311s.PerfCounterDataSource) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CounterSpecifiers
	destination.CounterSpecifiers = genruntime.CloneSliceOfString(source.CounterSpecifiers)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// SamplingFrequencyInSeconds
	destination.SamplingFrequencyInSeconds = genruntime.ClonePointerToInt(source.SamplingFrequencyInSeconds)

	// Streams
	destination.Streams = genruntime.CloneSliceOfString(source.Streams)

	// TransformKql
	destination.TransformKql = genruntime.ClonePointerToString(source.TransformKql)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForPerfCounterDataSource interface (if implemented) to customize the conversion
	var sourceAsAny any = source
	if augmentedSource, ok := sourceAsAny.(augmentConversionForPerfCounterDataSource); ok {
		err := augmentedSource.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.PerfCounterDataSource_STATUS
// Definition of which performance counters will be collected and how they will be collected by this data collection
// rule.
// Collected from both Windows and Linux machines where the counter is present.
type PerfCounterDataSource_STATUS struct {
	CounterSpecifiers          []string               `json:"counterSpecifiers,omitempty"`
	Name                       *string                `json:"name,omitempty"`
	PropertyBag                genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SamplingFrequencyInSeconds *int                   `json:"samplingFrequencyInSeconds,omitempty"`
	Streams                    []string               `json:"streams,omitempty"`
	TransformKql               *string                `json:"transformKql,omitempty"`
}

// AssignProperties_From_PerfCounterDataSource_STATUS populates our PerfCounterDataSource_STATUS from the provided source PerfCounterDataSource_STATUS
func (source *PerfCounterDataSource_STATUS) AssignProperties_From_PerfCounterDataSource_STATUS(origin *v20240311s.PerfCounterDataSource_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(origin.PropertyBag)

	// CounterSpecifiers
	source.CounterSpecifiers = genruntime.CloneSliceOfString(origin.CounterSpecifiers)

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// SamplingFrequencyInSeconds
	source.SamplingFrequencyInSeconds = genruntime.ClonePointerToInt(origin.SamplingFrequencyInSeconds)

	// Streams
	source.Streams = genruntime.CloneSliceOfString(origin.Streams)

	// TransformKql
	source.TransformKql = genruntime.ClonePointerToString(origin.TransformKql)

	// Update the property bag
	if len(propertyBag) > 0 {
		source.PropertyBag = propertyBag
	} else {
		source.PropertyBag = nil
	}

	// Invoke the augmentConversionForPerfCounterDataSource_STATUS interface (if implemented) to customize the conversion
	var sourceAsAny any = source
	if augmentedSource, ok := sourceAsAny.(augmentConversionForPerfCounterDataSource_STATUS); ok {
		err := augmentedSource.AssignPropertiesFrom(origin)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_PerfCounterDataSource_STATUS populates the provided destination PerfCounterDataSource_STATUS from our PerfCounterDataSource_STATUS
func (source *PerfCounterDataSource_STATUS) AssignProperties_To_PerfCounterDataSource_STATUS(destination *v20240311s.PerfCounterDataSource_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CounterSpecifiers
	destination.CounterSpecifiers = genruntime.CloneSliceOfString(source.CounterSpecifiers)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// SamplingFrequencyInSeconds
	destination.SamplingFrequencyInSeconds = genruntime.ClonePointerToInt(source.SamplingFrequencyInSeconds)

	// Streams
	destination.Streams = genruntime.CloneSliceOfString(source.Streams)

	// TransformKql
	destination.TransformKql = genruntime.ClonePointerToString(source.TransformKql)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForPerfCounterDataSource_STATUS interface (if implemented) to customize the conversion
	var sourceAsAny any = source
	if augmentedSource, ok := sourceAsAny.(augmentConversionForPerfCounterDataSource_STATUS); ok {
		err := augmentedSource.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.PlatformTelemetryDataSource
// Definition of platform telemetry data source configuration
type PlatformTelemetryDataSource struct {
	Name        *string                `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Streams     []string               `json:"streams,omitempty"`
}

// AssignProperties_From_PlatformTelemetryDataSource populates our PlatformTelemetryDataSource from the provided source PlatformTelemetryDataSource
func (source *PlatformTelemetryDataSource) AssignProperties_From_PlatformTelemetryDataSource(origin *v20240311s.PlatformTelemetryDataSource) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(origin.PropertyBag)

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// Streams
	source.Streams = genruntime.CloneSliceOfString(origin.Streams)

	// Update the property bag
	if len(propertyBag) > 0 {
		source.PropertyBag = propertyBag
	} else {
		source.PropertyBag = nil
	}

	// Invoke the augmentConversionForPlatformTelemetryDataSource interface (if implemented) to customize the conversion
	var sourceAsAny any = source
	if augmentedSource, ok := sourceAsAny.(augmentConversionForPlatformTelemetryDataSource); ok {
		err := augmentedSource.AssignPropertiesFrom(origin)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_PlatformTelemetryDataSource populates the provided destination PlatformTelemetryDataSource from our PlatformTelemetryDataSource
func (source *PlatformTelemetryDataSource) AssignProperties_To_PlatformTelemetryDataSource(destination *v20240311s.PlatformTelemetryDataSource) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// Streams
	destination.Streams = genruntime.CloneSliceOfString(source.Streams)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForPlatformTelemetryDataSource interface (if implemented) to customize the conversion
	var sourceAsAny any = source
	if augmentedSource, ok := sourceAsAny.(augmentConversionForPlatformTelemetryDataSource); ok {
		err := augmentedSource.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.PlatformTelemetryDataSource_STATUS
// Definition of platform telemetry data source configuration
type PlatformTelemetryDataSource_STATUS struct {
	Name        *string                `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Streams     []string               `json:"streams,omitempty"`
}

// AssignProperties_From_PlatformTelemetryDataSource_STATUS populates our PlatformTelemetryDataSource_STATUS from the provided source PlatformTelemetryDataSource_STATUS
func (source *PlatformTelemetryDataSource_STATUS) AssignProperties_From_PlatformTelemetryDataSource_STATUS(origin *v20240311s.PlatformTelemetryDataSource_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(origin.PropertyBag)

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// Streams
	source.Streams = genruntime.CloneSliceOfString(origin.Streams)

	// Update the property bag
	if len(propertyBag) > 0 {
		source.PropertyBag = propertyBag
	} else {
		source.PropertyBag = nil
	}

	// Invoke the augmentConversionForPlatformTelemetryDataSource_STATUS interface (if implemented) to customize the conversion
	var sourceAsAny any = source
	if augmentedSource, ok := sourceAsAny.(augmentConversionForPlatformTelemetryDataSource_STATUS); ok {
		err := augmentedSource.AssignPropertiesFrom(origin)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_PlatformTelemetryDataSource_STATUS populates the provided destination PlatformTelemetryDataSource_STATUS from our PlatformTelemetryDataSource_STATUS
func (source *PlatformTelemetryDataSource_STATUS) AssignProperties_To_PlatformTelemetryDataSource_STATUS(destination *v20240311s.PlatformTelemetryDataSource_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// Streams
	destination.Streams = genruntime.CloneSliceOfString(source.Streams)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForPlatformTelemetryDataSource_STATUS interface (if implemented) to customize the conversion
	var sourceAsAny any = source
	if augmentedSource, ok := sourceAsAny.(augmentConversionForPlatformTelemetryDataSource_STATUS); ok {
		err := augmentedSource.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.PrometheusForwarderDataSource
// Definition of Prometheus metrics forwarding configuration.
type PrometheusForwarderDataSource struct {
	LabelIncludeFilter map[string]string      `json:"labelIncludeFilter,omitempty"`
	Name               *string                `json:"name,omitempty"`
	PropertyBag        genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Streams            []string               `json:"streams,omitempty"`
}

// AssignProperties_From_PrometheusForwarderDataSource populates our PrometheusForwarderDataSource from the provided source PrometheusForwarderDataSource
func (source *PrometheusForwarderDataSource) AssignProperties_From_PrometheusForwarderDataSource(origin *v20240311s.PrometheusForwarderDataSource) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(origin.PropertyBag)

	// CustomVMScrapeConfig
	if len(origin.CustomVMScrapeConfig) > 0 {
		propertyBag.Add("CustomVMScrapeConfig", origin.CustomVMScrapeConfig)
	} else {
		propertyBag.Remove("CustomVMScrapeConfig")
	}

	// LabelIncludeFilter
	source.LabelIncludeFilter = genruntime.CloneMapOfStringToString(origin.LabelIncludeFilter)

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// Streams
	source.Streams = genruntime.CloneSliceOfString(origin.Streams)

	// Update the property bag
	if len(propertyBag) > 0 {
		source.PropertyBag = propertyBag
	} else {
		source.PropertyBag = nil
	}

	// Invoke the augmentConversionForPrometheusForwarderDataSource interface (if implemented) to customize the conversion
	var sourceAsAny any = source
	if augmentedSource, ok := sourceAsAny.(augmentConversionForPrometheusForwarderDataSource); ok {
		err := augmentedSource.AssignPropertiesFrom(origin)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_PrometheusForwarderDataSource populates the provided destination PrometheusForwarderDataSource from our PrometheusForwarderDataSource
func (source *PrometheusForwarderDataSource) AssignProperties_To_PrometheusForwarderDataSource(destination *v20240311s.PrometheusForwarderDataSource) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CustomVMScrapeConfig
	if propertyBag.Contains("CustomVMScrapeConfig") {
		var customVMScrapeConfig []map[string]v1.JSON
		err := propertyBag.Pull("CustomVMScrapeConfig", &customVMScrapeConfig)
		if err != nil {
			return eris.Wrap(err, "pulling 'CustomVMScrapeConfig' from propertyBag")
		}

		destination.CustomVMScrapeConfig = customVMScrapeConfig
	} else {
		destination.CustomVMScrapeConfig = nil
	}

	// LabelIncludeFilter
	destination.LabelIncludeFilter = genruntime.CloneMapOfStringToString(source.LabelIncludeFilter)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// Streams
	destination.Streams = genruntime.CloneSliceOfString(source.Streams)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForPrometheusForwarderDataSource interface (if implemented) to customize the conversion
	var sourceAsAny any = source
	if augmentedSource, ok := sourceAsAny.(augmentConversionForPrometheusForwarderDataSource); ok {
		err := augmentedSource.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.PrometheusForwarderDataSource_STATUS
// Definition of Prometheus metrics forwarding configuration.
type PrometheusForwarderDataSource_STATUS struct {
	LabelIncludeFilter map[string]string      `json:"labelIncludeFilter,omitempty"`
	Name               *string                `json:"name,omitempty"`
	PropertyBag        genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Streams            []string               `json:"streams,omitempty"`
}

// AssignProperties_From_PrometheusForwarderDataSource_STATUS populates our PrometheusForwarderDataSource_STATUS from the provided source PrometheusForwarderDataSource_STATUS
func (source *PrometheusForwarderDataSource_STATUS) AssignProperties_From_PrometheusForwarderDataSource_STATUS(origin *v20240311s.PrometheusForwarderDataSource_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(origin.PropertyBag)

	// CustomVMScrapeConfig
	if len(origin.CustomVMScrapeConfig) > 0 {
		propertyBag.Add("CustomVMScrapeConfig", origin.CustomVMScrapeConfig)
	} else {
		propertyBag.Remove("CustomVMScrapeConfig")
	}

	// LabelIncludeFilter
	source.LabelIncludeFilter = genruntime.CloneMapOfStringToString(origin.LabelIncludeFilter)

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// Streams
	source.Streams = genruntime.CloneSliceOfString(origin.Streams)

	// Update the property bag
	if len(propertyBag) > 0 {
		source.PropertyBag = propertyBag
	} else {
		source.PropertyBag = nil
	}

	// Invoke the augmentConversionForPrometheusForwarderDataSource_STATUS interface (if implemented) to customize the conversion
	var sourceAsAny any = source
	if augmentedSource, ok := sourceAsAny.(augmentConversionForPrometheusForwarderDataSource_STATUS); ok {
		err := augmentedSource.AssignPropertiesFrom(origin)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_PrometheusForwarderDataSource_STATUS populates the provided destination PrometheusForwarderDataSource_STATUS from our PrometheusForwarderDataSource_STATUS
func (source *PrometheusForwarderDataSource_STATUS) AssignProperties_To_PrometheusForwarderDataSource_STATUS(destination *v20240311s.PrometheusForwarderDataSource_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CustomVMScrapeConfig
	if propertyBag.Contains("CustomVMScrapeConfig") {
		var customVMScrapeConfig []map[string]v1.JSON
		err := propertyBag.Pull("CustomVMScrapeConfig", &customVMScrapeConfig)
		if err != nil {
			return eris.Wrap(err, "pulling 'CustomVMScrapeConfig' from propertyBag")
		}

		destination.CustomVMScrapeConfig = customVMScrapeConfig
	} else {
		destination.CustomVMScrapeConfig = nil
	}

	// LabelIncludeFilter
	destination.LabelIncludeFilter = genruntime.CloneMapOfStringToString(source.LabelIncludeFilter)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// Streams
	destination.Streams = genruntime.CloneSliceOfString(source.Streams)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForPrometheusForwarderDataSource_STATUS interface (if implemented) to customize the conversion
	var sourceAsAny any = source
	if augmentedSource, ok := sourceAsAny.(augmentConversionForPrometheusForwarderDataSource_STATUS); ok {
		err := augmentedSource.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.StorageBlobDestination
type StorageBlobDestination struct {
	ContainerName *string                `json:"containerName,omitempty"`
	Name          *string                `json:"name,omitempty"`
	PropertyBag   genruntime.PropertyBag `json:"$propertyBag,omitempty"`

	// StorageAccountResourceReference: The resource ID of the storage account.
	StorageAccountResourceReference *genruntime.ResourceReference `armReference:"StorageAccountResourceId" json:"storageAccountResourceReference,omitempty"`
}

// AssignProperties_From_StorageBlobDestination populates our StorageBlobDestination from the provided source StorageBlobDestination
func (destination *StorageBlobDestination) AssignProperties_From_StorageBlobDestination(source *v20240311s.StorageBlobDestination) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ContainerName
	destination.ContainerName = genruntime.ClonePointerToString(source.ContainerName)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// StorageAccountResourceReference
	if source.StorageAccountResourceReference != nil {
		storageAccountResourceReference := source.StorageAccountResourceReference.Copy()
		destination.StorageAccountResourceReference = &storageAccountResourceReference
	} else {
		destination.StorageAccountResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForStorageBlobDestination interface (if implemented) to customize the conversion
	var destinationAsAny any = destination
	if augmentedDestination, ok := destinationAsAny.(augmentConversionForStorageBlobDestination); ok {
		err := augmentedDestination.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_StorageBlobDestination populates the provided destination StorageBlobDestination from our StorageBlobDestination
func (destination *StorageBlobDestination) AssignProperties_To_StorageBlobDestination(target *v20240311s.StorageBlobDestination) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(destination.PropertyBag)

	// ContainerName
	target.ContainerName = genruntime.ClonePointerToString(destination.ContainerName)

	// Name
	target.Name = genruntime.ClonePointerToString(destination.Name)

	// StorageAccountResourceReference
	if destination.StorageAccountResourceReference != nil {
		storageAccountResourceReference := destination.StorageAccountResourceReference.Copy()
		target.StorageAccountResourceReference = &storageAccountResourceReference
	} else {
		target.StorageAccountResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		target.PropertyBag = propertyBag
	} else {
		target.PropertyBag = nil
	}

	// Invoke the augmentConversionForStorageBlobDestination interface (if implemented) to customize the conversion
	var destinationAsAny any = destination
	if augmentedDestination, ok := destinationAsAny.(augmentConversionForStorageBlobDestination); ok {
		err := augmentedDestination.AssignPropertiesTo(target)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.StorageBlobDestination_STATUS
type StorageBlobDestination_STATUS struct {
	ContainerName            *string                `json:"containerName,omitempty"`
	Name                     *string                `json:"name,omitempty"`
	PropertyBag              genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	StorageAccountResourceId *string                `json:"storageAccountResourceId,omitempty"`
}

// AssignProperties_From_StorageBlobDestination_STATUS populates our StorageBlobDestination_STATUS from the provided source StorageBlobDestination_STATUS
func (destination *StorageBlobDestination_STATUS) AssignProperties_From_StorageBlobDestination_STATUS(source *v20240311s.StorageBlobDestination_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ContainerName
	destination.ContainerName = genruntime.ClonePointerToString(source.ContainerName)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// StorageAccountResourceId
	destination.StorageAccountResourceId = genruntime.ClonePointerToString(source.StorageAccountResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForStorageBlobDestination_STATUS interface (if implemented) to customize the conversion
	var destinationAsAny any = destination
	if augmentedDestination, ok := destinationAsAny.(augmentConversionForStorageBlobDestination_STATUS); ok {
		err := augmentedDestination.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_StorageBlobDestination_STATUS populates the provided destination StorageBlobDestination_STATUS from our StorageBlobDestination_STATUS
func (destination *StorageBlobDestination_STATUS) AssignProperties_To_StorageBlobDestination_STATUS(target *v20240311s.StorageBlobDestination_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(destination.PropertyBag)

	// ContainerName
	target.ContainerName = genruntime.ClonePointerToString(destination.ContainerName)

	// Name
	target.Name = genruntime.ClonePointerToString(destination.Name)

	// StorageAccountResourceId
	target.StorageAccountResourceId = genruntime.ClonePointerToString(destination.StorageAccountResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		target.PropertyBag = propertyBag
	} else {
		target.PropertyBag = nil
	}

	// Invoke the augmentConversionForStorageBlobDestination_STATUS interface (if implemented) to customize the conversion
	var destinationAsAny any = destination
	if augmentedDestination, ok := destinationAsAny.(augmentConversionForStorageBlobDestination_STATUS); ok {
		err := augmentedDestination.AssignPropertiesTo(target)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.StorageTableDestination
type StorageTableDestination struct {
	Name        *string                `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`

	// StorageAccountResourceReference: The resource ID of the storage account.
	StorageAccountResourceReference *genruntime.ResourceReference `armReference:"StorageAccountResourceId" json:"storageAccountResourceReference,omitempty"`
	TableName                       *string                       `json:"tableName,omitempty"`
}

// AssignProperties_From_StorageTableDestination populates our StorageTableDestination from the provided source StorageTableDestination
func (destination *StorageTableDestination) AssignProperties_From_StorageTableDestination(source *v20240311s.StorageTableDestination) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// StorageAccountResourceReference
	if source.StorageAccountResourceReference != nil {
		storageAccountResourceReference := source.StorageAccountResourceReference.Copy()
		destination.StorageAccountResourceReference = &storageAccountResourceReference
	} else {
		destination.StorageAccountResourceReference = nil
	}

	// TableName
	destination.TableName = genruntime.ClonePointerToString(source.TableName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForStorageTableDestination interface (if implemented) to customize the conversion
	var destinationAsAny any = destination
	if augmentedDestination, ok := destinationAsAny.(augmentConversionForStorageTableDestination); ok {
		err := augmentedDestination.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_StorageTableDestination populates the provided destination StorageTableDestination from our StorageTableDestination
func (destination *StorageTableDestination) AssignProperties_To_StorageTableDestination(target *v20240311s.StorageTableDestination) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(destination.PropertyBag)

	// Name
	target.Name = genruntime.ClonePointerToString(destination.Name)

	// StorageAccountResourceReference
	if destination.StorageAccountResourceReference != nil {
		storageAccountResourceReference := destination.StorageAccountResourceReference.Copy()
		target.StorageAccountResourceReference = &storageAccountResourceReference
	} else {
		target.StorageAccountResourceReference = nil
	}

	// TableName
	target.TableName = genruntime.ClonePointerToString(destination.TableName)

	// Update the property bag
	if len(propertyBag) > 0 {
		target.PropertyBag = propertyBag
	} else {
		target.PropertyBag = nil
	}

	// Invoke the augmentConversionForStorageTableDestination interface (if implemented) to customize the conversion
	var destinationAsAny any = destination
	if augmentedDestination, ok := destinationAsAny.(augmentConversionForStorageTableDestination); ok {
		err := augmentedDestination.AssignPropertiesTo(target)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.StorageTableDestination_STATUS
type StorageTableDestination_STATUS struct {
	Name                     *string                `json:"name,omitempty"`
	PropertyBag              genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	StorageAccountResourceId *string                `json:"storageAccountResourceId,omitempty"`
	TableName                *string                `json:"tableName,omitempty"`
}

// AssignProperties_From_StorageTableDestination_STATUS populates our StorageTableDestination_STATUS from the provided source StorageTableDestination_STATUS
func (destination *StorageTableDestination_STATUS) AssignProperties_From_StorageTableDestination_STATUS(source *v20240311s.StorageTableDestination_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// StorageAccountResourceId
	destination.StorageAccountResourceId = genruntime.ClonePointerToString(source.StorageAccountResourceId)

	// TableName
	destination.TableName = genruntime.ClonePointerToString(source.TableName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForStorageTableDestination_STATUS interface (if implemented) to customize the conversion
	var destinationAsAny any = destination
	if augmentedDestination, ok := destinationAsAny.(augmentConversionForStorageTableDestination_STATUS); ok {
		err := augmentedDestination.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_StorageTableDestination_STATUS populates the provided destination StorageTableDestination_STATUS from our StorageTableDestination_STATUS
func (destination *StorageTableDestination_STATUS) AssignProperties_To_StorageTableDestination_STATUS(target *v20240311s.StorageTableDestination_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(destination.PropertyBag)

	// Name
	target.Name = genruntime.ClonePointerToString(destination.Name)

	// StorageAccountResourceId
	target.StorageAccountResourceId = genruntime.ClonePointerToString(destination.StorageAccountResourceId)

	// TableName
	target.TableName = genruntime.ClonePointerToString(destination.TableName)

	// Update the property bag
	if len(propertyBag) > 0 {
		target.PropertyBag = propertyBag
	} else {
		target.PropertyBag = nil
	}

	// Invoke the augmentConversionForStorageTableDestination_STATUS interface (if implemented) to customize the conversion
	var destinationAsAny any = destination
	if augmentedDestination, ok := destinationAsAny.(augmentConversionForStorageTableDestination_STATUS); ok {
		err := augmentedDestination.AssignPropertiesTo(target)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.SyslogDataSource
// Definition of which syslog data will be collected and how it will be collected.
// Only collected from Linux machines.
type SyslogDataSource struct {
	FacilityNames []string               `json:"facilityNames,omitempty"`
	LogLevels     []string               `json:"logLevels,omitempty"`
	Name          *string                `json:"name,omitempty"`
	PropertyBag   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Streams       []string               `json:"streams,omitempty"`
	TransformKql  *string                `json:"transformKql,omitempty"`
}

// AssignProperties_From_SyslogDataSource populates our SyslogDataSource from the provided source SyslogDataSource
func (source *SyslogDataSource) AssignProperties_From_SyslogDataSource(origin *v20240311s.SyslogDataSource) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(origin.PropertyBag)

	// FacilityNames
	source.FacilityNames = genruntime.CloneSliceOfString(origin.FacilityNames)

	// LogLevels
	source.LogLevels = genruntime.CloneSliceOfString(origin.LogLevels)

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// Streams
	source.Streams = genruntime.CloneSliceOfString(origin.Streams)

	// TransformKql
	source.TransformKql = genruntime.ClonePointerToString(origin.TransformKql)

	// Update the property bag
	if len(propertyBag) > 0 {
		source.PropertyBag = propertyBag
	} else {
		source.PropertyBag = nil
	}

	// Invoke the augmentConversionForSyslogDataSource interface (if implemented) to customize the conversion
	var sourceAsAny any = source
	if augmentedSource, ok := sourceAsAny.(augmentConversionForSyslogDataSource); ok {
		err := augmentedSource.AssignPropertiesFrom(origin)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_SyslogDataSource populates the provided destination SyslogDataSource from our SyslogDataSource
func (source *SyslogDataSource) AssignProperties_To_SyslogDataSource(destination *v20240311s.SyslogDataSource) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// FacilityNames
	destination.FacilityNames = genruntime.CloneSliceOfString(source.FacilityNames)

	// LogLevels
	destination.LogLevels = genruntime.CloneSliceOfString(source.LogLevels)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// Streams
	destination.Streams = genruntime.CloneSliceOfString(source.Streams)

	// TransformKql
	destination.TransformKql = genruntime.ClonePointerToString(source.TransformKql)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForSyslogDataSource interface (if implemented) to customize the conversion
	var sourceAsAny any = source
	if augmentedSource, ok := sourceAsAny.(augmentConversionForSyslogDataSource); ok {
		err := augmentedSource.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.SyslogDataSource_STATUS
// Definition of which syslog data will be collected and how it will be collected.
// Only collected from Linux machines.
type SyslogDataSource_STATUS struct {
	FacilityNames []string               `json:"facilityNames,omitempty"`
	LogLevels     []string               `json:"logLevels,omitempty"`
	Name          *string                `json:"name,omitempty"`
	PropertyBag   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Streams       []string               `json:"streams,omitempty"`
	TransformKql  *string                `json:"transformKql,omitempty"`
}

// AssignProperties_From_SyslogDataSource_STATUS populates our SyslogDataSource_STATUS from the provided source SyslogDataSource_STATUS
func (source *SyslogDataSource_STATUS) AssignProperties_From_SyslogDataSource_STATUS(origin *v20240311s.SyslogDataSource_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(origin.PropertyBag)

	// FacilityNames
	source.FacilityNames = genruntime.CloneSliceOfString(origin.FacilityNames)

	// LogLevels
	source.LogLevels = genruntime.CloneSliceOfString(origin.LogLevels)

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// Streams
	source.Streams = genruntime.CloneSliceOfString(origin.Streams)

	// TransformKql
	source.TransformKql = genruntime.ClonePointerToString(origin.TransformKql)

	// Update the property bag
	if len(propertyBag) > 0 {
		source.PropertyBag = propertyBag
	} else {
		source.PropertyBag = nil
	}

	// Invoke the augmentConversionForSyslogDataSource_STATUS interface (if implemented) to customize the conversion
	var sourceAsAny any = source
	if augmentedSource, ok := sourceAsAny.(augmentConversionForSyslogDataSource_STATUS); ok {
		err := augmentedSource.AssignPropertiesFrom(origin)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_SyslogDataSource_STATUS populates the provided destination SyslogDataSource_STATUS from our SyslogDataSource_STATUS
func (source *SyslogDataSource_STATUS) AssignProperties_To_SyslogDataSource_STATUS(destination *v20240311s.SyslogDataSource_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// FacilityNames
	destination.FacilityNames = genruntime.CloneSliceOfString(source.FacilityNames)

	// LogLevels
	destination.LogLevels = genruntime.CloneSliceOfString(source.LogLevels)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// Streams
	destination.Streams = genruntime.CloneSliceOfString(source.Streams)

	// TransformKql
	destination.TransformKql = genruntime.ClonePointerToString(source.TransformKql)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForSyslogDataSource_STATUS interface (if implemented) to customize the conversion
	var sourceAsAny any = source
	if augmentedSource, ok := sourceAsAny.(augmentConversionForSyslogDataSource_STATUS); ok {
		err := augmentedSource.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.WindowsEventLogDataSource
// Definition of which Windows Event Log events will be collected and how they will be collected.
// Only collected from
// Windows machines.
type WindowsEventLogDataSource struct {
	Name         *string                `json:"name,omitempty"`
	PropertyBag  genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Streams      []string               `json:"streams,omitempty"`
	TransformKql *string                `json:"transformKql,omitempty"`
	XPathQueries []string               `json:"xPathQueries,omitempty"`
}

// AssignProperties_From_WindowsEventLogDataSource populates our WindowsEventLogDataSource from the provided source WindowsEventLogDataSource
func (source *WindowsEventLogDataSource) AssignProperties_From_WindowsEventLogDataSource(origin *v20240311s.WindowsEventLogDataSource) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(origin.PropertyBag)

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// Streams
	source.Streams = genruntime.CloneSliceOfString(origin.Streams)

	// TransformKql
	source.TransformKql = genruntime.ClonePointerToString(origin.TransformKql)

	// XPathQueries
	source.XPathQueries = genruntime.CloneSliceOfString(origin.XPathQueries)

	// Update the property bag
	if len(propertyBag) > 0 {
		source.PropertyBag = propertyBag
	} else {
		source.PropertyBag = nil
	}

	// Invoke the augmentConversionForWindowsEventLogDataSource interface (if implemented) to customize the conversion
	var sourceAsAny any = source
	if augmentedSource, ok := sourceAsAny.(augmentConversionForWindowsEventLogDataSource); ok {
		err := augmentedSource.AssignPropertiesFrom(origin)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_WindowsEventLogDataSource populates the provided destination WindowsEventLogDataSource from our WindowsEventLogDataSource
func (source *WindowsEventLogDataSource) AssignProperties_To_WindowsEventLogDataSource(destination *v20240311s.WindowsEventLogDataSource) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// Streams
	destination.Streams = genruntime.CloneSliceOfString(source.Streams)

	// TransformKql
	destination.TransformKql = genruntime.ClonePointerToString(source.TransformKql)

	// XPathQueries
	destination.XPathQueries = genruntime.CloneSliceOfString(source.XPathQueries)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForWindowsEventLogDataSource interface (if implemented) to customize the conversion
	var sourceAsAny any = source
	if augmentedSource, ok := sourceAsAny.(augmentConversionForWindowsEventLogDataSource); ok {
		err := augmentedSource.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.WindowsEventLogDataSource_STATUS
// Definition of which Windows Event Log events will be collected and how they will be collected.
// Only collected from
// Windows machines.
type WindowsEventLogDataSource_STATUS struct {
	Name         *string                `json:"name,omitempty"`
	PropertyBag  genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Streams      []string               `json:"streams,omitempty"`
	TransformKql *string                `json:"transformKql,omitempty"`
	XPathQueries []string               `json:"xPathQueries,omitempty"`
}

// AssignProperties_From_WindowsEventLogDataSource_STATUS populates our WindowsEventLogDataSource_STATUS from the provided source WindowsEventLogDataSource_STATUS
func (source *WindowsEventLogDataSource_STATUS) AssignProperties_From_WindowsEventLogDataSource_STATUS(origin *v20240311s.WindowsEventLogDataSource_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(origin.PropertyBag)

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// Streams
	source.Streams = genruntime.CloneSliceOfString(origin.Streams)

	// TransformKql
	source.TransformKql = genruntime.ClonePointerToString(origin.TransformKql)

	// XPathQueries
	source.XPathQueries = genruntime.CloneSliceOfString(origin.XPathQueries)

	// Update the property bag
	if len(propertyBag) > 0 {
		source.PropertyBag = propertyBag
	} else {
		source.PropertyBag = nil
	}

	// Invoke the augmentConversionForWindowsEventLogDataSource_STATUS interface (if implemented) to customize the conversion
	var sourceAsAny any = source
	if augmentedSource, ok := sourceAsAny.(augmentConversionForWindowsEventLogDataSource_STATUS); ok {
		err := augmentedSource.AssignPropertiesFrom(origin)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_WindowsEventLogDataSource_STATUS populates the provided destination WindowsEventLogDataSource_STATUS from our WindowsEventLogDataSource_STATUS
func (source *WindowsEventLogDataSource_STATUS) AssignProperties_To_WindowsEventLogDataSource_STATUS(destination *v20240311s.WindowsEventLogDataSource_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// Streams
	destination.Streams = genruntime.CloneSliceOfString(source.Streams)

	// TransformKql
	destination.TransformKql = genruntime.ClonePointerToString(source.TransformKql)

	// XPathQueries
	destination.XPathQueries = genruntime.CloneSliceOfString(source.XPathQueries)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForWindowsEventLogDataSource_STATUS interface (if implemented) to customize the conversion
	var sourceAsAny any = source
	if augmentedSource, ok := sourceAsAny.(augmentConversionForWindowsEventLogDataSource_STATUS); ok {
		err := augmentedSource.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.WindowsFirewallLogsDataSource
// Enables Firewall logs to be collected by this data collection rule.
type WindowsFirewallLogsDataSource struct {
	Name          *string                `json:"name,omitempty"`
	ProfileFilter []string               `json:"profileFilter,omitempty"`
	PropertyBag   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Streams       []string               `json:"streams,omitempty"`
}

// AssignProperties_From_WindowsFirewallLogsDataSource populates our WindowsFirewallLogsDataSource from the provided source WindowsFirewallLogsDataSource
func (source *WindowsFirewallLogsDataSource) AssignProperties_From_WindowsFirewallLogsDataSource(origin *v20240311s.WindowsFirewallLogsDataSource) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(origin.PropertyBag)

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// ProfileFilter
	source.ProfileFilter = genruntime.CloneSliceOfString(origin.ProfileFilter)

	// Streams
	source.Streams = genruntime.CloneSliceOfString(origin.Streams)

	// Update the property bag
	if len(propertyBag) > 0 {
		source.PropertyBag = propertyBag
	} else {
		source.PropertyBag = nil
	}

	// Invoke the augmentConversionForWindowsFirewallLogsDataSource interface (if implemented) to customize the conversion
	var sourceAsAny any = source
	if augmentedSource, ok := sourceAsAny.(augmentConversionForWindowsFirewallLogsDataSource); ok {
		err := augmentedSource.AssignPropertiesFrom(origin)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_WindowsFirewallLogsDataSource populates the provided destination WindowsFirewallLogsDataSource from our WindowsFirewallLogsDataSource
func (source *WindowsFirewallLogsDataSource) AssignProperties_To_WindowsFirewallLogsDataSource(destination *v20240311s.WindowsFirewallLogsDataSource) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// ProfileFilter
	destination.ProfileFilter = genruntime.CloneSliceOfString(source.ProfileFilter)

	// Streams
	destination.Streams = genruntime.CloneSliceOfString(source.Streams)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForWindowsFirewallLogsDataSource interface (if implemented) to customize the conversion
	var sourceAsAny any = source
	if augmentedSource, ok := sourceAsAny.(augmentConversionForWindowsFirewallLogsDataSource); ok {
		err := augmentedSource.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.WindowsFirewallLogsDataSource_STATUS
// Enables Firewall logs to be collected by this data collection rule.
type WindowsFirewallLogsDataSource_STATUS struct {
	Name          *string                `json:"name,omitempty"`
	ProfileFilter []string               `json:"profileFilter,omitempty"`
	PropertyBag   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Streams       []string               `json:"streams,omitempty"`
}

// AssignProperties_From_WindowsFirewallLogsDataSource_STATUS populates our WindowsFirewallLogsDataSource_STATUS from the provided source WindowsFirewallLogsDataSource_STATUS
func (source *WindowsFirewallLogsDataSource_STATUS) AssignProperties_From_WindowsFirewallLogsDataSource_STATUS(origin *v20240311s.WindowsFirewallLogsDataSource_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(origin.PropertyBag)

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// ProfileFilter
	source.ProfileFilter = genruntime.CloneSliceOfString(origin.ProfileFilter)

	// Streams
	source.Streams = genruntime.CloneSliceOfString(origin.Streams)

	// Update the property bag
	if len(propertyBag) > 0 {
		source.PropertyBag = propertyBag
	} else {
		source.PropertyBag = nil
	}

	// Invoke the augmentConversionForWindowsFirewallLogsDataSource_STATUS interface (if implemented) to customize the conversion
	var sourceAsAny any = source
	if augmentedSource, ok := sourceAsAny.(augmentConversionForWindowsFirewallLogsDataSource_STATUS); ok {
		err := augmentedSource.AssignPropertiesFrom(origin)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_WindowsFirewallLogsDataSource_STATUS populates the provided destination WindowsFirewallLogsDataSource_STATUS from our WindowsFirewallLogsDataSource_STATUS
func (source *WindowsFirewallLogsDataSource_STATUS) AssignProperties_To_WindowsFirewallLogsDataSource_STATUS(destination *v20240311s.WindowsFirewallLogsDataSource_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// ProfileFilter
	destination.ProfileFilter = genruntime.CloneSliceOfString(source.ProfileFilter)

	// Streams
	destination.Streams = genruntime.CloneSliceOfString(source.Streams)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForWindowsFirewallLogsDataSource_STATUS interface (if implemented) to customize the conversion
	var sourceAsAny any = source
	if augmentedSource, ok := sourceAsAny.(augmentConversionForWindowsFirewallLogsDataSource_STATUS); ok {
		err := augmentedSource.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForAdxDestination interface {
	AssignPropertiesFrom(src *v20240311s.AdxDestination) error
	AssignPropertiesTo(dst *v20240311s.AdxDestination) error
}

type augmentConversionForAdxDestination_STATUS interface {
	AssignPropertiesFrom(src *v20240311s.AdxDestination_STATUS) error
	AssignPropertiesTo(dst *v20240311s.AdxDestination_STATUS) error
}

type augmentConversionForAgentSetting interface {
	AssignPropertiesFrom(src *v20240311s.AgentSetting) error
	AssignPropertiesTo(dst *v20240311s.AgentSetting) error
}

type augmentConversionForAgentSetting_STATUS interface {
	AssignPropertiesFrom(src *v20240311s.AgentSetting_STATUS) error
	AssignPropertiesTo(dst *v20240311s.AgentSetting_STATUS) error
}

type augmentConversionForAzureMonitorMetricsDestination interface {
	AssignPropertiesFrom(src *v20240311s.AzureMonitorMetricsDestination) error
	AssignPropertiesTo(dst *v20240311s.AzureMonitorMetricsDestination) error
}

type augmentConversionForAzureMonitorMetricsDestination_STATUS interface {
	AssignPropertiesFrom(src *v20240311s.AzureMonitorMetricsDestination_STATUS) error
	AssignPropertiesTo(dst *v20240311s.AzureMonitorMetricsDestination_STATUS) error
}

type augmentConversionForColumnDefinition interface {
	AssignPropertiesFrom(src *v20240311s.ColumnDefinition) error
	AssignPropertiesTo(dst *v20240311s.ColumnDefinition) error
}

type augmentConversionForColumnDefinition_STATUS interface {
	AssignPropertiesFrom(src *v20240311s.ColumnDefinition_STATUS) error
	AssignPropertiesTo(dst *v20240311s.ColumnDefinition_STATUS) error
}

type augmentConversionForDataImportSources interface {
	AssignPropertiesFrom(src *v20240311s.DataImportSources) error
	AssignPropertiesTo(dst *v20240311s.DataImportSources) error
}

type augmentConversionForDataImportSources_STATUS interface {
	AssignPropertiesFrom(src *v20240311s.DataImportSources_STATUS) error
	AssignPropertiesTo(dst *v20240311s.DataImportSources_STATUS) error
}

type augmentConversionForEnrichmentData interface {
	AssignPropertiesFrom(src *v20240311s.EnrichmentData) error
	AssignPropertiesTo(dst *v20240311s.EnrichmentData) error
}

type augmentConversionForEnrichmentData_STATUS interface {
	AssignPropertiesFrom(src *v20240311s.EnrichmentData_STATUS) error
	AssignPropertiesTo(dst *v20240311s.EnrichmentData_STATUS) error
}

type augmentConversionForEventHubDestination interface {
	AssignPropertiesFrom(src *v20240311s.EventHubDestination) error
	AssignPropertiesTo(dst *v20240311s.EventHubDestination) error
}

type augmentConversionForEventHubDestination_STATUS interface {
	AssignPropertiesFrom(src *v20240311s.EventHubDestination_STATUS) error
	AssignPropertiesTo(dst *v20240311s.EventHubDestination_STATUS) error
}

type augmentConversionForEventHubDirectDestination interface {
	AssignPropertiesFrom(src *v20240311s.EventHubDirectDestination) error
	AssignPropertiesTo(dst *v20240311s.EventHubDirectDestination) error
}

type augmentConversionForEventHubDirectDestination_STATUS interface {
	AssignPropertiesFrom(src *v20240311s.EventHubDirectDestination_STATUS) error
	AssignPropertiesTo(dst *v20240311s.EventHubDirectDestination_STATUS) error
}

type augmentConversionForExtensionDataSource interface {
	AssignPropertiesFrom(src *v20240311s.ExtensionDataSource) error
	AssignPropertiesTo(dst *v20240311s.ExtensionDataSource) error
}

type augmentConversionForExtensionDataSource_STATUS interface {
	AssignPropertiesFrom(src *v20240311s.ExtensionDataSource_STATUS) error
	AssignPropertiesTo(dst *v20240311s.ExtensionDataSource_STATUS) error
}

type augmentConversionForIisLogsDataSource interface {
	AssignPropertiesFrom(src *v20240311s.IisLogsDataSource) error
	AssignPropertiesTo(dst *v20240311s.IisLogsDataSource) error
}

type augmentConversionForIisLogsDataSource_STATUS interface {
	AssignPropertiesFrom(src *v20240311s.IisLogsDataSource_STATUS) error
	AssignPropertiesTo(dst *v20240311s.IisLogsDataSource_STATUS) error
}

type augmentConversionForLogAnalyticsDestination interface {
	AssignPropertiesFrom(src *v20240311s.LogAnalyticsDestination) error
	AssignPropertiesTo(dst *v20240311s.LogAnalyticsDestination) error
}

type augmentConversionForLogAnalyticsDestination_STATUS interface {
	AssignPropertiesFrom(src *v20240311s.LogAnalyticsDestination_STATUS) error
	AssignPropertiesTo(dst *v20240311s.LogAnalyticsDestination_STATUS) error
}

type augmentConversionForLogFilesDataSource interface {
	AssignPropertiesFrom(src *v20240311s.LogFilesDataSource) error
	AssignPropertiesTo(dst *v20240311s.LogFilesDataSource) error
}

type augmentConversionForLogFilesDataSource_STATUS interface {
	AssignPropertiesFrom(src *v20240311s.LogFilesDataSource_STATUS) error
	AssignPropertiesTo(dst *v20240311s.LogFilesDataSource_STATUS) error
}

type augmentConversionForMicrosoftFabricDestination interface {
	AssignPropertiesFrom(src *v20240311s.MicrosoftFabricDestination) error
	AssignPropertiesTo(dst *v20240311s.MicrosoftFabricDestination) error
}

type augmentConversionForMicrosoftFabricDestination_STATUS interface {
	AssignPropertiesFrom(src *v20240311s.MicrosoftFabricDestination_STATUS) error
	AssignPropertiesTo(dst *v20240311s.MicrosoftFabricDestination_STATUS) error
}

type augmentConversionForMonitoringAccountDestination interface {
	AssignPropertiesFrom(src *v20240311s.MonitoringAccountDestination) error
	AssignPropertiesTo(dst *v20240311s.MonitoringAccountDestination) error
}

type augmentConversionForMonitoringAccountDestination_STATUS interface {
	AssignPropertiesFrom(src *v20240311s.MonitoringAccountDestination_STATUS) error
	AssignPropertiesTo(dst *v20240311s.MonitoringAccountDestination_STATUS) error
}

type augmentConversionForPerfCounterDataSource interface {
	AssignPropertiesFrom(src *v20240311s.PerfCounterDataSource) error
	AssignPropertiesTo(dst *v20240311s.PerfCounterDataSource) error
}

type augmentConversionForPerfCounterDataSource_STATUS interface {
	AssignPropertiesFrom(src *v20240311s.PerfCounterDataSource_STATUS) error
	AssignPropertiesTo(dst *v20240311s.PerfCounterDataSource_STATUS) error
}

type augmentConversionForPlatformTelemetryDataSource interface {
	AssignPropertiesFrom(src *v20240311s.PlatformTelemetryDataSource) error
	AssignPropertiesTo(dst *v20240311s.PlatformTelemetryDataSource) error
}

type augmentConversionForPlatformTelemetryDataSource_STATUS interface {
	AssignPropertiesFrom(src *v20240311s.PlatformTelemetryDataSource_STATUS) error
	AssignPropertiesTo(dst *v20240311s.PlatformTelemetryDataSource_STATUS) error
}

type augmentConversionForPrometheusForwarderDataSource interface {
	AssignPropertiesFrom(src *v20240311s.PrometheusForwarderDataSource) error
	AssignPropertiesTo(dst *v20240311s.PrometheusForwarderDataSource) error
}

type augmentConversionForPrometheusForwarderDataSource_STATUS interface {
	AssignPropertiesFrom(src *v20240311s.PrometheusForwarderDataSource_STATUS) error
	AssignPropertiesTo(dst *v20240311s.PrometheusForwarderDataSource_STATUS) error
}

type augmentConversionForStorageBlobDestination interface {
	AssignPropertiesFrom(src *v20240311s.StorageBlobDestination) error
	AssignPropertiesTo(dst *v20240311s.StorageBlobDestination) error
}

type augmentConversionForStorageBlobDestination_STATUS interface {
	AssignPropertiesFrom(src *v20240311s.StorageBlobDestination_STATUS) error
	AssignPropertiesTo(dst *v20240311s.StorageBlobDestination_STATUS) error
}

type augmentConversionForStorageTableDestination interface {
	AssignPropertiesFrom(src *v20240311s.StorageTableDestination) error
	AssignPropertiesTo(dst *v20240311s.StorageTableDestination) error
}

type augmentConversionForStorageTableDestination_STATUS interface {
	AssignPropertiesFrom(src *v20240311s.StorageTableDestination_STATUS) error
	AssignPropertiesTo(dst *v20240311s.StorageTableDestination_STATUS) error
}

type augmentConversionForSyslogDataSource interface {
	AssignPropertiesFrom(src *v20240311s.SyslogDataSource) error
	AssignPropertiesTo(dst *v20240311s.SyslogDataSource) error
}

type augmentConversionForSyslogDataSource_STATUS interface {
	AssignPropertiesFrom(src *v20240311s.SyslogDataSource_STATUS) error
	AssignPropertiesTo(dst *v20240311s.SyslogDataSource_STATUS) error
}

type augmentConversionForWindowsEventLogDataSource interface {
	AssignPropertiesFrom(src *v20240311s.WindowsEventLogDataSource) error
	AssignPropertiesTo(dst *v20240311s.WindowsEventLogDataSource) error
}

type augmentConversionForWindowsEventLogDataSource_STATUS interface {
	AssignPropertiesFrom(src *v20240311s.WindowsEventLogDataSource_STATUS) error
	AssignPropertiesTo(dst *v20240311s.WindowsEventLogDataSource_STATUS) error
}

type augmentConversionForWindowsFirewallLogsDataSource interface {
	AssignPropertiesFrom(src *v20240311s.WindowsFirewallLogsDataSource) error
	AssignPropertiesTo(dst *v20240311s.WindowsFirewallLogsDataSource) error
}

type augmentConversionForWindowsFirewallLogsDataSource_STATUS interface {
	AssignPropertiesFrom(src *v20240311s.WindowsFirewallLogsDataSource_STATUS) error
	AssignPropertiesTo(dst *v20240311s.WindowsFirewallLogsDataSource_STATUS) error
}

// Storage version of v1api20230311.EventHubDataSource
type EventHubDataSource struct {
	ConsumerGroup *string                `json:"consumerGroup,omitempty"`
	Name          *string                `json:"name,omitempty"`
	PropertyBag   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Stream        *string                `json:"stream,omitempty"`
}

// AssignProperties_From_EventHubDataSource populates our EventHubDataSource from the provided source EventHubDataSource
func (source *EventHubDataSource) AssignProperties_From_EventHubDataSource(origin *v20240311s.EventHubDataSource) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(origin.PropertyBag)

	// ConsumerGroup
	source.ConsumerGroup = genruntime.ClonePointerToString(origin.ConsumerGroup)

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// Stream
	source.Stream = genruntime.ClonePointerToString(origin.Stream)

	// Update the property bag
	if len(propertyBag) > 0 {
		source.PropertyBag = propertyBag
	} else {
		source.PropertyBag = nil
	}

	// Invoke the augmentConversionForEventHubDataSource interface (if implemented) to customize the conversion
	var sourceAsAny any = source
	if augmentedSource, ok := sourceAsAny.(augmentConversionForEventHubDataSource); ok {
		err := augmentedSource.AssignPropertiesFrom(origin)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_EventHubDataSource populates the provided destination EventHubDataSource from our EventHubDataSource
func (source *EventHubDataSource) AssignProperties_To_EventHubDataSource(destination *v20240311s.EventHubDataSource) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ConsumerGroup
	destination.ConsumerGroup = genruntime.ClonePointerToString(source.ConsumerGroup)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// Stream
	destination.Stream = genruntime.ClonePointerToString(source.Stream)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForEventHubDataSource interface (if implemented) to customize the conversion
	var sourceAsAny any = source
	if augmentedSource, ok := sourceAsAny.(augmentConversionForEventHubDataSource); ok {
		err := augmentedSource.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.EventHubDataSource_STATUS
type EventHubDataSource_STATUS struct {
	ConsumerGroup *string                `json:"consumerGroup,omitempty"`
	Name          *string                `json:"name,omitempty"`
	PropertyBag   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Stream        *string                `json:"stream,omitempty"`
}

// AssignProperties_From_EventHubDataSource_STATUS populates our EventHubDataSource_STATUS from the provided source EventHubDataSource_STATUS
func (source *EventHubDataSource_STATUS) AssignProperties_From_EventHubDataSource_STATUS(origin *v20240311s.EventHubDataSource_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(origin.PropertyBag)

	// ConsumerGroup
	source.ConsumerGroup = genruntime.ClonePointerToString(origin.ConsumerGroup)

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// Stream
	source.Stream = genruntime.ClonePointerToString(origin.Stream)

	// Update the property bag
	if len(propertyBag) > 0 {
		source.PropertyBag = propertyBag
	} else {
		source.PropertyBag = nil
	}

	// Invoke the augmentConversionForEventHubDataSource_STATUS interface (if implemented) to customize the conversion
	var sourceAsAny any = source
	if augmentedSource, ok := sourceAsAny.(augmentConversionForEventHubDataSource_STATUS); ok {
		err := augmentedSource.AssignPropertiesFrom(origin)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_EventHubDataSource_STATUS populates the provided destination EventHubDataSource_STATUS from our EventHubDataSource_STATUS
func (source *EventHubDataSource_STATUS) AssignProperties_To_EventHubDataSource_STATUS(destination *v20240311s.EventHubDataSource_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ConsumerGroup
	destination.ConsumerGroup = genruntime.ClonePointerToString(source.ConsumerGroup)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// Stream
	destination.Stream = genruntime.ClonePointerToString(source.Stream)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForEventHubDataSource_STATUS interface (if implemented) to customize the conversion
	var sourceAsAny any = source
	if augmentedSource, ok := sourceAsAny.(augmentConversionForEventHubDataSource_STATUS); ok {
		err := augmentedSource.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.LogFileSettings
// Settings for different log file formats
type LogFileSettings struct {
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Text        *LogFileTextSettings   `json:"text,omitempty"`
}

// AssignProperties_From_LogFileSettings populates our LogFileSettings from the provided source LogFileSettings
func (settings *LogFileSettings) AssignProperties_From_LogFileSettings(source *v20240311s.LogFileSettings) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Text
	if source.Text != nil {
		var text LogFileTextSettings
		err := text.AssignProperties_From_LogFileTextSettings(source.Text)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_LogFileTextSettings() to populate field Text")
		}
		settings.Text = &text
	} else {
		settings.Text = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// Invoke the augmentConversionForLogFileSettings interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForLogFileSettings); ok {
		err := augmentedSettings.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_LogFileSettings populates the provided destination LogFileSettings from our LogFileSettings
func (settings *LogFileSettings) AssignProperties_To_LogFileSettings(destination *v20240311s.LogFileSettings) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// Text
	if settings.Text != nil {
		var text v20240311s.LogFileTextSettings
		err := settings.Text.AssignProperties_To_LogFileTextSettings(&text)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_LogFileTextSettings() to populate field Text")
		}
		destination.Text = &text
	} else {
		destination.Text = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForLogFileSettings interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForLogFileSettings); ok {
		err := augmentedSettings.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.LogFileSettings_STATUS
// Settings for different log file formats
type LogFileSettings_STATUS struct {
	PropertyBag genruntime.PropertyBag      `json:"$propertyBag,omitempty"`
	Text        *LogFileTextSettings_STATUS `json:"text,omitempty"`
}

// AssignProperties_From_LogFileSettings_STATUS populates our LogFileSettings_STATUS from the provided source LogFileSettings_STATUS
func (settings *LogFileSettings_STATUS) AssignProperties_From_LogFileSettings_STATUS(source *v20240311s.LogFileSettings_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Text
	if source.Text != nil {
		var text LogFileTextSettings_STATUS
		err := text.AssignProperties_From_LogFileTextSettings_STATUS(source.Text)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_LogFileTextSettings_STATUS() to populate field Text")
		}
		settings.Text = &text
	} else {
		settings.Text = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// Invoke the augmentConversionForLogFileSettings_STATUS interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForLogFileSettings_STATUS); ok {
		err := augmentedSettings.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_LogFileSettings_STATUS populates the provided destination LogFileSettings_STATUS from our LogFileSettings_STATUS
func (settings *LogFileSettings_STATUS) AssignProperties_To_LogFileSettings_STATUS(destination *v20240311s.LogFileSettings_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// Text
	if settings.Text != nil {
		var text v20240311s.LogFileTextSettings_STATUS
		err := settings.Text.AssignProperties_To_LogFileTextSettings_STATUS(&text)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_LogFileTextSettings_STATUS() to populate field Text")
		}
		destination.Text = &text
	} else {
		destination.Text = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForLogFileSettings_STATUS interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForLogFileSettings_STATUS); ok {
		err := augmentedSettings.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.StorageBlob
type StorageBlob struct {
	BlobUrl     *string                `json:"blobUrl,omitempty"`
	LookupType  *string                `json:"lookupType,omitempty"`
	Name        *string                `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`

	// ResourceReference: Resource Id of the storage account that hosts the blob
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceId" json:"resourceReference,omitempty"`
}

// AssignProperties_From_StorageBlob populates our StorageBlob from the provided source StorageBlob
func (blob *StorageBlob) AssignProperties_From_StorageBlob(source *v20240311s.StorageBlob) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// BlobUrl
	blob.BlobUrl = genruntime.ClonePointerToString(source.BlobUrl)

	// LookupType
	blob.LookupType = genruntime.ClonePointerToString(source.LookupType)

	// Name
	blob.Name = genruntime.ClonePointerToString(source.Name)

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		blob.ResourceReference = &resourceReference
	} else {
		blob.ResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		blob.PropertyBag = propertyBag
	} else {
		blob.PropertyBag = nil
	}

	// Invoke the augmentConversionForStorageBlob interface (if implemented) to customize the conversion
	var blobAsAny any = blob
	if augmentedBlob, ok := blobAsAny.(augmentConversionForStorageBlob); ok {
		err := augmentedBlob.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_StorageBlob populates the provided destination StorageBlob from our StorageBlob
func (blob *StorageBlob) AssignProperties_To_StorageBlob(destination *v20240311s.StorageBlob) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(blob.PropertyBag)

	// BlobUrl
	destination.BlobUrl = genruntime.ClonePointerToString(blob.BlobUrl)

	// LookupType
	destination.LookupType = genruntime.ClonePointerToString(blob.LookupType)

	// Name
	destination.Name = genruntime.ClonePointerToString(blob.Name)

	// ResourceReference
	if blob.ResourceReference != nil {
		resourceReference := blob.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForStorageBlob interface (if implemented) to customize the conversion
	var blobAsAny any = blob
	if augmentedBlob, ok := blobAsAny.(augmentConversionForStorageBlob); ok {
		err := augmentedBlob.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.StorageBlob_STATUS
type StorageBlob_STATUS struct {
	BlobUrl     *string                `json:"blobUrl,omitempty"`
	LookupType  *string                `json:"lookupType,omitempty"`
	Name        *string                `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	ResourceId  *string                `json:"resourceId,omitempty"`
}

// AssignProperties_From_StorageBlob_STATUS populates our StorageBlob_STATUS from the provided source StorageBlob_STATUS
func (blob *StorageBlob_STATUS) AssignProperties_From_StorageBlob_STATUS(source *v20240311s.StorageBlob_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// BlobUrl
	blob.BlobUrl = genruntime.ClonePointerToString(source.BlobUrl)

	// LookupType
	blob.LookupType = genruntime.ClonePointerToString(source.LookupType)

	// Name
	blob.Name = genruntime.ClonePointerToString(source.Name)

	// ResourceId
	blob.ResourceId = genruntime.ClonePointerToString(source.ResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		blob.PropertyBag = propertyBag
	} else {
		blob.PropertyBag = nil
	}

	// Invoke the augmentConversionForStorageBlob_STATUS interface (if implemented) to customize the conversion
	var blobAsAny any = blob
	if augmentedBlob, ok := blobAsAny.(augmentConversionForStorageBlob_STATUS); ok {
		err := augmentedBlob.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_StorageBlob_STATUS populates the provided destination StorageBlob_STATUS from our StorageBlob_STATUS
func (blob *StorageBlob_STATUS) AssignProperties_To_StorageBlob_STATUS(destination *v20240311s.StorageBlob_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(blob.PropertyBag)

	// BlobUrl
	destination.BlobUrl = genruntime.ClonePointerToString(blob.BlobUrl)

	// LookupType
	destination.LookupType = genruntime.ClonePointerToString(blob.LookupType)

	// Name
	destination.Name = genruntime.ClonePointerToString(blob.Name)

	// ResourceId
	destination.ResourceId = genruntime.ClonePointerToString(blob.ResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForStorageBlob_STATUS interface (if implemented) to customize the conversion
	var blobAsAny any = blob
	if augmentedBlob, ok := blobAsAny.(augmentConversionForStorageBlob_STATUS); ok {
		err := augmentedBlob.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForEventHubDataSource interface {
	AssignPropertiesFrom(src *v20240311s.EventHubDataSource) error
	AssignPropertiesTo(dst *v20240311s.EventHubDataSource) error
}

type augmentConversionForEventHubDataSource_STATUS interface {
	AssignPropertiesFrom(src *v20240311s.EventHubDataSource_STATUS) error
	AssignPropertiesTo(dst *v20240311s.EventHubDataSource_STATUS) error
}

type augmentConversionForLogFileSettings interface {
	AssignPropertiesFrom(src *v20240311s.LogFileSettings) error
	AssignPropertiesTo(dst *v20240311s.LogFileSettings) error
}

type augmentConversionForLogFileSettings_STATUS interface {
	AssignPropertiesFrom(src *v20240311s.LogFileSettings_STATUS) error
	AssignPropertiesTo(dst *v20240311s.LogFileSettings_STATUS) error
}

type augmentConversionForStorageBlob interface {
	AssignPropertiesFrom(src *v20240311s.StorageBlob) error
	AssignPropertiesTo(dst *v20240311s.StorageBlob) error
}

type augmentConversionForStorageBlob_STATUS interface {
	AssignPropertiesFrom(src *v20240311s.StorageBlob_STATUS) error
	AssignPropertiesTo(dst *v20240311s.StorageBlob_STATUS) error
}

// Storage version of v1api20230311.LogFileTextSettings
// Settings for text log files
type LogFileTextSettings struct {
	PropertyBag                genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	RecordStartTimestampFormat *string                `json:"recordStartTimestampFormat,omitempty"`
}

// AssignProperties_From_LogFileTextSettings populates our LogFileTextSettings from the provided source LogFileTextSettings
func (settings *LogFileTextSettings) AssignProperties_From_LogFileTextSettings(source *v20240311s.LogFileTextSettings) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// RecordStartTimestampFormat
	settings.RecordStartTimestampFormat = genruntime.ClonePointerToString(source.RecordStartTimestampFormat)

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// Invoke the augmentConversionForLogFileTextSettings interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForLogFileTextSettings); ok {
		err := augmentedSettings.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_LogFileTextSettings populates the provided destination LogFileTextSettings from our LogFileTextSettings
func (settings *LogFileTextSettings) AssignProperties_To_LogFileTextSettings(destination *v20240311s.LogFileTextSettings) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// RecordStartTimestampFormat
	destination.RecordStartTimestampFormat = genruntime.ClonePointerToString(settings.RecordStartTimestampFormat)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForLogFileTextSettings interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForLogFileTextSettings); ok {
		err := augmentedSettings.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230311.LogFileTextSettings_STATUS
// Settings for text log files
type LogFileTextSettings_STATUS struct {
	PropertyBag                genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	RecordStartTimestampFormat *string                `json:"recordStartTimestampFormat,omitempty"`
}

// AssignProperties_From_LogFileTextSettings_STATUS populates our LogFileTextSettings_STATUS from the provided source LogFileTextSettings_STATUS
func (settings *LogFileTextSettings_STATUS) AssignProperties_From_LogFileTextSettings_STATUS(source *v20240311s.LogFileTextSettings_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// RecordStartTimestampFormat
	settings.RecordStartTimestampFormat = genruntime.ClonePointerToString(source.RecordStartTimestampFormat)

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// Invoke the augmentConversionForLogFileTextSettings_STATUS interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForLogFileTextSettings_STATUS); ok {
		err := augmentedSettings.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_LogFileTextSettings_STATUS populates the provided destination LogFileTextSettings_STATUS from our LogFileTextSettings_STATUS
func (settings *LogFileTextSettings_STATUS) AssignProperties_To_LogFileTextSettings_STATUS(destination *v20240311s.LogFileTextSettings_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// RecordStartTimestampFormat
	destination.RecordStartTimestampFormat = genruntime.ClonePointerToString(settings.RecordStartTimestampFormat)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForLogFileTextSettings_STATUS interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForLogFileTextSettings_STATUS); ok {
		err := augmentedSettings.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForLogFileTextSettings interface {
	AssignPropertiesFrom(src *v20240311s.LogFileTextSettings) error
	AssignPropertiesTo(dst *v20240311s.LogFileTextSettings) error
}

type augmentConversionForLogFileTextSettings_STATUS interface {
	AssignPropertiesFrom(src *v20240311s.LogFileTextSettings_STATUS) error
	AssignPropertiesTo(dst *v20240311s.LogFileTextSettings_STATUS) error
}

func init() {
	SchemeBuilder.Register(&DataCollectionRule{}, &DataCollectionRuleList{})
}
