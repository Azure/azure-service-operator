// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20230311

import (
	"fmt"
	arm "github.com/Azure/azure-service-operator/v2/api/insights/v1api20230311/arm"
	storage "github.com/Azure/azure-service-operator/v2/api/insights/v1api20230311/storage"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/rotisserie/eris"
	"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /monitor/resource-manager/Microsoft.Insights/stable/2023-03-11/dataCollectionRules_API.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Insights/dataCollectionRules/{dataCollectionRuleName}
type DataCollectionRule struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              DataCollectionRule_Spec           `json:"spec,omitempty"`
	Status            DataCollectionRuleResource_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &DataCollectionRule{}

// GetConditions returns the conditions of the resource
func (rule *DataCollectionRule) GetConditions() conditions.Conditions {
	return rule.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (rule *DataCollectionRule) SetConditions(conditions conditions.Conditions) {
	rule.Status.Conditions = conditions
}

var _ conversion.Convertible = &DataCollectionRule{}

// ConvertFrom populates our DataCollectionRule from the provided hub DataCollectionRule
func (rule *DataCollectionRule) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*storage.DataCollectionRule)
	if !ok {
		return fmt.Errorf("expected insights/v1api20230311/storage/DataCollectionRule but received %T instead", hub)
	}

	return rule.AssignProperties_From_DataCollectionRule(source)
}

// ConvertTo populates the provided hub DataCollectionRule from our DataCollectionRule
func (rule *DataCollectionRule) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*storage.DataCollectionRule)
	if !ok {
		return fmt.Errorf("expected insights/v1api20230311/storage/DataCollectionRule but received %T instead", hub)
	}

	return rule.AssignProperties_To_DataCollectionRule(destination)
}

var _ configmaps.Exporter = &DataCollectionRule{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (rule *DataCollectionRule) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if rule.Spec.OperatorSpec == nil {
		return nil
	}
	return rule.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &DataCollectionRule{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (rule *DataCollectionRule) SecretDestinationExpressions() []*core.DestinationExpression {
	if rule.Spec.OperatorSpec == nil {
		return nil
	}
	return rule.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.ImportableResource = &DataCollectionRule{}

// InitializeSpec initializes the spec for this resource from the given status
func (rule *DataCollectionRule) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*DataCollectionRuleResource_STATUS); ok {
		return rule.Spec.Initialize_From_DataCollectionRuleResource_STATUS(s)
	}

	return fmt.Errorf("expected Status of type DataCollectionRuleResource_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &DataCollectionRule{}

// AzureName returns the Azure name of the resource
func (rule *DataCollectionRule) AzureName() string {
	return rule.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2023-03-11"
func (rule DataCollectionRule) GetAPIVersion() string {
	return "2023-03-11"
}

// GetResourceScope returns the scope of the resource
func (rule *DataCollectionRule) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (rule *DataCollectionRule) GetSpec() genruntime.ConvertibleSpec {
	return &rule.Spec
}

// GetStatus returns the status of this resource
func (rule *DataCollectionRule) GetStatus() genruntime.ConvertibleStatus {
	return &rule.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (rule *DataCollectionRule) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Insights/dataCollectionRules"
func (rule *DataCollectionRule) GetType() string {
	return "Microsoft.Insights/dataCollectionRules"
}

// NewEmptyStatus returns a new empty (blank) status
func (rule *DataCollectionRule) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &DataCollectionRuleResource_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (rule *DataCollectionRule) Owner() *genruntime.ResourceReference {
	if rule.Spec.Owner == nil {
		return nil
	}

	group, kind := genruntime.LookupOwnerGroupKind(rule.Spec)
	return rule.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (rule *DataCollectionRule) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*DataCollectionRuleResource_STATUS); ok {
		rule.Status = *st
		return nil
	}

	// Convert status to required version
	var st DataCollectionRuleResource_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return eris.Wrap(err, "failed to convert status")
	}

	rule.Status = st
	return nil
}

// AssignProperties_From_DataCollectionRule populates our DataCollectionRule from the provided source DataCollectionRule
func (rule *DataCollectionRule) AssignProperties_From_DataCollectionRule(source *storage.DataCollectionRule) error {

	// ObjectMeta
	rule.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec DataCollectionRule_Spec
	err := spec.AssignProperties_From_DataCollectionRule_Spec(&source.Spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_DataCollectionRule_Spec() to populate field Spec")
	}
	rule.Spec = spec

	// Status
	var status DataCollectionRuleResource_STATUS
	err = status.AssignProperties_From_DataCollectionRuleResource_STATUS(&source.Status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_DataCollectionRuleResource_STATUS() to populate field Status")
	}
	rule.Status = status

	// No error
	return nil
}

// AssignProperties_To_DataCollectionRule populates the provided destination DataCollectionRule from our DataCollectionRule
func (rule *DataCollectionRule) AssignProperties_To_DataCollectionRule(destination *storage.DataCollectionRule) error {

	// ObjectMeta
	destination.ObjectMeta = *rule.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.DataCollectionRule_Spec
	err := rule.Spec.AssignProperties_To_DataCollectionRule_Spec(&spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_DataCollectionRule_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.DataCollectionRuleResource_STATUS
	err = rule.Status.AssignProperties_To_DataCollectionRuleResource_STATUS(&status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_DataCollectionRuleResource_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (rule *DataCollectionRule) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: rule.Spec.OriginalVersion(),
		Kind:    "DataCollectionRule",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /monitor/resource-manager/Microsoft.Insights/stable/2023-03-11/dataCollectionRules_API.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Insights/dataCollectionRules/{dataCollectionRuleName}
type DataCollectionRuleList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []DataCollectionRule `json:"items"`
}

// +kubebuilder:validation:Enum={"2023-03-11"}
type APIVersion string

const APIVersion_Value = APIVersion("2023-03-11")

type DataCollectionRule_Spec struct {
	// AgentSettings: Agent settings used to modify agent behavior on a given host
	AgentSettings *AgentSettingsSpec `json:"agentSettings,omitempty"`

	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// DataCollectionEndpointReference: The resource ID of the data collection endpoint that this rule can be used with.
	DataCollectionEndpointReference *genruntime.ResourceReference `armReference:"DataCollectionEndpointId" json:"dataCollectionEndpointReference,omitempty"`

	// DataFlows: The specification of data flows.
	DataFlows []DataFlow `json:"dataFlows,omitempty"`

	// DataSources: The specification of data sources.
	// This property is optional and can be omitted if the rule is meant to be used via direct calls to the provisioned
	// endpoint.
	DataSources *DataSourcesSpec `json:"dataSources,omitempty"`

	// Description: Description of the data collection rule.
	Description *string `json:"description,omitempty"`

	// Destinations: The specification of destinations.
	Destinations *DestinationsSpec `json:"destinations,omitempty"`

	// Identity: Managed service identity of the resource.
	Identity *ManagedServiceIdentity `json:"identity,omitempty"`

	// Kind: The kind of the resource.
	Kind *DataCollectionRule_Kind_Spec `json:"kind,omitempty"`

	// +kubebuilder:validation:Required
	// Location: The geo-location where the resource lives.
	Location *string `json:"location,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *DataCollectionRuleOperatorSpec `json:"operatorSpec,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`

	// References: Defines all the references that may be used in other sections of the DCR
	References *ReferencesSpec `json:"references,omitempty"`

	// StreamDeclarations: Declaration of custom streams used in this rule.
	StreamDeclarations map[string]StreamDeclaration `json:"streamDeclarations,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`
}

var _ genruntime.ARMTransformer = &DataCollectionRule_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *DataCollectionRule_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &arm.DataCollectionRule_Spec{}

	// Set property "Identity":
	if rule.Identity != nil {
		identity_ARM, err := (*rule.Identity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := *identity_ARM.(*arm.ManagedServiceIdentity)
		result.Identity = &identity
	}

	// Set property "Kind":
	if rule.Kind != nil {
		var temp string
		temp = string(*rule.Kind)
		kind := arm.DataCollectionRule_Kind_Spec(temp)
		result.Kind = &kind
	}

	// Set property "Location":
	if rule.Location != nil {
		location := *rule.Location
		result.Location = &location
	}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if rule.AgentSettings != nil ||
		rule.DataCollectionEndpointReference != nil ||
		rule.DataFlows != nil ||
		rule.DataSources != nil ||
		rule.Description != nil ||
		rule.Destinations != nil ||
		rule.References != nil ||
		rule.StreamDeclarations != nil {
		result.Properties = &arm.DataCollectionRuleSpec{}
	}
	if rule.AgentSettings != nil {
		agentSettings_ARM, err := (*rule.AgentSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		agentSettings := *agentSettings_ARM.(*arm.AgentSettingsSpec)
		result.Properties.AgentSettings = &agentSettings
	}
	if rule.DataCollectionEndpointReference != nil {
		dataCollectionEndpointIdARMID, err := resolved.ResolvedReferences.Lookup(*rule.DataCollectionEndpointReference)
		if err != nil {
			return nil, err
		}
		dataCollectionEndpointId := dataCollectionEndpointIdARMID
		result.Properties.DataCollectionEndpointId = &dataCollectionEndpointId
	}
	for _, item := range rule.DataFlows {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.DataFlows = append(result.Properties.DataFlows, *item_ARM.(*arm.DataFlow))
	}
	if rule.DataSources != nil {
		dataSources_ARM, err := (*rule.DataSources).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		dataSources := *dataSources_ARM.(*arm.DataSourcesSpec)
		result.Properties.DataSources = &dataSources
	}
	if rule.Description != nil {
		description := *rule.Description
		result.Properties.Description = &description
	}
	if rule.Destinations != nil {
		destinations_ARM, err := (*rule.Destinations).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		destinations := *destinations_ARM.(*arm.DestinationsSpec)
		result.Properties.Destinations = &destinations
	}
	if rule.References != nil {
		references_ARM, err := (*rule.References).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		references := *references_ARM.(*arm.ReferencesSpec)
		result.Properties.References = &references
	}
	if rule.StreamDeclarations != nil {
		result.Properties.StreamDeclarations = make(map[string]arm.StreamDeclaration, len(rule.StreamDeclarations))
		for key, value := range rule.StreamDeclarations {
			value_ARM, err := value.ConvertToARM(resolved)
			if err != nil {
				return nil, err
			}
			result.Properties.StreamDeclarations[key] = *value_ARM.(*arm.StreamDeclaration)
		}
	}

	// Set property "Tags":
	if rule.Tags != nil {
		result.Tags = make(map[string]string, len(rule.Tags))
		for key, value := range rule.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *DataCollectionRule_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DataCollectionRule_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *DataCollectionRule_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DataCollectionRule_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DataCollectionRule_Spec, got %T", armInput)
	}

	// Set property "AgentSettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AgentSettings != nil {
			var agentSettings1 AgentSettingsSpec
			err := agentSettings1.PopulateFromARM(owner, *typedInput.Properties.AgentSettings)
			if err != nil {
				return err
			}
			agentSettings := agentSettings1
			rule.AgentSettings = &agentSettings
		}
	}

	// Set property "AzureName":
	rule.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// no assignment for property "DataCollectionEndpointReference"

	// Set property "DataFlows":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.DataFlows {
			var item1 DataFlow
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			rule.DataFlows = append(rule.DataFlows, item1)
		}
	}

	// Set property "DataSources":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DataSources != nil {
			var dataSources1 DataSourcesSpec
			err := dataSources1.PopulateFromARM(owner, *typedInput.Properties.DataSources)
			if err != nil {
				return err
			}
			dataSources := dataSources1
			rule.DataSources = &dataSources
		}
	}

	// Set property "Description":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Description != nil {
			description := *typedInput.Properties.Description
			rule.Description = &description
		}
	}

	// Set property "Destinations":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Destinations != nil {
			var destinations1 DestinationsSpec
			err := destinations1.PopulateFromARM(owner, *typedInput.Properties.Destinations)
			if err != nil {
				return err
			}
			destinations := destinations1
			rule.Destinations = &destinations
		}
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 ManagedServiceIdentity
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		rule.Identity = &identity
	}

	// Set property "Kind":
	if typedInput.Kind != nil {
		var temp string
		temp = string(*typedInput.Kind)
		kind := DataCollectionRule_Kind_Spec(temp)
		rule.Kind = &kind
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		rule.Location = &location
	}

	// no assignment for property "OperatorSpec"

	// Set property "Owner":
	rule.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "References":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.References != nil {
			var references1 ReferencesSpec
			err := references1.PopulateFromARM(owner, *typedInput.Properties.References)
			if err != nil {
				return err
			}
			references := references1
			rule.References = &references
		}
	}

	// Set property "StreamDeclarations":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.StreamDeclarations != nil {
			rule.StreamDeclarations = make(map[string]StreamDeclaration, len(typedInput.Properties.StreamDeclarations))
			for key, value := range typedInput.Properties.StreamDeclarations {
				var value1 StreamDeclaration
				err := value1.PopulateFromARM(owner, value)
				if err != nil {
					return err
				}
				rule.StreamDeclarations[key] = value1
			}
		}
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		rule.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			rule.Tags[key] = value
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &DataCollectionRule_Spec{}

// ConvertSpecFrom populates our DataCollectionRule_Spec from the provided source
func (rule *DataCollectionRule_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.DataCollectionRule_Spec)
	if ok {
		// Populate our instance from source
		return rule.AssignProperties_From_DataCollectionRule_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.DataCollectionRule_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = rule.AssignProperties_From_DataCollectionRule_Spec(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our DataCollectionRule_Spec
func (rule *DataCollectionRule_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.DataCollectionRule_Spec)
	if ok {
		// Populate destination from our instance
		return rule.AssignProperties_To_DataCollectionRule_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.DataCollectionRule_Spec{}
	err := rule.AssignProperties_To_DataCollectionRule_Spec(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_DataCollectionRule_Spec populates our DataCollectionRule_Spec from the provided source DataCollectionRule_Spec
func (rule *DataCollectionRule_Spec) AssignProperties_From_DataCollectionRule_Spec(source *storage.DataCollectionRule_Spec) error {

	// AgentSettings
	if source.AgentSettings != nil {
		var agentSetting AgentSettingsSpec
		err := agentSetting.AssignProperties_From_AgentSettingsSpec(source.AgentSettings)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AgentSettingsSpec() to populate field AgentSettings")
		}
		rule.AgentSettings = &agentSetting
	} else {
		rule.AgentSettings = nil
	}

	// AzureName
	rule.AzureName = source.AzureName

	// DataCollectionEndpointReference
	if source.DataCollectionEndpointReference != nil {
		dataCollectionEndpointReference := source.DataCollectionEndpointReference.Copy()
		rule.DataCollectionEndpointReference = &dataCollectionEndpointReference
	} else {
		rule.DataCollectionEndpointReference = nil
	}

	// DataFlows
	if source.DataFlows != nil {
		dataFlowList := make([]DataFlow, len(source.DataFlows))
		for dataFlowIndex, dataFlowItem := range source.DataFlows {
			// Shadow the loop variable to avoid aliasing
			dataFlowItem := dataFlowItem
			var dataFlow DataFlow
			err := dataFlow.AssignProperties_From_DataFlow(&dataFlowItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_DataFlow() to populate field DataFlows")
			}
			dataFlowList[dataFlowIndex] = dataFlow
		}
		rule.DataFlows = dataFlowList
	} else {
		rule.DataFlows = nil
	}

	// DataSources
	if source.DataSources != nil {
		var dataSource DataSourcesSpec
		err := dataSource.AssignProperties_From_DataSourcesSpec(source.DataSources)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DataSourcesSpec() to populate field DataSources")
		}
		rule.DataSources = &dataSource
	} else {
		rule.DataSources = nil
	}

	// Description
	rule.Description = genruntime.ClonePointerToString(source.Description)

	// Destinations
	if source.Destinations != nil {
		var destination DestinationsSpec
		err := destination.AssignProperties_From_DestinationsSpec(source.Destinations)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DestinationsSpec() to populate field Destinations")
		}
		rule.Destinations = &destination
	} else {
		rule.Destinations = nil
	}

	// Identity
	if source.Identity != nil {
		var identity ManagedServiceIdentity
		err := identity.AssignProperties_From_ManagedServiceIdentity(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedServiceIdentity() to populate field Identity")
		}
		rule.Identity = &identity
	} else {
		rule.Identity = nil
	}

	// Kind
	if source.Kind != nil {
		kind := *source.Kind
		kindTemp := genruntime.ToEnum(kind, dataCollectionRule_Kind_Spec_Values)
		rule.Kind = &kindTemp
	} else {
		rule.Kind = nil
	}

	// Location
	rule.Location = genruntime.ClonePointerToString(source.Location)

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec DataCollectionRuleOperatorSpec
		err := operatorSpec.AssignProperties_From_DataCollectionRuleOperatorSpec(source.OperatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DataCollectionRuleOperatorSpec() to populate field OperatorSpec")
		}
		rule.OperatorSpec = &operatorSpec
	} else {
		rule.OperatorSpec = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		rule.Owner = &owner
	} else {
		rule.Owner = nil
	}

	// References
	if source.References != nil {
		var reference ReferencesSpec
		err := reference.AssignProperties_From_ReferencesSpec(source.References)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ReferencesSpec() to populate field References")
		}
		rule.References = &reference
	} else {
		rule.References = nil
	}

	// StreamDeclarations
	if source.StreamDeclarations != nil {
		streamDeclarationMap := make(map[string]StreamDeclaration, len(source.StreamDeclarations))
		for streamDeclarationKey, streamDeclarationValue := range source.StreamDeclarations {
			// Shadow the loop variable to avoid aliasing
			streamDeclarationValue := streamDeclarationValue
			var streamDeclaration StreamDeclaration
			err := streamDeclaration.AssignProperties_From_StreamDeclaration(&streamDeclarationValue)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_StreamDeclaration() to populate field StreamDeclarations")
			}
			streamDeclarationMap[streamDeclarationKey] = streamDeclaration
		}
		rule.StreamDeclarations = streamDeclarationMap
	} else {
		rule.StreamDeclarations = nil
	}

	// Tags
	rule.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// AssignProperties_To_DataCollectionRule_Spec populates the provided destination DataCollectionRule_Spec from our DataCollectionRule_Spec
func (rule *DataCollectionRule_Spec) AssignProperties_To_DataCollectionRule_Spec(destination *storage.DataCollectionRule_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AgentSettings
	if rule.AgentSettings != nil {
		var agentSetting storage.AgentSettingsSpec
		err := rule.AgentSettings.AssignProperties_To_AgentSettingsSpec(&agentSetting)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AgentSettingsSpec() to populate field AgentSettings")
		}
		destination.AgentSettings = &agentSetting
	} else {
		destination.AgentSettings = nil
	}

	// AzureName
	destination.AzureName = rule.AzureName

	// DataCollectionEndpointReference
	if rule.DataCollectionEndpointReference != nil {
		dataCollectionEndpointReference := rule.DataCollectionEndpointReference.Copy()
		destination.DataCollectionEndpointReference = &dataCollectionEndpointReference
	} else {
		destination.DataCollectionEndpointReference = nil
	}

	// DataFlows
	if rule.DataFlows != nil {
		dataFlowList := make([]storage.DataFlow, len(rule.DataFlows))
		for dataFlowIndex, dataFlowItem := range rule.DataFlows {
			// Shadow the loop variable to avoid aliasing
			dataFlowItem := dataFlowItem
			var dataFlow storage.DataFlow
			err := dataFlowItem.AssignProperties_To_DataFlow(&dataFlow)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_DataFlow() to populate field DataFlows")
			}
			dataFlowList[dataFlowIndex] = dataFlow
		}
		destination.DataFlows = dataFlowList
	} else {
		destination.DataFlows = nil
	}

	// DataSources
	if rule.DataSources != nil {
		var dataSource storage.DataSourcesSpec
		err := rule.DataSources.AssignProperties_To_DataSourcesSpec(&dataSource)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DataSourcesSpec() to populate field DataSources")
		}
		destination.DataSources = &dataSource
	} else {
		destination.DataSources = nil
	}

	// Description
	destination.Description = genruntime.ClonePointerToString(rule.Description)

	// Destinations
	if rule.Destinations != nil {
		var destinationLocal storage.DestinationsSpec
		err := rule.Destinations.AssignProperties_To_DestinationsSpec(&destinationLocal)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DestinationsSpec() to populate field Destinations")
		}
		destination.Destinations = &destinationLocal
	} else {
		destination.Destinations = nil
	}

	// Identity
	if rule.Identity != nil {
		var identity storage.ManagedServiceIdentity
		err := rule.Identity.AssignProperties_To_ManagedServiceIdentity(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedServiceIdentity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Kind
	if rule.Kind != nil {
		kind := string(*rule.Kind)
		destination.Kind = &kind
	} else {
		destination.Kind = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(rule.Location)

	// OperatorSpec
	if rule.OperatorSpec != nil {
		var operatorSpec storage.DataCollectionRuleOperatorSpec
		err := rule.OperatorSpec.AssignProperties_To_DataCollectionRuleOperatorSpec(&operatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DataCollectionRuleOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = rule.OriginalVersion()

	// Owner
	if rule.Owner != nil {
		owner := rule.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// References
	if rule.References != nil {
		var reference storage.ReferencesSpec
		err := rule.References.AssignProperties_To_ReferencesSpec(&reference)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ReferencesSpec() to populate field References")
		}
		destination.References = &reference
	} else {
		destination.References = nil
	}

	// StreamDeclarations
	if rule.StreamDeclarations != nil {
		streamDeclarationMap := make(map[string]storage.StreamDeclaration, len(rule.StreamDeclarations))
		for streamDeclarationKey, streamDeclarationValue := range rule.StreamDeclarations {
			// Shadow the loop variable to avoid aliasing
			streamDeclarationValue := streamDeclarationValue
			var streamDeclaration storage.StreamDeclaration
			err := streamDeclarationValue.AssignProperties_To_StreamDeclaration(&streamDeclaration)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_StreamDeclaration() to populate field StreamDeclarations")
			}
			streamDeclarationMap[streamDeclarationKey] = streamDeclaration
		}
		destination.StreamDeclarations = streamDeclarationMap
	} else {
		destination.StreamDeclarations = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(rule.Tags)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DataCollectionRuleResource_STATUS populates our DataCollectionRule_Spec from the provided source DataCollectionRuleResource_STATUS
func (rule *DataCollectionRule_Spec) Initialize_From_DataCollectionRuleResource_STATUS(source *DataCollectionRuleResource_STATUS) error {

	// AgentSettings
	if source.AgentSettings != nil {
		var agentSetting AgentSettingsSpec
		err := agentSetting.Initialize_From_AgentSettingsSpec_STATUS(source.AgentSettings)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_AgentSettingsSpec_STATUS() to populate field AgentSettings")
		}
		rule.AgentSettings = &agentSetting
	} else {
		rule.AgentSettings = nil
	}

	// DataCollectionEndpointReference
	if source.DataCollectionEndpointId != nil {
		dataCollectionEndpointReference := genruntime.CreateResourceReferenceFromARMID(*source.DataCollectionEndpointId)
		rule.DataCollectionEndpointReference = &dataCollectionEndpointReference
	} else {
		rule.DataCollectionEndpointReference = nil
	}

	// DataFlows
	if source.DataFlows != nil {
		dataFlowList := make([]DataFlow, len(source.DataFlows))
		for dataFlowIndex, dataFlowItem := range source.DataFlows {
			// Shadow the loop variable to avoid aliasing
			dataFlowItem := dataFlowItem
			var dataFlow DataFlow
			err := dataFlow.Initialize_From_DataFlow_STATUS(&dataFlowItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_DataFlow_STATUS() to populate field DataFlows")
			}
			dataFlowList[dataFlowIndex] = dataFlow
		}
		rule.DataFlows = dataFlowList
	} else {
		rule.DataFlows = nil
	}

	// DataSources
	if source.DataSources != nil {
		var dataSource DataSourcesSpec
		err := dataSource.Initialize_From_DataSourcesSpec_STATUS(source.DataSources)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_DataSourcesSpec_STATUS() to populate field DataSources")
		}
		rule.DataSources = &dataSource
	} else {
		rule.DataSources = nil
	}

	// Description
	rule.Description = genruntime.ClonePointerToString(source.Description)

	// Destinations
	if source.Destinations != nil {
		var destination DestinationsSpec
		err := destination.Initialize_From_DestinationsSpec_STATUS(source.Destinations)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_DestinationsSpec_STATUS() to populate field Destinations")
		}
		rule.Destinations = &destination
	} else {
		rule.Destinations = nil
	}

	// Identity
	if source.Identity != nil {
		var identity ManagedServiceIdentity
		err := identity.Initialize_From_ManagedServiceIdentity_STATUS(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ManagedServiceIdentity_STATUS() to populate field Identity")
		}
		rule.Identity = &identity
	} else {
		rule.Identity = nil
	}

	// Kind
	if source.Kind != nil {
		kind := genruntime.ToEnum(string(*source.Kind), dataCollectionRule_Kind_Spec_Values)
		rule.Kind = &kind
	} else {
		rule.Kind = nil
	}

	// Location
	rule.Location = genruntime.ClonePointerToString(source.Location)

	// References
	if source.References != nil {
		var reference ReferencesSpec
		err := reference.Initialize_From_ReferencesSpec_STATUS(source.References)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ReferencesSpec_STATUS() to populate field References")
		}
		rule.References = &reference
	} else {
		rule.References = nil
	}

	// StreamDeclarations
	if source.StreamDeclarations != nil {
		streamDeclarationMap := make(map[string]StreamDeclaration, len(source.StreamDeclarations))
		for streamDeclarationKey, streamDeclarationValue := range source.StreamDeclarations {
			// Shadow the loop variable to avoid aliasing
			streamDeclarationValue := streamDeclarationValue
			var streamDeclaration StreamDeclaration
			err := streamDeclaration.Initialize_From_StreamDeclaration_STATUS(&streamDeclarationValue)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_StreamDeclaration_STATUS() to populate field StreamDeclarations")
			}
			streamDeclarationMap[streamDeclarationKey] = streamDeclaration
		}
		rule.StreamDeclarations = streamDeclarationMap
	} else {
		rule.StreamDeclarations = nil
	}

	// Tags
	rule.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (rule *DataCollectionRule_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (rule *DataCollectionRule_Spec) SetAzureName(azureName string) { rule.AzureName = azureName }

// Definition of ARM tracked top level resource.
type DataCollectionRuleResource_STATUS struct {
	// AgentSettings: Agent settings used to modify agent behavior on a given host
	AgentSettings *AgentSettingsSpec_STATUS `json:"agentSettings,omitempty"`

	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// DataCollectionEndpointId: The resource ID of the data collection endpoint that this rule can be used with.
	DataCollectionEndpointId *string `json:"dataCollectionEndpointId,omitempty"`

	// DataFlows: The specification of data flows.
	DataFlows []DataFlow_STATUS `json:"dataFlows,omitempty"`

	// DataSources: The specification of data sources.
	// This property is optional and can be omitted if the rule is meant to be used via direct calls to the provisioned
	// endpoint.
	DataSources *DataSourcesSpec_STATUS `json:"dataSources,omitempty"`

	// Description: Description of the data collection rule.
	Description *string `json:"description,omitempty"`

	// Destinations: The specification of destinations.
	Destinations *DestinationsSpec_STATUS `json:"destinations,omitempty"`

	// Endpoints: Defines the ingestion endpoints to send data to via this rule.
	Endpoints *EndpointsSpec_STATUS `json:"endpoints,omitempty"`

	// Etag: Resource entity tag (ETag).
	Etag *string `json:"etag,omitempty"`

	// Id: Fully qualified ID of the resource.
	Id *string `json:"id,omitempty"`

	// Identity: Managed service identity of the resource.
	Identity *ManagedServiceIdentity_STATUS `json:"identity,omitempty"`

	// ImmutableId: The immutable ID of this data collection rule. This property is READ-ONLY.
	ImmutableId *string `json:"immutableId,omitempty"`

	// Kind: The kind of the resource.
	Kind *DataCollectionRuleResource_Kind_STATUS `json:"kind,omitempty"`

	// Location: The geo-location where the resource lives.
	Location *string `json:"location,omitempty"`

	// Metadata: Metadata about the resource
	Metadata *Metadata_STATUS `json:"metadata,omitempty"`

	// Name: The name of the resource.
	Name *string `json:"name,omitempty"`

	// ProvisioningState: The resource provisioning state.
	ProvisioningState *DataCollectionRule_ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// References: Defines all the references that may be used in other sections of the DCR
	References *ReferencesSpec_STATUS `json:"references,omitempty"`

	// StreamDeclarations: Declaration of custom streams used in this rule.
	StreamDeclarations map[string]StreamDeclaration_STATUS `json:"streamDeclarations,omitempty"`

	// SystemData: Metadata pertaining to creation and last modification of the resource.
	SystemData *SystemData_STATUS `json:"systemData,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// Type: The type of the resource.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &DataCollectionRuleResource_STATUS{}

// ConvertStatusFrom populates our DataCollectionRuleResource_STATUS from the provided source
func (resource *DataCollectionRuleResource_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.DataCollectionRuleResource_STATUS)
	if ok {
		// Populate our instance from source
		return resource.AssignProperties_From_DataCollectionRuleResource_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.DataCollectionRuleResource_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = resource.AssignProperties_From_DataCollectionRuleResource_STATUS(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our DataCollectionRuleResource_STATUS
func (resource *DataCollectionRuleResource_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.DataCollectionRuleResource_STATUS)
	if ok {
		// Populate destination from our instance
		return resource.AssignProperties_To_DataCollectionRuleResource_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.DataCollectionRuleResource_STATUS{}
	err := resource.AssignProperties_To_DataCollectionRuleResource_STATUS(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &DataCollectionRuleResource_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resource *DataCollectionRuleResource_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DataCollectionRuleResource_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resource *DataCollectionRuleResource_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DataCollectionRuleResource_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DataCollectionRuleResource_STATUS, got %T", armInput)
	}

	// Set property "AgentSettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AgentSettings != nil {
			var agentSettings1 AgentSettingsSpec_STATUS
			err := agentSettings1.PopulateFromARM(owner, *typedInput.Properties.AgentSettings)
			if err != nil {
				return err
			}
			agentSettings := agentSettings1
			resource.AgentSettings = &agentSettings
		}
	}

	// no assignment for property "Conditions"

	// Set property "DataCollectionEndpointId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DataCollectionEndpointId != nil {
			dataCollectionEndpointId := *typedInput.Properties.DataCollectionEndpointId
			resource.DataCollectionEndpointId = &dataCollectionEndpointId
		}
	}

	// Set property "DataFlows":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.DataFlows {
			var item1 DataFlow_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			resource.DataFlows = append(resource.DataFlows, item1)
		}
	}

	// Set property "DataSources":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DataSources != nil {
			var dataSources1 DataSourcesSpec_STATUS
			err := dataSources1.PopulateFromARM(owner, *typedInput.Properties.DataSources)
			if err != nil {
				return err
			}
			dataSources := dataSources1
			resource.DataSources = &dataSources
		}
	}

	// Set property "Description":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Description != nil {
			description := *typedInput.Properties.Description
			resource.Description = &description
		}
	}

	// Set property "Destinations":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Destinations != nil {
			var destinations1 DestinationsSpec_STATUS
			err := destinations1.PopulateFromARM(owner, *typedInput.Properties.Destinations)
			if err != nil {
				return err
			}
			destinations := destinations1
			resource.Destinations = &destinations
		}
	}

	// Set property "Endpoints":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Endpoints != nil {
			var endpoints1 EndpointsSpec_STATUS
			err := endpoints1.PopulateFromARM(owner, *typedInput.Properties.Endpoints)
			if err != nil {
				return err
			}
			endpoints := endpoints1
			resource.Endpoints = &endpoints
		}
	}

	// Set property "Etag":
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		resource.Etag = &etag
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		resource.Id = &id
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 ManagedServiceIdentity_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		resource.Identity = &identity
	}

	// Set property "ImmutableId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ImmutableId != nil {
			immutableId := *typedInput.Properties.ImmutableId
			resource.ImmutableId = &immutableId
		}
	}

	// Set property "Kind":
	if typedInput.Kind != nil {
		var temp string
		temp = string(*typedInput.Kind)
		kind := DataCollectionRuleResource_Kind_STATUS(temp)
		resource.Kind = &kind
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		resource.Location = &location
	}

	// Set property "Metadata":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Metadata != nil {
			var metadata1 Metadata_STATUS
			err := metadata1.PopulateFromARM(owner, *typedInput.Properties.Metadata)
			if err != nil {
				return err
			}
			metadata := metadata1
			resource.Metadata = &metadata
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		resource.Name = &name
	}

	// Set property "ProvisioningState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			var temp string
			temp = string(*typedInput.Properties.ProvisioningState)
			provisioningState := DataCollectionRule_ProvisioningState_STATUS(temp)
			resource.ProvisioningState = &provisioningState
		}
	}

	// Set property "References":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.References != nil {
			var references1 ReferencesSpec_STATUS
			err := references1.PopulateFromARM(owner, *typedInput.Properties.References)
			if err != nil {
				return err
			}
			references := references1
			resource.References = &references
		}
	}

	// Set property "StreamDeclarations":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.StreamDeclarations != nil {
			resource.StreamDeclarations = make(map[string]StreamDeclaration_STATUS, len(typedInput.Properties.StreamDeclarations))
			for key, value := range typedInput.Properties.StreamDeclarations {
				var value1 StreamDeclaration_STATUS
				err := value1.PopulateFromARM(owner, value)
				if err != nil {
					return err
				}
				resource.StreamDeclarations[key] = value1
			}
		}
	}

	// Set property "SystemData":
	if typedInput.SystemData != nil {
		var systemData1 SystemData_STATUS
		err := systemData1.PopulateFromARM(owner, *typedInput.SystemData)
		if err != nil {
			return err
		}
		systemData := systemData1
		resource.SystemData = &systemData
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		resource.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			resource.Tags[key] = value
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		resource.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_DataCollectionRuleResource_STATUS populates our DataCollectionRuleResource_STATUS from the provided source DataCollectionRuleResource_STATUS
func (resource *DataCollectionRuleResource_STATUS) AssignProperties_From_DataCollectionRuleResource_STATUS(source *storage.DataCollectionRuleResource_STATUS) error {

	// AgentSettings
	if source.AgentSettings != nil {
		var agentSetting AgentSettingsSpec_STATUS
		err := agentSetting.AssignProperties_From_AgentSettingsSpec_STATUS(source.AgentSettings)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AgentSettingsSpec_STATUS() to populate field AgentSettings")
		}
		resource.AgentSettings = &agentSetting
	} else {
		resource.AgentSettings = nil
	}

	// Conditions
	resource.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// DataCollectionEndpointId
	resource.DataCollectionEndpointId = genruntime.ClonePointerToString(source.DataCollectionEndpointId)

	// DataFlows
	if source.DataFlows != nil {
		dataFlowList := make([]DataFlow_STATUS, len(source.DataFlows))
		for dataFlowIndex, dataFlowItem := range source.DataFlows {
			// Shadow the loop variable to avoid aliasing
			dataFlowItem := dataFlowItem
			var dataFlow DataFlow_STATUS
			err := dataFlow.AssignProperties_From_DataFlow_STATUS(&dataFlowItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_DataFlow_STATUS() to populate field DataFlows")
			}
			dataFlowList[dataFlowIndex] = dataFlow
		}
		resource.DataFlows = dataFlowList
	} else {
		resource.DataFlows = nil
	}

	// DataSources
	if source.DataSources != nil {
		var dataSource DataSourcesSpec_STATUS
		err := dataSource.AssignProperties_From_DataSourcesSpec_STATUS(source.DataSources)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DataSourcesSpec_STATUS() to populate field DataSources")
		}
		resource.DataSources = &dataSource
	} else {
		resource.DataSources = nil
	}

	// Description
	resource.Description = genruntime.ClonePointerToString(source.Description)

	// Destinations
	if source.Destinations != nil {
		var destination DestinationsSpec_STATUS
		err := destination.AssignProperties_From_DestinationsSpec_STATUS(source.Destinations)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DestinationsSpec_STATUS() to populate field Destinations")
		}
		resource.Destinations = &destination
	} else {
		resource.Destinations = nil
	}

	// Endpoints
	if source.Endpoints != nil {
		var endpoint EndpointsSpec_STATUS
		err := endpoint.AssignProperties_From_EndpointsSpec_STATUS(source.Endpoints)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_EndpointsSpec_STATUS() to populate field Endpoints")
		}
		resource.Endpoints = &endpoint
	} else {
		resource.Endpoints = nil
	}

	// Etag
	resource.Etag = genruntime.ClonePointerToString(source.Etag)

	// Id
	resource.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity ManagedServiceIdentity_STATUS
		err := identity.AssignProperties_From_ManagedServiceIdentity_STATUS(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedServiceIdentity_STATUS() to populate field Identity")
		}
		resource.Identity = &identity
	} else {
		resource.Identity = nil
	}

	// ImmutableId
	resource.ImmutableId = genruntime.ClonePointerToString(source.ImmutableId)

	// Kind
	if source.Kind != nil {
		kind := *source.Kind
		kindTemp := genruntime.ToEnum(kind, dataCollectionRuleResource_Kind_STATUS_Values)
		resource.Kind = &kindTemp
	} else {
		resource.Kind = nil
	}

	// Location
	resource.Location = genruntime.ClonePointerToString(source.Location)

	// Metadata
	if source.Metadata != nil {
		var metadatum Metadata_STATUS
		err := metadatum.AssignProperties_From_Metadata_STATUS(source.Metadata)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Metadata_STATUS() to populate field Metadata")
		}
		resource.Metadata = &metadatum
	} else {
		resource.Metadata = nil
	}

	// Name
	resource.Name = genruntime.ClonePointerToString(source.Name)

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, dataCollectionRule_ProvisioningState_STATUS_Values)
		resource.ProvisioningState = &provisioningStateTemp
	} else {
		resource.ProvisioningState = nil
	}

	// References
	if source.References != nil {
		var reference ReferencesSpec_STATUS
		err := reference.AssignProperties_From_ReferencesSpec_STATUS(source.References)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ReferencesSpec_STATUS() to populate field References")
		}
		resource.References = &reference
	} else {
		resource.References = nil
	}

	// StreamDeclarations
	if source.StreamDeclarations != nil {
		streamDeclarationMap := make(map[string]StreamDeclaration_STATUS, len(source.StreamDeclarations))
		for streamDeclarationKey, streamDeclarationValue := range source.StreamDeclarations {
			// Shadow the loop variable to avoid aliasing
			streamDeclarationValue := streamDeclarationValue
			var streamDeclaration StreamDeclaration_STATUS
			err := streamDeclaration.AssignProperties_From_StreamDeclaration_STATUS(&streamDeclarationValue)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_StreamDeclaration_STATUS() to populate field StreamDeclarations")
			}
			streamDeclarationMap[streamDeclarationKey] = streamDeclaration
		}
		resource.StreamDeclarations = streamDeclarationMap
	} else {
		resource.StreamDeclarations = nil
	}

	// SystemData
	if source.SystemData != nil {
		var systemDatum SystemData_STATUS
		err := systemDatum.AssignProperties_From_SystemData_STATUS(source.SystemData)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SystemData_STATUS() to populate field SystemData")
		}
		resource.SystemData = &systemDatum
	} else {
		resource.SystemData = nil
	}

	// Tags
	resource.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	resource.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_DataCollectionRuleResource_STATUS populates the provided destination DataCollectionRuleResource_STATUS from our DataCollectionRuleResource_STATUS
func (resource *DataCollectionRuleResource_STATUS) AssignProperties_To_DataCollectionRuleResource_STATUS(destination *storage.DataCollectionRuleResource_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AgentSettings
	if resource.AgentSettings != nil {
		var agentSetting storage.AgentSettingsSpec_STATUS
		err := resource.AgentSettings.AssignProperties_To_AgentSettingsSpec_STATUS(&agentSetting)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AgentSettingsSpec_STATUS() to populate field AgentSettings")
		}
		destination.AgentSettings = &agentSetting
	} else {
		destination.AgentSettings = nil
	}

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(resource.Conditions)

	// DataCollectionEndpointId
	destination.DataCollectionEndpointId = genruntime.ClonePointerToString(resource.DataCollectionEndpointId)

	// DataFlows
	if resource.DataFlows != nil {
		dataFlowList := make([]storage.DataFlow_STATUS, len(resource.DataFlows))
		for dataFlowIndex, dataFlowItem := range resource.DataFlows {
			// Shadow the loop variable to avoid aliasing
			dataFlowItem := dataFlowItem
			var dataFlow storage.DataFlow_STATUS
			err := dataFlowItem.AssignProperties_To_DataFlow_STATUS(&dataFlow)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_DataFlow_STATUS() to populate field DataFlows")
			}
			dataFlowList[dataFlowIndex] = dataFlow
		}
		destination.DataFlows = dataFlowList
	} else {
		destination.DataFlows = nil
	}

	// DataSources
	if resource.DataSources != nil {
		var dataSource storage.DataSourcesSpec_STATUS
		err := resource.DataSources.AssignProperties_To_DataSourcesSpec_STATUS(&dataSource)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DataSourcesSpec_STATUS() to populate field DataSources")
		}
		destination.DataSources = &dataSource
	} else {
		destination.DataSources = nil
	}

	// Description
	destination.Description = genruntime.ClonePointerToString(resource.Description)

	// Destinations
	if resource.Destinations != nil {
		var destinationLocal storage.DestinationsSpec_STATUS
		err := resource.Destinations.AssignProperties_To_DestinationsSpec_STATUS(&destinationLocal)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DestinationsSpec_STATUS() to populate field Destinations")
		}
		destination.Destinations = &destinationLocal
	} else {
		destination.Destinations = nil
	}

	// Endpoints
	if resource.Endpoints != nil {
		var endpoint storage.EndpointsSpec_STATUS
		err := resource.Endpoints.AssignProperties_To_EndpointsSpec_STATUS(&endpoint)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_EndpointsSpec_STATUS() to populate field Endpoints")
		}
		destination.Endpoints = &endpoint
	} else {
		destination.Endpoints = nil
	}

	// Etag
	destination.Etag = genruntime.ClonePointerToString(resource.Etag)

	// Id
	destination.Id = genruntime.ClonePointerToString(resource.Id)

	// Identity
	if resource.Identity != nil {
		var identity storage.ManagedServiceIdentity_STATUS
		err := resource.Identity.AssignProperties_To_ManagedServiceIdentity_STATUS(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedServiceIdentity_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// ImmutableId
	destination.ImmutableId = genruntime.ClonePointerToString(resource.ImmutableId)

	// Kind
	if resource.Kind != nil {
		kind := string(*resource.Kind)
		destination.Kind = &kind
	} else {
		destination.Kind = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(resource.Location)

	// Metadata
	if resource.Metadata != nil {
		var metadatum storage.Metadata_STATUS
		err := resource.Metadata.AssignProperties_To_Metadata_STATUS(&metadatum)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Metadata_STATUS() to populate field Metadata")
		}
		destination.Metadata = &metadatum
	} else {
		destination.Metadata = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(resource.Name)

	// ProvisioningState
	if resource.ProvisioningState != nil {
		provisioningState := string(*resource.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// References
	if resource.References != nil {
		var reference storage.ReferencesSpec_STATUS
		err := resource.References.AssignProperties_To_ReferencesSpec_STATUS(&reference)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ReferencesSpec_STATUS() to populate field References")
		}
		destination.References = &reference
	} else {
		destination.References = nil
	}

	// StreamDeclarations
	if resource.StreamDeclarations != nil {
		streamDeclarationMap := make(map[string]storage.StreamDeclaration_STATUS, len(resource.StreamDeclarations))
		for streamDeclarationKey, streamDeclarationValue := range resource.StreamDeclarations {
			// Shadow the loop variable to avoid aliasing
			streamDeclarationValue := streamDeclarationValue
			var streamDeclaration storage.StreamDeclaration_STATUS
			err := streamDeclarationValue.AssignProperties_To_StreamDeclaration_STATUS(&streamDeclaration)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_StreamDeclaration_STATUS() to populate field StreamDeclarations")
			}
			streamDeclarationMap[streamDeclarationKey] = streamDeclaration
		}
		destination.StreamDeclarations = streamDeclarationMap
	} else {
		destination.StreamDeclarations = nil
	}

	// SystemData
	if resource.SystemData != nil {
		var systemDatum storage.SystemData_STATUS
		err := resource.SystemData.AssignProperties_To_SystemData_STATUS(&systemDatum)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SystemData_STATUS() to populate field SystemData")
		}
		destination.SystemData = &systemDatum
	} else {
		destination.SystemData = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(resource.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(resource.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// An agent setting
type AgentSettingsSpec struct {
	// Logs: All the settings that are applicable to the logs agent (AMA)
	Logs []AgentSetting `json:"logs,omitempty"`
}

var _ genruntime.ARMTransformer = &AgentSettingsSpec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *AgentSettingsSpec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &arm.AgentSettingsSpec{}

	// Set property "Logs":
	for _, item := range settings.Logs {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Logs = append(result.Logs, *item_ARM.(*arm.AgentSetting))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *AgentSettingsSpec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AgentSettingsSpec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *AgentSettingsSpec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AgentSettingsSpec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AgentSettingsSpec, got %T", armInput)
	}

	// Set property "Logs":
	for _, item := range typedInput.Logs {
		var item1 AgentSetting
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		settings.Logs = append(settings.Logs, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_AgentSettingsSpec populates our AgentSettingsSpec from the provided source AgentSettingsSpec
func (settings *AgentSettingsSpec) AssignProperties_From_AgentSettingsSpec(source *storage.AgentSettingsSpec) error {

	// Logs
	if source.Logs != nil {
		logList := make([]AgentSetting, len(source.Logs))
		for logIndex, logItem := range source.Logs {
			// Shadow the loop variable to avoid aliasing
			logItem := logItem
			var log AgentSetting
			err := log.AssignProperties_From_AgentSetting(&logItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_AgentSetting() to populate field Logs")
			}
			logList[logIndex] = log
		}
		settings.Logs = logList
	} else {
		settings.Logs = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AgentSettingsSpec populates the provided destination AgentSettingsSpec from our AgentSettingsSpec
func (settings *AgentSettingsSpec) AssignProperties_To_AgentSettingsSpec(destination *storage.AgentSettingsSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Logs
	if settings.Logs != nil {
		logList := make([]storage.AgentSetting, len(settings.Logs))
		for logIndex, logItem := range settings.Logs {
			// Shadow the loop variable to avoid aliasing
			logItem := logItem
			var log storage.AgentSetting
			err := logItem.AssignProperties_To_AgentSetting(&log)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_AgentSetting() to populate field Logs")
			}
			logList[logIndex] = log
		}
		destination.Logs = logList
	} else {
		destination.Logs = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AgentSettingsSpec_STATUS populates our AgentSettingsSpec from the provided source AgentSettingsSpec_STATUS
func (settings *AgentSettingsSpec) Initialize_From_AgentSettingsSpec_STATUS(source *AgentSettingsSpec_STATUS) error {

	// Logs
	if source.Logs != nil {
		logList := make([]AgentSetting, len(source.Logs))
		for logIndex, logItem := range source.Logs {
			// Shadow the loop variable to avoid aliasing
			logItem := logItem
			var log AgentSetting
			err := log.Initialize_From_AgentSetting_STATUS(&logItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_AgentSetting_STATUS() to populate field Logs")
			}
			logList[logIndex] = log
		}
		settings.Logs = logList
	} else {
		settings.Logs = nil
	}

	// No error
	return nil
}

// An agent setting
type AgentSettingsSpec_STATUS struct {
	// Logs: All the settings that are applicable to the logs agent (AMA)
	Logs []AgentSetting_STATUS `json:"logs,omitempty"`
}

var _ genruntime.FromARMConverter = &AgentSettingsSpec_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *AgentSettingsSpec_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AgentSettingsSpec_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *AgentSettingsSpec_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AgentSettingsSpec_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AgentSettingsSpec_STATUS, got %T", armInput)
	}

	// Set property "Logs":
	for _, item := range typedInput.Logs {
		var item1 AgentSetting_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		settings.Logs = append(settings.Logs, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_AgentSettingsSpec_STATUS populates our AgentSettingsSpec_STATUS from the provided source AgentSettingsSpec_STATUS
func (settings *AgentSettingsSpec_STATUS) AssignProperties_From_AgentSettingsSpec_STATUS(source *storage.AgentSettingsSpec_STATUS) error {

	// Logs
	if source.Logs != nil {
		logList := make([]AgentSetting_STATUS, len(source.Logs))
		for logIndex, logItem := range source.Logs {
			// Shadow the loop variable to avoid aliasing
			logItem := logItem
			var log AgentSetting_STATUS
			err := log.AssignProperties_From_AgentSetting_STATUS(&logItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_AgentSetting_STATUS() to populate field Logs")
			}
			logList[logIndex] = log
		}
		settings.Logs = logList
	} else {
		settings.Logs = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AgentSettingsSpec_STATUS populates the provided destination AgentSettingsSpec_STATUS from our AgentSettingsSpec_STATUS
func (settings *AgentSettingsSpec_STATUS) AssignProperties_To_AgentSettingsSpec_STATUS(destination *storage.AgentSettingsSpec_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Logs
	if settings.Logs != nil {
		logList := make([]storage.AgentSetting_STATUS, len(settings.Logs))
		for logIndex, logItem := range settings.Logs {
			// Shadow the loop variable to avoid aliasing
			logItem := logItem
			var log storage.AgentSetting_STATUS
			err := logItem.AssignProperties_To_AgentSetting_STATUS(&log)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_AgentSetting_STATUS() to populate field Logs")
			}
			logList[logIndex] = log
		}
		destination.Logs = logList
	} else {
		destination.Logs = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Linux","Windows"}
type DataCollectionRule_Kind_Spec string

const (
	DataCollectionRule_Kind_Spec_Linux   = DataCollectionRule_Kind_Spec("Linux")
	DataCollectionRule_Kind_Spec_Windows = DataCollectionRule_Kind_Spec("Windows")
)

// Mapping from string to DataCollectionRule_Kind_Spec
var dataCollectionRule_Kind_Spec_Values = map[string]DataCollectionRule_Kind_Spec{
	"linux":   DataCollectionRule_Kind_Spec_Linux,
	"windows": DataCollectionRule_Kind_Spec_Windows,
}

type DataCollectionRule_ProvisioningState_STATUS string

const (
	DataCollectionRule_ProvisioningState_STATUS_Canceled  = DataCollectionRule_ProvisioningState_STATUS("Canceled")
	DataCollectionRule_ProvisioningState_STATUS_Creating  = DataCollectionRule_ProvisioningState_STATUS("Creating")
	DataCollectionRule_ProvisioningState_STATUS_Deleting  = DataCollectionRule_ProvisioningState_STATUS("Deleting")
	DataCollectionRule_ProvisioningState_STATUS_Failed    = DataCollectionRule_ProvisioningState_STATUS("Failed")
	DataCollectionRule_ProvisioningState_STATUS_Succeeded = DataCollectionRule_ProvisioningState_STATUS("Succeeded")
	DataCollectionRule_ProvisioningState_STATUS_Updating  = DataCollectionRule_ProvisioningState_STATUS("Updating")
)

// Mapping from string to DataCollectionRule_ProvisioningState_STATUS
var dataCollectionRule_ProvisioningState_STATUS_Values = map[string]DataCollectionRule_ProvisioningState_STATUS{
	"canceled":  DataCollectionRule_ProvisioningState_STATUS_Canceled,
	"creating":  DataCollectionRule_ProvisioningState_STATUS_Creating,
	"deleting":  DataCollectionRule_ProvisioningState_STATUS_Deleting,
	"failed":    DataCollectionRule_ProvisioningState_STATUS_Failed,
	"succeeded": DataCollectionRule_ProvisioningState_STATUS_Succeeded,
	"updating":  DataCollectionRule_ProvisioningState_STATUS_Updating,
}

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type DataCollectionRuleOperatorSpec struct {
	// ConfigMapExpressions: configures where to place operator written dynamic ConfigMaps (created with CEL expressions).
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`

	// SecretExpressions: configures where to place operator written dynamic secrets (created with CEL expressions).
	SecretExpressions []*core.DestinationExpression `json:"secretExpressions,omitempty"`
}

// AssignProperties_From_DataCollectionRuleOperatorSpec populates our DataCollectionRuleOperatorSpec from the provided source DataCollectionRuleOperatorSpec
func (operator *DataCollectionRuleOperatorSpec) AssignProperties_From_DataCollectionRuleOperatorSpec(source *storage.DataCollectionRuleOperatorSpec) error {

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DataCollectionRuleOperatorSpec populates the provided destination DataCollectionRuleOperatorSpec from our DataCollectionRuleOperatorSpec
func (operator *DataCollectionRuleOperatorSpec) AssignProperties_To_DataCollectionRuleOperatorSpec(destination *storage.DataCollectionRuleOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DataCollectionRuleResource_Kind_STATUS string

const (
	DataCollectionRuleResource_Kind_STATUS_Linux   = DataCollectionRuleResource_Kind_STATUS("Linux")
	DataCollectionRuleResource_Kind_STATUS_Windows = DataCollectionRuleResource_Kind_STATUS("Windows")
)

// Mapping from string to DataCollectionRuleResource_Kind_STATUS
var dataCollectionRuleResource_Kind_STATUS_Values = map[string]DataCollectionRuleResource_Kind_STATUS{
	"linux":   DataCollectionRuleResource_Kind_STATUS_Linux,
	"windows": DataCollectionRuleResource_Kind_STATUS_Windows,
}

// Definition of which streams are sent to which destinations.
type DataFlow struct {
	// BuiltInTransform: The builtIn transform to transform stream data
	BuiltInTransform *string `json:"builtInTransform,omitempty"`

	// CaptureOverflow: Flag to enable overflow column in LA destinations
	CaptureOverflow *bool `json:"captureOverflow,omitempty"`

	// Destinations: List of destinations for this data flow.
	Destinations []string `json:"destinations,omitempty"`

	// OutputStream: The output stream of the transform. Only required if the transform changes data to a different stream.
	OutputStream *string `json:"outputStream,omitempty"`

	// Streams: List of streams for this data flow.
	Streams []DataFlow_Streams `json:"streams,omitempty"`

	// TransformKql: The KQL query to transform stream data.
	TransformKql *string `json:"transformKql,omitempty"`
}

var _ genruntime.ARMTransformer = &DataFlow{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (flow *DataFlow) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if flow == nil {
		return nil, nil
	}
	result := &arm.DataFlow{}

	// Set property "BuiltInTransform":
	if flow.BuiltInTransform != nil {
		builtInTransform := *flow.BuiltInTransform
		result.BuiltInTransform = &builtInTransform
	}

	// Set property "CaptureOverflow":
	if flow.CaptureOverflow != nil {
		captureOverflow := *flow.CaptureOverflow
		result.CaptureOverflow = &captureOverflow
	}

	// Set property "Destinations":
	for _, item := range flow.Destinations {
		result.Destinations = append(result.Destinations, item)
	}

	// Set property "OutputStream":
	if flow.OutputStream != nil {
		outputStream := *flow.OutputStream
		result.OutputStream = &outputStream
	}

	// Set property "Streams":
	for _, item := range flow.Streams {
		var temp string
		temp = string(item)
		result.Streams = append(result.Streams, arm.DataFlow_Streams(temp))
	}

	// Set property "TransformKql":
	if flow.TransformKql != nil {
		transformKql := *flow.TransformKql
		result.TransformKql = &transformKql
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (flow *DataFlow) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DataFlow{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (flow *DataFlow) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DataFlow)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DataFlow, got %T", armInput)
	}

	// Set property "BuiltInTransform":
	if typedInput.BuiltInTransform != nil {
		builtInTransform := *typedInput.BuiltInTransform
		flow.BuiltInTransform = &builtInTransform
	}

	// Set property "CaptureOverflow":
	if typedInput.CaptureOverflow != nil {
		captureOverflow := *typedInput.CaptureOverflow
		flow.CaptureOverflow = &captureOverflow
	}

	// Set property "Destinations":
	for _, item := range typedInput.Destinations {
		flow.Destinations = append(flow.Destinations, item)
	}

	// Set property "OutputStream":
	if typedInput.OutputStream != nil {
		outputStream := *typedInput.OutputStream
		flow.OutputStream = &outputStream
	}

	// Set property "Streams":
	for _, item := range typedInput.Streams {
		var temp string
		temp = string(item)
		flow.Streams = append(flow.Streams, DataFlow_Streams(temp))
	}

	// Set property "TransformKql":
	if typedInput.TransformKql != nil {
		transformKql := *typedInput.TransformKql
		flow.TransformKql = &transformKql
	}

	// No error
	return nil
}

// AssignProperties_From_DataFlow populates our DataFlow from the provided source DataFlow
func (flow *DataFlow) AssignProperties_From_DataFlow(source *storage.DataFlow) error {

	// BuiltInTransform
	flow.BuiltInTransform = genruntime.ClonePointerToString(source.BuiltInTransform)

	// CaptureOverflow
	if source.CaptureOverflow != nil {
		captureOverflow := *source.CaptureOverflow
		flow.CaptureOverflow = &captureOverflow
	} else {
		flow.CaptureOverflow = nil
	}

	// Destinations
	flow.Destinations = genruntime.CloneSliceOfString(source.Destinations)

	// OutputStream
	flow.OutputStream = genruntime.ClonePointerToString(source.OutputStream)

	// Streams
	if source.Streams != nil {
		streamList := make([]DataFlow_Streams, len(source.Streams))
		for streamIndex, streamItem := range source.Streams {
			// Shadow the loop variable to avoid aliasing
			streamItem := streamItem
			streamList[streamIndex] = genruntime.ToEnum(streamItem, dataFlow_Streams_Values)
		}
		flow.Streams = streamList
	} else {
		flow.Streams = nil
	}

	// TransformKql
	flow.TransformKql = genruntime.ClonePointerToString(source.TransformKql)

	// No error
	return nil
}

// AssignProperties_To_DataFlow populates the provided destination DataFlow from our DataFlow
func (flow *DataFlow) AssignProperties_To_DataFlow(destination *storage.DataFlow) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BuiltInTransform
	destination.BuiltInTransform = genruntime.ClonePointerToString(flow.BuiltInTransform)

	// CaptureOverflow
	if flow.CaptureOverflow != nil {
		captureOverflow := *flow.CaptureOverflow
		destination.CaptureOverflow = &captureOverflow
	} else {
		destination.CaptureOverflow = nil
	}

	// Destinations
	destination.Destinations = genruntime.CloneSliceOfString(flow.Destinations)

	// OutputStream
	destination.OutputStream = genruntime.ClonePointerToString(flow.OutputStream)

	// Streams
	if flow.Streams != nil {
		streamList := make([]string, len(flow.Streams))
		for streamIndex, streamItem := range flow.Streams {
			// Shadow the loop variable to avoid aliasing
			streamItem := streamItem
			streamList[streamIndex] = string(streamItem)
		}
		destination.Streams = streamList
	} else {
		destination.Streams = nil
	}

	// TransformKql
	destination.TransformKql = genruntime.ClonePointerToString(flow.TransformKql)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DataFlow_STATUS populates our DataFlow from the provided source DataFlow_STATUS
func (flow *DataFlow) Initialize_From_DataFlow_STATUS(source *DataFlow_STATUS) error {

	// BuiltInTransform
	flow.BuiltInTransform = genruntime.ClonePointerToString(source.BuiltInTransform)

	// CaptureOverflow
	if source.CaptureOverflow != nil {
		captureOverflow := *source.CaptureOverflow
		flow.CaptureOverflow = &captureOverflow
	} else {
		flow.CaptureOverflow = nil
	}

	// Destinations
	flow.Destinations = genruntime.CloneSliceOfString(source.Destinations)

	// OutputStream
	flow.OutputStream = genruntime.ClonePointerToString(source.OutputStream)

	// Streams
	if source.Streams != nil {
		streamList := make([]DataFlow_Streams, len(source.Streams))
		for streamIndex, streamItem := range source.Streams {
			// Shadow the loop variable to avoid aliasing
			streamItem := streamItem
			stream := genruntime.ToEnum(string(streamItem), dataFlow_Streams_Values)
			streamList[streamIndex] = stream
		}
		flow.Streams = streamList
	} else {
		flow.Streams = nil
	}

	// TransformKql
	flow.TransformKql = genruntime.ClonePointerToString(source.TransformKql)

	// No error
	return nil
}

// Definition of which streams are sent to which destinations.
type DataFlow_STATUS struct {
	// BuiltInTransform: The builtIn transform to transform stream data
	BuiltInTransform *string `json:"builtInTransform,omitempty"`

	// CaptureOverflow: Flag to enable overflow column in LA destinations
	CaptureOverflow *bool `json:"captureOverflow,omitempty"`

	// Destinations: List of destinations for this data flow.
	Destinations []string `json:"destinations,omitempty"`

	// OutputStream: The output stream of the transform. Only required if the transform changes data to a different stream.
	OutputStream *string `json:"outputStream,omitempty"`

	// Streams: List of streams for this data flow.
	Streams []DataFlow_Streams_STATUS `json:"streams,omitempty"`

	// TransformKql: The KQL query to transform stream data.
	TransformKql *string `json:"transformKql,omitempty"`
}

var _ genruntime.FromARMConverter = &DataFlow_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (flow *DataFlow_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DataFlow_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (flow *DataFlow_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DataFlow_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DataFlow_STATUS, got %T", armInput)
	}

	// Set property "BuiltInTransform":
	if typedInput.BuiltInTransform != nil {
		builtInTransform := *typedInput.BuiltInTransform
		flow.BuiltInTransform = &builtInTransform
	}

	// Set property "CaptureOverflow":
	if typedInput.CaptureOverflow != nil {
		captureOverflow := *typedInput.CaptureOverflow
		flow.CaptureOverflow = &captureOverflow
	}

	// Set property "Destinations":
	for _, item := range typedInput.Destinations {
		flow.Destinations = append(flow.Destinations, item)
	}

	// Set property "OutputStream":
	if typedInput.OutputStream != nil {
		outputStream := *typedInput.OutputStream
		flow.OutputStream = &outputStream
	}

	// Set property "Streams":
	for _, item := range typedInput.Streams {
		var temp string
		temp = string(item)
		flow.Streams = append(flow.Streams, DataFlow_Streams_STATUS(temp))
	}

	// Set property "TransformKql":
	if typedInput.TransformKql != nil {
		transformKql := *typedInput.TransformKql
		flow.TransformKql = &transformKql
	}

	// No error
	return nil
}

// AssignProperties_From_DataFlow_STATUS populates our DataFlow_STATUS from the provided source DataFlow_STATUS
func (flow *DataFlow_STATUS) AssignProperties_From_DataFlow_STATUS(source *storage.DataFlow_STATUS) error {

	// BuiltInTransform
	flow.BuiltInTransform = genruntime.ClonePointerToString(source.BuiltInTransform)

	// CaptureOverflow
	if source.CaptureOverflow != nil {
		captureOverflow := *source.CaptureOverflow
		flow.CaptureOverflow = &captureOverflow
	} else {
		flow.CaptureOverflow = nil
	}

	// Destinations
	flow.Destinations = genruntime.CloneSliceOfString(source.Destinations)

	// OutputStream
	flow.OutputStream = genruntime.ClonePointerToString(source.OutputStream)

	// Streams
	if source.Streams != nil {
		streamList := make([]DataFlow_Streams_STATUS, len(source.Streams))
		for streamIndex, streamItem := range source.Streams {
			// Shadow the loop variable to avoid aliasing
			streamItem := streamItem
			streamList[streamIndex] = genruntime.ToEnum(streamItem, dataFlow_Streams_STATUS_Values)
		}
		flow.Streams = streamList
	} else {
		flow.Streams = nil
	}

	// TransformKql
	flow.TransformKql = genruntime.ClonePointerToString(source.TransformKql)

	// No error
	return nil
}

// AssignProperties_To_DataFlow_STATUS populates the provided destination DataFlow_STATUS from our DataFlow_STATUS
func (flow *DataFlow_STATUS) AssignProperties_To_DataFlow_STATUS(destination *storage.DataFlow_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BuiltInTransform
	destination.BuiltInTransform = genruntime.ClonePointerToString(flow.BuiltInTransform)

	// CaptureOverflow
	if flow.CaptureOverflow != nil {
		captureOverflow := *flow.CaptureOverflow
		destination.CaptureOverflow = &captureOverflow
	} else {
		destination.CaptureOverflow = nil
	}

	// Destinations
	destination.Destinations = genruntime.CloneSliceOfString(flow.Destinations)

	// OutputStream
	destination.OutputStream = genruntime.ClonePointerToString(flow.OutputStream)

	// Streams
	if flow.Streams != nil {
		streamList := make([]string, len(flow.Streams))
		for streamIndex, streamItem := range flow.Streams {
			// Shadow the loop variable to avoid aliasing
			streamItem := streamItem
			streamList[streamIndex] = string(streamItem)
		}
		destination.Streams = streamList
	} else {
		destination.Streams = nil
	}

	// TransformKql
	destination.TransformKql = genruntime.ClonePointerToString(flow.TransformKql)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Specification of data sources that will be collected.
type DataSourcesSpec struct {
	// DataImports: Specifications of pull based data sources
	DataImports *DataImportSources `json:"dataImports,omitempty"`

	// Extensions: The list of Azure VM extension data source configurations.
	Extensions []ExtensionDataSource `json:"extensions,omitempty"`

	// IisLogs: The list of IIS logs source configurations.
	IisLogs []IisLogsDataSource `json:"iisLogs,omitempty"`

	// LogFiles: The list of Log files source configurations.
	LogFiles []LogFilesDataSource `json:"logFiles,omitempty"`

	// PerformanceCounters: The list of performance counter data source configurations.
	PerformanceCounters []PerfCounterDataSource `json:"performanceCounters,omitempty"`

	// PlatformTelemetry: The list of platform telemetry configurations
	PlatformTelemetry []PlatformTelemetryDataSource `json:"platformTelemetry,omitempty"`

	// PrometheusForwarder: The list of Prometheus forwarder data source configurations.
	PrometheusForwarder []PrometheusForwarderDataSource `json:"prometheusForwarder,omitempty"`

	// Syslog: The list of Syslog data source configurations.
	Syslog []SyslogDataSource `json:"syslog,omitempty"`

	// WindowsEventLogs: The list of Windows Event Log data source configurations.
	WindowsEventLogs []WindowsEventLogDataSource `json:"windowsEventLogs,omitempty"`

	// WindowsFirewallLogs: The list of Windows Firewall logs source configurations.
	WindowsFirewallLogs []WindowsFirewallLogsDataSource `json:"windowsFirewallLogs,omitempty"`
}

var _ genruntime.ARMTransformer = &DataSourcesSpec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (sources *DataSourcesSpec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if sources == nil {
		return nil, nil
	}
	result := &arm.DataSourcesSpec{}

	// Set property "DataImports":
	if sources.DataImports != nil {
		dataImports_ARM, err := (*sources.DataImports).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		dataImports := *dataImports_ARM.(*arm.DataImportSources)
		result.DataImports = &dataImports
	}

	// Set property "Extensions":
	for _, item := range sources.Extensions {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Extensions = append(result.Extensions, *item_ARM.(*arm.ExtensionDataSource))
	}

	// Set property "IisLogs":
	for _, item := range sources.IisLogs {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.IisLogs = append(result.IisLogs, *item_ARM.(*arm.IisLogsDataSource))
	}

	// Set property "LogFiles":
	for _, item := range sources.LogFiles {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.LogFiles = append(result.LogFiles, *item_ARM.(*arm.LogFilesDataSource))
	}

	// Set property "PerformanceCounters":
	for _, item := range sources.PerformanceCounters {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.PerformanceCounters = append(result.PerformanceCounters, *item_ARM.(*arm.PerfCounterDataSource))
	}

	// Set property "PlatformTelemetry":
	for _, item := range sources.PlatformTelemetry {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.PlatformTelemetry = append(result.PlatformTelemetry, *item_ARM.(*arm.PlatformTelemetryDataSource))
	}

	// Set property "PrometheusForwarder":
	for _, item := range sources.PrometheusForwarder {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.PrometheusForwarder = append(result.PrometheusForwarder, *item_ARM.(*arm.PrometheusForwarderDataSource))
	}

	// Set property "Syslog":
	for _, item := range sources.Syslog {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Syslog = append(result.Syslog, *item_ARM.(*arm.SyslogDataSource))
	}

	// Set property "WindowsEventLogs":
	for _, item := range sources.WindowsEventLogs {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.WindowsEventLogs = append(result.WindowsEventLogs, *item_ARM.(*arm.WindowsEventLogDataSource))
	}

	// Set property "WindowsFirewallLogs":
	for _, item := range sources.WindowsFirewallLogs {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.WindowsFirewallLogs = append(result.WindowsFirewallLogs, *item_ARM.(*arm.WindowsFirewallLogsDataSource))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sources *DataSourcesSpec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DataSourcesSpec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sources *DataSourcesSpec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DataSourcesSpec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DataSourcesSpec, got %T", armInput)
	}

	// Set property "DataImports":
	if typedInput.DataImports != nil {
		var dataImports1 DataImportSources
		err := dataImports1.PopulateFromARM(owner, *typedInput.DataImports)
		if err != nil {
			return err
		}
		dataImports := dataImports1
		sources.DataImports = &dataImports
	}

	// Set property "Extensions":
	for _, item := range typedInput.Extensions {
		var item1 ExtensionDataSource
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		sources.Extensions = append(sources.Extensions, item1)
	}

	// Set property "IisLogs":
	for _, item := range typedInput.IisLogs {
		var item1 IisLogsDataSource
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		sources.IisLogs = append(sources.IisLogs, item1)
	}

	// Set property "LogFiles":
	for _, item := range typedInput.LogFiles {
		var item1 LogFilesDataSource
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		sources.LogFiles = append(sources.LogFiles, item1)
	}

	// Set property "PerformanceCounters":
	for _, item := range typedInput.PerformanceCounters {
		var item1 PerfCounterDataSource
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		sources.PerformanceCounters = append(sources.PerformanceCounters, item1)
	}

	// Set property "PlatformTelemetry":
	for _, item := range typedInput.PlatformTelemetry {
		var item1 PlatformTelemetryDataSource
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		sources.PlatformTelemetry = append(sources.PlatformTelemetry, item1)
	}

	// Set property "PrometheusForwarder":
	for _, item := range typedInput.PrometheusForwarder {
		var item1 PrometheusForwarderDataSource
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		sources.PrometheusForwarder = append(sources.PrometheusForwarder, item1)
	}

	// Set property "Syslog":
	for _, item := range typedInput.Syslog {
		var item1 SyslogDataSource
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		sources.Syslog = append(sources.Syslog, item1)
	}

	// Set property "WindowsEventLogs":
	for _, item := range typedInput.WindowsEventLogs {
		var item1 WindowsEventLogDataSource
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		sources.WindowsEventLogs = append(sources.WindowsEventLogs, item1)
	}

	// Set property "WindowsFirewallLogs":
	for _, item := range typedInput.WindowsFirewallLogs {
		var item1 WindowsFirewallLogsDataSource
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		sources.WindowsFirewallLogs = append(sources.WindowsFirewallLogs, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_DataSourcesSpec populates our DataSourcesSpec from the provided source DataSourcesSpec
func (sources *DataSourcesSpec) AssignProperties_From_DataSourcesSpec(source *storage.DataSourcesSpec) error {

	// DataImports
	if source.DataImports != nil {
		var dataImport DataImportSources
		err := dataImport.AssignProperties_From_DataImportSources(source.DataImports)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DataImportSources() to populate field DataImports")
		}
		sources.DataImports = &dataImport
	} else {
		sources.DataImports = nil
	}

	// Extensions
	if source.Extensions != nil {
		extensionList := make([]ExtensionDataSource, len(source.Extensions))
		for extensionIndex, extensionItem := range source.Extensions {
			// Shadow the loop variable to avoid aliasing
			extensionItem := extensionItem
			var extension ExtensionDataSource
			err := extension.AssignProperties_From_ExtensionDataSource(&extensionItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ExtensionDataSource() to populate field Extensions")
			}
			extensionList[extensionIndex] = extension
		}
		sources.Extensions = extensionList
	} else {
		sources.Extensions = nil
	}

	// IisLogs
	if source.IisLogs != nil {
		iisLogList := make([]IisLogsDataSource, len(source.IisLogs))
		for iisLogIndex, iisLogItem := range source.IisLogs {
			// Shadow the loop variable to avoid aliasing
			iisLogItem := iisLogItem
			var iisLog IisLogsDataSource
			err := iisLog.AssignProperties_From_IisLogsDataSource(&iisLogItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_IisLogsDataSource() to populate field IisLogs")
			}
			iisLogList[iisLogIndex] = iisLog
		}
		sources.IisLogs = iisLogList
	} else {
		sources.IisLogs = nil
	}

	// LogFiles
	if source.LogFiles != nil {
		logFileList := make([]LogFilesDataSource, len(source.LogFiles))
		for logFileIndex, logFileItem := range source.LogFiles {
			// Shadow the loop variable to avoid aliasing
			logFileItem := logFileItem
			var logFile LogFilesDataSource
			err := logFile.AssignProperties_From_LogFilesDataSource(&logFileItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_LogFilesDataSource() to populate field LogFiles")
			}
			logFileList[logFileIndex] = logFile
		}
		sources.LogFiles = logFileList
	} else {
		sources.LogFiles = nil
	}

	// PerformanceCounters
	if source.PerformanceCounters != nil {
		performanceCounterList := make([]PerfCounterDataSource, len(source.PerformanceCounters))
		for performanceCounterIndex, performanceCounterItem := range source.PerformanceCounters {
			// Shadow the loop variable to avoid aliasing
			performanceCounterItem := performanceCounterItem
			var performanceCounter PerfCounterDataSource
			err := performanceCounter.AssignProperties_From_PerfCounterDataSource(&performanceCounterItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_PerfCounterDataSource() to populate field PerformanceCounters")
			}
			performanceCounterList[performanceCounterIndex] = performanceCounter
		}
		sources.PerformanceCounters = performanceCounterList
	} else {
		sources.PerformanceCounters = nil
	}

	// PlatformTelemetry
	if source.PlatformTelemetry != nil {
		platformTelemetryList := make([]PlatformTelemetryDataSource, len(source.PlatformTelemetry))
		for platformTelemetryIndex, platformTelemetryItem := range source.PlatformTelemetry {
			// Shadow the loop variable to avoid aliasing
			platformTelemetryItem := platformTelemetryItem
			var platformTelemetry PlatformTelemetryDataSource
			err := platformTelemetry.AssignProperties_From_PlatformTelemetryDataSource(&platformTelemetryItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_PlatformTelemetryDataSource() to populate field PlatformTelemetry")
			}
			platformTelemetryList[platformTelemetryIndex] = platformTelemetry
		}
		sources.PlatformTelemetry = platformTelemetryList
	} else {
		sources.PlatformTelemetry = nil
	}

	// PrometheusForwarder
	if source.PrometheusForwarder != nil {
		prometheusForwarderList := make([]PrometheusForwarderDataSource, len(source.PrometheusForwarder))
		for prometheusForwarderIndex, prometheusForwarderItem := range source.PrometheusForwarder {
			// Shadow the loop variable to avoid aliasing
			prometheusForwarderItem := prometheusForwarderItem
			var prometheusForwarder PrometheusForwarderDataSource
			err := prometheusForwarder.AssignProperties_From_PrometheusForwarderDataSource(&prometheusForwarderItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_PrometheusForwarderDataSource() to populate field PrometheusForwarder")
			}
			prometheusForwarderList[prometheusForwarderIndex] = prometheusForwarder
		}
		sources.PrometheusForwarder = prometheusForwarderList
	} else {
		sources.PrometheusForwarder = nil
	}

	// Syslog
	if source.Syslog != nil {
		syslogList := make([]SyslogDataSource, len(source.Syslog))
		for syslogIndex, syslogItem := range source.Syslog {
			// Shadow the loop variable to avoid aliasing
			syslogItem := syslogItem
			var syslog SyslogDataSource
			err := syslog.AssignProperties_From_SyslogDataSource(&syslogItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_SyslogDataSource() to populate field Syslog")
			}
			syslogList[syslogIndex] = syslog
		}
		sources.Syslog = syslogList
	} else {
		sources.Syslog = nil
	}

	// WindowsEventLogs
	if source.WindowsEventLogs != nil {
		windowsEventLogList := make([]WindowsEventLogDataSource, len(source.WindowsEventLogs))
		for windowsEventLogIndex, windowsEventLogItem := range source.WindowsEventLogs {
			// Shadow the loop variable to avoid aliasing
			windowsEventLogItem := windowsEventLogItem
			var windowsEventLog WindowsEventLogDataSource
			err := windowsEventLog.AssignProperties_From_WindowsEventLogDataSource(&windowsEventLogItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_WindowsEventLogDataSource() to populate field WindowsEventLogs")
			}
			windowsEventLogList[windowsEventLogIndex] = windowsEventLog
		}
		sources.WindowsEventLogs = windowsEventLogList
	} else {
		sources.WindowsEventLogs = nil
	}

	// WindowsFirewallLogs
	if source.WindowsFirewallLogs != nil {
		windowsFirewallLogList := make([]WindowsFirewallLogsDataSource, len(source.WindowsFirewallLogs))
		for windowsFirewallLogIndex, windowsFirewallLogItem := range source.WindowsFirewallLogs {
			// Shadow the loop variable to avoid aliasing
			windowsFirewallLogItem := windowsFirewallLogItem
			var windowsFirewallLog WindowsFirewallLogsDataSource
			err := windowsFirewallLog.AssignProperties_From_WindowsFirewallLogsDataSource(&windowsFirewallLogItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_WindowsFirewallLogsDataSource() to populate field WindowsFirewallLogs")
			}
			windowsFirewallLogList[windowsFirewallLogIndex] = windowsFirewallLog
		}
		sources.WindowsFirewallLogs = windowsFirewallLogList
	} else {
		sources.WindowsFirewallLogs = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DataSourcesSpec populates the provided destination DataSourcesSpec from our DataSourcesSpec
func (sources *DataSourcesSpec) AssignProperties_To_DataSourcesSpec(destination *storage.DataSourcesSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DataImports
	if sources.DataImports != nil {
		var dataImport storage.DataImportSources
		err := sources.DataImports.AssignProperties_To_DataImportSources(&dataImport)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DataImportSources() to populate field DataImports")
		}
		destination.DataImports = &dataImport
	} else {
		destination.DataImports = nil
	}

	// Extensions
	if sources.Extensions != nil {
		extensionList := make([]storage.ExtensionDataSource, len(sources.Extensions))
		for extensionIndex, extensionItem := range sources.Extensions {
			// Shadow the loop variable to avoid aliasing
			extensionItem := extensionItem
			var extension storage.ExtensionDataSource
			err := extensionItem.AssignProperties_To_ExtensionDataSource(&extension)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ExtensionDataSource() to populate field Extensions")
			}
			extensionList[extensionIndex] = extension
		}
		destination.Extensions = extensionList
	} else {
		destination.Extensions = nil
	}

	// IisLogs
	if sources.IisLogs != nil {
		iisLogList := make([]storage.IisLogsDataSource, len(sources.IisLogs))
		for iisLogIndex, iisLogItem := range sources.IisLogs {
			// Shadow the loop variable to avoid aliasing
			iisLogItem := iisLogItem
			var iisLog storage.IisLogsDataSource
			err := iisLogItem.AssignProperties_To_IisLogsDataSource(&iisLog)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_IisLogsDataSource() to populate field IisLogs")
			}
			iisLogList[iisLogIndex] = iisLog
		}
		destination.IisLogs = iisLogList
	} else {
		destination.IisLogs = nil
	}

	// LogFiles
	if sources.LogFiles != nil {
		logFileList := make([]storage.LogFilesDataSource, len(sources.LogFiles))
		for logFileIndex, logFileItem := range sources.LogFiles {
			// Shadow the loop variable to avoid aliasing
			logFileItem := logFileItem
			var logFile storage.LogFilesDataSource
			err := logFileItem.AssignProperties_To_LogFilesDataSource(&logFile)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_LogFilesDataSource() to populate field LogFiles")
			}
			logFileList[logFileIndex] = logFile
		}
		destination.LogFiles = logFileList
	} else {
		destination.LogFiles = nil
	}

	// PerformanceCounters
	if sources.PerformanceCounters != nil {
		performanceCounterList := make([]storage.PerfCounterDataSource, len(sources.PerformanceCounters))
		for performanceCounterIndex, performanceCounterItem := range sources.PerformanceCounters {
			// Shadow the loop variable to avoid aliasing
			performanceCounterItem := performanceCounterItem
			var performanceCounter storage.PerfCounterDataSource
			err := performanceCounterItem.AssignProperties_To_PerfCounterDataSource(&performanceCounter)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_PerfCounterDataSource() to populate field PerformanceCounters")
			}
			performanceCounterList[performanceCounterIndex] = performanceCounter
		}
		destination.PerformanceCounters = performanceCounterList
	} else {
		destination.PerformanceCounters = nil
	}

	// PlatformTelemetry
	if sources.PlatformTelemetry != nil {
		platformTelemetryList := make([]storage.PlatformTelemetryDataSource, len(sources.PlatformTelemetry))
		for platformTelemetryIndex, platformTelemetryItem := range sources.PlatformTelemetry {
			// Shadow the loop variable to avoid aliasing
			platformTelemetryItem := platformTelemetryItem
			var platformTelemetry storage.PlatformTelemetryDataSource
			err := platformTelemetryItem.AssignProperties_To_PlatformTelemetryDataSource(&platformTelemetry)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_PlatformTelemetryDataSource() to populate field PlatformTelemetry")
			}
			platformTelemetryList[platformTelemetryIndex] = platformTelemetry
		}
		destination.PlatformTelemetry = platformTelemetryList
	} else {
		destination.PlatformTelemetry = nil
	}

	// PrometheusForwarder
	if sources.PrometheusForwarder != nil {
		prometheusForwarderList := make([]storage.PrometheusForwarderDataSource, len(sources.PrometheusForwarder))
		for prometheusForwarderIndex, prometheusForwarderItem := range sources.PrometheusForwarder {
			// Shadow the loop variable to avoid aliasing
			prometheusForwarderItem := prometheusForwarderItem
			var prometheusForwarder storage.PrometheusForwarderDataSource
			err := prometheusForwarderItem.AssignProperties_To_PrometheusForwarderDataSource(&prometheusForwarder)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_PrometheusForwarderDataSource() to populate field PrometheusForwarder")
			}
			prometheusForwarderList[prometheusForwarderIndex] = prometheusForwarder
		}
		destination.PrometheusForwarder = prometheusForwarderList
	} else {
		destination.PrometheusForwarder = nil
	}

	// Syslog
	if sources.Syslog != nil {
		syslogList := make([]storage.SyslogDataSource, len(sources.Syslog))
		for syslogIndex, syslogItem := range sources.Syslog {
			// Shadow the loop variable to avoid aliasing
			syslogItem := syslogItem
			var syslog storage.SyslogDataSource
			err := syslogItem.AssignProperties_To_SyslogDataSource(&syslog)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_SyslogDataSource() to populate field Syslog")
			}
			syslogList[syslogIndex] = syslog
		}
		destination.Syslog = syslogList
	} else {
		destination.Syslog = nil
	}

	// WindowsEventLogs
	if sources.WindowsEventLogs != nil {
		windowsEventLogList := make([]storage.WindowsEventLogDataSource, len(sources.WindowsEventLogs))
		for windowsEventLogIndex, windowsEventLogItem := range sources.WindowsEventLogs {
			// Shadow the loop variable to avoid aliasing
			windowsEventLogItem := windowsEventLogItem
			var windowsEventLog storage.WindowsEventLogDataSource
			err := windowsEventLogItem.AssignProperties_To_WindowsEventLogDataSource(&windowsEventLog)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_WindowsEventLogDataSource() to populate field WindowsEventLogs")
			}
			windowsEventLogList[windowsEventLogIndex] = windowsEventLog
		}
		destination.WindowsEventLogs = windowsEventLogList
	} else {
		destination.WindowsEventLogs = nil
	}

	// WindowsFirewallLogs
	if sources.WindowsFirewallLogs != nil {
		windowsFirewallLogList := make([]storage.WindowsFirewallLogsDataSource, len(sources.WindowsFirewallLogs))
		for windowsFirewallLogIndex, windowsFirewallLogItem := range sources.WindowsFirewallLogs {
			// Shadow the loop variable to avoid aliasing
			windowsFirewallLogItem := windowsFirewallLogItem
			var windowsFirewallLog storage.WindowsFirewallLogsDataSource
			err := windowsFirewallLogItem.AssignProperties_To_WindowsFirewallLogsDataSource(&windowsFirewallLog)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_WindowsFirewallLogsDataSource() to populate field WindowsFirewallLogs")
			}
			windowsFirewallLogList[windowsFirewallLogIndex] = windowsFirewallLog
		}
		destination.WindowsFirewallLogs = windowsFirewallLogList
	} else {
		destination.WindowsFirewallLogs = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DataSourcesSpec_STATUS populates our DataSourcesSpec from the provided source DataSourcesSpec_STATUS
func (sources *DataSourcesSpec) Initialize_From_DataSourcesSpec_STATUS(source *DataSourcesSpec_STATUS) error {

	// DataImports
	if source.DataImports != nil {
		var dataImport DataImportSources
		err := dataImport.Initialize_From_DataImportSources_STATUS(source.DataImports)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_DataImportSources_STATUS() to populate field DataImports")
		}
		sources.DataImports = &dataImport
	} else {
		sources.DataImports = nil
	}

	// Extensions
	if source.Extensions != nil {
		extensionList := make([]ExtensionDataSource, len(source.Extensions))
		for extensionIndex, extensionItem := range source.Extensions {
			// Shadow the loop variable to avoid aliasing
			extensionItem := extensionItem
			var extension ExtensionDataSource
			err := extension.Initialize_From_ExtensionDataSource_STATUS(&extensionItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_ExtensionDataSource_STATUS() to populate field Extensions")
			}
			extensionList[extensionIndex] = extension
		}
		sources.Extensions = extensionList
	} else {
		sources.Extensions = nil
	}

	// IisLogs
	if source.IisLogs != nil {
		iisLogList := make([]IisLogsDataSource, len(source.IisLogs))
		for iisLogIndex, iisLogItem := range source.IisLogs {
			// Shadow the loop variable to avoid aliasing
			iisLogItem := iisLogItem
			var iisLog IisLogsDataSource
			err := iisLog.Initialize_From_IisLogsDataSource_STATUS(&iisLogItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_IisLogsDataSource_STATUS() to populate field IisLogs")
			}
			iisLogList[iisLogIndex] = iisLog
		}
		sources.IisLogs = iisLogList
	} else {
		sources.IisLogs = nil
	}

	// LogFiles
	if source.LogFiles != nil {
		logFileList := make([]LogFilesDataSource, len(source.LogFiles))
		for logFileIndex, logFileItem := range source.LogFiles {
			// Shadow the loop variable to avoid aliasing
			logFileItem := logFileItem
			var logFile LogFilesDataSource
			err := logFile.Initialize_From_LogFilesDataSource_STATUS(&logFileItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_LogFilesDataSource_STATUS() to populate field LogFiles")
			}
			logFileList[logFileIndex] = logFile
		}
		sources.LogFiles = logFileList
	} else {
		sources.LogFiles = nil
	}

	// PerformanceCounters
	if source.PerformanceCounters != nil {
		performanceCounterList := make([]PerfCounterDataSource, len(source.PerformanceCounters))
		for performanceCounterIndex, performanceCounterItem := range source.PerformanceCounters {
			// Shadow the loop variable to avoid aliasing
			performanceCounterItem := performanceCounterItem
			var performanceCounter PerfCounterDataSource
			err := performanceCounter.Initialize_From_PerfCounterDataSource_STATUS(&performanceCounterItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_PerfCounterDataSource_STATUS() to populate field PerformanceCounters")
			}
			performanceCounterList[performanceCounterIndex] = performanceCounter
		}
		sources.PerformanceCounters = performanceCounterList
	} else {
		sources.PerformanceCounters = nil
	}

	// PlatformTelemetry
	if source.PlatformTelemetry != nil {
		platformTelemetryList := make([]PlatformTelemetryDataSource, len(source.PlatformTelemetry))
		for platformTelemetryIndex, platformTelemetryItem := range source.PlatformTelemetry {
			// Shadow the loop variable to avoid aliasing
			platformTelemetryItem := platformTelemetryItem
			var platformTelemetry PlatformTelemetryDataSource
			err := platformTelemetry.Initialize_From_PlatformTelemetryDataSource_STATUS(&platformTelemetryItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_PlatformTelemetryDataSource_STATUS() to populate field PlatformTelemetry")
			}
			platformTelemetryList[platformTelemetryIndex] = platformTelemetry
		}
		sources.PlatformTelemetry = platformTelemetryList
	} else {
		sources.PlatformTelemetry = nil
	}

	// PrometheusForwarder
	if source.PrometheusForwarder != nil {
		prometheusForwarderList := make([]PrometheusForwarderDataSource, len(source.PrometheusForwarder))
		for prometheusForwarderIndex, prometheusForwarderItem := range source.PrometheusForwarder {
			// Shadow the loop variable to avoid aliasing
			prometheusForwarderItem := prometheusForwarderItem
			var prometheusForwarder PrometheusForwarderDataSource
			err := prometheusForwarder.Initialize_From_PrometheusForwarderDataSource_STATUS(&prometheusForwarderItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_PrometheusForwarderDataSource_STATUS() to populate field PrometheusForwarder")
			}
			prometheusForwarderList[prometheusForwarderIndex] = prometheusForwarder
		}
		sources.PrometheusForwarder = prometheusForwarderList
	} else {
		sources.PrometheusForwarder = nil
	}

	// Syslog
	if source.Syslog != nil {
		syslogList := make([]SyslogDataSource, len(source.Syslog))
		for syslogIndex, syslogItem := range source.Syslog {
			// Shadow the loop variable to avoid aliasing
			syslogItem := syslogItem
			var syslog SyslogDataSource
			err := syslog.Initialize_From_SyslogDataSource_STATUS(&syslogItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_SyslogDataSource_STATUS() to populate field Syslog")
			}
			syslogList[syslogIndex] = syslog
		}
		sources.Syslog = syslogList
	} else {
		sources.Syslog = nil
	}

	// WindowsEventLogs
	if source.WindowsEventLogs != nil {
		windowsEventLogList := make([]WindowsEventLogDataSource, len(source.WindowsEventLogs))
		for windowsEventLogIndex, windowsEventLogItem := range source.WindowsEventLogs {
			// Shadow the loop variable to avoid aliasing
			windowsEventLogItem := windowsEventLogItem
			var windowsEventLog WindowsEventLogDataSource
			err := windowsEventLog.Initialize_From_WindowsEventLogDataSource_STATUS(&windowsEventLogItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_WindowsEventLogDataSource_STATUS() to populate field WindowsEventLogs")
			}
			windowsEventLogList[windowsEventLogIndex] = windowsEventLog
		}
		sources.WindowsEventLogs = windowsEventLogList
	} else {
		sources.WindowsEventLogs = nil
	}

	// WindowsFirewallLogs
	if source.WindowsFirewallLogs != nil {
		windowsFirewallLogList := make([]WindowsFirewallLogsDataSource, len(source.WindowsFirewallLogs))
		for windowsFirewallLogIndex, windowsFirewallLogItem := range source.WindowsFirewallLogs {
			// Shadow the loop variable to avoid aliasing
			windowsFirewallLogItem := windowsFirewallLogItem
			var windowsFirewallLog WindowsFirewallLogsDataSource
			err := windowsFirewallLog.Initialize_From_WindowsFirewallLogsDataSource_STATUS(&windowsFirewallLogItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_WindowsFirewallLogsDataSource_STATUS() to populate field WindowsFirewallLogs")
			}
			windowsFirewallLogList[windowsFirewallLogIndex] = windowsFirewallLog
		}
		sources.WindowsFirewallLogs = windowsFirewallLogList
	} else {
		sources.WindowsFirewallLogs = nil
	}

	// No error
	return nil
}

// Specification of data sources that will be collected.
type DataSourcesSpec_STATUS struct {
	// DataImports: Specifications of pull based data sources
	DataImports *DataImportSources_STATUS `json:"dataImports,omitempty"`

	// Extensions: The list of Azure VM extension data source configurations.
	Extensions []ExtensionDataSource_STATUS `json:"extensions,omitempty"`

	// IisLogs: The list of IIS logs source configurations.
	IisLogs []IisLogsDataSource_STATUS `json:"iisLogs,omitempty"`

	// LogFiles: The list of Log files source configurations.
	LogFiles []LogFilesDataSource_STATUS `json:"logFiles,omitempty"`

	// PerformanceCounters: The list of performance counter data source configurations.
	PerformanceCounters []PerfCounterDataSource_STATUS `json:"performanceCounters,omitempty"`

	// PlatformTelemetry: The list of platform telemetry configurations
	PlatformTelemetry []PlatformTelemetryDataSource_STATUS `json:"platformTelemetry,omitempty"`

	// PrometheusForwarder: The list of Prometheus forwarder data source configurations.
	PrometheusForwarder []PrometheusForwarderDataSource_STATUS `json:"prometheusForwarder,omitempty"`

	// Syslog: The list of Syslog data source configurations.
	Syslog []SyslogDataSource_STATUS `json:"syslog,omitempty"`

	// WindowsEventLogs: The list of Windows Event Log data source configurations.
	WindowsEventLogs []WindowsEventLogDataSource_STATUS `json:"windowsEventLogs,omitempty"`

	// WindowsFirewallLogs: The list of Windows Firewall logs source configurations.
	WindowsFirewallLogs []WindowsFirewallLogsDataSource_STATUS `json:"windowsFirewallLogs,omitempty"`
}

var _ genruntime.FromARMConverter = &DataSourcesSpec_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sources *DataSourcesSpec_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DataSourcesSpec_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sources *DataSourcesSpec_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DataSourcesSpec_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DataSourcesSpec_STATUS, got %T", armInput)
	}

	// Set property "DataImports":
	if typedInput.DataImports != nil {
		var dataImports1 DataImportSources_STATUS
		err := dataImports1.PopulateFromARM(owner, *typedInput.DataImports)
		if err != nil {
			return err
		}
		dataImports := dataImports1
		sources.DataImports = &dataImports
	}

	// Set property "Extensions":
	for _, item := range typedInput.Extensions {
		var item1 ExtensionDataSource_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		sources.Extensions = append(sources.Extensions, item1)
	}

	// Set property "IisLogs":
	for _, item := range typedInput.IisLogs {
		var item1 IisLogsDataSource_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		sources.IisLogs = append(sources.IisLogs, item1)
	}

	// Set property "LogFiles":
	for _, item := range typedInput.LogFiles {
		var item1 LogFilesDataSource_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		sources.LogFiles = append(sources.LogFiles, item1)
	}

	// Set property "PerformanceCounters":
	for _, item := range typedInput.PerformanceCounters {
		var item1 PerfCounterDataSource_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		sources.PerformanceCounters = append(sources.PerformanceCounters, item1)
	}

	// Set property "PlatformTelemetry":
	for _, item := range typedInput.PlatformTelemetry {
		var item1 PlatformTelemetryDataSource_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		sources.PlatformTelemetry = append(sources.PlatformTelemetry, item1)
	}

	// Set property "PrometheusForwarder":
	for _, item := range typedInput.PrometheusForwarder {
		var item1 PrometheusForwarderDataSource_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		sources.PrometheusForwarder = append(sources.PrometheusForwarder, item1)
	}

	// Set property "Syslog":
	for _, item := range typedInput.Syslog {
		var item1 SyslogDataSource_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		sources.Syslog = append(sources.Syslog, item1)
	}

	// Set property "WindowsEventLogs":
	for _, item := range typedInput.WindowsEventLogs {
		var item1 WindowsEventLogDataSource_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		sources.WindowsEventLogs = append(sources.WindowsEventLogs, item1)
	}

	// Set property "WindowsFirewallLogs":
	for _, item := range typedInput.WindowsFirewallLogs {
		var item1 WindowsFirewallLogsDataSource_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		sources.WindowsFirewallLogs = append(sources.WindowsFirewallLogs, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_DataSourcesSpec_STATUS populates our DataSourcesSpec_STATUS from the provided source DataSourcesSpec_STATUS
func (sources *DataSourcesSpec_STATUS) AssignProperties_From_DataSourcesSpec_STATUS(source *storage.DataSourcesSpec_STATUS) error {

	// DataImports
	if source.DataImports != nil {
		var dataImport DataImportSources_STATUS
		err := dataImport.AssignProperties_From_DataImportSources_STATUS(source.DataImports)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DataImportSources_STATUS() to populate field DataImports")
		}
		sources.DataImports = &dataImport
	} else {
		sources.DataImports = nil
	}

	// Extensions
	if source.Extensions != nil {
		extensionList := make([]ExtensionDataSource_STATUS, len(source.Extensions))
		for extensionIndex, extensionItem := range source.Extensions {
			// Shadow the loop variable to avoid aliasing
			extensionItem := extensionItem
			var extension ExtensionDataSource_STATUS
			err := extension.AssignProperties_From_ExtensionDataSource_STATUS(&extensionItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ExtensionDataSource_STATUS() to populate field Extensions")
			}
			extensionList[extensionIndex] = extension
		}
		sources.Extensions = extensionList
	} else {
		sources.Extensions = nil
	}

	// IisLogs
	if source.IisLogs != nil {
		iisLogList := make([]IisLogsDataSource_STATUS, len(source.IisLogs))
		for iisLogIndex, iisLogItem := range source.IisLogs {
			// Shadow the loop variable to avoid aliasing
			iisLogItem := iisLogItem
			var iisLog IisLogsDataSource_STATUS
			err := iisLog.AssignProperties_From_IisLogsDataSource_STATUS(&iisLogItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_IisLogsDataSource_STATUS() to populate field IisLogs")
			}
			iisLogList[iisLogIndex] = iisLog
		}
		sources.IisLogs = iisLogList
	} else {
		sources.IisLogs = nil
	}

	// LogFiles
	if source.LogFiles != nil {
		logFileList := make([]LogFilesDataSource_STATUS, len(source.LogFiles))
		for logFileIndex, logFileItem := range source.LogFiles {
			// Shadow the loop variable to avoid aliasing
			logFileItem := logFileItem
			var logFile LogFilesDataSource_STATUS
			err := logFile.AssignProperties_From_LogFilesDataSource_STATUS(&logFileItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_LogFilesDataSource_STATUS() to populate field LogFiles")
			}
			logFileList[logFileIndex] = logFile
		}
		sources.LogFiles = logFileList
	} else {
		sources.LogFiles = nil
	}

	// PerformanceCounters
	if source.PerformanceCounters != nil {
		performanceCounterList := make([]PerfCounterDataSource_STATUS, len(source.PerformanceCounters))
		for performanceCounterIndex, performanceCounterItem := range source.PerformanceCounters {
			// Shadow the loop variable to avoid aliasing
			performanceCounterItem := performanceCounterItem
			var performanceCounter PerfCounterDataSource_STATUS
			err := performanceCounter.AssignProperties_From_PerfCounterDataSource_STATUS(&performanceCounterItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_PerfCounterDataSource_STATUS() to populate field PerformanceCounters")
			}
			performanceCounterList[performanceCounterIndex] = performanceCounter
		}
		sources.PerformanceCounters = performanceCounterList
	} else {
		sources.PerformanceCounters = nil
	}

	// PlatformTelemetry
	if source.PlatformTelemetry != nil {
		platformTelemetryList := make([]PlatformTelemetryDataSource_STATUS, len(source.PlatformTelemetry))
		for platformTelemetryIndex, platformTelemetryItem := range source.PlatformTelemetry {
			// Shadow the loop variable to avoid aliasing
			platformTelemetryItem := platformTelemetryItem
			var platformTelemetry PlatformTelemetryDataSource_STATUS
			err := platformTelemetry.AssignProperties_From_PlatformTelemetryDataSource_STATUS(&platformTelemetryItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_PlatformTelemetryDataSource_STATUS() to populate field PlatformTelemetry")
			}
			platformTelemetryList[platformTelemetryIndex] = platformTelemetry
		}
		sources.PlatformTelemetry = platformTelemetryList
	} else {
		sources.PlatformTelemetry = nil
	}

	// PrometheusForwarder
	if source.PrometheusForwarder != nil {
		prometheusForwarderList := make([]PrometheusForwarderDataSource_STATUS, len(source.PrometheusForwarder))
		for prometheusForwarderIndex, prometheusForwarderItem := range source.PrometheusForwarder {
			// Shadow the loop variable to avoid aliasing
			prometheusForwarderItem := prometheusForwarderItem
			var prometheusForwarder PrometheusForwarderDataSource_STATUS
			err := prometheusForwarder.AssignProperties_From_PrometheusForwarderDataSource_STATUS(&prometheusForwarderItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_PrometheusForwarderDataSource_STATUS() to populate field PrometheusForwarder")
			}
			prometheusForwarderList[prometheusForwarderIndex] = prometheusForwarder
		}
		sources.PrometheusForwarder = prometheusForwarderList
	} else {
		sources.PrometheusForwarder = nil
	}

	// Syslog
	if source.Syslog != nil {
		syslogList := make([]SyslogDataSource_STATUS, len(source.Syslog))
		for syslogIndex, syslogItem := range source.Syslog {
			// Shadow the loop variable to avoid aliasing
			syslogItem := syslogItem
			var syslog SyslogDataSource_STATUS
			err := syslog.AssignProperties_From_SyslogDataSource_STATUS(&syslogItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_SyslogDataSource_STATUS() to populate field Syslog")
			}
			syslogList[syslogIndex] = syslog
		}
		sources.Syslog = syslogList
	} else {
		sources.Syslog = nil
	}

	// WindowsEventLogs
	if source.WindowsEventLogs != nil {
		windowsEventLogList := make([]WindowsEventLogDataSource_STATUS, len(source.WindowsEventLogs))
		for windowsEventLogIndex, windowsEventLogItem := range source.WindowsEventLogs {
			// Shadow the loop variable to avoid aliasing
			windowsEventLogItem := windowsEventLogItem
			var windowsEventLog WindowsEventLogDataSource_STATUS
			err := windowsEventLog.AssignProperties_From_WindowsEventLogDataSource_STATUS(&windowsEventLogItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_WindowsEventLogDataSource_STATUS() to populate field WindowsEventLogs")
			}
			windowsEventLogList[windowsEventLogIndex] = windowsEventLog
		}
		sources.WindowsEventLogs = windowsEventLogList
	} else {
		sources.WindowsEventLogs = nil
	}

	// WindowsFirewallLogs
	if source.WindowsFirewallLogs != nil {
		windowsFirewallLogList := make([]WindowsFirewallLogsDataSource_STATUS, len(source.WindowsFirewallLogs))
		for windowsFirewallLogIndex, windowsFirewallLogItem := range source.WindowsFirewallLogs {
			// Shadow the loop variable to avoid aliasing
			windowsFirewallLogItem := windowsFirewallLogItem
			var windowsFirewallLog WindowsFirewallLogsDataSource_STATUS
			err := windowsFirewallLog.AssignProperties_From_WindowsFirewallLogsDataSource_STATUS(&windowsFirewallLogItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_WindowsFirewallLogsDataSource_STATUS() to populate field WindowsFirewallLogs")
			}
			windowsFirewallLogList[windowsFirewallLogIndex] = windowsFirewallLog
		}
		sources.WindowsFirewallLogs = windowsFirewallLogList
	} else {
		sources.WindowsFirewallLogs = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DataSourcesSpec_STATUS populates the provided destination DataSourcesSpec_STATUS from our DataSourcesSpec_STATUS
func (sources *DataSourcesSpec_STATUS) AssignProperties_To_DataSourcesSpec_STATUS(destination *storage.DataSourcesSpec_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DataImports
	if sources.DataImports != nil {
		var dataImport storage.DataImportSources_STATUS
		err := sources.DataImports.AssignProperties_To_DataImportSources_STATUS(&dataImport)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DataImportSources_STATUS() to populate field DataImports")
		}
		destination.DataImports = &dataImport
	} else {
		destination.DataImports = nil
	}

	// Extensions
	if sources.Extensions != nil {
		extensionList := make([]storage.ExtensionDataSource_STATUS, len(sources.Extensions))
		for extensionIndex, extensionItem := range sources.Extensions {
			// Shadow the loop variable to avoid aliasing
			extensionItem := extensionItem
			var extension storage.ExtensionDataSource_STATUS
			err := extensionItem.AssignProperties_To_ExtensionDataSource_STATUS(&extension)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ExtensionDataSource_STATUS() to populate field Extensions")
			}
			extensionList[extensionIndex] = extension
		}
		destination.Extensions = extensionList
	} else {
		destination.Extensions = nil
	}

	// IisLogs
	if sources.IisLogs != nil {
		iisLogList := make([]storage.IisLogsDataSource_STATUS, len(sources.IisLogs))
		for iisLogIndex, iisLogItem := range sources.IisLogs {
			// Shadow the loop variable to avoid aliasing
			iisLogItem := iisLogItem
			var iisLog storage.IisLogsDataSource_STATUS
			err := iisLogItem.AssignProperties_To_IisLogsDataSource_STATUS(&iisLog)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_IisLogsDataSource_STATUS() to populate field IisLogs")
			}
			iisLogList[iisLogIndex] = iisLog
		}
		destination.IisLogs = iisLogList
	} else {
		destination.IisLogs = nil
	}

	// LogFiles
	if sources.LogFiles != nil {
		logFileList := make([]storage.LogFilesDataSource_STATUS, len(sources.LogFiles))
		for logFileIndex, logFileItem := range sources.LogFiles {
			// Shadow the loop variable to avoid aliasing
			logFileItem := logFileItem
			var logFile storage.LogFilesDataSource_STATUS
			err := logFileItem.AssignProperties_To_LogFilesDataSource_STATUS(&logFile)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_LogFilesDataSource_STATUS() to populate field LogFiles")
			}
			logFileList[logFileIndex] = logFile
		}
		destination.LogFiles = logFileList
	} else {
		destination.LogFiles = nil
	}

	// PerformanceCounters
	if sources.PerformanceCounters != nil {
		performanceCounterList := make([]storage.PerfCounterDataSource_STATUS, len(sources.PerformanceCounters))
		for performanceCounterIndex, performanceCounterItem := range sources.PerformanceCounters {
			// Shadow the loop variable to avoid aliasing
			performanceCounterItem := performanceCounterItem
			var performanceCounter storage.PerfCounterDataSource_STATUS
			err := performanceCounterItem.AssignProperties_To_PerfCounterDataSource_STATUS(&performanceCounter)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_PerfCounterDataSource_STATUS() to populate field PerformanceCounters")
			}
			performanceCounterList[performanceCounterIndex] = performanceCounter
		}
		destination.PerformanceCounters = performanceCounterList
	} else {
		destination.PerformanceCounters = nil
	}

	// PlatformTelemetry
	if sources.PlatformTelemetry != nil {
		platformTelemetryList := make([]storage.PlatformTelemetryDataSource_STATUS, len(sources.PlatformTelemetry))
		for platformTelemetryIndex, platformTelemetryItem := range sources.PlatformTelemetry {
			// Shadow the loop variable to avoid aliasing
			platformTelemetryItem := platformTelemetryItem
			var platformTelemetry storage.PlatformTelemetryDataSource_STATUS
			err := platformTelemetryItem.AssignProperties_To_PlatformTelemetryDataSource_STATUS(&platformTelemetry)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_PlatformTelemetryDataSource_STATUS() to populate field PlatformTelemetry")
			}
			platformTelemetryList[platformTelemetryIndex] = platformTelemetry
		}
		destination.PlatformTelemetry = platformTelemetryList
	} else {
		destination.PlatformTelemetry = nil
	}

	// PrometheusForwarder
	if sources.PrometheusForwarder != nil {
		prometheusForwarderList := make([]storage.PrometheusForwarderDataSource_STATUS, len(sources.PrometheusForwarder))
		for prometheusForwarderIndex, prometheusForwarderItem := range sources.PrometheusForwarder {
			// Shadow the loop variable to avoid aliasing
			prometheusForwarderItem := prometheusForwarderItem
			var prometheusForwarder storage.PrometheusForwarderDataSource_STATUS
			err := prometheusForwarderItem.AssignProperties_To_PrometheusForwarderDataSource_STATUS(&prometheusForwarder)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_PrometheusForwarderDataSource_STATUS() to populate field PrometheusForwarder")
			}
			prometheusForwarderList[prometheusForwarderIndex] = prometheusForwarder
		}
		destination.PrometheusForwarder = prometheusForwarderList
	} else {
		destination.PrometheusForwarder = nil
	}

	// Syslog
	if sources.Syslog != nil {
		syslogList := make([]storage.SyslogDataSource_STATUS, len(sources.Syslog))
		for syslogIndex, syslogItem := range sources.Syslog {
			// Shadow the loop variable to avoid aliasing
			syslogItem := syslogItem
			var syslog storage.SyslogDataSource_STATUS
			err := syslogItem.AssignProperties_To_SyslogDataSource_STATUS(&syslog)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_SyslogDataSource_STATUS() to populate field Syslog")
			}
			syslogList[syslogIndex] = syslog
		}
		destination.Syslog = syslogList
	} else {
		destination.Syslog = nil
	}

	// WindowsEventLogs
	if sources.WindowsEventLogs != nil {
		windowsEventLogList := make([]storage.WindowsEventLogDataSource_STATUS, len(sources.WindowsEventLogs))
		for windowsEventLogIndex, windowsEventLogItem := range sources.WindowsEventLogs {
			// Shadow the loop variable to avoid aliasing
			windowsEventLogItem := windowsEventLogItem
			var windowsEventLog storage.WindowsEventLogDataSource_STATUS
			err := windowsEventLogItem.AssignProperties_To_WindowsEventLogDataSource_STATUS(&windowsEventLog)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_WindowsEventLogDataSource_STATUS() to populate field WindowsEventLogs")
			}
			windowsEventLogList[windowsEventLogIndex] = windowsEventLog
		}
		destination.WindowsEventLogs = windowsEventLogList
	} else {
		destination.WindowsEventLogs = nil
	}

	// WindowsFirewallLogs
	if sources.WindowsFirewallLogs != nil {
		windowsFirewallLogList := make([]storage.WindowsFirewallLogsDataSource_STATUS, len(sources.WindowsFirewallLogs))
		for windowsFirewallLogIndex, windowsFirewallLogItem := range sources.WindowsFirewallLogs {
			// Shadow the loop variable to avoid aliasing
			windowsFirewallLogItem := windowsFirewallLogItem
			var windowsFirewallLog storage.WindowsFirewallLogsDataSource_STATUS
			err := windowsFirewallLogItem.AssignProperties_To_WindowsFirewallLogsDataSource_STATUS(&windowsFirewallLog)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_WindowsFirewallLogsDataSource_STATUS() to populate field WindowsFirewallLogs")
			}
			windowsFirewallLogList[windowsFirewallLogIndex] = windowsFirewallLog
		}
		destination.WindowsFirewallLogs = windowsFirewallLogList
	} else {
		destination.WindowsFirewallLogs = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Specification of destinations that can be used in data flows.
type DestinationsSpec struct {
	// AzureDataExplorer: List of Azure Data Explorer destinations.
	AzureDataExplorer []AdxDestination `json:"azureDataExplorer,omitempty"`

	// AzureMonitorMetrics: Azure Monitor Metrics destination.
	AzureMonitorMetrics *AzureMonitorMetricsDestination `json:"azureMonitorMetrics,omitempty"`

	// EventHubs: List of Event Hubs destinations.
	EventHubs []EventHubDestination `json:"eventHubs,omitempty"`

	// EventHubsDirect: List of Event Hubs Direct destinations.
	EventHubsDirect []EventHubDirectDestination `json:"eventHubsDirect,omitempty"`

	// LogAnalytics: List of Log Analytics destinations.
	LogAnalytics []LogAnalyticsDestination `json:"logAnalytics,omitempty"`

	// MicrosoftFabric: List of Microsoft Fabric destinations.
	MicrosoftFabric []MicrosoftFabricDestination `json:"microsoftFabric,omitempty"`

	// MonitoringAccounts: List of monitoring account destinations.
	MonitoringAccounts []MonitoringAccountDestination `json:"monitoringAccounts,omitempty"`

	// StorageAccounts: List of storage accounts destinations.
	StorageAccounts []StorageBlobDestination `json:"storageAccounts,omitempty"`

	// StorageBlobsDirect: List of Storage Blob Direct destinations. To be used only for sending data directly to store from
	// the agent.
	StorageBlobsDirect []StorageBlobDestination `json:"storageBlobsDirect,omitempty"`

	// StorageTablesDirect: List of Storage Table Direct destinations.
	StorageTablesDirect []StorageTableDestination `json:"storageTablesDirect,omitempty"`
}

var _ genruntime.ARMTransformer = &DestinationsSpec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (destinations *DestinationsSpec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if destinations == nil {
		return nil, nil
	}
	result := &arm.DestinationsSpec{}

	// Set property "AzureDataExplorer":
	for _, item := range destinations.AzureDataExplorer {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.AzureDataExplorer = append(result.AzureDataExplorer, *item_ARM.(*arm.AdxDestination))
	}

	// Set property "AzureMonitorMetrics":
	if destinations.AzureMonitorMetrics != nil {
		azureMonitorMetrics_ARM, err := (*destinations.AzureMonitorMetrics).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		azureMonitorMetrics := *azureMonitorMetrics_ARM.(*arm.AzureMonitorMetricsDestination)
		result.AzureMonitorMetrics = &azureMonitorMetrics
	}

	// Set property "EventHubs":
	for _, item := range destinations.EventHubs {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.EventHubs = append(result.EventHubs, *item_ARM.(*arm.EventHubDestination))
	}

	// Set property "EventHubsDirect":
	for _, item := range destinations.EventHubsDirect {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.EventHubsDirect = append(result.EventHubsDirect, *item_ARM.(*arm.EventHubDirectDestination))
	}

	// Set property "LogAnalytics":
	for _, item := range destinations.LogAnalytics {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.LogAnalytics = append(result.LogAnalytics, *item_ARM.(*arm.LogAnalyticsDestination))
	}

	// Set property "MicrosoftFabric":
	for _, item := range destinations.MicrosoftFabric {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.MicrosoftFabric = append(result.MicrosoftFabric, *item_ARM.(*arm.MicrosoftFabricDestination))
	}

	// Set property "MonitoringAccounts":
	for _, item := range destinations.MonitoringAccounts {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.MonitoringAccounts = append(result.MonitoringAccounts, *item_ARM.(*arm.MonitoringAccountDestination))
	}

	// Set property "StorageAccounts":
	for _, item := range destinations.StorageAccounts {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.StorageAccounts = append(result.StorageAccounts, *item_ARM.(*arm.StorageBlobDestination))
	}

	// Set property "StorageBlobsDirect":
	for _, item := range destinations.StorageBlobsDirect {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.StorageBlobsDirect = append(result.StorageBlobsDirect, *item_ARM.(*arm.StorageBlobDestination))
	}

	// Set property "StorageTablesDirect":
	for _, item := range destinations.StorageTablesDirect {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.StorageTablesDirect = append(result.StorageTablesDirect, *item_ARM.(*arm.StorageTableDestination))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (destinations *DestinationsSpec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DestinationsSpec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (destinations *DestinationsSpec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DestinationsSpec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DestinationsSpec, got %T", armInput)
	}

	// Set property "AzureDataExplorer":
	for _, item := range typedInput.AzureDataExplorer {
		var item1 AdxDestination
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		destinations.AzureDataExplorer = append(destinations.AzureDataExplorer, item1)
	}

	// Set property "AzureMonitorMetrics":
	if typedInput.AzureMonitorMetrics != nil {
		var azureMonitorMetrics1 AzureMonitorMetricsDestination
		err := azureMonitorMetrics1.PopulateFromARM(owner, *typedInput.AzureMonitorMetrics)
		if err != nil {
			return err
		}
		azureMonitorMetrics := azureMonitorMetrics1
		destinations.AzureMonitorMetrics = &azureMonitorMetrics
	}

	// Set property "EventHubs":
	for _, item := range typedInput.EventHubs {
		var item1 EventHubDestination
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		destinations.EventHubs = append(destinations.EventHubs, item1)
	}

	// Set property "EventHubsDirect":
	for _, item := range typedInput.EventHubsDirect {
		var item1 EventHubDirectDestination
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		destinations.EventHubsDirect = append(destinations.EventHubsDirect, item1)
	}

	// Set property "LogAnalytics":
	for _, item := range typedInput.LogAnalytics {
		var item1 LogAnalyticsDestination
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		destinations.LogAnalytics = append(destinations.LogAnalytics, item1)
	}

	// Set property "MicrosoftFabric":
	for _, item := range typedInput.MicrosoftFabric {
		var item1 MicrosoftFabricDestination
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		destinations.MicrosoftFabric = append(destinations.MicrosoftFabric, item1)
	}

	// Set property "MonitoringAccounts":
	for _, item := range typedInput.MonitoringAccounts {
		var item1 MonitoringAccountDestination
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		destinations.MonitoringAccounts = append(destinations.MonitoringAccounts, item1)
	}

	// Set property "StorageAccounts":
	for _, item := range typedInput.StorageAccounts {
		var item1 StorageBlobDestination
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		destinations.StorageAccounts = append(destinations.StorageAccounts, item1)
	}

	// Set property "StorageBlobsDirect":
	for _, item := range typedInput.StorageBlobsDirect {
		var item1 StorageBlobDestination
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		destinations.StorageBlobsDirect = append(destinations.StorageBlobsDirect, item1)
	}

	// Set property "StorageTablesDirect":
	for _, item := range typedInput.StorageTablesDirect {
		var item1 StorageTableDestination
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		destinations.StorageTablesDirect = append(destinations.StorageTablesDirect, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_DestinationsSpec populates our DestinationsSpec from the provided source DestinationsSpec
func (destinations *DestinationsSpec) AssignProperties_From_DestinationsSpec(source *storage.DestinationsSpec) error {

	// AzureDataExplorer
	if source.AzureDataExplorer != nil {
		azureDataExplorerList := make([]AdxDestination, len(source.AzureDataExplorer))
		for azureDataExplorerIndex, azureDataExplorerItem := range source.AzureDataExplorer {
			// Shadow the loop variable to avoid aliasing
			azureDataExplorerItem := azureDataExplorerItem
			var azureDataExplorer AdxDestination
			err := azureDataExplorer.AssignProperties_From_AdxDestination(&azureDataExplorerItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_AdxDestination() to populate field AzureDataExplorer")
			}
			azureDataExplorerList[azureDataExplorerIndex] = azureDataExplorer
		}
		destinations.AzureDataExplorer = azureDataExplorerList
	} else {
		destinations.AzureDataExplorer = nil
	}

	// AzureMonitorMetrics
	if source.AzureMonitorMetrics != nil {
		var azureMonitorMetric AzureMonitorMetricsDestination
		err := azureMonitorMetric.AssignProperties_From_AzureMonitorMetricsDestination(source.AzureMonitorMetrics)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AzureMonitorMetricsDestination() to populate field AzureMonitorMetrics")
		}
		destinations.AzureMonitorMetrics = &azureMonitorMetric
	} else {
		destinations.AzureMonitorMetrics = nil
	}

	// EventHubs
	if source.EventHubs != nil {
		eventHubList := make([]EventHubDestination, len(source.EventHubs))
		for eventHubIndex, eventHubItem := range source.EventHubs {
			// Shadow the loop variable to avoid aliasing
			eventHubItem := eventHubItem
			var eventHub EventHubDestination
			err := eventHub.AssignProperties_From_EventHubDestination(&eventHubItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_EventHubDestination() to populate field EventHubs")
			}
			eventHubList[eventHubIndex] = eventHub
		}
		destinations.EventHubs = eventHubList
	} else {
		destinations.EventHubs = nil
	}

	// EventHubsDirect
	if source.EventHubsDirect != nil {
		eventHubsDirectList := make([]EventHubDirectDestination, len(source.EventHubsDirect))
		for eventHubsDirectIndex, eventHubsDirectItem := range source.EventHubsDirect {
			// Shadow the loop variable to avoid aliasing
			eventHubsDirectItem := eventHubsDirectItem
			var eventHubsDirect EventHubDirectDestination
			err := eventHubsDirect.AssignProperties_From_EventHubDirectDestination(&eventHubsDirectItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_EventHubDirectDestination() to populate field EventHubsDirect")
			}
			eventHubsDirectList[eventHubsDirectIndex] = eventHubsDirect
		}
		destinations.EventHubsDirect = eventHubsDirectList
	} else {
		destinations.EventHubsDirect = nil
	}

	// LogAnalytics
	if source.LogAnalytics != nil {
		logAnalyticList := make([]LogAnalyticsDestination, len(source.LogAnalytics))
		for logAnalyticIndex, logAnalyticItem := range source.LogAnalytics {
			// Shadow the loop variable to avoid aliasing
			logAnalyticItem := logAnalyticItem
			var logAnalytic LogAnalyticsDestination
			err := logAnalytic.AssignProperties_From_LogAnalyticsDestination(&logAnalyticItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_LogAnalyticsDestination() to populate field LogAnalytics")
			}
			logAnalyticList[logAnalyticIndex] = logAnalytic
		}
		destinations.LogAnalytics = logAnalyticList
	} else {
		destinations.LogAnalytics = nil
	}

	// MicrosoftFabric
	if source.MicrosoftFabric != nil {
		microsoftFabricList := make([]MicrosoftFabricDestination, len(source.MicrosoftFabric))
		for microsoftFabricIndex, microsoftFabricItem := range source.MicrosoftFabric {
			// Shadow the loop variable to avoid aliasing
			microsoftFabricItem := microsoftFabricItem
			var microsoftFabric MicrosoftFabricDestination
			err := microsoftFabric.AssignProperties_From_MicrosoftFabricDestination(&microsoftFabricItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_MicrosoftFabricDestination() to populate field MicrosoftFabric")
			}
			microsoftFabricList[microsoftFabricIndex] = microsoftFabric
		}
		destinations.MicrosoftFabric = microsoftFabricList
	} else {
		destinations.MicrosoftFabric = nil
	}

	// MonitoringAccounts
	if source.MonitoringAccounts != nil {
		monitoringAccountList := make([]MonitoringAccountDestination, len(source.MonitoringAccounts))
		for monitoringAccountIndex, monitoringAccountItem := range source.MonitoringAccounts {
			// Shadow the loop variable to avoid aliasing
			monitoringAccountItem := monitoringAccountItem
			var monitoringAccount MonitoringAccountDestination
			err := monitoringAccount.AssignProperties_From_MonitoringAccountDestination(&monitoringAccountItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_MonitoringAccountDestination() to populate field MonitoringAccounts")
			}
			monitoringAccountList[monitoringAccountIndex] = monitoringAccount
		}
		destinations.MonitoringAccounts = monitoringAccountList
	} else {
		destinations.MonitoringAccounts = nil
	}

	// StorageAccounts
	if source.StorageAccounts != nil {
		storageAccountList := make([]StorageBlobDestination, len(source.StorageAccounts))
		for storageAccountIndex, storageAccountItem := range source.StorageAccounts {
			// Shadow the loop variable to avoid aliasing
			storageAccountItem := storageAccountItem
			var storageAccount StorageBlobDestination
			err := storageAccount.AssignProperties_From_StorageBlobDestination(&storageAccountItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_StorageBlobDestination() to populate field StorageAccounts")
			}
			storageAccountList[storageAccountIndex] = storageAccount
		}
		destinations.StorageAccounts = storageAccountList
	} else {
		destinations.StorageAccounts = nil
	}

	// StorageBlobsDirect
	if source.StorageBlobsDirect != nil {
		storageBlobsDirectList := make([]StorageBlobDestination, len(source.StorageBlobsDirect))
		for storageBlobsDirectIndex, storageBlobsDirectItem := range source.StorageBlobsDirect {
			// Shadow the loop variable to avoid aliasing
			storageBlobsDirectItem := storageBlobsDirectItem
			var storageBlobsDirect StorageBlobDestination
			err := storageBlobsDirect.AssignProperties_From_StorageBlobDestination(&storageBlobsDirectItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_StorageBlobDestination() to populate field StorageBlobsDirect")
			}
			storageBlobsDirectList[storageBlobsDirectIndex] = storageBlobsDirect
		}
		destinations.StorageBlobsDirect = storageBlobsDirectList
	} else {
		destinations.StorageBlobsDirect = nil
	}

	// StorageTablesDirect
	if source.StorageTablesDirect != nil {
		storageTablesDirectList := make([]StorageTableDestination, len(source.StorageTablesDirect))
		for storageTablesDirectIndex, storageTablesDirectItem := range source.StorageTablesDirect {
			// Shadow the loop variable to avoid aliasing
			storageTablesDirectItem := storageTablesDirectItem
			var storageTablesDirect StorageTableDestination
			err := storageTablesDirect.AssignProperties_From_StorageTableDestination(&storageTablesDirectItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_StorageTableDestination() to populate field StorageTablesDirect")
			}
			storageTablesDirectList[storageTablesDirectIndex] = storageTablesDirect
		}
		destinations.StorageTablesDirect = storageTablesDirectList
	} else {
		destinations.StorageTablesDirect = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DestinationsSpec populates the provided destination DestinationsSpec from our DestinationsSpec
func (destinations *DestinationsSpec) AssignProperties_To_DestinationsSpec(destination *storage.DestinationsSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureDataExplorer
	if destinations.AzureDataExplorer != nil {
		azureDataExplorerList := make([]storage.AdxDestination, len(destinations.AzureDataExplorer))
		for azureDataExplorerIndex, azureDataExplorerItem := range destinations.AzureDataExplorer {
			// Shadow the loop variable to avoid aliasing
			azureDataExplorerItem := azureDataExplorerItem
			var azureDataExplorer storage.AdxDestination
			err := azureDataExplorerItem.AssignProperties_To_AdxDestination(&azureDataExplorer)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_AdxDestination() to populate field AzureDataExplorer")
			}
			azureDataExplorerList[azureDataExplorerIndex] = azureDataExplorer
		}
		destination.AzureDataExplorer = azureDataExplorerList
	} else {
		destination.AzureDataExplorer = nil
	}

	// AzureMonitorMetrics
	if destinations.AzureMonitorMetrics != nil {
		var azureMonitorMetric storage.AzureMonitorMetricsDestination
		err := destinations.AzureMonitorMetrics.AssignProperties_To_AzureMonitorMetricsDestination(&azureMonitorMetric)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AzureMonitorMetricsDestination() to populate field AzureMonitorMetrics")
		}
		destination.AzureMonitorMetrics = &azureMonitorMetric
	} else {
		destination.AzureMonitorMetrics = nil
	}

	// EventHubs
	if destinations.EventHubs != nil {
		eventHubList := make([]storage.EventHubDestination, len(destinations.EventHubs))
		for eventHubIndex, eventHubItem := range destinations.EventHubs {
			// Shadow the loop variable to avoid aliasing
			eventHubItem := eventHubItem
			var eventHub storage.EventHubDestination
			err := eventHubItem.AssignProperties_To_EventHubDestination(&eventHub)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_EventHubDestination() to populate field EventHubs")
			}
			eventHubList[eventHubIndex] = eventHub
		}
		destination.EventHubs = eventHubList
	} else {
		destination.EventHubs = nil
	}

	// EventHubsDirect
	if destinations.EventHubsDirect != nil {
		eventHubsDirectList := make([]storage.EventHubDirectDestination, len(destinations.EventHubsDirect))
		for eventHubsDirectIndex, eventHubsDirectItem := range destinations.EventHubsDirect {
			// Shadow the loop variable to avoid aliasing
			eventHubsDirectItem := eventHubsDirectItem
			var eventHubsDirect storage.EventHubDirectDestination
			err := eventHubsDirectItem.AssignProperties_To_EventHubDirectDestination(&eventHubsDirect)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_EventHubDirectDestination() to populate field EventHubsDirect")
			}
			eventHubsDirectList[eventHubsDirectIndex] = eventHubsDirect
		}
		destination.EventHubsDirect = eventHubsDirectList
	} else {
		destination.EventHubsDirect = nil
	}

	// LogAnalytics
	if destinations.LogAnalytics != nil {
		logAnalyticList := make([]storage.LogAnalyticsDestination, len(destinations.LogAnalytics))
		for logAnalyticIndex, logAnalyticItem := range destinations.LogAnalytics {
			// Shadow the loop variable to avoid aliasing
			logAnalyticItem := logAnalyticItem
			var logAnalytic storage.LogAnalyticsDestination
			err := logAnalyticItem.AssignProperties_To_LogAnalyticsDestination(&logAnalytic)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_LogAnalyticsDestination() to populate field LogAnalytics")
			}
			logAnalyticList[logAnalyticIndex] = logAnalytic
		}
		destination.LogAnalytics = logAnalyticList
	} else {
		destination.LogAnalytics = nil
	}

	// MicrosoftFabric
	if destinations.MicrosoftFabric != nil {
		microsoftFabricList := make([]storage.MicrosoftFabricDestination, len(destinations.MicrosoftFabric))
		for microsoftFabricIndex, microsoftFabricItem := range destinations.MicrosoftFabric {
			// Shadow the loop variable to avoid aliasing
			microsoftFabricItem := microsoftFabricItem
			var microsoftFabric storage.MicrosoftFabricDestination
			err := microsoftFabricItem.AssignProperties_To_MicrosoftFabricDestination(&microsoftFabric)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_MicrosoftFabricDestination() to populate field MicrosoftFabric")
			}
			microsoftFabricList[microsoftFabricIndex] = microsoftFabric
		}
		destination.MicrosoftFabric = microsoftFabricList
	} else {
		destination.MicrosoftFabric = nil
	}

	// MonitoringAccounts
	if destinations.MonitoringAccounts != nil {
		monitoringAccountList := make([]storage.MonitoringAccountDestination, len(destinations.MonitoringAccounts))
		for monitoringAccountIndex, monitoringAccountItem := range destinations.MonitoringAccounts {
			// Shadow the loop variable to avoid aliasing
			monitoringAccountItem := monitoringAccountItem
			var monitoringAccount storage.MonitoringAccountDestination
			err := monitoringAccountItem.AssignProperties_To_MonitoringAccountDestination(&monitoringAccount)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_MonitoringAccountDestination() to populate field MonitoringAccounts")
			}
			monitoringAccountList[monitoringAccountIndex] = monitoringAccount
		}
		destination.MonitoringAccounts = monitoringAccountList
	} else {
		destination.MonitoringAccounts = nil
	}

	// StorageAccounts
	if destinations.StorageAccounts != nil {
		storageAccountList := make([]storage.StorageBlobDestination, len(destinations.StorageAccounts))
		for storageAccountIndex, storageAccountItem := range destinations.StorageAccounts {
			// Shadow the loop variable to avoid aliasing
			storageAccountItem := storageAccountItem
			var storageAccount storage.StorageBlobDestination
			err := storageAccountItem.AssignProperties_To_StorageBlobDestination(&storageAccount)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_StorageBlobDestination() to populate field StorageAccounts")
			}
			storageAccountList[storageAccountIndex] = storageAccount
		}
		destination.StorageAccounts = storageAccountList
	} else {
		destination.StorageAccounts = nil
	}

	// StorageBlobsDirect
	if destinations.StorageBlobsDirect != nil {
		storageBlobsDirectList := make([]storage.StorageBlobDestination, len(destinations.StorageBlobsDirect))
		for storageBlobsDirectIndex, storageBlobsDirectItem := range destinations.StorageBlobsDirect {
			// Shadow the loop variable to avoid aliasing
			storageBlobsDirectItem := storageBlobsDirectItem
			var storageBlobsDirect storage.StorageBlobDestination
			err := storageBlobsDirectItem.AssignProperties_To_StorageBlobDestination(&storageBlobsDirect)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_StorageBlobDestination() to populate field StorageBlobsDirect")
			}
			storageBlobsDirectList[storageBlobsDirectIndex] = storageBlobsDirect
		}
		destination.StorageBlobsDirect = storageBlobsDirectList
	} else {
		destination.StorageBlobsDirect = nil
	}

	// StorageTablesDirect
	if destinations.StorageTablesDirect != nil {
		storageTablesDirectList := make([]storage.StorageTableDestination, len(destinations.StorageTablesDirect))
		for storageTablesDirectIndex, storageTablesDirectItem := range destinations.StorageTablesDirect {
			// Shadow the loop variable to avoid aliasing
			storageTablesDirectItem := storageTablesDirectItem
			var storageTablesDirect storage.StorageTableDestination
			err := storageTablesDirectItem.AssignProperties_To_StorageTableDestination(&storageTablesDirect)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_StorageTableDestination() to populate field StorageTablesDirect")
			}
			storageTablesDirectList[storageTablesDirectIndex] = storageTablesDirect
		}
		destination.StorageTablesDirect = storageTablesDirectList
	} else {
		destination.StorageTablesDirect = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DestinationsSpec_STATUS populates our DestinationsSpec from the provided source DestinationsSpec_STATUS
func (destinations *DestinationsSpec) Initialize_From_DestinationsSpec_STATUS(source *DestinationsSpec_STATUS) error {

	// AzureDataExplorer
	if source.AzureDataExplorer != nil {
		azureDataExplorerList := make([]AdxDestination, len(source.AzureDataExplorer))
		for azureDataExplorerIndex, azureDataExplorerItem := range source.AzureDataExplorer {
			// Shadow the loop variable to avoid aliasing
			azureDataExplorerItem := azureDataExplorerItem
			var azureDataExplorer AdxDestination
			err := azureDataExplorer.Initialize_From_AdxDestination_STATUS(&azureDataExplorerItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_AdxDestination_STATUS() to populate field AzureDataExplorer")
			}
			azureDataExplorerList[azureDataExplorerIndex] = azureDataExplorer
		}
		destinations.AzureDataExplorer = azureDataExplorerList
	} else {
		destinations.AzureDataExplorer = nil
	}

	// AzureMonitorMetrics
	if source.AzureMonitorMetrics != nil {
		var azureMonitorMetric AzureMonitorMetricsDestination
		err := azureMonitorMetric.Initialize_From_AzureMonitorMetricsDestination_STATUS(source.AzureMonitorMetrics)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_AzureMonitorMetricsDestination_STATUS() to populate field AzureMonitorMetrics")
		}
		destinations.AzureMonitorMetrics = &azureMonitorMetric
	} else {
		destinations.AzureMonitorMetrics = nil
	}

	// EventHubs
	if source.EventHubs != nil {
		eventHubList := make([]EventHubDestination, len(source.EventHubs))
		for eventHubIndex, eventHubItem := range source.EventHubs {
			// Shadow the loop variable to avoid aliasing
			eventHubItem := eventHubItem
			var eventHub EventHubDestination
			err := eventHub.Initialize_From_EventHubDestination_STATUS(&eventHubItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_EventHubDestination_STATUS() to populate field EventHubs")
			}
			eventHubList[eventHubIndex] = eventHub
		}
		destinations.EventHubs = eventHubList
	} else {
		destinations.EventHubs = nil
	}

	// EventHubsDirect
	if source.EventHubsDirect != nil {
		eventHubsDirectList := make([]EventHubDirectDestination, len(source.EventHubsDirect))
		for eventHubsDirectIndex, eventHubsDirectItem := range source.EventHubsDirect {
			// Shadow the loop variable to avoid aliasing
			eventHubsDirectItem := eventHubsDirectItem
			var eventHubsDirect EventHubDirectDestination
			err := eventHubsDirect.Initialize_From_EventHubDirectDestination_STATUS(&eventHubsDirectItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_EventHubDirectDestination_STATUS() to populate field EventHubsDirect")
			}
			eventHubsDirectList[eventHubsDirectIndex] = eventHubsDirect
		}
		destinations.EventHubsDirect = eventHubsDirectList
	} else {
		destinations.EventHubsDirect = nil
	}

	// LogAnalytics
	if source.LogAnalytics != nil {
		logAnalyticList := make([]LogAnalyticsDestination, len(source.LogAnalytics))
		for logAnalyticIndex, logAnalyticItem := range source.LogAnalytics {
			// Shadow the loop variable to avoid aliasing
			logAnalyticItem := logAnalyticItem
			var logAnalytic LogAnalyticsDestination
			err := logAnalytic.Initialize_From_LogAnalyticsDestination_STATUS(&logAnalyticItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_LogAnalyticsDestination_STATUS() to populate field LogAnalytics")
			}
			logAnalyticList[logAnalyticIndex] = logAnalytic
		}
		destinations.LogAnalytics = logAnalyticList
	} else {
		destinations.LogAnalytics = nil
	}

	// MicrosoftFabric
	if source.MicrosoftFabric != nil {
		microsoftFabricList := make([]MicrosoftFabricDestination, len(source.MicrosoftFabric))
		for microsoftFabricIndex, microsoftFabricItem := range source.MicrosoftFabric {
			// Shadow the loop variable to avoid aliasing
			microsoftFabricItem := microsoftFabricItem
			var microsoftFabric MicrosoftFabricDestination
			err := microsoftFabric.Initialize_From_MicrosoftFabricDestination_STATUS(&microsoftFabricItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_MicrosoftFabricDestination_STATUS() to populate field MicrosoftFabric")
			}
			microsoftFabricList[microsoftFabricIndex] = microsoftFabric
		}
		destinations.MicrosoftFabric = microsoftFabricList
	} else {
		destinations.MicrosoftFabric = nil
	}

	// MonitoringAccounts
	if source.MonitoringAccounts != nil {
		monitoringAccountList := make([]MonitoringAccountDestination, len(source.MonitoringAccounts))
		for monitoringAccountIndex, monitoringAccountItem := range source.MonitoringAccounts {
			// Shadow the loop variable to avoid aliasing
			monitoringAccountItem := monitoringAccountItem
			var monitoringAccount MonitoringAccountDestination
			err := monitoringAccount.Initialize_From_MonitoringAccountDestination_STATUS(&monitoringAccountItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_MonitoringAccountDestination_STATUS() to populate field MonitoringAccounts")
			}
			monitoringAccountList[monitoringAccountIndex] = monitoringAccount
		}
		destinations.MonitoringAccounts = monitoringAccountList
	} else {
		destinations.MonitoringAccounts = nil
	}

	// StorageAccounts
	if source.StorageAccounts != nil {
		storageAccountList := make([]StorageBlobDestination, len(source.StorageAccounts))
		for storageAccountIndex, storageAccountItem := range source.StorageAccounts {
			// Shadow the loop variable to avoid aliasing
			storageAccountItem := storageAccountItem
			var storageAccount StorageBlobDestination
			err := storageAccount.Initialize_From_StorageBlobDestination_STATUS(&storageAccountItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_StorageBlobDestination_STATUS() to populate field StorageAccounts")
			}
			storageAccountList[storageAccountIndex] = storageAccount
		}
		destinations.StorageAccounts = storageAccountList
	} else {
		destinations.StorageAccounts = nil
	}

	// StorageBlobsDirect
	if source.StorageBlobsDirect != nil {
		storageBlobsDirectList := make([]StorageBlobDestination, len(source.StorageBlobsDirect))
		for storageBlobsDirectIndex, storageBlobsDirectItem := range source.StorageBlobsDirect {
			// Shadow the loop variable to avoid aliasing
			storageBlobsDirectItem := storageBlobsDirectItem
			var storageBlobsDirect StorageBlobDestination
			err := storageBlobsDirect.Initialize_From_StorageBlobDestination_STATUS(&storageBlobsDirectItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_StorageBlobDestination_STATUS() to populate field StorageBlobsDirect")
			}
			storageBlobsDirectList[storageBlobsDirectIndex] = storageBlobsDirect
		}
		destinations.StorageBlobsDirect = storageBlobsDirectList
	} else {
		destinations.StorageBlobsDirect = nil
	}

	// StorageTablesDirect
	if source.StorageTablesDirect != nil {
		storageTablesDirectList := make([]StorageTableDestination, len(source.StorageTablesDirect))
		for storageTablesDirectIndex, storageTablesDirectItem := range source.StorageTablesDirect {
			// Shadow the loop variable to avoid aliasing
			storageTablesDirectItem := storageTablesDirectItem
			var storageTablesDirect StorageTableDestination
			err := storageTablesDirect.Initialize_From_StorageTableDestination_STATUS(&storageTablesDirectItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_StorageTableDestination_STATUS() to populate field StorageTablesDirect")
			}
			storageTablesDirectList[storageTablesDirectIndex] = storageTablesDirect
		}
		destinations.StorageTablesDirect = storageTablesDirectList
	} else {
		destinations.StorageTablesDirect = nil
	}

	// No error
	return nil
}

// Specification of destinations that can be used in data flows.
type DestinationsSpec_STATUS struct {
	// AzureDataExplorer: List of Azure Data Explorer destinations.
	AzureDataExplorer []AdxDestination_STATUS `json:"azureDataExplorer,omitempty"`

	// AzureMonitorMetrics: Azure Monitor Metrics destination.
	AzureMonitorMetrics *AzureMonitorMetricsDestination_STATUS `json:"azureMonitorMetrics,omitempty"`

	// EventHubs: List of Event Hubs destinations.
	EventHubs []EventHubDestination_STATUS `json:"eventHubs,omitempty"`

	// EventHubsDirect: List of Event Hubs Direct destinations.
	EventHubsDirect []EventHubDirectDestination_STATUS `json:"eventHubsDirect,omitempty"`

	// LogAnalytics: List of Log Analytics destinations.
	LogAnalytics []LogAnalyticsDestination_STATUS `json:"logAnalytics,omitempty"`

	// MicrosoftFabric: List of Microsoft Fabric destinations.
	MicrosoftFabric []MicrosoftFabricDestination_STATUS `json:"microsoftFabric,omitempty"`

	// MonitoringAccounts: List of monitoring account destinations.
	MonitoringAccounts []MonitoringAccountDestination_STATUS `json:"monitoringAccounts,omitempty"`

	// StorageAccounts: List of storage accounts destinations.
	StorageAccounts []StorageBlobDestination_STATUS `json:"storageAccounts,omitempty"`

	// StorageBlobsDirect: List of Storage Blob Direct destinations. To be used only for sending data directly to store from
	// the agent.
	StorageBlobsDirect []StorageBlobDestination_STATUS `json:"storageBlobsDirect,omitempty"`

	// StorageTablesDirect: List of Storage Table Direct destinations.
	StorageTablesDirect []StorageTableDestination_STATUS `json:"storageTablesDirect,omitempty"`
}

var _ genruntime.FromARMConverter = &DestinationsSpec_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (destinations *DestinationsSpec_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DestinationsSpec_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (destinations *DestinationsSpec_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DestinationsSpec_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DestinationsSpec_STATUS, got %T", armInput)
	}

	// Set property "AzureDataExplorer":
	for _, item := range typedInput.AzureDataExplorer {
		var item1 AdxDestination_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		destinations.AzureDataExplorer = append(destinations.AzureDataExplorer, item1)
	}

	// Set property "AzureMonitorMetrics":
	if typedInput.AzureMonitorMetrics != nil {
		var azureMonitorMetrics1 AzureMonitorMetricsDestination_STATUS
		err := azureMonitorMetrics1.PopulateFromARM(owner, *typedInput.AzureMonitorMetrics)
		if err != nil {
			return err
		}
		azureMonitorMetrics := azureMonitorMetrics1
		destinations.AzureMonitorMetrics = &azureMonitorMetrics
	}

	// Set property "EventHubs":
	for _, item := range typedInput.EventHubs {
		var item1 EventHubDestination_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		destinations.EventHubs = append(destinations.EventHubs, item1)
	}

	// Set property "EventHubsDirect":
	for _, item := range typedInput.EventHubsDirect {
		var item1 EventHubDirectDestination_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		destinations.EventHubsDirect = append(destinations.EventHubsDirect, item1)
	}

	// Set property "LogAnalytics":
	for _, item := range typedInput.LogAnalytics {
		var item1 LogAnalyticsDestination_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		destinations.LogAnalytics = append(destinations.LogAnalytics, item1)
	}

	// Set property "MicrosoftFabric":
	for _, item := range typedInput.MicrosoftFabric {
		var item1 MicrosoftFabricDestination_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		destinations.MicrosoftFabric = append(destinations.MicrosoftFabric, item1)
	}

	// Set property "MonitoringAccounts":
	for _, item := range typedInput.MonitoringAccounts {
		var item1 MonitoringAccountDestination_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		destinations.MonitoringAccounts = append(destinations.MonitoringAccounts, item1)
	}

	// Set property "StorageAccounts":
	for _, item := range typedInput.StorageAccounts {
		var item1 StorageBlobDestination_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		destinations.StorageAccounts = append(destinations.StorageAccounts, item1)
	}

	// Set property "StorageBlobsDirect":
	for _, item := range typedInput.StorageBlobsDirect {
		var item1 StorageBlobDestination_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		destinations.StorageBlobsDirect = append(destinations.StorageBlobsDirect, item1)
	}

	// Set property "StorageTablesDirect":
	for _, item := range typedInput.StorageTablesDirect {
		var item1 StorageTableDestination_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		destinations.StorageTablesDirect = append(destinations.StorageTablesDirect, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_DestinationsSpec_STATUS populates our DestinationsSpec_STATUS from the provided source DestinationsSpec_STATUS
func (destinations *DestinationsSpec_STATUS) AssignProperties_From_DestinationsSpec_STATUS(source *storage.DestinationsSpec_STATUS) error {

	// AzureDataExplorer
	if source.AzureDataExplorer != nil {
		azureDataExplorerList := make([]AdxDestination_STATUS, len(source.AzureDataExplorer))
		for azureDataExplorerIndex, azureDataExplorerItem := range source.AzureDataExplorer {
			// Shadow the loop variable to avoid aliasing
			azureDataExplorerItem := azureDataExplorerItem
			var azureDataExplorer AdxDestination_STATUS
			err := azureDataExplorer.AssignProperties_From_AdxDestination_STATUS(&azureDataExplorerItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_AdxDestination_STATUS() to populate field AzureDataExplorer")
			}
			azureDataExplorerList[azureDataExplorerIndex] = azureDataExplorer
		}
		destinations.AzureDataExplorer = azureDataExplorerList
	} else {
		destinations.AzureDataExplorer = nil
	}

	// AzureMonitorMetrics
	if source.AzureMonitorMetrics != nil {
		var azureMonitorMetric AzureMonitorMetricsDestination_STATUS
		err := azureMonitorMetric.AssignProperties_From_AzureMonitorMetricsDestination_STATUS(source.AzureMonitorMetrics)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AzureMonitorMetricsDestination_STATUS() to populate field AzureMonitorMetrics")
		}
		destinations.AzureMonitorMetrics = &azureMonitorMetric
	} else {
		destinations.AzureMonitorMetrics = nil
	}

	// EventHubs
	if source.EventHubs != nil {
		eventHubList := make([]EventHubDestination_STATUS, len(source.EventHubs))
		for eventHubIndex, eventHubItem := range source.EventHubs {
			// Shadow the loop variable to avoid aliasing
			eventHubItem := eventHubItem
			var eventHub EventHubDestination_STATUS
			err := eventHub.AssignProperties_From_EventHubDestination_STATUS(&eventHubItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_EventHubDestination_STATUS() to populate field EventHubs")
			}
			eventHubList[eventHubIndex] = eventHub
		}
		destinations.EventHubs = eventHubList
	} else {
		destinations.EventHubs = nil
	}

	// EventHubsDirect
	if source.EventHubsDirect != nil {
		eventHubsDirectList := make([]EventHubDirectDestination_STATUS, len(source.EventHubsDirect))
		for eventHubsDirectIndex, eventHubsDirectItem := range source.EventHubsDirect {
			// Shadow the loop variable to avoid aliasing
			eventHubsDirectItem := eventHubsDirectItem
			var eventHubsDirect EventHubDirectDestination_STATUS
			err := eventHubsDirect.AssignProperties_From_EventHubDirectDestination_STATUS(&eventHubsDirectItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_EventHubDirectDestination_STATUS() to populate field EventHubsDirect")
			}
			eventHubsDirectList[eventHubsDirectIndex] = eventHubsDirect
		}
		destinations.EventHubsDirect = eventHubsDirectList
	} else {
		destinations.EventHubsDirect = nil
	}

	// LogAnalytics
	if source.LogAnalytics != nil {
		logAnalyticList := make([]LogAnalyticsDestination_STATUS, len(source.LogAnalytics))
		for logAnalyticIndex, logAnalyticItem := range source.LogAnalytics {
			// Shadow the loop variable to avoid aliasing
			logAnalyticItem := logAnalyticItem
			var logAnalytic LogAnalyticsDestination_STATUS
			err := logAnalytic.AssignProperties_From_LogAnalyticsDestination_STATUS(&logAnalyticItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_LogAnalyticsDestination_STATUS() to populate field LogAnalytics")
			}
			logAnalyticList[logAnalyticIndex] = logAnalytic
		}
		destinations.LogAnalytics = logAnalyticList
	} else {
		destinations.LogAnalytics = nil
	}

	// MicrosoftFabric
	if source.MicrosoftFabric != nil {
		microsoftFabricList := make([]MicrosoftFabricDestination_STATUS, len(source.MicrosoftFabric))
		for microsoftFabricIndex, microsoftFabricItem := range source.MicrosoftFabric {
			// Shadow the loop variable to avoid aliasing
			microsoftFabricItem := microsoftFabricItem
			var microsoftFabric MicrosoftFabricDestination_STATUS
			err := microsoftFabric.AssignProperties_From_MicrosoftFabricDestination_STATUS(&microsoftFabricItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_MicrosoftFabricDestination_STATUS() to populate field MicrosoftFabric")
			}
			microsoftFabricList[microsoftFabricIndex] = microsoftFabric
		}
		destinations.MicrosoftFabric = microsoftFabricList
	} else {
		destinations.MicrosoftFabric = nil
	}

	// MonitoringAccounts
	if source.MonitoringAccounts != nil {
		monitoringAccountList := make([]MonitoringAccountDestination_STATUS, len(source.MonitoringAccounts))
		for monitoringAccountIndex, monitoringAccountItem := range source.MonitoringAccounts {
			// Shadow the loop variable to avoid aliasing
			monitoringAccountItem := monitoringAccountItem
			var monitoringAccount MonitoringAccountDestination_STATUS
			err := monitoringAccount.AssignProperties_From_MonitoringAccountDestination_STATUS(&monitoringAccountItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_MonitoringAccountDestination_STATUS() to populate field MonitoringAccounts")
			}
			monitoringAccountList[monitoringAccountIndex] = monitoringAccount
		}
		destinations.MonitoringAccounts = monitoringAccountList
	} else {
		destinations.MonitoringAccounts = nil
	}

	// StorageAccounts
	if source.StorageAccounts != nil {
		storageAccountList := make([]StorageBlobDestination_STATUS, len(source.StorageAccounts))
		for storageAccountIndex, storageAccountItem := range source.StorageAccounts {
			// Shadow the loop variable to avoid aliasing
			storageAccountItem := storageAccountItem
			var storageAccount StorageBlobDestination_STATUS
			err := storageAccount.AssignProperties_From_StorageBlobDestination_STATUS(&storageAccountItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_StorageBlobDestination_STATUS() to populate field StorageAccounts")
			}
			storageAccountList[storageAccountIndex] = storageAccount
		}
		destinations.StorageAccounts = storageAccountList
	} else {
		destinations.StorageAccounts = nil
	}

	// StorageBlobsDirect
	if source.StorageBlobsDirect != nil {
		storageBlobsDirectList := make([]StorageBlobDestination_STATUS, len(source.StorageBlobsDirect))
		for storageBlobsDirectIndex, storageBlobsDirectItem := range source.StorageBlobsDirect {
			// Shadow the loop variable to avoid aliasing
			storageBlobsDirectItem := storageBlobsDirectItem
			var storageBlobsDirect StorageBlobDestination_STATUS
			err := storageBlobsDirect.AssignProperties_From_StorageBlobDestination_STATUS(&storageBlobsDirectItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_StorageBlobDestination_STATUS() to populate field StorageBlobsDirect")
			}
			storageBlobsDirectList[storageBlobsDirectIndex] = storageBlobsDirect
		}
		destinations.StorageBlobsDirect = storageBlobsDirectList
	} else {
		destinations.StorageBlobsDirect = nil
	}

	// StorageTablesDirect
	if source.StorageTablesDirect != nil {
		storageTablesDirectList := make([]StorageTableDestination_STATUS, len(source.StorageTablesDirect))
		for storageTablesDirectIndex, storageTablesDirectItem := range source.StorageTablesDirect {
			// Shadow the loop variable to avoid aliasing
			storageTablesDirectItem := storageTablesDirectItem
			var storageTablesDirect StorageTableDestination_STATUS
			err := storageTablesDirect.AssignProperties_From_StorageTableDestination_STATUS(&storageTablesDirectItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_StorageTableDestination_STATUS() to populate field StorageTablesDirect")
			}
			storageTablesDirectList[storageTablesDirectIndex] = storageTablesDirect
		}
		destinations.StorageTablesDirect = storageTablesDirectList
	} else {
		destinations.StorageTablesDirect = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DestinationsSpec_STATUS populates the provided destination DestinationsSpec_STATUS from our DestinationsSpec_STATUS
func (destinations *DestinationsSpec_STATUS) AssignProperties_To_DestinationsSpec_STATUS(destination *storage.DestinationsSpec_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureDataExplorer
	if destinations.AzureDataExplorer != nil {
		azureDataExplorerList := make([]storage.AdxDestination_STATUS, len(destinations.AzureDataExplorer))
		for azureDataExplorerIndex, azureDataExplorerItem := range destinations.AzureDataExplorer {
			// Shadow the loop variable to avoid aliasing
			azureDataExplorerItem := azureDataExplorerItem
			var azureDataExplorer storage.AdxDestination_STATUS
			err := azureDataExplorerItem.AssignProperties_To_AdxDestination_STATUS(&azureDataExplorer)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_AdxDestination_STATUS() to populate field AzureDataExplorer")
			}
			azureDataExplorerList[azureDataExplorerIndex] = azureDataExplorer
		}
		destination.AzureDataExplorer = azureDataExplorerList
	} else {
		destination.AzureDataExplorer = nil
	}

	// AzureMonitorMetrics
	if destinations.AzureMonitorMetrics != nil {
		var azureMonitorMetric storage.AzureMonitorMetricsDestination_STATUS
		err := destinations.AzureMonitorMetrics.AssignProperties_To_AzureMonitorMetricsDestination_STATUS(&azureMonitorMetric)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AzureMonitorMetricsDestination_STATUS() to populate field AzureMonitorMetrics")
		}
		destination.AzureMonitorMetrics = &azureMonitorMetric
	} else {
		destination.AzureMonitorMetrics = nil
	}

	// EventHubs
	if destinations.EventHubs != nil {
		eventHubList := make([]storage.EventHubDestination_STATUS, len(destinations.EventHubs))
		for eventHubIndex, eventHubItem := range destinations.EventHubs {
			// Shadow the loop variable to avoid aliasing
			eventHubItem := eventHubItem
			var eventHub storage.EventHubDestination_STATUS
			err := eventHubItem.AssignProperties_To_EventHubDestination_STATUS(&eventHub)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_EventHubDestination_STATUS() to populate field EventHubs")
			}
			eventHubList[eventHubIndex] = eventHub
		}
		destination.EventHubs = eventHubList
	} else {
		destination.EventHubs = nil
	}

	// EventHubsDirect
	if destinations.EventHubsDirect != nil {
		eventHubsDirectList := make([]storage.EventHubDirectDestination_STATUS, len(destinations.EventHubsDirect))
		for eventHubsDirectIndex, eventHubsDirectItem := range destinations.EventHubsDirect {
			// Shadow the loop variable to avoid aliasing
			eventHubsDirectItem := eventHubsDirectItem
			var eventHubsDirect storage.EventHubDirectDestination_STATUS
			err := eventHubsDirectItem.AssignProperties_To_EventHubDirectDestination_STATUS(&eventHubsDirect)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_EventHubDirectDestination_STATUS() to populate field EventHubsDirect")
			}
			eventHubsDirectList[eventHubsDirectIndex] = eventHubsDirect
		}
		destination.EventHubsDirect = eventHubsDirectList
	} else {
		destination.EventHubsDirect = nil
	}

	// LogAnalytics
	if destinations.LogAnalytics != nil {
		logAnalyticList := make([]storage.LogAnalyticsDestination_STATUS, len(destinations.LogAnalytics))
		for logAnalyticIndex, logAnalyticItem := range destinations.LogAnalytics {
			// Shadow the loop variable to avoid aliasing
			logAnalyticItem := logAnalyticItem
			var logAnalytic storage.LogAnalyticsDestination_STATUS
			err := logAnalyticItem.AssignProperties_To_LogAnalyticsDestination_STATUS(&logAnalytic)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_LogAnalyticsDestination_STATUS() to populate field LogAnalytics")
			}
			logAnalyticList[logAnalyticIndex] = logAnalytic
		}
		destination.LogAnalytics = logAnalyticList
	} else {
		destination.LogAnalytics = nil
	}

	// MicrosoftFabric
	if destinations.MicrosoftFabric != nil {
		microsoftFabricList := make([]storage.MicrosoftFabricDestination_STATUS, len(destinations.MicrosoftFabric))
		for microsoftFabricIndex, microsoftFabricItem := range destinations.MicrosoftFabric {
			// Shadow the loop variable to avoid aliasing
			microsoftFabricItem := microsoftFabricItem
			var microsoftFabric storage.MicrosoftFabricDestination_STATUS
			err := microsoftFabricItem.AssignProperties_To_MicrosoftFabricDestination_STATUS(&microsoftFabric)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_MicrosoftFabricDestination_STATUS() to populate field MicrosoftFabric")
			}
			microsoftFabricList[microsoftFabricIndex] = microsoftFabric
		}
		destination.MicrosoftFabric = microsoftFabricList
	} else {
		destination.MicrosoftFabric = nil
	}

	// MonitoringAccounts
	if destinations.MonitoringAccounts != nil {
		monitoringAccountList := make([]storage.MonitoringAccountDestination_STATUS, len(destinations.MonitoringAccounts))
		for monitoringAccountIndex, monitoringAccountItem := range destinations.MonitoringAccounts {
			// Shadow the loop variable to avoid aliasing
			monitoringAccountItem := monitoringAccountItem
			var monitoringAccount storage.MonitoringAccountDestination_STATUS
			err := monitoringAccountItem.AssignProperties_To_MonitoringAccountDestination_STATUS(&monitoringAccount)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_MonitoringAccountDestination_STATUS() to populate field MonitoringAccounts")
			}
			monitoringAccountList[monitoringAccountIndex] = monitoringAccount
		}
		destination.MonitoringAccounts = monitoringAccountList
	} else {
		destination.MonitoringAccounts = nil
	}

	// StorageAccounts
	if destinations.StorageAccounts != nil {
		storageAccountList := make([]storage.StorageBlobDestination_STATUS, len(destinations.StorageAccounts))
		for storageAccountIndex, storageAccountItem := range destinations.StorageAccounts {
			// Shadow the loop variable to avoid aliasing
			storageAccountItem := storageAccountItem
			var storageAccount storage.StorageBlobDestination_STATUS
			err := storageAccountItem.AssignProperties_To_StorageBlobDestination_STATUS(&storageAccount)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_StorageBlobDestination_STATUS() to populate field StorageAccounts")
			}
			storageAccountList[storageAccountIndex] = storageAccount
		}
		destination.StorageAccounts = storageAccountList
	} else {
		destination.StorageAccounts = nil
	}

	// StorageBlobsDirect
	if destinations.StorageBlobsDirect != nil {
		storageBlobsDirectList := make([]storage.StorageBlobDestination_STATUS, len(destinations.StorageBlobsDirect))
		for storageBlobsDirectIndex, storageBlobsDirectItem := range destinations.StorageBlobsDirect {
			// Shadow the loop variable to avoid aliasing
			storageBlobsDirectItem := storageBlobsDirectItem
			var storageBlobsDirect storage.StorageBlobDestination_STATUS
			err := storageBlobsDirectItem.AssignProperties_To_StorageBlobDestination_STATUS(&storageBlobsDirect)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_StorageBlobDestination_STATUS() to populate field StorageBlobsDirect")
			}
			storageBlobsDirectList[storageBlobsDirectIndex] = storageBlobsDirect
		}
		destination.StorageBlobsDirect = storageBlobsDirectList
	} else {
		destination.StorageBlobsDirect = nil
	}

	// StorageTablesDirect
	if destinations.StorageTablesDirect != nil {
		storageTablesDirectList := make([]storage.StorageTableDestination_STATUS, len(destinations.StorageTablesDirect))
		for storageTablesDirectIndex, storageTablesDirectItem := range destinations.StorageTablesDirect {
			// Shadow the loop variable to avoid aliasing
			storageTablesDirectItem := storageTablesDirectItem
			var storageTablesDirect storage.StorageTableDestination_STATUS
			err := storageTablesDirectItem.AssignProperties_To_StorageTableDestination_STATUS(&storageTablesDirect)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_StorageTableDestination_STATUS() to populate field StorageTablesDirect")
			}
			storageTablesDirectList[storageTablesDirectIndex] = storageTablesDirect
		}
		destination.StorageTablesDirect = storageTablesDirectList
	} else {
		destination.StorageTablesDirect = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// This defines all the ingestion endpoints that can be used by this rule
type EndpointsSpec_STATUS struct {
	// LogsIngestion: The ingestion endpoint for logs
	LogsIngestion *string `json:"logsIngestion,omitempty"`

	// MetricsIngestion: The ingestion endpoint for metrics
	MetricsIngestion *string `json:"metricsIngestion,omitempty"`
}

var _ genruntime.FromARMConverter = &EndpointsSpec_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (endpoints *EndpointsSpec_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EndpointsSpec_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (endpoints *EndpointsSpec_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EndpointsSpec_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EndpointsSpec_STATUS, got %T", armInput)
	}

	// Set property "LogsIngestion":
	if typedInput.LogsIngestion != nil {
		logsIngestion := *typedInput.LogsIngestion
		endpoints.LogsIngestion = &logsIngestion
	}

	// Set property "MetricsIngestion":
	if typedInput.MetricsIngestion != nil {
		metricsIngestion := *typedInput.MetricsIngestion
		endpoints.MetricsIngestion = &metricsIngestion
	}

	// No error
	return nil
}

// AssignProperties_From_EndpointsSpec_STATUS populates our EndpointsSpec_STATUS from the provided source EndpointsSpec_STATUS
func (endpoints *EndpointsSpec_STATUS) AssignProperties_From_EndpointsSpec_STATUS(source *storage.EndpointsSpec_STATUS) error {

	// LogsIngestion
	endpoints.LogsIngestion = genruntime.ClonePointerToString(source.LogsIngestion)

	// MetricsIngestion
	endpoints.MetricsIngestion = genruntime.ClonePointerToString(source.MetricsIngestion)

	// No error
	return nil
}

// AssignProperties_To_EndpointsSpec_STATUS populates the provided destination EndpointsSpec_STATUS from our EndpointsSpec_STATUS
func (endpoints *EndpointsSpec_STATUS) AssignProperties_To_EndpointsSpec_STATUS(destination *storage.EndpointsSpec_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// LogsIngestion
	destination.LogsIngestion = genruntime.ClonePointerToString(endpoints.LogsIngestion)

	// MetricsIngestion
	destination.MetricsIngestion = genruntime.ClonePointerToString(endpoints.MetricsIngestion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Managed service identity (system assigned and/or user assigned identities)
type ManagedServiceIdentity struct {
	// +kubebuilder:validation:Required
	// Type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
	Type                   *ManagedServiceIdentityType   `json:"type,omitempty"`
	UserAssignedIdentities []UserAssignedIdentityDetails `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedServiceIdentity{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (identity *ManagedServiceIdentity) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if identity == nil {
		return nil, nil
	}
	result := &arm.ManagedServiceIdentity{}

	// Set property "Type":
	if identity.Type != nil {
		var temp string
		temp = string(*identity.Type)
		typeVar := arm.ManagedServiceIdentityType(temp)
		result.Type = &typeVar
	}

	// Set property "UserAssignedIdentities":
	result.UserAssignedIdentities = make(map[string]arm.UserAssignedIdentityDetails, len(identity.UserAssignedIdentities))
	for _, ident := range identity.UserAssignedIdentities {
		identARMID, err := resolved.ResolvedReferences.Lookup(ident.Reference)
		if err != nil {
			return nil, err
		}
		key := identARMID
		result.UserAssignedIdentities[key] = arm.UserAssignedIdentityDetails{}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ManagedServiceIdentity) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedServiceIdentity{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ManagedServiceIdentity) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedServiceIdentity)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedServiceIdentity, got %T", armInput)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := ManagedServiceIdentityType(temp)
		identity.Type = &typeVar
	}

	// no assignment for property "UserAssignedIdentities"

	// No error
	return nil
}

// AssignProperties_From_ManagedServiceIdentity populates our ManagedServiceIdentity from the provided source ManagedServiceIdentity
func (identity *ManagedServiceIdentity) AssignProperties_From_ManagedServiceIdentity(source *storage.ManagedServiceIdentity) error {

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, managedServiceIdentityType_Values)
		identity.Type = &typeTemp
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]UserAssignedIdentityDetails, len(source.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity UserAssignedIdentityDetails
			err := userAssignedIdentity.AssignProperties_From_UserAssignedIdentityDetails(&userAssignedIdentityItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityList
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedServiceIdentity populates the provided destination ManagedServiceIdentity from our ManagedServiceIdentity
func (identity *ManagedServiceIdentity) AssignProperties_To_ManagedServiceIdentity(destination *storage.ManagedServiceIdentity) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]storage.UserAssignedIdentityDetails, len(identity.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity storage.UserAssignedIdentityDetails
			err := userAssignedIdentityItem.AssignProperties_To_UserAssignedIdentityDetails(&userAssignedIdentity)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityList
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ManagedServiceIdentity_STATUS populates our ManagedServiceIdentity from the provided source ManagedServiceIdentity_STATUS
func (identity *ManagedServiceIdentity) Initialize_From_ManagedServiceIdentity_STATUS(source *ManagedServiceIdentity_STATUS) error {

	// Type
	if source.Type != nil {
		typeVar := genruntime.ToEnum(string(*source.Type), managedServiceIdentityType_Values)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]UserAssignedIdentityDetails, 0, len(source.UserAssignedIdentities))
		for userAssignedIdentitiesKey := range source.UserAssignedIdentities {
			userAssignedIdentitiesRef := genruntime.CreateResourceReferenceFromARMID(userAssignedIdentitiesKey)
			userAssignedIdentityList = append(userAssignedIdentityList, UserAssignedIdentityDetails{Reference: userAssignedIdentitiesRef})
		}
		identity.UserAssignedIdentities = userAssignedIdentityList
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// Managed service identity (system assigned and/or user assigned identities)
type ManagedServiceIdentity_STATUS struct {
	// PrincipalId: The service principal ID of the system assigned identity. This property will only be provided for a system
	// assigned identity.
	PrincipalId *string `json:"principalId,omitempty"`

	// TenantId: The tenant ID of the system assigned identity. This property will only be provided for a system assigned
	// identity.
	TenantId *string `json:"tenantId,omitempty"`

	// Type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
	Type                   *ManagedServiceIdentityType_STATUS     `json:"type,omitempty"`
	UserAssignedIdentities map[string]UserAssignedIdentity_STATUS `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedServiceIdentity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ManagedServiceIdentity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedServiceIdentity_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ManagedServiceIdentity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedServiceIdentity_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedServiceIdentity_STATUS, got %T", armInput)
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identity.PrincipalId = &principalId
	}

	// Set property "TenantId":
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		identity.TenantId = &tenantId
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := ManagedServiceIdentityType_STATUS(temp)
		identity.Type = &typeVar
	}

	// Set property "UserAssignedIdentities":
	if typedInput.UserAssignedIdentities != nil {
		identity.UserAssignedIdentities = make(map[string]UserAssignedIdentity_STATUS, len(typedInput.UserAssignedIdentities))
		for key, value := range typedInput.UserAssignedIdentities {
			var value1 UserAssignedIdentity_STATUS
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			identity.UserAssignedIdentities[key] = value1
		}
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedServiceIdentity_STATUS populates our ManagedServiceIdentity_STATUS from the provided source ManagedServiceIdentity_STATUS
func (identity *ManagedServiceIdentity_STATUS) AssignProperties_From_ManagedServiceIdentity_STATUS(source *storage.ManagedServiceIdentity_STATUS) error {

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// TenantId
	identity.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, managedServiceIdentityType_STATUS_Values)
		identity.Type = &typeTemp
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]UserAssignedIdentity_STATUS, len(source.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity UserAssignedIdentity_STATUS
			err := userAssignedIdentity.AssignProperties_From_UserAssignedIdentity_STATUS(&userAssignedIdentityValue)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_UserAssignedIdentity_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedServiceIdentity_STATUS populates the provided destination ManagedServiceIdentity_STATUS from our ManagedServiceIdentity_STATUS
func (identity *ManagedServiceIdentity_STATUS) AssignProperties_To_ManagedServiceIdentity_STATUS(destination *storage.ManagedServiceIdentity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(identity.TenantId)

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]storage.UserAssignedIdentity_STATUS, len(identity.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity storage.UserAssignedIdentity_STATUS
			err := userAssignedIdentityValue.AssignProperties_To_UserAssignedIdentity_STATUS(&userAssignedIdentity)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_UserAssignedIdentity_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Metadata about the resource
type Metadata_STATUS struct {
	// ProvisionedBy: Azure offering managing this resource on-behalf-of customer.
	ProvisionedBy *string `json:"provisionedBy,omitempty"`

	// ProvisionedByImmutableId: Immutable Id of azure offering managing this resource on-behalf-of customer.
	ProvisionedByImmutableId *string `json:"provisionedByImmutableId,omitempty"`

	// ProvisionedByResourceId: Resource Id of azure offering managing this resource on-behalf-of customer.
	ProvisionedByResourceId *string `json:"provisionedByResourceId,omitempty"`
}

var _ genruntime.FromARMConverter = &Metadata_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (metadata *Metadata_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Metadata_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (metadata *Metadata_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Metadata_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Metadata_STATUS, got %T", armInput)
	}

	// Set property "ProvisionedBy":
	if typedInput.ProvisionedBy != nil {
		provisionedBy := *typedInput.ProvisionedBy
		metadata.ProvisionedBy = &provisionedBy
	}

	// Set property "ProvisionedByImmutableId":
	if typedInput.ProvisionedByImmutableId != nil {
		provisionedByImmutableId := *typedInput.ProvisionedByImmutableId
		metadata.ProvisionedByImmutableId = &provisionedByImmutableId
	}

	// Set property "ProvisionedByResourceId":
	if typedInput.ProvisionedByResourceId != nil {
		provisionedByResourceId := *typedInput.ProvisionedByResourceId
		metadata.ProvisionedByResourceId = &provisionedByResourceId
	}

	// No error
	return nil
}

// AssignProperties_From_Metadata_STATUS populates our Metadata_STATUS from the provided source Metadata_STATUS
func (metadata *Metadata_STATUS) AssignProperties_From_Metadata_STATUS(source *storage.Metadata_STATUS) error {

	// ProvisionedBy
	metadata.ProvisionedBy = genruntime.ClonePointerToString(source.ProvisionedBy)

	// ProvisionedByImmutableId
	metadata.ProvisionedByImmutableId = genruntime.ClonePointerToString(source.ProvisionedByImmutableId)

	// ProvisionedByResourceId
	metadata.ProvisionedByResourceId = genruntime.ClonePointerToString(source.ProvisionedByResourceId)

	// No error
	return nil
}

// AssignProperties_To_Metadata_STATUS populates the provided destination Metadata_STATUS from our Metadata_STATUS
func (metadata *Metadata_STATUS) AssignProperties_To_Metadata_STATUS(destination *storage.Metadata_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ProvisionedBy
	destination.ProvisionedBy = genruntime.ClonePointerToString(metadata.ProvisionedBy)

	// ProvisionedByImmutableId
	destination.ProvisionedByImmutableId = genruntime.ClonePointerToString(metadata.ProvisionedByImmutableId)

	// ProvisionedByResourceId
	destination.ProvisionedByResourceId = genruntime.ClonePointerToString(metadata.ProvisionedByResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// This section defines all the references that may be used in other sections of the DCR
type ReferencesSpec struct {
	// EnrichmentData: All the enrichment data sources referenced in data flows
	EnrichmentData *EnrichmentData `json:"enrichmentData,omitempty"`
}

var _ genruntime.ARMTransformer = &ReferencesSpec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (references *ReferencesSpec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if references == nil {
		return nil, nil
	}
	result := &arm.ReferencesSpec{}

	// Set property "EnrichmentData":
	if references.EnrichmentData != nil {
		enrichmentData_ARM, err := (*references.EnrichmentData).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		enrichmentData := *enrichmentData_ARM.(*arm.EnrichmentData)
		result.EnrichmentData = &enrichmentData
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (references *ReferencesSpec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ReferencesSpec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (references *ReferencesSpec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ReferencesSpec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ReferencesSpec, got %T", armInput)
	}

	// Set property "EnrichmentData":
	if typedInput.EnrichmentData != nil {
		var enrichmentData1 EnrichmentData
		err := enrichmentData1.PopulateFromARM(owner, *typedInput.EnrichmentData)
		if err != nil {
			return err
		}
		enrichmentData := enrichmentData1
		references.EnrichmentData = &enrichmentData
	}

	// No error
	return nil
}

// AssignProperties_From_ReferencesSpec populates our ReferencesSpec from the provided source ReferencesSpec
func (references *ReferencesSpec) AssignProperties_From_ReferencesSpec(source *storage.ReferencesSpec) error {

	// EnrichmentData
	if source.EnrichmentData != nil {
		var enrichmentDatum EnrichmentData
		err := enrichmentDatum.AssignProperties_From_EnrichmentData(source.EnrichmentData)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_EnrichmentData() to populate field EnrichmentData")
		}
		references.EnrichmentData = &enrichmentDatum
	} else {
		references.EnrichmentData = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ReferencesSpec populates the provided destination ReferencesSpec from our ReferencesSpec
func (references *ReferencesSpec) AssignProperties_To_ReferencesSpec(destination *storage.ReferencesSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EnrichmentData
	if references.EnrichmentData != nil {
		var enrichmentDatum storage.EnrichmentData
		err := references.EnrichmentData.AssignProperties_To_EnrichmentData(&enrichmentDatum)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_EnrichmentData() to populate field EnrichmentData")
		}
		destination.EnrichmentData = &enrichmentDatum
	} else {
		destination.EnrichmentData = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ReferencesSpec_STATUS populates our ReferencesSpec from the provided source ReferencesSpec_STATUS
func (references *ReferencesSpec) Initialize_From_ReferencesSpec_STATUS(source *ReferencesSpec_STATUS) error {

	// EnrichmentData
	if source.EnrichmentData != nil {
		var enrichmentDatum EnrichmentData
		err := enrichmentDatum.Initialize_From_EnrichmentData_STATUS(source.EnrichmentData)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_EnrichmentData_STATUS() to populate field EnrichmentData")
		}
		references.EnrichmentData = &enrichmentDatum
	} else {
		references.EnrichmentData = nil
	}

	// No error
	return nil
}

// This section defines all the references that may be used in other sections of the DCR
type ReferencesSpec_STATUS struct {
	// EnrichmentData: All the enrichment data sources referenced in data flows
	EnrichmentData *EnrichmentData_STATUS `json:"enrichmentData,omitempty"`
}

var _ genruntime.FromARMConverter = &ReferencesSpec_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (references *ReferencesSpec_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ReferencesSpec_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (references *ReferencesSpec_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ReferencesSpec_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ReferencesSpec_STATUS, got %T", armInput)
	}

	// Set property "EnrichmentData":
	if typedInput.EnrichmentData != nil {
		var enrichmentData1 EnrichmentData_STATUS
		err := enrichmentData1.PopulateFromARM(owner, *typedInput.EnrichmentData)
		if err != nil {
			return err
		}
		enrichmentData := enrichmentData1
		references.EnrichmentData = &enrichmentData
	}

	// No error
	return nil
}

// AssignProperties_From_ReferencesSpec_STATUS populates our ReferencesSpec_STATUS from the provided source ReferencesSpec_STATUS
func (references *ReferencesSpec_STATUS) AssignProperties_From_ReferencesSpec_STATUS(source *storage.ReferencesSpec_STATUS) error {

	// EnrichmentData
	if source.EnrichmentData != nil {
		var enrichmentDatum EnrichmentData_STATUS
		err := enrichmentDatum.AssignProperties_From_EnrichmentData_STATUS(source.EnrichmentData)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_EnrichmentData_STATUS() to populate field EnrichmentData")
		}
		references.EnrichmentData = &enrichmentDatum
	} else {
		references.EnrichmentData = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ReferencesSpec_STATUS populates the provided destination ReferencesSpec_STATUS from our ReferencesSpec_STATUS
func (references *ReferencesSpec_STATUS) AssignProperties_To_ReferencesSpec_STATUS(destination *storage.ReferencesSpec_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EnrichmentData
	if references.EnrichmentData != nil {
		var enrichmentDatum storage.EnrichmentData_STATUS
		err := references.EnrichmentData.AssignProperties_To_EnrichmentData_STATUS(&enrichmentDatum)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_EnrichmentData_STATUS() to populate field EnrichmentData")
		}
		destination.EnrichmentData = &enrichmentDatum
	} else {
		destination.EnrichmentData = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Declaration of a custom stream.
type StreamDeclaration struct {
	// Columns: List of columns used by data in this stream.
	Columns []ColumnDefinition `json:"columns,omitempty"`
}

var _ genruntime.ARMTransformer = &StreamDeclaration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (declaration *StreamDeclaration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if declaration == nil {
		return nil, nil
	}
	result := &arm.StreamDeclaration{}

	// Set property "Columns":
	for _, item := range declaration.Columns {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Columns = append(result.Columns, *item_ARM.(*arm.ColumnDefinition))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (declaration *StreamDeclaration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.StreamDeclaration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (declaration *StreamDeclaration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.StreamDeclaration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.StreamDeclaration, got %T", armInput)
	}

	// Set property "Columns":
	for _, item := range typedInput.Columns {
		var item1 ColumnDefinition
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		declaration.Columns = append(declaration.Columns, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_StreamDeclaration populates our StreamDeclaration from the provided source StreamDeclaration
func (declaration *StreamDeclaration) AssignProperties_From_StreamDeclaration(source *storage.StreamDeclaration) error {

	// Columns
	if source.Columns != nil {
		columnList := make([]ColumnDefinition, len(source.Columns))
		for columnIndex, columnItem := range source.Columns {
			// Shadow the loop variable to avoid aliasing
			columnItem := columnItem
			var column ColumnDefinition
			err := column.AssignProperties_From_ColumnDefinition(&columnItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ColumnDefinition() to populate field Columns")
			}
			columnList[columnIndex] = column
		}
		declaration.Columns = columnList
	} else {
		declaration.Columns = nil
	}

	// No error
	return nil
}

// AssignProperties_To_StreamDeclaration populates the provided destination StreamDeclaration from our StreamDeclaration
func (declaration *StreamDeclaration) AssignProperties_To_StreamDeclaration(destination *storage.StreamDeclaration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Columns
	if declaration.Columns != nil {
		columnList := make([]storage.ColumnDefinition, len(declaration.Columns))
		for columnIndex, columnItem := range declaration.Columns {
			// Shadow the loop variable to avoid aliasing
			columnItem := columnItem
			var column storage.ColumnDefinition
			err := columnItem.AssignProperties_To_ColumnDefinition(&column)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ColumnDefinition() to populate field Columns")
			}
			columnList[columnIndex] = column
		}
		destination.Columns = columnList
	} else {
		destination.Columns = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_StreamDeclaration_STATUS populates our StreamDeclaration from the provided source StreamDeclaration_STATUS
func (declaration *StreamDeclaration) Initialize_From_StreamDeclaration_STATUS(source *StreamDeclaration_STATUS) error {

	// Columns
	if source.Columns != nil {
		columnList := make([]ColumnDefinition, len(source.Columns))
		for columnIndex, columnItem := range source.Columns {
			// Shadow the loop variable to avoid aliasing
			columnItem := columnItem
			var column ColumnDefinition
			err := column.Initialize_From_ColumnDefinition_STATUS(&columnItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_ColumnDefinition_STATUS() to populate field Columns")
			}
			columnList[columnIndex] = column
		}
		declaration.Columns = columnList
	} else {
		declaration.Columns = nil
	}

	// No error
	return nil
}

// Declaration of a custom stream.
type StreamDeclaration_STATUS struct {
	// Columns: List of columns used by data in this stream.
	Columns []ColumnDefinition_STATUS `json:"columns,omitempty"`
}

var _ genruntime.FromARMConverter = &StreamDeclaration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (declaration *StreamDeclaration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.StreamDeclaration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (declaration *StreamDeclaration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.StreamDeclaration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.StreamDeclaration_STATUS, got %T", armInput)
	}

	// Set property "Columns":
	for _, item := range typedInput.Columns {
		var item1 ColumnDefinition_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		declaration.Columns = append(declaration.Columns, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_StreamDeclaration_STATUS populates our StreamDeclaration_STATUS from the provided source StreamDeclaration_STATUS
func (declaration *StreamDeclaration_STATUS) AssignProperties_From_StreamDeclaration_STATUS(source *storage.StreamDeclaration_STATUS) error {

	// Columns
	if source.Columns != nil {
		columnList := make([]ColumnDefinition_STATUS, len(source.Columns))
		for columnIndex, columnItem := range source.Columns {
			// Shadow the loop variable to avoid aliasing
			columnItem := columnItem
			var column ColumnDefinition_STATUS
			err := column.AssignProperties_From_ColumnDefinition_STATUS(&columnItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ColumnDefinition_STATUS() to populate field Columns")
			}
			columnList[columnIndex] = column
		}
		declaration.Columns = columnList
	} else {
		declaration.Columns = nil
	}

	// No error
	return nil
}

// AssignProperties_To_StreamDeclaration_STATUS populates the provided destination StreamDeclaration_STATUS from our StreamDeclaration_STATUS
func (declaration *StreamDeclaration_STATUS) AssignProperties_To_StreamDeclaration_STATUS(destination *storage.StreamDeclaration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Columns
	if declaration.Columns != nil {
		columnList := make([]storage.ColumnDefinition_STATUS, len(declaration.Columns))
		for columnIndex, columnItem := range declaration.Columns {
			// Shadow the loop variable to avoid aliasing
			columnItem := columnItem
			var column storage.ColumnDefinition_STATUS
			err := columnItem.AssignProperties_To_ColumnDefinition_STATUS(&column)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ColumnDefinition_STATUS() to populate field Columns")
			}
			columnList[columnIndex] = column
		}
		destination.Columns = columnList
	} else {
		destination.Columns = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Metadata pertaining to creation and last modification of the resource.
type SystemData_STATUS struct {
	// CreatedAt: The timestamp of resource creation (UTC).
	CreatedAt *string `json:"createdAt,omitempty"`

	// CreatedBy: The identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty"`

	// CreatedByType: The type of identity that created the resource.
	CreatedByType *SystemData_CreatedByType_STATUS `json:"createdByType,omitempty"`

	// LastModifiedAt: The timestamp of resource last modification (UTC)
	LastModifiedAt *string `json:"lastModifiedAt,omitempty"`

	// LastModifiedBy: The identity that last modified the resource.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`

	// LastModifiedByType: The type of identity that last modified the resource.
	LastModifiedByType *SystemData_LastModifiedByType_STATUS `json:"lastModifiedByType,omitempty"`
}

var _ genruntime.FromARMConverter = &SystemData_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (data *SystemData_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SystemData_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (data *SystemData_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SystemData_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SystemData_STATUS, got %T", armInput)
	}

	// Set property "CreatedAt":
	if typedInput.CreatedAt != nil {
		createdAt := *typedInput.CreatedAt
		data.CreatedAt = &createdAt
	}

	// Set property "CreatedBy":
	if typedInput.CreatedBy != nil {
		createdBy := *typedInput.CreatedBy
		data.CreatedBy = &createdBy
	}

	// Set property "CreatedByType":
	if typedInput.CreatedByType != nil {
		var temp string
		temp = string(*typedInput.CreatedByType)
		createdByType := SystemData_CreatedByType_STATUS(temp)
		data.CreatedByType = &createdByType
	}

	// Set property "LastModifiedAt":
	if typedInput.LastModifiedAt != nil {
		lastModifiedAt := *typedInput.LastModifiedAt
		data.LastModifiedAt = &lastModifiedAt
	}

	// Set property "LastModifiedBy":
	if typedInput.LastModifiedBy != nil {
		lastModifiedBy := *typedInput.LastModifiedBy
		data.LastModifiedBy = &lastModifiedBy
	}

	// Set property "LastModifiedByType":
	if typedInput.LastModifiedByType != nil {
		var temp string
		temp = string(*typedInput.LastModifiedByType)
		lastModifiedByType := SystemData_LastModifiedByType_STATUS(temp)
		data.LastModifiedByType = &lastModifiedByType
	}

	// No error
	return nil
}

// AssignProperties_From_SystemData_STATUS populates our SystemData_STATUS from the provided source SystemData_STATUS
func (data *SystemData_STATUS) AssignProperties_From_SystemData_STATUS(source *storage.SystemData_STATUS) error {

	// CreatedAt
	data.CreatedAt = genruntime.ClonePointerToString(source.CreatedAt)

	// CreatedBy
	data.CreatedBy = genruntime.ClonePointerToString(source.CreatedBy)

	// CreatedByType
	if source.CreatedByType != nil {
		createdByType := *source.CreatedByType
		createdByTypeTemp := genruntime.ToEnum(createdByType, systemData_CreatedByType_STATUS_Values)
		data.CreatedByType = &createdByTypeTemp
	} else {
		data.CreatedByType = nil
	}

	// LastModifiedAt
	data.LastModifiedAt = genruntime.ClonePointerToString(source.LastModifiedAt)

	// LastModifiedBy
	data.LastModifiedBy = genruntime.ClonePointerToString(source.LastModifiedBy)

	// LastModifiedByType
	if source.LastModifiedByType != nil {
		lastModifiedByType := *source.LastModifiedByType
		lastModifiedByTypeTemp := genruntime.ToEnum(lastModifiedByType, systemData_LastModifiedByType_STATUS_Values)
		data.LastModifiedByType = &lastModifiedByTypeTemp
	} else {
		data.LastModifiedByType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SystemData_STATUS populates the provided destination SystemData_STATUS from our SystemData_STATUS
func (data *SystemData_STATUS) AssignProperties_To_SystemData_STATUS(destination *storage.SystemData_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CreatedAt
	destination.CreatedAt = genruntime.ClonePointerToString(data.CreatedAt)

	// CreatedBy
	destination.CreatedBy = genruntime.ClonePointerToString(data.CreatedBy)

	// CreatedByType
	if data.CreatedByType != nil {
		createdByType := string(*data.CreatedByType)
		destination.CreatedByType = &createdByType
	} else {
		destination.CreatedByType = nil
	}

	// LastModifiedAt
	destination.LastModifiedAt = genruntime.ClonePointerToString(data.LastModifiedAt)

	// LastModifiedBy
	destination.LastModifiedBy = genruntime.ClonePointerToString(data.LastModifiedBy)

	// LastModifiedByType
	if data.LastModifiedByType != nil {
		lastModifiedByType := string(*data.LastModifiedByType)
		destination.LastModifiedByType = &lastModifiedByType
	} else {
		destination.LastModifiedByType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Azure Data Explorer (Adx) destination.
type AdxDestination struct {
	// DatabaseName: The name of the database to which data will be ingested.
	DatabaseName *string `json:"databaseName,omitempty"`

	// Name: A friendly name for the destination.
	// This name should be unique across all destinations (regardless of type) within the data collection rule.
	Name *string `json:"name,omitempty"`

	// ResourceReference: The ARM resource id of the Adx resource.
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceId" json:"resourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &AdxDestination{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (destination *AdxDestination) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if destination == nil {
		return nil, nil
	}
	result := &arm.AdxDestination{}

	// Set property "DatabaseName":
	if destination.DatabaseName != nil {
		databaseName := *destination.DatabaseName
		result.DatabaseName = &databaseName
	}

	// Set property "Name":
	if destination.Name != nil {
		name := *destination.Name
		result.Name = &name
	}

	// Set property "ResourceId":
	if destination.ResourceReference != nil {
		resourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*destination.ResourceReference)
		if err != nil {
			return nil, err
		}
		resourceReference := resourceReferenceARMID
		result.ResourceId = &resourceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (destination *AdxDestination) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AdxDestination{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (destination *AdxDestination) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AdxDestination)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AdxDestination, got %T", armInput)
	}

	// Set property "DatabaseName":
	if typedInput.DatabaseName != nil {
		databaseName := *typedInput.DatabaseName
		destination.DatabaseName = &databaseName
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		destination.Name = &name
	}

	// no assignment for property "ResourceReference"

	// No error
	return nil
}

// AssignProperties_From_AdxDestination populates our AdxDestination from the provided source AdxDestination
func (destination *AdxDestination) AssignProperties_From_AdxDestination(source *storage.AdxDestination) error {

	// DatabaseName
	destination.DatabaseName = genruntime.ClonePointerToString(source.DatabaseName)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AdxDestination populates the provided destination AdxDestination from our AdxDestination
func (destination *AdxDestination) AssignProperties_To_AdxDestination(target *storage.AdxDestination) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DatabaseName
	target.DatabaseName = genruntime.ClonePointerToString(destination.DatabaseName)

	// Name
	target.Name = genruntime.ClonePointerToString(destination.Name)

	// ResourceReference
	if destination.ResourceReference != nil {
		resourceReference := destination.ResourceReference.Copy()
		target.ResourceReference = &resourceReference
	} else {
		target.ResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		target.PropertyBag = propertyBag
	} else {
		target.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AdxDestination_STATUS populates our AdxDestination from the provided source AdxDestination_STATUS
func (destination *AdxDestination) Initialize_From_AdxDestination_STATUS(source *AdxDestination_STATUS) error {

	// DatabaseName
	destination.DatabaseName = genruntime.ClonePointerToString(source.DatabaseName)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// ResourceReference
	if source.ResourceId != nil {
		resourceReference := genruntime.CreateResourceReferenceFromARMID(*source.ResourceId)
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// No error
	return nil
}

// Azure Data Explorer (Adx) destination.
type AdxDestination_STATUS struct {
	// DatabaseName: The name of the database to which data will be ingested.
	DatabaseName *string `json:"databaseName,omitempty"`

	// IngestionUri: The ingestion uri of the Adx resource.
	IngestionUri *string `json:"ingestionUri,omitempty"`

	// Name: A friendly name for the destination.
	// This name should be unique across all destinations (regardless of type) within the data collection rule.
	Name *string `json:"name,omitempty"`

	// ResourceId: The ARM resource id of the Adx resource.
	ResourceId *string `json:"resourceId,omitempty"`
}

var _ genruntime.FromARMConverter = &AdxDestination_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (destination *AdxDestination_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AdxDestination_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (destination *AdxDestination_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AdxDestination_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AdxDestination_STATUS, got %T", armInput)
	}

	// Set property "DatabaseName":
	if typedInput.DatabaseName != nil {
		databaseName := *typedInput.DatabaseName
		destination.DatabaseName = &databaseName
	}

	// Set property "IngestionUri":
	if typedInput.IngestionUri != nil {
		ingestionUri := *typedInput.IngestionUri
		destination.IngestionUri = &ingestionUri
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		destination.Name = &name
	}

	// Set property "ResourceId":
	if typedInput.ResourceId != nil {
		resourceId := *typedInput.ResourceId
		destination.ResourceId = &resourceId
	}

	// No error
	return nil
}

// AssignProperties_From_AdxDestination_STATUS populates our AdxDestination_STATUS from the provided source AdxDestination_STATUS
func (destination *AdxDestination_STATUS) AssignProperties_From_AdxDestination_STATUS(source *storage.AdxDestination_STATUS) error {

	// DatabaseName
	destination.DatabaseName = genruntime.ClonePointerToString(source.DatabaseName)

	// IngestionUri
	destination.IngestionUri = genruntime.ClonePointerToString(source.IngestionUri)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// ResourceId
	destination.ResourceId = genruntime.ClonePointerToString(source.ResourceId)

	// No error
	return nil
}

// AssignProperties_To_AdxDestination_STATUS populates the provided destination AdxDestination_STATUS from our AdxDestination_STATUS
func (destination *AdxDestination_STATUS) AssignProperties_To_AdxDestination_STATUS(target *storage.AdxDestination_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DatabaseName
	target.DatabaseName = genruntime.ClonePointerToString(destination.DatabaseName)

	// IngestionUri
	target.IngestionUri = genruntime.ClonePointerToString(destination.IngestionUri)

	// Name
	target.Name = genruntime.ClonePointerToString(destination.Name)

	// ResourceId
	target.ResourceId = genruntime.ClonePointerToString(destination.ResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		target.PropertyBag = propertyBag
	} else {
		target.PropertyBag = nil
	}

	// No error
	return nil
}

// A setting used to control an agent behavior on a host machine
type AgentSetting struct {
	// Name: The name of the setting.
	// Must be part of the list of supported settings
	Name *AgentSetting_Name `json:"name,omitempty"`

	// Value: The value of the setting
	Value *string `json:"value,omitempty"`
}

var _ genruntime.ARMTransformer = &AgentSetting{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (setting *AgentSetting) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if setting == nil {
		return nil, nil
	}
	result := &arm.AgentSetting{}

	// Set property "Name":
	if setting.Name != nil {
		var temp string
		temp = string(*setting.Name)
		name := arm.AgentSetting_Name(temp)
		result.Name = &name
	}

	// Set property "Value":
	if setting.Value != nil {
		value := *setting.Value
		result.Value = &value
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (setting *AgentSetting) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AgentSetting{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (setting *AgentSetting) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AgentSetting)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AgentSetting, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		var temp string
		temp = string(*typedInput.Name)
		name := AgentSetting_Name(temp)
		setting.Name = &name
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		setting.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_AgentSetting populates our AgentSetting from the provided source AgentSetting
func (setting *AgentSetting) AssignProperties_From_AgentSetting(source *storage.AgentSetting) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, agentSetting_Name_Values)
		setting.Name = &nameTemp
	} else {
		setting.Name = nil
	}

	// Value
	setting.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_AgentSetting populates the provided destination AgentSetting from our AgentSetting
func (setting *AgentSetting) AssignProperties_To_AgentSetting(destination *storage.AgentSetting) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if setting.Name != nil {
		name := string(*setting.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Value
	destination.Value = genruntime.ClonePointerToString(setting.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AgentSetting_STATUS populates our AgentSetting from the provided source AgentSetting_STATUS
func (setting *AgentSetting) Initialize_From_AgentSetting_STATUS(source *AgentSetting_STATUS) error {

	// Name
	if source.Name != nil {
		name := genruntime.ToEnum(string(*source.Name), agentSetting_Name_Values)
		setting.Name = &name
	} else {
		setting.Name = nil
	}

	// Value
	setting.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// A setting used to control an agent behavior on a host machine
type AgentSetting_STATUS struct {
	// Name: The name of the setting.
	// Must be part of the list of supported settings
	Name *AgentSetting_Name_STATUS `json:"name,omitempty"`

	// Value: The value of the setting
	Value *string `json:"value,omitempty"`
}

var _ genruntime.FromARMConverter = &AgentSetting_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (setting *AgentSetting_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AgentSetting_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (setting *AgentSetting_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AgentSetting_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AgentSetting_STATUS, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		var temp string
		temp = string(*typedInput.Name)
		name := AgentSetting_Name_STATUS(temp)
		setting.Name = &name
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		setting.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_AgentSetting_STATUS populates our AgentSetting_STATUS from the provided source AgentSetting_STATUS
func (setting *AgentSetting_STATUS) AssignProperties_From_AgentSetting_STATUS(source *storage.AgentSetting_STATUS) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, agentSetting_Name_STATUS_Values)
		setting.Name = &nameTemp
	} else {
		setting.Name = nil
	}

	// Value
	setting.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_AgentSetting_STATUS populates the provided destination AgentSetting_STATUS from our AgentSetting_STATUS
func (setting *AgentSetting_STATUS) AssignProperties_To_AgentSetting_STATUS(destination *storage.AgentSetting_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if setting.Name != nil {
		name := string(*setting.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Value
	destination.Value = genruntime.ClonePointerToString(setting.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Azure Monitor Metrics destination.
type AzureMonitorMetricsDestination struct {
	// Name: A friendly name for the destination.
	// This name should be unique across all destinations (regardless of type) within the data collection rule.
	Name *string `json:"name,omitempty"`
}

var _ genruntime.ARMTransformer = &AzureMonitorMetricsDestination{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (destination *AzureMonitorMetricsDestination) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if destination == nil {
		return nil, nil
	}
	result := &arm.AzureMonitorMetricsDestination{}

	// Set property "Name":
	if destination.Name != nil {
		name := *destination.Name
		result.Name = &name
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (destination *AzureMonitorMetricsDestination) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureMonitorMetricsDestination{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (destination *AzureMonitorMetricsDestination) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureMonitorMetricsDestination)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureMonitorMetricsDestination, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		destination.Name = &name
	}

	// No error
	return nil
}

// AssignProperties_From_AzureMonitorMetricsDestination populates our AzureMonitorMetricsDestination from the provided source AzureMonitorMetricsDestination
func (destination *AzureMonitorMetricsDestination) AssignProperties_From_AzureMonitorMetricsDestination(source *storage.AzureMonitorMetricsDestination) error {

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// No error
	return nil
}

// AssignProperties_To_AzureMonitorMetricsDestination populates the provided destination AzureMonitorMetricsDestination from our AzureMonitorMetricsDestination
func (destination *AzureMonitorMetricsDestination) AssignProperties_To_AzureMonitorMetricsDestination(target *storage.AzureMonitorMetricsDestination) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	target.Name = genruntime.ClonePointerToString(destination.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		target.PropertyBag = propertyBag
	} else {
		target.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AzureMonitorMetricsDestination_STATUS populates our AzureMonitorMetricsDestination from the provided source AzureMonitorMetricsDestination_STATUS
func (destination *AzureMonitorMetricsDestination) Initialize_From_AzureMonitorMetricsDestination_STATUS(source *AzureMonitorMetricsDestination_STATUS) error {

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// No error
	return nil
}

// Azure Monitor Metrics destination.
type AzureMonitorMetricsDestination_STATUS struct {
	// Name: A friendly name for the destination.
	// This name should be unique across all destinations (regardless of type) within the data collection rule.
	Name *string `json:"name,omitempty"`
}

var _ genruntime.FromARMConverter = &AzureMonitorMetricsDestination_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (destination *AzureMonitorMetricsDestination_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureMonitorMetricsDestination_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (destination *AzureMonitorMetricsDestination_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureMonitorMetricsDestination_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureMonitorMetricsDestination_STATUS, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		destination.Name = &name
	}

	// No error
	return nil
}

// AssignProperties_From_AzureMonitorMetricsDestination_STATUS populates our AzureMonitorMetricsDestination_STATUS from the provided source AzureMonitorMetricsDestination_STATUS
func (destination *AzureMonitorMetricsDestination_STATUS) AssignProperties_From_AzureMonitorMetricsDestination_STATUS(source *storage.AzureMonitorMetricsDestination_STATUS) error {

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// No error
	return nil
}

// AssignProperties_To_AzureMonitorMetricsDestination_STATUS populates the provided destination AzureMonitorMetricsDestination_STATUS from our AzureMonitorMetricsDestination_STATUS
func (destination *AzureMonitorMetricsDestination_STATUS) AssignProperties_To_AzureMonitorMetricsDestination_STATUS(target *storage.AzureMonitorMetricsDestination_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	target.Name = genruntime.ClonePointerToString(destination.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		target.PropertyBag = propertyBag
	} else {
		target.PropertyBag = nil
	}

	// No error
	return nil
}

// Definition of custom data column.
type ColumnDefinition struct {
	// Name: The name of the column.
	Name *string `json:"name,omitempty"`

	// Type: The type of the column data.
	Type *ColumnDefinition_Type `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &ColumnDefinition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (definition *ColumnDefinition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if definition == nil {
		return nil, nil
	}
	result := &arm.ColumnDefinition{}

	// Set property "Name":
	if definition.Name != nil {
		name := *definition.Name
		result.Name = &name
	}

	// Set property "Type":
	if definition.Type != nil {
		var temp string
		temp = string(*definition.Type)
		typeVar := arm.ColumnDefinition_Type(temp)
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (definition *ColumnDefinition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ColumnDefinition{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (definition *ColumnDefinition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ColumnDefinition)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ColumnDefinition, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		definition.Name = &name
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := ColumnDefinition_Type(temp)
		definition.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_ColumnDefinition populates our ColumnDefinition from the provided source ColumnDefinition
func (definition *ColumnDefinition) AssignProperties_From_ColumnDefinition(source *storage.ColumnDefinition) error {

	// Name
	definition.Name = genruntime.ClonePointerToString(source.Name)

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, columnDefinition_Type_Values)
		definition.Type = &typeTemp
	} else {
		definition.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ColumnDefinition populates the provided destination ColumnDefinition from our ColumnDefinition
func (definition *ColumnDefinition) AssignProperties_To_ColumnDefinition(destination *storage.ColumnDefinition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(definition.Name)

	// Type
	if definition.Type != nil {
		typeVar := string(*definition.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ColumnDefinition_STATUS populates our ColumnDefinition from the provided source ColumnDefinition_STATUS
func (definition *ColumnDefinition) Initialize_From_ColumnDefinition_STATUS(source *ColumnDefinition_STATUS) error {

	// Name
	definition.Name = genruntime.ClonePointerToString(source.Name)

	// Type
	if source.Type != nil {
		typeVar := genruntime.ToEnum(string(*source.Type), columnDefinition_Type_Values)
		definition.Type = &typeVar
	} else {
		definition.Type = nil
	}

	// No error
	return nil
}

// Definition of custom data column.
type ColumnDefinition_STATUS struct {
	// Name: The name of the column.
	Name *string `json:"name,omitempty"`

	// Type: The type of the column data.
	Type *ColumnDefinition_Type_STATUS `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &ColumnDefinition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (definition *ColumnDefinition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ColumnDefinition_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (definition *ColumnDefinition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ColumnDefinition_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ColumnDefinition_STATUS, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		definition.Name = &name
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := ColumnDefinition_Type_STATUS(temp)
		definition.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_ColumnDefinition_STATUS populates our ColumnDefinition_STATUS from the provided source ColumnDefinition_STATUS
func (definition *ColumnDefinition_STATUS) AssignProperties_From_ColumnDefinition_STATUS(source *storage.ColumnDefinition_STATUS) error {

	// Name
	definition.Name = genruntime.ClonePointerToString(source.Name)

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, columnDefinition_Type_STATUS_Values)
		definition.Type = &typeTemp
	} else {
		definition.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ColumnDefinition_STATUS populates the provided destination ColumnDefinition_STATUS from our ColumnDefinition_STATUS
func (definition *ColumnDefinition_STATUS) AssignProperties_To_ColumnDefinition_STATUS(destination *storage.ColumnDefinition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(definition.Name)

	// Type
	if definition.Type != nil {
		typeVar := string(*definition.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Microsoft-Event","Microsoft-InsightsMetrics","Microsoft-Perf","Microsoft-Syslog","Microsoft-WindowsEvent"}
type DataFlow_Streams string

const (
	DataFlow_Streams_MicrosoftEvent           = DataFlow_Streams("Microsoft-Event")
	DataFlow_Streams_MicrosoftInsightsMetrics = DataFlow_Streams("Microsoft-InsightsMetrics")
	DataFlow_Streams_MicrosoftPerf            = DataFlow_Streams("Microsoft-Perf")
	DataFlow_Streams_MicrosoftSyslog          = DataFlow_Streams("Microsoft-Syslog")
	DataFlow_Streams_MicrosoftWindowsEvent    = DataFlow_Streams("Microsoft-WindowsEvent")
)

// Mapping from string to DataFlow_Streams
var dataFlow_Streams_Values = map[string]DataFlow_Streams{
	"microsoft-event":           DataFlow_Streams_MicrosoftEvent,
	"microsoft-insightsmetrics": DataFlow_Streams_MicrosoftInsightsMetrics,
	"microsoft-perf":            DataFlow_Streams_MicrosoftPerf,
	"microsoft-syslog":          DataFlow_Streams_MicrosoftSyslog,
	"microsoft-windowsevent":    DataFlow_Streams_MicrosoftWindowsEvent,
}

type DataFlow_Streams_STATUS string

const (
	DataFlow_Streams_STATUS_MicrosoftEvent           = DataFlow_Streams_STATUS("Microsoft-Event")
	DataFlow_Streams_STATUS_MicrosoftInsightsMetrics = DataFlow_Streams_STATUS("Microsoft-InsightsMetrics")
	DataFlow_Streams_STATUS_MicrosoftPerf            = DataFlow_Streams_STATUS("Microsoft-Perf")
	DataFlow_Streams_STATUS_MicrosoftSyslog          = DataFlow_Streams_STATUS("Microsoft-Syslog")
	DataFlow_Streams_STATUS_MicrosoftWindowsEvent    = DataFlow_Streams_STATUS("Microsoft-WindowsEvent")
)

// Mapping from string to DataFlow_Streams_STATUS
var dataFlow_Streams_STATUS_Values = map[string]DataFlow_Streams_STATUS{
	"microsoft-event":           DataFlow_Streams_STATUS_MicrosoftEvent,
	"microsoft-insightsmetrics": DataFlow_Streams_STATUS_MicrosoftInsightsMetrics,
	"microsoft-perf":            DataFlow_Streams_STATUS_MicrosoftPerf,
	"microsoft-syslog":          DataFlow_Streams_STATUS_MicrosoftSyslog,
	"microsoft-windowsevent":    DataFlow_Streams_STATUS_MicrosoftWindowsEvent,
}

type DataImportSources struct {
	// EventHub: Definition of Event Hub configuration.
	EventHub *EventHubDataSource `json:"eventHub,omitempty"`
}

var _ genruntime.ARMTransformer = &DataImportSources{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (sources *DataImportSources) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if sources == nil {
		return nil, nil
	}
	result := &arm.DataImportSources{}

	// Set property "EventHub":
	if sources.EventHub != nil {
		eventHub_ARM, err := (*sources.EventHub).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		eventHub := *eventHub_ARM.(*arm.EventHubDataSource)
		result.EventHub = &eventHub
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sources *DataImportSources) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DataImportSources{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sources *DataImportSources) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DataImportSources)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DataImportSources, got %T", armInput)
	}

	// Set property "EventHub":
	if typedInput.EventHub != nil {
		var eventHub1 EventHubDataSource
		err := eventHub1.PopulateFromARM(owner, *typedInput.EventHub)
		if err != nil {
			return err
		}
		eventHub := eventHub1
		sources.EventHub = &eventHub
	}

	// No error
	return nil
}

// AssignProperties_From_DataImportSources populates our DataImportSources from the provided source DataImportSources
func (sources *DataImportSources) AssignProperties_From_DataImportSources(source *storage.DataImportSources) error {

	// EventHub
	if source.EventHub != nil {
		var eventHub EventHubDataSource
		err := eventHub.AssignProperties_From_EventHubDataSource(source.EventHub)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_EventHubDataSource() to populate field EventHub")
		}
		sources.EventHub = &eventHub
	} else {
		sources.EventHub = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DataImportSources populates the provided destination DataImportSources from our DataImportSources
func (sources *DataImportSources) AssignProperties_To_DataImportSources(destination *storage.DataImportSources) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EventHub
	if sources.EventHub != nil {
		var eventHub storage.EventHubDataSource
		err := sources.EventHub.AssignProperties_To_EventHubDataSource(&eventHub)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_EventHubDataSource() to populate field EventHub")
		}
		destination.EventHub = &eventHub
	} else {
		destination.EventHub = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DataImportSources_STATUS populates our DataImportSources from the provided source DataImportSources_STATUS
func (sources *DataImportSources) Initialize_From_DataImportSources_STATUS(source *DataImportSources_STATUS) error {

	// EventHub
	if source.EventHub != nil {
		var eventHub EventHubDataSource
		err := eventHub.Initialize_From_EventHubDataSource_STATUS(source.EventHub)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_EventHubDataSource_STATUS() to populate field EventHub")
		}
		sources.EventHub = &eventHub
	} else {
		sources.EventHub = nil
	}

	// No error
	return nil
}

type DataImportSources_STATUS struct {
	// EventHub: Definition of Event Hub configuration.
	EventHub *EventHubDataSource_STATUS `json:"eventHub,omitempty"`
}

var _ genruntime.FromARMConverter = &DataImportSources_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sources *DataImportSources_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DataImportSources_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sources *DataImportSources_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DataImportSources_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DataImportSources_STATUS, got %T", armInput)
	}

	// Set property "EventHub":
	if typedInput.EventHub != nil {
		var eventHub1 EventHubDataSource_STATUS
		err := eventHub1.PopulateFromARM(owner, *typedInput.EventHub)
		if err != nil {
			return err
		}
		eventHub := eventHub1
		sources.EventHub = &eventHub
	}

	// No error
	return nil
}

// AssignProperties_From_DataImportSources_STATUS populates our DataImportSources_STATUS from the provided source DataImportSources_STATUS
func (sources *DataImportSources_STATUS) AssignProperties_From_DataImportSources_STATUS(source *storage.DataImportSources_STATUS) error {

	// EventHub
	if source.EventHub != nil {
		var eventHub EventHubDataSource_STATUS
		err := eventHub.AssignProperties_From_EventHubDataSource_STATUS(source.EventHub)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_EventHubDataSource_STATUS() to populate field EventHub")
		}
		sources.EventHub = &eventHub
	} else {
		sources.EventHub = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DataImportSources_STATUS populates the provided destination DataImportSources_STATUS from our DataImportSources_STATUS
func (sources *DataImportSources_STATUS) AssignProperties_To_DataImportSources_STATUS(destination *storage.DataImportSources_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EventHub
	if sources.EventHub != nil {
		var eventHub storage.EventHubDataSource_STATUS
		err := sources.EventHub.AssignProperties_To_EventHubDataSource_STATUS(&eventHub)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_EventHubDataSource_STATUS() to populate field EventHub")
		}
		destination.EventHub = &eventHub
	} else {
		destination.EventHub = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// All the enrichment data sources referenced in data flows
type EnrichmentData struct {
	// StorageBlobs: All the storage blobs used as enrichment data sources
	StorageBlobs []StorageBlob `json:"storageBlobs,omitempty"`
}

var _ genruntime.ARMTransformer = &EnrichmentData{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (data *EnrichmentData) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if data == nil {
		return nil, nil
	}
	result := &arm.EnrichmentData{}

	// Set property "StorageBlobs":
	for _, item := range data.StorageBlobs {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.StorageBlobs = append(result.StorageBlobs, *item_ARM.(*arm.StorageBlob))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (data *EnrichmentData) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EnrichmentData{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (data *EnrichmentData) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EnrichmentData)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EnrichmentData, got %T", armInput)
	}

	// Set property "StorageBlobs":
	for _, item := range typedInput.StorageBlobs {
		var item1 StorageBlob
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		data.StorageBlobs = append(data.StorageBlobs, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_EnrichmentData populates our EnrichmentData from the provided source EnrichmentData
func (data *EnrichmentData) AssignProperties_From_EnrichmentData(source *storage.EnrichmentData) error {

	// StorageBlobs
	if source.StorageBlobs != nil {
		storageBlobList := make([]StorageBlob, len(source.StorageBlobs))
		for storageBlobIndex, storageBlobItem := range source.StorageBlobs {
			// Shadow the loop variable to avoid aliasing
			storageBlobItem := storageBlobItem
			var storageBlob StorageBlob
			err := storageBlob.AssignProperties_From_StorageBlob(&storageBlobItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_StorageBlob() to populate field StorageBlobs")
			}
			storageBlobList[storageBlobIndex] = storageBlob
		}
		data.StorageBlobs = storageBlobList
	} else {
		data.StorageBlobs = nil
	}

	// No error
	return nil
}

// AssignProperties_To_EnrichmentData populates the provided destination EnrichmentData from our EnrichmentData
func (data *EnrichmentData) AssignProperties_To_EnrichmentData(destination *storage.EnrichmentData) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// StorageBlobs
	if data.StorageBlobs != nil {
		storageBlobList := make([]storage.StorageBlob, len(data.StorageBlobs))
		for storageBlobIndex, storageBlobItem := range data.StorageBlobs {
			// Shadow the loop variable to avoid aliasing
			storageBlobItem := storageBlobItem
			var storageBlob storage.StorageBlob
			err := storageBlobItem.AssignProperties_To_StorageBlob(&storageBlob)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_StorageBlob() to populate field StorageBlobs")
			}
			storageBlobList[storageBlobIndex] = storageBlob
		}
		destination.StorageBlobs = storageBlobList
	} else {
		destination.StorageBlobs = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_EnrichmentData_STATUS populates our EnrichmentData from the provided source EnrichmentData_STATUS
func (data *EnrichmentData) Initialize_From_EnrichmentData_STATUS(source *EnrichmentData_STATUS) error {

	// StorageBlobs
	if source.StorageBlobs != nil {
		storageBlobList := make([]StorageBlob, len(source.StorageBlobs))
		for storageBlobIndex, storageBlobItem := range source.StorageBlobs {
			// Shadow the loop variable to avoid aliasing
			storageBlobItem := storageBlobItem
			var storageBlob StorageBlob
			err := storageBlob.Initialize_From_StorageBlob_STATUS(&storageBlobItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_StorageBlob_STATUS() to populate field StorageBlobs")
			}
			storageBlobList[storageBlobIndex] = storageBlob
		}
		data.StorageBlobs = storageBlobList
	} else {
		data.StorageBlobs = nil
	}

	// No error
	return nil
}

// All the enrichment data sources referenced in data flows
type EnrichmentData_STATUS struct {
	// StorageBlobs: All the storage blobs used as enrichment data sources
	StorageBlobs []StorageBlob_STATUS `json:"storageBlobs,omitempty"`
}

var _ genruntime.FromARMConverter = &EnrichmentData_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (data *EnrichmentData_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EnrichmentData_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (data *EnrichmentData_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EnrichmentData_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EnrichmentData_STATUS, got %T", armInput)
	}

	// Set property "StorageBlobs":
	for _, item := range typedInput.StorageBlobs {
		var item1 StorageBlob_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		data.StorageBlobs = append(data.StorageBlobs, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_EnrichmentData_STATUS populates our EnrichmentData_STATUS from the provided source EnrichmentData_STATUS
func (data *EnrichmentData_STATUS) AssignProperties_From_EnrichmentData_STATUS(source *storage.EnrichmentData_STATUS) error {

	// StorageBlobs
	if source.StorageBlobs != nil {
		storageBlobList := make([]StorageBlob_STATUS, len(source.StorageBlobs))
		for storageBlobIndex, storageBlobItem := range source.StorageBlobs {
			// Shadow the loop variable to avoid aliasing
			storageBlobItem := storageBlobItem
			var storageBlob StorageBlob_STATUS
			err := storageBlob.AssignProperties_From_StorageBlob_STATUS(&storageBlobItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_StorageBlob_STATUS() to populate field StorageBlobs")
			}
			storageBlobList[storageBlobIndex] = storageBlob
		}
		data.StorageBlobs = storageBlobList
	} else {
		data.StorageBlobs = nil
	}

	// No error
	return nil
}

// AssignProperties_To_EnrichmentData_STATUS populates the provided destination EnrichmentData_STATUS from our EnrichmentData_STATUS
func (data *EnrichmentData_STATUS) AssignProperties_To_EnrichmentData_STATUS(destination *storage.EnrichmentData_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// StorageBlobs
	if data.StorageBlobs != nil {
		storageBlobList := make([]storage.StorageBlob_STATUS, len(data.StorageBlobs))
		for storageBlobIndex, storageBlobItem := range data.StorageBlobs {
			// Shadow the loop variable to avoid aliasing
			storageBlobItem := storageBlobItem
			var storageBlob storage.StorageBlob_STATUS
			err := storageBlobItem.AssignProperties_To_StorageBlob_STATUS(&storageBlob)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_StorageBlob_STATUS() to populate field StorageBlobs")
			}
			storageBlobList[storageBlobIndex] = storageBlob
		}
		destination.StorageBlobs = storageBlobList
	} else {
		destination.StorageBlobs = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type EventHubDestination struct {
	// EventHubResourceReference: The resource ID of the event hub.
	EventHubResourceReference *genruntime.ResourceReference `armReference:"EventHubResourceId" json:"eventHubResourceReference,omitempty"`

	// Name: A friendly name for the destination.
	// This name should be unique across all destinations (regardless of type) within the data collection rule.
	Name *string `json:"name,omitempty"`
}

var _ genruntime.ARMTransformer = &EventHubDestination{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (destination *EventHubDestination) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if destination == nil {
		return nil, nil
	}
	result := &arm.EventHubDestination{}

	// Set property "EventHubResourceId":
	if destination.EventHubResourceReference != nil {
		eventHubResourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*destination.EventHubResourceReference)
		if err != nil {
			return nil, err
		}
		eventHubResourceReference := eventHubResourceReferenceARMID
		result.EventHubResourceId = &eventHubResourceReference
	}

	// Set property "Name":
	if destination.Name != nil {
		name := *destination.Name
		result.Name = &name
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (destination *EventHubDestination) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EventHubDestination{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (destination *EventHubDestination) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EventHubDestination)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EventHubDestination, got %T", armInput)
	}

	// no assignment for property "EventHubResourceReference"

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		destination.Name = &name
	}

	// No error
	return nil
}

// AssignProperties_From_EventHubDestination populates our EventHubDestination from the provided source EventHubDestination
func (destination *EventHubDestination) AssignProperties_From_EventHubDestination(source *storage.EventHubDestination) error {

	// EventHubResourceReference
	if source.EventHubResourceReference != nil {
		eventHubResourceReference := source.EventHubResourceReference.Copy()
		destination.EventHubResourceReference = &eventHubResourceReference
	} else {
		destination.EventHubResourceReference = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// No error
	return nil
}

// AssignProperties_To_EventHubDestination populates the provided destination EventHubDestination from our EventHubDestination
func (destination *EventHubDestination) AssignProperties_To_EventHubDestination(target *storage.EventHubDestination) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EventHubResourceReference
	if destination.EventHubResourceReference != nil {
		eventHubResourceReference := destination.EventHubResourceReference.Copy()
		target.EventHubResourceReference = &eventHubResourceReference
	} else {
		target.EventHubResourceReference = nil
	}

	// Name
	target.Name = genruntime.ClonePointerToString(destination.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		target.PropertyBag = propertyBag
	} else {
		target.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_EventHubDestination_STATUS populates our EventHubDestination from the provided source EventHubDestination_STATUS
func (destination *EventHubDestination) Initialize_From_EventHubDestination_STATUS(source *EventHubDestination_STATUS) error {

	// EventHubResourceReference
	if source.EventHubResourceId != nil {
		eventHubResourceReference := genruntime.CreateResourceReferenceFromARMID(*source.EventHubResourceId)
		destination.EventHubResourceReference = &eventHubResourceReference
	} else {
		destination.EventHubResourceReference = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// No error
	return nil
}

type EventHubDestination_STATUS struct {
	// EventHubResourceId: The resource ID of the event hub.
	EventHubResourceId *string `json:"eventHubResourceId,omitempty"`

	// Name: A friendly name for the destination.
	// This name should be unique across all destinations (regardless of type) within the data collection rule.
	Name *string `json:"name,omitempty"`
}

var _ genruntime.FromARMConverter = &EventHubDestination_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (destination *EventHubDestination_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EventHubDestination_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (destination *EventHubDestination_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EventHubDestination_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EventHubDestination_STATUS, got %T", armInput)
	}

	// Set property "EventHubResourceId":
	if typedInput.EventHubResourceId != nil {
		eventHubResourceId := *typedInput.EventHubResourceId
		destination.EventHubResourceId = &eventHubResourceId
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		destination.Name = &name
	}

	// No error
	return nil
}

// AssignProperties_From_EventHubDestination_STATUS populates our EventHubDestination_STATUS from the provided source EventHubDestination_STATUS
func (destination *EventHubDestination_STATUS) AssignProperties_From_EventHubDestination_STATUS(source *storage.EventHubDestination_STATUS) error {

	// EventHubResourceId
	destination.EventHubResourceId = genruntime.ClonePointerToString(source.EventHubResourceId)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// No error
	return nil
}

// AssignProperties_To_EventHubDestination_STATUS populates the provided destination EventHubDestination_STATUS from our EventHubDestination_STATUS
func (destination *EventHubDestination_STATUS) AssignProperties_To_EventHubDestination_STATUS(target *storage.EventHubDestination_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EventHubResourceId
	target.EventHubResourceId = genruntime.ClonePointerToString(destination.EventHubResourceId)

	// Name
	target.Name = genruntime.ClonePointerToString(destination.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		target.PropertyBag = propertyBag
	} else {
		target.PropertyBag = nil
	}

	// No error
	return nil
}

type EventHubDirectDestination struct {
	// EventHubResourceReference: The resource ID of the event hub.
	EventHubResourceReference *genruntime.ResourceReference `armReference:"EventHubResourceId" json:"eventHubResourceReference,omitempty"`

	// Name: A friendly name for the destination.
	// This name should be unique across all destinations (regardless of type) within the data collection rule.
	Name *string `json:"name,omitempty"`
}

var _ genruntime.ARMTransformer = &EventHubDirectDestination{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (destination *EventHubDirectDestination) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if destination == nil {
		return nil, nil
	}
	result := &arm.EventHubDirectDestination{}

	// Set property "EventHubResourceId":
	if destination.EventHubResourceReference != nil {
		eventHubResourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*destination.EventHubResourceReference)
		if err != nil {
			return nil, err
		}
		eventHubResourceReference := eventHubResourceReferenceARMID
		result.EventHubResourceId = &eventHubResourceReference
	}

	// Set property "Name":
	if destination.Name != nil {
		name := *destination.Name
		result.Name = &name
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (destination *EventHubDirectDestination) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EventHubDirectDestination{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (destination *EventHubDirectDestination) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EventHubDirectDestination)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EventHubDirectDestination, got %T", armInput)
	}

	// no assignment for property "EventHubResourceReference"

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		destination.Name = &name
	}

	// No error
	return nil
}

// AssignProperties_From_EventHubDirectDestination populates our EventHubDirectDestination from the provided source EventHubDirectDestination
func (destination *EventHubDirectDestination) AssignProperties_From_EventHubDirectDestination(source *storage.EventHubDirectDestination) error {

	// EventHubResourceReference
	if source.EventHubResourceReference != nil {
		eventHubResourceReference := source.EventHubResourceReference.Copy()
		destination.EventHubResourceReference = &eventHubResourceReference
	} else {
		destination.EventHubResourceReference = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// No error
	return nil
}

// AssignProperties_To_EventHubDirectDestination populates the provided destination EventHubDirectDestination from our EventHubDirectDestination
func (destination *EventHubDirectDestination) AssignProperties_To_EventHubDirectDestination(target *storage.EventHubDirectDestination) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EventHubResourceReference
	if destination.EventHubResourceReference != nil {
		eventHubResourceReference := destination.EventHubResourceReference.Copy()
		target.EventHubResourceReference = &eventHubResourceReference
	} else {
		target.EventHubResourceReference = nil
	}

	// Name
	target.Name = genruntime.ClonePointerToString(destination.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		target.PropertyBag = propertyBag
	} else {
		target.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_EventHubDirectDestination_STATUS populates our EventHubDirectDestination from the provided source EventHubDirectDestination_STATUS
func (destination *EventHubDirectDestination) Initialize_From_EventHubDirectDestination_STATUS(source *EventHubDirectDestination_STATUS) error {

	// EventHubResourceReference
	if source.EventHubResourceId != nil {
		eventHubResourceReference := genruntime.CreateResourceReferenceFromARMID(*source.EventHubResourceId)
		destination.EventHubResourceReference = &eventHubResourceReference
	} else {
		destination.EventHubResourceReference = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// No error
	return nil
}

type EventHubDirectDestination_STATUS struct {
	// EventHubResourceId: The resource ID of the event hub.
	EventHubResourceId *string `json:"eventHubResourceId,omitempty"`

	// Name: A friendly name for the destination.
	// This name should be unique across all destinations (regardless of type) within the data collection rule.
	Name *string `json:"name,omitempty"`
}

var _ genruntime.FromARMConverter = &EventHubDirectDestination_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (destination *EventHubDirectDestination_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EventHubDirectDestination_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (destination *EventHubDirectDestination_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EventHubDirectDestination_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EventHubDirectDestination_STATUS, got %T", armInput)
	}

	// Set property "EventHubResourceId":
	if typedInput.EventHubResourceId != nil {
		eventHubResourceId := *typedInput.EventHubResourceId
		destination.EventHubResourceId = &eventHubResourceId
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		destination.Name = &name
	}

	// No error
	return nil
}

// AssignProperties_From_EventHubDirectDestination_STATUS populates our EventHubDirectDestination_STATUS from the provided source EventHubDirectDestination_STATUS
func (destination *EventHubDirectDestination_STATUS) AssignProperties_From_EventHubDirectDestination_STATUS(source *storage.EventHubDirectDestination_STATUS) error {

	// EventHubResourceId
	destination.EventHubResourceId = genruntime.ClonePointerToString(source.EventHubResourceId)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// No error
	return nil
}

// AssignProperties_To_EventHubDirectDestination_STATUS populates the provided destination EventHubDirectDestination_STATUS from our EventHubDirectDestination_STATUS
func (destination *EventHubDirectDestination_STATUS) AssignProperties_To_EventHubDirectDestination_STATUS(target *storage.EventHubDirectDestination_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EventHubResourceId
	target.EventHubResourceId = genruntime.ClonePointerToString(destination.EventHubResourceId)

	// Name
	target.Name = genruntime.ClonePointerToString(destination.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		target.PropertyBag = propertyBag
	} else {
		target.PropertyBag = nil
	}

	// No error
	return nil
}

// Definition of which data will be collected from a separate VM extension that integrates with the Azure Monitor
// Agent.
// Collected from either Windows and Linux machines, depending on which extension is defined.
type ExtensionDataSource struct {
	// +kubebuilder:validation:Required
	// ExtensionName: The name of the VM extension.
	ExtensionName *string `json:"extensionName,omitempty"`

	// ExtensionSettings: The extension settings. The format is specific for particular extension.
	ExtensionSettings map[string]v1.JSON `json:"extensionSettings,omitempty"`

	// InputDataSources: The list of data sources this extension needs data from.
	InputDataSources []string `json:"inputDataSources,omitempty"`

	// Name: A friendly name for the data source.
	// This name should be unique across all data sources (regardless of type) within the data collection rule.
	Name *string `json:"name,omitempty"`

	// Streams: List of streams that this data source will be sent to.
	// A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent
	// to.
	Streams []ExtensionDataSource_Streams `json:"streams,omitempty"`
}

var _ genruntime.ARMTransformer = &ExtensionDataSource{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (source *ExtensionDataSource) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if source == nil {
		return nil, nil
	}
	result := &arm.ExtensionDataSource{}

	// Set property "ExtensionName":
	if source.ExtensionName != nil {
		extensionName := *source.ExtensionName
		result.ExtensionName = &extensionName
	}

	// Set property "ExtensionSettings":
	if source.ExtensionSettings != nil {
		result.ExtensionSettings = make(map[string]v1.JSON, len(source.ExtensionSettings))
		for key, value := range source.ExtensionSettings {
			result.ExtensionSettings[key] = *value.DeepCopy()
		}
	}

	// Set property "InputDataSources":
	for _, item := range source.InputDataSources {
		result.InputDataSources = append(result.InputDataSources, item)
	}

	// Set property "Name":
	if source.Name != nil {
		name := *source.Name
		result.Name = &name
	}

	// Set property "Streams":
	for _, item := range source.Streams {
		var temp string
		temp = string(item)
		result.Streams = append(result.Streams, arm.ExtensionDataSource_Streams(temp))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (source *ExtensionDataSource) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ExtensionDataSource{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (source *ExtensionDataSource) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ExtensionDataSource)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ExtensionDataSource, got %T", armInput)
	}

	// Set property "ExtensionName":
	if typedInput.ExtensionName != nil {
		extensionName := *typedInput.ExtensionName
		source.ExtensionName = &extensionName
	}

	// Set property "ExtensionSettings":
	if typedInput.ExtensionSettings != nil {
		source.ExtensionSettings = make(map[string]v1.JSON, len(typedInput.ExtensionSettings))
		for key, value := range typedInput.ExtensionSettings {
			source.ExtensionSettings[key] = *value.DeepCopy()
		}
	}

	// Set property "InputDataSources":
	for _, item := range typedInput.InputDataSources {
		source.InputDataSources = append(source.InputDataSources, item)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		source.Name = &name
	}

	// Set property "Streams":
	for _, item := range typedInput.Streams {
		var temp string
		temp = string(item)
		source.Streams = append(source.Streams, ExtensionDataSource_Streams(temp))
	}

	// No error
	return nil
}

// AssignProperties_From_ExtensionDataSource populates our ExtensionDataSource from the provided source ExtensionDataSource
func (source *ExtensionDataSource) AssignProperties_From_ExtensionDataSource(origin *storage.ExtensionDataSource) error {

	// ExtensionName
	source.ExtensionName = genruntime.ClonePointerToString(origin.ExtensionName)

	// ExtensionSettings
	if origin.ExtensionSettings != nil {
		extensionSettingMap := make(map[string]v1.JSON, len(origin.ExtensionSettings))
		for extensionSettingKey, extensionSettingValue := range origin.ExtensionSettings {
			// Shadow the loop variable to avoid aliasing
			extensionSettingValue := extensionSettingValue
			extensionSettingMap[extensionSettingKey] = *extensionSettingValue.DeepCopy()
		}
		source.ExtensionSettings = extensionSettingMap
	} else {
		source.ExtensionSettings = nil
	}

	// InputDataSources
	source.InputDataSources = genruntime.CloneSliceOfString(origin.InputDataSources)

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// Streams
	if origin.Streams != nil {
		streamList := make([]ExtensionDataSource_Streams, len(origin.Streams))
		for streamIndex, streamItem := range origin.Streams {
			// Shadow the loop variable to avoid aliasing
			streamItem := streamItem
			streamList[streamIndex] = genruntime.ToEnum(streamItem, extensionDataSource_Streams_Values)
		}
		source.Streams = streamList
	} else {
		source.Streams = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ExtensionDataSource populates the provided destination ExtensionDataSource from our ExtensionDataSource
func (source *ExtensionDataSource) AssignProperties_To_ExtensionDataSource(destination *storage.ExtensionDataSource) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ExtensionName
	destination.ExtensionName = genruntime.ClonePointerToString(source.ExtensionName)

	// ExtensionSettings
	if source.ExtensionSettings != nil {
		extensionSettingMap := make(map[string]v1.JSON, len(source.ExtensionSettings))
		for extensionSettingKey, extensionSettingValue := range source.ExtensionSettings {
			// Shadow the loop variable to avoid aliasing
			extensionSettingValue := extensionSettingValue
			extensionSettingMap[extensionSettingKey] = *extensionSettingValue.DeepCopy()
		}
		destination.ExtensionSettings = extensionSettingMap
	} else {
		destination.ExtensionSettings = nil
	}

	// InputDataSources
	destination.InputDataSources = genruntime.CloneSliceOfString(source.InputDataSources)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// Streams
	if source.Streams != nil {
		streamList := make([]string, len(source.Streams))
		for streamIndex, streamItem := range source.Streams {
			// Shadow the loop variable to avoid aliasing
			streamItem := streamItem
			streamList[streamIndex] = string(streamItem)
		}
		destination.Streams = streamList
	} else {
		destination.Streams = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ExtensionDataSource_STATUS populates our ExtensionDataSource from the provided source ExtensionDataSource_STATUS
func (source *ExtensionDataSource) Initialize_From_ExtensionDataSource_STATUS(origin *ExtensionDataSource_STATUS) error {

	// ExtensionName
	source.ExtensionName = genruntime.ClonePointerToString(origin.ExtensionName)

	// ExtensionSettings
	if origin.ExtensionSettings != nil {
		extensionSettingMap := make(map[string]v1.JSON, len(origin.ExtensionSettings))
		for extensionSettingKey, extensionSettingValue := range origin.ExtensionSettings {
			// Shadow the loop variable to avoid aliasing
			extensionSettingValue := extensionSettingValue
			extensionSettingMap[extensionSettingKey] = *extensionSettingValue.DeepCopy()
		}
		source.ExtensionSettings = extensionSettingMap
	} else {
		source.ExtensionSettings = nil
	}

	// InputDataSources
	source.InputDataSources = genruntime.CloneSliceOfString(origin.InputDataSources)

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// Streams
	if origin.Streams != nil {
		streamList := make([]ExtensionDataSource_Streams, len(origin.Streams))
		for streamIndex, streamItem := range origin.Streams {
			// Shadow the loop variable to avoid aliasing
			streamItem := streamItem
			stream := genruntime.ToEnum(string(streamItem), extensionDataSource_Streams_Values)
			streamList[streamIndex] = stream
		}
		source.Streams = streamList
	} else {
		source.Streams = nil
	}

	// No error
	return nil
}

// Definition of which data will be collected from a separate VM extension that integrates with the Azure Monitor
// Agent.
// Collected from either Windows and Linux machines, depending on which extension is defined.
type ExtensionDataSource_STATUS struct {
	// ExtensionName: The name of the VM extension.
	ExtensionName *string `json:"extensionName,omitempty"`

	// ExtensionSettings: The extension settings. The format is specific for particular extension.
	ExtensionSettings map[string]v1.JSON `json:"extensionSettings,omitempty"`

	// InputDataSources: The list of data sources this extension needs data from.
	InputDataSources []string `json:"inputDataSources,omitempty"`

	// Name: A friendly name for the data source.
	// This name should be unique across all data sources (regardless of type) within the data collection rule.
	Name *string `json:"name,omitempty"`

	// Streams: List of streams that this data source will be sent to.
	// A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent
	// to.
	Streams []ExtensionDataSource_Streams_STATUS `json:"streams,omitempty"`
}

var _ genruntime.FromARMConverter = &ExtensionDataSource_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (source *ExtensionDataSource_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ExtensionDataSource_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (source *ExtensionDataSource_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ExtensionDataSource_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ExtensionDataSource_STATUS, got %T", armInput)
	}

	// Set property "ExtensionName":
	if typedInput.ExtensionName != nil {
		extensionName := *typedInput.ExtensionName
		source.ExtensionName = &extensionName
	}

	// Set property "ExtensionSettings":
	if typedInput.ExtensionSettings != nil {
		source.ExtensionSettings = make(map[string]v1.JSON, len(typedInput.ExtensionSettings))
		for key, value := range typedInput.ExtensionSettings {
			source.ExtensionSettings[key] = *value.DeepCopy()
		}
	}

	// Set property "InputDataSources":
	for _, item := range typedInput.InputDataSources {
		source.InputDataSources = append(source.InputDataSources, item)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		source.Name = &name
	}

	// Set property "Streams":
	for _, item := range typedInput.Streams {
		var temp string
		temp = string(item)
		source.Streams = append(source.Streams, ExtensionDataSource_Streams_STATUS(temp))
	}

	// No error
	return nil
}

// AssignProperties_From_ExtensionDataSource_STATUS populates our ExtensionDataSource_STATUS from the provided source ExtensionDataSource_STATUS
func (source *ExtensionDataSource_STATUS) AssignProperties_From_ExtensionDataSource_STATUS(origin *storage.ExtensionDataSource_STATUS) error {

	// ExtensionName
	source.ExtensionName = genruntime.ClonePointerToString(origin.ExtensionName)

	// ExtensionSettings
	if origin.ExtensionSettings != nil {
		extensionSettingMap := make(map[string]v1.JSON, len(origin.ExtensionSettings))
		for extensionSettingKey, extensionSettingValue := range origin.ExtensionSettings {
			// Shadow the loop variable to avoid aliasing
			extensionSettingValue := extensionSettingValue
			extensionSettingMap[extensionSettingKey] = *extensionSettingValue.DeepCopy()
		}
		source.ExtensionSettings = extensionSettingMap
	} else {
		source.ExtensionSettings = nil
	}

	// InputDataSources
	source.InputDataSources = genruntime.CloneSliceOfString(origin.InputDataSources)

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// Streams
	if origin.Streams != nil {
		streamList := make([]ExtensionDataSource_Streams_STATUS, len(origin.Streams))
		for streamIndex, streamItem := range origin.Streams {
			// Shadow the loop variable to avoid aliasing
			streamItem := streamItem
			streamList[streamIndex] = genruntime.ToEnum(streamItem, extensionDataSource_Streams_STATUS_Values)
		}
		source.Streams = streamList
	} else {
		source.Streams = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ExtensionDataSource_STATUS populates the provided destination ExtensionDataSource_STATUS from our ExtensionDataSource_STATUS
func (source *ExtensionDataSource_STATUS) AssignProperties_To_ExtensionDataSource_STATUS(destination *storage.ExtensionDataSource_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ExtensionName
	destination.ExtensionName = genruntime.ClonePointerToString(source.ExtensionName)

	// ExtensionSettings
	if source.ExtensionSettings != nil {
		extensionSettingMap := make(map[string]v1.JSON, len(source.ExtensionSettings))
		for extensionSettingKey, extensionSettingValue := range source.ExtensionSettings {
			// Shadow the loop variable to avoid aliasing
			extensionSettingValue := extensionSettingValue
			extensionSettingMap[extensionSettingKey] = *extensionSettingValue.DeepCopy()
		}
		destination.ExtensionSettings = extensionSettingMap
	} else {
		destination.ExtensionSettings = nil
	}

	// InputDataSources
	destination.InputDataSources = genruntime.CloneSliceOfString(source.InputDataSources)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// Streams
	if source.Streams != nil {
		streamList := make([]string, len(source.Streams))
		for streamIndex, streamItem := range source.Streams {
			// Shadow the loop variable to avoid aliasing
			streamItem := streamItem
			streamList[streamIndex] = string(streamItem)
		}
		destination.Streams = streamList
	} else {
		destination.Streams = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Enables IIS logs to be collected by this data collection rule.
type IisLogsDataSource struct {
	// LogDirectories: Absolute paths file location
	LogDirectories []string `json:"logDirectories,omitempty"`

	// Name: A friendly name for the data source.
	// This name should be unique across all data sources (regardless of type) within the data collection rule.
	Name *string `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Streams: IIS streams
	Streams []string `json:"streams,omitempty"`

	// TransformKql: The KQL query to transform the data source.
	TransformKql *string `json:"transformKql,omitempty"`
}

var _ genruntime.ARMTransformer = &IisLogsDataSource{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (source *IisLogsDataSource) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if source == nil {
		return nil, nil
	}
	result := &arm.IisLogsDataSource{}

	// Set property "LogDirectories":
	for _, item := range source.LogDirectories {
		result.LogDirectories = append(result.LogDirectories, item)
	}

	// Set property "Name":
	if source.Name != nil {
		name := *source.Name
		result.Name = &name
	}

	// Set property "Streams":
	for _, item := range source.Streams {
		result.Streams = append(result.Streams, item)
	}

	// Set property "TransformKql":
	if source.TransformKql != nil {
		transformKql := *source.TransformKql
		result.TransformKql = &transformKql
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (source *IisLogsDataSource) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.IisLogsDataSource{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (source *IisLogsDataSource) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.IisLogsDataSource)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.IisLogsDataSource, got %T", armInput)
	}

	// Set property "LogDirectories":
	for _, item := range typedInput.LogDirectories {
		source.LogDirectories = append(source.LogDirectories, item)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		source.Name = &name
	}

	// Set property "Streams":
	for _, item := range typedInput.Streams {
		source.Streams = append(source.Streams, item)
	}

	// Set property "TransformKql":
	if typedInput.TransformKql != nil {
		transformKql := *typedInput.TransformKql
		source.TransformKql = &transformKql
	}

	// No error
	return nil
}

// AssignProperties_From_IisLogsDataSource populates our IisLogsDataSource from the provided source IisLogsDataSource
func (source *IisLogsDataSource) AssignProperties_From_IisLogsDataSource(origin *storage.IisLogsDataSource) error {

	// LogDirectories
	source.LogDirectories = genruntime.CloneSliceOfString(origin.LogDirectories)

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// Streams
	source.Streams = genruntime.CloneSliceOfString(origin.Streams)

	// TransformKql
	source.TransformKql = genruntime.ClonePointerToString(origin.TransformKql)

	// No error
	return nil
}

// AssignProperties_To_IisLogsDataSource populates the provided destination IisLogsDataSource from our IisLogsDataSource
func (source *IisLogsDataSource) AssignProperties_To_IisLogsDataSource(destination *storage.IisLogsDataSource) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// LogDirectories
	destination.LogDirectories = genruntime.CloneSliceOfString(source.LogDirectories)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// Streams
	destination.Streams = genruntime.CloneSliceOfString(source.Streams)

	// TransformKql
	destination.TransformKql = genruntime.ClonePointerToString(source.TransformKql)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_IisLogsDataSource_STATUS populates our IisLogsDataSource from the provided source IisLogsDataSource_STATUS
func (source *IisLogsDataSource) Initialize_From_IisLogsDataSource_STATUS(origin *IisLogsDataSource_STATUS) error {

	// LogDirectories
	source.LogDirectories = genruntime.CloneSliceOfString(origin.LogDirectories)

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// Streams
	source.Streams = genruntime.CloneSliceOfString(origin.Streams)

	// TransformKql
	source.TransformKql = genruntime.ClonePointerToString(origin.TransformKql)

	// No error
	return nil
}

// Enables IIS logs to be collected by this data collection rule.
type IisLogsDataSource_STATUS struct {
	// LogDirectories: Absolute paths file location
	LogDirectories []string `json:"logDirectories,omitempty"`

	// Name: A friendly name for the data source.
	// This name should be unique across all data sources (regardless of type) within the data collection rule.
	Name *string `json:"name,omitempty"`

	// Streams: IIS streams
	Streams []string `json:"streams,omitempty"`

	// TransformKql: The KQL query to transform the data source.
	TransformKql *string `json:"transformKql,omitempty"`
}

var _ genruntime.FromARMConverter = &IisLogsDataSource_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (source *IisLogsDataSource_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.IisLogsDataSource_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (source *IisLogsDataSource_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.IisLogsDataSource_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.IisLogsDataSource_STATUS, got %T", armInput)
	}

	// Set property "LogDirectories":
	for _, item := range typedInput.LogDirectories {
		source.LogDirectories = append(source.LogDirectories, item)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		source.Name = &name
	}

	// Set property "Streams":
	for _, item := range typedInput.Streams {
		source.Streams = append(source.Streams, item)
	}

	// Set property "TransformKql":
	if typedInput.TransformKql != nil {
		transformKql := *typedInput.TransformKql
		source.TransformKql = &transformKql
	}

	// No error
	return nil
}

// AssignProperties_From_IisLogsDataSource_STATUS populates our IisLogsDataSource_STATUS from the provided source IisLogsDataSource_STATUS
func (source *IisLogsDataSource_STATUS) AssignProperties_From_IisLogsDataSource_STATUS(origin *storage.IisLogsDataSource_STATUS) error {

	// LogDirectories
	source.LogDirectories = genruntime.CloneSliceOfString(origin.LogDirectories)

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// Streams
	source.Streams = genruntime.CloneSliceOfString(origin.Streams)

	// TransformKql
	source.TransformKql = genruntime.ClonePointerToString(origin.TransformKql)

	// No error
	return nil
}

// AssignProperties_To_IisLogsDataSource_STATUS populates the provided destination IisLogsDataSource_STATUS from our IisLogsDataSource_STATUS
func (source *IisLogsDataSource_STATUS) AssignProperties_To_IisLogsDataSource_STATUS(destination *storage.IisLogsDataSource_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// LogDirectories
	destination.LogDirectories = genruntime.CloneSliceOfString(source.LogDirectories)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// Streams
	destination.Streams = genruntime.CloneSliceOfString(source.Streams)

	// TransformKql
	destination.TransformKql = genruntime.ClonePointerToString(source.TransformKql)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Log Analytics destination.
type LogAnalyticsDestination struct {
	// Name: A friendly name for the destination.
	// This name should be unique across all destinations (regardless of type) within the data collection rule.
	Name *string `json:"name,omitempty"`

	// WorkspaceResourceReference: The resource ID of the Log Analytics workspace.
	WorkspaceResourceReference *genruntime.ResourceReference `armReference:"WorkspaceResourceId" json:"workspaceResourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &LogAnalyticsDestination{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (destination *LogAnalyticsDestination) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if destination == nil {
		return nil, nil
	}
	result := &arm.LogAnalyticsDestination{}

	// Set property "Name":
	if destination.Name != nil {
		name := *destination.Name
		result.Name = &name
	}

	// Set property "WorkspaceResourceId":
	if destination.WorkspaceResourceReference != nil {
		workspaceResourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*destination.WorkspaceResourceReference)
		if err != nil {
			return nil, err
		}
		workspaceResourceReference := workspaceResourceReferenceARMID
		result.WorkspaceResourceId = &workspaceResourceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (destination *LogAnalyticsDestination) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.LogAnalyticsDestination{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (destination *LogAnalyticsDestination) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.LogAnalyticsDestination)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.LogAnalyticsDestination, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		destination.Name = &name
	}

	// no assignment for property "WorkspaceResourceReference"

	// No error
	return nil
}

// AssignProperties_From_LogAnalyticsDestination populates our LogAnalyticsDestination from the provided source LogAnalyticsDestination
func (destination *LogAnalyticsDestination) AssignProperties_From_LogAnalyticsDestination(source *storage.LogAnalyticsDestination) error {

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// WorkspaceResourceReference
	if source.WorkspaceResourceReference != nil {
		workspaceResourceReference := source.WorkspaceResourceReference.Copy()
		destination.WorkspaceResourceReference = &workspaceResourceReference
	} else {
		destination.WorkspaceResourceReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_LogAnalyticsDestination populates the provided destination LogAnalyticsDestination from our LogAnalyticsDestination
func (destination *LogAnalyticsDestination) AssignProperties_To_LogAnalyticsDestination(target *storage.LogAnalyticsDestination) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	target.Name = genruntime.ClonePointerToString(destination.Name)

	// WorkspaceResourceReference
	if destination.WorkspaceResourceReference != nil {
		workspaceResourceReference := destination.WorkspaceResourceReference.Copy()
		target.WorkspaceResourceReference = &workspaceResourceReference
	} else {
		target.WorkspaceResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		target.PropertyBag = propertyBag
	} else {
		target.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_LogAnalyticsDestination_STATUS populates our LogAnalyticsDestination from the provided source LogAnalyticsDestination_STATUS
func (destination *LogAnalyticsDestination) Initialize_From_LogAnalyticsDestination_STATUS(source *LogAnalyticsDestination_STATUS) error {

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// WorkspaceResourceReference
	if source.WorkspaceResourceId != nil {
		workspaceResourceReference := genruntime.CreateResourceReferenceFromARMID(*source.WorkspaceResourceId)
		destination.WorkspaceResourceReference = &workspaceResourceReference
	} else {
		destination.WorkspaceResourceReference = nil
	}

	// No error
	return nil
}

// Log Analytics destination.
type LogAnalyticsDestination_STATUS struct {
	// Name: A friendly name for the destination.
	// This name should be unique across all destinations (regardless of type) within the data collection rule.
	Name *string `json:"name,omitempty"`

	// WorkspaceId: The Customer ID of the Log Analytics workspace.
	WorkspaceId *string `json:"workspaceId,omitempty"`

	// WorkspaceResourceId: The resource ID of the Log Analytics workspace.
	WorkspaceResourceId *string `json:"workspaceResourceId,omitempty"`
}

var _ genruntime.FromARMConverter = &LogAnalyticsDestination_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (destination *LogAnalyticsDestination_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.LogAnalyticsDestination_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (destination *LogAnalyticsDestination_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.LogAnalyticsDestination_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.LogAnalyticsDestination_STATUS, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		destination.Name = &name
	}

	// Set property "WorkspaceId":
	if typedInput.WorkspaceId != nil {
		workspaceId := *typedInput.WorkspaceId
		destination.WorkspaceId = &workspaceId
	}

	// Set property "WorkspaceResourceId":
	if typedInput.WorkspaceResourceId != nil {
		workspaceResourceId := *typedInput.WorkspaceResourceId
		destination.WorkspaceResourceId = &workspaceResourceId
	}

	// No error
	return nil
}

// AssignProperties_From_LogAnalyticsDestination_STATUS populates our LogAnalyticsDestination_STATUS from the provided source LogAnalyticsDestination_STATUS
func (destination *LogAnalyticsDestination_STATUS) AssignProperties_From_LogAnalyticsDestination_STATUS(source *storage.LogAnalyticsDestination_STATUS) error {

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// WorkspaceId
	destination.WorkspaceId = genruntime.ClonePointerToString(source.WorkspaceId)

	// WorkspaceResourceId
	destination.WorkspaceResourceId = genruntime.ClonePointerToString(source.WorkspaceResourceId)

	// No error
	return nil
}

// AssignProperties_To_LogAnalyticsDestination_STATUS populates the provided destination LogAnalyticsDestination_STATUS from our LogAnalyticsDestination_STATUS
func (destination *LogAnalyticsDestination_STATUS) AssignProperties_To_LogAnalyticsDestination_STATUS(target *storage.LogAnalyticsDestination_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	target.Name = genruntime.ClonePointerToString(destination.Name)

	// WorkspaceId
	target.WorkspaceId = genruntime.ClonePointerToString(destination.WorkspaceId)

	// WorkspaceResourceId
	target.WorkspaceResourceId = genruntime.ClonePointerToString(destination.WorkspaceResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		target.PropertyBag = propertyBag
	} else {
		target.PropertyBag = nil
	}

	// No error
	return nil
}

// Definition of which custom log files will be collected by this data collection rule
type LogFilesDataSource struct {
	// +kubebuilder:validation:Required
	// FilePatterns: File Patterns where the log files are located
	FilePatterns []string `json:"filePatterns,omitempty"`

	// +kubebuilder:validation:Required
	// Format: The data format of the log files
	Format *LogFilesDataSource_Format `json:"format,omitempty"`

	// Name: A friendly name for the data source.
	// This name should be unique across all data sources (regardless of type) within the data collection rule.
	Name *string `json:"name,omitempty"`

	// Settings: The log files specific settings.
	Settings *LogFileSettings `json:"settings,omitempty"`

	// +kubebuilder:validation:Required
	// Streams: List of streams that this data source will be sent to.
	// A stream indicates what schema will be used for this data source
	Streams []string `json:"streams,omitempty"`

	// TransformKql: The KQL query to transform the data source.
	TransformKql *string `json:"transformKql,omitempty"`
}

var _ genruntime.ARMTransformer = &LogFilesDataSource{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (source *LogFilesDataSource) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if source == nil {
		return nil, nil
	}
	result := &arm.LogFilesDataSource{}

	// Set property "FilePatterns":
	for _, item := range source.FilePatterns {
		result.FilePatterns = append(result.FilePatterns, item)
	}

	// Set property "Format":
	if source.Format != nil {
		var temp string
		temp = string(*source.Format)
		format := arm.LogFilesDataSource_Format(temp)
		result.Format = &format
	}

	// Set property "Name":
	if source.Name != nil {
		name := *source.Name
		result.Name = &name
	}

	// Set property "Settings":
	if source.Settings != nil {
		settings_ARM, err := (*source.Settings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		settings := *settings_ARM.(*arm.LogFileSettings)
		result.Settings = &settings
	}

	// Set property "Streams":
	for _, item := range source.Streams {
		result.Streams = append(result.Streams, item)
	}

	// Set property "TransformKql":
	if source.TransformKql != nil {
		transformKql := *source.TransformKql
		result.TransformKql = &transformKql
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (source *LogFilesDataSource) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.LogFilesDataSource{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (source *LogFilesDataSource) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.LogFilesDataSource)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.LogFilesDataSource, got %T", armInput)
	}

	// Set property "FilePatterns":
	for _, item := range typedInput.FilePatterns {
		source.FilePatterns = append(source.FilePatterns, item)
	}

	// Set property "Format":
	if typedInput.Format != nil {
		var temp string
		temp = string(*typedInput.Format)
		format := LogFilesDataSource_Format(temp)
		source.Format = &format
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		source.Name = &name
	}

	// Set property "Settings":
	if typedInput.Settings != nil {
		var settings1 LogFileSettings
		err := settings1.PopulateFromARM(owner, *typedInput.Settings)
		if err != nil {
			return err
		}
		settings := settings1
		source.Settings = &settings
	}

	// Set property "Streams":
	for _, item := range typedInput.Streams {
		source.Streams = append(source.Streams, item)
	}

	// Set property "TransformKql":
	if typedInput.TransformKql != nil {
		transformKql := *typedInput.TransformKql
		source.TransformKql = &transformKql
	}

	// No error
	return nil
}

// AssignProperties_From_LogFilesDataSource populates our LogFilesDataSource from the provided source LogFilesDataSource
func (source *LogFilesDataSource) AssignProperties_From_LogFilesDataSource(origin *storage.LogFilesDataSource) error {

	// FilePatterns
	source.FilePatterns = genruntime.CloneSliceOfString(origin.FilePatterns)

	// Format
	if origin.Format != nil {
		format := *origin.Format
		formatTemp := genruntime.ToEnum(format, logFilesDataSource_Format_Values)
		source.Format = &formatTemp
	} else {
		source.Format = nil
	}

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// Settings
	if origin.Settings != nil {
		var setting LogFileSettings
		err := setting.AssignProperties_From_LogFileSettings(origin.Settings)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_LogFileSettings() to populate field Settings")
		}
		source.Settings = &setting
	} else {
		source.Settings = nil
	}

	// Streams
	source.Streams = genruntime.CloneSliceOfString(origin.Streams)

	// TransformKql
	source.TransformKql = genruntime.ClonePointerToString(origin.TransformKql)

	// No error
	return nil
}

// AssignProperties_To_LogFilesDataSource populates the provided destination LogFilesDataSource from our LogFilesDataSource
func (source *LogFilesDataSource) AssignProperties_To_LogFilesDataSource(destination *storage.LogFilesDataSource) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// FilePatterns
	destination.FilePatterns = genruntime.CloneSliceOfString(source.FilePatterns)

	// Format
	if source.Format != nil {
		format := string(*source.Format)
		destination.Format = &format
	} else {
		destination.Format = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// Settings
	if source.Settings != nil {
		var setting storage.LogFileSettings
		err := source.Settings.AssignProperties_To_LogFileSettings(&setting)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_LogFileSettings() to populate field Settings")
		}
		destination.Settings = &setting
	} else {
		destination.Settings = nil
	}

	// Streams
	destination.Streams = genruntime.CloneSliceOfString(source.Streams)

	// TransformKql
	destination.TransformKql = genruntime.ClonePointerToString(source.TransformKql)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_LogFilesDataSource_STATUS populates our LogFilesDataSource from the provided source LogFilesDataSource_STATUS
func (source *LogFilesDataSource) Initialize_From_LogFilesDataSource_STATUS(origin *LogFilesDataSource_STATUS) error {

	// FilePatterns
	source.FilePatterns = genruntime.CloneSliceOfString(origin.FilePatterns)

	// Format
	if origin.Format != nil {
		format := genruntime.ToEnum(string(*origin.Format), logFilesDataSource_Format_Values)
		source.Format = &format
	} else {
		source.Format = nil
	}

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// Settings
	if origin.Settings != nil {
		var setting LogFileSettings
		err := setting.Initialize_From_LogFileSettings_STATUS(origin.Settings)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_LogFileSettings_STATUS() to populate field Settings")
		}
		source.Settings = &setting
	} else {
		source.Settings = nil
	}

	// Streams
	source.Streams = genruntime.CloneSliceOfString(origin.Streams)

	// TransformKql
	source.TransformKql = genruntime.ClonePointerToString(origin.TransformKql)

	// No error
	return nil
}

// Definition of which custom log files will be collected by this data collection rule
type LogFilesDataSource_STATUS struct {
	// FilePatterns: File Patterns where the log files are located
	FilePatterns []string `json:"filePatterns,omitempty"`

	// Format: The data format of the log files
	Format *LogFilesDataSource_Format_STATUS `json:"format,omitempty"`

	// Name: A friendly name for the data source.
	// This name should be unique across all data sources (regardless of type) within the data collection rule.
	Name *string `json:"name,omitempty"`

	// Settings: The log files specific settings.
	Settings *LogFileSettings_STATUS `json:"settings,omitempty"`

	// Streams: List of streams that this data source will be sent to.
	// A stream indicates what schema will be used for this data source
	Streams []string `json:"streams,omitempty"`

	// TransformKql: The KQL query to transform the data source.
	TransformKql *string `json:"transformKql,omitempty"`
}

var _ genruntime.FromARMConverter = &LogFilesDataSource_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (source *LogFilesDataSource_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.LogFilesDataSource_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (source *LogFilesDataSource_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.LogFilesDataSource_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.LogFilesDataSource_STATUS, got %T", armInput)
	}

	// Set property "FilePatterns":
	for _, item := range typedInput.FilePatterns {
		source.FilePatterns = append(source.FilePatterns, item)
	}

	// Set property "Format":
	if typedInput.Format != nil {
		var temp string
		temp = string(*typedInput.Format)
		format := LogFilesDataSource_Format_STATUS(temp)
		source.Format = &format
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		source.Name = &name
	}

	// Set property "Settings":
	if typedInput.Settings != nil {
		var settings1 LogFileSettings_STATUS
		err := settings1.PopulateFromARM(owner, *typedInput.Settings)
		if err != nil {
			return err
		}
		settings := settings1
		source.Settings = &settings
	}

	// Set property "Streams":
	for _, item := range typedInput.Streams {
		source.Streams = append(source.Streams, item)
	}

	// Set property "TransformKql":
	if typedInput.TransformKql != nil {
		transformKql := *typedInput.TransformKql
		source.TransformKql = &transformKql
	}

	// No error
	return nil
}

// AssignProperties_From_LogFilesDataSource_STATUS populates our LogFilesDataSource_STATUS from the provided source LogFilesDataSource_STATUS
func (source *LogFilesDataSource_STATUS) AssignProperties_From_LogFilesDataSource_STATUS(origin *storage.LogFilesDataSource_STATUS) error {

	// FilePatterns
	source.FilePatterns = genruntime.CloneSliceOfString(origin.FilePatterns)

	// Format
	if origin.Format != nil {
		format := *origin.Format
		formatTemp := genruntime.ToEnum(format, logFilesDataSource_Format_STATUS_Values)
		source.Format = &formatTemp
	} else {
		source.Format = nil
	}

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// Settings
	if origin.Settings != nil {
		var setting LogFileSettings_STATUS
		err := setting.AssignProperties_From_LogFileSettings_STATUS(origin.Settings)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_LogFileSettings_STATUS() to populate field Settings")
		}
		source.Settings = &setting
	} else {
		source.Settings = nil
	}

	// Streams
	source.Streams = genruntime.CloneSliceOfString(origin.Streams)

	// TransformKql
	source.TransformKql = genruntime.ClonePointerToString(origin.TransformKql)

	// No error
	return nil
}

// AssignProperties_To_LogFilesDataSource_STATUS populates the provided destination LogFilesDataSource_STATUS from our LogFilesDataSource_STATUS
func (source *LogFilesDataSource_STATUS) AssignProperties_To_LogFilesDataSource_STATUS(destination *storage.LogFilesDataSource_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// FilePatterns
	destination.FilePatterns = genruntime.CloneSliceOfString(source.FilePatterns)

	// Format
	if source.Format != nil {
		format := string(*source.Format)
		destination.Format = &format
	} else {
		destination.Format = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// Settings
	if source.Settings != nil {
		var setting storage.LogFileSettings_STATUS
		err := source.Settings.AssignProperties_To_LogFileSettings_STATUS(&setting)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_LogFileSettings_STATUS() to populate field Settings")
		}
		destination.Settings = &setting
	} else {
		destination.Settings = nil
	}

	// Streams
	destination.Streams = genruntime.CloneSliceOfString(source.Streams)

	// TransformKql
	destination.TransformKql = genruntime.ClonePointerToString(source.TransformKql)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
// +kubebuilder:validation:Enum={"None","SystemAssigned","SystemAssigned,UserAssigned","UserAssigned"}
type ManagedServiceIdentityType string

const (
	ManagedServiceIdentityType_None                       = ManagedServiceIdentityType("None")
	ManagedServiceIdentityType_SystemAssigned             = ManagedServiceIdentityType("SystemAssigned")
	ManagedServiceIdentityType_SystemAssignedUserAssigned = ManagedServiceIdentityType("SystemAssigned,UserAssigned")
	ManagedServiceIdentityType_UserAssigned               = ManagedServiceIdentityType("UserAssigned")
)

// Mapping from string to ManagedServiceIdentityType
var managedServiceIdentityType_Values = map[string]ManagedServiceIdentityType{
	"none":                        ManagedServiceIdentityType_None,
	"systemassigned":              ManagedServiceIdentityType_SystemAssigned,
	"systemassigned,userassigned": ManagedServiceIdentityType_SystemAssignedUserAssigned,
	"userassigned":                ManagedServiceIdentityType_UserAssigned,
}

// Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
type ManagedServiceIdentityType_STATUS string

const (
	ManagedServiceIdentityType_STATUS_None                       = ManagedServiceIdentityType_STATUS("None")
	ManagedServiceIdentityType_STATUS_SystemAssigned             = ManagedServiceIdentityType_STATUS("SystemAssigned")
	ManagedServiceIdentityType_STATUS_SystemAssignedUserAssigned = ManagedServiceIdentityType_STATUS("SystemAssigned,UserAssigned")
	ManagedServiceIdentityType_STATUS_UserAssigned               = ManagedServiceIdentityType_STATUS("UserAssigned")
)

// Mapping from string to ManagedServiceIdentityType_STATUS
var managedServiceIdentityType_STATUS_Values = map[string]ManagedServiceIdentityType_STATUS{
	"none":                        ManagedServiceIdentityType_STATUS_None,
	"systemassigned":              ManagedServiceIdentityType_STATUS_SystemAssigned,
	"systemassigned,userassigned": ManagedServiceIdentityType_STATUS_SystemAssignedUserAssigned,
	"userassigned":                ManagedServiceIdentityType_STATUS_UserAssigned,
}

// Microsoft Fabric destination (non-Azure).
type MicrosoftFabricDestination struct {
	// ArtifactId: The artifact id of the Microsoft Fabric resource.
	ArtifactId *string `json:"artifactId,omitempty"`

	// DatabaseName: The name of the database to which data will be ingested.
	DatabaseName *string `json:"databaseName,omitempty"`

	// IngestionUri: The ingestion uri of the Microsoft Fabric resource.
	IngestionUri *string `json:"ingestionUri,omitempty"`

	// Name: A friendly name for the destination.
	// This name should be unique across all destinations (regardless of type) within the data collection rule.
	Name *string `json:"name,omitempty"`

	// TenantId: The tenant id of the Microsoft Fabric resource.
	TenantId *string `json:"tenantId,omitempty"`
}

var _ genruntime.ARMTransformer = &MicrosoftFabricDestination{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (destination *MicrosoftFabricDestination) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if destination == nil {
		return nil, nil
	}
	result := &arm.MicrosoftFabricDestination{}

	// Set property "ArtifactId":
	if destination.ArtifactId != nil {
		artifactId := *destination.ArtifactId
		result.ArtifactId = &artifactId
	}

	// Set property "DatabaseName":
	if destination.DatabaseName != nil {
		databaseName := *destination.DatabaseName
		result.DatabaseName = &databaseName
	}

	// Set property "IngestionUri":
	if destination.IngestionUri != nil {
		ingestionUri := *destination.IngestionUri
		result.IngestionUri = &ingestionUri
	}

	// Set property "Name":
	if destination.Name != nil {
		name := *destination.Name
		result.Name = &name
	}

	// Set property "TenantId":
	if destination.TenantId != nil {
		tenantId := *destination.TenantId
		result.TenantId = &tenantId
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (destination *MicrosoftFabricDestination) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.MicrosoftFabricDestination{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (destination *MicrosoftFabricDestination) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.MicrosoftFabricDestination)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.MicrosoftFabricDestination, got %T", armInput)
	}

	// Set property "ArtifactId":
	if typedInput.ArtifactId != nil {
		artifactId := *typedInput.ArtifactId
		destination.ArtifactId = &artifactId
	}

	// Set property "DatabaseName":
	if typedInput.DatabaseName != nil {
		databaseName := *typedInput.DatabaseName
		destination.DatabaseName = &databaseName
	}

	// Set property "IngestionUri":
	if typedInput.IngestionUri != nil {
		ingestionUri := *typedInput.IngestionUri
		destination.IngestionUri = &ingestionUri
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		destination.Name = &name
	}

	// Set property "TenantId":
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		destination.TenantId = &tenantId
	}

	// No error
	return nil
}

// AssignProperties_From_MicrosoftFabricDestination populates our MicrosoftFabricDestination from the provided source MicrosoftFabricDestination
func (destination *MicrosoftFabricDestination) AssignProperties_From_MicrosoftFabricDestination(source *storage.MicrosoftFabricDestination) error {

	// ArtifactId
	destination.ArtifactId = genruntime.ClonePointerToString(source.ArtifactId)

	// DatabaseName
	destination.DatabaseName = genruntime.ClonePointerToString(source.DatabaseName)

	// IngestionUri
	destination.IngestionUri = genruntime.ClonePointerToString(source.IngestionUri)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// No error
	return nil
}

// AssignProperties_To_MicrosoftFabricDestination populates the provided destination MicrosoftFabricDestination from our MicrosoftFabricDestination
func (destination *MicrosoftFabricDestination) AssignProperties_To_MicrosoftFabricDestination(target *storage.MicrosoftFabricDestination) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ArtifactId
	target.ArtifactId = genruntime.ClonePointerToString(destination.ArtifactId)

	// DatabaseName
	target.DatabaseName = genruntime.ClonePointerToString(destination.DatabaseName)

	// IngestionUri
	target.IngestionUri = genruntime.ClonePointerToString(destination.IngestionUri)

	// Name
	target.Name = genruntime.ClonePointerToString(destination.Name)

	// TenantId
	target.TenantId = genruntime.ClonePointerToString(destination.TenantId)

	// Update the property bag
	if len(propertyBag) > 0 {
		target.PropertyBag = propertyBag
	} else {
		target.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_MicrosoftFabricDestination_STATUS populates our MicrosoftFabricDestination from the provided source MicrosoftFabricDestination_STATUS
func (destination *MicrosoftFabricDestination) Initialize_From_MicrosoftFabricDestination_STATUS(source *MicrosoftFabricDestination_STATUS) error {

	// ArtifactId
	destination.ArtifactId = genruntime.ClonePointerToString(source.ArtifactId)

	// DatabaseName
	destination.DatabaseName = genruntime.ClonePointerToString(source.DatabaseName)

	// IngestionUri
	destination.IngestionUri = genruntime.ClonePointerToString(source.IngestionUri)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// No error
	return nil
}

// Microsoft Fabric destination (non-Azure).
type MicrosoftFabricDestination_STATUS struct {
	// ArtifactId: The artifact id of the Microsoft Fabric resource.
	ArtifactId *string `json:"artifactId,omitempty"`

	// DatabaseName: The name of the database to which data will be ingested.
	DatabaseName *string `json:"databaseName,omitempty"`

	// IngestionUri: The ingestion uri of the Microsoft Fabric resource.
	IngestionUri *string `json:"ingestionUri,omitempty"`

	// Name: A friendly name for the destination.
	// This name should be unique across all destinations (regardless of type) within the data collection rule.
	Name *string `json:"name,omitempty"`

	// TenantId: The tenant id of the Microsoft Fabric resource.
	TenantId *string `json:"tenantId,omitempty"`
}

var _ genruntime.FromARMConverter = &MicrosoftFabricDestination_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (destination *MicrosoftFabricDestination_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.MicrosoftFabricDestination_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (destination *MicrosoftFabricDestination_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.MicrosoftFabricDestination_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.MicrosoftFabricDestination_STATUS, got %T", armInput)
	}

	// Set property "ArtifactId":
	if typedInput.ArtifactId != nil {
		artifactId := *typedInput.ArtifactId
		destination.ArtifactId = &artifactId
	}

	// Set property "DatabaseName":
	if typedInput.DatabaseName != nil {
		databaseName := *typedInput.DatabaseName
		destination.DatabaseName = &databaseName
	}

	// Set property "IngestionUri":
	if typedInput.IngestionUri != nil {
		ingestionUri := *typedInput.IngestionUri
		destination.IngestionUri = &ingestionUri
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		destination.Name = &name
	}

	// Set property "TenantId":
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		destination.TenantId = &tenantId
	}

	// No error
	return nil
}

// AssignProperties_From_MicrosoftFabricDestination_STATUS populates our MicrosoftFabricDestination_STATUS from the provided source MicrosoftFabricDestination_STATUS
func (destination *MicrosoftFabricDestination_STATUS) AssignProperties_From_MicrosoftFabricDestination_STATUS(source *storage.MicrosoftFabricDestination_STATUS) error {

	// ArtifactId
	destination.ArtifactId = genruntime.ClonePointerToString(source.ArtifactId)

	// DatabaseName
	destination.DatabaseName = genruntime.ClonePointerToString(source.DatabaseName)

	// IngestionUri
	destination.IngestionUri = genruntime.ClonePointerToString(source.IngestionUri)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// No error
	return nil
}

// AssignProperties_To_MicrosoftFabricDestination_STATUS populates the provided destination MicrosoftFabricDestination_STATUS from our MicrosoftFabricDestination_STATUS
func (destination *MicrosoftFabricDestination_STATUS) AssignProperties_To_MicrosoftFabricDestination_STATUS(target *storage.MicrosoftFabricDestination_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ArtifactId
	target.ArtifactId = genruntime.ClonePointerToString(destination.ArtifactId)

	// DatabaseName
	target.DatabaseName = genruntime.ClonePointerToString(destination.DatabaseName)

	// IngestionUri
	target.IngestionUri = genruntime.ClonePointerToString(destination.IngestionUri)

	// Name
	target.Name = genruntime.ClonePointerToString(destination.Name)

	// TenantId
	target.TenantId = genruntime.ClonePointerToString(destination.TenantId)

	// Update the property bag
	if len(propertyBag) > 0 {
		target.PropertyBag = propertyBag
	} else {
		target.PropertyBag = nil
	}

	// No error
	return nil
}

// Monitoring account destination.
type MonitoringAccountDestination struct {
	// AccountResourceReference: The resource ID of the monitoring account.
	AccountResourceReference *genruntime.ResourceReference `armReference:"AccountResourceId" json:"accountResourceReference,omitempty"`

	// Name: A friendly name for the destination.
	// This name should be unique across all destinations (regardless of type) within the data collection rule.
	Name *string `json:"name,omitempty"`
}

var _ genruntime.ARMTransformer = &MonitoringAccountDestination{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (destination *MonitoringAccountDestination) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if destination == nil {
		return nil, nil
	}
	result := &arm.MonitoringAccountDestination{}

	// Set property "AccountResourceId":
	if destination.AccountResourceReference != nil {
		accountResourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*destination.AccountResourceReference)
		if err != nil {
			return nil, err
		}
		accountResourceReference := accountResourceReferenceARMID
		result.AccountResourceId = &accountResourceReference
	}

	// Set property "Name":
	if destination.Name != nil {
		name := *destination.Name
		result.Name = &name
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (destination *MonitoringAccountDestination) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.MonitoringAccountDestination{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (destination *MonitoringAccountDestination) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.MonitoringAccountDestination)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.MonitoringAccountDestination, got %T", armInput)
	}

	// no assignment for property "AccountResourceReference"

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		destination.Name = &name
	}

	// No error
	return nil
}

// AssignProperties_From_MonitoringAccountDestination populates our MonitoringAccountDestination from the provided source MonitoringAccountDestination
func (destination *MonitoringAccountDestination) AssignProperties_From_MonitoringAccountDestination(source *storage.MonitoringAccountDestination) error {

	// AccountResourceReference
	if source.AccountResourceReference != nil {
		accountResourceReference := source.AccountResourceReference.Copy()
		destination.AccountResourceReference = &accountResourceReference
	} else {
		destination.AccountResourceReference = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// No error
	return nil
}

// AssignProperties_To_MonitoringAccountDestination populates the provided destination MonitoringAccountDestination from our MonitoringAccountDestination
func (destination *MonitoringAccountDestination) AssignProperties_To_MonitoringAccountDestination(target *storage.MonitoringAccountDestination) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AccountResourceReference
	if destination.AccountResourceReference != nil {
		accountResourceReference := destination.AccountResourceReference.Copy()
		target.AccountResourceReference = &accountResourceReference
	} else {
		target.AccountResourceReference = nil
	}

	// Name
	target.Name = genruntime.ClonePointerToString(destination.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		target.PropertyBag = propertyBag
	} else {
		target.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_MonitoringAccountDestination_STATUS populates our MonitoringAccountDestination from the provided source MonitoringAccountDestination_STATUS
func (destination *MonitoringAccountDestination) Initialize_From_MonitoringAccountDestination_STATUS(source *MonitoringAccountDestination_STATUS) error {

	// AccountResourceReference
	if source.AccountResourceId != nil {
		accountResourceReference := genruntime.CreateResourceReferenceFromARMID(*source.AccountResourceId)
		destination.AccountResourceReference = &accountResourceReference
	} else {
		destination.AccountResourceReference = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// No error
	return nil
}

// Monitoring account destination.
type MonitoringAccountDestination_STATUS struct {
	// AccountId: The immutable ID  of the account.
	AccountId *string `json:"accountId,omitempty"`

	// AccountResourceId: The resource ID of the monitoring account.
	AccountResourceId *string `json:"accountResourceId,omitempty"`

	// Name: A friendly name for the destination.
	// This name should be unique across all destinations (regardless of type) within the data collection rule.
	Name *string `json:"name,omitempty"`
}

var _ genruntime.FromARMConverter = &MonitoringAccountDestination_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (destination *MonitoringAccountDestination_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.MonitoringAccountDestination_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (destination *MonitoringAccountDestination_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.MonitoringAccountDestination_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.MonitoringAccountDestination_STATUS, got %T", armInput)
	}

	// Set property "AccountId":
	if typedInput.AccountId != nil {
		accountId := *typedInput.AccountId
		destination.AccountId = &accountId
	}

	// Set property "AccountResourceId":
	if typedInput.AccountResourceId != nil {
		accountResourceId := *typedInput.AccountResourceId
		destination.AccountResourceId = &accountResourceId
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		destination.Name = &name
	}

	// No error
	return nil
}

// AssignProperties_From_MonitoringAccountDestination_STATUS populates our MonitoringAccountDestination_STATUS from the provided source MonitoringAccountDestination_STATUS
func (destination *MonitoringAccountDestination_STATUS) AssignProperties_From_MonitoringAccountDestination_STATUS(source *storage.MonitoringAccountDestination_STATUS) error {

	// AccountId
	destination.AccountId = genruntime.ClonePointerToString(source.AccountId)

	// AccountResourceId
	destination.AccountResourceId = genruntime.ClonePointerToString(source.AccountResourceId)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// No error
	return nil
}

// AssignProperties_To_MonitoringAccountDestination_STATUS populates the provided destination MonitoringAccountDestination_STATUS from our MonitoringAccountDestination_STATUS
func (destination *MonitoringAccountDestination_STATUS) AssignProperties_To_MonitoringAccountDestination_STATUS(target *storage.MonitoringAccountDestination_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AccountId
	target.AccountId = genruntime.ClonePointerToString(destination.AccountId)

	// AccountResourceId
	target.AccountResourceId = genruntime.ClonePointerToString(destination.AccountResourceId)

	// Name
	target.Name = genruntime.ClonePointerToString(destination.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		target.PropertyBag = propertyBag
	} else {
		target.PropertyBag = nil
	}

	// No error
	return nil
}

// Definition of which performance counters will be collected and how they will be collected by this data collection
// rule.
// Collected from both Windows and Linux machines where the counter is present.
type PerfCounterDataSource struct {
	// CounterSpecifiers: A list of specifier names of the performance counters you want to collect.
	// Use a wildcard (*) to collect a counter for all instances.
	// To get a list of performance counters on Windows, run the command 'typeperf'.
	CounterSpecifiers []string `json:"counterSpecifiers,omitempty"`

	// Name: A friendly name for the data source.
	// This name should be unique across all data sources (regardless of type) within the data collection rule.
	Name *string `json:"name,omitempty"`

	// SamplingFrequencyInSeconds: The number of seconds between consecutive counter measurements (samples).
	SamplingFrequencyInSeconds *int `json:"samplingFrequencyInSeconds,omitempty"`

	// Streams: List of streams that this data source will be sent to.
	// A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent
	// to.
	Streams []PerfCounterDataSource_Streams `json:"streams,omitempty"`

	// TransformKql: The KQL query to transform the data source.
	TransformKql *string `json:"transformKql,omitempty"`
}

var _ genruntime.ARMTransformer = &PerfCounterDataSource{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (source *PerfCounterDataSource) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if source == nil {
		return nil, nil
	}
	result := &arm.PerfCounterDataSource{}

	// Set property "CounterSpecifiers":
	for _, item := range source.CounterSpecifiers {
		result.CounterSpecifiers = append(result.CounterSpecifiers, item)
	}

	// Set property "Name":
	if source.Name != nil {
		name := *source.Name
		result.Name = &name
	}

	// Set property "SamplingFrequencyInSeconds":
	if source.SamplingFrequencyInSeconds != nil {
		samplingFrequencyInSeconds := *source.SamplingFrequencyInSeconds
		result.SamplingFrequencyInSeconds = &samplingFrequencyInSeconds
	}

	// Set property "Streams":
	for _, item := range source.Streams {
		var temp string
		temp = string(item)
		result.Streams = append(result.Streams, arm.PerfCounterDataSource_Streams(temp))
	}

	// Set property "TransformKql":
	if source.TransformKql != nil {
		transformKql := *source.TransformKql
		result.TransformKql = &transformKql
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (source *PerfCounterDataSource) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PerfCounterDataSource{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (source *PerfCounterDataSource) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PerfCounterDataSource)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PerfCounterDataSource, got %T", armInput)
	}

	// Set property "CounterSpecifiers":
	for _, item := range typedInput.CounterSpecifiers {
		source.CounterSpecifiers = append(source.CounterSpecifiers, item)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		source.Name = &name
	}

	// Set property "SamplingFrequencyInSeconds":
	if typedInput.SamplingFrequencyInSeconds != nil {
		samplingFrequencyInSeconds := *typedInput.SamplingFrequencyInSeconds
		source.SamplingFrequencyInSeconds = &samplingFrequencyInSeconds
	}

	// Set property "Streams":
	for _, item := range typedInput.Streams {
		var temp string
		temp = string(item)
		source.Streams = append(source.Streams, PerfCounterDataSource_Streams(temp))
	}

	// Set property "TransformKql":
	if typedInput.TransformKql != nil {
		transformKql := *typedInput.TransformKql
		source.TransformKql = &transformKql
	}

	// No error
	return nil
}

// AssignProperties_From_PerfCounterDataSource populates our PerfCounterDataSource from the provided source PerfCounterDataSource
func (source *PerfCounterDataSource) AssignProperties_From_PerfCounterDataSource(origin *storage.PerfCounterDataSource) error {

	// CounterSpecifiers
	source.CounterSpecifiers = genruntime.CloneSliceOfString(origin.CounterSpecifiers)

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// SamplingFrequencyInSeconds
	source.SamplingFrequencyInSeconds = genruntime.ClonePointerToInt(origin.SamplingFrequencyInSeconds)

	// Streams
	if origin.Streams != nil {
		streamList := make([]PerfCounterDataSource_Streams, len(origin.Streams))
		for streamIndex, streamItem := range origin.Streams {
			// Shadow the loop variable to avoid aliasing
			streamItem := streamItem
			streamList[streamIndex] = genruntime.ToEnum(streamItem, perfCounterDataSource_Streams_Values)
		}
		source.Streams = streamList
	} else {
		source.Streams = nil
	}

	// TransformKql
	source.TransformKql = genruntime.ClonePointerToString(origin.TransformKql)

	// No error
	return nil
}

// AssignProperties_To_PerfCounterDataSource populates the provided destination PerfCounterDataSource from our PerfCounterDataSource
func (source *PerfCounterDataSource) AssignProperties_To_PerfCounterDataSource(destination *storage.PerfCounterDataSource) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CounterSpecifiers
	destination.CounterSpecifiers = genruntime.CloneSliceOfString(source.CounterSpecifiers)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// SamplingFrequencyInSeconds
	destination.SamplingFrequencyInSeconds = genruntime.ClonePointerToInt(source.SamplingFrequencyInSeconds)

	// Streams
	if source.Streams != nil {
		streamList := make([]string, len(source.Streams))
		for streamIndex, streamItem := range source.Streams {
			// Shadow the loop variable to avoid aliasing
			streamItem := streamItem
			streamList[streamIndex] = string(streamItem)
		}
		destination.Streams = streamList
	} else {
		destination.Streams = nil
	}

	// TransformKql
	destination.TransformKql = genruntime.ClonePointerToString(source.TransformKql)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_PerfCounterDataSource_STATUS populates our PerfCounterDataSource from the provided source PerfCounterDataSource_STATUS
func (source *PerfCounterDataSource) Initialize_From_PerfCounterDataSource_STATUS(origin *PerfCounterDataSource_STATUS) error {

	// CounterSpecifiers
	source.CounterSpecifiers = genruntime.CloneSliceOfString(origin.CounterSpecifiers)

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// SamplingFrequencyInSeconds
	source.SamplingFrequencyInSeconds = genruntime.ClonePointerToInt(origin.SamplingFrequencyInSeconds)

	// Streams
	if origin.Streams != nil {
		streamList := make([]PerfCounterDataSource_Streams, len(origin.Streams))
		for streamIndex, streamItem := range origin.Streams {
			// Shadow the loop variable to avoid aliasing
			streamItem := streamItem
			stream := genruntime.ToEnum(string(streamItem), perfCounterDataSource_Streams_Values)
			streamList[streamIndex] = stream
		}
		source.Streams = streamList
	} else {
		source.Streams = nil
	}

	// TransformKql
	source.TransformKql = genruntime.ClonePointerToString(origin.TransformKql)

	// No error
	return nil
}

// Definition of which performance counters will be collected and how they will be collected by this data collection
// rule.
// Collected from both Windows and Linux machines where the counter is present.
type PerfCounterDataSource_STATUS struct {
	// CounterSpecifiers: A list of specifier names of the performance counters you want to collect.
	// Use a wildcard (*) to collect a counter for all instances.
	// To get a list of performance counters on Windows, run the command 'typeperf'.
	CounterSpecifiers []string `json:"counterSpecifiers,omitempty"`

	// Name: A friendly name for the data source.
	// This name should be unique across all data sources (regardless of type) within the data collection rule.
	Name *string `json:"name,omitempty"`

	// SamplingFrequencyInSeconds: The number of seconds between consecutive counter measurements (samples).
	SamplingFrequencyInSeconds *int `json:"samplingFrequencyInSeconds,omitempty"`

	// Streams: List of streams that this data source will be sent to.
	// A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent
	// to.
	Streams []PerfCounterDataSource_Streams_STATUS `json:"streams,omitempty"`

	// TransformKql: The KQL query to transform the data source.
	TransformKql *string `json:"transformKql,omitempty"`
}

var _ genruntime.FromARMConverter = &PerfCounterDataSource_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (source *PerfCounterDataSource_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PerfCounterDataSource_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (source *PerfCounterDataSource_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PerfCounterDataSource_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PerfCounterDataSource_STATUS, got %T", armInput)
	}

	// Set property "CounterSpecifiers":
	for _, item := range typedInput.CounterSpecifiers {
		source.CounterSpecifiers = append(source.CounterSpecifiers, item)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		source.Name = &name
	}

	// Set property "SamplingFrequencyInSeconds":
	if typedInput.SamplingFrequencyInSeconds != nil {
		samplingFrequencyInSeconds := *typedInput.SamplingFrequencyInSeconds
		source.SamplingFrequencyInSeconds = &samplingFrequencyInSeconds
	}

	// Set property "Streams":
	for _, item := range typedInput.Streams {
		var temp string
		temp = string(item)
		source.Streams = append(source.Streams, PerfCounterDataSource_Streams_STATUS(temp))
	}

	// Set property "TransformKql":
	if typedInput.TransformKql != nil {
		transformKql := *typedInput.TransformKql
		source.TransformKql = &transformKql
	}

	// No error
	return nil
}

// AssignProperties_From_PerfCounterDataSource_STATUS populates our PerfCounterDataSource_STATUS from the provided source PerfCounterDataSource_STATUS
func (source *PerfCounterDataSource_STATUS) AssignProperties_From_PerfCounterDataSource_STATUS(origin *storage.PerfCounterDataSource_STATUS) error {

	// CounterSpecifiers
	source.CounterSpecifiers = genruntime.CloneSliceOfString(origin.CounterSpecifiers)

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// SamplingFrequencyInSeconds
	source.SamplingFrequencyInSeconds = genruntime.ClonePointerToInt(origin.SamplingFrequencyInSeconds)

	// Streams
	if origin.Streams != nil {
		streamList := make([]PerfCounterDataSource_Streams_STATUS, len(origin.Streams))
		for streamIndex, streamItem := range origin.Streams {
			// Shadow the loop variable to avoid aliasing
			streamItem := streamItem
			streamList[streamIndex] = genruntime.ToEnum(streamItem, perfCounterDataSource_Streams_STATUS_Values)
		}
		source.Streams = streamList
	} else {
		source.Streams = nil
	}

	// TransformKql
	source.TransformKql = genruntime.ClonePointerToString(origin.TransformKql)

	// No error
	return nil
}

// AssignProperties_To_PerfCounterDataSource_STATUS populates the provided destination PerfCounterDataSource_STATUS from our PerfCounterDataSource_STATUS
func (source *PerfCounterDataSource_STATUS) AssignProperties_To_PerfCounterDataSource_STATUS(destination *storage.PerfCounterDataSource_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CounterSpecifiers
	destination.CounterSpecifiers = genruntime.CloneSliceOfString(source.CounterSpecifiers)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// SamplingFrequencyInSeconds
	destination.SamplingFrequencyInSeconds = genruntime.ClonePointerToInt(source.SamplingFrequencyInSeconds)

	// Streams
	if source.Streams != nil {
		streamList := make([]string, len(source.Streams))
		for streamIndex, streamItem := range source.Streams {
			// Shadow the loop variable to avoid aliasing
			streamItem := streamItem
			streamList[streamIndex] = string(streamItem)
		}
		destination.Streams = streamList
	} else {
		destination.Streams = nil
	}

	// TransformKql
	destination.TransformKql = genruntime.ClonePointerToString(source.TransformKql)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Definition of platform telemetry data source configuration
type PlatformTelemetryDataSource struct {
	// Name: A friendly name for the data source.
	// This name should be unique across all data sources (regardless of type) within the data collection rule.
	Name *string `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Streams: List of platform telemetry streams to collect
	Streams []string `json:"streams,omitempty"`
}

var _ genruntime.ARMTransformer = &PlatformTelemetryDataSource{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (source *PlatformTelemetryDataSource) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if source == nil {
		return nil, nil
	}
	result := &arm.PlatformTelemetryDataSource{}

	// Set property "Name":
	if source.Name != nil {
		name := *source.Name
		result.Name = &name
	}

	// Set property "Streams":
	for _, item := range source.Streams {
		result.Streams = append(result.Streams, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (source *PlatformTelemetryDataSource) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PlatformTelemetryDataSource{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (source *PlatformTelemetryDataSource) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PlatformTelemetryDataSource)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PlatformTelemetryDataSource, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		source.Name = &name
	}

	// Set property "Streams":
	for _, item := range typedInput.Streams {
		source.Streams = append(source.Streams, item)
	}

	// No error
	return nil
}

// AssignProperties_From_PlatformTelemetryDataSource populates our PlatformTelemetryDataSource from the provided source PlatformTelemetryDataSource
func (source *PlatformTelemetryDataSource) AssignProperties_From_PlatformTelemetryDataSource(origin *storage.PlatformTelemetryDataSource) error {

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// Streams
	source.Streams = genruntime.CloneSliceOfString(origin.Streams)

	// No error
	return nil
}

// AssignProperties_To_PlatformTelemetryDataSource populates the provided destination PlatformTelemetryDataSource from our PlatformTelemetryDataSource
func (source *PlatformTelemetryDataSource) AssignProperties_To_PlatformTelemetryDataSource(destination *storage.PlatformTelemetryDataSource) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// Streams
	destination.Streams = genruntime.CloneSliceOfString(source.Streams)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_PlatformTelemetryDataSource_STATUS populates our PlatformTelemetryDataSource from the provided source PlatformTelemetryDataSource_STATUS
func (source *PlatformTelemetryDataSource) Initialize_From_PlatformTelemetryDataSource_STATUS(origin *PlatformTelemetryDataSource_STATUS) error {

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// Streams
	source.Streams = genruntime.CloneSliceOfString(origin.Streams)

	// No error
	return nil
}

// Definition of platform telemetry data source configuration
type PlatformTelemetryDataSource_STATUS struct {
	// Name: A friendly name for the data source.
	// This name should be unique across all data sources (regardless of type) within the data collection rule.
	Name *string `json:"name,omitempty"`

	// Streams: List of platform telemetry streams to collect
	Streams []string `json:"streams,omitempty"`
}

var _ genruntime.FromARMConverter = &PlatformTelemetryDataSource_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (source *PlatformTelemetryDataSource_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PlatformTelemetryDataSource_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (source *PlatformTelemetryDataSource_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PlatformTelemetryDataSource_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PlatformTelemetryDataSource_STATUS, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		source.Name = &name
	}

	// Set property "Streams":
	for _, item := range typedInput.Streams {
		source.Streams = append(source.Streams, item)
	}

	// No error
	return nil
}

// AssignProperties_From_PlatformTelemetryDataSource_STATUS populates our PlatformTelemetryDataSource_STATUS from the provided source PlatformTelemetryDataSource_STATUS
func (source *PlatformTelemetryDataSource_STATUS) AssignProperties_From_PlatformTelemetryDataSource_STATUS(origin *storage.PlatformTelemetryDataSource_STATUS) error {

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// Streams
	source.Streams = genruntime.CloneSliceOfString(origin.Streams)

	// No error
	return nil
}

// AssignProperties_To_PlatformTelemetryDataSource_STATUS populates the provided destination PlatformTelemetryDataSource_STATUS from our PlatformTelemetryDataSource_STATUS
func (source *PlatformTelemetryDataSource_STATUS) AssignProperties_To_PlatformTelemetryDataSource_STATUS(destination *storage.PlatformTelemetryDataSource_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// Streams
	destination.Streams = genruntime.CloneSliceOfString(source.Streams)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Definition of Prometheus metrics forwarding configuration.
type PrometheusForwarderDataSource struct {
	// LabelIncludeFilter: The list of label inclusion filters in the form of label "name-value" pairs.
	// Currently only one label is supported: 'microsoft_metrics_include_label'.
	// Label values are matched case-insensitively.
	LabelIncludeFilter map[string]string `json:"labelIncludeFilter,omitempty"`

	// Name: A friendly name for the data source.
	// This name should be unique across all data sources (regardless of type) within the data collection rule.
	Name *string `json:"name,omitempty"`

	// Streams: List of streams that this data source will be sent to.
	Streams []PrometheusForwarderDataSource_Streams `json:"streams,omitempty"`
}

var _ genruntime.ARMTransformer = &PrometheusForwarderDataSource{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (source *PrometheusForwarderDataSource) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if source == nil {
		return nil, nil
	}
	result := &arm.PrometheusForwarderDataSource{}

	// Set property "LabelIncludeFilter":
	if source.LabelIncludeFilter != nil {
		result.LabelIncludeFilter = make(map[string]string, len(source.LabelIncludeFilter))
		for key, value := range source.LabelIncludeFilter {
			result.LabelIncludeFilter[key] = value
		}
	}

	// Set property "Name":
	if source.Name != nil {
		name := *source.Name
		result.Name = &name
	}

	// Set property "Streams":
	for _, item := range source.Streams {
		var temp string
		temp = string(item)
		result.Streams = append(result.Streams, arm.PrometheusForwarderDataSource_Streams(temp))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (source *PrometheusForwarderDataSource) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PrometheusForwarderDataSource{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (source *PrometheusForwarderDataSource) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PrometheusForwarderDataSource)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PrometheusForwarderDataSource, got %T", armInput)
	}

	// Set property "LabelIncludeFilter":
	if typedInput.LabelIncludeFilter != nil {
		source.LabelIncludeFilter = make(map[string]string, len(typedInput.LabelIncludeFilter))
		for key, value := range typedInput.LabelIncludeFilter {
			source.LabelIncludeFilter[key] = value
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		source.Name = &name
	}

	// Set property "Streams":
	for _, item := range typedInput.Streams {
		var temp string
		temp = string(item)
		source.Streams = append(source.Streams, PrometheusForwarderDataSource_Streams(temp))
	}

	// No error
	return nil
}

// AssignProperties_From_PrometheusForwarderDataSource populates our PrometheusForwarderDataSource from the provided source PrometheusForwarderDataSource
func (source *PrometheusForwarderDataSource) AssignProperties_From_PrometheusForwarderDataSource(origin *storage.PrometheusForwarderDataSource) error {

	// LabelIncludeFilter
	source.LabelIncludeFilter = genruntime.CloneMapOfStringToString(origin.LabelIncludeFilter)

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// Streams
	if origin.Streams != nil {
		streamList := make([]PrometheusForwarderDataSource_Streams, len(origin.Streams))
		for streamIndex, streamItem := range origin.Streams {
			// Shadow the loop variable to avoid aliasing
			streamItem := streamItem
			streamList[streamIndex] = genruntime.ToEnum(streamItem, prometheusForwarderDataSource_Streams_Values)
		}
		source.Streams = streamList
	} else {
		source.Streams = nil
	}

	// No error
	return nil
}

// AssignProperties_To_PrometheusForwarderDataSource populates the provided destination PrometheusForwarderDataSource from our PrometheusForwarderDataSource
func (source *PrometheusForwarderDataSource) AssignProperties_To_PrometheusForwarderDataSource(destination *storage.PrometheusForwarderDataSource) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// LabelIncludeFilter
	destination.LabelIncludeFilter = genruntime.CloneMapOfStringToString(source.LabelIncludeFilter)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// Streams
	if source.Streams != nil {
		streamList := make([]string, len(source.Streams))
		for streamIndex, streamItem := range source.Streams {
			// Shadow the loop variable to avoid aliasing
			streamItem := streamItem
			streamList[streamIndex] = string(streamItem)
		}
		destination.Streams = streamList
	} else {
		destination.Streams = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_PrometheusForwarderDataSource_STATUS populates our PrometheusForwarderDataSource from the provided source PrometheusForwarderDataSource_STATUS
func (source *PrometheusForwarderDataSource) Initialize_From_PrometheusForwarderDataSource_STATUS(origin *PrometheusForwarderDataSource_STATUS) error {

	// LabelIncludeFilter
	source.LabelIncludeFilter = genruntime.CloneMapOfStringToString(origin.LabelIncludeFilter)

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// Streams
	if origin.Streams != nil {
		streamList := make([]PrometheusForwarderDataSource_Streams, len(origin.Streams))
		for streamIndex, streamItem := range origin.Streams {
			// Shadow the loop variable to avoid aliasing
			streamItem := streamItem
			stream := genruntime.ToEnum(string(streamItem), prometheusForwarderDataSource_Streams_Values)
			streamList[streamIndex] = stream
		}
		source.Streams = streamList
	} else {
		source.Streams = nil
	}

	// No error
	return nil
}

// Definition of Prometheus metrics forwarding configuration.
type PrometheusForwarderDataSource_STATUS struct {
	// LabelIncludeFilter: The list of label inclusion filters in the form of label "name-value" pairs.
	// Currently only one label is supported: 'microsoft_metrics_include_label'.
	// Label values are matched case-insensitively.
	LabelIncludeFilter map[string]string `json:"labelIncludeFilter,omitempty"`

	// Name: A friendly name for the data source.
	// This name should be unique across all data sources (regardless of type) within the data collection rule.
	Name *string `json:"name,omitempty"`

	// Streams: List of streams that this data source will be sent to.
	Streams []PrometheusForwarderDataSource_Streams_STATUS `json:"streams,omitempty"`
}

var _ genruntime.FromARMConverter = &PrometheusForwarderDataSource_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (source *PrometheusForwarderDataSource_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PrometheusForwarderDataSource_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (source *PrometheusForwarderDataSource_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PrometheusForwarderDataSource_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PrometheusForwarderDataSource_STATUS, got %T", armInput)
	}

	// Set property "LabelIncludeFilter":
	if typedInput.LabelIncludeFilter != nil {
		source.LabelIncludeFilter = make(map[string]string, len(typedInput.LabelIncludeFilter))
		for key, value := range typedInput.LabelIncludeFilter {
			source.LabelIncludeFilter[key] = value
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		source.Name = &name
	}

	// Set property "Streams":
	for _, item := range typedInput.Streams {
		var temp string
		temp = string(item)
		source.Streams = append(source.Streams, PrometheusForwarderDataSource_Streams_STATUS(temp))
	}

	// No error
	return nil
}

// AssignProperties_From_PrometheusForwarderDataSource_STATUS populates our PrometheusForwarderDataSource_STATUS from the provided source PrometheusForwarderDataSource_STATUS
func (source *PrometheusForwarderDataSource_STATUS) AssignProperties_From_PrometheusForwarderDataSource_STATUS(origin *storage.PrometheusForwarderDataSource_STATUS) error {

	// LabelIncludeFilter
	source.LabelIncludeFilter = genruntime.CloneMapOfStringToString(origin.LabelIncludeFilter)

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// Streams
	if origin.Streams != nil {
		streamList := make([]PrometheusForwarderDataSource_Streams_STATUS, len(origin.Streams))
		for streamIndex, streamItem := range origin.Streams {
			// Shadow the loop variable to avoid aliasing
			streamItem := streamItem
			streamList[streamIndex] = genruntime.ToEnum(streamItem, prometheusForwarderDataSource_Streams_STATUS_Values)
		}
		source.Streams = streamList
	} else {
		source.Streams = nil
	}

	// No error
	return nil
}

// AssignProperties_To_PrometheusForwarderDataSource_STATUS populates the provided destination PrometheusForwarderDataSource_STATUS from our PrometheusForwarderDataSource_STATUS
func (source *PrometheusForwarderDataSource_STATUS) AssignProperties_To_PrometheusForwarderDataSource_STATUS(destination *storage.PrometheusForwarderDataSource_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// LabelIncludeFilter
	destination.LabelIncludeFilter = genruntime.CloneMapOfStringToString(source.LabelIncludeFilter)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// Streams
	if source.Streams != nil {
		streamList := make([]string, len(source.Streams))
		for streamIndex, streamItem := range source.Streams {
			// Shadow the loop variable to avoid aliasing
			streamItem := streamItem
			streamList[streamIndex] = string(streamItem)
		}
		destination.Streams = streamList
	} else {
		destination.Streams = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type StorageBlobDestination struct {
	// ContainerName: The container name of the Storage Blob.
	ContainerName *string `json:"containerName,omitempty"`

	// Name: A friendly name for the destination.
	// This name should be unique across all destinations (regardless of type) within the data collection rule.
	Name *string `json:"name,omitempty"`

	// StorageAccountResourceReference: The resource ID of the storage account.
	StorageAccountResourceReference *genruntime.ResourceReference `armReference:"StorageAccountResourceId" json:"storageAccountResourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &StorageBlobDestination{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (destination *StorageBlobDestination) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if destination == nil {
		return nil, nil
	}
	result := &arm.StorageBlobDestination{}

	// Set property "ContainerName":
	if destination.ContainerName != nil {
		containerName := *destination.ContainerName
		result.ContainerName = &containerName
	}

	// Set property "Name":
	if destination.Name != nil {
		name := *destination.Name
		result.Name = &name
	}

	// Set property "StorageAccountResourceId":
	if destination.StorageAccountResourceReference != nil {
		storageAccountResourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*destination.StorageAccountResourceReference)
		if err != nil {
			return nil, err
		}
		storageAccountResourceReference := storageAccountResourceReferenceARMID
		result.StorageAccountResourceId = &storageAccountResourceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (destination *StorageBlobDestination) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.StorageBlobDestination{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (destination *StorageBlobDestination) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.StorageBlobDestination)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.StorageBlobDestination, got %T", armInput)
	}

	// Set property "ContainerName":
	if typedInput.ContainerName != nil {
		containerName := *typedInput.ContainerName
		destination.ContainerName = &containerName
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		destination.Name = &name
	}

	// no assignment for property "StorageAccountResourceReference"

	// No error
	return nil
}

// AssignProperties_From_StorageBlobDestination populates our StorageBlobDestination from the provided source StorageBlobDestination
func (destination *StorageBlobDestination) AssignProperties_From_StorageBlobDestination(source *storage.StorageBlobDestination) error {

	// ContainerName
	destination.ContainerName = genruntime.ClonePointerToString(source.ContainerName)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// StorageAccountResourceReference
	if source.StorageAccountResourceReference != nil {
		storageAccountResourceReference := source.StorageAccountResourceReference.Copy()
		destination.StorageAccountResourceReference = &storageAccountResourceReference
	} else {
		destination.StorageAccountResourceReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_StorageBlobDestination populates the provided destination StorageBlobDestination from our StorageBlobDestination
func (destination *StorageBlobDestination) AssignProperties_To_StorageBlobDestination(target *storage.StorageBlobDestination) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ContainerName
	target.ContainerName = genruntime.ClonePointerToString(destination.ContainerName)

	// Name
	target.Name = genruntime.ClonePointerToString(destination.Name)

	// StorageAccountResourceReference
	if destination.StorageAccountResourceReference != nil {
		storageAccountResourceReference := destination.StorageAccountResourceReference.Copy()
		target.StorageAccountResourceReference = &storageAccountResourceReference
	} else {
		target.StorageAccountResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		target.PropertyBag = propertyBag
	} else {
		target.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_StorageBlobDestination_STATUS populates our StorageBlobDestination from the provided source StorageBlobDestination_STATUS
func (destination *StorageBlobDestination) Initialize_From_StorageBlobDestination_STATUS(source *StorageBlobDestination_STATUS) error {

	// ContainerName
	destination.ContainerName = genruntime.ClonePointerToString(source.ContainerName)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// StorageAccountResourceReference
	if source.StorageAccountResourceId != nil {
		storageAccountResourceReference := genruntime.CreateResourceReferenceFromARMID(*source.StorageAccountResourceId)
		destination.StorageAccountResourceReference = &storageAccountResourceReference
	} else {
		destination.StorageAccountResourceReference = nil
	}

	// No error
	return nil
}

type StorageBlobDestination_STATUS struct {
	// ContainerName: The container name of the Storage Blob.
	ContainerName *string `json:"containerName,omitempty"`

	// Name: A friendly name for the destination.
	// This name should be unique across all destinations (regardless of type) within the data collection rule.
	Name *string `json:"name,omitempty"`

	// StorageAccountResourceId: The resource ID of the storage account.
	StorageAccountResourceId *string `json:"storageAccountResourceId,omitempty"`
}

var _ genruntime.FromARMConverter = &StorageBlobDestination_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (destination *StorageBlobDestination_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.StorageBlobDestination_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (destination *StorageBlobDestination_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.StorageBlobDestination_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.StorageBlobDestination_STATUS, got %T", armInput)
	}

	// Set property "ContainerName":
	if typedInput.ContainerName != nil {
		containerName := *typedInput.ContainerName
		destination.ContainerName = &containerName
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		destination.Name = &name
	}

	// Set property "StorageAccountResourceId":
	if typedInput.StorageAccountResourceId != nil {
		storageAccountResourceId := *typedInput.StorageAccountResourceId
		destination.StorageAccountResourceId = &storageAccountResourceId
	}

	// No error
	return nil
}

// AssignProperties_From_StorageBlobDestination_STATUS populates our StorageBlobDestination_STATUS from the provided source StorageBlobDestination_STATUS
func (destination *StorageBlobDestination_STATUS) AssignProperties_From_StorageBlobDestination_STATUS(source *storage.StorageBlobDestination_STATUS) error {

	// ContainerName
	destination.ContainerName = genruntime.ClonePointerToString(source.ContainerName)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// StorageAccountResourceId
	destination.StorageAccountResourceId = genruntime.ClonePointerToString(source.StorageAccountResourceId)

	// No error
	return nil
}

// AssignProperties_To_StorageBlobDestination_STATUS populates the provided destination StorageBlobDestination_STATUS from our StorageBlobDestination_STATUS
func (destination *StorageBlobDestination_STATUS) AssignProperties_To_StorageBlobDestination_STATUS(target *storage.StorageBlobDestination_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ContainerName
	target.ContainerName = genruntime.ClonePointerToString(destination.ContainerName)

	// Name
	target.Name = genruntime.ClonePointerToString(destination.Name)

	// StorageAccountResourceId
	target.StorageAccountResourceId = genruntime.ClonePointerToString(destination.StorageAccountResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		target.PropertyBag = propertyBag
	} else {
		target.PropertyBag = nil
	}

	// No error
	return nil
}

type StorageTableDestination struct {
	// Name: A friendly name for the destination.
	// This name should be unique across all destinations (regardless of type) within the data collection rule.
	Name *string `json:"name,omitempty"`

	// StorageAccountResourceReference: The resource ID of the storage account.
	StorageAccountResourceReference *genruntime.ResourceReference `armReference:"StorageAccountResourceId" json:"storageAccountResourceReference,omitempty"`

	// TableName: The name of the Storage Table.
	TableName *string `json:"tableName,omitempty"`
}

var _ genruntime.ARMTransformer = &StorageTableDestination{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (destination *StorageTableDestination) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if destination == nil {
		return nil, nil
	}
	result := &arm.StorageTableDestination{}

	// Set property "Name":
	if destination.Name != nil {
		name := *destination.Name
		result.Name = &name
	}

	// Set property "StorageAccountResourceId":
	if destination.StorageAccountResourceReference != nil {
		storageAccountResourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*destination.StorageAccountResourceReference)
		if err != nil {
			return nil, err
		}
		storageAccountResourceReference := storageAccountResourceReferenceARMID
		result.StorageAccountResourceId = &storageAccountResourceReference
	}

	// Set property "TableName":
	if destination.TableName != nil {
		tableName := *destination.TableName
		result.TableName = &tableName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (destination *StorageTableDestination) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.StorageTableDestination{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (destination *StorageTableDestination) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.StorageTableDestination)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.StorageTableDestination, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		destination.Name = &name
	}

	// no assignment for property "StorageAccountResourceReference"

	// Set property "TableName":
	if typedInput.TableName != nil {
		tableName := *typedInput.TableName
		destination.TableName = &tableName
	}

	// No error
	return nil
}

// AssignProperties_From_StorageTableDestination populates our StorageTableDestination from the provided source StorageTableDestination
func (destination *StorageTableDestination) AssignProperties_From_StorageTableDestination(source *storage.StorageTableDestination) error {

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// StorageAccountResourceReference
	if source.StorageAccountResourceReference != nil {
		storageAccountResourceReference := source.StorageAccountResourceReference.Copy()
		destination.StorageAccountResourceReference = &storageAccountResourceReference
	} else {
		destination.StorageAccountResourceReference = nil
	}

	// TableName
	destination.TableName = genruntime.ClonePointerToString(source.TableName)

	// No error
	return nil
}

// AssignProperties_To_StorageTableDestination populates the provided destination StorageTableDestination from our StorageTableDestination
func (destination *StorageTableDestination) AssignProperties_To_StorageTableDestination(target *storage.StorageTableDestination) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	target.Name = genruntime.ClonePointerToString(destination.Name)

	// StorageAccountResourceReference
	if destination.StorageAccountResourceReference != nil {
		storageAccountResourceReference := destination.StorageAccountResourceReference.Copy()
		target.StorageAccountResourceReference = &storageAccountResourceReference
	} else {
		target.StorageAccountResourceReference = nil
	}

	// TableName
	target.TableName = genruntime.ClonePointerToString(destination.TableName)

	// Update the property bag
	if len(propertyBag) > 0 {
		target.PropertyBag = propertyBag
	} else {
		target.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_StorageTableDestination_STATUS populates our StorageTableDestination from the provided source StorageTableDestination_STATUS
func (destination *StorageTableDestination) Initialize_From_StorageTableDestination_STATUS(source *StorageTableDestination_STATUS) error {

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// StorageAccountResourceReference
	if source.StorageAccountResourceId != nil {
		storageAccountResourceReference := genruntime.CreateResourceReferenceFromARMID(*source.StorageAccountResourceId)
		destination.StorageAccountResourceReference = &storageAccountResourceReference
	} else {
		destination.StorageAccountResourceReference = nil
	}

	// TableName
	destination.TableName = genruntime.ClonePointerToString(source.TableName)

	// No error
	return nil
}

type StorageTableDestination_STATUS struct {
	// Name: A friendly name for the destination.
	// This name should be unique across all destinations (regardless of type) within the data collection rule.
	Name *string `json:"name,omitempty"`

	// StorageAccountResourceId: The resource ID of the storage account.
	StorageAccountResourceId *string `json:"storageAccountResourceId,omitempty"`

	// TableName: The name of the Storage Table.
	TableName *string `json:"tableName,omitempty"`
}

var _ genruntime.FromARMConverter = &StorageTableDestination_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (destination *StorageTableDestination_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.StorageTableDestination_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (destination *StorageTableDestination_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.StorageTableDestination_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.StorageTableDestination_STATUS, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		destination.Name = &name
	}

	// Set property "StorageAccountResourceId":
	if typedInput.StorageAccountResourceId != nil {
		storageAccountResourceId := *typedInput.StorageAccountResourceId
		destination.StorageAccountResourceId = &storageAccountResourceId
	}

	// Set property "TableName":
	if typedInput.TableName != nil {
		tableName := *typedInput.TableName
		destination.TableName = &tableName
	}

	// No error
	return nil
}

// AssignProperties_From_StorageTableDestination_STATUS populates our StorageTableDestination_STATUS from the provided source StorageTableDestination_STATUS
func (destination *StorageTableDestination_STATUS) AssignProperties_From_StorageTableDestination_STATUS(source *storage.StorageTableDestination_STATUS) error {

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// StorageAccountResourceId
	destination.StorageAccountResourceId = genruntime.ClonePointerToString(source.StorageAccountResourceId)

	// TableName
	destination.TableName = genruntime.ClonePointerToString(source.TableName)

	// No error
	return nil
}

// AssignProperties_To_StorageTableDestination_STATUS populates the provided destination StorageTableDestination_STATUS from our StorageTableDestination_STATUS
func (destination *StorageTableDestination_STATUS) AssignProperties_To_StorageTableDestination_STATUS(target *storage.StorageTableDestination_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	target.Name = genruntime.ClonePointerToString(destination.Name)

	// StorageAccountResourceId
	target.StorageAccountResourceId = genruntime.ClonePointerToString(destination.StorageAccountResourceId)

	// TableName
	target.TableName = genruntime.ClonePointerToString(destination.TableName)

	// Update the property bag
	if len(propertyBag) > 0 {
		target.PropertyBag = propertyBag
	} else {
		target.PropertyBag = nil
	}

	// No error
	return nil
}

// Definition of which syslog data will be collected and how it will be collected.
// Only collected from Linux machines.
type SyslogDataSource struct {
	// FacilityNames: The list of facility names.
	FacilityNames []SyslogDataSource_FacilityNames `json:"facilityNames,omitempty"`

	// LogLevels: The log levels to collect.
	LogLevels []SyslogDataSource_LogLevels `json:"logLevels,omitempty"`

	// Name: A friendly name for the data source.
	// This name should be unique across all data sources (regardless of type) within the data collection rule.
	Name *string `json:"name,omitempty"`

	// Streams: List of streams that this data source will be sent to.
	// A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent
	// to.
	Streams []SyslogDataSource_Streams `json:"streams,omitempty"`

	// TransformKql: The KQL query to transform the data source.
	TransformKql *string `json:"transformKql,omitempty"`
}

var _ genruntime.ARMTransformer = &SyslogDataSource{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (source *SyslogDataSource) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if source == nil {
		return nil, nil
	}
	result := &arm.SyslogDataSource{}

	// Set property "FacilityNames":
	for _, item := range source.FacilityNames {
		var temp string
		temp = string(item)
		result.FacilityNames = append(result.FacilityNames, arm.SyslogDataSource_FacilityNames(temp))
	}

	// Set property "LogLevels":
	for _, item := range source.LogLevels {
		var temp string
		temp = string(item)
		result.LogLevels = append(result.LogLevels, arm.SyslogDataSource_LogLevels(temp))
	}

	// Set property "Name":
	if source.Name != nil {
		name := *source.Name
		result.Name = &name
	}

	// Set property "Streams":
	for _, item := range source.Streams {
		var temp string
		temp = string(item)
		result.Streams = append(result.Streams, arm.SyslogDataSource_Streams(temp))
	}

	// Set property "TransformKql":
	if source.TransformKql != nil {
		transformKql := *source.TransformKql
		result.TransformKql = &transformKql
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (source *SyslogDataSource) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SyslogDataSource{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (source *SyslogDataSource) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SyslogDataSource)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SyslogDataSource, got %T", armInput)
	}

	// Set property "FacilityNames":
	for _, item := range typedInput.FacilityNames {
		var temp string
		temp = string(item)
		source.FacilityNames = append(source.FacilityNames, SyslogDataSource_FacilityNames(temp))
	}

	// Set property "LogLevels":
	for _, item := range typedInput.LogLevels {
		var temp string
		temp = string(item)
		source.LogLevels = append(source.LogLevels, SyslogDataSource_LogLevels(temp))
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		source.Name = &name
	}

	// Set property "Streams":
	for _, item := range typedInput.Streams {
		var temp string
		temp = string(item)
		source.Streams = append(source.Streams, SyslogDataSource_Streams(temp))
	}

	// Set property "TransformKql":
	if typedInput.TransformKql != nil {
		transformKql := *typedInput.TransformKql
		source.TransformKql = &transformKql
	}

	// No error
	return nil
}

// AssignProperties_From_SyslogDataSource populates our SyslogDataSource from the provided source SyslogDataSource
func (source *SyslogDataSource) AssignProperties_From_SyslogDataSource(origin *storage.SyslogDataSource) error {

	// FacilityNames
	if origin.FacilityNames != nil {
		facilityNameList := make([]SyslogDataSource_FacilityNames, len(origin.FacilityNames))
		for facilityNameIndex, facilityNameItem := range origin.FacilityNames {
			// Shadow the loop variable to avoid aliasing
			facilityNameItem := facilityNameItem
			facilityNameList[facilityNameIndex] = genruntime.ToEnum(facilityNameItem, syslogDataSource_FacilityNames_Values)
		}
		source.FacilityNames = facilityNameList
	} else {
		source.FacilityNames = nil
	}

	// LogLevels
	if origin.LogLevels != nil {
		logLevelList := make([]SyslogDataSource_LogLevels, len(origin.LogLevels))
		for logLevelIndex, logLevelItem := range origin.LogLevels {
			// Shadow the loop variable to avoid aliasing
			logLevelItem := logLevelItem
			logLevelList[logLevelIndex] = genruntime.ToEnum(logLevelItem, syslogDataSource_LogLevels_Values)
		}
		source.LogLevels = logLevelList
	} else {
		source.LogLevels = nil
	}

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// Streams
	if origin.Streams != nil {
		streamList := make([]SyslogDataSource_Streams, len(origin.Streams))
		for streamIndex, streamItem := range origin.Streams {
			// Shadow the loop variable to avoid aliasing
			streamItem := streamItem
			streamList[streamIndex] = genruntime.ToEnum(streamItem, syslogDataSource_Streams_Values)
		}
		source.Streams = streamList
	} else {
		source.Streams = nil
	}

	// TransformKql
	source.TransformKql = genruntime.ClonePointerToString(origin.TransformKql)

	// No error
	return nil
}

// AssignProperties_To_SyslogDataSource populates the provided destination SyslogDataSource from our SyslogDataSource
func (source *SyslogDataSource) AssignProperties_To_SyslogDataSource(destination *storage.SyslogDataSource) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// FacilityNames
	if source.FacilityNames != nil {
		facilityNameList := make([]string, len(source.FacilityNames))
		for facilityNameIndex, facilityNameItem := range source.FacilityNames {
			// Shadow the loop variable to avoid aliasing
			facilityNameItem := facilityNameItem
			facilityNameList[facilityNameIndex] = string(facilityNameItem)
		}
		destination.FacilityNames = facilityNameList
	} else {
		destination.FacilityNames = nil
	}

	// LogLevels
	if source.LogLevels != nil {
		logLevelList := make([]string, len(source.LogLevels))
		for logLevelIndex, logLevelItem := range source.LogLevels {
			// Shadow the loop variable to avoid aliasing
			logLevelItem := logLevelItem
			logLevelList[logLevelIndex] = string(logLevelItem)
		}
		destination.LogLevels = logLevelList
	} else {
		destination.LogLevels = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// Streams
	if source.Streams != nil {
		streamList := make([]string, len(source.Streams))
		for streamIndex, streamItem := range source.Streams {
			// Shadow the loop variable to avoid aliasing
			streamItem := streamItem
			streamList[streamIndex] = string(streamItem)
		}
		destination.Streams = streamList
	} else {
		destination.Streams = nil
	}

	// TransformKql
	destination.TransformKql = genruntime.ClonePointerToString(source.TransformKql)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_SyslogDataSource_STATUS populates our SyslogDataSource from the provided source SyslogDataSource_STATUS
func (source *SyslogDataSource) Initialize_From_SyslogDataSource_STATUS(origin *SyslogDataSource_STATUS) error {

	// FacilityNames
	if origin.FacilityNames != nil {
		facilityNameList := make([]SyslogDataSource_FacilityNames, len(origin.FacilityNames))
		for facilityNameIndex, facilityNameItem := range origin.FacilityNames {
			// Shadow the loop variable to avoid aliasing
			facilityNameItem := facilityNameItem
			facilityName := genruntime.ToEnum(string(facilityNameItem), syslogDataSource_FacilityNames_Values)
			facilityNameList[facilityNameIndex] = facilityName
		}
		source.FacilityNames = facilityNameList
	} else {
		source.FacilityNames = nil
	}

	// LogLevels
	if origin.LogLevels != nil {
		logLevelList := make([]SyslogDataSource_LogLevels, len(origin.LogLevels))
		for logLevelIndex, logLevelItem := range origin.LogLevels {
			// Shadow the loop variable to avoid aliasing
			logLevelItem := logLevelItem
			logLevel := genruntime.ToEnum(string(logLevelItem), syslogDataSource_LogLevels_Values)
			logLevelList[logLevelIndex] = logLevel
		}
		source.LogLevels = logLevelList
	} else {
		source.LogLevels = nil
	}

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// Streams
	if origin.Streams != nil {
		streamList := make([]SyslogDataSource_Streams, len(origin.Streams))
		for streamIndex, streamItem := range origin.Streams {
			// Shadow the loop variable to avoid aliasing
			streamItem := streamItem
			stream := genruntime.ToEnum(string(streamItem), syslogDataSource_Streams_Values)
			streamList[streamIndex] = stream
		}
		source.Streams = streamList
	} else {
		source.Streams = nil
	}

	// TransformKql
	source.TransformKql = genruntime.ClonePointerToString(origin.TransformKql)

	// No error
	return nil
}

// Definition of which syslog data will be collected and how it will be collected.
// Only collected from Linux machines.
type SyslogDataSource_STATUS struct {
	// FacilityNames: The list of facility names.
	FacilityNames []SyslogDataSource_FacilityNames_STATUS `json:"facilityNames,omitempty"`

	// LogLevels: The log levels to collect.
	LogLevels []SyslogDataSource_LogLevels_STATUS `json:"logLevels,omitempty"`

	// Name: A friendly name for the data source.
	// This name should be unique across all data sources (regardless of type) within the data collection rule.
	Name *string `json:"name,omitempty"`

	// Streams: List of streams that this data source will be sent to.
	// A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent
	// to.
	Streams []SyslogDataSource_Streams_STATUS `json:"streams,omitempty"`

	// TransformKql: The KQL query to transform the data source.
	TransformKql *string `json:"transformKql,omitempty"`
}

var _ genruntime.FromARMConverter = &SyslogDataSource_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (source *SyslogDataSource_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SyslogDataSource_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (source *SyslogDataSource_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SyslogDataSource_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SyslogDataSource_STATUS, got %T", armInput)
	}

	// Set property "FacilityNames":
	for _, item := range typedInput.FacilityNames {
		var temp string
		temp = string(item)
		source.FacilityNames = append(source.FacilityNames, SyslogDataSource_FacilityNames_STATUS(temp))
	}

	// Set property "LogLevels":
	for _, item := range typedInput.LogLevels {
		var temp string
		temp = string(item)
		source.LogLevels = append(source.LogLevels, SyslogDataSource_LogLevels_STATUS(temp))
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		source.Name = &name
	}

	// Set property "Streams":
	for _, item := range typedInput.Streams {
		var temp string
		temp = string(item)
		source.Streams = append(source.Streams, SyslogDataSource_Streams_STATUS(temp))
	}

	// Set property "TransformKql":
	if typedInput.TransformKql != nil {
		transformKql := *typedInput.TransformKql
		source.TransformKql = &transformKql
	}

	// No error
	return nil
}

// AssignProperties_From_SyslogDataSource_STATUS populates our SyslogDataSource_STATUS from the provided source SyslogDataSource_STATUS
func (source *SyslogDataSource_STATUS) AssignProperties_From_SyslogDataSource_STATUS(origin *storage.SyslogDataSource_STATUS) error {

	// FacilityNames
	if origin.FacilityNames != nil {
		facilityNameList := make([]SyslogDataSource_FacilityNames_STATUS, len(origin.FacilityNames))
		for facilityNameIndex, facilityNameItem := range origin.FacilityNames {
			// Shadow the loop variable to avoid aliasing
			facilityNameItem := facilityNameItem
			facilityNameList[facilityNameIndex] = genruntime.ToEnum(facilityNameItem, syslogDataSource_FacilityNames_STATUS_Values)
		}
		source.FacilityNames = facilityNameList
	} else {
		source.FacilityNames = nil
	}

	// LogLevels
	if origin.LogLevels != nil {
		logLevelList := make([]SyslogDataSource_LogLevels_STATUS, len(origin.LogLevels))
		for logLevelIndex, logLevelItem := range origin.LogLevels {
			// Shadow the loop variable to avoid aliasing
			logLevelItem := logLevelItem
			logLevelList[logLevelIndex] = genruntime.ToEnum(logLevelItem, syslogDataSource_LogLevels_STATUS_Values)
		}
		source.LogLevels = logLevelList
	} else {
		source.LogLevels = nil
	}

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// Streams
	if origin.Streams != nil {
		streamList := make([]SyslogDataSource_Streams_STATUS, len(origin.Streams))
		for streamIndex, streamItem := range origin.Streams {
			// Shadow the loop variable to avoid aliasing
			streamItem := streamItem
			streamList[streamIndex] = genruntime.ToEnum(streamItem, syslogDataSource_Streams_STATUS_Values)
		}
		source.Streams = streamList
	} else {
		source.Streams = nil
	}

	// TransformKql
	source.TransformKql = genruntime.ClonePointerToString(origin.TransformKql)

	// No error
	return nil
}

// AssignProperties_To_SyslogDataSource_STATUS populates the provided destination SyslogDataSource_STATUS from our SyslogDataSource_STATUS
func (source *SyslogDataSource_STATUS) AssignProperties_To_SyslogDataSource_STATUS(destination *storage.SyslogDataSource_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// FacilityNames
	if source.FacilityNames != nil {
		facilityNameList := make([]string, len(source.FacilityNames))
		for facilityNameIndex, facilityNameItem := range source.FacilityNames {
			// Shadow the loop variable to avoid aliasing
			facilityNameItem := facilityNameItem
			facilityNameList[facilityNameIndex] = string(facilityNameItem)
		}
		destination.FacilityNames = facilityNameList
	} else {
		destination.FacilityNames = nil
	}

	// LogLevels
	if source.LogLevels != nil {
		logLevelList := make([]string, len(source.LogLevels))
		for logLevelIndex, logLevelItem := range source.LogLevels {
			// Shadow the loop variable to avoid aliasing
			logLevelItem := logLevelItem
			logLevelList[logLevelIndex] = string(logLevelItem)
		}
		destination.LogLevels = logLevelList
	} else {
		destination.LogLevels = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// Streams
	if source.Streams != nil {
		streamList := make([]string, len(source.Streams))
		for streamIndex, streamItem := range source.Streams {
			// Shadow the loop variable to avoid aliasing
			streamItem := streamItem
			streamList[streamIndex] = string(streamItem)
		}
		destination.Streams = streamList
	} else {
		destination.Streams = nil
	}

	// TransformKql
	destination.TransformKql = genruntime.ClonePointerToString(source.TransformKql)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type SystemData_CreatedByType_STATUS string

const (
	SystemData_CreatedByType_STATUS_Application     = SystemData_CreatedByType_STATUS("Application")
	SystemData_CreatedByType_STATUS_Key             = SystemData_CreatedByType_STATUS("Key")
	SystemData_CreatedByType_STATUS_ManagedIdentity = SystemData_CreatedByType_STATUS("ManagedIdentity")
	SystemData_CreatedByType_STATUS_User            = SystemData_CreatedByType_STATUS("User")
)

// Mapping from string to SystemData_CreatedByType_STATUS
var systemData_CreatedByType_STATUS_Values = map[string]SystemData_CreatedByType_STATUS{
	"application":     SystemData_CreatedByType_STATUS_Application,
	"key":             SystemData_CreatedByType_STATUS_Key,
	"managedidentity": SystemData_CreatedByType_STATUS_ManagedIdentity,
	"user":            SystemData_CreatedByType_STATUS_User,
}

type SystemData_LastModifiedByType_STATUS string

const (
	SystemData_LastModifiedByType_STATUS_Application     = SystemData_LastModifiedByType_STATUS("Application")
	SystemData_LastModifiedByType_STATUS_Key             = SystemData_LastModifiedByType_STATUS("Key")
	SystemData_LastModifiedByType_STATUS_ManagedIdentity = SystemData_LastModifiedByType_STATUS("ManagedIdentity")
	SystemData_LastModifiedByType_STATUS_User            = SystemData_LastModifiedByType_STATUS("User")
)

// Mapping from string to SystemData_LastModifiedByType_STATUS
var systemData_LastModifiedByType_STATUS_Values = map[string]SystemData_LastModifiedByType_STATUS{
	"application":     SystemData_LastModifiedByType_STATUS_Application,
	"key":             SystemData_LastModifiedByType_STATUS_Key,
	"managedidentity": SystemData_LastModifiedByType_STATUS_ManagedIdentity,
	"user":            SystemData_LastModifiedByType_STATUS_User,
}

// User assigned identity properties
type UserAssignedIdentity_STATUS struct {
	// ClientId: The client ID of the assigned identity.
	ClientId *string `json:"clientId,omitempty"`

	// PrincipalId: The principal ID of the assigned identity.
	PrincipalId *string `json:"principalId,omitempty"`
}

var _ genruntime.FromARMConverter = &UserAssignedIdentity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *UserAssignedIdentity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UserAssignedIdentity_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *UserAssignedIdentity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UserAssignedIdentity_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UserAssignedIdentity_STATUS, got %T", armInput)
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		identity.ClientId = &clientId
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identity.PrincipalId = &principalId
	}

	// No error
	return nil
}

// AssignProperties_From_UserAssignedIdentity_STATUS populates our UserAssignedIdentity_STATUS from the provided source UserAssignedIdentity_STATUS
func (identity *UserAssignedIdentity_STATUS) AssignProperties_From_UserAssignedIdentity_STATUS(source *storage.UserAssignedIdentity_STATUS) error {

	// ClientId
	identity.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// No error
	return nil
}

// AssignProperties_To_UserAssignedIdentity_STATUS populates the provided destination UserAssignedIdentity_STATUS from our UserAssignedIdentity_STATUS
func (identity *UserAssignedIdentity_STATUS) AssignProperties_To_UserAssignedIdentity_STATUS(destination *storage.UserAssignedIdentity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(identity.ClientId)

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Information about the user assigned identity for the resource
type UserAssignedIdentityDetails struct {
	Reference genruntime.ResourceReference `armReference:"Reference" json:"reference,omitempty"`
}

// AssignProperties_From_UserAssignedIdentityDetails populates our UserAssignedIdentityDetails from the provided source UserAssignedIdentityDetails
func (details *UserAssignedIdentityDetails) AssignProperties_From_UserAssignedIdentityDetails(source *storage.UserAssignedIdentityDetails) error {

	// Reference
	details.Reference = source.Reference.Copy()

	// No error
	return nil
}

// AssignProperties_To_UserAssignedIdentityDetails populates the provided destination UserAssignedIdentityDetails from our UserAssignedIdentityDetails
func (details *UserAssignedIdentityDetails) AssignProperties_To_UserAssignedIdentityDetails(destination *storage.UserAssignedIdentityDetails) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	destination.Reference = details.Reference.Copy()

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Definition of which Windows Event Log events will be collected and how they will be collected.
// Only collected from
// Windows machines.
type WindowsEventLogDataSource struct {
	// Name: A friendly name for the data source.
	// This name should be unique across all data sources (regardless of type) within the data collection rule.
	Name *string `json:"name,omitempty"`

	// Streams: List of streams that this data source will be sent to.
	// A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent
	// to.
	Streams []WindowsEventLogDataSource_Streams `json:"streams,omitempty"`

	// TransformKql: The KQL query to transform the data source.
	TransformKql *string `json:"transformKql,omitempty"`

	// XPathQueries: A list of Windows Event Log queries in XPATH format.
	XPathQueries []string `json:"xPathQueries,omitempty"`
}

var _ genruntime.ARMTransformer = &WindowsEventLogDataSource{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (source *WindowsEventLogDataSource) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if source == nil {
		return nil, nil
	}
	result := &arm.WindowsEventLogDataSource{}

	// Set property "Name":
	if source.Name != nil {
		name := *source.Name
		result.Name = &name
	}

	// Set property "Streams":
	for _, item := range source.Streams {
		var temp string
		temp = string(item)
		result.Streams = append(result.Streams, arm.WindowsEventLogDataSource_Streams(temp))
	}

	// Set property "TransformKql":
	if source.TransformKql != nil {
		transformKql := *source.TransformKql
		result.TransformKql = &transformKql
	}

	// Set property "XPathQueries":
	for _, item := range source.XPathQueries {
		result.XPathQueries = append(result.XPathQueries, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (source *WindowsEventLogDataSource) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WindowsEventLogDataSource{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (source *WindowsEventLogDataSource) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WindowsEventLogDataSource)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WindowsEventLogDataSource, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		source.Name = &name
	}

	// Set property "Streams":
	for _, item := range typedInput.Streams {
		var temp string
		temp = string(item)
		source.Streams = append(source.Streams, WindowsEventLogDataSource_Streams(temp))
	}

	// Set property "TransformKql":
	if typedInput.TransformKql != nil {
		transformKql := *typedInput.TransformKql
		source.TransformKql = &transformKql
	}

	// Set property "XPathQueries":
	for _, item := range typedInput.XPathQueries {
		source.XPathQueries = append(source.XPathQueries, item)
	}

	// No error
	return nil
}

// AssignProperties_From_WindowsEventLogDataSource populates our WindowsEventLogDataSource from the provided source WindowsEventLogDataSource
func (source *WindowsEventLogDataSource) AssignProperties_From_WindowsEventLogDataSource(origin *storage.WindowsEventLogDataSource) error {

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// Streams
	if origin.Streams != nil {
		streamList := make([]WindowsEventLogDataSource_Streams, len(origin.Streams))
		for streamIndex, streamItem := range origin.Streams {
			// Shadow the loop variable to avoid aliasing
			streamItem := streamItem
			streamList[streamIndex] = genruntime.ToEnum(streamItem, windowsEventLogDataSource_Streams_Values)
		}
		source.Streams = streamList
	} else {
		source.Streams = nil
	}

	// TransformKql
	source.TransformKql = genruntime.ClonePointerToString(origin.TransformKql)

	// XPathQueries
	source.XPathQueries = genruntime.CloneSliceOfString(origin.XPathQueries)

	// No error
	return nil
}

// AssignProperties_To_WindowsEventLogDataSource populates the provided destination WindowsEventLogDataSource from our WindowsEventLogDataSource
func (source *WindowsEventLogDataSource) AssignProperties_To_WindowsEventLogDataSource(destination *storage.WindowsEventLogDataSource) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// Streams
	if source.Streams != nil {
		streamList := make([]string, len(source.Streams))
		for streamIndex, streamItem := range source.Streams {
			// Shadow the loop variable to avoid aliasing
			streamItem := streamItem
			streamList[streamIndex] = string(streamItem)
		}
		destination.Streams = streamList
	} else {
		destination.Streams = nil
	}

	// TransformKql
	destination.TransformKql = genruntime.ClonePointerToString(source.TransformKql)

	// XPathQueries
	destination.XPathQueries = genruntime.CloneSliceOfString(source.XPathQueries)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_WindowsEventLogDataSource_STATUS populates our WindowsEventLogDataSource from the provided source WindowsEventLogDataSource_STATUS
func (source *WindowsEventLogDataSource) Initialize_From_WindowsEventLogDataSource_STATUS(origin *WindowsEventLogDataSource_STATUS) error {

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// Streams
	if origin.Streams != nil {
		streamList := make([]WindowsEventLogDataSource_Streams, len(origin.Streams))
		for streamIndex, streamItem := range origin.Streams {
			// Shadow the loop variable to avoid aliasing
			streamItem := streamItem
			stream := genruntime.ToEnum(string(streamItem), windowsEventLogDataSource_Streams_Values)
			streamList[streamIndex] = stream
		}
		source.Streams = streamList
	} else {
		source.Streams = nil
	}

	// TransformKql
	source.TransformKql = genruntime.ClonePointerToString(origin.TransformKql)

	// XPathQueries
	source.XPathQueries = genruntime.CloneSliceOfString(origin.XPathQueries)

	// No error
	return nil
}

// Definition of which Windows Event Log events will be collected and how they will be collected.
// Only collected from
// Windows machines.
type WindowsEventLogDataSource_STATUS struct {
	// Name: A friendly name for the data source.
	// This name should be unique across all data sources (regardless of type) within the data collection rule.
	Name *string `json:"name,omitempty"`

	// Streams: List of streams that this data source will be sent to.
	// A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent
	// to.
	Streams []WindowsEventLogDataSource_Streams_STATUS `json:"streams,omitempty"`

	// TransformKql: The KQL query to transform the data source.
	TransformKql *string `json:"transformKql,omitempty"`

	// XPathQueries: A list of Windows Event Log queries in XPATH format.
	XPathQueries []string `json:"xPathQueries,omitempty"`
}

var _ genruntime.FromARMConverter = &WindowsEventLogDataSource_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (source *WindowsEventLogDataSource_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WindowsEventLogDataSource_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (source *WindowsEventLogDataSource_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WindowsEventLogDataSource_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WindowsEventLogDataSource_STATUS, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		source.Name = &name
	}

	// Set property "Streams":
	for _, item := range typedInput.Streams {
		var temp string
		temp = string(item)
		source.Streams = append(source.Streams, WindowsEventLogDataSource_Streams_STATUS(temp))
	}

	// Set property "TransformKql":
	if typedInput.TransformKql != nil {
		transformKql := *typedInput.TransformKql
		source.TransformKql = &transformKql
	}

	// Set property "XPathQueries":
	for _, item := range typedInput.XPathQueries {
		source.XPathQueries = append(source.XPathQueries, item)
	}

	// No error
	return nil
}

// AssignProperties_From_WindowsEventLogDataSource_STATUS populates our WindowsEventLogDataSource_STATUS from the provided source WindowsEventLogDataSource_STATUS
func (source *WindowsEventLogDataSource_STATUS) AssignProperties_From_WindowsEventLogDataSource_STATUS(origin *storage.WindowsEventLogDataSource_STATUS) error {

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// Streams
	if origin.Streams != nil {
		streamList := make([]WindowsEventLogDataSource_Streams_STATUS, len(origin.Streams))
		for streamIndex, streamItem := range origin.Streams {
			// Shadow the loop variable to avoid aliasing
			streamItem := streamItem
			streamList[streamIndex] = genruntime.ToEnum(streamItem, windowsEventLogDataSource_Streams_STATUS_Values)
		}
		source.Streams = streamList
	} else {
		source.Streams = nil
	}

	// TransformKql
	source.TransformKql = genruntime.ClonePointerToString(origin.TransformKql)

	// XPathQueries
	source.XPathQueries = genruntime.CloneSliceOfString(origin.XPathQueries)

	// No error
	return nil
}

// AssignProperties_To_WindowsEventLogDataSource_STATUS populates the provided destination WindowsEventLogDataSource_STATUS from our WindowsEventLogDataSource_STATUS
func (source *WindowsEventLogDataSource_STATUS) AssignProperties_To_WindowsEventLogDataSource_STATUS(destination *storage.WindowsEventLogDataSource_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// Streams
	if source.Streams != nil {
		streamList := make([]string, len(source.Streams))
		for streamIndex, streamItem := range source.Streams {
			// Shadow the loop variable to avoid aliasing
			streamItem := streamItem
			streamList[streamIndex] = string(streamItem)
		}
		destination.Streams = streamList
	} else {
		destination.Streams = nil
	}

	// TransformKql
	destination.TransformKql = genruntime.ClonePointerToString(source.TransformKql)

	// XPathQueries
	destination.XPathQueries = genruntime.CloneSliceOfString(source.XPathQueries)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Enables Firewall logs to be collected by this data collection rule.
type WindowsFirewallLogsDataSource struct {
	// Name: A friendly name for the data source.
	// This name should be unique across all data sources (regardless of type) within the data collection rule.
	Name *string `json:"name,omitempty"`

	// ProfileFilter: Firewall logs profile filter
	ProfileFilter []WindowsFirewallLogsDataSource_ProfileFilter `json:"profileFilter,omitempty"`

	// +kubebuilder:validation:Required
	// Streams: Firewall logs streams
	Streams []string `json:"streams,omitempty"`
}

var _ genruntime.ARMTransformer = &WindowsFirewallLogsDataSource{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (source *WindowsFirewallLogsDataSource) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if source == nil {
		return nil, nil
	}
	result := &arm.WindowsFirewallLogsDataSource{}

	// Set property "Name":
	if source.Name != nil {
		name := *source.Name
		result.Name = &name
	}

	// Set property "ProfileFilter":
	for _, item := range source.ProfileFilter {
		var temp string
		temp = string(item)
		result.ProfileFilter = append(result.ProfileFilter, arm.WindowsFirewallLogsDataSource_ProfileFilter(temp))
	}

	// Set property "Streams":
	for _, item := range source.Streams {
		result.Streams = append(result.Streams, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (source *WindowsFirewallLogsDataSource) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WindowsFirewallLogsDataSource{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (source *WindowsFirewallLogsDataSource) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WindowsFirewallLogsDataSource)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WindowsFirewallLogsDataSource, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		source.Name = &name
	}

	// Set property "ProfileFilter":
	for _, item := range typedInput.ProfileFilter {
		var temp string
		temp = string(item)
		source.ProfileFilter = append(source.ProfileFilter, WindowsFirewallLogsDataSource_ProfileFilter(temp))
	}

	// Set property "Streams":
	for _, item := range typedInput.Streams {
		source.Streams = append(source.Streams, item)
	}

	// No error
	return nil
}

// AssignProperties_From_WindowsFirewallLogsDataSource populates our WindowsFirewallLogsDataSource from the provided source WindowsFirewallLogsDataSource
func (source *WindowsFirewallLogsDataSource) AssignProperties_From_WindowsFirewallLogsDataSource(origin *storage.WindowsFirewallLogsDataSource) error {

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// ProfileFilter
	if origin.ProfileFilter != nil {
		profileFilterList := make([]WindowsFirewallLogsDataSource_ProfileFilter, len(origin.ProfileFilter))
		for profileFilterIndex, profileFilterItem := range origin.ProfileFilter {
			// Shadow the loop variable to avoid aliasing
			profileFilterItem := profileFilterItem
			profileFilterList[profileFilterIndex] = genruntime.ToEnum(profileFilterItem, windowsFirewallLogsDataSource_ProfileFilter_Values)
		}
		source.ProfileFilter = profileFilterList
	} else {
		source.ProfileFilter = nil
	}

	// Streams
	source.Streams = genruntime.CloneSliceOfString(origin.Streams)

	// No error
	return nil
}

// AssignProperties_To_WindowsFirewallLogsDataSource populates the provided destination WindowsFirewallLogsDataSource from our WindowsFirewallLogsDataSource
func (source *WindowsFirewallLogsDataSource) AssignProperties_To_WindowsFirewallLogsDataSource(destination *storage.WindowsFirewallLogsDataSource) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// ProfileFilter
	if source.ProfileFilter != nil {
		profileFilterList := make([]string, len(source.ProfileFilter))
		for profileFilterIndex, profileFilterItem := range source.ProfileFilter {
			// Shadow the loop variable to avoid aliasing
			profileFilterItem := profileFilterItem
			profileFilterList[profileFilterIndex] = string(profileFilterItem)
		}
		destination.ProfileFilter = profileFilterList
	} else {
		destination.ProfileFilter = nil
	}

	// Streams
	destination.Streams = genruntime.CloneSliceOfString(source.Streams)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_WindowsFirewallLogsDataSource_STATUS populates our WindowsFirewallLogsDataSource from the provided source WindowsFirewallLogsDataSource_STATUS
func (source *WindowsFirewallLogsDataSource) Initialize_From_WindowsFirewallLogsDataSource_STATUS(origin *WindowsFirewallLogsDataSource_STATUS) error {

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// ProfileFilter
	if origin.ProfileFilter != nil {
		profileFilterList := make([]WindowsFirewallLogsDataSource_ProfileFilter, len(origin.ProfileFilter))
		for profileFilterIndex, profileFilterItem := range origin.ProfileFilter {
			// Shadow the loop variable to avoid aliasing
			profileFilterItem := profileFilterItem
			profileFilter := genruntime.ToEnum(string(profileFilterItem), windowsFirewallLogsDataSource_ProfileFilter_Values)
			profileFilterList[profileFilterIndex] = profileFilter
		}
		source.ProfileFilter = profileFilterList
	} else {
		source.ProfileFilter = nil
	}

	// Streams
	source.Streams = genruntime.CloneSliceOfString(origin.Streams)

	// No error
	return nil
}

// Enables Firewall logs to be collected by this data collection rule.
type WindowsFirewallLogsDataSource_STATUS struct {
	// Name: A friendly name for the data source.
	// This name should be unique across all data sources (regardless of type) within the data collection rule.
	Name *string `json:"name,omitempty"`

	// ProfileFilter: Firewall logs profile filter
	ProfileFilter []WindowsFirewallLogsDataSource_ProfileFilter_STATUS `json:"profileFilter,omitempty"`

	// Streams: Firewall logs streams
	Streams []string `json:"streams,omitempty"`
}

var _ genruntime.FromARMConverter = &WindowsFirewallLogsDataSource_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (source *WindowsFirewallLogsDataSource_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WindowsFirewallLogsDataSource_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (source *WindowsFirewallLogsDataSource_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WindowsFirewallLogsDataSource_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WindowsFirewallLogsDataSource_STATUS, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		source.Name = &name
	}

	// Set property "ProfileFilter":
	for _, item := range typedInput.ProfileFilter {
		var temp string
		temp = string(item)
		source.ProfileFilter = append(source.ProfileFilter, WindowsFirewallLogsDataSource_ProfileFilter_STATUS(temp))
	}

	// Set property "Streams":
	for _, item := range typedInput.Streams {
		source.Streams = append(source.Streams, item)
	}

	// No error
	return nil
}

// AssignProperties_From_WindowsFirewallLogsDataSource_STATUS populates our WindowsFirewallLogsDataSource_STATUS from the provided source WindowsFirewallLogsDataSource_STATUS
func (source *WindowsFirewallLogsDataSource_STATUS) AssignProperties_From_WindowsFirewallLogsDataSource_STATUS(origin *storage.WindowsFirewallLogsDataSource_STATUS) error {

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// ProfileFilter
	if origin.ProfileFilter != nil {
		profileFilterList := make([]WindowsFirewallLogsDataSource_ProfileFilter_STATUS, len(origin.ProfileFilter))
		for profileFilterIndex, profileFilterItem := range origin.ProfileFilter {
			// Shadow the loop variable to avoid aliasing
			profileFilterItem := profileFilterItem
			profileFilterList[profileFilterIndex] = genruntime.ToEnum(profileFilterItem, windowsFirewallLogsDataSource_ProfileFilter_STATUS_Values)
		}
		source.ProfileFilter = profileFilterList
	} else {
		source.ProfileFilter = nil
	}

	// Streams
	source.Streams = genruntime.CloneSliceOfString(origin.Streams)

	// No error
	return nil
}

// AssignProperties_To_WindowsFirewallLogsDataSource_STATUS populates the provided destination WindowsFirewallLogsDataSource_STATUS from our WindowsFirewallLogsDataSource_STATUS
func (source *WindowsFirewallLogsDataSource_STATUS) AssignProperties_To_WindowsFirewallLogsDataSource_STATUS(destination *storage.WindowsFirewallLogsDataSource_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// ProfileFilter
	if source.ProfileFilter != nil {
		profileFilterList := make([]string, len(source.ProfileFilter))
		for profileFilterIndex, profileFilterItem := range source.ProfileFilter {
			// Shadow the loop variable to avoid aliasing
			profileFilterItem := profileFilterItem
			profileFilterList[profileFilterIndex] = string(profileFilterItem)
		}
		destination.ProfileFilter = profileFilterList
	} else {
		destination.ProfileFilter = nil
	}

	// Streams
	destination.Streams = genruntime.CloneSliceOfString(source.Streams)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"MaxDiskQuotaInMB","UseTimeReceivedForForwardedEvents"}
type AgentSetting_Name string

const (
	AgentSetting_Name_MaxDiskQuotaInMB                  = AgentSetting_Name("MaxDiskQuotaInMB")
	AgentSetting_Name_UseTimeReceivedForForwardedEvents = AgentSetting_Name("UseTimeReceivedForForwardedEvents")
)

// Mapping from string to AgentSetting_Name
var agentSetting_Name_Values = map[string]AgentSetting_Name{
	"maxdiskquotainmb":                  AgentSetting_Name_MaxDiskQuotaInMB,
	"usetimereceivedforforwardedevents": AgentSetting_Name_UseTimeReceivedForForwardedEvents,
}

type AgentSetting_Name_STATUS string

const (
	AgentSetting_Name_STATUS_MaxDiskQuotaInMB                  = AgentSetting_Name_STATUS("MaxDiskQuotaInMB")
	AgentSetting_Name_STATUS_UseTimeReceivedForForwardedEvents = AgentSetting_Name_STATUS("UseTimeReceivedForForwardedEvents")
)

// Mapping from string to AgentSetting_Name_STATUS
var agentSetting_Name_STATUS_Values = map[string]AgentSetting_Name_STATUS{
	"maxdiskquotainmb":                  AgentSetting_Name_STATUS_MaxDiskQuotaInMB,
	"usetimereceivedforforwardedevents": AgentSetting_Name_STATUS_UseTimeReceivedForForwardedEvents,
}

// +kubebuilder:validation:Enum={"boolean","datetime","dynamic","int","long","real","string"}
type ColumnDefinition_Type string

const (
	ColumnDefinition_Type_Boolean  = ColumnDefinition_Type("boolean")
	ColumnDefinition_Type_Datetime = ColumnDefinition_Type("datetime")
	ColumnDefinition_Type_Dynamic  = ColumnDefinition_Type("dynamic")
	ColumnDefinition_Type_Int      = ColumnDefinition_Type("int")
	ColumnDefinition_Type_Long     = ColumnDefinition_Type("long")
	ColumnDefinition_Type_Real     = ColumnDefinition_Type("real")
	ColumnDefinition_Type_String   = ColumnDefinition_Type("string")
)

// Mapping from string to ColumnDefinition_Type
var columnDefinition_Type_Values = map[string]ColumnDefinition_Type{
	"boolean":  ColumnDefinition_Type_Boolean,
	"datetime": ColumnDefinition_Type_Datetime,
	"dynamic":  ColumnDefinition_Type_Dynamic,
	"int":      ColumnDefinition_Type_Int,
	"long":     ColumnDefinition_Type_Long,
	"real":     ColumnDefinition_Type_Real,
	"string":   ColumnDefinition_Type_String,
}

type ColumnDefinition_Type_STATUS string

const (
	ColumnDefinition_Type_STATUS_Boolean  = ColumnDefinition_Type_STATUS("boolean")
	ColumnDefinition_Type_STATUS_Datetime = ColumnDefinition_Type_STATUS("datetime")
	ColumnDefinition_Type_STATUS_Dynamic  = ColumnDefinition_Type_STATUS("dynamic")
	ColumnDefinition_Type_STATUS_Int      = ColumnDefinition_Type_STATUS("int")
	ColumnDefinition_Type_STATUS_Long     = ColumnDefinition_Type_STATUS("long")
	ColumnDefinition_Type_STATUS_Real     = ColumnDefinition_Type_STATUS("real")
	ColumnDefinition_Type_STATUS_String   = ColumnDefinition_Type_STATUS("string")
)

// Mapping from string to ColumnDefinition_Type_STATUS
var columnDefinition_Type_STATUS_Values = map[string]ColumnDefinition_Type_STATUS{
	"boolean":  ColumnDefinition_Type_STATUS_Boolean,
	"datetime": ColumnDefinition_Type_STATUS_Datetime,
	"dynamic":  ColumnDefinition_Type_STATUS_Dynamic,
	"int":      ColumnDefinition_Type_STATUS_Int,
	"long":     ColumnDefinition_Type_STATUS_Long,
	"real":     ColumnDefinition_Type_STATUS_Real,
	"string":   ColumnDefinition_Type_STATUS_String,
}

type EventHubDataSource struct {
	// ConsumerGroup: Event Hub consumer group name
	ConsumerGroup *string `json:"consumerGroup,omitempty"`

	// Name: A friendly name for the data source.
	// This name should be unique across all data sources (regardless of type) within the data collection rule.
	Name *string `json:"name,omitempty"`

	// Stream: The stream to collect from EventHub
	Stream *string `json:"stream,omitempty"`
}

var _ genruntime.ARMTransformer = &EventHubDataSource{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (source *EventHubDataSource) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if source == nil {
		return nil, nil
	}
	result := &arm.EventHubDataSource{}

	// Set property "ConsumerGroup":
	if source.ConsumerGroup != nil {
		consumerGroup := *source.ConsumerGroup
		result.ConsumerGroup = &consumerGroup
	}

	// Set property "Name":
	if source.Name != nil {
		name := *source.Name
		result.Name = &name
	}

	// Set property "Stream":
	if source.Stream != nil {
		stream := *source.Stream
		result.Stream = &stream
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (source *EventHubDataSource) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EventHubDataSource{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (source *EventHubDataSource) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EventHubDataSource)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EventHubDataSource, got %T", armInput)
	}

	// Set property "ConsumerGroup":
	if typedInput.ConsumerGroup != nil {
		consumerGroup := *typedInput.ConsumerGroup
		source.ConsumerGroup = &consumerGroup
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		source.Name = &name
	}

	// Set property "Stream":
	if typedInput.Stream != nil {
		stream := *typedInput.Stream
		source.Stream = &stream
	}

	// No error
	return nil
}

// AssignProperties_From_EventHubDataSource populates our EventHubDataSource from the provided source EventHubDataSource
func (source *EventHubDataSource) AssignProperties_From_EventHubDataSource(origin *storage.EventHubDataSource) error {

	// ConsumerGroup
	source.ConsumerGroup = genruntime.ClonePointerToString(origin.ConsumerGroup)

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// Stream
	source.Stream = genruntime.ClonePointerToString(origin.Stream)

	// No error
	return nil
}

// AssignProperties_To_EventHubDataSource populates the provided destination EventHubDataSource from our EventHubDataSource
func (source *EventHubDataSource) AssignProperties_To_EventHubDataSource(destination *storage.EventHubDataSource) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConsumerGroup
	destination.ConsumerGroup = genruntime.ClonePointerToString(source.ConsumerGroup)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// Stream
	destination.Stream = genruntime.ClonePointerToString(source.Stream)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_EventHubDataSource_STATUS populates our EventHubDataSource from the provided source EventHubDataSource_STATUS
func (source *EventHubDataSource) Initialize_From_EventHubDataSource_STATUS(origin *EventHubDataSource_STATUS) error {

	// ConsumerGroup
	source.ConsumerGroup = genruntime.ClonePointerToString(origin.ConsumerGroup)

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// Stream
	source.Stream = genruntime.ClonePointerToString(origin.Stream)

	// No error
	return nil
}

type EventHubDataSource_STATUS struct {
	// ConsumerGroup: Event Hub consumer group name
	ConsumerGroup *string `json:"consumerGroup,omitempty"`

	// Name: A friendly name for the data source.
	// This name should be unique across all data sources (regardless of type) within the data collection rule.
	Name *string `json:"name,omitempty"`

	// Stream: The stream to collect from EventHub
	Stream *string `json:"stream,omitempty"`
}

var _ genruntime.FromARMConverter = &EventHubDataSource_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (source *EventHubDataSource_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EventHubDataSource_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (source *EventHubDataSource_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EventHubDataSource_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EventHubDataSource_STATUS, got %T", armInput)
	}

	// Set property "ConsumerGroup":
	if typedInput.ConsumerGroup != nil {
		consumerGroup := *typedInput.ConsumerGroup
		source.ConsumerGroup = &consumerGroup
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		source.Name = &name
	}

	// Set property "Stream":
	if typedInput.Stream != nil {
		stream := *typedInput.Stream
		source.Stream = &stream
	}

	// No error
	return nil
}

// AssignProperties_From_EventHubDataSource_STATUS populates our EventHubDataSource_STATUS from the provided source EventHubDataSource_STATUS
func (source *EventHubDataSource_STATUS) AssignProperties_From_EventHubDataSource_STATUS(origin *storage.EventHubDataSource_STATUS) error {

	// ConsumerGroup
	source.ConsumerGroup = genruntime.ClonePointerToString(origin.ConsumerGroup)

	// Name
	source.Name = genruntime.ClonePointerToString(origin.Name)

	// Stream
	source.Stream = genruntime.ClonePointerToString(origin.Stream)

	// No error
	return nil
}

// AssignProperties_To_EventHubDataSource_STATUS populates the provided destination EventHubDataSource_STATUS from our EventHubDataSource_STATUS
func (source *EventHubDataSource_STATUS) AssignProperties_To_EventHubDataSource_STATUS(destination *storage.EventHubDataSource_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConsumerGroup
	destination.ConsumerGroup = genruntime.ClonePointerToString(source.ConsumerGroup)

	// Name
	destination.Name = genruntime.ClonePointerToString(source.Name)

	// Stream
	destination.Stream = genruntime.ClonePointerToString(source.Stream)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Microsoft-Event","Microsoft-InsightsMetrics","Microsoft-Perf","Microsoft-Syslog","Microsoft-WindowsEvent"}
type ExtensionDataSource_Streams string

const (
	ExtensionDataSource_Streams_MicrosoftEvent           = ExtensionDataSource_Streams("Microsoft-Event")
	ExtensionDataSource_Streams_MicrosoftInsightsMetrics = ExtensionDataSource_Streams("Microsoft-InsightsMetrics")
	ExtensionDataSource_Streams_MicrosoftPerf            = ExtensionDataSource_Streams("Microsoft-Perf")
	ExtensionDataSource_Streams_MicrosoftSyslog          = ExtensionDataSource_Streams("Microsoft-Syslog")
	ExtensionDataSource_Streams_MicrosoftWindowsEvent    = ExtensionDataSource_Streams("Microsoft-WindowsEvent")
)

// Mapping from string to ExtensionDataSource_Streams
var extensionDataSource_Streams_Values = map[string]ExtensionDataSource_Streams{
	"microsoft-event":           ExtensionDataSource_Streams_MicrosoftEvent,
	"microsoft-insightsmetrics": ExtensionDataSource_Streams_MicrosoftInsightsMetrics,
	"microsoft-perf":            ExtensionDataSource_Streams_MicrosoftPerf,
	"microsoft-syslog":          ExtensionDataSource_Streams_MicrosoftSyslog,
	"microsoft-windowsevent":    ExtensionDataSource_Streams_MicrosoftWindowsEvent,
}

type ExtensionDataSource_Streams_STATUS string

const (
	ExtensionDataSource_Streams_STATUS_MicrosoftEvent           = ExtensionDataSource_Streams_STATUS("Microsoft-Event")
	ExtensionDataSource_Streams_STATUS_MicrosoftInsightsMetrics = ExtensionDataSource_Streams_STATUS("Microsoft-InsightsMetrics")
	ExtensionDataSource_Streams_STATUS_MicrosoftPerf            = ExtensionDataSource_Streams_STATUS("Microsoft-Perf")
	ExtensionDataSource_Streams_STATUS_MicrosoftSyslog          = ExtensionDataSource_Streams_STATUS("Microsoft-Syslog")
	ExtensionDataSource_Streams_STATUS_MicrosoftWindowsEvent    = ExtensionDataSource_Streams_STATUS("Microsoft-WindowsEvent")
)

// Mapping from string to ExtensionDataSource_Streams_STATUS
var extensionDataSource_Streams_STATUS_Values = map[string]ExtensionDataSource_Streams_STATUS{
	"microsoft-event":           ExtensionDataSource_Streams_STATUS_MicrosoftEvent,
	"microsoft-insightsmetrics": ExtensionDataSource_Streams_STATUS_MicrosoftInsightsMetrics,
	"microsoft-perf":            ExtensionDataSource_Streams_STATUS_MicrosoftPerf,
	"microsoft-syslog":          ExtensionDataSource_Streams_STATUS_MicrosoftSyslog,
	"microsoft-windowsevent":    ExtensionDataSource_Streams_STATUS_MicrosoftWindowsEvent,
}

// +kubebuilder:validation:Enum={"json","text"}
type LogFilesDataSource_Format string

const (
	LogFilesDataSource_Format_Json = LogFilesDataSource_Format("json")
	LogFilesDataSource_Format_Text = LogFilesDataSource_Format("text")
)

// Mapping from string to LogFilesDataSource_Format
var logFilesDataSource_Format_Values = map[string]LogFilesDataSource_Format{
	"json": LogFilesDataSource_Format_Json,
	"text": LogFilesDataSource_Format_Text,
}

type LogFilesDataSource_Format_STATUS string

const (
	LogFilesDataSource_Format_STATUS_Json = LogFilesDataSource_Format_STATUS("json")
	LogFilesDataSource_Format_STATUS_Text = LogFilesDataSource_Format_STATUS("text")
)

// Mapping from string to LogFilesDataSource_Format_STATUS
var logFilesDataSource_Format_STATUS_Values = map[string]LogFilesDataSource_Format_STATUS{
	"json": LogFilesDataSource_Format_STATUS_Json,
	"text": LogFilesDataSource_Format_STATUS_Text,
}

// Settings for different log file formats
type LogFileSettings struct {
	// Text: Text settings
	Text *LogFileTextSettings `json:"text,omitempty"`
}

var _ genruntime.ARMTransformer = &LogFileSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *LogFileSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &arm.LogFileSettings{}

	// Set property "Text":
	if settings.Text != nil {
		text_ARM, err := (*settings.Text).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		text := *text_ARM.(*arm.LogFileTextSettings)
		result.Text = &text
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *LogFileSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.LogFileSettings{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *LogFileSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.LogFileSettings)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.LogFileSettings, got %T", armInput)
	}

	// Set property "Text":
	if typedInput.Text != nil {
		var text1 LogFileTextSettings
		err := text1.PopulateFromARM(owner, *typedInput.Text)
		if err != nil {
			return err
		}
		text := text1
		settings.Text = &text
	}

	// No error
	return nil
}

// AssignProperties_From_LogFileSettings populates our LogFileSettings from the provided source LogFileSettings
func (settings *LogFileSettings) AssignProperties_From_LogFileSettings(source *storage.LogFileSettings) error {

	// Text
	if source.Text != nil {
		var text LogFileTextSettings
		err := text.AssignProperties_From_LogFileTextSettings(source.Text)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_LogFileTextSettings() to populate field Text")
		}
		settings.Text = &text
	} else {
		settings.Text = nil
	}

	// No error
	return nil
}

// AssignProperties_To_LogFileSettings populates the provided destination LogFileSettings from our LogFileSettings
func (settings *LogFileSettings) AssignProperties_To_LogFileSettings(destination *storage.LogFileSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Text
	if settings.Text != nil {
		var text storage.LogFileTextSettings
		err := settings.Text.AssignProperties_To_LogFileTextSettings(&text)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_LogFileTextSettings() to populate field Text")
		}
		destination.Text = &text
	} else {
		destination.Text = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_LogFileSettings_STATUS populates our LogFileSettings from the provided source LogFileSettings_STATUS
func (settings *LogFileSettings) Initialize_From_LogFileSettings_STATUS(source *LogFileSettings_STATUS) error {

	// Text
	if source.Text != nil {
		var text LogFileTextSettings
		err := text.Initialize_From_LogFileTextSettings_STATUS(source.Text)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_LogFileTextSettings_STATUS() to populate field Text")
		}
		settings.Text = &text
	} else {
		settings.Text = nil
	}

	// No error
	return nil
}

// Settings for different log file formats
type LogFileSettings_STATUS struct {
	// Text: Text settings
	Text *LogFileTextSettings_STATUS `json:"text,omitempty"`
}

var _ genruntime.FromARMConverter = &LogFileSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *LogFileSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.LogFileSettings_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *LogFileSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.LogFileSettings_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.LogFileSettings_STATUS, got %T", armInput)
	}

	// Set property "Text":
	if typedInput.Text != nil {
		var text1 LogFileTextSettings_STATUS
		err := text1.PopulateFromARM(owner, *typedInput.Text)
		if err != nil {
			return err
		}
		text := text1
		settings.Text = &text
	}

	// No error
	return nil
}

// AssignProperties_From_LogFileSettings_STATUS populates our LogFileSettings_STATUS from the provided source LogFileSettings_STATUS
func (settings *LogFileSettings_STATUS) AssignProperties_From_LogFileSettings_STATUS(source *storage.LogFileSettings_STATUS) error {

	// Text
	if source.Text != nil {
		var text LogFileTextSettings_STATUS
		err := text.AssignProperties_From_LogFileTextSettings_STATUS(source.Text)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_LogFileTextSettings_STATUS() to populate field Text")
		}
		settings.Text = &text
	} else {
		settings.Text = nil
	}

	// No error
	return nil
}

// AssignProperties_To_LogFileSettings_STATUS populates the provided destination LogFileSettings_STATUS from our LogFileSettings_STATUS
func (settings *LogFileSettings_STATUS) AssignProperties_To_LogFileSettings_STATUS(destination *storage.LogFileSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Text
	if settings.Text != nil {
		var text storage.LogFileTextSettings_STATUS
		err := settings.Text.AssignProperties_To_LogFileTextSettings_STATUS(&text)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_LogFileTextSettings_STATUS() to populate field Text")
		}
		destination.Text = &text
	} else {
		destination.Text = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Microsoft-InsightsMetrics","Microsoft-Perf"}
type PerfCounterDataSource_Streams string

const (
	PerfCounterDataSource_Streams_MicrosoftInsightsMetrics = PerfCounterDataSource_Streams("Microsoft-InsightsMetrics")
	PerfCounterDataSource_Streams_MicrosoftPerf            = PerfCounterDataSource_Streams("Microsoft-Perf")
)

// Mapping from string to PerfCounterDataSource_Streams
var perfCounterDataSource_Streams_Values = map[string]PerfCounterDataSource_Streams{
	"microsoft-insightsmetrics": PerfCounterDataSource_Streams_MicrosoftInsightsMetrics,
	"microsoft-perf":            PerfCounterDataSource_Streams_MicrosoftPerf,
}

type PerfCounterDataSource_Streams_STATUS string

const (
	PerfCounterDataSource_Streams_STATUS_MicrosoftInsightsMetrics = PerfCounterDataSource_Streams_STATUS("Microsoft-InsightsMetrics")
	PerfCounterDataSource_Streams_STATUS_MicrosoftPerf            = PerfCounterDataSource_Streams_STATUS("Microsoft-Perf")
)

// Mapping from string to PerfCounterDataSource_Streams_STATUS
var perfCounterDataSource_Streams_STATUS_Values = map[string]PerfCounterDataSource_Streams_STATUS{
	"microsoft-insightsmetrics": PerfCounterDataSource_Streams_STATUS_MicrosoftInsightsMetrics,
	"microsoft-perf":            PerfCounterDataSource_Streams_STATUS_MicrosoftPerf,
}

// +kubebuilder:validation:Enum={"Microsoft-PrometheusMetrics"}
type PrometheusForwarderDataSource_Streams string

const PrometheusForwarderDataSource_Streams_MicrosoftPrometheusMetrics = PrometheusForwarderDataSource_Streams("Microsoft-PrometheusMetrics")

// Mapping from string to PrometheusForwarderDataSource_Streams
var prometheusForwarderDataSource_Streams_Values = map[string]PrometheusForwarderDataSource_Streams{
	"microsoft-prometheusmetrics": PrometheusForwarderDataSource_Streams_MicrosoftPrometheusMetrics,
}

type PrometheusForwarderDataSource_Streams_STATUS string

const PrometheusForwarderDataSource_Streams_STATUS_MicrosoftPrometheusMetrics = PrometheusForwarderDataSource_Streams_STATUS("Microsoft-PrometheusMetrics")

// Mapping from string to PrometheusForwarderDataSource_Streams_STATUS
var prometheusForwarderDataSource_Streams_STATUS_Values = map[string]PrometheusForwarderDataSource_Streams_STATUS{
	"microsoft-prometheusmetrics": PrometheusForwarderDataSource_Streams_STATUS_MicrosoftPrometheusMetrics,
}

type StorageBlob struct {
	// BlobUrl: Url of the storage blob
	BlobUrl *string `json:"blobUrl,omitempty"`

	// LookupType: The type of lookup to perform on the blob
	LookupType *StorageBlob_LookupType `json:"lookupType,omitempty"`

	// Name: The name of the enrichment data source used as an alias when referencing this data source in data flows
	Name *string `json:"name,omitempty"`

	// ResourceReference: Resource Id of the storage account that hosts the blob
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceId" json:"resourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &StorageBlob{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (blob *StorageBlob) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if blob == nil {
		return nil, nil
	}
	result := &arm.StorageBlob{}

	// Set property "BlobUrl":
	if blob.BlobUrl != nil {
		blobUrl := *blob.BlobUrl
		result.BlobUrl = &blobUrl
	}

	// Set property "LookupType":
	if blob.LookupType != nil {
		var temp string
		temp = string(*blob.LookupType)
		lookupType := arm.StorageBlob_LookupType(temp)
		result.LookupType = &lookupType
	}

	// Set property "Name":
	if blob.Name != nil {
		name := *blob.Name
		result.Name = &name
	}

	// Set property "ResourceId":
	if blob.ResourceReference != nil {
		resourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*blob.ResourceReference)
		if err != nil {
			return nil, err
		}
		resourceReference := resourceReferenceARMID
		result.ResourceId = &resourceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (blob *StorageBlob) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.StorageBlob{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (blob *StorageBlob) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.StorageBlob)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.StorageBlob, got %T", armInput)
	}

	// Set property "BlobUrl":
	if typedInput.BlobUrl != nil {
		blobUrl := *typedInput.BlobUrl
		blob.BlobUrl = &blobUrl
	}

	// Set property "LookupType":
	if typedInput.LookupType != nil {
		var temp string
		temp = string(*typedInput.LookupType)
		lookupType := StorageBlob_LookupType(temp)
		blob.LookupType = &lookupType
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		blob.Name = &name
	}

	// no assignment for property "ResourceReference"

	// No error
	return nil
}

// AssignProperties_From_StorageBlob populates our StorageBlob from the provided source StorageBlob
func (blob *StorageBlob) AssignProperties_From_StorageBlob(source *storage.StorageBlob) error {

	// BlobUrl
	blob.BlobUrl = genruntime.ClonePointerToString(source.BlobUrl)

	// LookupType
	if source.LookupType != nil {
		lookupType := *source.LookupType
		lookupTypeTemp := genruntime.ToEnum(lookupType, storageBlob_LookupType_Values)
		blob.LookupType = &lookupTypeTemp
	} else {
		blob.LookupType = nil
	}

	// Name
	blob.Name = genruntime.ClonePointerToString(source.Name)

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		blob.ResourceReference = &resourceReference
	} else {
		blob.ResourceReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_StorageBlob populates the provided destination StorageBlob from our StorageBlob
func (blob *StorageBlob) AssignProperties_To_StorageBlob(destination *storage.StorageBlob) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BlobUrl
	destination.BlobUrl = genruntime.ClonePointerToString(blob.BlobUrl)

	// LookupType
	if blob.LookupType != nil {
		lookupType := string(*blob.LookupType)
		destination.LookupType = &lookupType
	} else {
		destination.LookupType = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(blob.Name)

	// ResourceReference
	if blob.ResourceReference != nil {
		resourceReference := blob.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_StorageBlob_STATUS populates our StorageBlob from the provided source StorageBlob_STATUS
func (blob *StorageBlob) Initialize_From_StorageBlob_STATUS(source *StorageBlob_STATUS) error {

	// BlobUrl
	blob.BlobUrl = genruntime.ClonePointerToString(source.BlobUrl)

	// LookupType
	if source.LookupType != nil {
		lookupType := genruntime.ToEnum(string(*source.LookupType), storageBlob_LookupType_Values)
		blob.LookupType = &lookupType
	} else {
		blob.LookupType = nil
	}

	// Name
	blob.Name = genruntime.ClonePointerToString(source.Name)

	// ResourceReference
	if source.ResourceId != nil {
		resourceReference := genruntime.CreateResourceReferenceFromARMID(*source.ResourceId)
		blob.ResourceReference = &resourceReference
	} else {
		blob.ResourceReference = nil
	}

	// No error
	return nil
}

type StorageBlob_STATUS struct {
	// BlobUrl: Url of the storage blob
	BlobUrl *string `json:"blobUrl,omitempty"`

	// LookupType: The type of lookup to perform on the blob
	LookupType *StorageBlob_LookupType_STATUS `json:"lookupType,omitempty"`

	// Name: The name of the enrichment data source used as an alias when referencing this data source in data flows
	Name *string `json:"name,omitempty"`

	// ResourceId: Resource Id of the storage account that hosts the blob
	ResourceId *string `json:"resourceId,omitempty"`
}

var _ genruntime.FromARMConverter = &StorageBlob_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (blob *StorageBlob_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.StorageBlob_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (blob *StorageBlob_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.StorageBlob_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.StorageBlob_STATUS, got %T", armInput)
	}

	// Set property "BlobUrl":
	if typedInput.BlobUrl != nil {
		blobUrl := *typedInput.BlobUrl
		blob.BlobUrl = &blobUrl
	}

	// Set property "LookupType":
	if typedInput.LookupType != nil {
		var temp string
		temp = string(*typedInput.LookupType)
		lookupType := StorageBlob_LookupType_STATUS(temp)
		blob.LookupType = &lookupType
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		blob.Name = &name
	}

	// Set property "ResourceId":
	if typedInput.ResourceId != nil {
		resourceId := *typedInput.ResourceId
		blob.ResourceId = &resourceId
	}

	// No error
	return nil
}

// AssignProperties_From_StorageBlob_STATUS populates our StorageBlob_STATUS from the provided source StorageBlob_STATUS
func (blob *StorageBlob_STATUS) AssignProperties_From_StorageBlob_STATUS(source *storage.StorageBlob_STATUS) error {

	// BlobUrl
	blob.BlobUrl = genruntime.ClonePointerToString(source.BlobUrl)

	// LookupType
	if source.LookupType != nil {
		lookupType := *source.LookupType
		lookupTypeTemp := genruntime.ToEnum(lookupType, storageBlob_LookupType_STATUS_Values)
		blob.LookupType = &lookupTypeTemp
	} else {
		blob.LookupType = nil
	}

	// Name
	blob.Name = genruntime.ClonePointerToString(source.Name)

	// ResourceId
	blob.ResourceId = genruntime.ClonePointerToString(source.ResourceId)

	// No error
	return nil
}

// AssignProperties_To_StorageBlob_STATUS populates the provided destination StorageBlob_STATUS from our StorageBlob_STATUS
func (blob *StorageBlob_STATUS) AssignProperties_To_StorageBlob_STATUS(destination *storage.StorageBlob_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BlobUrl
	destination.BlobUrl = genruntime.ClonePointerToString(blob.BlobUrl)

	// LookupType
	if blob.LookupType != nil {
		lookupType := string(*blob.LookupType)
		destination.LookupType = &lookupType
	} else {
		destination.LookupType = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(blob.Name)

	// ResourceId
	destination.ResourceId = genruntime.ClonePointerToString(blob.ResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"alert","audit","auth","authpriv","clock","cron","daemon","ftp","kern","local0","local1","local2","local3","local4","local5","local6","local7","lpr","mail","mark","news","nopri","ntp","*","syslog","user","uucp"}
type SyslogDataSource_FacilityNames string

const (
	SyslogDataSource_FacilityNames_Alert    = SyslogDataSource_FacilityNames("alert")
	SyslogDataSource_FacilityNames_Audit    = SyslogDataSource_FacilityNames("audit")
	SyslogDataSource_FacilityNames_Auth     = SyslogDataSource_FacilityNames("auth")
	SyslogDataSource_FacilityNames_Authpriv = SyslogDataSource_FacilityNames("authpriv")
	SyslogDataSource_FacilityNames_Clock    = SyslogDataSource_FacilityNames("clock")
	SyslogDataSource_FacilityNames_Cron     = SyslogDataSource_FacilityNames("cron")
	SyslogDataSource_FacilityNames_Daemon   = SyslogDataSource_FacilityNames("daemon")
	SyslogDataSource_FacilityNames_Ftp      = SyslogDataSource_FacilityNames("ftp")
	SyslogDataSource_FacilityNames_Kern     = SyslogDataSource_FacilityNames("kern")
	SyslogDataSource_FacilityNames_Local0   = SyslogDataSource_FacilityNames("local0")
	SyslogDataSource_FacilityNames_Local1   = SyslogDataSource_FacilityNames("local1")
	SyslogDataSource_FacilityNames_Local2   = SyslogDataSource_FacilityNames("local2")
	SyslogDataSource_FacilityNames_Local3   = SyslogDataSource_FacilityNames("local3")
	SyslogDataSource_FacilityNames_Local4   = SyslogDataSource_FacilityNames("local4")
	SyslogDataSource_FacilityNames_Local5   = SyslogDataSource_FacilityNames("local5")
	SyslogDataSource_FacilityNames_Local6   = SyslogDataSource_FacilityNames("local6")
	SyslogDataSource_FacilityNames_Local7   = SyslogDataSource_FacilityNames("local7")
	SyslogDataSource_FacilityNames_Lpr      = SyslogDataSource_FacilityNames("lpr")
	SyslogDataSource_FacilityNames_Mail     = SyslogDataSource_FacilityNames("mail")
	SyslogDataSource_FacilityNames_Mark     = SyslogDataSource_FacilityNames("mark")
	SyslogDataSource_FacilityNames_News     = SyslogDataSource_FacilityNames("news")
	SyslogDataSource_FacilityNames_Nopri    = SyslogDataSource_FacilityNames("nopri")
	SyslogDataSource_FacilityNames_Ntp      = SyslogDataSource_FacilityNames("ntp")
	SyslogDataSource_FacilityNames_Star     = SyslogDataSource_FacilityNames("*")
	SyslogDataSource_FacilityNames_Syslog   = SyslogDataSource_FacilityNames("syslog")
	SyslogDataSource_FacilityNames_User     = SyslogDataSource_FacilityNames("user")
	SyslogDataSource_FacilityNames_Uucp     = SyslogDataSource_FacilityNames("uucp")
)

// Mapping from string to SyslogDataSource_FacilityNames
var syslogDataSource_FacilityNames_Values = map[string]SyslogDataSource_FacilityNames{
	"alert":    SyslogDataSource_FacilityNames_Alert,
	"audit":    SyslogDataSource_FacilityNames_Audit,
	"auth":     SyslogDataSource_FacilityNames_Auth,
	"authpriv": SyslogDataSource_FacilityNames_Authpriv,
	"clock":    SyslogDataSource_FacilityNames_Clock,
	"cron":     SyslogDataSource_FacilityNames_Cron,
	"daemon":   SyslogDataSource_FacilityNames_Daemon,
	"ftp":      SyslogDataSource_FacilityNames_Ftp,
	"kern":     SyslogDataSource_FacilityNames_Kern,
	"local0":   SyslogDataSource_FacilityNames_Local0,
	"local1":   SyslogDataSource_FacilityNames_Local1,
	"local2":   SyslogDataSource_FacilityNames_Local2,
	"local3":   SyslogDataSource_FacilityNames_Local3,
	"local4":   SyslogDataSource_FacilityNames_Local4,
	"local5":   SyslogDataSource_FacilityNames_Local5,
	"local6":   SyslogDataSource_FacilityNames_Local6,
	"local7":   SyslogDataSource_FacilityNames_Local7,
	"lpr":      SyslogDataSource_FacilityNames_Lpr,
	"mail":     SyslogDataSource_FacilityNames_Mail,
	"mark":     SyslogDataSource_FacilityNames_Mark,
	"news":     SyslogDataSource_FacilityNames_News,
	"nopri":    SyslogDataSource_FacilityNames_Nopri,
	"ntp":      SyslogDataSource_FacilityNames_Ntp,
	"*":        SyslogDataSource_FacilityNames_Star,
	"syslog":   SyslogDataSource_FacilityNames_Syslog,
	"user":     SyslogDataSource_FacilityNames_User,
	"uucp":     SyslogDataSource_FacilityNames_Uucp,
}

type SyslogDataSource_FacilityNames_STATUS string

const (
	SyslogDataSource_FacilityNames_STATUS_Alert    = SyslogDataSource_FacilityNames_STATUS("alert")
	SyslogDataSource_FacilityNames_STATUS_Audit    = SyslogDataSource_FacilityNames_STATUS("audit")
	SyslogDataSource_FacilityNames_STATUS_Auth     = SyslogDataSource_FacilityNames_STATUS("auth")
	SyslogDataSource_FacilityNames_STATUS_Authpriv = SyslogDataSource_FacilityNames_STATUS("authpriv")
	SyslogDataSource_FacilityNames_STATUS_Clock    = SyslogDataSource_FacilityNames_STATUS("clock")
	SyslogDataSource_FacilityNames_STATUS_Cron     = SyslogDataSource_FacilityNames_STATUS("cron")
	SyslogDataSource_FacilityNames_STATUS_Daemon   = SyslogDataSource_FacilityNames_STATUS("daemon")
	SyslogDataSource_FacilityNames_STATUS_Ftp      = SyslogDataSource_FacilityNames_STATUS("ftp")
	SyslogDataSource_FacilityNames_STATUS_Kern     = SyslogDataSource_FacilityNames_STATUS("kern")
	SyslogDataSource_FacilityNames_STATUS_Local0   = SyslogDataSource_FacilityNames_STATUS("local0")
	SyslogDataSource_FacilityNames_STATUS_Local1   = SyslogDataSource_FacilityNames_STATUS("local1")
	SyslogDataSource_FacilityNames_STATUS_Local2   = SyslogDataSource_FacilityNames_STATUS("local2")
	SyslogDataSource_FacilityNames_STATUS_Local3   = SyslogDataSource_FacilityNames_STATUS("local3")
	SyslogDataSource_FacilityNames_STATUS_Local4   = SyslogDataSource_FacilityNames_STATUS("local4")
	SyslogDataSource_FacilityNames_STATUS_Local5   = SyslogDataSource_FacilityNames_STATUS("local5")
	SyslogDataSource_FacilityNames_STATUS_Local6   = SyslogDataSource_FacilityNames_STATUS("local6")
	SyslogDataSource_FacilityNames_STATUS_Local7   = SyslogDataSource_FacilityNames_STATUS("local7")
	SyslogDataSource_FacilityNames_STATUS_Lpr      = SyslogDataSource_FacilityNames_STATUS("lpr")
	SyslogDataSource_FacilityNames_STATUS_Mail     = SyslogDataSource_FacilityNames_STATUS("mail")
	SyslogDataSource_FacilityNames_STATUS_Mark     = SyslogDataSource_FacilityNames_STATUS("mark")
	SyslogDataSource_FacilityNames_STATUS_News     = SyslogDataSource_FacilityNames_STATUS("news")
	SyslogDataSource_FacilityNames_STATUS_Nopri    = SyslogDataSource_FacilityNames_STATUS("nopri")
	SyslogDataSource_FacilityNames_STATUS_Ntp      = SyslogDataSource_FacilityNames_STATUS("ntp")
	SyslogDataSource_FacilityNames_STATUS_Star     = SyslogDataSource_FacilityNames_STATUS("*")
	SyslogDataSource_FacilityNames_STATUS_Syslog   = SyslogDataSource_FacilityNames_STATUS("syslog")
	SyslogDataSource_FacilityNames_STATUS_User     = SyslogDataSource_FacilityNames_STATUS("user")
	SyslogDataSource_FacilityNames_STATUS_Uucp     = SyslogDataSource_FacilityNames_STATUS("uucp")
)

// Mapping from string to SyslogDataSource_FacilityNames_STATUS
var syslogDataSource_FacilityNames_STATUS_Values = map[string]SyslogDataSource_FacilityNames_STATUS{
	"alert":    SyslogDataSource_FacilityNames_STATUS_Alert,
	"audit":    SyslogDataSource_FacilityNames_STATUS_Audit,
	"auth":     SyslogDataSource_FacilityNames_STATUS_Auth,
	"authpriv": SyslogDataSource_FacilityNames_STATUS_Authpriv,
	"clock":    SyslogDataSource_FacilityNames_STATUS_Clock,
	"cron":     SyslogDataSource_FacilityNames_STATUS_Cron,
	"daemon":   SyslogDataSource_FacilityNames_STATUS_Daemon,
	"ftp":      SyslogDataSource_FacilityNames_STATUS_Ftp,
	"kern":     SyslogDataSource_FacilityNames_STATUS_Kern,
	"local0":   SyslogDataSource_FacilityNames_STATUS_Local0,
	"local1":   SyslogDataSource_FacilityNames_STATUS_Local1,
	"local2":   SyslogDataSource_FacilityNames_STATUS_Local2,
	"local3":   SyslogDataSource_FacilityNames_STATUS_Local3,
	"local4":   SyslogDataSource_FacilityNames_STATUS_Local4,
	"local5":   SyslogDataSource_FacilityNames_STATUS_Local5,
	"local6":   SyslogDataSource_FacilityNames_STATUS_Local6,
	"local7":   SyslogDataSource_FacilityNames_STATUS_Local7,
	"lpr":      SyslogDataSource_FacilityNames_STATUS_Lpr,
	"mail":     SyslogDataSource_FacilityNames_STATUS_Mail,
	"mark":     SyslogDataSource_FacilityNames_STATUS_Mark,
	"news":     SyslogDataSource_FacilityNames_STATUS_News,
	"nopri":    SyslogDataSource_FacilityNames_STATUS_Nopri,
	"ntp":      SyslogDataSource_FacilityNames_STATUS_Ntp,
	"*":        SyslogDataSource_FacilityNames_STATUS_Star,
	"syslog":   SyslogDataSource_FacilityNames_STATUS_Syslog,
	"user":     SyslogDataSource_FacilityNames_STATUS_User,
	"uucp":     SyslogDataSource_FacilityNames_STATUS_Uucp,
}

// +kubebuilder:validation:Enum={"Alert","Critical","Debug","Emergency","Error","Info","Notice","*","Warning"}
type SyslogDataSource_LogLevels string

const (
	SyslogDataSource_LogLevels_Alert     = SyslogDataSource_LogLevels("Alert")
	SyslogDataSource_LogLevels_Critical  = SyslogDataSource_LogLevels("Critical")
	SyslogDataSource_LogLevels_Debug     = SyslogDataSource_LogLevels("Debug")
	SyslogDataSource_LogLevels_Emergency = SyslogDataSource_LogLevels("Emergency")
	SyslogDataSource_LogLevels_Error     = SyslogDataSource_LogLevels("Error")
	SyslogDataSource_LogLevels_Info      = SyslogDataSource_LogLevels("Info")
	SyslogDataSource_LogLevels_Notice    = SyslogDataSource_LogLevels("Notice")
	SyslogDataSource_LogLevels_Star      = SyslogDataSource_LogLevels("*")
	SyslogDataSource_LogLevels_Warning   = SyslogDataSource_LogLevels("Warning")
)

// Mapping from string to SyslogDataSource_LogLevels
var syslogDataSource_LogLevels_Values = map[string]SyslogDataSource_LogLevels{
	"alert":     SyslogDataSource_LogLevels_Alert,
	"critical":  SyslogDataSource_LogLevels_Critical,
	"debug":     SyslogDataSource_LogLevels_Debug,
	"emergency": SyslogDataSource_LogLevels_Emergency,
	"error":     SyslogDataSource_LogLevels_Error,
	"info":      SyslogDataSource_LogLevels_Info,
	"notice":    SyslogDataSource_LogLevels_Notice,
	"*":         SyslogDataSource_LogLevels_Star,
	"warning":   SyslogDataSource_LogLevels_Warning,
}

type SyslogDataSource_LogLevels_STATUS string

const (
	SyslogDataSource_LogLevels_STATUS_Alert     = SyslogDataSource_LogLevels_STATUS("Alert")
	SyslogDataSource_LogLevels_STATUS_Critical  = SyslogDataSource_LogLevels_STATUS("Critical")
	SyslogDataSource_LogLevels_STATUS_Debug     = SyslogDataSource_LogLevels_STATUS("Debug")
	SyslogDataSource_LogLevels_STATUS_Emergency = SyslogDataSource_LogLevels_STATUS("Emergency")
	SyslogDataSource_LogLevels_STATUS_Error     = SyslogDataSource_LogLevels_STATUS("Error")
	SyslogDataSource_LogLevels_STATUS_Info      = SyslogDataSource_LogLevels_STATUS("Info")
	SyslogDataSource_LogLevels_STATUS_Notice    = SyslogDataSource_LogLevels_STATUS("Notice")
	SyslogDataSource_LogLevels_STATUS_Star      = SyslogDataSource_LogLevels_STATUS("*")
	SyslogDataSource_LogLevels_STATUS_Warning   = SyslogDataSource_LogLevels_STATUS("Warning")
)

// Mapping from string to SyslogDataSource_LogLevels_STATUS
var syslogDataSource_LogLevels_STATUS_Values = map[string]SyslogDataSource_LogLevels_STATUS{
	"alert":     SyslogDataSource_LogLevels_STATUS_Alert,
	"critical":  SyslogDataSource_LogLevels_STATUS_Critical,
	"debug":     SyslogDataSource_LogLevels_STATUS_Debug,
	"emergency": SyslogDataSource_LogLevels_STATUS_Emergency,
	"error":     SyslogDataSource_LogLevels_STATUS_Error,
	"info":      SyslogDataSource_LogLevels_STATUS_Info,
	"notice":    SyslogDataSource_LogLevels_STATUS_Notice,
	"*":         SyslogDataSource_LogLevels_STATUS_Star,
	"warning":   SyslogDataSource_LogLevels_STATUS_Warning,
}

// +kubebuilder:validation:Enum={"Microsoft-Syslog"}
type SyslogDataSource_Streams string

const SyslogDataSource_Streams_MicrosoftSyslog = SyslogDataSource_Streams("Microsoft-Syslog")

// Mapping from string to SyslogDataSource_Streams
var syslogDataSource_Streams_Values = map[string]SyslogDataSource_Streams{
	"microsoft-syslog": SyslogDataSource_Streams_MicrosoftSyslog,
}

type SyslogDataSource_Streams_STATUS string

const SyslogDataSource_Streams_STATUS_MicrosoftSyslog = SyslogDataSource_Streams_STATUS("Microsoft-Syslog")

// Mapping from string to SyslogDataSource_Streams_STATUS
var syslogDataSource_Streams_STATUS_Values = map[string]SyslogDataSource_Streams_STATUS{
	"microsoft-syslog": SyslogDataSource_Streams_STATUS_MicrosoftSyslog,
}

// +kubebuilder:validation:Enum={"Microsoft-Event","Microsoft-WindowsEvent"}
type WindowsEventLogDataSource_Streams string

const (
	WindowsEventLogDataSource_Streams_MicrosoftEvent        = WindowsEventLogDataSource_Streams("Microsoft-Event")
	WindowsEventLogDataSource_Streams_MicrosoftWindowsEvent = WindowsEventLogDataSource_Streams("Microsoft-WindowsEvent")
)

// Mapping from string to WindowsEventLogDataSource_Streams
var windowsEventLogDataSource_Streams_Values = map[string]WindowsEventLogDataSource_Streams{
	"microsoft-event":        WindowsEventLogDataSource_Streams_MicrosoftEvent,
	"microsoft-windowsevent": WindowsEventLogDataSource_Streams_MicrosoftWindowsEvent,
}

type WindowsEventLogDataSource_Streams_STATUS string

const (
	WindowsEventLogDataSource_Streams_STATUS_MicrosoftEvent        = WindowsEventLogDataSource_Streams_STATUS("Microsoft-Event")
	WindowsEventLogDataSource_Streams_STATUS_MicrosoftWindowsEvent = WindowsEventLogDataSource_Streams_STATUS("Microsoft-WindowsEvent")
)

// Mapping from string to WindowsEventLogDataSource_Streams_STATUS
var windowsEventLogDataSource_Streams_STATUS_Values = map[string]WindowsEventLogDataSource_Streams_STATUS{
	"microsoft-event":        WindowsEventLogDataSource_Streams_STATUS_MicrosoftEvent,
	"microsoft-windowsevent": WindowsEventLogDataSource_Streams_STATUS_MicrosoftWindowsEvent,
}

// +kubebuilder:validation:Enum={"Domain","Private","Public"}
type WindowsFirewallLogsDataSource_ProfileFilter string

const (
	WindowsFirewallLogsDataSource_ProfileFilter_Domain  = WindowsFirewallLogsDataSource_ProfileFilter("Domain")
	WindowsFirewallLogsDataSource_ProfileFilter_Private = WindowsFirewallLogsDataSource_ProfileFilter("Private")
	WindowsFirewallLogsDataSource_ProfileFilter_Public  = WindowsFirewallLogsDataSource_ProfileFilter("Public")
)

// Mapping from string to WindowsFirewallLogsDataSource_ProfileFilter
var windowsFirewallLogsDataSource_ProfileFilter_Values = map[string]WindowsFirewallLogsDataSource_ProfileFilter{
	"domain":  WindowsFirewallLogsDataSource_ProfileFilter_Domain,
	"private": WindowsFirewallLogsDataSource_ProfileFilter_Private,
	"public":  WindowsFirewallLogsDataSource_ProfileFilter_Public,
}

type WindowsFirewallLogsDataSource_ProfileFilter_STATUS string

const (
	WindowsFirewallLogsDataSource_ProfileFilter_STATUS_Domain  = WindowsFirewallLogsDataSource_ProfileFilter_STATUS("Domain")
	WindowsFirewallLogsDataSource_ProfileFilter_STATUS_Private = WindowsFirewallLogsDataSource_ProfileFilter_STATUS("Private")
	WindowsFirewallLogsDataSource_ProfileFilter_STATUS_Public  = WindowsFirewallLogsDataSource_ProfileFilter_STATUS("Public")
)

// Mapping from string to WindowsFirewallLogsDataSource_ProfileFilter_STATUS
var windowsFirewallLogsDataSource_ProfileFilter_STATUS_Values = map[string]WindowsFirewallLogsDataSource_ProfileFilter_STATUS{
	"domain":  WindowsFirewallLogsDataSource_ProfileFilter_STATUS_Domain,
	"private": WindowsFirewallLogsDataSource_ProfileFilter_STATUS_Private,
	"public":  WindowsFirewallLogsDataSource_ProfileFilter_STATUS_Public,
}

// Settings for text log files
type LogFileTextSettings struct {
	// +kubebuilder:validation:Required
	// RecordStartTimestampFormat: One of the supported timestamp formats
	RecordStartTimestampFormat *LogFileTextSettings_RecordStartTimestampFormat `json:"recordStartTimestampFormat,omitempty"`
}

var _ genruntime.ARMTransformer = &LogFileTextSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *LogFileTextSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &arm.LogFileTextSettings{}

	// Set property "RecordStartTimestampFormat":
	if settings.RecordStartTimestampFormat != nil {
		var temp string
		temp = string(*settings.RecordStartTimestampFormat)
		recordStartTimestampFormat := arm.LogFileTextSettings_RecordStartTimestampFormat(temp)
		result.RecordStartTimestampFormat = &recordStartTimestampFormat
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *LogFileTextSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.LogFileTextSettings{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *LogFileTextSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.LogFileTextSettings)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.LogFileTextSettings, got %T", armInput)
	}

	// Set property "RecordStartTimestampFormat":
	if typedInput.RecordStartTimestampFormat != nil {
		var temp string
		temp = string(*typedInput.RecordStartTimestampFormat)
		recordStartTimestampFormat := LogFileTextSettings_RecordStartTimestampFormat(temp)
		settings.RecordStartTimestampFormat = &recordStartTimestampFormat
	}

	// No error
	return nil
}

// AssignProperties_From_LogFileTextSettings populates our LogFileTextSettings from the provided source LogFileTextSettings
func (settings *LogFileTextSettings) AssignProperties_From_LogFileTextSettings(source *storage.LogFileTextSettings) error {

	// RecordStartTimestampFormat
	if source.RecordStartTimestampFormat != nil {
		recordStartTimestampFormat := *source.RecordStartTimestampFormat
		recordStartTimestampFormatTemp := genruntime.ToEnum(recordStartTimestampFormat, logFileTextSettings_RecordStartTimestampFormat_Values)
		settings.RecordStartTimestampFormat = &recordStartTimestampFormatTemp
	} else {
		settings.RecordStartTimestampFormat = nil
	}

	// No error
	return nil
}

// AssignProperties_To_LogFileTextSettings populates the provided destination LogFileTextSettings from our LogFileTextSettings
func (settings *LogFileTextSettings) AssignProperties_To_LogFileTextSettings(destination *storage.LogFileTextSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// RecordStartTimestampFormat
	if settings.RecordStartTimestampFormat != nil {
		recordStartTimestampFormat := string(*settings.RecordStartTimestampFormat)
		destination.RecordStartTimestampFormat = &recordStartTimestampFormat
	} else {
		destination.RecordStartTimestampFormat = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_LogFileTextSettings_STATUS populates our LogFileTextSettings from the provided source LogFileTextSettings_STATUS
func (settings *LogFileTextSettings) Initialize_From_LogFileTextSettings_STATUS(source *LogFileTextSettings_STATUS) error {

	// RecordStartTimestampFormat
	if source.RecordStartTimestampFormat != nil {
		recordStartTimestampFormat := genruntime.ToEnum(string(*source.RecordStartTimestampFormat), logFileTextSettings_RecordStartTimestampFormat_Values)
		settings.RecordStartTimestampFormat = &recordStartTimestampFormat
	} else {
		settings.RecordStartTimestampFormat = nil
	}

	// No error
	return nil
}

// Settings for text log files
type LogFileTextSettings_STATUS struct {
	// RecordStartTimestampFormat: One of the supported timestamp formats
	RecordStartTimestampFormat *LogFileTextSettings_RecordStartTimestampFormat_STATUS `json:"recordStartTimestampFormat,omitempty"`
}

var _ genruntime.FromARMConverter = &LogFileTextSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *LogFileTextSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.LogFileTextSettings_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *LogFileTextSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.LogFileTextSettings_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.LogFileTextSettings_STATUS, got %T", armInput)
	}

	// Set property "RecordStartTimestampFormat":
	if typedInput.RecordStartTimestampFormat != nil {
		var temp string
		temp = string(*typedInput.RecordStartTimestampFormat)
		recordStartTimestampFormat := LogFileTextSettings_RecordStartTimestampFormat_STATUS(temp)
		settings.RecordStartTimestampFormat = &recordStartTimestampFormat
	}

	// No error
	return nil
}

// AssignProperties_From_LogFileTextSettings_STATUS populates our LogFileTextSettings_STATUS from the provided source LogFileTextSettings_STATUS
func (settings *LogFileTextSettings_STATUS) AssignProperties_From_LogFileTextSettings_STATUS(source *storage.LogFileTextSettings_STATUS) error {

	// RecordStartTimestampFormat
	if source.RecordStartTimestampFormat != nil {
		recordStartTimestampFormat := *source.RecordStartTimestampFormat
		recordStartTimestampFormatTemp := genruntime.ToEnum(recordStartTimestampFormat, logFileTextSettings_RecordStartTimestampFormat_STATUS_Values)
		settings.RecordStartTimestampFormat = &recordStartTimestampFormatTemp
	} else {
		settings.RecordStartTimestampFormat = nil
	}

	// No error
	return nil
}

// AssignProperties_To_LogFileTextSettings_STATUS populates the provided destination LogFileTextSettings_STATUS from our LogFileTextSettings_STATUS
func (settings *LogFileTextSettings_STATUS) AssignProperties_To_LogFileTextSettings_STATUS(destination *storage.LogFileTextSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// RecordStartTimestampFormat
	if settings.RecordStartTimestampFormat != nil {
		recordStartTimestampFormat := string(*settings.RecordStartTimestampFormat)
		destination.RecordStartTimestampFormat = &recordStartTimestampFormat
	} else {
		destination.RecordStartTimestampFormat = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Cidr","String"}
type StorageBlob_LookupType string

const (
	StorageBlob_LookupType_Cidr   = StorageBlob_LookupType("Cidr")
	StorageBlob_LookupType_String = StorageBlob_LookupType("String")
)

// Mapping from string to StorageBlob_LookupType
var storageBlob_LookupType_Values = map[string]StorageBlob_LookupType{
	"cidr":   StorageBlob_LookupType_Cidr,
	"string": StorageBlob_LookupType_String,
}

type StorageBlob_LookupType_STATUS string

const (
	StorageBlob_LookupType_STATUS_Cidr   = StorageBlob_LookupType_STATUS("Cidr")
	StorageBlob_LookupType_STATUS_String = StorageBlob_LookupType_STATUS("String")
)

// Mapping from string to StorageBlob_LookupType_STATUS
var storageBlob_LookupType_STATUS_Values = map[string]StorageBlob_LookupType_STATUS{
	"cidr":   StorageBlob_LookupType_STATUS_Cidr,
	"string": StorageBlob_LookupType_STATUS_String,
}

// +kubebuilder:validation:Enum={"dd/MMM/yyyy:HH:mm:ss zzz","ddMMyy HH:mm:ss","ISO 8601","M/D/YYYY HH:MM:SS AM/PM","MMM d hh:mm:ss","Mon DD, YYYY HH:MM:SS","YYYY-MM-DD HH:MM:SS","yyMMdd HH:mm:ss","yyyy-MM-ddTHH:mm:ssK"}
type LogFileTextSettings_RecordStartTimestampFormat string

const (
	LogFileTextSettings_RecordStartTimestampFormat_DdMMMYyyyHHMmSsZzz = LogFileTextSettings_RecordStartTimestampFormat("dd/MMM/yyyy:HH:mm:ss zzz")
	LogFileTextSettings_RecordStartTimestampFormat_DdMMyyHHMmSs       = LogFileTextSettings_RecordStartTimestampFormat("ddMMyy HH:mm:ss")
	LogFileTextSettings_RecordStartTimestampFormat_ISO8601            = LogFileTextSettings_RecordStartTimestampFormat("ISO 8601")
	LogFileTextSettings_RecordStartTimestampFormat_MDYYYYHHMMSSAMPM   = LogFileTextSettings_RecordStartTimestampFormat("M/D/YYYY HH:MM:SS AM/PM")
	LogFileTextSettings_RecordStartTimestampFormat_MMMDHhMmSs         = LogFileTextSettings_RecordStartTimestampFormat("MMM d hh:mm:ss")
	LogFileTextSettings_RecordStartTimestampFormat_MonDDYYYYHHMMSS    = LogFileTextSettings_RecordStartTimestampFormat("Mon DD, YYYY HH:MM:SS")
	LogFileTextSettings_RecordStartTimestampFormat_YYYYMMDDHHMMSS     = LogFileTextSettings_RecordStartTimestampFormat("YYYY-MM-DD HH:MM:SS")
	LogFileTextSettings_RecordStartTimestampFormat_YyMMddHHMmSs       = LogFileTextSettings_RecordStartTimestampFormat("yyMMdd HH:mm:ss")
	LogFileTextSettings_RecordStartTimestampFormat_YyyyMMDdTHHMmSsK   = LogFileTextSettings_RecordStartTimestampFormat("yyyy-MM-ddTHH:mm:ssK")
)

// Mapping from string to LogFileTextSettings_RecordStartTimestampFormat
var logFileTextSettings_RecordStartTimestampFormat_Values = map[string]LogFileTextSettings_RecordStartTimestampFormat{
	"dd/mmm/yyyy:hh:mm:ss zzz": LogFileTextSettings_RecordStartTimestampFormat_DdMMMYyyyHHMmSsZzz,
	"ddmmyy hh:mm:ss":          LogFileTextSettings_RecordStartTimestampFormat_DdMMyyHHMmSs,
	"iso 8601":                 LogFileTextSettings_RecordStartTimestampFormat_ISO8601,
	"m/d/yyyy hh:mm:ss am/pm":  LogFileTextSettings_RecordStartTimestampFormat_MDYYYYHHMMSSAMPM,
	"mmm d hh:mm:ss":           LogFileTextSettings_RecordStartTimestampFormat_MMMDHhMmSs,
	"mon dd, yyyy hh:mm:ss":    LogFileTextSettings_RecordStartTimestampFormat_MonDDYYYYHHMMSS,
	"yyyy-mm-dd hh:mm:ss":      LogFileTextSettings_RecordStartTimestampFormat_YYYYMMDDHHMMSS,
	"yymmdd hh:mm:ss":          LogFileTextSettings_RecordStartTimestampFormat_YyMMddHHMmSs,
	"yyyy-mm-ddthh:mm:ssk":     LogFileTextSettings_RecordStartTimestampFormat_YyyyMMDdTHHMmSsK,
}

type LogFileTextSettings_RecordStartTimestampFormat_STATUS string

const (
	LogFileTextSettings_RecordStartTimestampFormat_STATUS_DdMMMYyyyHHMmSsZzz = LogFileTextSettings_RecordStartTimestampFormat_STATUS("dd/MMM/yyyy:HH:mm:ss zzz")
	LogFileTextSettings_RecordStartTimestampFormat_STATUS_DdMMyyHHMmSs       = LogFileTextSettings_RecordStartTimestampFormat_STATUS("ddMMyy HH:mm:ss")
	LogFileTextSettings_RecordStartTimestampFormat_STATUS_ISO8601            = LogFileTextSettings_RecordStartTimestampFormat_STATUS("ISO 8601")
	LogFileTextSettings_RecordStartTimestampFormat_STATUS_MDYYYYHHMMSSAMPM   = LogFileTextSettings_RecordStartTimestampFormat_STATUS("M/D/YYYY HH:MM:SS AM/PM")
	LogFileTextSettings_RecordStartTimestampFormat_STATUS_MMMDHhMmSs         = LogFileTextSettings_RecordStartTimestampFormat_STATUS("MMM d hh:mm:ss")
	LogFileTextSettings_RecordStartTimestampFormat_STATUS_MonDDYYYYHHMMSS    = LogFileTextSettings_RecordStartTimestampFormat_STATUS("Mon DD, YYYY HH:MM:SS")
	LogFileTextSettings_RecordStartTimestampFormat_STATUS_YYYYMMDDHHMMSS     = LogFileTextSettings_RecordStartTimestampFormat_STATUS("YYYY-MM-DD HH:MM:SS")
	LogFileTextSettings_RecordStartTimestampFormat_STATUS_YyMMddHHMmSs       = LogFileTextSettings_RecordStartTimestampFormat_STATUS("yyMMdd HH:mm:ss")
	LogFileTextSettings_RecordStartTimestampFormat_STATUS_YyyyMMDdTHHMmSsK   = LogFileTextSettings_RecordStartTimestampFormat_STATUS("yyyy-MM-ddTHH:mm:ssK")
)

// Mapping from string to LogFileTextSettings_RecordStartTimestampFormat_STATUS
var logFileTextSettings_RecordStartTimestampFormat_STATUS_Values = map[string]LogFileTextSettings_RecordStartTimestampFormat_STATUS{
	"dd/mmm/yyyy:hh:mm:ss zzz": LogFileTextSettings_RecordStartTimestampFormat_STATUS_DdMMMYyyyHHMmSsZzz,
	"ddmmyy hh:mm:ss":          LogFileTextSettings_RecordStartTimestampFormat_STATUS_DdMMyyHHMmSs,
	"iso 8601":                 LogFileTextSettings_RecordStartTimestampFormat_STATUS_ISO8601,
	"m/d/yyyy hh:mm:ss am/pm":  LogFileTextSettings_RecordStartTimestampFormat_STATUS_MDYYYYHHMMSSAMPM,
	"mmm d hh:mm:ss":           LogFileTextSettings_RecordStartTimestampFormat_STATUS_MMMDHhMmSs,
	"mon dd, yyyy hh:mm:ss":    LogFileTextSettings_RecordStartTimestampFormat_STATUS_MonDDYYYYHHMMSS,
	"yyyy-mm-dd hh:mm:ss":      LogFileTextSettings_RecordStartTimestampFormat_STATUS_YYYYMMDDHHMMSS,
	"yymmdd hh:mm:ss":          LogFileTextSettings_RecordStartTimestampFormat_STATUS_YyMMddHHMmSs,
	"yyyy-mm-ddthh:mm:ssk":     LogFileTextSettings_RecordStartTimestampFormat_STATUS_YyyyMMDdTHHMmSsK,
}

func init() {
	SchemeBuilder.Register(&DataCollectionRule{}, &DataCollectionRuleList{})
}
