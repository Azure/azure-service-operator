// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20230311

import (
	"encoding/json"
	storage "github.com/Azure/azure-service-operator/v2/api/insights/v1api20230311/storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_AdxDestination_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AdxDestination to AdxDestination via AssignProperties_To_AdxDestination & AssignProperties_From_AdxDestination returns original",
		prop.ForAll(RunPropertyAssignmentTestForAdxDestination, AdxDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAdxDestination tests if a specific instance of AdxDestination can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAdxDestination(subject AdxDestination) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AdxDestination
	err := copied.AssignProperties_To_AdxDestination(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AdxDestination
	err = actual.AssignProperties_From_AdxDestination(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AdxDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdxDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdxDestination, AdxDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdxDestination runs a test to see if a specific instance of AdxDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForAdxDestination(subject AdxDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdxDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdxDestination instances for property testing - lazily instantiated by AdxDestinationGenerator()
var adxDestinationGenerator gopter.Gen

// AdxDestinationGenerator returns a generator of AdxDestination instances for property testing.
func AdxDestinationGenerator() gopter.Gen {
	if adxDestinationGenerator != nil {
		return adxDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdxDestination(generators)
	adxDestinationGenerator = gen.Struct(reflect.TypeOf(AdxDestination{}), generators)

	return adxDestinationGenerator
}

// AddIndependentPropertyGeneratorsForAdxDestination is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdxDestination(gens map[string]gopter.Gen) {
	gens["DatabaseName"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_AdxDestination_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AdxDestination_STATUS to AdxDestination_STATUS via AssignProperties_To_AdxDestination_STATUS & AssignProperties_From_AdxDestination_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAdxDestination_STATUS, AdxDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAdxDestination_STATUS tests if a specific instance of AdxDestination_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAdxDestination_STATUS(subject AdxDestination_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AdxDestination_STATUS
	err := copied.AssignProperties_To_AdxDestination_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AdxDestination_STATUS
	err = actual.AssignProperties_From_AdxDestination_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AdxDestination_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdxDestination_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdxDestination_STATUS, AdxDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdxDestination_STATUS runs a test to see if a specific instance of AdxDestination_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAdxDestination_STATUS(subject AdxDestination_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdxDestination_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdxDestination_STATUS instances for property testing - lazily instantiated by
// AdxDestination_STATUSGenerator()
var adxDestination_STATUSGenerator gopter.Gen

// AdxDestination_STATUSGenerator returns a generator of AdxDestination_STATUS instances for property testing.
func AdxDestination_STATUSGenerator() gopter.Gen {
	if adxDestination_STATUSGenerator != nil {
		return adxDestination_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdxDestination_STATUS(generators)
	adxDestination_STATUSGenerator = gen.Struct(reflect.TypeOf(AdxDestination_STATUS{}), generators)

	return adxDestination_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAdxDestination_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdxDestination_STATUS(gens map[string]gopter.Gen) {
	gens["DatabaseName"] = gen.PtrOf(gen.AlphaString())
	gens["IngestionUri"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_AgentSetting_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AgentSetting to AgentSetting via AssignProperties_To_AgentSetting & AssignProperties_From_AgentSetting returns original",
		prop.ForAll(RunPropertyAssignmentTestForAgentSetting, AgentSettingGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAgentSetting tests if a specific instance of AgentSetting can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAgentSetting(subject AgentSetting) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AgentSetting
	err := copied.AssignProperties_To_AgentSetting(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AgentSetting
	err = actual.AssignProperties_From_AgentSetting(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AgentSetting_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AgentSetting via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAgentSetting, AgentSettingGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAgentSetting runs a test to see if a specific instance of AgentSetting round trips to JSON and back losslessly
func RunJSONSerializationTestForAgentSetting(subject AgentSetting) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AgentSetting
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AgentSetting instances for property testing - lazily instantiated by AgentSettingGenerator()
var agentSettingGenerator gopter.Gen

// AgentSettingGenerator returns a generator of AgentSetting instances for property testing.
func AgentSettingGenerator() gopter.Gen {
	if agentSettingGenerator != nil {
		return agentSettingGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAgentSetting(generators)
	agentSettingGenerator = gen.Struct(reflect.TypeOf(AgentSetting{}), generators)

	return agentSettingGenerator
}

// AddIndependentPropertyGeneratorsForAgentSetting is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAgentSetting(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(AgentSetting_Name_MaxDiskQuotaInMB, AgentSetting_Name_UseTimeReceivedForForwardedEvents))
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_AgentSetting_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AgentSetting_STATUS to AgentSetting_STATUS via AssignProperties_To_AgentSetting_STATUS & AssignProperties_From_AgentSetting_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAgentSetting_STATUS, AgentSetting_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAgentSetting_STATUS tests if a specific instance of AgentSetting_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAgentSetting_STATUS(subject AgentSetting_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AgentSetting_STATUS
	err := copied.AssignProperties_To_AgentSetting_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AgentSetting_STATUS
	err = actual.AssignProperties_From_AgentSetting_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AgentSetting_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AgentSetting_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAgentSetting_STATUS, AgentSetting_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAgentSetting_STATUS runs a test to see if a specific instance of AgentSetting_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAgentSetting_STATUS(subject AgentSetting_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AgentSetting_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AgentSetting_STATUS instances for property testing - lazily instantiated by
// AgentSetting_STATUSGenerator()
var agentSetting_STATUSGenerator gopter.Gen

// AgentSetting_STATUSGenerator returns a generator of AgentSetting_STATUS instances for property testing.
func AgentSetting_STATUSGenerator() gopter.Gen {
	if agentSetting_STATUSGenerator != nil {
		return agentSetting_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAgentSetting_STATUS(generators)
	agentSetting_STATUSGenerator = gen.Struct(reflect.TypeOf(AgentSetting_STATUS{}), generators)

	return agentSetting_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAgentSetting_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAgentSetting_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(AgentSetting_Name_STATUS_MaxDiskQuotaInMB, AgentSetting_Name_STATUS_UseTimeReceivedForForwardedEvents))
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_AgentSettingsSpec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AgentSettingsSpec to AgentSettingsSpec via AssignProperties_To_AgentSettingsSpec & AssignProperties_From_AgentSettingsSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForAgentSettingsSpec, AgentSettingsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAgentSettingsSpec tests if a specific instance of AgentSettingsSpec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAgentSettingsSpec(subject AgentSettingsSpec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AgentSettingsSpec
	err := copied.AssignProperties_To_AgentSettingsSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AgentSettingsSpec
	err = actual.AssignProperties_From_AgentSettingsSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AgentSettingsSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AgentSettingsSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAgentSettingsSpec, AgentSettingsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAgentSettingsSpec runs a test to see if a specific instance of AgentSettingsSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForAgentSettingsSpec(subject AgentSettingsSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AgentSettingsSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AgentSettingsSpec instances for property testing - lazily instantiated by AgentSettingsSpecGenerator()
var agentSettingsSpecGenerator gopter.Gen

// AgentSettingsSpecGenerator returns a generator of AgentSettingsSpec instances for property testing.
func AgentSettingsSpecGenerator() gopter.Gen {
	if agentSettingsSpecGenerator != nil {
		return agentSettingsSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForAgentSettingsSpec(generators)
	agentSettingsSpecGenerator = gen.Struct(reflect.TypeOf(AgentSettingsSpec{}), generators)

	return agentSettingsSpecGenerator
}

// AddRelatedPropertyGeneratorsForAgentSettingsSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAgentSettingsSpec(gens map[string]gopter.Gen) {
	gens["Logs"] = gen.SliceOf(AgentSettingGenerator())
}

func Test_AgentSettingsSpec_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AgentSettingsSpec_STATUS to AgentSettingsSpec_STATUS via AssignProperties_To_AgentSettingsSpec_STATUS & AssignProperties_From_AgentSettingsSpec_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAgentSettingsSpec_STATUS, AgentSettingsSpec_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAgentSettingsSpec_STATUS tests if a specific instance of AgentSettingsSpec_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAgentSettingsSpec_STATUS(subject AgentSettingsSpec_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AgentSettingsSpec_STATUS
	err := copied.AssignProperties_To_AgentSettingsSpec_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AgentSettingsSpec_STATUS
	err = actual.AssignProperties_From_AgentSettingsSpec_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AgentSettingsSpec_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AgentSettingsSpec_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAgentSettingsSpec_STATUS, AgentSettingsSpec_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAgentSettingsSpec_STATUS runs a test to see if a specific instance of AgentSettingsSpec_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAgentSettingsSpec_STATUS(subject AgentSettingsSpec_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AgentSettingsSpec_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AgentSettingsSpec_STATUS instances for property testing - lazily instantiated by
// AgentSettingsSpec_STATUSGenerator()
var agentSettingsSpec_STATUSGenerator gopter.Gen

// AgentSettingsSpec_STATUSGenerator returns a generator of AgentSettingsSpec_STATUS instances for property testing.
func AgentSettingsSpec_STATUSGenerator() gopter.Gen {
	if agentSettingsSpec_STATUSGenerator != nil {
		return agentSettingsSpec_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForAgentSettingsSpec_STATUS(generators)
	agentSettingsSpec_STATUSGenerator = gen.Struct(reflect.TypeOf(AgentSettingsSpec_STATUS{}), generators)

	return agentSettingsSpec_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForAgentSettingsSpec_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAgentSettingsSpec_STATUS(gens map[string]gopter.Gen) {
	gens["Logs"] = gen.SliceOf(AgentSetting_STATUSGenerator())
}

func Test_AzureMonitorMetricsDestination_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AzureMonitorMetricsDestination to AzureMonitorMetricsDestination via AssignProperties_To_AzureMonitorMetricsDestination & AssignProperties_From_AzureMonitorMetricsDestination returns original",
		prop.ForAll(RunPropertyAssignmentTestForAzureMonitorMetricsDestination, AzureMonitorMetricsDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAzureMonitorMetricsDestination tests if a specific instance of AzureMonitorMetricsDestination can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAzureMonitorMetricsDestination(subject AzureMonitorMetricsDestination) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AzureMonitorMetricsDestination
	err := copied.AssignProperties_To_AzureMonitorMetricsDestination(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AzureMonitorMetricsDestination
	err = actual.AssignProperties_From_AzureMonitorMetricsDestination(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AzureMonitorMetricsDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureMonitorMetricsDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureMonitorMetricsDestination, AzureMonitorMetricsDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureMonitorMetricsDestination runs a test to see if a specific instance of AzureMonitorMetricsDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureMonitorMetricsDestination(subject AzureMonitorMetricsDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureMonitorMetricsDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureMonitorMetricsDestination instances for property testing - lazily instantiated by
// AzureMonitorMetricsDestinationGenerator()
var azureMonitorMetricsDestinationGenerator gopter.Gen

// AzureMonitorMetricsDestinationGenerator returns a generator of AzureMonitorMetricsDestination instances for property testing.
func AzureMonitorMetricsDestinationGenerator() gopter.Gen {
	if azureMonitorMetricsDestinationGenerator != nil {
		return azureMonitorMetricsDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureMonitorMetricsDestination(generators)
	azureMonitorMetricsDestinationGenerator = gen.Struct(reflect.TypeOf(AzureMonitorMetricsDestination{}), generators)

	return azureMonitorMetricsDestinationGenerator
}

// AddIndependentPropertyGeneratorsForAzureMonitorMetricsDestination is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureMonitorMetricsDestination(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_AzureMonitorMetricsDestination_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AzureMonitorMetricsDestination_STATUS to AzureMonitorMetricsDestination_STATUS via AssignProperties_To_AzureMonitorMetricsDestination_STATUS & AssignProperties_From_AzureMonitorMetricsDestination_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAzureMonitorMetricsDestination_STATUS, AzureMonitorMetricsDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAzureMonitorMetricsDestination_STATUS tests if a specific instance of AzureMonitorMetricsDestination_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAzureMonitorMetricsDestination_STATUS(subject AzureMonitorMetricsDestination_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AzureMonitorMetricsDestination_STATUS
	err := copied.AssignProperties_To_AzureMonitorMetricsDestination_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AzureMonitorMetricsDestination_STATUS
	err = actual.AssignProperties_From_AzureMonitorMetricsDestination_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AzureMonitorMetricsDestination_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureMonitorMetricsDestination_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureMonitorMetricsDestination_STATUS, AzureMonitorMetricsDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureMonitorMetricsDestination_STATUS runs a test to see if a specific instance of AzureMonitorMetricsDestination_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureMonitorMetricsDestination_STATUS(subject AzureMonitorMetricsDestination_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureMonitorMetricsDestination_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureMonitorMetricsDestination_STATUS instances for property testing - lazily instantiated by
// AzureMonitorMetricsDestination_STATUSGenerator()
var azureMonitorMetricsDestination_STATUSGenerator gopter.Gen

// AzureMonitorMetricsDestination_STATUSGenerator returns a generator of AzureMonitorMetricsDestination_STATUS instances for property testing.
func AzureMonitorMetricsDestination_STATUSGenerator() gopter.Gen {
	if azureMonitorMetricsDestination_STATUSGenerator != nil {
		return azureMonitorMetricsDestination_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureMonitorMetricsDestination_STATUS(generators)
	azureMonitorMetricsDestination_STATUSGenerator = gen.Struct(reflect.TypeOf(AzureMonitorMetricsDestination_STATUS{}), generators)

	return azureMonitorMetricsDestination_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAzureMonitorMetricsDestination_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureMonitorMetricsDestination_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_ColumnDefinition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ColumnDefinition to ColumnDefinition via AssignProperties_To_ColumnDefinition & AssignProperties_From_ColumnDefinition returns original",
		prop.ForAll(RunPropertyAssignmentTestForColumnDefinition, ColumnDefinitionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForColumnDefinition tests if a specific instance of ColumnDefinition can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForColumnDefinition(subject ColumnDefinition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ColumnDefinition
	err := copied.AssignProperties_To_ColumnDefinition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ColumnDefinition
	err = actual.AssignProperties_From_ColumnDefinition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ColumnDefinition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ColumnDefinition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForColumnDefinition, ColumnDefinitionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForColumnDefinition runs a test to see if a specific instance of ColumnDefinition round trips to JSON and back losslessly
func RunJSONSerializationTestForColumnDefinition(subject ColumnDefinition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ColumnDefinition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ColumnDefinition instances for property testing - lazily instantiated by ColumnDefinitionGenerator()
var columnDefinitionGenerator gopter.Gen

// ColumnDefinitionGenerator returns a generator of ColumnDefinition instances for property testing.
func ColumnDefinitionGenerator() gopter.Gen {
	if columnDefinitionGenerator != nil {
		return columnDefinitionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForColumnDefinition(generators)
	columnDefinitionGenerator = gen.Struct(reflect.TypeOf(ColumnDefinition{}), generators)

	return columnDefinitionGenerator
}

// AddIndependentPropertyGeneratorsForColumnDefinition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForColumnDefinition(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ColumnDefinition_Type_Boolean,
		ColumnDefinition_Type_Datetime,
		ColumnDefinition_Type_Dynamic,
		ColumnDefinition_Type_Int,
		ColumnDefinition_Type_Long,
		ColumnDefinition_Type_Real,
		ColumnDefinition_Type_String))
}

func Test_ColumnDefinition_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ColumnDefinition_STATUS to ColumnDefinition_STATUS via AssignProperties_To_ColumnDefinition_STATUS & AssignProperties_From_ColumnDefinition_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForColumnDefinition_STATUS, ColumnDefinition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForColumnDefinition_STATUS tests if a specific instance of ColumnDefinition_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForColumnDefinition_STATUS(subject ColumnDefinition_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ColumnDefinition_STATUS
	err := copied.AssignProperties_To_ColumnDefinition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ColumnDefinition_STATUS
	err = actual.AssignProperties_From_ColumnDefinition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ColumnDefinition_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ColumnDefinition_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForColumnDefinition_STATUS, ColumnDefinition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForColumnDefinition_STATUS runs a test to see if a specific instance of ColumnDefinition_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForColumnDefinition_STATUS(subject ColumnDefinition_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ColumnDefinition_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ColumnDefinition_STATUS instances for property testing - lazily instantiated by
// ColumnDefinition_STATUSGenerator()
var columnDefinition_STATUSGenerator gopter.Gen

// ColumnDefinition_STATUSGenerator returns a generator of ColumnDefinition_STATUS instances for property testing.
func ColumnDefinition_STATUSGenerator() gopter.Gen {
	if columnDefinition_STATUSGenerator != nil {
		return columnDefinition_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForColumnDefinition_STATUS(generators)
	columnDefinition_STATUSGenerator = gen.Struct(reflect.TypeOf(ColumnDefinition_STATUS{}), generators)

	return columnDefinition_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForColumnDefinition_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForColumnDefinition_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ColumnDefinition_Type_STATUS_Boolean,
		ColumnDefinition_Type_STATUS_Datetime,
		ColumnDefinition_Type_STATUS_Dynamic,
		ColumnDefinition_Type_STATUS_Int,
		ColumnDefinition_Type_STATUS_Long,
		ColumnDefinition_Type_STATUS_Real,
		ColumnDefinition_Type_STATUS_String))
}

func Test_DataCollectionRule_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	parameters.MinSuccessfulTests = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DataCollectionRule to hub returns original",
		prop.ForAll(RunResourceConversionTestForDataCollectionRule, DataCollectionRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForDataCollectionRule tests if a specific instance of DataCollectionRule round trips to the hub storage version and back losslessly
func RunResourceConversionTestForDataCollectionRule(subject DataCollectionRule) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub storage.DataCollectionRule
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual DataCollectionRule
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DataCollectionRule_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DataCollectionRule to DataCollectionRule via AssignProperties_To_DataCollectionRule & AssignProperties_From_DataCollectionRule returns original",
		prop.ForAll(RunPropertyAssignmentTestForDataCollectionRule, DataCollectionRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDataCollectionRule tests if a specific instance of DataCollectionRule can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForDataCollectionRule(subject DataCollectionRule) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.DataCollectionRule
	err := copied.AssignProperties_To_DataCollectionRule(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DataCollectionRule
	err = actual.AssignProperties_From_DataCollectionRule(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DataCollectionRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataCollectionRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataCollectionRule, DataCollectionRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataCollectionRule runs a test to see if a specific instance of DataCollectionRule round trips to JSON and back losslessly
func RunJSONSerializationTestForDataCollectionRule(subject DataCollectionRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataCollectionRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataCollectionRule instances for property testing - lazily instantiated by DataCollectionRuleGenerator()
var dataCollectionRuleGenerator gopter.Gen

// DataCollectionRuleGenerator returns a generator of DataCollectionRule instances for property testing.
func DataCollectionRuleGenerator() gopter.Gen {
	if dataCollectionRuleGenerator != nil {
		return dataCollectionRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDataCollectionRule(generators)
	dataCollectionRuleGenerator = gen.Struct(reflect.TypeOf(DataCollectionRule{}), generators)

	return dataCollectionRuleGenerator
}

// AddRelatedPropertyGeneratorsForDataCollectionRule is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataCollectionRule(gens map[string]gopter.Gen) {
	gens["Spec"] = DataCollectionRule_SpecGenerator()
	gens["Status"] = DataCollectionRuleResource_STATUSGenerator()
}

func Test_DataCollectionRuleOperatorSpec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DataCollectionRuleOperatorSpec to DataCollectionRuleOperatorSpec via AssignProperties_To_DataCollectionRuleOperatorSpec & AssignProperties_From_DataCollectionRuleOperatorSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForDataCollectionRuleOperatorSpec, DataCollectionRuleOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDataCollectionRuleOperatorSpec tests if a specific instance of DataCollectionRuleOperatorSpec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForDataCollectionRuleOperatorSpec(subject DataCollectionRuleOperatorSpec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.DataCollectionRuleOperatorSpec
	err := copied.AssignProperties_To_DataCollectionRuleOperatorSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DataCollectionRuleOperatorSpec
	err = actual.AssignProperties_From_DataCollectionRuleOperatorSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DataCollectionRuleOperatorSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataCollectionRuleOperatorSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataCollectionRuleOperatorSpec, DataCollectionRuleOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataCollectionRuleOperatorSpec runs a test to see if a specific instance of DataCollectionRuleOperatorSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForDataCollectionRuleOperatorSpec(subject DataCollectionRuleOperatorSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataCollectionRuleOperatorSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataCollectionRuleOperatorSpec instances for property testing - lazily instantiated by
// DataCollectionRuleOperatorSpecGenerator()
var dataCollectionRuleOperatorSpecGenerator gopter.Gen

// DataCollectionRuleOperatorSpecGenerator returns a generator of DataCollectionRuleOperatorSpec instances for property testing.
func DataCollectionRuleOperatorSpecGenerator() gopter.Gen {
	if dataCollectionRuleOperatorSpecGenerator != nil {
		return dataCollectionRuleOperatorSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	dataCollectionRuleOperatorSpecGenerator = gen.Struct(reflect.TypeOf(DataCollectionRuleOperatorSpec{}), generators)

	return dataCollectionRuleOperatorSpecGenerator
}

func Test_DataCollectionRuleResource_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DataCollectionRuleResource_STATUS to DataCollectionRuleResource_STATUS via AssignProperties_To_DataCollectionRuleResource_STATUS & AssignProperties_From_DataCollectionRuleResource_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDataCollectionRuleResource_STATUS, DataCollectionRuleResource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDataCollectionRuleResource_STATUS tests if a specific instance of DataCollectionRuleResource_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForDataCollectionRuleResource_STATUS(subject DataCollectionRuleResource_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.DataCollectionRuleResource_STATUS
	err := copied.AssignProperties_To_DataCollectionRuleResource_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DataCollectionRuleResource_STATUS
	err = actual.AssignProperties_From_DataCollectionRuleResource_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DataCollectionRuleResource_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataCollectionRuleResource_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataCollectionRuleResource_STATUS, DataCollectionRuleResource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataCollectionRuleResource_STATUS runs a test to see if a specific instance of DataCollectionRuleResource_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDataCollectionRuleResource_STATUS(subject DataCollectionRuleResource_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataCollectionRuleResource_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataCollectionRuleResource_STATUS instances for property testing - lazily instantiated by
// DataCollectionRuleResource_STATUSGenerator()
var dataCollectionRuleResource_STATUSGenerator gopter.Gen

// DataCollectionRuleResource_STATUSGenerator returns a generator of DataCollectionRuleResource_STATUS instances for property testing.
// We first initialize dataCollectionRuleResource_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DataCollectionRuleResource_STATUSGenerator() gopter.Gen {
	if dataCollectionRuleResource_STATUSGenerator != nil {
		return dataCollectionRuleResource_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataCollectionRuleResource_STATUS(generators)
	dataCollectionRuleResource_STATUSGenerator = gen.Struct(reflect.TypeOf(DataCollectionRuleResource_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataCollectionRuleResource_STATUS(generators)
	AddRelatedPropertyGeneratorsForDataCollectionRuleResource_STATUS(generators)
	dataCollectionRuleResource_STATUSGenerator = gen.Struct(reflect.TypeOf(DataCollectionRuleResource_STATUS{}), generators)

	return dataCollectionRuleResource_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDataCollectionRuleResource_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDataCollectionRuleResource_STATUS(gens map[string]gopter.Gen) {
	gens["DataCollectionEndpointId"] = gen.PtrOf(gen.AlphaString())
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["ImmutableId"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(DataCollectionRuleResource_Kind_STATUS_Linux, DataCollectionRuleResource_Kind_STATUS_Windows))
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		DataCollectionRule_ProvisioningState_STATUS_Canceled,
		DataCollectionRule_ProvisioningState_STATUS_Creating,
		DataCollectionRule_ProvisioningState_STATUS_Deleting,
		DataCollectionRule_ProvisioningState_STATUS_Failed,
		DataCollectionRule_ProvisioningState_STATUS_Succeeded,
		DataCollectionRule_ProvisioningState_STATUS_Updating))
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDataCollectionRuleResource_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataCollectionRuleResource_STATUS(gens map[string]gopter.Gen) {
	gens["AgentSettings"] = gen.PtrOf(AgentSettingsSpec_STATUSGenerator())
	gens["DataFlows"] = gen.SliceOf(DataFlow_STATUSGenerator())
	gens["DataSources"] = gen.PtrOf(DataSourcesSpec_STATUSGenerator())
	gens["Destinations"] = gen.PtrOf(DestinationsSpec_STATUSGenerator())
	gens["Endpoints"] = gen.PtrOf(EndpointsSpec_STATUSGenerator())
	gens["Identity"] = gen.PtrOf(ManagedServiceIdentity_STATUSGenerator())
	gens["Metadata"] = gen.PtrOf(Metadata_STATUSGenerator())
	gens["References"] = gen.PtrOf(ReferencesSpec_STATUSGenerator())
	gens["StreamDeclarations"] = gen.MapOf(
		gen.AlphaString(),
		StreamDeclaration_STATUSGenerator())
	gens["SystemData"] = gen.PtrOf(SystemData_STATUSGenerator())
}

func Test_DataCollectionRule_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DataCollectionRule_Spec to DataCollectionRule_Spec via AssignProperties_To_DataCollectionRule_Spec & AssignProperties_From_DataCollectionRule_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForDataCollectionRule_Spec, DataCollectionRule_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDataCollectionRule_Spec tests if a specific instance of DataCollectionRule_Spec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForDataCollectionRule_Spec(subject DataCollectionRule_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.DataCollectionRule_Spec
	err := copied.AssignProperties_To_DataCollectionRule_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DataCollectionRule_Spec
	err = actual.AssignProperties_From_DataCollectionRule_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DataCollectionRule_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataCollectionRule_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataCollectionRule_Spec, DataCollectionRule_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataCollectionRule_Spec runs a test to see if a specific instance of DataCollectionRule_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForDataCollectionRule_Spec(subject DataCollectionRule_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataCollectionRule_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataCollectionRule_Spec instances for property testing - lazily instantiated by
// DataCollectionRule_SpecGenerator()
var dataCollectionRule_SpecGenerator gopter.Gen

// DataCollectionRule_SpecGenerator returns a generator of DataCollectionRule_Spec instances for property testing.
// We first initialize dataCollectionRule_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DataCollectionRule_SpecGenerator() gopter.Gen {
	if dataCollectionRule_SpecGenerator != nil {
		return dataCollectionRule_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataCollectionRule_Spec(generators)
	dataCollectionRule_SpecGenerator = gen.Struct(reflect.TypeOf(DataCollectionRule_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataCollectionRule_Spec(generators)
	AddRelatedPropertyGeneratorsForDataCollectionRule_Spec(generators)
	dataCollectionRule_SpecGenerator = gen.Struct(reflect.TypeOf(DataCollectionRule_Spec{}), generators)

	return dataCollectionRule_SpecGenerator
}

// AddIndependentPropertyGeneratorsForDataCollectionRule_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDataCollectionRule_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(DataCollectionRule_Kind_Spec_Linux, DataCollectionRule_Kind_Spec_Windows))
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDataCollectionRule_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataCollectionRule_Spec(gens map[string]gopter.Gen) {
	gens["AgentSettings"] = gen.PtrOf(AgentSettingsSpecGenerator())
	gens["DataFlows"] = gen.SliceOf(DataFlowGenerator())
	gens["DataSources"] = gen.PtrOf(DataSourcesSpecGenerator())
	gens["Destinations"] = gen.PtrOf(DestinationsSpecGenerator())
	gens["Identity"] = gen.PtrOf(ManagedServiceIdentityGenerator())
	gens["OperatorSpec"] = gen.PtrOf(DataCollectionRuleOperatorSpecGenerator())
	gens["References"] = gen.PtrOf(ReferencesSpecGenerator())
	gens["StreamDeclarations"] = gen.MapOf(
		gen.AlphaString(),
		StreamDeclarationGenerator())
}

func Test_DataFlow_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DataFlow to DataFlow via AssignProperties_To_DataFlow & AssignProperties_From_DataFlow returns original",
		prop.ForAll(RunPropertyAssignmentTestForDataFlow, DataFlowGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDataFlow tests if a specific instance of DataFlow can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForDataFlow(subject DataFlow) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.DataFlow
	err := copied.AssignProperties_To_DataFlow(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DataFlow
	err = actual.AssignProperties_From_DataFlow(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DataFlow_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataFlow via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataFlow, DataFlowGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataFlow runs a test to see if a specific instance of DataFlow round trips to JSON and back losslessly
func RunJSONSerializationTestForDataFlow(subject DataFlow) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataFlow
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataFlow instances for property testing - lazily instantiated by DataFlowGenerator()
var dataFlowGenerator gopter.Gen

// DataFlowGenerator returns a generator of DataFlow instances for property testing.
func DataFlowGenerator() gopter.Gen {
	if dataFlowGenerator != nil {
		return dataFlowGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataFlow(generators)
	dataFlowGenerator = gen.Struct(reflect.TypeOf(DataFlow{}), generators)

	return dataFlowGenerator
}

// AddIndependentPropertyGeneratorsForDataFlow is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDataFlow(gens map[string]gopter.Gen) {
	gens["BuiltInTransform"] = gen.PtrOf(gen.AlphaString())
	gens["CaptureOverflow"] = gen.PtrOf(gen.Bool())
	gens["Destinations"] = gen.SliceOf(gen.AlphaString())
	gens["OutputStream"] = gen.PtrOf(gen.AlphaString())
	gens["Streams"] = gen.SliceOf(gen.OneConstOf(
		DataFlow_Streams_MicrosoftEvent,
		DataFlow_Streams_MicrosoftInsightsMetrics,
		DataFlow_Streams_MicrosoftPerf,
		DataFlow_Streams_MicrosoftSyslog,
		DataFlow_Streams_MicrosoftWindowsEvent))
	gens["TransformKql"] = gen.PtrOf(gen.AlphaString())
}

func Test_DataFlow_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DataFlow_STATUS to DataFlow_STATUS via AssignProperties_To_DataFlow_STATUS & AssignProperties_From_DataFlow_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDataFlow_STATUS, DataFlow_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDataFlow_STATUS tests if a specific instance of DataFlow_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForDataFlow_STATUS(subject DataFlow_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.DataFlow_STATUS
	err := copied.AssignProperties_To_DataFlow_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DataFlow_STATUS
	err = actual.AssignProperties_From_DataFlow_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DataFlow_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataFlow_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataFlow_STATUS, DataFlow_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataFlow_STATUS runs a test to see if a specific instance of DataFlow_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDataFlow_STATUS(subject DataFlow_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataFlow_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataFlow_STATUS instances for property testing - lazily instantiated by DataFlow_STATUSGenerator()
var dataFlow_STATUSGenerator gopter.Gen

// DataFlow_STATUSGenerator returns a generator of DataFlow_STATUS instances for property testing.
func DataFlow_STATUSGenerator() gopter.Gen {
	if dataFlow_STATUSGenerator != nil {
		return dataFlow_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataFlow_STATUS(generators)
	dataFlow_STATUSGenerator = gen.Struct(reflect.TypeOf(DataFlow_STATUS{}), generators)

	return dataFlow_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDataFlow_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDataFlow_STATUS(gens map[string]gopter.Gen) {
	gens["BuiltInTransform"] = gen.PtrOf(gen.AlphaString())
	gens["CaptureOverflow"] = gen.PtrOf(gen.Bool())
	gens["Destinations"] = gen.SliceOf(gen.AlphaString())
	gens["OutputStream"] = gen.PtrOf(gen.AlphaString())
	gens["Streams"] = gen.SliceOf(gen.OneConstOf(
		DataFlow_Streams_STATUS_MicrosoftEvent,
		DataFlow_Streams_STATUS_MicrosoftInsightsMetrics,
		DataFlow_Streams_STATUS_MicrosoftPerf,
		DataFlow_Streams_STATUS_MicrosoftSyslog,
		DataFlow_Streams_STATUS_MicrosoftWindowsEvent))
	gens["TransformKql"] = gen.PtrOf(gen.AlphaString())
}

func Test_DataImportSources_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DataImportSources to DataImportSources via AssignProperties_To_DataImportSources & AssignProperties_From_DataImportSources returns original",
		prop.ForAll(RunPropertyAssignmentTestForDataImportSources, DataImportSourcesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDataImportSources tests if a specific instance of DataImportSources can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForDataImportSources(subject DataImportSources) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.DataImportSources
	err := copied.AssignProperties_To_DataImportSources(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DataImportSources
	err = actual.AssignProperties_From_DataImportSources(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DataImportSources_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataImportSources via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataImportSources, DataImportSourcesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataImportSources runs a test to see if a specific instance of DataImportSources round trips to JSON and back losslessly
func RunJSONSerializationTestForDataImportSources(subject DataImportSources) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataImportSources
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataImportSources instances for property testing - lazily instantiated by DataImportSourcesGenerator()
var dataImportSourcesGenerator gopter.Gen

// DataImportSourcesGenerator returns a generator of DataImportSources instances for property testing.
func DataImportSourcesGenerator() gopter.Gen {
	if dataImportSourcesGenerator != nil {
		return dataImportSourcesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDataImportSources(generators)
	dataImportSourcesGenerator = gen.Struct(reflect.TypeOf(DataImportSources{}), generators)

	return dataImportSourcesGenerator
}

// AddRelatedPropertyGeneratorsForDataImportSources is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataImportSources(gens map[string]gopter.Gen) {
	gens["EventHub"] = gen.PtrOf(EventHubDataSourceGenerator())
}

func Test_DataImportSources_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DataImportSources_STATUS to DataImportSources_STATUS via AssignProperties_To_DataImportSources_STATUS & AssignProperties_From_DataImportSources_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDataImportSources_STATUS, DataImportSources_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDataImportSources_STATUS tests if a specific instance of DataImportSources_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForDataImportSources_STATUS(subject DataImportSources_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.DataImportSources_STATUS
	err := copied.AssignProperties_To_DataImportSources_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DataImportSources_STATUS
	err = actual.AssignProperties_From_DataImportSources_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DataImportSources_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataImportSources_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataImportSources_STATUS, DataImportSources_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataImportSources_STATUS runs a test to see if a specific instance of DataImportSources_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDataImportSources_STATUS(subject DataImportSources_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataImportSources_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataImportSources_STATUS instances for property testing - lazily instantiated by
// DataImportSources_STATUSGenerator()
var dataImportSources_STATUSGenerator gopter.Gen

// DataImportSources_STATUSGenerator returns a generator of DataImportSources_STATUS instances for property testing.
func DataImportSources_STATUSGenerator() gopter.Gen {
	if dataImportSources_STATUSGenerator != nil {
		return dataImportSources_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDataImportSources_STATUS(generators)
	dataImportSources_STATUSGenerator = gen.Struct(reflect.TypeOf(DataImportSources_STATUS{}), generators)

	return dataImportSources_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForDataImportSources_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataImportSources_STATUS(gens map[string]gopter.Gen) {
	gens["EventHub"] = gen.PtrOf(EventHubDataSource_STATUSGenerator())
}

func Test_DataSourcesSpec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DataSourcesSpec to DataSourcesSpec via AssignProperties_To_DataSourcesSpec & AssignProperties_From_DataSourcesSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForDataSourcesSpec, DataSourcesSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDataSourcesSpec tests if a specific instance of DataSourcesSpec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForDataSourcesSpec(subject DataSourcesSpec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.DataSourcesSpec
	err := copied.AssignProperties_To_DataSourcesSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DataSourcesSpec
	err = actual.AssignProperties_From_DataSourcesSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DataSourcesSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataSourcesSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataSourcesSpec, DataSourcesSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataSourcesSpec runs a test to see if a specific instance of DataSourcesSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForDataSourcesSpec(subject DataSourcesSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataSourcesSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataSourcesSpec instances for property testing - lazily instantiated by DataSourcesSpecGenerator()
var dataSourcesSpecGenerator gopter.Gen

// DataSourcesSpecGenerator returns a generator of DataSourcesSpec instances for property testing.
func DataSourcesSpecGenerator() gopter.Gen {
	if dataSourcesSpecGenerator != nil {
		return dataSourcesSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDataSourcesSpec(generators)
	dataSourcesSpecGenerator = gen.Struct(reflect.TypeOf(DataSourcesSpec{}), generators)

	return dataSourcesSpecGenerator
}

// AddRelatedPropertyGeneratorsForDataSourcesSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataSourcesSpec(gens map[string]gopter.Gen) {
	gens["DataImports"] = gen.PtrOf(DataImportSourcesGenerator())
	gens["Extensions"] = gen.SliceOf(ExtensionDataSourceGenerator())
	gens["IisLogs"] = gen.SliceOf(IisLogsDataSourceGenerator())
	gens["LogFiles"] = gen.SliceOf(LogFilesDataSourceGenerator())
	gens["PerformanceCounters"] = gen.SliceOf(PerfCounterDataSourceGenerator())
	gens["PlatformTelemetry"] = gen.SliceOf(PlatformTelemetryDataSourceGenerator())
	gens["PrometheusForwarder"] = gen.SliceOf(PrometheusForwarderDataSourceGenerator())
	gens["Syslog"] = gen.SliceOf(SyslogDataSourceGenerator())
	gens["WindowsEventLogs"] = gen.SliceOf(WindowsEventLogDataSourceGenerator())
	gens["WindowsFirewallLogs"] = gen.SliceOf(WindowsFirewallLogsDataSourceGenerator())
}

func Test_DataSourcesSpec_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DataSourcesSpec_STATUS to DataSourcesSpec_STATUS via AssignProperties_To_DataSourcesSpec_STATUS & AssignProperties_From_DataSourcesSpec_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDataSourcesSpec_STATUS, DataSourcesSpec_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDataSourcesSpec_STATUS tests if a specific instance of DataSourcesSpec_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForDataSourcesSpec_STATUS(subject DataSourcesSpec_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.DataSourcesSpec_STATUS
	err := copied.AssignProperties_To_DataSourcesSpec_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DataSourcesSpec_STATUS
	err = actual.AssignProperties_From_DataSourcesSpec_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DataSourcesSpec_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataSourcesSpec_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataSourcesSpec_STATUS, DataSourcesSpec_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataSourcesSpec_STATUS runs a test to see if a specific instance of DataSourcesSpec_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDataSourcesSpec_STATUS(subject DataSourcesSpec_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataSourcesSpec_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataSourcesSpec_STATUS instances for property testing - lazily instantiated by
// DataSourcesSpec_STATUSGenerator()
var dataSourcesSpec_STATUSGenerator gopter.Gen

// DataSourcesSpec_STATUSGenerator returns a generator of DataSourcesSpec_STATUS instances for property testing.
func DataSourcesSpec_STATUSGenerator() gopter.Gen {
	if dataSourcesSpec_STATUSGenerator != nil {
		return dataSourcesSpec_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDataSourcesSpec_STATUS(generators)
	dataSourcesSpec_STATUSGenerator = gen.Struct(reflect.TypeOf(DataSourcesSpec_STATUS{}), generators)

	return dataSourcesSpec_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForDataSourcesSpec_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataSourcesSpec_STATUS(gens map[string]gopter.Gen) {
	gens["DataImports"] = gen.PtrOf(DataImportSources_STATUSGenerator())
	gens["Extensions"] = gen.SliceOf(ExtensionDataSource_STATUSGenerator())
	gens["IisLogs"] = gen.SliceOf(IisLogsDataSource_STATUSGenerator())
	gens["LogFiles"] = gen.SliceOf(LogFilesDataSource_STATUSGenerator())
	gens["PerformanceCounters"] = gen.SliceOf(PerfCounterDataSource_STATUSGenerator())
	gens["PlatformTelemetry"] = gen.SliceOf(PlatformTelemetryDataSource_STATUSGenerator())
	gens["PrometheusForwarder"] = gen.SliceOf(PrometheusForwarderDataSource_STATUSGenerator())
	gens["Syslog"] = gen.SliceOf(SyslogDataSource_STATUSGenerator())
	gens["WindowsEventLogs"] = gen.SliceOf(WindowsEventLogDataSource_STATUSGenerator())
	gens["WindowsFirewallLogs"] = gen.SliceOf(WindowsFirewallLogsDataSource_STATUSGenerator())
}

func Test_DestinationsSpec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DestinationsSpec to DestinationsSpec via AssignProperties_To_DestinationsSpec & AssignProperties_From_DestinationsSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForDestinationsSpec, DestinationsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDestinationsSpec tests if a specific instance of DestinationsSpec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForDestinationsSpec(subject DestinationsSpec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.DestinationsSpec
	err := copied.AssignProperties_To_DestinationsSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DestinationsSpec
	err = actual.AssignProperties_From_DestinationsSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DestinationsSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DestinationsSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDestinationsSpec, DestinationsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDestinationsSpec runs a test to see if a specific instance of DestinationsSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForDestinationsSpec(subject DestinationsSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DestinationsSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DestinationsSpec instances for property testing - lazily instantiated by DestinationsSpecGenerator()
var destinationsSpecGenerator gopter.Gen

// DestinationsSpecGenerator returns a generator of DestinationsSpec instances for property testing.
func DestinationsSpecGenerator() gopter.Gen {
	if destinationsSpecGenerator != nil {
		return destinationsSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDestinationsSpec(generators)
	destinationsSpecGenerator = gen.Struct(reflect.TypeOf(DestinationsSpec{}), generators)

	return destinationsSpecGenerator
}

// AddRelatedPropertyGeneratorsForDestinationsSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDestinationsSpec(gens map[string]gopter.Gen) {
	gens["AzureDataExplorer"] = gen.SliceOf(AdxDestinationGenerator())
	gens["AzureMonitorMetrics"] = gen.PtrOf(AzureMonitorMetricsDestinationGenerator())
	gens["EventHubs"] = gen.SliceOf(EventHubDestinationGenerator())
	gens["EventHubsDirect"] = gen.SliceOf(EventHubDirectDestinationGenerator())
	gens["LogAnalytics"] = gen.SliceOf(LogAnalyticsDestinationGenerator())
	gens["MicrosoftFabric"] = gen.SliceOf(MicrosoftFabricDestinationGenerator())
	gens["MonitoringAccounts"] = gen.SliceOf(MonitoringAccountDestinationGenerator())
	gens["StorageAccounts"] = gen.SliceOf(StorageBlobDestinationGenerator())
	gens["StorageBlobsDirect"] = gen.SliceOf(StorageBlobDestinationGenerator())
	gens["StorageTablesDirect"] = gen.SliceOf(StorageTableDestinationGenerator())
}

func Test_DestinationsSpec_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DestinationsSpec_STATUS to DestinationsSpec_STATUS via AssignProperties_To_DestinationsSpec_STATUS & AssignProperties_From_DestinationsSpec_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDestinationsSpec_STATUS, DestinationsSpec_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDestinationsSpec_STATUS tests if a specific instance of DestinationsSpec_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForDestinationsSpec_STATUS(subject DestinationsSpec_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.DestinationsSpec_STATUS
	err := copied.AssignProperties_To_DestinationsSpec_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DestinationsSpec_STATUS
	err = actual.AssignProperties_From_DestinationsSpec_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DestinationsSpec_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DestinationsSpec_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDestinationsSpec_STATUS, DestinationsSpec_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDestinationsSpec_STATUS runs a test to see if a specific instance of DestinationsSpec_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDestinationsSpec_STATUS(subject DestinationsSpec_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DestinationsSpec_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DestinationsSpec_STATUS instances for property testing - lazily instantiated by
// DestinationsSpec_STATUSGenerator()
var destinationsSpec_STATUSGenerator gopter.Gen

// DestinationsSpec_STATUSGenerator returns a generator of DestinationsSpec_STATUS instances for property testing.
func DestinationsSpec_STATUSGenerator() gopter.Gen {
	if destinationsSpec_STATUSGenerator != nil {
		return destinationsSpec_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDestinationsSpec_STATUS(generators)
	destinationsSpec_STATUSGenerator = gen.Struct(reflect.TypeOf(DestinationsSpec_STATUS{}), generators)

	return destinationsSpec_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForDestinationsSpec_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDestinationsSpec_STATUS(gens map[string]gopter.Gen) {
	gens["AzureDataExplorer"] = gen.SliceOf(AdxDestination_STATUSGenerator())
	gens["AzureMonitorMetrics"] = gen.PtrOf(AzureMonitorMetricsDestination_STATUSGenerator())
	gens["EventHubs"] = gen.SliceOf(EventHubDestination_STATUSGenerator())
	gens["EventHubsDirect"] = gen.SliceOf(EventHubDirectDestination_STATUSGenerator())
	gens["LogAnalytics"] = gen.SliceOf(LogAnalyticsDestination_STATUSGenerator())
	gens["MicrosoftFabric"] = gen.SliceOf(MicrosoftFabricDestination_STATUSGenerator())
	gens["MonitoringAccounts"] = gen.SliceOf(MonitoringAccountDestination_STATUSGenerator())
	gens["StorageAccounts"] = gen.SliceOf(StorageBlobDestination_STATUSGenerator())
	gens["StorageBlobsDirect"] = gen.SliceOf(StorageBlobDestination_STATUSGenerator())
	gens["StorageTablesDirect"] = gen.SliceOf(StorageTableDestination_STATUSGenerator())
}

func Test_EndpointsSpec_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EndpointsSpec_STATUS to EndpointsSpec_STATUS via AssignProperties_To_EndpointsSpec_STATUS & AssignProperties_From_EndpointsSpec_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForEndpointsSpec_STATUS, EndpointsSpec_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEndpointsSpec_STATUS tests if a specific instance of EndpointsSpec_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForEndpointsSpec_STATUS(subject EndpointsSpec_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.EndpointsSpec_STATUS
	err := copied.AssignProperties_To_EndpointsSpec_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EndpointsSpec_STATUS
	err = actual.AssignProperties_From_EndpointsSpec_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EndpointsSpec_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EndpointsSpec_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEndpointsSpec_STATUS, EndpointsSpec_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEndpointsSpec_STATUS runs a test to see if a specific instance of EndpointsSpec_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEndpointsSpec_STATUS(subject EndpointsSpec_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EndpointsSpec_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EndpointsSpec_STATUS instances for property testing - lazily instantiated by
// EndpointsSpec_STATUSGenerator()
var endpointsSpec_STATUSGenerator gopter.Gen

// EndpointsSpec_STATUSGenerator returns a generator of EndpointsSpec_STATUS instances for property testing.
func EndpointsSpec_STATUSGenerator() gopter.Gen {
	if endpointsSpec_STATUSGenerator != nil {
		return endpointsSpec_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEndpointsSpec_STATUS(generators)
	endpointsSpec_STATUSGenerator = gen.Struct(reflect.TypeOf(EndpointsSpec_STATUS{}), generators)

	return endpointsSpec_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForEndpointsSpec_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEndpointsSpec_STATUS(gens map[string]gopter.Gen) {
	gens["LogsIngestion"] = gen.PtrOf(gen.AlphaString())
	gens["MetricsIngestion"] = gen.PtrOf(gen.AlphaString())
}

func Test_EnrichmentData_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EnrichmentData to EnrichmentData via AssignProperties_To_EnrichmentData & AssignProperties_From_EnrichmentData returns original",
		prop.ForAll(RunPropertyAssignmentTestForEnrichmentData, EnrichmentDataGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEnrichmentData tests if a specific instance of EnrichmentData can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForEnrichmentData(subject EnrichmentData) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.EnrichmentData
	err := copied.AssignProperties_To_EnrichmentData(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EnrichmentData
	err = actual.AssignProperties_From_EnrichmentData(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EnrichmentData_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EnrichmentData via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEnrichmentData, EnrichmentDataGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEnrichmentData runs a test to see if a specific instance of EnrichmentData round trips to JSON and back losslessly
func RunJSONSerializationTestForEnrichmentData(subject EnrichmentData) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EnrichmentData
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EnrichmentData instances for property testing - lazily instantiated by EnrichmentDataGenerator()
var enrichmentDataGenerator gopter.Gen

// EnrichmentDataGenerator returns a generator of EnrichmentData instances for property testing.
func EnrichmentDataGenerator() gopter.Gen {
	if enrichmentDataGenerator != nil {
		return enrichmentDataGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForEnrichmentData(generators)
	enrichmentDataGenerator = gen.Struct(reflect.TypeOf(EnrichmentData{}), generators)

	return enrichmentDataGenerator
}

// AddRelatedPropertyGeneratorsForEnrichmentData is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEnrichmentData(gens map[string]gopter.Gen) {
	gens["StorageBlobs"] = gen.SliceOf(StorageBlobGenerator())
}

func Test_EnrichmentData_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EnrichmentData_STATUS to EnrichmentData_STATUS via AssignProperties_To_EnrichmentData_STATUS & AssignProperties_From_EnrichmentData_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForEnrichmentData_STATUS, EnrichmentData_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEnrichmentData_STATUS tests if a specific instance of EnrichmentData_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForEnrichmentData_STATUS(subject EnrichmentData_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.EnrichmentData_STATUS
	err := copied.AssignProperties_To_EnrichmentData_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EnrichmentData_STATUS
	err = actual.AssignProperties_From_EnrichmentData_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EnrichmentData_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EnrichmentData_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEnrichmentData_STATUS, EnrichmentData_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEnrichmentData_STATUS runs a test to see if a specific instance of EnrichmentData_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEnrichmentData_STATUS(subject EnrichmentData_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EnrichmentData_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EnrichmentData_STATUS instances for property testing - lazily instantiated by
// EnrichmentData_STATUSGenerator()
var enrichmentData_STATUSGenerator gopter.Gen

// EnrichmentData_STATUSGenerator returns a generator of EnrichmentData_STATUS instances for property testing.
func EnrichmentData_STATUSGenerator() gopter.Gen {
	if enrichmentData_STATUSGenerator != nil {
		return enrichmentData_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForEnrichmentData_STATUS(generators)
	enrichmentData_STATUSGenerator = gen.Struct(reflect.TypeOf(EnrichmentData_STATUS{}), generators)

	return enrichmentData_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForEnrichmentData_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEnrichmentData_STATUS(gens map[string]gopter.Gen) {
	gens["StorageBlobs"] = gen.SliceOf(StorageBlob_STATUSGenerator())
}

func Test_EventHubDataSource_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EventHubDataSource to EventHubDataSource via AssignProperties_To_EventHubDataSource & AssignProperties_From_EventHubDataSource returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventHubDataSource, EventHubDataSourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventHubDataSource tests if a specific instance of EventHubDataSource can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForEventHubDataSource(subject EventHubDataSource) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.EventHubDataSource
	err := copied.AssignProperties_To_EventHubDataSource(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EventHubDataSource
	err = actual.AssignProperties_From_EventHubDataSource(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventHubDataSource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventHubDataSource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventHubDataSource, EventHubDataSourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventHubDataSource runs a test to see if a specific instance of EventHubDataSource round trips to JSON and back losslessly
func RunJSONSerializationTestForEventHubDataSource(subject EventHubDataSource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventHubDataSource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventHubDataSource instances for property testing - lazily instantiated by EventHubDataSourceGenerator()
var eventHubDataSourceGenerator gopter.Gen

// EventHubDataSourceGenerator returns a generator of EventHubDataSource instances for property testing.
func EventHubDataSourceGenerator() gopter.Gen {
	if eventHubDataSourceGenerator != nil {
		return eventHubDataSourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventHubDataSource(generators)
	eventHubDataSourceGenerator = gen.Struct(reflect.TypeOf(EventHubDataSource{}), generators)

	return eventHubDataSourceGenerator
}

// AddIndependentPropertyGeneratorsForEventHubDataSource is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventHubDataSource(gens map[string]gopter.Gen) {
	gens["ConsumerGroup"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Stream"] = gen.PtrOf(gen.AlphaString())
}

func Test_EventHubDataSource_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EventHubDataSource_STATUS to EventHubDataSource_STATUS via AssignProperties_To_EventHubDataSource_STATUS & AssignProperties_From_EventHubDataSource_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventHubDataSource_STATUS, EventHubDataSource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventHubDataSource_STATUS tests if a specific instance of EventHubDataSource_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForEventHubDataSource_STATUS(subject EventHubDataSource_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.EventHubDataSource_STATUS
	err := copied.AssignProperties_To_EventHubDataSource_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EventHubDataSource_STATUS
	err = actual.AssignProperties_From_EventHubDataSource_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventHubDataSource_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventHubDataSource_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventHubDataSource_STATUS, EventHubDataSource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventHubDataSource_STATUS runs a test to see if a specific instance of EventHubDataSource_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEventHubDataSource_STATUS(subject EventHubDataSource_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventHubDataSource_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventHubDataSource_STATUS instances for property testing - lazily instantiated by
// EventHubDataSource_STATUSGenerator()
var eventHubDataSource_STATUSGenerator gopter.Gen

// EventHubDataSource_STATUSGenerator returns a generator of EventHubDataSource_STATUS instances for property testing.
func EventHubDataSource_STATUSGenerator() gopter.Gen {
	if eventHubDataSource_STATUSGenerator != nil {
		return eventHubDataSource_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventHubDataSource_STATUS(generators)
	eventHubDataSource_STATUSGenerator = gen.Struct(reflect.TypeOf(EventHubDataSource_STATUS{}), generators)

	return eventHubDataSource_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForEventHubDataSource_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventHubDataSource_STATUS(gens map[string]gopter.Gen) {
	gens["ConsumerGroup"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Stream"] = gen.PtrOf(gen.AlphaString())
}

func Test_EventHubDestination_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EventHubDestination to EventHubDestination via AssignProperties_To_EventHubDestination & AssignProperties_From_EventHubDestination returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventHubDestination, EventHubDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventHubDestination tests if a specific instance of EventHubDestination can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForEventHubDestination(subject EventHubDestination) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.EventHubDestination
	err := copied.AssignProperties_To_EventHubDestination(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EventHubDestination
	err = actual.AssignProperties_From_EventHubDestination(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventHubDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventHubDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventHubDestination, EventHubDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventHubDestination runs a test to see if a specific instance of EventHubDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForEventHubDestination(subject EventHubDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventHubDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventHubDestination instances for property testing - lazily instantiated by
// EventHubDestinationGenerator()
var eventHubDestinationGenerator gopter.Gen

// EventHubDestinationGenerator returns a generator of EventHubDestination instances for property testing.
func EventHubDestinationGenerator() gopter.Gen {
	if eventHubDestinationGenerator != nil {
		return eventHubDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventHubDestination(generators)
	eventHubDestinationGenerator = gen.Struct(reflect.TypeOf(EventHubDestination{}), generators)

	return eventHubDestinationGenerator
}

// AddIndependentPropertyGeneratorsForEventHubDestination is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventHubDestination(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_EventHubDestination_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EventHubDestination_STATUS to EventHubDestination_STATUS via AssignProperties_To_EventHubDestination_STATUS & AssignProperties_From_EventHubDestination_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventHubDestination_STATUS, EventHubDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventHubDestination_STATUS tests if a specific instance of EventHubDestination_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForEventHubDestination_STATUS(subject EventHubDestination_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.EventHubDestination_STATUS
	err := copied.AssignProperties_To_EventHubDestination_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EventHubDestination_STATUS
	err = actual.AssignProperties_From_EventHubDestination_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventHubDestination_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventHubDestination_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventHubDestination_STATUS, EventHubDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventHubDestination_STATUS runs a test to see if a specific instance of EventHubDestination_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEventHubDestination_STATUS(subject EventHubDestination_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventHubDestination_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventHubDestination_STATUS instances for property testing - lazily instantiated by
// EventHubDestination_STATUSGenerator()
var eventHubDestination_STATUSGenerator gopter.Gen

// EventHubDestination_STATUSGenerator returns a generator of EventHubDestination_STATUS instances for property testing.
func EventHubDestination_STATUSGenerator() gopter.Gen {
	if eventHubDestination_STATUSGenerator != nil {
		return eventHubDestination_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventHubDestination_STATUS(generators)
	eventHubDestination_STATUSGenerator = gen.Struct(reflect.TypeOf(EventHubDestination_STATUS{}), generators)

	return eventHubDestination_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForEventHubDestination_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventHubDestination_STATUS(gens map[string]gopter.Gen) {
	gens["EventHubResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_EventHubDirectDestination_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EventHubDirectDestination to EventHubDirectDestination via AssignProperties_To_EventHubDirectDestination & AssignProperties_From_EventHubDirectDestination returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventHubDirectDestination, EventHubDirectDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventHubDirectDestination tests if a specific instance of EventHubDirectDestination can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForEventHubDirectDestination(subject EventHubDirectDestination) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.EventHubDirectDestination
	err := copied.AssignProperties_To_EventHubDirectDestination(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EventHubDirectDestination
	err = actual.AssignProperties_From_EventHubDirectDestination(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventHubDirectDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventHubDirectDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventHubDirectDestination, EventHubDirectDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventHubDirectDestination runs a test to see if a specific instance of EventHubDirectDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForEventHubDirectDestination(subject EventHubDirectDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventHubDirectDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventHubDirectDestination instances for property testing - lazily instantiated by
// EventHubDirectDestinationGenerator()
var eventHubDirectDestinationGenerator gopter.Gen

// EventHubDirectDestinationGenerator returns a generator of EventHubDirectDestination instances for property testing.
func EventHubDirectDestinationGenerator() gopter.Gen {
	if eventHubDirectDestinationGenerator != nil {
		return eventHubDirectDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventHubDirectDestination(generators)
	eventHubDirectDestinationGenerator = gen.Struct(reflect.TypeOf(EventHubDirectDestination{}), generators)

	return eventHubDirectDestinationGenerator
}

// AddIndependentPropertyGeneratorsForEventHubDirectDestination is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventHubDirectDestination(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_EventHubDirectDestination_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EventHubDirectDestination_STATUS to EventHubDirectDestination_STATUS via AssignProperties_To_EventHubDirectDestination_STATUS & AssignProperties_From_EventHubDirectDestination_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventHubDirectDestination_STATUS, EventHubDirectDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventHubDirectDestination_STATUS tests if a specific instance of EventHubDirectDestination_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForEventHubDirectDestination_STATUS(subject EventHubDirectDestination_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.EventHubDirectDestination_STATUS
	err := copied.AssignProperties_To_EventHubDirectDestination_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EventHubDirectDestination_STATUS
	err = actual.AssignProperties_From_EventHubDirectDestination_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventHubDirectDestination_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventHubDirectDestination_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventHubDirectDestination_STATUS, EventHubDirectDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventHubDirectDestination_STATUS runs a test to see if a specific instance of EventHubDirectDestination_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEventHubDirectDestination_STATUS(subject EventHubDirectDestination_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventHubDirectDestination_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventHubDirectDestination_STATUS instances for property testing - lazily instantiated by
// EventHubDirectDestination_STATUSGenerator()
var eventHubDirectDestination_STATUSGenerator gopter.Gen

// EventHubDirectDestination_STATUSGenerator returns a generator of EventHubDirectDestination_STATUS instances for property testing.
func EventHubDirectDestination_STATUSGenerator() gopter.Gen {
	if eventHubDirectDestination_STATUSGenerator != nil {
		return eventHubDirectDestination_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventHubDirectDestination_STATUS(generators)
	eventHubDirectDestination_STATUSGenerator = gen.Struct(reflect.TypeOf(EventHubDirectDestination_STATUS{}), generators)

	return eventHubDirectDestination_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForEventHubDirectDestination_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventHubDirectDestination_STATUS(gens map[string]gopter.Gen) {
	gens["EventHubResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_ExtensionDataSource_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ExtensionDataSource to ExtensionDataSource via AssignProperties_To_ExtensionDataSource & AssignProperties_From_ExtensionDataSource returns original",
		prop.ForAll(RunPropertyAssignmentTestForExtensionDataSource, ExtensionDataSourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExtensionDataSource tests if a specific instance of ExtensionDataSource can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForExtensionDataSource(subject ExtensionDataSource) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ExtensionDataSource
	err := copied.AssignProperties_To_ExtensionDataSource(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ExtensionDataSource
	err = actual.AssignProperties_From_ExtensionDataSource(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ExtensionDataSource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtensionDataSource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtensionDataSource, ExtensionDataSourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtensionDataSource runs a test to see if a specific instance of ExtensionDataSource round trips to JSON and back losslessly
func RunJSONSerializationTestForExtensionDataSource(subject ExtensionDataSource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtensionDataSource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtensionDataSource instances for property testing - lazily instantiated by
// ExtensionDataSourceGenerator()
var extensionDataSourceGenerator gopter.Gen

// ExtensionDataSourceGenerator returns a generator of ExtensionDataSource instances for property testing.
func ExtensionDataSourceGenerator() gopter.Gen {
	if extensionDataSourceGenerator != nil {
		return extensionDataSourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtensionDataSource(generators)
	extensionDataSourceGenerator = gen.Struct(reflect.TypeOf(ExtensionDataSource{}), generators)

	return extensionDataSourceGenerator
}

// AddIndependentPropertyGeneratorsForExtensionDataSource is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtensionDataSource(gens map[string]gopter.Gen) {
	gens["ExtensionName"] = gen.PtrOf(gen.AlphaString())
	gens["InputDataSources"] = gen.SliceOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Streams"] = gen.SliceOf(gen.OneConstOf(
		ExtensionDataSource_Streams_MicrosoftEvent,
		ExtensionDataSource_Streams_MicrosoftInsightsMetrics,
		ExtensionDataSource_Streams_MicrosoftPerf,
		ExtensionDataSource_Streams_MicrosoftSyslog,
		ExtensionDataSource_Streams_MicrosoftWindowsEvent))
}

func Test_ExtensionDataSource_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ExtensionDataSource_STATUS to ExtensionDataSource_STATUS via AssignProperties_To_ExtensionDataSource_STATUS & AssignProperties_From_ExtensionDataSource_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForExtensionDataSource_STATUS, ExtensionDataSource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExtensionDataSource_STATUS tests if a specific instance of ExtensionDataSource_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForExtensionDataSource_STATUS(subject ExtensionDataSource_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ExtensionDataSource_STATUS
	err := copied.AssignProperties_To_ExtensionDataSource_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ExtensionDataSource_STATUS
	err = actual.AssignProperties_From_ExtensionDataSource_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ExtensionDataSource_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtensionDataSource_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtensionDataSource_STATUS, ExtensionDataSource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtensionDataSource_STATUS runs a test to see if a specific instance of ExtensionDataSource_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForExtensionDataSource_STATUS(subject ExtensionDataSource_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtensionDataSource_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtensionDataSource_STATUS instances for property testing - lazily instantiated by
// ExtensionDataSource_STATUSGenerator()
var extensionDataSource_STATUSGenerator gopter.Gen

// ExtensionDataSource_STATUSGenerator returns a generator of ExtensionDataSource_STATUS instances for property testing.
func ExtensionDataSource_STATUSGenerator() gopter.Gen {
	if extensionDataSource_STATUSGenerator != nil {
		return extensionDataSource_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtensionDataSource_STATUS(generators)
	extensionDataSource_STATUSGenerator = gen.Struct(reflect.TypeOf(ExtensionDataSource_STATUS{}), generators)

	return extensionDataSource_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForExtensionDataSource_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtensionDataSource_STATUS(gens map[string]gopter.Gen) {
	gens["ExtensionName"] = gen.PtrOf(gen.AlphaString())
	gens["InputDataSources"] = gen.SliceOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Streams"] = gen.SliceOf(gen.OneConstOf(
		ExtensionDataSource_Streams_STATUS_MicrosoftEvent,
		ExtensionDataSource_Streams_STATUS_MicrosoftInsightsMetrics,
		ExtensionDataSource_Streams_STATUS_MicrosoftPerf,
		ExtensionDataSource_Streams_STATUS_MicrosoftSyslog,
		ExtensionDataSource_Streams_STATUS_MicrosoftWindowsEvent))
}

func Test_IisLogsDataSource_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IisLogsDataSource to IisLogsDataSource via AssignProperties_To_IisLogsDataSource & AssignProperties_From_IisLogsDataSource returns original",
		prop.ForAll(RunPropertyAssignmentTestForIisLogsDataSource, IisLogsDataSourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIisLogsDataSource tests if a specific instance of IisLogsDataSource can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForIisLogsDataSource(subject IisLogsDataSource) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.IisLogsDataSource
	err := copied.AssignProperties_To_IisLogsDataSource(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IisLogsDataSource
	err = actual.AssignProperties_From_IisLogsDataSource(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IisLogsDataSource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IisLogsDataSource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIisLogsDataSource, IisLogsDataSourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIisLogsDataSource runs a test to see if a specific instance of IisLogsDataSource round trips to JSON and back losslessly
func RunJSONSerializationTestForIisLogsDataSource(subject IisLogsDataSource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IisLogsDataSource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IisLogsDataSource instances for property testing - lazily instantiated by IisLogsDataSourceGenerator()
var iisLogsDataSourceGenerator gopter.Gen

// IisLogsDataSourceGenerator returns a generator of IisLogsDataSource instances for property testing.
func IisLogsDataSourceGenerator() gopter.Gen {
	if iisLogsDataSourceGenerator != nil {
		return iisLogsDataSourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIisLogsDataSource(generators)
	iisLogsDataSourceGenerator = gen.Struct(reflect.TypeOf(IisLogsDataSource{}), generators)

	return iisLogsDataSourceGenerator
}

// AddIndependentPropertyGeneratorsForIisLogsDataSource is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIisLogsDataSource(gens map[string]gopter.Gen) {
	gens["LogDirectories"] = gen.SliceOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Streams"] = gen.SliceOf(gen.AlphaString())
	gens["TransformKql"] = gen.PtrOf(gen.AlphaString())
}

func Test_IisLogsDataSource_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IisLogsDataSource_STATUS to IisLogsDataSource_STATUS via AssignProperties_To_IisLogsDataSource_STATUS & AssignProperties_From_IisLogsDataSource_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForIisLogsDataSource_STATUS, IisLogsDataSource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIisLogsDataSource_STATUS tests if a specific instance of IisLogsDataSource_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForIisLogsDataSource_STATUS(subject IisLogsDataSource_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.IisLogsDataSource_STATUS
	err := copied.AssignProperties_To_IisLogsDataSource_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IisLogsDataSource_STATUS
	err = actual.AssignProperties_From_IisLogsDataSource_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IisLogsDataSource_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IisLogsDataSource_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIisLogsDataSource_STATUS, IisLogsDataSource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIisLogsDataSource_STATUS runs a test to see if a specific instance of IisLogsDataSource_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForIisLogsDataSource_STATUS(subject IisLogsDataSource_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IisLogsDataSource_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IisLogsDataSource_STATUS instances for property testing - lazily instantiated by
// IisLogsDataSource_STATUSGenerator()
var iisLogsDataSource_STATUSGenerator gopter.Gen

// IisLogsDataSource_STATUSGenerator returns a generator of IisLogsDataSource_STATUS instances for property testing.
func IisLogsDataSource_STATUSGenerator() gopter.Gen {
	if iisLogsDataSource_STATUSGenerator != nil {
		return iisLogsDataSource_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIisLogsDataSource_STATUS(generators)
	iisLogsDataSource_STATUSGenerator = gen.Struct(reflect.TypeOf(IisLogsDataSource_STATUS{}), generators)

	return iisLogsDataSource_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForIisLogsDataSource_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIisLogsDataSource_STATUS(gens map[string]gopter.Gen) {
	gens["LogDirectories"] = gen.SliceOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Streams"] = gen.SliceOf(gen.AlphaString())
	gens["TransformKql"] = gen.PtrOf(gen.AlphaString())
}

func Test_LogAnalyticsDestination_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LogAnalyticsDestination to LogAnalyticsDestination via AssignProperties_To_LogAnalyticsDestination & AssignProperties_From_LogAnalyticsDestination returns original",
		prop.ForAll(RunPropertyAssignmentTestForLogAnalyticsDestination, LogAnalyticsDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLogAnalyticsDestination tests if a specific instance of LogAnalyticsDestination can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForLogAnalyticsDestination(subject LogAnalyticsDestination) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.LogAnalyticsDestination
	err := copied.AssignProperties_To_LogAnalyticsDestination(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LogAnalyticsDestination
	err = actual.AssignProperties_From_LogAnalyticsDestination(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LogAnalyticsDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LogAnalyticsDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLogAnalyticsDestination, LogAnalyticsDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLogAnalyticsDestination runs a test to see if a specific instance of LogAnalyticsDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForLogAnalyticsDestination(subject LogAnalyticsDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LogAnalyticsDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LogAnalyticsDestination instances for property testing - lazily instantiated by
// LogAnalyticsDestinationGenerator()
var logAnalyticsDestinationGenerator gopter.Gen

// LogAnalyticsDestinationGenerator returns a generator of LogAnalyticsDestination instances for property testing.
func LogAnalyticsDestinationGenerator() gopter.Gen {
	if logAnalyticsDestinationGenerator != nil {
		return logAnalyticsDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLogAnalyticsDestination(generators)
	logAnalyticsDestinationGenerator = gen.Struct(reflect.TypeOf(LogAnalyticsDestination{}), generators)

	return logAnalyticsDestinationGenerator
}

// AddIndependentPropertyGeneratorsForLogAnalyticsDestination is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLogAnalyticsDestination(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_LogAnalyticsDestination_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LogAnalyticsDestination_STATUS to LogAnalyticsDestination_STATUS via AssignProperties_To_LogAnalyticsDestination_STATUS & AssignProperties_From_LogAnalyticsDestination_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForLogAnalyticsDestination_STATUS, LogAnalyticsDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLogAnalyticsDestination_STATUS tests if a specific instance of LogAnalyticsDestination_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForLogAnalyticsDestination_STATUS(subject LogAnalyticsDestination_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.LogAnalyticsDestination_STATUS
	err := copied.AssignProperties_To_LogAnalyticsDestination_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LogAnalyticsDestination_STATUS
	err = actual.AssignProperties_From_LogAnalyticsDestination_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LogAnalyticsDestination_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LogAnalyticsDestination_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLogAnalyticsDestination_STATUS, LogAnalyticsDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLogAnalyticsDestination_STATUS runs a test to see if a specific instance of LogAnalyticsDestination_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForLogAnalyticsDestination_STATUS(subject LogAnalyticsDestination_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LogAnalyticsDestination_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LogAnalyticsDestination_STATUS instances for property testing - lazily instantiated by
// LogAnalyticsDestination_STATUSGenerator()
var logAnalyticsDestination_STATUSGenerator gopter.Gen

// LogAnalyticsDestination_STATUSGenerator returns a generator of LogAnalyticsDestination_STATUS instances for property testing.
func LogAnalyticsDestination_STATUSGenerator() gopter.Gen {
	if logAnalyticsDestination_STATUSGenerator != nil {
		return logAnalyticsDestination_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLogAnalyticsDestination_STATUS(generators)
	logAnalyticsDestination_STATUSGenerator = gen.Struct(reflect.TypeOf(LogAnalyticsDestination_STATUS{}), generators)

	return logAnalyticsDestination_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForLogAnalyticsDestination_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLogAnalyticsDestination_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["WorkspaceId"] = gen.PtrOf(gen.AlphaString())
	gens["WorkspaceResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_LogFileSettings_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LogFileSettings to LogFileSettings via AssignProperties_To_LogFileSettings & AssignProperties_From_LogFileSettings returns original",
		prop.ForAll(RunPropertyAssignmentTestForLogFileSettings, LogFileSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLogFileSettings tests if a specific instance of LogFileSettings can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForLogFileSettings(subject LogFileSettings) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.LogFileSettings
	err := copied.AssignProperties_To_LogFileSettings(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LogFileSettings
	err = actual.AssignProperties_From_LogFileSettings(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LogFileSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LogFileSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLogFileSettings, LogFileSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLogFileSettings runs a test to see if a specific instance of LogFileSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForLogFileSettings(subject LogFileSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LogFileSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LogFileSettings instances for property testing - lazily instantiated by LogFileSettingsGenerator()
var logFileSettingsGenerator gopter.Gen

// LogFileSettingsGenerator returns a generator of LogFileSettings instances for property testing.
func LogFileSettingsGenerator() gopter.Gen {
	if logFileSettingsGenerator != nil {
		return logFileSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForLogFileSettings(generators)
	logFileSettingsGenerator = gen.Struct(reflect.TypeOf(LogFileSettings{}), generators)

	return logFileSettingsGenerator
}

// AddRelatedPropertyGeneratorsForLogFileSettings is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLogFileSettings(gens map[string]gopter.Gen) {
	gens["Text"] = gen.PtrOf(LogFileTextSettingsGenerator())
}

func Test_LogFileSettings_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LogFileSettings_STATUS to LogFileSettings_STATUS via AssignProperties_To_LogFileSettings_STATUS & AssignProperties_From_LogFileSettings_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForLogFileSettings_STATUS, LogFileSettings_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLogFileSettings_STATUS tests if a specific instance of LogFileSettings_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForLogFileSettings_STATUS(subject LogFileSettings_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.LogFileSettings_STATUS
	err := copied.AssignProperties_To_LogFileSettings_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LogFileSettings_STATUS
	err = actual.AssignProperties_From_LogFileSettings_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LogFileSettings_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LogFileSettings_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLogFileSettings_STATUS, LogFileSettings_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLogFileSettings_STATUS runs a test to see if a specific instance of LogFileSettings_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForLogFileSettings_STATUS(subject LogFileSettings_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LogFileSettings_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LogFileSettings_STATUS instances for property testing - lazily instantiated by
// LogFileSettings_STATUSGenerator()
var logFileSettings_STATUSGenerator gopter.Gen

// LogFileSettings_STATUSGenerator returns a generator of LogFileSettings_STATUS instances for property testing.
func LogFileSettings_STATUSGenerator() gopter.Gen {
	if logFileSettings_STATUSGenerator != nil {
		return logFileSettings_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForLogFileSettings_STATUS(generators)
	logFileSettings_STATUSGenerator = gen.Struct(reflect.TypeOf(LogFileSettings_STATUS{}), generators)

	return logFileSettings_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForLogFileSettings_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLogFileSettings_STATUS(gens map[string]gopter.Gen) {
	gens["Text"] = gen.PtrOf(LogFileTextSettings_STATUSGenerator())
}

func Test_LogFileTextSettings_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LogFileTextSettings to LogFileTextSettings via AssignProperties_To_LogFileTextSettings & AssignProperties_From_LogFileTextSettings returns original",
		prop.ForAll(RunPropertyAssignmentTestForLogFileTextSettings, LogFileTextSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLogFileTextSettings tests if a specific instance of LogFileTextSettings can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForLogFileTextSettings(subject LogFileTextSettings) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.LogFileTextSettings
	err := copied.AssignProperties_To_LogFileTextSettings(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LogFileTextSettings
	err = actual.AssignProperties_From_LogFileTextSettings(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LogFileTextSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LogFileTextSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLogFileTextSettings, LogFileTextSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLogFileTextSettings runs a test to see if a specific instance of LogFileTextSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForLogFileTextSettings(subject LogFileTextSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LogFileTextSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LogFileTextSettings instances for property testing - lazily instantiated by
// LogFileTextSettingsGenerator()
var logFileTextSettingsGenerator gopter.Gen

// LogFileTextSettingsGenerator returns a generator of LogFileTextSettings instances for property testing.
func LogFileTextSettingsGenerator() gopter.Gen {
	if logFileTextSettingsGenerator != nil {
		return logFileTextSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLogFileTextSettings(generators)
	logFileTextSettingsGenerator = gen.Struct(reflect.TypeOf(LogFileTextSettings{}), generators)

	return logFileTextSettingsGenerator
}

// AddIndependentPropertyGeneratorsForLogFileTextSettings is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLogFileTextSettings(gens map[string]gopter.Gen) {
	gens["RecordStartTimestampFormat"] = gen.PtrOf(gen.OneConstOf(
		LogFileTextSettings_RecordStartTimestampFormat_DdMMMYyyyHHMmSsZzz,
		LogFileTextSettings_RecordStartTimestampFormat_DdMMyyHHMmSs,
		LogFileTextSettings_RecordStartTimestampFormat_ISO8601,
		LogFileTextSettings_RecordStartTimestampFormat_MDYYYYHHMMSSAMPM,
		LogFileTextSettings_RecordStartTimestampFormat_MMMDHhMmSs,
		LogFileTextSettings_RecordStartTimestampFormat_MonDDYYYYHHMMSS,
		LogFileTextSettings_RecordStartTimestampFormat_YYYYMMDDHHMMSS,
		LogFileTextSettings_RecordStartTimestampFormat_YyMMddHHMmSs,
		LogFileTextSettings_RecordStartTimestampFormat_YyyyMMDdTHHMmSsK))
}

func Test_LogFileTextSettings_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LogFileTextSettings_STATUS to LogFileTextSettings_STATUS via AssignProperties_To_LogFileTextSettings_STATUS & AssignProperties_From_LogFileTextSettings_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForLogFileTextSettings_STATUS, LogFileTextSettings_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLogFileTextSettings_STATUS tests if a specific instance of LogFileTextSettings_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForLogFileTextSettings_STATUS(subject LogFileTextSettings_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.LogFileTextSettings_STATUS
	err := copied.AssignProperties_To_LogFileTextSettings_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LogFileTextSettings_STATUS
	err = actual.AssignProperties_From_LogFileTextSettings_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LogFileTextSettings_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LogFileTextSettings_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLogFileTextSettings_STATUS, LogFileTextSettings_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLogFileTextSettings_STATUS runs a test to see if a specific instance of LogFileTextSettings_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForLogFileTextSettings_STATUS(subject LogFileTextSettings_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LogFileTextSettings_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LogFileTextSettings_STATUS instances for property testing - lazily instantiated by
// LogFileTextSettings_STATUSGenerator()
var logFileTextSettings_STATUSGenerator gopter.Gen

// LogFileTextSettings_STATUSGenerator returns a generator of LogFileTextSettings_STATUS instances for property testing.
func LogFileTextSettings_STATUSGenerator() gopter.Gen {
	if logFileTextSettings_STATUSGenerator != nil {
		return logFileTextSettings_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLogFileTextSettings_STATUS(generators)
	logFileTextSettings_STATUSGenerator = gen.Struct(reflect.TypeOf(LogFileTextSettings_STATUS{}), generators)

	return logFileTextSettings_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForLogFileTextSettings_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLogFileTextSettings_STATUS(gens map[string]gopter.Gen) {
	gens["RecordStartTimestampFormat"] = gen.PtrOf(gen.OneConstOf(
		LogFileTextSettings_RecordStartTimestampFormat_STATUS_DdMMMYyyyHHMmSsZzz,
		LogFileTextSettings_RecordStartTimestampFormat_STATUS_DdMMyyHHMmSs,
		LogFileTextSettings_RecordStartTimestampFormat_STATUS_ISO8601,
		LogFileTextSettings_RecordStartTimestampFormat_STATUS_MDYYYYHHMMSSAMPM,
		LogFileTextSettings_RecordStartTimestampFormat_STATUS_MMMDHhMmSs,
		LogFileTextSettings_RecordStartTimestampFormat_STATUS_MonDDYYYYHHMMSS,
		LogFileTextSettings_RecordStartTimestampFormat_STATUS_YYYYMMDDHHMMSS,
		LogFileTextSettings_RecordStartTimestampFormat_STATUS_YyMMddHHMmSs,
		LogFileTextSettings_RecordStartTimestampFormat_STATUS_YyyyMMDdTHHMmSsK))
}

func Test_LogFilesDataSource_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LogFilesDataSource to LogFilesDataSource via AssignProperties_To_LogFilesDataSource & AssignProperties_From_LogFilesDataSource returns original",
		prop.ForAll(RunPropertyAssignmentTestForLogFilesDataSource, LogFilesDataSourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLogFilesDataSource tests if a specific instance of LogFilesDataSource can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForLogFilesDataSource(subject LogFilesDataSource) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.LogFilesDataSource
	err := copied.AssignProperties_To_LogFilesDataSource(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LogFilesDataSource
	err = actual.AssignProperties_From_LogFilesDataSource(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LogFilesDataSource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LogFilesDataSource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLogFilesDataSource, LogFilesDataSourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLogFilesDataSource runs a test to see if a specific instance of LogFilesDataSource round trips to JSON and back losslessly
func RunJSONSerializationTestForLogFilesDataSource(subject LogFilesDataSource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LogFilesDataSource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LogFilesDataSource instances for property testing - lazily instantiated by LogFilesDataSourceGenerator()
var logFilesDataSourceGenerator gopter.Gen

// LogFilesDataSourceGenerator returns a generator of LogFilesDataSource instances for property testing.
// We first initialize logFilesDataSourceGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LogFilesDataSourceGenerator() gopter.Gen {
	if logFilesDataSourceGenerator != nil {
		return logFilesDataSourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLogFilesDataSource(generators)
	logFilesDataSourceGenerator = gen.Struct(reflect.TypeOf(LogFilesDataSource{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLogFilesDataSource(generators)
	AddRelatedPropertyGeneratorsForLogFilesDataSource(generators)
	logFilesDataSourceGenerator = gen.Struct(reflect.TypeOf(LogFilesDataSource{}), generators)

	return logFilesDataSourceGenerator
}

// AddIndependentPropertyGeneratorsForLogFilesDataSource is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLogFilesDataSource(gens map[string]gopter.Gen) {
	gens["FilePatterns"] = gen.SliceOf(gen.AlphaString())
	gens["Format"] = gen.PtrOf(gen.OneConstOf(LogFilesDataSource_Format_Json, LogFilesDataSource_Format_Text))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Streams"] = gen.SliceOf(gen.AlphaString())
	gens["TransformKql"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLogFilesDataSource is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLogFilesDataSource(gens map[string]gopter.Gen) {
	gens["Settings"] = gen.PtrOf(LogFileSettingsGenerator())
}

func Test_LogFilesDataSource_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LogFilesDataSource_STATUS to LogFilesDataSource_STATUS via AssignProperties_To_LogFilesDataSource_STATUS & AssignProperties_From_LogFilesDataSource_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForLogFilesDataSource_STATUS, LogFilesDataSource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLogFilesDataSource_STATUS tests if a specific instance of LogFilesDataSource_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForLogFilesDataSource_STATUS(subject LogFilesDataSource_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.LogFilesDataSource_STATUS
	err := copied.AssignProperties_To_LogFilesDataSource_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LogFilesDataSource_STATUS
	err = actual.AssignProperties_From_LogFilesDataSource_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LogFilesDataSource_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LogFilesDataSource_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLogFilesDataSource_STATUS, LogFilesDataSource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLogFilesDataSource_STATUS runs a test to see if a specific instance of LogFilesDataSource_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForLogFilesDataSource_STATUS(subject LogFilesDataSource_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LogFilesDataSource_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LogFilesDataSource_STATUS instances for property testing - lazily instantiated by
// LogFilesDataSource_STATUSGenerator()
var logFilesDataSource_STATUSGenerator gopter.Gen

// LogFilesDataSource_STATUSGenerator returns a generator of LogFilesDataSource_STATUS instances for property testing.
// We first initialize logFilesDataSource_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LogFilesDataSource_STATUSGenerator() gopter.Gen {
	if logFilesDataSource_STATUSGenerator != nil {
		return logFilesDataSource_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLogFilesDataSource_STATUS(generators)
	logFilesDataSource_STATUSGenerator = gen.Struct(reflect.TypeOf(LogFilesDataSource_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLogFilesDataSource_STATUS(generators)
	AddRelatedPropertyGeneratorsForLogFilesDataSource_STATUS(generators)
	logFilesDataSource_STATUSGenerator = gen.Struct(reflect.TypeOf(LogFilesDataSource_STATUS{}), generators)

	return logFilesDataSource_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForLogFilesDataSource_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLogFilesDataSource_STATUS(gens map[string]gopter.Gen) {
	gens["FilePatterns"] = gen.SliceOf(gen.AlphaString())
	gens["Format"] = gen.PtrOf(gen.OneConstOf(LogFilesDataSource_Format_STATUS_Json, LogFilesDataSource_Format_STATUS_Text))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Streams"] = gen.SliceOf(gen.AlphaString())
	gens["TransformKql"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLogFilesDataSource_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLogFilesDataSource_STATUS(gens map[string]gopter.Gen) {
	gens["Settings"] = gen.PtrOf(LogFileSettings_STATUSGenerator())
}

func Test_ManagedServiceIdentity_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedServiceIdentity to ManagedServiceIdentity via AssignProperties_To_ManagedServiceIdentity & AssignProperties_From_ManagedServiceIdentity returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedServiceIdentity, ManagedServiceIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedServiceIdentity tests if a specific instance of ManagedServiceIdentity can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedServiceIdentity(subject ManagedServiceIdentity) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ManagedServiceIdentity
	err := copied.AssignProperties_To_ManagedServiceIdentity(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedServiceIdentity
	err = actual.AssignProperties_From_ManagedServiceIdentity(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedServiceIdentity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentity, ManagedServiceIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentity runs a test to see if a specific instance of ManagedServiceIdentity round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentity(subject ManagedServiceIdentity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity instances for property testing - lazily instantiated by
// ManagedServiceIdentityGenerator()
var managedServiceIdentityGenerator gopter.Gen

// ManagedServiceIdentityGenerator returns a generator of ManagedServiceIdentity instances for property testing.
// We first initialize managedServiceIdentityGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedServiceIdentityGenerator() gopter.Gen {
	if managedServiceIdentityGenerator != nil {
		return managedServiceIdentityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity(generators)
	managedServiceIdentityGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity(generators)
	AddRelatedPropertyGeneratorsForManagedServiceIdentity(generators)
	managedServiceIdentityGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity{}), generators)

	return managedServiceIdentityGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentity is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentity(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ManagedServiceIdentityType_None,
		ManagedServiceIdentityType_SystemAssigned,
		ManagedServiceIdentityType_SystemAssignedUserAssigned,
		ManagedServiceIdentityType_UserAssigned))
}

// AddRelatedPropertyGeneratorsForManagedServiceIdentity is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedServiceIdentity(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.SliceOf(UserAssignedIdentityDetailsGenerator())
}

func Test_ManagedServiceIdentity_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedServiceIdentity_STATUS to ManagedServiceIdentity_STATUS via AssignProperties_To_ManagedServiceIdentity_STATUS & AssignProperties_From_ManagedServiceIdentity_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedServiceIdentity_STATUS, ManagedServiceIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedServiceIdentity_STATUS tests if a specific instance of ManagedServiceIdentity_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedServiceIdentity_STATUS(subject ManagedServiceIdentity_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ManagedServiceIdentity_STATUS
	err := copied.AssignProperties_To_ManagedServiceIdentity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedServiceIdentity_STATUS
	err = actual.AssignProperties_From_ManagedServiceIdentity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedServiceIdentity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentity_STATUS, ManagedServiceIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentity_STATUS runs a test to see if a specific instance of ManagedServiceIdentity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentity_STATUS(subject ManagedServiceIdentity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity_STATUS instances for property testing - lazily instantiated by
// ManagedServiceIdentity_STATUSGenerator()
var managedServiceIdentity_STATUSGenerator gopter.Gen

// ManagedServiceIdentity_STATUSGenerator returns a generator of ManagedServiceIdentity_STATUS instances for property testing.
// We first initialize managedServiceIdentity_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedServiceIdentity_STATUSGenerator() gopter.Gen {
	if managedServiceIdentity_STATUSGenerator != nil {
		return managedServiceIdentity_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity_STATUS(generators)
	managedServiceIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity_STATUS(generators)
	AddRelatedPropertyGeneratorsForManagedServiceIdentity_STATUS(generators)
	managedServiceIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_STATUS{}), generators)

	return managedServiceIdentity_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentity_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ManagedServiceIdentityType_STATUS_None,
		ManagedServiceIdentityType_STATUS_SystemAssigned,
		ManagedServiceIdentityType_STATUS_SystemAssignedUserAssigned,
		ManagedServiceIdentityType_STATUS_UserAssigned))
}

// AddRelatedPropertyGeneratorsForManagedServiceIdentity_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedServiceIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(
		gen.AlphaString(),
		UserAssignedIdentity_STATUSGenerator())
}

func Test_Metadata_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Metadata_STATUS to Metadata_STATUS via AssignProperties_To_Metadata_STATUS & AssignProperties_From_Metadata_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForMetadata_STATUS, Metadata_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMetadata_STATUS tests if a specific instance of Metadata_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForMetadata_STATUS(subject Metadata_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.Metadata_STATUS
	err := copied.AssignProperties_To_Metadata_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Metadata_STATUS
	err = actual.AssignProperties_From_Metadata_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Metadata_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Metadata_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMetadata_STATUS, Metadata_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMetadata_STATUS runs a test to see if a specific instance of Metadata_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForMetadata_STATUS(subject Metadata_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Metadata_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Metadata_STATUS instances for property testing - lazily instantiated by Metadata_STATUSGenerator()
var metadata_STATUSGenerator gopter.Gen

// Metadata_STATUSGenerator returns a generator of Metadata_STATUS instances for property testing.
func Metadata_STATUSGenerator() gopter.Gen {
	if metadata_STATUSGenerator != nil {
		return metadata_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetadata_STATUS(generators)
	metadata_STATUSGenerator = gen.Struct(reflect.TypeOf(Metadata_STATUS{}), generators)

	return metadata_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForMetadata_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMetadata_STATUS(gens map[string]gopter.Gen) {
	gens["ProvisionedBy"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisionedByImmutableId"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisionedByResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_MicrosoftFabricDestination_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MicrosoftFabricDestination to MicrosoftFabricDestination via AssignProperties_To_MicrosoftFabricDestination & AssignProperties_From_MicrosoftFabricDestination returns original",
		prop.ForAll(RunPropertyAssignmentTestForMicrosoftFabricDestination, MicrosoftFabricDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMicrosoftFabricDestination tests if a specific instance of MicrosoftFabricDestination can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForMicrosoftFabricDestination(subject MicrosoftFabricDestination) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.MicrosoftFabricDestination
	err := copied.AssignProperties_To_MicrosoftFabricDestination(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual MicrosoftFabricDestination
	err = actual.AssignProperties_From_MicrosoftFabricDestination(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MicrosoftFabricDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MicrosoftFabricDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMicrosoftFabricDestination, MicrosoftFabricDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMicrosoftFabricDestination runs a test to see if a specific instance of MicrosoftFabricDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForMicrosoftFabricDestination(subject MicrosoftFabricDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MicrosoftFabricDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MicrosoftFabricDestination instances for property testing - lazily instantiated by
// MicrosoftFabricDestinationGenerator()
var microsoftFabricDestinationGenerator gopter.Gen

// MicrosoftFabricDestinationGenerator returns a generator of MicrosoftFabricDestination instances for property testing.
func MicrosoftFabricDestinationGenerator() gopter.Gen {
	if microsoftFabricDestinationGenerator != nil {
		return microsoftFabricDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMicrosoftFabricDestination(generators)
	microsoftFabricDestinationGenerator = gen.Struct(reflect.TypeOf(MicrosoftFabricDestination{}), generators)

	return microsoftFabricDestinationGenerator
}

// AddIndependentPropertyGeneratorsForMicrosoftFabricDestination is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMicrosoftFabricDestination(gens map[string]gopter.Gen) {
	gens["ArtifactId"] = gen.PtrOf(gen.AlphaString())
	gens["DatabaseName"] = gen.PtrOf(gen.AlphaString())
	gens["IngestionUri"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
}

func Test_MicrosoftFabricDestination_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MicrosoftFabricDestination_STATUS to MicrosoftFabricDestination_STATUS via AssignProperties_To_MicrosoftFabricDestination_STATUS & AssignProperties_From_MicrosoftFabricDestination_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForMicrosoftFabricDestination_STATUS, MicrosoftFabricDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMicrosoftFabricDestination_STATUS tests if a specific instance of MicrosoftFabricDestination_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForMicrosoftFabricDestination_STATUS(subject MicrosoftFabricDestination_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.MicrosoftFabricDestination_STATUS
	err := copied.AssignProperties_To_MicrosoftFabricDestination_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual MicrosoftFabricDestination_STATUS
	err = actual.AssignProperties_From_MicrosoftFabricDestination_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MicrosoftFabricDestination_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MicrosoftFabricDestination_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMicrosoftFabricDestination_STATUS, MicrosoftFabricDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMicrosoftFabricDestination_STATUS runs a test to see if a specific instance of MicrosoftFabricDestination_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForMicrosoftFabricDestination_STATUS(subject MicrosoftFabricDestination_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MicrosoftFabricDestination_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MicrosoftFabricDestination_STATUS instances for property testing - lazily instantiated by
// MicrosoftFabricDestination_STATUSGenerator()
var microsoftFabricDestination_STATUSGenerator gopter.Gen

// MicrosoftFabricDestination_STATUSGenerator returns a generator of MicrosoftFabricDestination_STATUS instances for property testing.
func MicrosoftFabricDestination_STATUSGenerator() gopter.Gen {
	if microsoftFabricDestination_STATUSGenerator != nil {
		return microsoftFabricDestination_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMicrosoftFabricDestination_STATUS(generators)
	microsoftFabricDestination_STATUSGenerator = gen.Struct(reflect.TypeOf(MicrosoftFabricDestination_STATUS{}), generators)

	return microsoftFabricDestination_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForMicrosoftFabricDestination_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMicrosoftFabricDestination_STATUS(gens map[string]gopter.Gen) {
	gens["ArtifactId"] = gen.PtrOf(gen.AlphaString())
	gens["DatabaseName"] = gen.PtrOf(gen.AlphaString())
	gens["IngestionUri"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
}

func Test_MonitoringAccountDestination_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MonitoringAccountDestination to MonitoringAccountDestination via AssignProperties_To_MonitoringAccountDestination & AssignProperties_From_MonitoringAccountDestination returns original",
		prop.ForAll(RunPropertyAssignmentTestForMonitoringAccountDestination, MonitoringAccountDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMonitoringAccountDestination tests if a specific instance of MonitoringAccountDestination can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForMonitoringAccountDestination(subject MonitoringAccountDestination) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.MonitoringAccountDestination
	err := copied.AssignProperties_To_MonitoringAccountDestination(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual MonitoringAccountDestination
	err = actual.AssignProperties_From_MonitoringAccountDestination(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MonitoringAccountDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MonitoringAccountDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMonitoringAccountDestination, MonitoringAccountDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMonitoringAccountDestination runs a test to see if a specific instance of MonitoringAccountDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForMonitoringAccountDestination(subject MonitoringAccountDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MonitoringAccountDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MonitoringAccountDestination instances for property testing - lazily instantiated by
// MonitoringAccountDestinationGenerator()
var monitoringAccountDestinationGenerator gopter.Gen

// MonitoringAccountDestinationGenerator returns a generator of MonitoringAccountDestination instances for property testing.
func MonitoringAccountDestinationGenerator() gopter.Gen {
	if monitoringAccountDestinationGenerator != nil {
		return monitoringAccountDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMonitoringAccountDestination(generators)
	monitoringAccountDestinationGenerator = gen.Struct(reflect.TypeOf(MonitoringAccountDestination{}), generators)

	return monitoringAccountDestinationGenerator
}

// AddIndependentPropertyGeneratorsForMonitoringAccountDestination is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMonitoringAccountDestination(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_MonitoringAccountDestination_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MonitoringAccountDestination_STATUS to MonitoringAccountDestination_STATUS via AssignProperties_To_MonitoringAccountDestination_STATUS & AssignProperties_From_MonitoringAccountDestination_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForMonitoringAccountDestination_STATUS, MonitoringAccountDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMonitoringAccountDestination_STATUS tests if a specific instance of MonitoringAccountDestination_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForMonitoringAccountDestination_STATUS(subject MonitoringAccountDestination_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.MonitoringAccountDestination_STATUS
	err := copied.AssignProperties_To_MonitoringAccountDestination_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual MonitoringAccountDestination_STATUS
	err = actual.AssignProperties_From_MonitoringAccountDestination_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MonitoringAccountDestination_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MonitoringAccountDestination_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMonitoringAccountDestination_STATUS, MonitoringAccountDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMonitoringAccountDestination_STATUS runs a test to see if a specific instance of MonitoringAccountDestination_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForMonitoringAccountDestination_STATUS(subject MonitoringAccountDestination_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MonitoringAccountDestination_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MonitoringAccountDestination_STATUS instances for property testing - lazily instantiated by
// MonitoringAccountDestination_STATUSGenerator()
var monitoringAccountDestination_STATUSGenerator gopter.Gen

// MonitoringAccountDestination_STATUSGenerator returns a generator of MonitoringAccountDestination_STATUS instances for property testing.
func MonitoringAccountDestination_STATUSGenerator() gopter.Gen {
	if monitoringAccountDestination_STATUSGenerator != nil {
		return monitoringAccountDestination_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMonitoringAccountDestination_STATUS(generators)
	monitoringAccountDestination_STATUSGenerator = gen.Struct(reflect.TypeOf(MonitoringAccountDestination_STATUS{}), generators)

	return monitoringAccountDestination_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForMonitoringAccountDestination_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMonitoringAccountDestination_STATUS(gens map[string]gopter.Gen) {
	gens["AccountId"] = gen.PtrOf(gen.AlphaString())
	gens["AccountResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_PerfCounterDataSource_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PerfCounterDataSource to PerfCounterDataSource via AssignProperties_To_PerfCounterDataSource & AssignProperties_From_PerfCounterDataSource returns original",
		prop.ForAll(RunPropertyAssignmentTestForPerfCounterDataSource, PerfCounterDataSourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPerfCounterDataSource tests if a specific instance of PerfCounterDataSource can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForPerfCounterDataSource(subject PerfCounterDataSource) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.PerfCounterDataSource
	err := copied.AssignProperties_To_PerfCounterDataSource(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PerfCounterDataSource
	err = actual.AssignProperties_From_PerfCounterDataSource(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PerfCounterDataSource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PerfCounterDataSource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPerfCounterDataSource, PerfCounterDataSourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPerfCounterDataSource runs a test to see if a specific instance of PerfCounterDataSource round trips to JSON and back losslessly
func RunJSONSerializationTestForPerfCounterDataSource(subject PerfCounterDataSource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PerfCounterDataSource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PerfCounterDataSource instances for property testing - lazily instantiated by
// PerfCounterDataSourceGenerator()
var perfCounterDataSourceGenerator gopter.Gen

// PerfCounterDataSourceGenerator returns a generator of PerfCounterDataSource instances for property testing.
func PerfCounterDataSourceGenerator() gopter.Gen {
	if perfCounterDataSourceGenerator != nil {
		return perfCounterDataSourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPerfCounterDataSource(generators)
	perfCounterDataSourceGenerator = gen.Struct(reflect.TypeOf(PerfCounterDataSource{}), generators)

	return perfCounterDataSourceGenerator
}

// AddIndependentPropertyGeneratorsForPerfCounterDataSource is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPerfCounterDataSource(gens map[string]gopter.Gen) {
	gens["CounterSpecifiers"] = gen.SliceOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["SamplingFrequencyInSeconds"] = gen.PtrOf(gen.Int())
	gens["Streams"] = gen.SliceOf(gen.OneConstOf(PerfCounterDataSource_Streams_MicrosoftInsightsMetrics, PerfCounterDataSource_Streams_MicrosoftPerf))
	gens["TransformKql"] = gen.PtrOf(gen.AlphaString())
}

func Test_PerfCounterDataSource_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PerfCounterDataSource_STATUS to PerfCounterDataSource_STATUS via AssignProperties_To_PerfCounterDataSource_STATUS & AssignProperties_From_PerfCounterDataSource_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForPerfCounterDataSource_STATUS, PerfCounterDataSource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPerfCounterDataSource_STATUS tests if a specific instance of PerfCounterDataSource_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForPerfCounterDataSource_STATUS(subject PerfCounterDataSource_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.PerfCounterDataSource_STATUS
	err := copied.AssignProperties_To_PerfCounterDataSource_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PerfCounterDataSource_STATUS
	err = actual.AssignProperties_From_PerfCounterDataSource_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PerfCounterDataSource_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PerfCounterDataSource_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPerfCounterDataSource_STATUS, PerfCounterDataSource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPerfCounterDataSource_STATUS runs a test to see if a specific instance of PerfCounterDataSource_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPerfCounterDataSource_STATUS(subject PerfCounterDataSource_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PerfCounterDataSource_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PerfCounterDataSource_STATUS instances for property testing - lazily instantiated by
// PerfCounterDataSource_STATUSGenerator()
var perfCounterDataSource_STATUSGenerator gopter.Gen

// PerfCounterDataSource_STATUSGenerator returns a generator of PerfCounterDataSource_STATUS instances for property testing.
func PerfCounterDataSource_STATUSGenerator() gopter.Gen {
	if perfCounterDataSource_STATUSGenerator != nil {
		return perfCounterDataSource_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPerfCounterDataSource_STATUS(generators)
	perfCounterDataSource_STATUSGenerator = gen.Struct(reflect.TypeOf(PerfCounterDataSource_STATUS{}), generators)

	return perfCounterDataSource_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForPerfCounterDataSource_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPerfCounterDataSource_STATUS(gens map[string]gopter.Gen) {
	gens["CounterSpecifiers"] = gen.SliceOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["SamplingFrequencyInSeconds"] = gen.PtrOf(gen.Int())
	gens["Streams"] = gen.SliceOf(gen.OneConstOf(PerfCounterDataSource_Streams_STATUS_MicrosoftInsightsMetrics, PerfCounterDataSource_Streams_STATUS_MicrosoftPerf))
	gens["TransformKql"] = gen.PtrOf(gen.AlphaString())
}

func Test_PlatformTelemetryDataSource_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PlatformTelemetryDataSource to PlatformTelemetryDataSource via AssignProperties_To_PlatformTelemetryDataSource & AssignProperties_From_PlatformTelemetryDataSource returns original",
		prop.ForAll(RunPropertyAssignmentTestForPlatformTelemetryDataSource, PlatformTelemetryDataSourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPlatformTelemetryDataSource tests if a specific instance of PlatformTelemetryDataSource can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForPlatformTelemetryDataSource(subject PlatformTelemetryDataSource) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.PlatformTelemetryDataSource
	err := copied.AssignProperties_To_PlatformTelemetryDataSource(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PlatformTelemetryDataSource
	err = actual.AssignProperties_From_PlatformTelemetryDataSource(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PlatformTelemetryDataSource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PlatformTelemetryDataSource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPlatformTelemetryDataSource, PlatformTelemetryDataSourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPlatformTelemetryDataSource runs a test to see if a specific instance of PlatformTelemetryDataSource round trips to JSON and back losslessly
func RunJSONSerializationTestForPlatformTelemetryDataSource(subject PlatformTelemetryDataSource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PlatformTelemetryDataSource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PlatformTelemetryDataSource instances for property testing - lazily instantiated by
// PlatformTelemetryDataSourceGenerator()
var platformTelemetryDataSourceGenerator gopter.Gen

// PlatformTelemetryDataSourceGenerator returns a generator of PlatformTelemetryDataSource instances for property testing.
func PlatformTelemetryDataSourceGenerator() gopter.Gen {
	if platformTelemetryDataSourceGenerator != nil {
		return platformTelemetryDataSourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPlatformTelemetryDataSource(generators)
	platformTelemetryDataSourceGenerator = gen.Struct(reflect.TypeOf(PlatformTelemetryDataSource{}), generators)

	return platformTelemetryDataSourceGenerator
}

// AddIndependentPropertyGeneratorsForPlatformTelemetryDataSource is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPlatformTelemetryDataSource(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Streams"] = gen.SliceOf(gen.AlphaString())
}

func Test_PlatformTelemetryDataSource_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PlatformTelemetryDataSource_STATUS to PlatformTelemetryDataSource_STATUS via AssignProperties_To_PlatformTelemetryDataSource_STATUS & AssignProperties_From_PlatformTelemetryDataSource_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForPlatformTelemetryDataSource_STATUS, PlatformTelemetryDataSource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPlatformTelemetryDataSource_STATUS tests if a specific instance of PlatformTelemetryDataSource_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForPlatformTelemetryDataSource_STATUS(subject PlatformTelemetryDataSource_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.PlatformTelemetryDataSource_STATUS
	err := copied.AssignProperties_To_PlatformTelemetryDataSource_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PlatformTelemetryDataSource_STATUS
	err = actual.AssignProperties_From_PlatformTelemetryDataSource_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PlatformTelemetryDataSource_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PlatformTelemetryDataSource_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPlatformTelemetryDataSource_STATUS, PlatformTelemetryDataSource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPlatformTelemetryDataSource_STATUS runs a test to see if a specific instance of PlatformTelemetryDataSource_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPlatformTelemetryDataSource_STATUS(subject PlatformTelemetryDataSource_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PlatformTelemetryDataSource_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PlatformTelemetryDataSource_STATUS instances for property testing - lazily instantiated by
// PlatformTelemetryDataSource_STATUSGenerator()
var platformTelemetryDataSource_STATUSGenerator gopter.Gen

// PlatformTelemetryDataSource_STATUSGenerator returns a generator of PlatformTelemetryDataSource_STATUS instances for property testing.
func PlatformTelemetryDataSource_STATUSGenerator() gopter.Gen {
	if platformTelemetryDataSource_STATUSGenerator != nil {
		return platformTelemetryDataSource_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPlatformTelemetryDataSource_STATUS(generators)
	platformTelemetryDataSource_STATUSGenerator = gen.Struct(reflect.TypeOf(PlatformTelemetryDataSource_STATUS{}), generators)

	return platformTelemetryDataSource_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForPlatformTelemetryDataSource_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPlatformTelemetryDataSource_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Streams"] = gen.SliceOf(gen.AlphaString())
}

func Test_PrometheusForwarderDataSource_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PrometheusForwarderDataSource to PrometheusForwarderDataSource via AssignProperties_To_PrometheusForwarderDataSource & AssignProperties_From_PrometheusForwarderDataSource returns original",
		prop.ForAll(RunPropertyAssignmentTestForPrometheusForwarderDataSource, PrometheusForwarderDataSourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPrometheusForwarderDataSource tests if a specific instance of PrometheusForwarderDataSource can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForPrometheusForwarderDataSource(subject PrometheusForwarderDataSource) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.PrometheusForwarderDataSource
	err := copied.AssignProperties_To_PrometheusForwarderDataSource(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PrometheusForwarderDataSource
	err = actual.AssignProperties_From_PrometheusForwarderDataSource(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PrometheusForwarderDataSource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrometheusForwarderDataSource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrometheusForwarderDataSource, PrometheusForwarderDataSourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrometheusForwarderDataSource runs a test to see if a specific instance of PrometheusForwarderDataSource round trips to JSON and back losslessly
func RunJSONSerializationTestForPrometheusForwarderDataSource(subject PrometheusForwarderDataSource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrometheusForwarderDataSource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrometheusForwarderDataSource instances for property testing - lazily instantiated by
// PrometheusForwarderDataSourceGenerator()
var prometheusForwarderDataSourceGenerator gopter.Gen

// PrometheusForwarderDataSourceGenerator returns a generator of PrometheusForwarderDataSource instances for property testing.
func PrometheusForwarderDataSourceGenerator() gopter.Gen {
	if prometheusForwarderDataSourceGenerator != nil {
		return prometheusForwarderDataSourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrometheusForwarderDataSource(generators)
	prometheusForwarderDataSourceGenerator = gen.Struct(reflect.TypeOf(PrometheusForwarderDataSource{}), generators)

	return prometheusForwarderDataSourceGenerator
}

// AddIndependentPropertyGeneratorsForPrometheusForwarderDataSource is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrometheusForwarderDataSource(gens map[string]gopter.Gen) {
	gens["LabelIncludeFilter"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Streams"] = gen.SliceOf(gen.OneConstOf(PrometheusForwarderDataSource_Streams_MicrosoftPrometheusMetrics))
}

func Test_PrometheusForwarderDataSource_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PrometheusForwarderDataSource_STATUS to PrometheusForwarderDataSource_STATUS via AssignProperties_To_PrometheusForwarderDataSource_STATUS & AssignProperties_From_PrometheusForwarderDataSource_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForPrometheusForwarderDataSource_STATUS, PrometheusForwarderDataSource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPrometheusForwarderDataSource_STATUS tests if a specific instance of PrometheusForwarderDataSource_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForPrometheusForwarderDataSource_STATUS(subject PrometheusForwarderDataSource_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.PrometheusForwarderDataSource_STATUS
	err := copied.AssignProperties_To_PrometheusForwarderDataSource_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PrometheusForwarderDataSource_STATUS
	err = actual.AssignProperties_From_PrometheusForwarderDataSource_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PrometheusForwarderDataSource_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrometheusForwarderDataSource_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrometheusForwarderDataSource_STATUS, PrometheusForwarderDataSource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrometheusForwarderDataSource_STATUS runs a test to see if a specific instance of PrometheusForwarderDataSource_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPrometheusForwarderDataSource_STATUS(subject PrometheusForwarderDataSource_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrometheusForwarderDataSource_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrometheusForwarderDataSource_STATUS instances for property testing - lazily instantiated by
// PrometheusForwarderDataSource_STATUSGenerator()
var prometheusForwarderDataSource_STATUSGenerator gopter.Gen

// PrometheusForwarderDataSource_STATUSGenerator returns a generator of PrometheusForwarderDataSource_STATUS instances for property testing.
func PrometheusForwarderDataSource_STATUSGenerator() gopter.Gen {
	if prometheusForwarderDataSource_STATUSGenerator != nil {
		return prometheusForwarderDataSource_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrometheusForwarderDataSource_STATUS(generators)
	prometheusForwarderDataSource_STATUSGenerator = gen.Struct(reflect.TypeOf(PrometheusForwarderDataSource_STATUS{}), generators)

	return prometheusForwarderDataSource_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForPrometheusForwarderDataSource_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrometheusForwarderDataSource_STATUS(gens map[string]gopter.Gen) {
	gens["LabelIncludeFilter"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Streams"] = gen.SliceOf(gen.OneConstOf(PrometheusForwarderDataSource_Streams_STATUS_MicrosoftPrometheusMetrics))
}

func Test_ReferencesSpec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ReferencesSpec to ReferencesSpec via AssignProperties_To_ReferencesSpec & AssignProperties_From_ReferencesSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForReferencesSpec, ReferencesSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForReferencesSpec tests if a specific instance of ReferencesSpec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForReferencesSpec(subject ReferencesSpec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ReferencesSpec
	err := copied.AssignProperties_To_ReferencesSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ReferencesSpec
	err = actual.AssignProperties_From_ReferencesSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ReferencesSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ReferencesSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForReferencesSpec, ReferencesSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForReferencesSpec runs a test to see if a specific instance of ReferencesSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForReferencesSpec(subject ReferencesSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ReferencesSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ReferencesSpec instances for property testing - lazily instantiated by ReferencesSpecGenerator()
var referencesSpecGenerator gopter.Gen

// ReferencesSpecGenerator returns a generator of ReferencesSpec instances for property testing.
func ReferencesSpecGenerator() gopter.Gen {
	if referencesSpecGenerator != nil {
		return referencesSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForReferencesSpec(generators)
	referencesSpecGenerator = gen.Struct(reflect.TypeOf(ReferencesSpec{}), generators)

	return referencesSpecGenerator
}

// AddRelatedPropertyGeneratorsForReferencesSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForReferencesSpec(gens map[string]gopter.Gen) {
	gens["EnrichmentData"] = gen.PtrOf(EnrichmentDataGenerator())
}

func Test_ReferencesSpec_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ReferencesSpec_STATUS to ReferencesSpec_STATUS via AssignProperties_To_ReferencesSpec_STATUS & AssignProperties_From_ReferencesSpec_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForReferencesSpec_STATUS, ReferencesSpec_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForReferencesSpec_STATUS tests if a specific instance of ReferencesSpec_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForReferencesSpec_STATUS(subject ReferencesSpec_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ReferencesSpec_STATUS
	err := copied.AssignProperties_To_ReferencesSpec_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ReferencesSpec_STATUS
	err = actual.AssignProperties_From_ReferencesSpec_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ReferencesSpec_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ReferencesSpec_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForReferencesSpec_STATUS, ReferencesSpec_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForReferencesSpec_STATUS runs a test to see if a specific instance of ReferencesSpec_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForReferencesSpec_STATUS(subject ReferencesSpec_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ReferencesSpec_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ReferencesSpec_STATUS instances for property testing - lazily instantiated by
// ReferencesSpec_STATUSGenerator()
var referencesSpec_STATUSGenerator gopter.Gen

// ReferencesSpec_STATUSGenerator returns a generator of ReferencesSpec_STATUS instances for property testing.
func ReferencesSpec_STATUSGenerator() gopter.Gen {
	if referencesSpec_STATUSGenerator != nil {
		return referencesSpec_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForReferencesSpec_STATUS(generators)
	referencesSpec_STATUSGenerator = gen.Struct(reflect.TypeOf(ReferencesSpec_STATUS{}), generators)

	return referencesSpec_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForReferencesSpec_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForReferencesSpec_STATUS(gens map[string]gopter.Gen) {
	gens["EnrichmentData"] = gen.PtrOf(EnrichmentData_STATUSGenerator())
}

func Test_StorageBlob_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from StorageBlob to StorageBlob via AssignProperties_To_StorageBlob & AssignProperties_From_StorageBlob returns original",
		prop.ForAll(RunPropertyAssignmentTestForStorageBlob, StorageBlobGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForStorageBlob tests if a specific instance of StorageBlob can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForStorageBlob(subject StorageBlob) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.StorageBlob
	err := copied.AssignProperties_To_StorageBlob(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual StorageBlob
	err = actual.AssignProperties_From_StorageBlob(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_StorageBlob_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageBlob via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageBlob, StorageBlobGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageBlob runs a test to see if a specific instance of StorageBlob round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageBlob(subject StorageBlob) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageBlob
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageBlob instances for property testing - lazily instantiated by StorageBlobGenerator()
var storageBlobGenerator gopter.Gen

// StorageBlobGenerator returns a generator of StorageBlob instances for property testing.
func StorageBlobGenerator() gopter.Gen {
	if storageBlobGenerator != nil {
		return storageBlobGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageBlob(generators)
	storageBlobGenerator = gen.Struct(reflect.TypeOf(StorageBlob{}), generators)

	return storageBlobGenerator
}

// AddIndependentPropertyGeneratorsForStorageBlob is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageBlob(gens map[string]gopter.Gen) {
	gens["BlobUrl"] = gen.PtrOf(gen.AlphaString())
	gens["LookupType"] = gen.PtrOf(gen.OneConstOf(StorageBlob_LookupType_Cidr, StorageBlob_LookupType_String))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_StorageBlobDestination_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from StorageBlobDestination to StorageBlobDestination via AssignProperties_To_StorageBlobDestination & AssignProperties_From_StorageBlobDestination returns original",
		prop.ForAll(RunPropertyAssignmentTestForStorageBlobDestination, StorageBlobDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForStorageBlobDestination tests if a specific instance of StorageBlobDestination can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForStorageBlobDestination(subject StorageBlobDestination) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.StorageBlobDestination
	err := copied.AssignProperties_To_StorageBlobDestination(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual StorageBlobDestination
	err = actual.AssignProperties_From_StorageBlobDestination(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_StorageBlobDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageBlobDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageBlobDestination, StorageBlobDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageBlobDestination runs a test to see if a specific instance of StorageBlobDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageBlobDestination(subject StorageBlobDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageBlobDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageBlobDestination instances for property testing - lazily instantiated by
// StorageBlobDestinationGenerator()
var storageBlobDestinationGenerator gopter.Gen

// StorageBlobDestinationGenerator returns a generator of StorageBlobDestination instances for property testing.
func StorageBlobDestinationGenerator() gopter.Gen {
	if storageBlobDestinationGenerator != nil {
		return storageBlobDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageBlobDestination(generators)
	storageBlobDestinationGenerator = gen.Struct(reflect.TypeOf(StorageBlobDestination{}), generators)

	return storageBlobDestinationGenerator
}

// AddIndependentPropertyGeneratorsForStorageBlobDestination is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageBlobDestination(gens map[string]gopter.Gen) {
	gens["ContainerName"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_StorageBlobDestination_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from StorageBlobDestination_STATUS to StorageBlobDestination_STATUS via AssignProperties_To_StorageBlobDestination_STATUS & AssignProperties_From_StorageBlobDestination_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForStorageBlobDestination_STATUS, StorageBlobDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForStorageBlobDestination_STATUS tests if a specific instance of StorageBlobDestination_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForStorageBlobDestination_STATUS(subject StorageBlobDestination_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.StorageBlobDestination_STATUS
	err := copied.AssignProperties_To_StorageBlobDestination_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual StorageBlobDestination_STATUS
	err = actual.AssignProperties_From_StorageBlobDestination_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_StorageBlobDestination_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageBlobDestination_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageBlobDestination_STATUS, StorageBlobDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageBlobDestination_STATUS runs a test to see if a specific instance of StorageBlobDestination_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageBlobDestination_STATUS(subject StorageBlobDestination_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageBlobDestination_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageBlobDestination_STATUS instances for property testing - lazily instantiated by
// StorageBlobDestination_STATUSGenerator()
var storageBlobDestination_STATUSGenerator gopter.Gen

// StorageBlobDestination_STATUSGenerator returns a generator of StorageBlobDestination_STATUS instances for property testing.
func StorageBlobDestination_STATUSGenerator() gopter.Gen {
	if storageBlobDestination_STATUSGenerator != nil {
		return storageBlobDestination_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageBlobDestination_STATUS(generators)
	storageBlobDestination_STATUSGenerator = gen.Struct(reflect.TypeOf(StorageBlobDestination_STATUS{}), generators)

	return storageBlobDestination_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForStorageBlobDestination_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageBlobDestination_STATUS(gens map[string]gopter.Gen) {
	gens["ContainerName"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_StorageBlob_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from StorageBlob_STATUS to StorageBlob_STATUS via AssignProperties_To_StorageBlob_STATUS & AssignProperties_From_StorageBlob_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForStorageBlob_STATUS, StorageBlob_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForStorageBlob_STATUS tests if a specific instance of StorageBlob_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForStorageBlob_STATUS(subject StorageBlob_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.StorageBlob_STATUS
	err := copied.AssignProperties_To_StorageBlob_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual StorageBlob_STATUS
	err = actual.AssignProperties_From_StorageBlob_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_StorageBlob_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageBlob_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageBlob_STATUS, StorageBlob_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageBlob_STATUS runs a test to see if a specific instance of StorageBlob_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageBlob_STATUS(subject StorageBlob_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageBlob_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageBlob_STATUS instances for property testing - lazily instantiated by StorageBlob_STATUSGenerator()
var storageBlob_STATUSGenerator gopter.Gen

// StorageBlob_STATUSGenerator returns a generator of StorageBlob_STATUS instances for property testing.
func StorageBlob_STATUSGenerator() gopter.Gen {
	if storageBlob_STATUSGenerator != nil {
		return storageBlob_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageBlob_STATUS(generators)
	storageBlob_STATUSGenerator = gen.Struct(reflect.TypeOf(StorageBlob_STATUS{}), generators)

	return storageBlob_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForStorageBlob_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageBlob_STATUS(gens map[string]gopter.Gen) {
	gens["BlobUrl"] = gen.PtrOf(gen.AlphaString())
	gens["LookupType"] = gen.PtrOf(gen.OneConstOf(StorageBlob_LookupType_STATUS_Cidr, StorageBlob_LookupType_STATUS_String))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_StorageTableDestination_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from StorageTableDestination to StorageTableDestination via AssignProperties_To_StorageTableDestination & AssignProperties_From_StorageTableDestination returns original",
		prop.ForAll(RunPropertyAssignmentTestForStorageTableDestination, StorageTableDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForStorageTableDestination tests if a specific instance of StorageTableDestination can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForStorageTableDestination(subject StorageTableDestination) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.StorageTableDestination
	err := copied.AssignProperties_To_StorageTableDestination(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual StorageTableDestination
	err = actual.AssignProperties_From_StorageTableDestination(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_StorageTableDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageTableDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageTableDestination, StorageTableDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageTableDestination runs a test to see if a specific instance of StorageTableDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageTableDestination(subject StorageTableDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageTableDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageTableDestination instances for property testing - lazily instantiated by
// StorageTableDestinationGenerator()
var storageTableDestinationGenerator gopter.Gen

// StorageTableDestinationGenerator returns a generator of StorageTableDestination instances for property testing.
func StorageTableDestinationGenerator() gopter.Gen {
	if storageTableDestinationGenerator != nil {
		return storageTableDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageTableDestination(generators)
	storageTableDestinationGenerator = gen.Struct(reflect.TypeOf(StorageTableDestination{}), generators)

	return storageTableDestinationGenerator
}

// AddIndependentPropertyGeneratorsForStorageTableDestination is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageTableDestination(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["TableName"] = gen.PtrOf(gen.AlphaString())
}

func Test_StorageTableDestination_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from StorageTableDestination_STATUS to StorageTableDestination_STATUS via AssignProperties_To_StorageTableDestination_STATUS & AssignProperties_From_StorageTableDestination_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForStorageTableDestination_STATUS, StorageTableDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForStorageTableDestination_STATUS tests if a specific instance of StorageTableDestination_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForStorageTableDestination_STATUS(subject StorageTableDestination_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.StorageTableDestination_STATUS
	err := copied.AssignProperties_To_StorageTableDestination_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual StorageTableDestination_STATUS
	err = actual.AssignProperties_From_StorageTableDestination_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_StorageTableDestination_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageTableDestination_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageTableDestination_STATUS, StorageTableDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageTableDestination_STATUS runs a test to see if a specific instance of StorageTableDestination_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageTableDestination_STATUS(subject StorageTableDestination_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageTableDestination_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageTableDestination_STATUS instances for property testing - lazily instantiated by
// StorageTableDestination_STATUSGenerator()
var storageTableDestination_STATUSGenerator gopter.Gen

// StorageTableDestination_STATUSGenerator returns a generator of StorageTableDestination_STATUS instances for property testing.
func StorageTableDestination_STATUSGenerator() gopter.Gen {
	if storageTableDestination_STATUSGenerator != nil {
		return storageTableDestination_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageTableDestination_STATUS(generators)
	storageTableDestination_STATUSGenerator = gen.Struct(reflect.TypeOf(StorageTableDestination_STATUS{}), generators)

	return storageTableDestination_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForStorageTableDestination_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageTableDestination_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["TableName"] = gen.PtrOf(gen.AlphaString())
}

func Test_StreamDeclaration_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from StreamDeclaration to StreamDeclaration via AssignProperties_To_StreamDeclaration & AssignProperties_From_StreamDeclaration returns original",
		prop.ForAll(RunPropertyAssignmentTestForStreamDeclaration, StreamDeclarationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForStreamDeclaration tests if a specific instance of StreamDeclaration can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForStreamDeclaration(subject StreamDeclaration) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.StreamDeclaration
	err := copied.AssignProperties_To_StreamDeclaration(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual StreamDeclaration
	err = actual.AssignProperties_From_StreamDeclaration(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_StreamDeclaration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StreamDeclaration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStreamDeclaration, StreamDeclarationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStreamDeclaration runs a test to see if a specific instance of StreamDeclaration round trips to JSON and back losslessly
func RunJSONSerializationTestForStreamDeclaration(subject StreamDeclaration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StreamDeclaration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StreamDeclaration instances for property testing - lazily instantiated by StreamDeclarationGenerator()
var streamDeclarationGenerator gopter.Gen

// StreamDeclarationGenerator returns a generator of StreamDeclaration instances for property testing.
func StreamDeclarationGenerator() gopter.Gen {
	if streamDeclarationGenerator != nil {
		return streamDeclarationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForStreamDeclaration(generators)
	streamDeclarationGenerator = gen.Struct(reflect.TypeOf(StreamDeclaration{}), generators)

	return streamDeclarationGenerator
}

// AddRelatedPropertyGeneratorsForStreamDeclaration is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStreamDeclaration(gens map[string]gopter.Gen) {
	gens["Columns"] = gen.SliceOf(ColumnDefinitionGenerator())
}

func Test_StreamDeclaration_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from StreamDeclaration_STATUS to StreamDeclaration_STATUS via AssignProperties_To_StreamDeclaration_STATUS & AssignProperties_From_StreamDeclaration_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForStreamDeclaration_STATUS, StreamDeclaration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForStreamDeclaration_STATUS tests if a specific instance of StreamDeclaration_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForStreamDeclaration_STATUS(subject StreamDeclaration_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.StreamDeclaration_STATUS
	err := copied.AssignProperties_To_StreamDeclaration_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual StreamDeclaration_STATUS
	err = actual.AssignProperties_From_StreamDeclaration_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_StreamDeclaration_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StreamDeclaration_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStreamDeclaration_STATUS, StreamDeclaration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStreamDeclaration_STATUS runs a test to see if a specific instance of StreamDeclaration_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForStreamDeclaration_STATUS(subject StreamDeclaration_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StreamDeclaration_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StreamDeclaration_STATUS instances for property testing - lazily instantiated by
// StreamDeclaration_STATUSGenerator()
var streamDeclaration_STATUSGenerator gopter.Gen

// StreamDeclaration_STATUSGenerator returns a generator of StreamDeclaration_STATUS instances for property testing.
func StreamDeclaration_STATUSGenerator() gopter.Gen {
	if streamDeclaration_STATUSGenerator != nil {
		return streamDeclaration_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForStreamDeclaration_STATUS(generators)
	streamDeclaration_STATUSGenerator = gen.Struct(reflect.TypeOf(StreamDeclaration_STATUS{}), generators)

	return streamDeclaration_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForStreamDeclaration_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStreamDeclaration_STATUS(gens map[string]gopter.Gen) {
	gens["Columns"] = gen.SliceOf(ColumnDefinition_STATUSGenerator())
}

func Test_SyslogDataSource_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SyslogDataSource to SyslogDataSource via AssignProperties_To_SyslogDataSource & AssignProperties_From_SyslogDataSource returns original",
		prop.ForAll(RunPropertyAssignmentTestForSyslogDataSource, SyslogDataSourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSyslogDataSource tests if a specific instance of SyslogDataSource can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSyslogDataSource(subject SyslogDataSource) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.SyslogDataSource
	err := copied.AssignProperties_To_SyslogDataSource(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SyslogDataSource
	err = actual.AssignProperties_From_SyslogDataSource(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SyslogDataSource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SyslogDataSource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSyslogDataSource, SyslogDataSourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSyslogDataSource runs a test to see if a specific instance of SyslogDataSource round trips to JSON and back losslessly
func RunJSONSerializationTestForSyslogDataSource(subject SyslogDataSource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SyslogDataSource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SyslogDataSource instances for property testing - lazily instantiated by SyslogDataSourceGenerator()
var syslogDataSourceGenerator gopter.Gen

// SyslogDataSourceGenerator returns a generator of SyslogDataSource instances for property testing.
func SyslogDataSourceGenerator() gopter.Gen {
	if syslogDataSourceGenerator != nil {
		return syslogDataSourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSyslogDataSource(generators)
	syslogDataSourceGenerator = gen.Struct(reflect.TypeOf(SyslogDataSource{}), generators)

	return syslogDataSourceGenerator
}

// AddIndependentPropertyGeneratorsForSyslogDataSource is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSyslogDataSource(gens map[string]gopter.Gen) {
	gens["FacilityNames"] = gen.SliceOf(gen.OneConstOf(
		SyslogDataSource_FacilityNames_Alert,
		SyslogDataSource_FacilityNames_Audit,
		SyslogDataSource_FacilityNames_Auth,
		SyslogDataSource_FacilityNames_Authpriv,
		SyslogDataSource_FacilityNames_Clock,
		SyslogDataSource_FacilityNames_Cron,
		SyslogDataSource_FacilityNames_Daemon,
		SyslogDataSource_FacilityNames_Ftp,
		SyslogDataSource_FacilityNames_Kern,
		SyslogDataSource_FacilityNames_Local0,
		SyslogDataSource_FacilityNames_Local1,
		SyslogDataSource_FacilityNames_Local2,
		SyslogDataSource_FacilityNames_Local3,
		SyslogDataSource_FacilityNames_Local4,
		SyslogDataSource_FacilityNames_Local5,
		SyslogDataSource_FacilityNames_Local6,
		SyslogDataSource_FacilityNames_Local7,
		SyslogDataSource_FacilityNames_Lpr,
		SyslogDataSource_FacilityNames_Mail,
		SyslogDataSource_FacilityNames_Mark,
		SyslogDataSource_FacilityNames_News,
		SyslogDataSource_FacilityNames_Nopri,
		SyslogDataSource_FacilityNames_Ntp,
		SyslogDataSource_FacilityNames_Star,
		SyslogDataSource_FacilityNames_Syslog,
		SyslogDataSource_FacilityNames_User,
		SyslogDataSource_FacilityNames_Uucp))
	gens["LogLevels"] = gen.SliceOf(gen.OneConstOf(
		SyslogDataSource_LogLevels_Alert,
		SyslogDataSource_LogLevels_Critical,
		SyslogDataSource_LogLevels_Debug,
		SyslogDataSource_LogLevels_Emergency,
		SyslogDataSource_LogLevels_Error,
		SyslogDataSource_LogLevels_Info,
		SyslogDataSource_LogLevels_Notice,
		SyslogDataSource_LogLevels_Star,
		SyslogDataSource_LogLevels_Warning))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Streams"] = gen.SliceOf(gen.OneConstOf(SyslogDataSource_Streams_MicrosoftSyslog))
	gens["TransformKql"] = gen.PtrOf(gen.AlphaString())
}

func Test_SyslogDataSource_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SyslogDataSource_STATUS to SyslogDataSource_STATUS via AssignProperties_To_SyslogDataSource_STATUS & AssignProperties_From_SyslogDataSource_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSyslogDataSource_STATUS, SyslogDataSource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSyslogDataSource_STATUS tests if a specific instance of SyslogDataSource_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSyslogDataSource_STATUS(subject SyslogDataSource_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.SyslogDataSource_STATUS
	err := copied.AssignProperties_To_SyslogDataSource_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SyslogDataSource_STATUS
	err = actual.AssignProperties_From_SyslogDataSource_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SyslogDataSource_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SyslogDataSource_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSyslogDataSource_STATUS, SyslogDataSource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSyslogDataSource_STATUS runs a test to see if a specific instance of SyslogDataSource_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSyslogDataSource_STATUS(subject SyslogDataSource_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SyslogDataSource_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SyslogDataSource_STATUS instances for property testing - lazily instantiated by
// SyslogDataSource_STATUSGenerator()
var syslogDataSource_STATUSGenerator gopter.Gen

// SyslogDataSource_STATUSGenerator returns a generator of SyslogDataSource_STATUS instances for property testing.
func SyslogDataSource_STATUSGenerator() gopter.Gen {
	if syslogDataSource_STATUSGenerator != nil {
		return syslogDataSource_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSyslogDataSource_STATUS(generators)
	syslogDataSource_STATUSGenerator = gen.Struct(reflect.TypeOf(SyslogDataSource_STATUS{}), generators)

	return syslogDataSource_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSyslogDataSource_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSyslogDataSource_STATUS(gens map[string]gopter.Gen) {
	gens["FacilityNames"] = gen.SliceOf(gen.OneConstOf(
		SyslogDataSource_FacilityNames_STATUS_Alert,
		SyslogDataSource_FacilityNames_STATUS_Audit,
		SyslogDataSource_FacilityNames_STATUS_Auth,
		SyslogDataSource_FacilityNames_STATUS_Authpriv,
		SyslogDataSource_FacilityNames_STATUS_Clock,
		SyslogDataSource_FacilityNames_STATUS_Cron,
		SyslogDataSource_FacilityNames_STATUS_Daemon,
		SyslogDataSource_FacilityNames_STATUS_Ftp,
		SyslogDataSource_FacilityNames_STATUS_Kern,
		SyslogDataSource_FacilityNames_STATUS_Local0,
		SyslogDataSource_FacilityNames_STATUS_Local1,
		SyslogDataSource_FacilityNames_STATUS_Local2,
		SyslogDataSource_FacilityNames_STATUS_Local3,
		SyslogDataSource_FacilityNames_STATUS_Local4,
		SyslogDataSource_FacilityNames_STATUS_Local5,
		SyslogDataSource_FacilityNames_STATUS_Local6,
		SyslogDataSource_FacilityNames_STATUS_Local7,
		SyslogDataSource_FacilityNames_STATUS_Lpr,
		SyslogDataSource_FacilityNames_STATUS_Mail,
		SyslogDataSource_FacilityNames_STATUS_Mark,
		SyslogDataSource_FacilityNames_STATUS_News,
		SyslogDataSource_FacilityNames_STATUS_Nopri,
		SyslogDataSource_FacilityNames_STATUS_Ntp,
		SyslogDataSource_FacilityNames_STATUS_Star,
		SyslogDataSource_FacilityNames_STATUS_Syslog,
		SyslogDataSource_FacilityNames_STATUS_User,
		SyslogDataSource_FacilityNames_STATUS_Uucp))
	gens["LogLevels"] = gen.SliceOf(gen.OneConstOf(
		SyslogDataSource_LogLevels_STATUS_Alert,
		SyslogDataSource_LogLevels_STATUS_Critical,
		SyslogDataSource_LogLevels_STATUS_Debug,
		SyslogDataSource_LogLevels_STATUS_Emergency,
		SyslogDataSource_LogLevels_STATUS_Error,
		SyslogDataSource_LogLevels_STATUS_Info,
		SyslogDataSource_LogLevels_STATUS_Notice,
		SyslogDataSource_LogLevels_STATUS_Star,
		SyslogDataSource_LogLevels_STATUS_Warning))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Streams"] = gen.SliceOf(gen.OneConstOf(SyslogDataSource_Streams_STATUS_MicrosoftSyslog))
	gens["TransformKql"] = gen.PtrOf(gen.AlphaString())
}

func Test_SystemData_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SystemData_STATUS to SystemData_STATUS via AssignProperties_To_SystemData_STATUS & AssignProperties_From_SystemData_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSystemData_STATUS, SystemData_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSystemData_STATUS tests if a specific instance of SystemData_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSystemData_STATUS(subject SystemData_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.SystemData_STATUS
	err := copied.AssignProperties_To_SystemData_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SystemData_STATUS
	err = actual.AssignProperties_From_SystemData_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SystemData_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SystemData_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSystemData_STATUS, SystemData_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSystemData_STATUS runs a test to see if a specific instance of SystemData_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSystemData_STATUS(subject SystemData_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SystemData_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SystemData_STATUS instances for property testing - lazily instantiated by SystemData_STATUSGenerator()
var systemData_STATUSGenerator gopter.Gen

// SystemData_STATUSGenerator returns a generator of SystemData_STATUS instances for property testing.
func SystemData_STATUSGenerator() gopter.Gen {
	if systemData_STATUSGenerator != nil {
		return systemData_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSystemData_STATUS(generators)
	systemData_STATUSGenerator = gen.Struct(reflect.TypeOf(SystemData_STATUS{}), generators)

	return systemData_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSystemData_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSystemData_STATUS(gens map[string]gopter.Gen) {
	gens["CreatedAt"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedBy"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemData_CreatedByType_STATUS_Application,
		SystemData_CreatedByType_STATUS_Key,
		SystemData_CreatedByType_STATUS_ManagedIdentity,
		SystemData_CreatedByType_STATUS_User))
	gens["LastModifiedAt"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedBy"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemData_LastModifiedByType_STATUS_Application,
		SystemData_LastModifiedByType_STATUS_Key,
		SystemData_LastModifiedByType_STATUS_ManagedIdentity,
		SystemData_LastModifiedByType_STATUS_User))
}

func Test_UserAssignedIdentityDetails_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UserAssignedIdentityDetails to UserAssignedIdentityDetails via AssignProperties_To_UserAssignedIdentityDetails & AssignProperties_From_UserAssignedIdentityDetails returns original",
		prop.ForAll(RunPropertyAssignmentTestForUserAssignedIdentityDetails, UserAssignedIdentityDetailsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUserAssignedIdentityDetails tests if a specific instance of UserAssignedIdentityDetails can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForUserAssignedIdentityDetails(subject UserAssignedIdentityDetails) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.UserAssignedIdentityDetails
	err := copied.AssignProperties_To_UserAssignedIdentityDetails(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UserAssignedIdentityDetails
	err = actual.AssignProperties_From_UserAssignedIdentityDetails(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UserAssignedIdentityDetails_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentityDetails via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentityDetails, UserAssignedIdentityDetailsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentityDetails runs a test to see if a specific instance of UserAssignedIdentityDetails round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentityDetails(subject UserAssignedIdentityDetails) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentityDetails
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentityDetails instances for property testing - lazily instantiated by
// UserAssignedIdentityDetailsGenerator()
var userAssignedIdentityDetailsGenerator gopter.Gen

// UserAssignedIdentityDetailsGenerator returns a generator of UserAssignedIdentityDetails instances for property testing.
func UserAssignedIdentityDetailsGenerator() gopter.Gen {
	if userAssignedIdentityDetailsGenerator != nil {
		return userAssignedIdentityDetailsGenerator
	}

	generators := make(map[string]gopter.Gen)
	userAssignedIdentityDetailsGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentityDetails{}), generators)

	return userAssignedIdentityDetailsGenerator
}

func Test_UserAssignedIdentity_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UserAssignedIdentity_STATUS to UserAssignedIdentity_STATUS via AssignProperties_To_UserAssignedIdentity_STATUS & AssignProperties_From_UserAssignedIdentity_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForUserAssignedIdentity_STATUS, UserAssignedIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUserAssignedIdentity_STATUS tests if a specific instance of UserAssignedIdentity_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForUserAssignedIdentity_STATUS(subject UserAssignedIdentity_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.UserAssignedIdentity_STATUS
	err := copied.AssignProperties_To_UserAssignedIdentity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UserAssignedIdentity_STATUS
	err = actual.AssignProperties_From_UserAssignedIdentity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UserAssignedIdentity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentity_STATUS, UserAssignedIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentity_STATUS runs a test to see if a specific instance of UserAssignedIdentity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentity_STATUS(subject UserAssignedIdentity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentity_STATUS instances for property testing - lazily instantiated by
// UserAssignedIdentity_STATUSGenerator()
var userAssignedIdentity_STATUSGenerator gopter.Gen

// UserAssignedIdentity_STATUSGenerator returns a generator of UserAssignedIdentity_STATUS instances for property testing.
func UserAssignedIdentity_STATUSGenerator() gopter.Gen {
	if userAssignedIdentity_STATUSGenerator != nil {
		return userAssignedIdentity_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserAssignedIdentity_STATUS(generators)
	userAssignedIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentity_STATUS{}), generators)

	return userAssignedIdentity_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForUserAssignedIdentity_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserAssignedIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_WindowsEventLogDataSource_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WindowsEventLogDataSource to WindowsEventLogDataSource via AssignProperties_To_WindowsEventLogDataSource & AssignProperties_From_WindowsEventLogDataSource returns original",
		prop.ForAll(RunPropertyAssignmentTestForWindowsEventLogDataSource, WindowsEventLogDataSourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWindowsEventLogDataSource tests if a specific instance of WindowsEventLogDataSource can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWindowsEventLogDataSource(subject WindowsEventLogDataSource) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.WindowsEventLogDataSource
	err := copied.AssignProperties_To_WindowsEventLogDataSource(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WindowsEventLogDataSource
	err = actual.AssignProperties_From_WindowsEventLogDataSource(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WindowsEventLogDataSource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WindowsEventLogDataSource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWindowsEventLogDataSource, WindowsEventLogDataSourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWindowsEventLogDataSource runs a test to see if a specific instance of WindowsEventLogDataSource round trips to JSON and back losslessly
func RunJSONSerializationTestForWindowsEventLogDataSource(subject WindowsEventLogDataSource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WindowsEventLogDataSource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WindowsEventLogDataSource instances for property testing - lazily instantiated by
// WindowsEventLogDataSourceGenerator()
var windowsEventLogDataSourceGenerator gopter.Gen

// WindowsEventLogDataSourceGenerator returns a generator of WindowsEventLogDataSource instances for property testing.
func WindowsEventLogDataSourceGenerator() gopter.Gen {
	if windowsEventLogDataSourceGenerator != nil {
		return windowsEventLogDataSourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsEventLogDataSource(generators)
	windowsEventLogDataSourceGenerator = gen.Struct(reflect.TypeOf(WindowsEventLogDataSource{}), generators)

	return windowsEventLogDataSourceGenerator
}

// AddIndependentPropertyGeneratorsForWindowsEventLogDataSource is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWindowsEventLogDataSource(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Streams"] = gen.SliceOf(gen.OneConstOf(WindowsEventLogDataSource_Streams_MicrosoftEvent, WindowsEventLogDataSource_Streams_MicrosoftWindowsEvent))
	gens["TransformKql"] = gen.PtrOf(gen.AlphaString())
	gens["XPathQueries"] = gen.SliceOf(gen.AlphaString())
}

func Test_WindowsEventLogDataSource_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WindowsEventLogDataSource_STATUS to WindowsEventLogDataSource_STATUS via AssignProperties_To_WindowsEventLogDataSource_STATUS & AssignProperties_From_WindowsEventLogDataSource_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForWindowsEventLogDataSource_STATUS, WindowsEventLogDataSource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWindowsEventLogDataSource_STATUS tests if a specific instance of WindowsEventLogDataSource_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWindowsEventLogDataSource_STATUS(subject WindowsEventLogDataSource_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.WindowsEventLogDataSource_STATUS
	err := copied.AssignProperties_To_WindowsEventLogDataSource_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WindowsEventLogDataSource_STATUS
	err = actual.AssignProperties_From_WindowsEventLogDataSource_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WindowsEventLogDataSource_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WindowsEventLogDataSource_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWindowsEventLogDataSource_STATUS, WindowsEventLogDataSource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWindowsEventLogDataSource_STATUS runs a test to see if a specific instance of WindowsEventLogDataSource_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForWindowsEventLogDataSource_STATUS(subject WindowsEventLogDataSource_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WindowsEventLogDataSource_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WindowsEventLogDataSource_STATUS instances for property testing - lazily instantiated by
// WindowsEventLogDataSource_STATUSGenerator()
var windowsEventLogDataSource_STATUSGenerator gopter.Gen

// WindowsEventLogDataSource_STATUSGenerator returns a generator of WindowsEventLogDataSource_STATUS instances for property testing.
func WindowsEventLogDataSource_STATUSGenerator() gopter.Gen {
	if windowsEventLogDataSource_STATUSGenerator != nil {
		return windowsEventLogDataSource_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsEventLogDataSource_STATUS(generators)
	windowsEventLogDataSource_STATUSGenerator = gen.Struct(reflect.TypeOf(WindowsEventLogDataSource_STATUS{}), generators)

	return windowsEventLogDataSource_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForWindowsEventLogDataSource_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWindowsEventLogDataSource_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Streams"] = gen.SliceOf(gen.OneConstOf(WindowsEventLogDataSource_Streams_STATUS_MicrosoftEvent, WindowsEventLogDataSource_Streams_STATUS_MicrosoftWindowsEvent))
	gens["TransformKql"] = gen.PtrOf(gen.AlphaString())
	gens["XPathQueries"] = gen.SliceOf(gen.AlphaString())
}

func Test_WindowsFirewallLogsDataSource_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WindowsFirewallLogsDataSource to WindowsFirewallLogsDataSource via AssignProperties_To_WindowsFirewallLogsDataSource & AssignProperties_From_WindowsFirewallLogsDataSource returns original",
		prop.ForAll(RunPropertyAssignmentTestForWindowsFirewallLogsDataSource, WindowsFirewallLogsDataSourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWindowsFirewallLogsDataSource tests if a specific instance of WindowsFirewallLogsDataSource can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWindowsFirewallLogsDataSource(subject WindowsFirewallLogsDataSource) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.WindowsFirewallLogsDataSource
	err := copied.AssignProperties_To_WindowsFirewallLogsDataSource(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WindowsFirewallLogsDataSource
	err = actual.AssignProperties_From_WindowsFirewallLogsDataSource(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WindowsFirewallLogsDataSource_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WindowsFirewallLogsDataSource via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWindowsFirewallLogsDataSource, WindowsFirewallLogsDataSourceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWindowsFirewallLogsDataSource runs a test to see if a specific instance of WindowsFirewallLogsDataSource round trips to JSON and back losslessly
func RunJSONSerializationTestForWindowsFirewallLogsDataSource(subject WindowsFirewallLogsDataSource) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WindowsFirewallLogsDataSource
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WindowsFirewallLogsDataSource instances for property testing - lazily instantiated by
// WindowsFirewallLogsDataSourceGenerator()
var windowsFirewallLogsDataSourceGenerator gopter.Gen

// WindowsFirewallLogsDataSourceGenerator returns a generator of WindowsFirewallLogsDataSource instances for property testing.
func WindowsFirewallLogsDataSourceGenerator() gopter.Gen {
	if windowsFirewallLogsDataSourceGenerator != nil {
		return windowsFirewallLogsDataSourceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsFirewallLogsDataSource(generators)
	windowsFirewallLogsDataSourceGenerator = gen.Struct(reflect.TypeOf(WindowsFirewallLogsDataSource{}), generators)

	return windowsFirewallLogsDataSourceGenerator
}

// AddIndependentPropertyGeneratorsForWindowsFirewallLogsDataSource is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWindowsFirewallLogsDataSource(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ProfileFilter"] = gen.SliceOf(gen.OneConstOf(WindowsFirewallLogsDataSource_ProfileFilter_Domain, WindowsFirewallLogsDataSource_ProfileFilter_Private, WindowsFirewallLogsDataSource_ProfileFilter_Public))
	gens["Streams"] = gen.SliceOf(gen.AlphaString())
}

func Test_WindowsFirewallLogsDataSource_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WindowsFirewallLogsDataSource_STATUS to WindowsFirewallLogsDataSource_STATUS via AssignProperties_To_WindowsFirewallLogsDataSource_STATUS & AssignProperties_From_WindowsFirewallLogsDataSource_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForWindowsFirewallLogsDataSource_STATUS, WindowsFirewallLogsDataSource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWindowsFirewallLogsDataSource_STATUS tests if a specific instance of WindowsFirewallLogsDataSource_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWindowsFirewallLogsDataSource_STATUS(subject WindowsFirewallLogsDataSource_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.WindowsFirewallLogsDataSource_STATUS
	err := copied.AssignProperties_To_WindowsFirewallLogsDataSource_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WindowsFirewallLogsDataSource_STATUS
	err = actual.AssignProperties_From_WindowsFirewallLogsDataSource_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WindowsFirewallLogsDataSource_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WindowsFirewallLogsDataSource_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWindowsFirewallLogsDataSource_STATUS, WindowsFirewallLogsDataSource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWindowsFirewallLogsDataSource_STATUS runs a test to see if a specific instance of WindowsFirewallLogsDataSource_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForWindowsFirewallLogsDataSource_STATUS(subject WindowsFirewallLogsDataSource_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WindowsFirewallLogsDataSource_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WindowsFirewallLogsDataSource_STATUS instances for property testing - lazily instantiated by
// WindowsFirewallLogsDataSource_STATUSGenerator()
var windowsFirewallLogsDataSource_STATUSGenerator gopter.Gen

// WindowsFirewallLogsDataSource_STATUSGenerator returns a generator of WindowsFirewallLogsDataSource_STATUS instances for property testing.
func WindowsFirewallLogsDataSource_STATUSGenerator() gopter.Gen {
	if windowsFirewallLogsDataSource_STATUSGenerator != nil {
		return windowsFirewallLogsDataSource_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsFirewallLogsDataSource_STATUS(generators)
	windowsFirewallLogsDataSource_STATUSGenerator = gen.Struct(reflect.TypeOf(WindowsFirewallLogsDataSource_STATUS{}), generators)

	return windowsFirewallLogsDataSource_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForWindowsFirewallLogsDataSource_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWindowsFirewallLogsDataSource_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ProfileFilter"] = gen.SliceOf(gen.OneConstOf(WindowsFirewallLogsDataSource_ProfileFilter_STATUS_Domain, WindowsFirewallLogsDataSource_ProfileFilter_STATUS_Private, WindowsFirewallLogsDataSource_ProfileFilter_STATUS_Public))
	gens["Streams"] = gen.SliceOf(gen.AlphaString())
}
