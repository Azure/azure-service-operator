// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20221001

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_AutoscaleNotification_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoscaleNotification_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoscaleNotification_ARM, AutoscaleNotification_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoscaleNotification_ARM runs a test to see if a specific instance of AutoscaleNotification_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoscaleNotification_ARM(subject AutoscaleNotification_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoscaleNotification_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoscaleNotification_ARM instances for property testing - lazily instantiated by
// AutoscaleNotification_ARMGenerator()
var autoscaleNotification_ARMGenerator gopter.Gen

// AutoscaleNotification_ARMGenerator returns a generator of AutoscaleNotification_ARM instances for property testing.
// We first initialize autoscaleNotification_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AutoscaleNotification_ARMGenerator() gopter.Gen {
	if autoscaleNotification_ARMGenerator != nil {
		return autoscaleNotification_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscaleNotification_ARM(generators)
	autoscaleNotification_ARMGenerator = gen.Struct(reflect.TypeOf(AutoscaleNotification_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscaleNotification_ARM(generators)
	AddRelatedPropertyGeneratorsForAutoscaleNotification_ARM(generators)
	autoscaleNotification_ARMGenerator = gen.Struct(reflect.TypeOf(AutoscaleNotification_ARM{}), generators)

	return autoscaleNotification_ARMGenerator
}

// AddIndependentPropertyGeneratorsForAutoscaleNotification_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoscaleNotification_ARM(gens map[string]gopter.Gen) {
	gens["Operation"] = gen.PtrOf(gen.OneConstOf(AutoscaleNotification_Operation_ARM_Scale))
}

// AddRelatedPropertyGeneratorsForAutoscaleNotification_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoscaleNotification_ARM(gens map[string]gopter.Gen) {
	gens["Email"] = gen.PtrOf(EmailNotification_ARMGenerator())
	gens["Webhooks"] = gen.SliceOf(WebhookNotification_ARMGenerator())
}

func Test_AutoscaleProfile_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoscaleProfile_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoscaleProfile_ARM, AutoscaleProfile_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoscaleProfile_ARM runs a test to see if a specific instance of AutoscaleProfile_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoscaleProfile_ARM(subject AutoscaleProfile_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoscaleProfile_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoscaleProfile_ARM instances for property testing - lazily instantiated by
// AutoscaleProfile_ARMGenerator()
var autoscaleProfile_ARMGenerator gopter.Gen

// AutoscaleProfile_ARMGenerator returns a generator of AutoscaleProfile_ARM instances for property testing.
// We first initialize autoscaleProfile_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AutoscaleProfile_ARMGenerator() gopter.Gen {
	if autoscaleProfile_ARMGenerator != nil {
		return autoscaleProfile_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscaleProfile_ARM(generators)
	autoscaleProfile_ARMGenerator = gen.Struct(reflect.TypeOf(AutoscaleProfile_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscaleProfile_ARM(generators)
	AddRelatedPropertyGeneratorsForAutoscaleProfile_ARM(generators)
	autoscaleProfile_ARMGenerator = gen.Struct(reflect.TypeOf(AutoscaleProfile_ARM{}), generators)

	return autoscaleProfile_ARMGenerator
}

// AddIndependentPropertyGeneratorsForAutoscaleProfile_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoscaleProfile_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAutoscaleProfile_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoscaleProfile_ARM(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(ScaleCapacity_ARMGenerator())
	gens["FixedDate"] = gen.PtrOf(TimeWindow_ARMGenerator())
	gens["Recurrence"] = gen.PtrOf(Recurrence_ARMGenerator())
	gens["Rules"] = gen.SliceOf(ScaleRule_ARMGenerator())
}

func Test_AutoscaleSettingProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoscaleSettingProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoscaleSettingProperties_ARM, AutoscaleSettingProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoscaleSettingProperties_ARM runs a test to see if a specific instance of AutoscaleSettingProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoscaleSettingProperties_ARM(subject AutoscaleSettingProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoscaleSettingProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoscaleSettingProperties_ARM instances for property testing - lazily instantiated by
// AutoscaleSettingProperties_ARMGenerator()
var autoscaleSettingProperties_ARMGenerator gopter.Gen

// AutoscaleSettingProperties_ARMGenerator returns a generator of AutoscaleSettingProperties_ARM instances for property testing.
// We first initialize autoscaleSettingProperties_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AutoscaleSettingProperties_ARMGenerator() gopter.Gen {
	if autoscaleSettingProperties_ARMGenerator != nil {
		return autoscaleSettingProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscaleSettingProperties_ARM(generators)
	autoscaleSettingProperties_ARMGenerator = gen.Struct(reflect.TypeOf(AutoscaleSettingProperties_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscaleSettingProperties_ARM(generators)
	AddRelatedPropertyGeneratorsForAutoscaleSettingProperties_ARM(generators)
	autoscaleSettingProperties_ARMGenerator = gen.Struct(reflect.TypeOf(AutoscaleSettingProperties_ARM{}), generators)

	return autoscaleSettingProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForAutoscaleSettingProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoscaleSettingProperties_ARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["TargetResourceLocation"] = gen.PtrOf(gen.AlphaString())
	gens["TargetResourceUri"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAutoscaleSettingProperties_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoscaleSettingProperties_ARM(gens map[string]gopter.Gen) {
	gens["Notifications"] = gen.SliceOf(AutoscaleNotification_ARMGenerator())
	gens["PredictiveAutoscalePolicy"] = gen.PtrOf(PredictiveAutoscalePolicy_ARMGenerator())
	gens["Profiles"] = gen.SliceOf(AutoscaleProfile_ARMGenerator())
}

func Test_Autoscalesetting_Spec_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Autoscalesetting_Spec_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoscalesetting_Spec_ARM, Autoscalesetting_Spec_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoscalesetting_Spec_ARM runs a test to see if a specific instance of Autoscalesetting_Spec_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoscalesetting_Spec_ARM(subject Autoscalesetting_Spec_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Autoscalesetting_Spec_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Autoscalesetting_Spec_ARM instances for property testing - lazily instantiated by
// Autoscalesetting_Spec_ARMGenerator()
var autoscalesetting_Spec_ARMGenerator gopter.Gen

// Autoscalesetting_Spec_ARMGenerator returns a generator of Autoscalesetting_Spec_ARM instances for property testing.
// We first initialize autoscalesetting_Spec_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Autoscalesetting_Spec_ARMGenerator() gopter.Gen {
	if autoscalesetting_Spec_ARMGenerator != nil {
		return autoscalesetting_Spec_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscalesetting_Spec_ARM(generators)
	autoscalesetting_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(Autoscalesetting_Spec_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscalesetting_Spec_ARM(generators)
	AddRelatedPropertyGeneratorsForAutoscalesetting_Spec_ARM(generators)
	autoscalesetting_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(Autoscalesetting_Spec_ARM{}), generators)

	return autoscalesetting_Spec_ARMGenerator
}

// AddIndependentPropertyGeneratorsForAutoscalesetting_Spec_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoscalesetting_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAutoscalesetting_Spec_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoscalesetting_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(AutoscaleSettingProperties_ARMGenerator())
}

func Test_EmailNotification_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EmailNotification_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEmailNotification_ARM, EmailNotification_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEmailNotification_ARM runs a test to see if a specific instance of EmailNotification_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEmailNotification_ARM(subject EmailNotification_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EmailNotification_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EmailNotification_ARM instances for property testing - lazily instantiated by
// EmailNotification_ARMGenerator()
var emailNotification_ARMGenerator gopter.Gen

// EmailNotification_ARMGenerator returns a generator of EmailNotification_ARM instances for property testing.
func EmailNotification_ARMGenerator() gopter.Gen {
	if emailNotification_ARMGenerator != nil {
		return emailNotification_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEmailNotification_ARM(generators)
	emailNotification_ARMGenerator = gen.Struct(reflect.TypeOf(EmailNotification_ARM{}), generators)

	return emailNotification_ARMGenerator
}

// AddIndependentPropertyGeneratorsForEmailNotification_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEmailNotification_ARM(gens map[string]gopter.Gen) {
	gens["CustomEmails"] = gen.SliceOf(gen.AlphaString())
	gens["SendToSubscriptionAdministrator"] = gen.PtrOf(gen.Bool())
	gens["SendToSubscriptionCoAdministrators"] = gen.PtrOf(gen.Bool())
}

func Test_MetricTrigger_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MetricTrigger_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMetricTrigger_ARM, MetricTrigger_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMetricTrigger_ARM runs a test to see if a specific instance of MetricTrigger_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForMetricTrigger_ARM(subject MetricTrigger_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MetricTrigger_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MetricTrigger_ARM instances for property testing - lazily instantiated by MetricTrigger_ARMGenerator()
var metricTrigger_ARMGenerator gopter.Gen

// MetricTrigger_ARMGenerator returns a generator of MetricTrigger_ARM instances for property testing.
// We first initialize metricTrigger_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func MetricTrigger_ARMGenerator() gopter.Gen {
	if metricTrigger_ARMGenerator != nil {
		return metricTrigger_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricTrigger_ARM(generators)
	metricTrigger_ARMGenerator = gen.Struct(reflect.TypeOf(MetricTrigger_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricTrigger_ARM(generators)
	AddRelatedPropertyGeneratorsForMetricTrigger_ARM(generators)
	metricTrigger_ARMGenerator = gen.Struct(reflect.TypeOf(MetricTrigger_ARM{}), generators)

	return metricTrigger_ARMGenerator
}

// AddIndependentPropertyGeneratorsForMetricTrigger_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMetricTrigger_ARM(gens map[string]gopter.Gen) {
	gens["DividePerInstance"] = gen.PtrOf(gen.Bool())
	gens["MetricName"] = gen.PtrOf(gen.AlphaString())
	gens["MetricNamespace"] = gen.PtrOf(gen.AlphaString())
	gens["MetricResourceLocation"] = gen.PtrOf(gen.AlphaString())
	gens["MetricResourceUri"] = gen.PtrOf(gen.AlphaString())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		MetricTrigger_Operator_ARM_Equals,
		MetricTrigger_Operator_ARM_GreaterThan,
		MetricTrigger_Operator_ARM_GreaterThanOrEqual,
		MetricTrigger_Operator_ARM_LessThan,
		MetricTrigger_Operator_ARM_LessThanOrEqual,
		MetricTrigger_Operator_ARM_NotEquals))
	gens["Statistic"] = gen.PtrOf(gen.OneConstOf(
		MetricTrigger_Statistic_ARM_Average,
		MetricTrigger_Statistic_ARM_Count,
		MetricTrigger_Statistic_ARM_Max,
		MetricTrigger_Statistic_ARM_Min,
		MetricTrigger_Statistic_ARM_Sum))
	gens["Threshold"] = gen.PtrOf(gen.Float64())
	gens["TimeAggregation"] = gen.PtrOf(gen.OneConstOf(
		MetricTrigger_TimeAggregation_ARM_Average,
		MetricTrigger_TimeAggregation_ARM_Count,
		MetricTrigger_TimeAggregation_ARM_Last,
		MetricTrigger_TimeAggregation_ARM_Maximum,
		MetricTrigger_TimeAggregation_ARM_Minimum,
		MetricTrigger_TimeAggregation_ARM_Total))
	gens["TimeGrain"] = gen.PtrOf(gen.AlphaString())
	gens["TimeWindow"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForMetricTrigger_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMetricTrigger_ARM(gens map[string]gopter.Gen) {
	gens["Dimensions"] = gen.SliceOf(ScaleRuleMetricDimension_ARMGenerator())
}

func Test_PredictiveAutoscalePolicy_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PredictiveAutoscalePolicy_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPredictiveAutoscalePolicy_ARM, PredictiveAutoscalePolicy_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPredictiveAutoscalePolicy_ARM runs a test to see if a specific instance of PredictiveAutoscalePolicy_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPredictiveAutoscalePolicy_ARM(subject PredictiveAutoscalePolicy_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PredictiveAutoscalePolicy_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PredictiveAutoscalePolicy_ARM instances for property testing - lazily instantiated by
// PredictiveAutoscalePolicy_ARMGenerator()
var predictiveAutoscalePolicy_ARMGenerator gopter.Gen

// PredictiveAutoscalePolicy_ARMGenerator returns a generator of PredictiveAutoscalePolicy_ARM instances for property testing.
func PredictiveAutoscalePolicy_ARMGenerator() gopter.Gen {
	if predictiveAutoscalePolicy_ARMGenerator != nil {
		return predictiveAutoscalePolicy_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPredictiveAutoscalePolicy_ARM(generators)
	predictiveAutoscalePolicy_ARMGenerator = gen.Struct(reflect.TypeOf(PredictiveAutoscalePolicy_ARM{}), generators)

	return predictiveAutoscalePolicy_ARMGenerator
}

// AddIndependentPropertyGeneratorsForPredictiveAutoscalePolicy_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPredictiveAutoscalePolicy_ARM(gens map[string]gopter.Gen) {
	gens["ScaleLookAheadTime"] = gen.PtrOf(gen.AlphaString())
	gens["ScaleMode"] = gen.PtrOf(gen.OneConstOf(PredictiveAutoscalePolicy_ScaleMode_ARM_Disabled, PredictiveAutoscalePolicy_ScaleMode_ARM_Enabled, PredictiveAutoscalePolicy_ScaleMode_ARM_ForecastOnly))
}

func Test_Recurrence_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Recurrence_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRecurrence_ARM, Recurrence_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRecurrence_ARM runs a test to see if a specific instance of Recurrence_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRecurrence_ARM(subject Recurrence_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Recurrence_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Recurrence_ARM instances for property testing - lazily instantiated by Recurrence_ARMGenerator()
var recurrence_ARMGenerator gopter.Gen

// Recurrence_ARMGenerator returns a generator of Recurrence_ARM instances for property testing.
// We first initialize recurrence_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Recurrence_ARMGenerator() gopter.Gen {
	if recurrence_ARMGenerator != nil {
		return recurrence_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRecurrence_ARM(generators)
	recurrence_ARMGenerator = gen.Struct(reflect.TypeOf(Recurrence_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRecurrence_ARM(generators)
	AddRelatedPropertyGeneratorsForRecurrence_ARM(generators)
	recurrence_ARMGenerator = gen.Struct(reflect.TypeOf(Recurrence_ARM{}), generators)

	return recurrence_ARMGenerator
}

// AddIndependentPropertyGeneratorsForRecurrence_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRecurrence_ARM(gens map[string]gopter.Gen) {
	gens["Frequency"] = gen.PtrOf(gen.OneConstOf(
		Recurrence_Frequency_ARM_Day,
		Recurrence_Frequency_ARM_Hour,
		Recurrence_Frequency_ARM_Minute,
		Recurrence_Frequency_ARM_Month,
		Recurrence_Frequency_ARM_None,
		Recurrence_Frequency_ARM_Second,
		Recurrence_Frequency_ARM_Week,
		Recurrence_Frequency_ARM_Year))
}

// AddRelatedPropertyGeneratorsForRecurrence_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRecurrence_ARM(gens map[string]gopter.Gen) {
	gens["Schedule"] = gen.PtrOf(RecurrentSchedule_ARMGenerator())
}

func Test_RecurrentSchedule_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RecurrentSchedule_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRecurrentSchedule_ARM, RecurrentSchedule_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRecurrentSchedule_ARM runs a test to see if a specific instance of RecurrentSchedule_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRecurrentSchedule_ARM(subject RecurrentSchedule_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RecurrentSchedule_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RecurrentSchedule_ARM instances for property testing - lazily instantiated by
// RecurrentSchedule_ARMGenerator()
var recurrentSchedule_ARMGenerator gopter.Gen

// RecurrentSchedule_ARMGenerator returns a generator of RecurrentSchedule_ARM instances for property testing.
func RecurrentSchedule_ARMGenerator() gopter.Gen {
	if recurrentSchedule_ARMGenerator != nil {
		return recurrentSchedule_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRecurrentSchedule_ARM(generators)
	recurrentSchedule_ARMGenerator = gen.Struct(reflect.TypeOf(RecurrentSchedule_ARM{}), generators)

	return recurrentSchedule_ARMGenerator
}

// AddIndependentPropertyGeneratorsForRecurrentSchedule_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRecurrentSchedule_ARM(gens map[string]gopter.Gen) {
	gens["Days"] = gen.SliceOf(gen.AlphaString())
	gens["Hours"] = gen.SliceOf(gen.Int())
	gens["Minutes"] = gen.SliceOf(gen.Int())
	gens["TimeZone"] = gen.PtrOf(gen.AlphaString())
}

func Test_ScaleAction_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScaleAction_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScaleAction_ARM, ScaleAction_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScaleAction_ARM runs a test to see if a specific instance of ScaleAction_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForScaleAction_ARM(subject ScaleAction_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScaleAction_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScaleAction_ARM instances for property testing - lazily instantiated by ScaleAction_ARMGenerator()
var scaleAction_ARMGenerator gopter.Gen

// ScaleAction_ARMGenerator returns a generator of ScaleAction_ARM instances for property testing.
func ScaleAction_ARMGenerator() gopter.Gen {
	if scaleAction_ARMGenerator != nil {
		return scaleAction_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScaleAction_ARM(generators)
	scaleAction_ARMGenerator = gen.Struct(reflect.TypeOf(ScaleAction_ARM{}), generators)

	return scaleAction_ARMGenerator
}

// AddIndependentPropertyGeneratorsForScaleAction_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScaleAction_ARM(gens map[string]gopter.Gen) {
	gens["Cooldown"] = gen.PtrOf(gen.AlphaString())
	gens["Direction"] = gen.PtrOf(gen.OneConstOf(ScaleAction_Direction_ARM_Decrease, ScaleAction_Direction_ARM_Increase, ScaleAction_Direction_ARM_None))
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ScaleAction_Type_ARM_ChangeCount,
		ScaleAction_Type_ARM_ExactCount,
		ScaleAction_Type_ARM_PercentChangeCount,
		ScaleAction_Type_ARM_ServiceAllowedNextValue))
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_ScaleCapacity_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScaleCapacity_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScaleCapacity_ARM, ScaleCapacity_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScaleCapacity_ARM runs a test to see if a specific instance of ScaleCapacity_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForScaleCapacity_ARM(subject ScaleCapacity_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScaleCapacity_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScaleCapacity_ARM instances for property testing - lazily instantiated by ScaleCapacity_ARMGenerator()
var scaleCapacity_ARMGenerator gopter.Gen

// ScaleCapacity_ARMGenerator returns a generator of ScaleCapacity_ARM instances for property testing.
func ScaleCapacity_ARMGenerator() gopter.Gen {
	if scaleCapacity_ARMGenerator != nil {
		return scaleCapacity_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScaleCapacity_ARM(generators)
	scaleCapacity_ARMGenerator = gen.Struct(reflect.TypeOf(ScaleCapacity_ARM{}), generators)

	return scaleCapacity_ARMGenerator
}

// AddIndependentPropertyGeneratorsForScaleCapacity_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScaleCapacity_ARM(gens map[string]gopter.Gen) {
	gens["Default"] = gen.PtrOf(gen.AlphaString())
	gens["Maximum"] = gen.PtrOf(gen.AlphaString())
	gens["Minimum"] = gen.PtrOf(gen.AlphaString())
}

func Test_ScaleRuleMetricDimension_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScaleRuleMetricDimension_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScaleRuleMetricDimension_ARM, ScaleRuleMetricDimension_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScaleRuleMetricDimension_ARM runs a test to see if a specific instance of ScaleRuleMetricDimension_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForScaleRuleMetricDimension_ARM(subject ScaleRuleMetricDimension_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScaleRuleMetricDimension_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScaleRuleMetricDimension_ARM instances for property testing - lazily instantiated by
// ScaleRuleMetricDimension_ARMGenerator()
var scaleRuleMetricDimension_ARMGenerator gopter.Gen

// ScaleRuleMetricDimension_ARMGenerator returns a generator of ScaleRuleMetricDimension_ARM instances for property testing.
func ScaleRuleMetricDimension_ARMGenerator() gopter.Gen {
	if scaleRuleMetricDimension_ARMGenerator != nil {
		return scaleRuleMetricDimension_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScaleRuleMetricDimension_ARM(generators)
	scaleRuleMetricDimension_ARMGenerator = gen.Struct(reflect.TypeOf(ScaleRuleMetricDimension_ARM{}), generators)

	return scaleRuleMetricDimension_ARMGenerator
}

// AddIndependentPropertyGeneratorsForScaleRuleMetricDimension_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScaleRuleMetricDimension_ARM(gens map[string]gopter.Gen) {
	gens["DimensionName"] = gen.PtrOf(gen.AlphaString())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(ScaleRuleMetricDimension_Operator_ARM_Equals, ScaleRuleMetricDimension_Operator_ARM_NotEquals))
	gens["Values"] = gen.SliceOf(gen.AlphaString())
}

func Test_ScaleRule_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScaleRule_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScaleRule_ARM, ScaleRule_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScaleRule_ARM runs a test to see if a specific instance of ScaleRule_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForScaleRule_ARM(subject ScaleRule_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScaleRule_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScaleRule_ARM instances for property testing - lazily instantiated by ScaleRule_ARMGenerator()
var scaleRule_ARMGenerator gopter.Gen

// ScaleRule_ARMGenerator returns a generator of ScaleRule_ARM instances for property testing.
func ScaleRule_ARMGenerator() gopter.Gen {
	if scaleRule_ARMGenerator != nil {
		return scaleRule_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForScaleRule_ARM(generators)
	scaleRule_ARMGenerator = gen.Struct(reflect.TypeOf(ScaleRule_ARM{}), generators)

	return scaleRule_ARMGenerator
}

// AddRelatedPropertyGeneratorsForScaleRule_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForScaleRule_ARM(gens map[string]gopter.Gen) {
	gens["MetricTrigger"] = gen.PtrOf(MetricTrigger_ARMGenerator())
	gens["ScaleAction"] = gen.PtrOf(ScaleAction_ARMGenerator())
}

func Test_TimeWindow_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TimeWindow_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTimeWindow_ARM, TimeWindow_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTimeWindow_ARM runs a test to see if a specific instance of TimeWindow_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForTimeWindow_ARM(subject TimeWindow_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TimeWindow_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TimeWindow_ARM instances for property testing - lazily instantiated by TimeWindow_ARMGenerator()
var timeWindow_ARMGenerator gopter.Gen

// TimeWindow_ARMGenerator returns a generator of TimeWindow_ARM instances for property testing.
func TimeWindow_ARMGenerator() gopter.Gen {
	if timeWindow_ARMGenerator != nil {
		return timeWindow_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTimeWindow_ARM(generators)
	timeWindow_ARMGenerator = gen.Struct(reflect.TypeOf(TimeWindow_ARM{}), generators)

	return timeWindow_ARMGenerator
}

// AddIndependentPropertyGeneratorsForTimeWindow_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTimeWindow_ARM(gens map[string]gopter.Gen) {
	gens["End"] = gen.PtrOf(gen.AlphaString())
	gens["Start"] = gen.PtrOf(gen.AlphaString())
	gens["TimeZone"] = gen.PtrOf(gen.AlphaString())
}

func Test_WebhookNotification_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebhookNotification_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebhookNotification_ARM, WebhookNotification_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebhookNotification_ARM runs a test to see if a specific instance of WebhookNotification_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWebhookNotification_ARM(subject WebhookNotification_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebhookNotification_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebhookNotification_ARM instances for property testing - lazily instantiated by
// WebhookNotification_ARMGenerator()
var webhookNotification_ARMGenerator gopter.Gen

// WebhookNotification_ARMGenerator returns a generator of WebhookNotification_ARM instances for property testing.
func WebhookNotification_ARMGenerator() gopter.Gen {
	if webhookNotification_ARMGenerator != nil {
		return webhookNotification_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebhookNotification_ARM(generators)
	webhookNotification_ARMGenerator = gen.Struct(reflect.TypeOf(WebhookNotification_ARM{}), generators)

	return webhookNotification_ARMGenerator
}

// AddIndependentPropertyGeneratorsForWebhookNotification_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebhookNotification_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["ServiceUri"] = gen.PtrOf(gen.AlphaString())
}
