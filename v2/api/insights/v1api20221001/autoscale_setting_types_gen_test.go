// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20221001

import (
	"encoding/json"
	storage "github.com/Azure/azure-service-operator/v2/api/insights/v1api20221001/storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_AutoscaleNotification_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AutoscaleNotification to AutoscaleNotification via AssignProperties_To_AutoscaleNotification & AssignProperties_From_AutoscaleNotification returns original",
		prop.ForAll(RunPropertyAssignmentTestForAutoscaleNotification, AutoscaleNotificationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAutoscaleNotification tests if a specific instance of AutoscaleNotification can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAutoscaleNotification(subject AutoscaleNotification) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AutoscaleNotification
	err := copied.AssignProperties_To_AutoscaleNotification(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AutoscaleNotification
	err = actual.AssignProperties_From_AutoscaleNotification(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AutoscaleNotification_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoscaleNotification via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoscaleNotification, AutoscaleNotificationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoscaleNotification runs a test to see if a specific instance of AutoscaleNotification round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoscaleNotification(subject AutoscaleNotification) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoscaleNotification
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoscaleNotification instances for property testing - lazily instantiated by
// AutoscaleNotificationGenerator()
var autoscaleNotificationGenerator gopter.Gen

// AutoscaleNotificationGenerator returns a generator of AutoscaleNotification instances for property testing.
// We first initialize autoscaleNotificationGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AutoscaleNotificationGenerator() gopter.Gen {
	if autoscaleNotificationGenerator != nil {
		return autoscaleNotificationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscaleNotification(generators)
	autoscaleNotificationGenerator = gen.Struct(reflect.TypeOf(AutoscaleNotification{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscaleNotification(generators)
	AddRelatedPropertyGeneratorsForAutoscaleNotification(generators)
	autoscaleNotificationGenerator = gen.Struct(reflect.TypeOf(AutoscaleNotification{}), generators)

	return autoscaleNotificationGenerator
}

// AddIndependentPropertyGeneratorsForAutoscaleNotification is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoscaleNotification(gens map[string]gopter.Gen) {
	gens["Operation"] = gen.PtrOf(gen.OneConstOf(AutoscaleNotification_Operation_Scale))
}

// AddRelatedPropertyGeneratorsForAutoscaleNotification is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoscaleNotification(gens map[string]gopter.Gen) {
	gens["Email"] = gen.PtrOf(EmailNotificationGenerator())
	gens["Webhooks"] = gen.SliceOf(WebhookNotificationGenerator())
}

func Test_AutoscaleNotification_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AutoscaleNotification_STATUS to AutoscaleNotification_STATUS via AssignProperties_To_AutoscaleNotification_STATUS & AssignProperties_From_AutoscaleNotification_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAutoscaleNotification_STATUS, AutoscaleNotification_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAutoscaleNotification_STATUS tests if a specific instance of AutoscaleNotification_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAutoscaleNotification_STATUS(subject AutoscaleNotification_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AutoscaleNotification_STATUS
	err := copied.AssignProperties_To_AutoscaleNotification_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AutoscaleNotification_STATUS
	err = actual.AssignProperties_From_AutoscaleNotification_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AutoscaleNotification_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoscaleNotification_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoscaleNotification_STATUS, AutoscaleNotification_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoscaleNotification_STATUS runs a test to see if a specific instance of AutoscaleNotification_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoscaleNotification_STATUS(subject AutoscaleNotification_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoscaleNotification_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoscaleNotification_STATUS instances for property testing - lazily instantiated by
// AutoscaleNotification_STATUSGenerator()
var autoscaleNotification_STATUSGenerator gopter.Gen

// AutoscaleNotification_STATUSGenerator returns a generator of AutoscaleNotification_STATUS instances for property testing.
// We first initialize autoscaleNotification_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AutoscaleNotification_STATUSGenerator() gopter.Gen {
	if autoscaleNotification_STATUSGenerator != nil {
		return autoscaleNotification_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscaleNotification_STATUS(generators)
	autoscaleNotification_STATUSGenerator = gen.Struct(reflect.TypeOf(AutoscaleNotification_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscaleNotification_STATUS(generators)
	AddRelatedPropertyGeneratorsForAutoscaleNotification_STATUS(generators)
	autoscaleNotification_STATUSGenerator = gen.Struct(reflect.TypeOf(AutoscaleNotification_STATUS{}), generators)

	return autoscaleNotification_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAutoscaleNotification_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoscaleNotification_STATUS(gens map[string]gopter.Gen) {
	gens["Operation"] = gen.PtrOf(gen.OneConstOf(AutoscaleNotification_Operation_STATUS_Scale))
}

// AddRelatedPropertyGeneratorsForAutoscaleNotification_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoscaleNotification_STATUS(gens map[string]gopter.Gen) {
	gens["Email"] = gen.PtrOf(EmailNotification_STATUSGenerator())
	gens["Webhooks"] = gen.SliceOf(WebhookNotification_STATUSGenerator())
}

func Test_AutoscaleProfile_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AutoscaleProfile to AutoscaleProfile via AssignProperties_To_AutoscaleProfile & AssignProperties_From_AutoscaleProfile returns original",
		prop.ForAll(RunPropertyAssignmentTestForAutoscaleProfile, AutoscaleProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAutoscaleProfile tests if a specific instance of AutoscaleProfile can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAutoscaleProfile(subject AutoscaleProfile) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AutoscaleProfile
	err := copied.AssignProperties_To_AutoscaleProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AutoscaleProfile
	err = actual.AssignProperties_From_AutoscaleProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AutoscaleProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoscaleProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoscaleProfile, AutoscaleProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoscaleProfile runs a test to see if a specific instance of AutoscaleProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoscaleProfile(subject AutoscaleProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoscaleProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoscaleProfile instances for property testing - lazily instantiated by AutoscaleProfileGenerator()
var autoscaleProfileGenerator gopter.Gen

// AutoscaleProfileGenerator returns a generator of AutoscaleProfile instances for property testing.
// We first initialize autoscaleProfileGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AutoscaleProfileGenerator() gopter.Gen {
	if autoscaleProfileGenerator != nil {
		return autoscaleProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscaleProfile(generators)
	autoscaleProfileGenerator = gen.Struct(reflect.TypeOf(AutoscaleProfile{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscaleProfile(generators)
	AddRelatedPropertyGeneratorsForAutoscaleProfile(generators)
	autoscaleProfileGenerator = gen.Struct(reflect.TypeOf(AutoscaleProfile{}), generators)

	return autoscaleProfileGenerator
}

// AddIndependentPropertyGeneratorsForAutoscaleProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoscaleProfile(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAutoscaleProfile is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoscaleProfile(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(ScaleCapacityGenerator())
	gens["FixedDate"] = gen.PtrOf(TimeWindowGenerator())
	gens["Recurrence"] = gen.PtrOf(RecurrenceGenerator())
	gens["Rules"] = gen.SliceOf(ScaleRuleGenerator())
}

func Test_AutoscaleProfile_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AutoscaleProfile_STATUS to AutoscaleProfile_STATUS via AssignProperties_To_AutoscaleProfile_STATUS & AssignProperties_From_AutoscaleProfile_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAutoscaleProfile_STATUS, AutoscaleProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAutoscaleProfile_STATUS tests if a specific instance of AutoscaleProfile_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAutoscaleProfile_STATUS(subject AutoscaleProfile_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AutoscaleProfile_STATUS
	err := copied.AssignProperties_To_AutoscaleProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AutoscaleProfile_STATUS
	err = actual.AssignProperties_From_AutoscaleProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AutoscaleProfile_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoscaleProfile_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoscaleProfile_STATUS, AutoscaleProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoscaleProfile_STATUS runs a test to see if a specific instance of AutoscaleProfile_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoscaleProfile_STATUS(subject AutoscaleProfile_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoscaleProfile_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoscaleProfile_STATUS instances for property testing - lazily instantiated by
// AutoscaleProfile_STATUSGenerator()
var autoscaleProfile_STATUSGenerator gopter.Gen

// AutoscaleProfile_STATUSGenerator returns a generator of AutoscaleProfile_STATUS instances for property testing.
// We first initialize autoscaleProfile_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AutoscaleProfile_STATUSGenerator() gopter.Gen {
	if autoscaleProfile_STATUSGenerator != nil {
		return autoscaleProfile_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscaleProfile_STATUS(generators)
	autoscaleProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(AutoscaleProfile_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscaleProfile_STATUS(generators)
	AddRelatedPropertyGeneratorsForAutoscaleProfile_STATUS(generators)
	autoscaleProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(AutoscaleProfile_STATUS{}), generators)

	return autoscaleProfile_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAutoscaleProfile_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoscaleProfile_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAutoscaleProfile_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoscaleProfile_STATUS(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(ScaleCapacity_STATUSGenerator())
	gens["FixedDate"] = gen.PtrOf(TimeWindow_STATUSGenerator())
	gens["Recurrence"] = gen.PtrOf(Recurrence_STATUSGenerator())
	gens["Rules"] = gen.SliceOf(ScaleRule_STATUSGenerator())
}

func Test_AutoscaleSetting_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	parameters.MinSuccessfulTests = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AutoscaleSetting to hub returns original",
		prop.ForAll(RunResourceConversionTestForAutoscaleSetting, AutoscaleSettingGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForAutoscaleSetting tests if a specific instance of AutoscaleSetting round trips to the hub storage version and back losslessly
func RunResourceConversionTestForAutoscaleSetting(subject AutoscaleSetting) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub storage.AutoscaleSetting
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual AutoscaleSetting
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AutoscaleSetting_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AutoscaleSetting to AutoscaleSetting via AssignProperties_To_AutoscaleSetting & AssignProperties_From_AutoscaleSetting returns original",
		prop.ForAll(RunPropertyAssignmentTestForAutoscaleSetting, AutoscaleSettingGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAutoscaleSetting tests if a specific instance of AutoscaleSetting can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAutoscaleSetting(subject AutoscaleSetting) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AutoscaleSetting
	err := copied.AssignProperties_To_AutoscaleSetting(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AutoscaleSetting
	err = actual.AssignProperties_From_AutoscaleSetting(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AutoscaleSetting_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoscaleSetting via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoscaleSetting, AutoscaleSettingGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoscaleSetting runs a test to see if a specific instance of AutoscaleSetting round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoscaleSetting(subject AutoscaleSetting) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoscaleSetting
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoscaleSetting instances for property testing - lazily instantiated by AutoscaleSettingGenerator()
var autoscaleSettingGenerator gopter.Gen

// AutoscaleSettingGenerator returns a generator of AutoscaleSetting instances for property testing.
func AutoscaleSettingGenerator() gopter.Gen {
	if autoscaleSettingGenerator != nil {
		return autoscaleSettingGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForAutoscaleSetting(generators)
	autoscaleSettingGenerator = gen.Struct(reflect.TypeOf(AutoscaleSetting{}), generators)

	return autoscaleSettingGenerator
}

// AddRelatedPropertyGeneratorsForAutoscaleSetting is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoscaleSetting(gens map[string]gopter.Gen) {
	gens["Spec"] = AutoscaleSetting_SpecGenerator()
	gens["Status"] = Autoscalesetting_STATUSGenerator()
}

func Test_AutoscaleSettingOperatorSpec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AutoscaleSettingOperatorSpec to AutoscaleSettingOperatorSpec via AssignProperties_To_AutoscaleSettingOperatorSpec & AssignProperties_From_AutoscaleSettingOperatorSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForAutoscaleSettingOperatorSpec, AutoscaleSettingOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAutoscaleSettingOperatorSpec tests if a specific instance of AutoscaleSettingOperatorSpec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAutoscaleSettingOperatorSpec(subject AutoscaleSettingOperatorSpec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AutoscaleSettingOperatorSpec
	err := copied.AssignProperties_To_AutoscaleSettingOperatorSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AutoscaleSettingOperatorSpec
	err = actual.AssignProperties_From_AutoscaleSettingOperatorSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AutoscaleSettingOperatorSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoscaleSettingOperatorSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoscaleSettingOperatorSpec, AutoscaleSettingOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoscaleSettingOperatorSpec runs a test to see if a specific instance of AutoscaleSettingOperatorSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoscaleSettingOperatorSpec(subject AutoscaleSettingOperatorSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoscaleSettingOperatorSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoscaleSettingOperatorSpec instances for property testing - lazily instantiated by
// AutoscaleSettingOperatorSpecGenerator()
var autoscaleSettingOperatorSpecGenerator gopter.Gen

// AutoscaleSettingOperatorSpecGenerator returns a generator of AutoscaleSettingOperatorSpec instances for property testing.
func AutoscaleSettingOperatorSpecGenerator() gopter.Gen {
	if autoscaleSettingOperatorSpecGenerator != nil {
		return autoscaleSettingOperatorSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	autoscaleSettingOperatorSpecGenerator = gen.Struct(reflect.TypeOf(AutoscaleSettingOperatorSpec{}), generators)

	return autoscaleSettingOperatorSpecGenerator
}

func Test_AutoscaleSetting_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AutoscaleSetting_Spec to AutoscaleSetting_Spec via AssignProperties_To_AutoscaleSetting_Spec & AssignProperties_From_AutoscaleSetting_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForAutoscaleSetting_Spec, AutoscaleSetting_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAutoscaleSetting_Spec tests if a specific instance of AutoscaleSetting_Spec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAutoscaleSetting_Spec(subject AutoscaleSetting_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AutoscaleSetting_Spec
	err := copied.AssignProperties_To_AutoscaleSetting_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AutoscaleSetting_Spec
	err = actual.AssignProperties_From_AutoscaleSetting_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AutoscaleSetting_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoscaleSetting_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoscaleSetting_Spec, AutoscaleSetting_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoscaleSetting_Spec runs a test to see if a specific instance of AutoscaleSetting_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoscaleSetting_Spec(subject AutoscaleSetting_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoscaleSetting_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoscaleSetting_Spec instances for property testing - lazily instantiated by
// AutoscaleSetting_SpecGenerator()
var autoscaleSetting_SpecGenerator gopter.Gen

// AutoscaleSetting_SpecGenerator returns a generator of AutoscaleSetting_Spec instances for property testing.
// We first initialize autoscaleSetting_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AutoscaleSetting_SpecGenerator() gopter.Gen {
	if autoscaleSetting_SpecGenerator != nil {
		return autoscaleSetting_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscaleSetting_Spec(generators)
	autoscaleSetting_SpecGenerator = gen.Struct(reflect.TypeOf(AutoscaleSetting_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscaleSetting_Spec(generators)
	AddRelatedPropertyGeneratorsForAutoscaleSetting_Spec(generators)
	autoscaleSetting_SpecGenerator = gen.Struct(reflect.TypeOf(AutoscaleSetting_Spec{}), generators)

	return autoscaleSetting_SpecGenerator
}

// AddIndependentPropertyGeneratorsForAutoscaleSetting_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoscaleSetting_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["TargetResourceLocation"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAutoscaleSetting_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoscaleSetting_Spec(gens map[string]gopter.Gen) {
	gens["Notifications"] = gen.SliceOf(AutoscaleNotificationGenerator())
	gens["OperatorSpec"] = gen.PtrOf(AutoscaleSettingOperatorSpecGenerator())
	gens["PredictiveAutoscalePolicy"] = gen.PtrOf(PredictiveAutoscalePolicyGenerator())
	gens["Profiles"] = gen.SliceOf(AutoscaleProfileGenerator())
}

func Test_Autoscalesetting_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Autoscalesetting_STATUS to Autoscalesetting_STATUS via AssignProperties_To_Autoscalesetting_STATUS & AssignProperties_From_Autoscalesetting_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAutoscalesetting_STATUS, Autoscalesetting_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAutoscalesetting_STATUS tests if a specific instance of Autoscalesetting_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAutoscalesetting_STATUS(subject Autoscalesetting_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.Autoscalesetting_STATUS
	err := copied.AssignProperties_To_Autoscalesetting_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Autoscalesetting_STATUS
	err = actual.AssignProperties_From_Autoscalesetting_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Autoscalesetting_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Autoscalesetting_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoscalesetting_STATUS, Autoscalesetting_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoscalesetting_STATUS runs a test to see if a specific instance of Autoscalesetting_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoscalesetting_STATUS(subject Autoscalesetting_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Autoscalesetting_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Autoscalesetting_STATUS instances for property testing - lazily instantiated by
// Autoscalesetting_STATUSGenerator()
var autoscalesetting_STATUSGenerator gopter.Gen

// Autoscalesetting_STATUSGenerator returns a generator of Autoscalesetting_STATUS instances for property testing.
// We first initialize autoscalesetting_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Autoscalesetting_STATUSGenerator() gopter.Gen {
	if autoscalesetting_STATUSGenerator != nil {
		return autoscalesetting_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscalesetting_STATUS(generators)
	autoscalesetting_STATUSGenerator = gen.Struct(reflect.TypeOf(Autoscalesetting_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscalesetting_STATUS(generators)
	AddRelatedPropertyGeneratorsForAutoscalesetting_STATUS(generators)
	autoscalesetting_STATUSGenerator = gen.Struct(reflect.TypeOf(Autoscalesetting_STATUS{}), generators)

	return autoscalesetting_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAutoscalesetting_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoscalesetting_STATUS(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PropertiesName"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["TargetResourceLocation"] = gen.PtrOf(gen.AlphaString())
	gens["TargetResourceUri"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAutoscalesetting_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoscalesetting_STATUS(gens map[string]gopter.Gen) {
	gens["Notifications"] = gen.SliceOf(AutoscaleNotification_STATUSGenerator())
	gens["PredictiveAutoscalePolicy"] = gen.PtrOf(PredictiveAutoscalePolicy_STATUSGenerator())
	gens["Profiles"] = gen.SliceOf(AutoscaleProfile_STATUSGenerator())
	gens["SystemData"] = gen.PtrOf(SystemData_STATUSGenerator())
}

func Test_EmailNotification_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EmailNotification to EmailNotification via AssignProperties_To_EmailNotification & AssignProperties_From_EmailNotification returns original",
		prop.ForAll(RunPropertyAssignmentTestForEmailNotification, EmailNotificationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEmailNotification tests if a specific instance of EmailNotification can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForEmailNotification(subject EmailNotification) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.EmailNotification
	err := copied.AssignProperties_To_EmailNotification(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EmailNotification
	err = actual.AssignProperties_From_EmailNotification(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EmailNotification_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EmailNotification via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEmailNotification, EmailNotificationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEmailNotification runs a test to see if a specific instance of EmailNotification round trips to JSON and back losslessly
func RunJSONSerializationTestForEmailNotification(subject EmailNotification) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EmailNotification
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EmailNotification instances for property testing - lazily instantiated by EmailNotificationGenerator()
var emailNotificationGenerator gopter.Gen

// EmailNotificationGenerator returns a generator of EmailNotification instances for property testing.
func EmailNotificationGenerator() gopter.Gen {
	if emailNotificationGenerator != nil {
		return emailNotificationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEmailNotification(generators)
	emailNotificationGenerator = gen.Struct(reflect.TypeOf(EmailNotification{}), generators)

	return emailNotificationGenerator
}

// AddIndependentPropertyGeneratorsForEmailNotification is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEmailNotification(gens map[string]gopter.Gen) {
	gens["CustomEmails"] = gen.SliceOf(gen.AlphaString())
	gens["SendToSubscriptionAdministrator"] = gen.PtrOf(gen.Bool())
	gens["SendToSubscriptionCoAdministrators"] = gen.PtrOf(gen.Bool())
}

func Test_EmailNotification_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EmailNotification_STATUS to EmailNotification_STATUS via AssignProperties_To_EmailNotification_STATUS & AssignProperties_From_EmailNotification_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForEmailNotification_STATUS, EmailNotification_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEmailNotification_STATUS tests if a specific instance of EmailNotification_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForEmailNotification_STATUS(subject EmailNotification_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.EmailNotification_STATUS
	err := copied.AssignProperties_To_EmailNotification_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EmailNotification_STATUS
	err = actual.AssignProperties_From_EmailNotification_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EmailNotification_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EmailNotification_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEmailNotification_STATUS, EmailNotification_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEmailNotification_STATUS runs a test to see if a specific instance of EmailNotification_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEmailNotification_STATUS(subject EmailNotification_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EmailNotification_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EmailNotification_STATUS instances for property testing - lazily instantiated by
// EmailNotification_STATUSGenerator()
var emailNotification_STATUSGenerator gopter.Gen

// EmailNotification_STATUSGenerator returns a generator of EmailNotification_STATUS instances for property testing.
func EmailNotification_STATUSGenerator() gopter.Gen {
	if emailNotification_STATUSGenerator != nil {
		return emailNotification_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEmailNotification_STATUS(generators)
	emailNotification_STATUSGenerator = gen.Struct(reflect.TypeOf(EmailNotification_STATUS{}), generators)

	return emailNotification_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForEmailNotification_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEmailNotification_STATUS(gens map[string]gopter.Gen) {
	gens["CustomEmails"] = gen.SliceOf(gen.AlphaString())
	gens["SendToSubscriptionAdministrator"] = gen.PtrOf(gen.Bool())
	gens["SendToSubscriptionCoAdministrators"] = gen.PtrOf(gen.Bool())
}

func Test_MetricTrigger_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MetricTrigger to MetricTrigger via AssignProperties_To_MetricTrigger & AssignProperties_From_MetricTrigger returns original",
		prop.ForAll(RunPropertyAssignmentTestForMetricTrigger, MetricTriggerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMetricTrigger tests if a specific instance of MetricTrigger can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForMetricTrigger(subject MetricTrigger) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.MetricTrigger
	err := copied.AssignProperties_To_MetricTrigger(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual MetricTrigger
	err = actual.AssignProperties_From_MetricTrigger(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MetricTrigger_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MetricTrigger via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMetricTrigger, MetricTriggerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMetricTrigger runs a test to see if a specific instance of MetricTrigger round trips to JSON and back losslessly
func RunJSONSerializationTestForMetricTrigger(subject MetricTrigger) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MetricTrigger
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MetricTrigger instances for property testing - lazily instantiated by MetricTriggerGenerator()
var metricTriggerGenerator gopter.Gen

// MetricTriggerGenerator returns a generator of MetricTrigger instances for property testing.
// We first initialize metricTriggerGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func MetricTriggerGenerator() gopter.Gen {
	if metricTriggerGenerator != nil {
		return metricTriggerGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricTrigger(generators)
	metricTriggerGenerator = gen.Struct(reflect.TypeOf(MetricTrigger{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricTrigger(generators)
	AddRelatedPropertyGeneratorsForMetricTrigger(generators)
	metricTriggerGenerator = gen.Struct(reflect.TypeOf(MetricTrigger{}), generators)

	return metricTriggerGenerator
}

// AddIndependentPropertyGeneratorsForMetricTrigger is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMetricTrigger(gens map[string]gopter.Gen) {
	gens["DividePerInstance"] = gen.PtrOf(gen.Bool())
	gens["MetricName"] = gen.PtrOf(gen.AlphaString())
	gens["MetricNamespace"] = gen.PtrOf(gen.AlphaString())
	gens["MetricResourceLocation"] = gen.PtrOf(gen.AlphaString())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		MetricTrigger_Operator_Equals,
		MetricTrigger_Operator_GreaterThan,
		MetricTrigger_Operator_GreaterThanOrEqual,
		MetricTrigger_Operator_LessThan,
		MetricTrigger_Operator_LessThanOrEqual,
		MetricTrigger_Operator_NotEquals))
	gens["Statistic"] = gen.PtrOf(gen.OneConstOf(
		MetricTrigger_Statistic_Average,
		MetricTrigger_Statistic_Count,
		MetricTrigger_Statistic_Max,
		MetricTrigger_Statistic_Min,
		MetricTrigger_Statistic_Sum))
	gens["Threshold"] = gen.PtrOf(gen.Float64())
	gens["TimeAggregation"] = gen.PtrOf(gen.OneConstOf(
		MetricTrigger_TimeAggregation_Average,
		MetricTrigger_TimeAggregation_Count,
		MetricTrigger_TimeAggregation_Last,
		MetricTrigger_TimeAggregation_Maximum,
		MetricTrigger_TimeAggregation_Minimum,
		MetricTrigger_TimeAggregation_Total))
	gens["TimeGrain"] = gen.PtrOf(gen.AlphaString())
	gens["TimeWindow"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForMetricTrigger is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMetricTrigger(gens map[string]gopter.Gen) {
	gens["Dimensions"] = gen.SliceOf(ScaleRuleMetricDimensionGenerator())
}

func Test_MetricTrigger_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MetricTrigger_STATUS to MetricTrigger_STATUS via AssignProperties_To_MetricTrigger_STATUS & AssignProperties_From_MetricTrigger_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForMetricTrigger_STATUS, MetricTrigger_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMetricTrigger_STATUS tests if a specific instance of MetricTrigger_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForMetricTrigger_STATUS(subject MetricTrigger_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.MetricTrigger_STATUS
	err := copied.AssignProperties_To_MetricTrigger_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual MetricTrigger_STATUS
	err = actual.AssignProperties_From_MetricTrigger_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MetricTrigger_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MetricTrigger_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMetricTrigger_STATUS, MetricTrigger_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMetricTrigger_STATUS runs a test to see if a specific instance of MetricTrigger_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForMetricTrigger_STATUS(subject MetricTrigger_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MetricTrigger_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MetricTrigger_STATUS instances for property testing - lazily instantiated by
// MetricTrigger_STATUSGenerator()
var metricTrigger_STATUSGenerator gopter.Gen

// MetricTrigger_STATUSGenerator returns a generator of MetricTrigger_STATUS instances for property testing.
// We first initialize metricTrigger_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func MetricTrigger_STATUSGenerator() gopter.Gen {
	if metricTrigger_STATUSGenerator != nil {
		return metricTrigger_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricTrigger_STATUS(generators)
	metricTrigger_STATUSGenerator = gen.Struct(reflect.TypeOf(MetricTrigger_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricTrigger_STATUS(generators)
	AddRelatedPropertyGeneratorsForMetricTrigger_STATUS(generators)
	metricTrigger_STATUSGenerator = gen.Struct(reflect.TypeOf(MetricTrigger_STATUS{}), generators)

	return metricTrigger_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForMetricTrigger_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMetricTrigger_STATUS(gens map[string]gopter.Gen) {
	gens["DividePerInstance"] = gen.PtrOf(gen.Bool())
	gens["MetricName"] = gen.PtrOf(gen.AlphaString())
	gens["MetricNamespace"] = gen.PtrOf(gen.AlphaString())
	gens["MetricResourceLocation"] = gen.PtrOf(gen.AlphaString())
	gens["MetricResourceUri"] = gen.PtrOf(gen.AlphaString())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		MetricTrigger_Operator_STATUS_Equals,
		MetricTrigger_Operator_STATUS_GreaterThan,
		MetricTrigger_Operator_STATUS_GreaterThanOrEqual,
		MetricTrigger_Operator_STATUS_LessThan,
		MetricTrigger_Operator_STATUS_LessThanOrEqual,
		MetricTrigger_Operator_STATUS_NotEquals))
	gens["Statistic"] = gen.PtrOf(gen.OneConstOf(
		MetricTrigger_Statistic_STATUS_Average,
		MetricTrigger_Statistic_STATUS_Count,
		MetricTrigger_Statistic_STATUS_Max,
		MetricTrigger_Statistic_STATUS_Min,
		MetricTrigger_Statistic_STATUS_Sum))
	gens["Threshold"] = gen.PtrOf(gen.Float64())
	gens["TimeAggregation"] = gen.PtrOf(gen.OneConstOf(
		MetricTrigger_TimeAggregation_STATUS_Average,
		MetricTrigger_TimeAggregation_STATUS_Count,
		MetricTrigger_TimeAggregation_STATUS_Last,
		MetricTrigger_TimeAggregation_STATUS_Maximum,
		MetricTrigger_TimeAggregation_STATUS_Minimum,
		MetricTrigger_TimeAggregation_STATUS_Total))
	gens["TimeGrain"] = gen.PtrOf(gen.AlphaString())
	gens["TimeWindow"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForMetricTrigger_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMetricTrigger_STATUS(gens map[string]gopter.Gen) {
	gens["Dimensions"] = gen.SliceOf(ScaleRuleMetricDimension_STATUSGenerator())
}

func Test_PredictiveAutoscalePolicy_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PredictiveAutoscalePolicy to PredictiveAutoscalePolicy via AssignProperties_To_PredictiveAutoscalePolicy & AssignProperties_From_PredictiveAutoscalePolicy returns original",
		prop.ForAll(RunPropertyAssignmentTestForPredictiveAutoscalePolicy, PredictiveAutoscalePolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPredictiveAutoscalePolicy tests if a specific instance of PredictiveAutoscalePolicy can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForPredictiveAutoscalePolicy(subject PredictiveAutoscalePolicy) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.PredictiveAutoscalePolicy
	err := copied.AssignProperties_To_PredictiveAutoscalePolicy(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PredictiveAutoscalePolicy
	err = actual.AssignProperties_From_PredictiveAutoscalePolicy(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PredictiveAutoscalePolicy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PredictiveAutoscalePolicy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPredictiveAutoscalePolicy, PredictiveAutoscalePolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPredictiveAutoscalePolicy runs a test to see if a specific instance of PredictiveAutoscalePolicy round trips to JSON and back losslessly
func RunJSONSerializationTestForPredictiveAutoscalePolicy(subject PredictiveAutoscalePolicy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PredictiveAutoscalePolicy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PredictiveAutoscalePolicy instances for property testing - lazily instantiated by
// PredictiveAutoscalePolicyGenerator()
var predictiveAutoscalePolicyGenerator gopter.Gen

// PredictiveAutoscalePolicyGenerator returns a generator of PredictiveAutoscalePolicy instances for property testing.
func PredictiveAutoscalePolicyGenerator() gopter.Gen {
	if predictiveAutoscalePolicyGenerator != nil {
		return predictiveAutoscalePolicyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPredictiveAutoscalePolicy(generators)
	predictiveAutoscalePolicyGenerator = gen.Struct(reflect.TypeOf(PredictiveAutoscalePolicy{}), generators)

	return predictiveAutoscalePolicyGenerator
}

// AddIndependentPropertyGeneratorsForPredictiveAutoscalePolicy is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPredictiveAutoscalePolicy(gens map[string]gopter.Gen) {
	gens["ScaleLookAheadTime"] = gen.PtrOf(gen.AlphaString())
	gens["ScaleMode"] = gen.PtrOf(gen.OneConstOf(PredictiveAutoscalePolicy_ScaleMode_Disabled, PredictiveAutoscalePolicy_ScaleMode_Enabled, PredictiveAutoscalePolicy_ScaleMode_ForecastOnly))
}

func Test_PredictiveAutoscalePolicy_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PredictiveAutoscalePolicy_STATUS to PredictiveAutoscalePolicy_STATUS via AssignProperties_To_PredictiveAutoscalePolicy_STATUS & AssignProperties_From_PredictiveAutoscalePolicy_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForPredictiveAutoscalePolicy_STATUS, PredictiveAutoscalePolicy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPredictiveAutoscalePolicy_STATUS tests if a specific instance of PredictiveAutoscalePolicy_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForPredictiveAutoscalePolicy_STATUS(subject PredictiveAutoscalePolicy_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.PredictiveAutoscalePolicy_STATUS
	err := copied.AssignProperties_To_PredictiveAutoscalePolicy_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PredictiveAutoscalePolicy_STATUS
	err = actual.AssignProperties_From_PredictiveAutoscalePolicy_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PredictiveAutoscalePolicy_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PredictiveAutoscalePolicy_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPredictiveAutoscalePolicy_STATUS, PredictiveAutoscalePolicy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPredictiveAutoscalePolicy_STATUS runs a test to see if a specific instance of PredictiveAutoscalePolicy_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPredictiveAutoscalePolicy_STATUS(subject PredictiveAutoscalePolicy_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PredictiveAutoscalePolicy_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PredictiveAutoscalePolicy_STATUS instances for property testing - lazily instantiated by
// PredictiveAutoscalePolicy_STATUSGenerator()
var predictiveAutoscalePolicy_STATUSGenerator gopter.Gen

// PredictiveAutoscalePolicy_STATUSGenerator returns a generator of PredictiveAutoscalePolicy_STATUS instances for property testing.
func PredictiveAutoscalePolicy_STATUSGenerator() gopter.Gen {
	if predictiveAutoscalePolicy_STATUSGenerator != nil {
		return predictiveAutoscalePolicy_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPredictiveAutoscalePolicy_STATUS(generators)
	predictiveAutoscalePolicy_STATUSGenerator = gen.Struct(reflect.TypeOf(PredictiveAutoscalePolicy_STATUS{}), generators)

	return predictiveAutoscalePolicy_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForPredictiveAutoscalePolicy_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPredictiveAutoscalePolicy_STATUS(gens map[string]gopter.Gen) {
	gens["ScaleLookAheadTime"] = gen.PtrOf(gen.AlphaString())
	gens["ScaleMode"] = gen.PtrOf(gen.OneConstOf(PredictiveAutoscalePolicy_ScaleMode_STATUS_Disabled, PredictiveAutoscalePolicy_ScaleMode_STATUS_Enabled, PredictiveAutoscalePolicy_ScaleMode_STATUS_ForecastOnly))
}

func Test_Recurrence_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Recurrence to Recurrence via AssignProperties_To_Recurrence & AssignProperties_From_Recurrence returns original",
		prop.ForAll(RunPropertyAssignmentTestForRecurrence, RecurrenceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRecurrence tests if a specific instance of Recurrence can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForRecurrence(subject Recurrence) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.Recurrence
	err := copied.AssignProperties_To_Recurrence(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Recurrence
	err = actual.AssignProperties_From_Recurrence(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Recurrence_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Recurrence via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRecurrence, RecurrenceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRecurrence runs a test to see if a specific instance of Recurrence round trips to JSON and back losslessly
func RunJSONSerializationTestForRecurrence(subject Recurrence) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Recurrence
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Recurrence instances for property testing - lazily instantiated by RecurrenceGenerator()
var recurrenceGenerator gopter.Gen

// RecurrenceGenerator returns a generator of Recurrence instances for property testing.
// We first initialize recurrenceGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RecurrenceGenerator() gopter.Gen {
	if recurrenceGenerator != nil {
		return recurrenceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRecurrence(generators)
	recurrenceGenerator = gen.Struct(reflect.TypeOf(Recurrence{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRecurrence(generators)
	AddRelatedPropertyGeneratorsForRecurrence(generators)
	recurrenceGenerator = gen.Struct(reflect.TypeOf(Recurrence{}), generators)

	return recurrenceGenerator
}

// AddIndependentPropertyGeneratorsForRecurrence is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRecurrence(gens map[string]gopter.Gen) {
	gens["Frequency"] = gen.PtrOf(gen.OneConstOf(
		Recurrence_Frequency_Day,
		Recurrence_Frequency_Hour,
		Recurrence_Frequency_Minute,
		Recurrence_Frequency_Month,
		Recurrence_Frequency_None,
		Recurrence_Frequency_Second,
		Recurrence_Frequency_Week,
		Recurrence_Frequency_Year))
}

// AddRelatedPropertyGeneratorsForRecurrence is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRecurrence(gens map[string]gopter.Gen) {
	gens["Schedule"] = gen.PtrOf(RecurrentScheduleGenerator())
}

func Test_Recurrence_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Recurrence_STATUS to Recurrence_STATUS via AssignProperties_To_Recurrence_STATUS & AssignProperties_From_Recurrence_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForRecurrence_STATUS, Recurrence_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRecurrence_STATUS tests if a specific instance of Recurrence_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForRecurrence_STATUS(subject Recurrence_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.Recurrence_STATUS
	err := copied.AssignProperties_To_Recurrence_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Recurrence_STATUS
	err = actual.AssignProperties_From_Recurrence_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Recurrence_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Recurrence_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRecurrence_STATUS, Recurrence_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRecurrence_STATUS runs a test to see if a specific instance of Recurrence_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRecurrence_STATUS(subject Recurrence_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Recurrence_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Recurrence_STATUS instances for property testing - lazily instantiated by Recurrence_STATUSGenerator()
var recurrence_STATUSGenerator gopter.Gen

// Recurrence_STATUSGenerator returns a generator of Recurrence_STATUS instances for property testing.
// We first initialize recurrence_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Recurrence_STATUSGenerator() gopter.Gen {
	if recurrence_STATUSGenerator != nil {
		return recurrence_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRecurrence_STATUS(generators)
	recurrence_STATUSGenerator = gen.Struct(reflect.TypeOf(Recurrence_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRecurrence_STATUS(generators)
	AddRelatedPropertyGeneratorsForRecurrence_STATUS(generators)
	recurrence_STATUSGenerator = gen.Struct(reflect.TypeOf(Recurrence_STATUS{}), generators)

	return recurrence_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForRecurrence_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRecurrence_STATUS(gens map[string]gopter.Gen) {
	gens["Frequency"] = gen.PtrOf(gen.OneConstOf(
		Recurrence_Frequency_STATUS_Day,
		Recurrence_Frequency_STATUS_Hour,
		Recurrence_Frequency_STATUS_Minute,
		Recurrence_Frequency_STATUS_Month,
		Recurrence_Frequency_STATUS_None,
		Recurrence_Frequency_STATUS_Second,
		Recurrence_Frequency_STATUS_Week,
		Recurrence_Frequency_STATUS_Year))
}

// AddRelatedPropertyGeneratorsForRecurrence_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRecurrence_STATUS(gens map[string]gopter.Gen) {
	gens["Schedule"] = gen.PtrOf(RecurrentSchedule_STATUSGenerator())
}

func Test_RecurrentSchedule_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RecurrentSchedule to RecurrentSchedule via AssignProperties_To_RecurrentSchedule & AssignProperties_From_RecurrentSchedule returns original",
		prop.ForAll(RunPropertyAssignmentTestForRecurrentSchedule, RecurrentScheduleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRecurrentSchedule tests if a specific instance of RecurrentSchedule can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForRecurrentSchedule(subject RecurrentSchedule) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.RecurrentSchedule
	err := copied.AssignProperties_To_RecurrentSchedule(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RecurrentSchedule
	err = actual.AssignProperties_From_RecurrentSchedule(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RecurrentSchedule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RecurrentSchedule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRecurrentSchedule, RecurrentScheduleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRecurrentSchedule runs a test to see if a specific instance of RecurrentSchedule round trips to JSON and back losslessly
func RunJSONSerializationTestForRecurrentSchedule(subject RecurrentSchedule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RecurrentSchedule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RecurrentSchedule instances for property testing - lazily instantiated by RecurrentScheduleGenerator()
var recurrentScheduleGenerator gopter.Gen

// RecurrentScheduleGenerator returns a generator of RecurrentSchedule instances for property testing.
func RecurrentScheduleGenerator() gopter.Gen {
	if recurrentScheduleGenerator != nil {
		return recurrentScheduleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRecurrentSchedule(generators)
	recurrentScheduleGenerator = gen.Struct(reflect.TypeOf(RecurrentSchedule{}), generators)

	return recurrentScheduleGenerator
}

// AddIndependentPropertyGeneratorsForRecurrentSchedule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRecurrentSchedule(gens map[string]gopter.Gen) {
	gens["Days"] = gen.SliceOf(gen.AlphaString())
	gens["Hours"] = gen.SliceOf(gen.Int())
	gens["Minutes"] = gen.SliceOf(gen.Int())
	gens["TimeZone"] = gen.PtrOf(gen.AlphaString())
}

func Test_RecurrentSchedule_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RecurrentSchedule_STATUS to RecurrentSchedule_STATUS via AssignProperties_To_RecurrentSchedule_STATUS & AssignProperties_From_RecurrentSchedule_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForRecurrentSchedule_STATUS, RecurrentSchedule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRecurrentSchedule_STATUS tests if a specific instance of RecurrentSchedule_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForRecurrentSchedule_STATUS(subject RecurrentSchedule_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.RecurrentSchedule_STATUS
	err := copied.AssignProperties_To_RecurrentSchedule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RecurrentSchedule_STATUS
	err = actual.AssignProperties_From_RecurrentSchedule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RecurrentSchedule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RecurrentSchedule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRecurrentSchedule_STATUS, RecurrentSchedule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRecurrentSchedule_STATUS runs a test to see if a specific instance of RecurrentSchedule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRecurrentSchedule_STATUS(subject RecurrentSchedule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RecurrentSchedule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RecurrentSchedule_STATUS instances for property testing - lazily instantiated by
// RecurrentSchedule_STATUSGenerator()
var recurrentSchedule_STATUSGenerator gopter.Gen

// RecurrentSchedule_STATUSGenerator returns a generator of RecurrentSchedule_STATUS instances for property testing.
func RecurrentSchedule_STATUSGenerator() gopter.Gen {
	if recurrentSchedule_STATUSGenerator != nil {
		return recurrentSchedule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRecurrentSchedule_STATUS(generators)
	recurrentSchedule_STATUSGenerator = gen.Struct(reflect.TypeOf(RecurrentSchedule_STATUS{}), generators)

	return recurrentSchedule_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForRecurrentSchedule_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRecurrentSchedule_STATUS(gens map[string]gopter.Gen) {
	gens["Days"] = gen.SliceOf(gen.AlphaString())
	gens["Hours"] = gen.SliceOf(gen.Int())
	gens["Minutes"] = gen.SliceOf(gen.Int())
	gens["TimeZone"] = gen.PtrOf(gen.AlphaString())
}

func Test_ScaleAction_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ScaleAction to ScaleAction via AssignProperties_To_ScaleAction & AssignProperties_From_ScaleAction returns original",
		prop.ForAll(RunPropertyAssignmentTestForScaleAction, ScaleActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForScaleAction tests if a specific instance of ScaleAction can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForScaleAction(subject ScaleAction) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ScaleAction
	err := copied.AssignProperties_To_ScaleAction(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ScaleAction
	err = actual.AssignProperties_From_ScaleAction(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ScaleAction_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScaleAction via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScaleAction, ScaleActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScaleAction runs a test to see if a specific instance of ScaleAction round trips to JSON and back losslessly
func RunJSONSerializationTestForScaleAction(subject ScaleAction) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScaleAction
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScaleAction instances for property testing - lazily instantiated by ScaleActionGenerator()
var scaleActionGenerator gopter.Gen

// ScaleActionGenerator returns a generator of ScaleAction instances for property testing.
func ScaleActionGenerator() gopter.Gen {
	if scaleActionGenerator != nil {
		return scaleActionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScaleAction(generators)
	scaleActionGenerator = gen.Struct(reflect.TypeOf(ScaleAction{}), generators)

	return scaleActionGenerator
}

// AddIndependentPropertyGeneratorsForScaleAction is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScaleAction(gens map[string]gopter.Gen) {
	gens["Cooldown"] = gen.PtrOf(gen.AlphaString())
	gens["Direction"] = gen.PtrOf(gen.OneConstOf(ScaleAction_Direction_Decrease, ScaleAction_Direction_Increase, ScaleAction_Direction_None))
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ScaleAction_Type_ChangeCount,
		ScaleAction_Type_ExactCount,
		ScaleAction_Type_PercentChangeCount,
		ScaleAction_Type_ServiceAllowedNextValue))
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_ScaleAction_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ScaleAction_STATUS to ScaleAction_STATUS via AssignProperties_To_ScaleAction_STATUS & AssignProperties_From_ScaleAction_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForScaleAction_STATUS, ScaleAction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForScaleAction_STATUS tests if a specific instance of ScaleAction_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForScaleAction_STATUS(subject ScaleAction_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ScaleAction_STATUS
	err := copied.AssignProperties_To_ScaleAction_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ScaleAction_STATUS
	err = actual.AssignProperties_From_ScaleAction_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ScaleAction_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScaleAction_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScaleAction_STATUS, ScaleAction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScaleAction_STATUS runs a test to see if a specific instance of ScaleAction_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForScaleAction_STATUS(subject ScaleAction_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScaleAction_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScaleAction_STATUS instances for property testing - lazily instantiated by ScaleAction_STATUSGenerator()
var scaleAction_STATUSGenerator gopter.Gen

// ScaleAction_STATUSGenerator returns a generator of ScaleAction_STATUS instances for property testing.
func ScaleAction_STATUSGenerator() gopter.Gen {
	if scaleAction_STATUSGenerator != nil {
		return scaleAction_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScaleAction_STATUS(generators)
	scaleAction_STATUSGenerator = gen.Struct(reflect.TypeOf(ScaleAction_STATUS{}), generators)

	return scaleAction_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForScaleAction_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScaleAction_STATUS(gens map[string]gopter.Gen) {
	gens["Cooldown"] = gen.PtrOf(gen.AlphaString())
	gens["Direction"] = gen.PtrOf(gen.OneConstOf(ScaleAction_Direction_STATUS_Decrease, ScaleAction_Direction_STATUS_Increase, ScaleAction_Direction_STATUS_None))
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ScaleAction_Type_STATUS_ChangeCount,
		ScaleAction_Type_STATUS_ExactCount,
		ScaleAction_Type_STATUS_PercentChangeCount,
		ScaleAction_Type_STATUS_ServiceAllowedNextValue))
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_ScaleCapacity_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ScaleCapacity to ScaleCapacity via AssignProperties_To_ScaleCapacity & AssignProperties_From_ScaleCapacity returns original",
		prop.ForAll(RunPropertyAssignmentTestForScaleCapacity, ScaleCapacityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForScaleCapacity tests if a specific instance of ScaleCapacity can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForScaleCapacity(subject ScaleCapacity) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ScaleCapacity
	err := copied.AssignProperties_To_ScaleCapacity(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ScaleCapacity
	err = actual.AssignProperties_From_ScaleCapacity(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ScaleCapacity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScaleCapacity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScaleCapacity, ScaleCapacityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScaleCapacity runs a test to see if a specific instance of ScaleCapacity round trips to JSON and back losslessly
func RunJSONSerializationTestForScaleCapacity(subject ScaleCapacity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScaleCapacity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScaleCapacity instances for property testing - lazily instantiated by ScaleCapacityGenerator()
var scaleCapacityGenerator gopter.Gen

// ScaleCapacityGenerator returns a generator of ScaleCapacity instances for property testing.
func ScaleCapacityGenerator() gopter.Gen {
	if scaleCapacityGenerator != nil {
		return scaleCapacityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScaleCapacity(generators)
	scaleCapacityGenerator = gen.Struct(reflect.TypeOf(ScaleCapacity{}), generators)

	return scaleCapacityGenerator
}

// AddIndependentPropertyGeneratorsForScaleCapacity is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScaleCapacity(gens map[string]gopter.Gen) {
	gens["Default"] = gen.PtrOf(gen.AlphaString())
	gens["Maximum"] = gen.PtrOf(gen.AlphaString())
	gens["Minimum"] = gen.PtrOf(gen.AlphaString())
}

func Test_ScaleCapacity_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ScaleCapacity_STATUS to ScaleCapacity_STATUS via AssignProperties_To_ScaleCapacity_STATUS & AssignProperties_From_ScaleCapacity_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForScaleCapacity_STATUS, ScaleCapacity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForScaleCapacity_STATUS tests if a specific instance of ScaleCapacity_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForScaleCapacity_STATUS(subject ScaleCapacity_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ScaleCapacity_STATUS
	err := copied.AssignProperties_To_ScaleCapacity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ScaleCapacity_STATUS
	err = actual.AssignProperties_From_ScaleCapacity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ScaleCapacity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScaleCapacity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScaleCapacity_STATUS, ScaleCapacity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScaleCapacity_STATUS runs a test to see if a specific instance of ScaleCapacity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForScaleCapacity_STATUS(subject ScaleCapacity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScaleCapacity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScaleCapacity_STATUS instances for property testing - lazily instantiated by
// ScaleCapacity_STATUSGenerator()
var scaleCapacity_STATUSGenerator gopter.Gen

// ScaleCapacity_STATUSGenerator returns a generator of ScaleCapacity_STATUS instances for property testing.
func ScaleCapacity_STATUSGenerator() gopter.Gen {
	if scaleCapacity_STATUSGenerator != nil {
		return scaleCapacity_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScaleCapacity_STATUS(generators)
	scaleCapacity_STATUSGenerator = gen.Struct(reflect.TypeOf(ScaleCapacity_STATUS{}), generators)

	return scaleCapacity_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForScaleCapacity_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScaleCapacity_STATUS(gens map[string]gopter.Gen) {
	gens["Default"] = gen.PtrOf(gen.AlphaString())
	gens["Maximum"] = gen.PtrOf(gen.AlphaString())
	gens["Minimum"] = gen.PtrOf(gen.AlphaString())
}

func Test_ScaleRule_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ScaleRule to ScaleRule via AssignProperties_To_ScaleRule & AssignProperties_From_ScaleRule returns original",
		prop.ForAll(RunPropertyAssignmentTestForScaleRule, ScaleRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForScaleRule tests if a specific instance of ScaleRule can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForScaleRule(subject ScaleRule) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ScaleRule
	err := copied.AssignProperties_To_ScaleRule(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ScaleRule
	err = actual.AssignProperties_From_ScaleRule(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ScaleRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScaleRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScaleRule, ScaleRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScaleRule runs a test to see if a specific instance of ScaleRule round trips to JSON and back losslessly
func RunJSONSerializationTestForScaleRule(subject ScaleRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScaleRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScaleRule instances for property testing - lazily instantiated by ScaleRuleGenerator()
var scaleRuleGenerator gopter.Gen

// ScaleRuleGenerator returns a generator of ScaleRule instances for property testing.
func ScaleRuleGenerator() gopter.Gen {
	if scaleRuleGenerator != nil {
		return scaleRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForScaleRule(generators)
	scaleRuleGenerator = gen.Struct(reflect.TypeOf(ScaleRule{}), generators)

	return scaleRuleGenerator
}

// AddRelatedPropertyGeneratorsForScaleRule is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForScaleRule(gens map[string]gopter.Gen) {
	gens["MetricTrigger"] = gen.PtrOf(MetricTriggerGenerator())
	gens["ScaleAction"] = gen.PtrOf(ScaleActionGenerator())
}

func Test_ScaleRuleMetricDimension_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ScaleRuleMetricDimension to ScaleRuleMetricDimension via AssignProperties_To_ScaleRuleMetricDimension & AssignProperties_From_ScaleRuleMetricDimension returns original",
		prop.ForAll(RunPropertyAssignmentTestForScaleRuleMetricDimension, ScaleRuleMetricDimensionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForScaleRuleMetricDimension tests if a specific instance of ScaleRuleMetricDimension can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForScaleRuleMetricDimension(subject ScaleRuleMetricDimension) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ScaleRuleMetricDimension
	err := copied.AssignProperties_To_ScaleRuleMetricDimension(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ScaleRuleMetricDimension
	err = actual.AssignProperties_From_ScaleRuleMetricDimension(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ScaleRuleMetricDimension_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScaleRuleMetricDimension via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScaleRuleMetricDimension, ScaleRuleMetricDimensionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScaleRuleMetricDimension runs a test to see if a specific instance of ScaleRuleMetricDimension round trips to JSON and back losslessly
func RunJSONSerializationTestForScaleRuleMetricDimension(subject ScaleRuleMetricDimension) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScaleRuleMetricDimension
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScaleRuleMetricDimension instances for property testing - lazily instantiated by
// ScaleRuleMetricDimensionGenerator()
var scaleRuleMetricDimensionGenerator gopter.Gen

// ScaleRuleMetricDimensionGenerator returns a generator of ScaleRuleMetricDimension instances for property testing.
func ScaleRuleMetricDimensionGenerator() gopter.Gen {
	if scaleRuleMetricDimensionGenerator != nil {
		return scaleRuleMetricDimensionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScaleRuleMetricDimension(generators)
	scaleRuleMetricDimensionGenerator = gen.Struct(reflect.TypeOf(ScaleRuleMetricDimension{}), generators)

	return scaleRuleMetricDimensionGenerator
}

// AddIndependentPropertyGeneratorsForScaleRuleMetricDimension is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScaleRuleMetricDimension(gens map[string]gopter.Gen) {
	gens["DimensionName"] = gen.PtrOf(gen.AlphaString())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(ScaleRuleMetricDimension_Operator_Equals, ScaleRuleMetricDimension_Operator_NotEquals))
	gens["Values"] = gen.SliceOf(gen.AlphaString())
}

func Test_ScaleRuleMetricDimension_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ScaleRuleMetricDimension_STATUS to ScaleRuleMetricDimension_STATUS via AssignProperties_To_ScaleRuleMetricDimension_STATUS & AssignProperties_From_ScaleRuleMetricDimension_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForScaleRuleMetricDimension_STATUS, ScaleRuleMetricDimension_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForScaleRuleMetricDimension_STATUS tests if a specific instance of ScaleRuleMetricDimension_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForScaleRuleMetricDimension_STATUS(subject ScaleRuleMetricDimension_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ScaleRuleMetricDimension_STATUS
	err := copied.AssignProperties_To_ScaleRuleMetricDimension_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ScaleRuleMetricDimension_STATUS
	err = actual.AssignProperties_From_ScaleRuleMetricDimension_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ScaleRuleMetricDimension_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScaleRuleMetricDimension_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScaleRuleMetricDimension_STATUS, ScaleRuleMetricDimension_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScaleRuleMetricDimension_STATUS runs a test to see if a specific instance of ScaleRuleMetricDimension_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForScaleRuleMetricDimension_STATUS(subject ScaleRuleMetricDimension_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScaleRuleMetricDimension_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScaleRuleMetricDimension_STATUS instances for property testing - lazily instantiated by
// ScaleRuleMetricDimension_STATUSGenerator()
var scaleRuleMetricDimension_STATUSGenerator gopter.Gen

// ScaleRuleMetricDimension_STATUSGenerator returns a generator of ScaleRuleMetricDimension_STATUS instances for property testing.
func ScaleRuleMetricDimension_STATUSGenerator() gopter.Gen {
	if scaleRuleMetricDimension_STATUSGenerator != nil {
		return scaleRuleMetricDimension_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScaleRuleMetricDimension_STATUS(generators)
	scaleRuleMetricDimension_STATUSGenerator = gen.Struct(reflect.TypeOf(ScaleRuleMetricDimension_STATUS{}), generators)

	return scaleRuleMetricDimension_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForScaleRuleMetricDimension_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScaleRuleMetricDimension_STATUS(gens map[string]gopter.Gen) {
	gens["DimensionName"] = gen.PtrOf(gen.AlphaString())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(ScaleRuleMetricDimension_Operator_STATUS_Equals, ScaleRuleMetricDimension_Operator_STATUS_NotEquals))
	gens["Values"] = gen.SliceOf(gen.AlphaString())
}

func Test_ScaleRule_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ScaleRule_STATUS to ScaleRule_STATUS via AssignProperties_To_ScaleRule_STATUS & AssignProperties_From_ScaleRule_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForScaleRule_STATUS, ScaleRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForScaleRule_STATUS tests if a specific instance of ScaleRule_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForScaleRule_STATUS(subject ScaleRule_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ScaleRule_STATUS
	err := copied.AssignProperties_To_ScaleRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ScaleRule_STATUS
	err = actual.AssignProperties_From_ScaleRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ScaleRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScaleRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScaleRule_STATUS, ScaleRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScaleRule_STATUS runs a test to see if a specific instance of ScaleRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForScaleRule_STATUS(subject ScaleRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScaleRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScaleRule_STATUS instances for property testing - lazily instantiated by ScaleRule_STATUSGenerator()
var scaleRule_STATUSGenerator gopter.Gen

// ScaleRule_STATUSGenerator returns a generator of ScaleRule_STATUS instances for property testing.
func ScaleRule_STATUSGenerator() gopter.Gen {
	if scaleRule_STATUSGenerator != nil {
		return scaleRule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForScaleRule_STATUS(generators)
	scaleRule_STATUSGenerator = gen.Struct(reflect.TypeOf(ScaleRule_STATUS{}), generators)

	return scaleRule_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForScaleRule_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForScaleRule_STATUS(gens map[string]gopter.Gen) {
	gens["MetricTrigger"] = gen.PtrOf(MetricTrigger_STATUSGenerator())
	gens["ScaleAction"] = gen.PtrOf(ScaleAction_STATUSGenerator())
}

func Test_SystemData_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SystemData_STATUS to SystemData_STATUS via AssignProperties_To_SystemData_STATUS & AssignProperties_From_SystemData_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSystemData_STATUS, SystemData_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSystemData_STATUS tests if a specific instance of SystemData_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSystemData_STATUS(subject SystemData_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.SystemData_STATUS
	err := copied.AssignProperties_To_SystemData_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SystemData_STATUS
	err = actual.AssignProperties_From_SystemData_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SystemData_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SystemData_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSystemData_STATUS, SystemData_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSystemData_STATUS runs a test to see if a specific instance of SystemData_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSystemData_STATUS(subject SystemData_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SystemData_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SystemData_STATUS instances for property testing - lazily instantiated by SystemData_STATUSGenerator()
var systemData_STATUSGenerator gopter.Gen

// SystemData_STATUSGenerator returns a generator of SystemData_STATUS instances for property testing.
func SystemData_STATUSGenerator() gopter.Gen {
	if systemData_STATUSGenerator != nil {
		return systemData_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSystemData_STATUS(generators)
	systemData_STATUSGenerator = gen.Struct(reflect.TypeOf(SystemData_STATUS{}), generators)

	return systemData_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSystemData_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSystemData_STATUS(gens map[string]gopter.Gen) {
	gens["CreatedAt"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedBy"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemData_CreatedByType_STATUS_Application,
		SystemData_CreatedByType_STATUS_Key,
		SystemData_CreatedByType_STATUS_ManagedIdentity,
		SystemData_CreatedByType_STATUS_User))
	gens["LastModifiedAt"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedBy"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemData_LastModifiedByType_STATUS_Application,
		SystemData_LastModifiedByType_STATUS_Key,
		SystemData_LastModifiedByType_STATUS_ManagedIdentity,
		SystemData_LastModifiedByType_STATUS_User))
}

func Test_TimeWindow_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from TimeWindow to TimeWindow via AssignProperties_To_TimeWindow & AssignProperties_From_TimeWindow returns original",
		prop.ForAll(RunPropertyAssignmentTestForTimeWindow, TimeWindowGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForTimeWindow tests if a specific instance of TimeWindow can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForTimeWindow(subject TimeWindow) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.TimeWindow
	err := copied.AssignProperties_To_TimeWindow(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual TimeWindow
	err = actual.AssignProperties_From_TimeWindow(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_TimeWindow_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TimeWindow via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTimeWindow, TimeWindowGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTimeWindow runs a test to see if a specific instance of TimeWindow round trips to JSON and back losslessly
func RunJSONSerializationTestForTimeWindow(subject TimeWindow) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TimeWindow
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TimeWindow instances for property testing - lazily instantiated by TimeWindowGenerator()
var timeWindowGenerator gopter.Gen

// TimeWindowGenerator returns a generator of TimeWindow instances for property testing.
func TimeWindowGenerator() gopter.Gen {
	if timeWindowGenerator != nil {
		return timeWindowGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTimeWindow(generators)
	timeWindowGenerator = gen.Struct(reflect.TypeOf(TimeWindow{}), generators)

	return timeWindowGenerator
}

// AddIndependentPropertyGeneratorsForTimeWindow is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTimeWindow(gens map[string]gopter.Gen) {
	gens["End"] = gen.PtrOf(gen.AlphaString())
	gens["Start"] = gen.PtrOf(gen.AlphaString())
	gens["TimeZone"] = gen.PtrOf(gen.AlphaString())
}

func Test_TimeWindow_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from TimeWindow_STATUS to TimeWindow_STATUS via AssignProperties_To_TimeWindow_STATUS & AssignProperties_From_TimeWindow_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForTimeWindow_STATUS, TimeWindow_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForTimeWindow_STATUS tests if a specific instance of TimeWindow_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForTimeWindow_STATUS(subject TimeWindow_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.TimeWindow_STATUS
	err := copied.AssignProperties_To_TimeWindow_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual TimeWindow_STATUS
	err = actual.AssignProperties_From_TimeWindow_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_TimeWindow_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TimeWindow_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTimeWindow_STATUS, TimeWindow_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTimeWindow_STATUS runs a test to see if a specific instance of TimeWindow_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForTimeWindow_STATUS(subject TimeWindow_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TimeWindow_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TimeWindow_STATUS instances for property testing - lazily instantiated by TimeWindow_STATUSGenerator()
var timeWindow_STATUSGenerator gopter.Gen

// TimeWindow_STATUSGenerator returns a generator of TimeWindow_STATUS instances for property testing.
func TimeWindow_STATUSGenerator() gopter.Gen {
	if timeWindow_STATUSGenerator != nil {
		return timeWindow_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTimeWindow_STATUS(generators)
	timeWindow_STATUSGenerator = gen.Struct(reflect.TypeOf(TimeWindow_STATUS{}), generators)

	return timeWindow_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForTimeWindow_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTimeWindow_STATUS(gens map[string]gopter.Gen) {
	gens["End"] = gen.PtrOf(gen.AlphaString())
	gens["Start"] = gen.PtrOf(gen.AlphaString())
	gens["TimeZone"] = gen.PtrOf(gen.AlphaString())
}

func Test_WebhookNotification_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WebhookNotification to WebhookNotification via AssignProperties_To_WebhookNotification & AssignProperties_From_WebhookNotification returns original",
		prop.ForAll(RunPropertyAssignmentTestForWebhookNotification, WebhookNotificationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWebhookNotification tests if a specific instance of WebhookNotification can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWebhookNotification(subject WebhookNotification) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.WebhookNotification
	err := copied.AssignProperties_To_WebhookNotification(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WebhookNotification
	err = actual.AssignProperties_From_WebhookNotification(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WebhookNotification_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebhookNotification via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebhookNotification, WebhookNotificationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebhookNotification runs a test to see if a specific instance of WebhookNotification round trips to JSON and back losslessly
func RunJSONSerializationTestForWebhookNotification(subject WebhookNotification) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebhookNotification
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebhookNotification instances for property testing - lazily instantiated by
// WebhookNotificationGenerator()
var webhookNotificationGenerator gopter.Gen

// WebhookNotificationGenerator returns a generator of WebhookNotification instances for property testing.
func WebhookNotificationGenerator() gopter.Gen {
	if webhookNotificationGenerator != nil {
		return webhookNotificationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebhookNotification(generators)
	webhookNotificationGenerator = gen.Struct(reflect.TypeOf(WebhookNotification{}), generators)

	return webhookNotificationGenerator
}

// AddIndependentPropertyGeneratorsForWebhookNotification is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebhookNotification(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["ServiceUri"] = gen.PtrOf(gen.AlphaString())
}

func Test_WebhookNotification_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WebhookNotification_STATUS to WebhookNotification_STATUS via AssignProperties_To_WebhookNotification_STATUS & AssignProperties_From_WebhookNotification_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForWebhookNotification_STATUS, WebhookNotification_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWebhookNotification_STATUS tests if a specific instance of WebhookNotification_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWebhookNotification_STATUS(subject WebhookNotification_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.WebhookNotification_STATUS
	err := copied.AssignProperties_To_WebhookNotification_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WebhookNotification_STATUS
	err = actual.AssignProperties_From_WebhookNotification_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WebhookNotification_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebhookNotification_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebhookNotification_STATUS, WebhookNotification_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebhookNotification_STATUS runs a test to see if a specific instance of WebhookNotification_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForWebhookNotification_STATUS(subject WebhookNotification_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebhookNotification_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebhookNotification_STATUS instances for property testing - lazily instantiated by
// WebhookNotification_STATUSGenerator()
var webhookNotification_STATUSGenerator gopter.Gen

// WebhookNotification_STATUSGenerator returns a generator of WebhookNotification_STATUS instances for property testing.
func WebhookNotification_STATUSGenerator() gopter.Gen {
	if webhookNotification_STATUSGenerator != nil {
		return webhookNotification_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebhookNotification_STATUS(generators)
	webhookNotification_STATUSGenerator = gen.Struct(reflect.TypeOf(WebhookNotification_STATUS{}), generators)

	return webhookNotification_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForWebhookNotification_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebhookNotification_STATUS(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["ServiceUri"] = gen.PtrOf(gen.AlphaString())
}
