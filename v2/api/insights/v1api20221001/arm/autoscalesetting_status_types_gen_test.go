// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package arm

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_AutoscaleNotification_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoscaleNotification_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoscaleNotification_STATUS, AutoscaleNotification_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoscaleNotification_STATUS runs a test to see if a specific instance of AutoscaleNotification_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoscaleNotification_STATUS(subject AutoscaleNotification_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoscaleNotification_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoscaleNotification_STATUS instances for property testing - lazily instantiated by
// AutoscaleNotification_STATUSGenerator()
var autoscaleNotification_STATUSGenerator gopter.Gen

// AutoscaleNotification_STATUSGenerator returns a generator of AutoscaleNotification_STATUS instances for property testing.
// We first initialize autoscaleNotification_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AutoscaleNotification_STATUSGenerator() gopter.Gen {
	if autoscaleNotification_STATUSGenerator != nil {
		return autoscaleNotification_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscaleNotification_STATUS(generators)
	autoscaleNotification_STATUSGenerator = gen.Struct(reflect.TypeOf(AutoscaleNotification_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscaleNotification_STATUS(generators)
	AddRelatedPropertyGeneratorsForAutoscaleNotification_STATUS(generators)
	autoscaleNotification_STATUSGenerator = gen.Struct(reflect.TypeOf(AutoscaleNotification_STATUS{}), generators)

	return autoscaleNotification_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAutoscaleNotification_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoscaleNotification_STATUS(gens map[string]gopter.Gen) {
	gens["Operation"] = gen.PtrOf(gen.OneConstOf(AutoscaleNotification_Operation_STATUS_Scale))
}

// AddRelatedPropertyGeneratorsForAutoscaleNotification_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoscaleNotification_STATUS(gens map[string]gopter.Gen) {
	gens["Email"] = gen.PtrOf(EmailNotification_STATUSGenerator())
	gens["Webhooks"] = gen.SliceOf(WebhookNotification_STATUSGenerator())
}

func Test_AutoscaleProfile_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoscaleProfile_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoscaleProfile_STATUS, AutoscaleProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoscaleProfile_STATUS runs a test to see if a specific instance of AutoscaleProfile_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoscaleProfile_STATUS(subject AutoscaleProfile_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoscaleProfile_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoscaleProfile_STATUS instances for property testing - lazily instantiated by
// AutoscaleProfile_STATUSGenerator()
var autoscaleProfile_STATUSGenerator gopter.Gen

// AutoscaleProfile_STATUSGenerator returns a generator of AutoscaleProfile_STATUS instances for property testing.
// We first initialize autoscaleProfile_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AutoscaleProfile_STATUSGenerator() gopter.Gen {
	if autoscaleProfile_STATUSGenerator != nil {
		return autoscaleProfile_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscaleProfile_STATUS(generators)
	autoscaleProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(AutoscaleProfile_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscaleProfile_STATUS(generators)
	AddRelatedPropertyGeneratorsForAutoscaleProfile_STATUS(generators)
	autoscaleProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(AutoscaleProfile_STATUS{}), generators)

	return autoscaleProfile_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAutoscaleProfile_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoscaleProfile_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAutoscaleProfile_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoscaleProfile_STATUS(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(ScaleCapacity_STATUSGenerator())
	gens["FixedDate"] = gen.PtrOf(TimeWindow_STATUSGenerator())
	gens["Recurrence"] = gen.PtrOf(Recurrence_STATUSGenerator())
	gens["Rules"] = gen.SliceOf(ScaleRule_STATUSGenerator())
}

func Test_AutoscaleSetting_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoscaleSetting_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoscaleSetting_STATUS, AutoscaleSetting_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoscaleSetting_STATUS runs a test to see if a specific instance of AutoscaleSetting_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoscaleSetting_STATUS(subject AutoscaleSetting_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoscaleSetting_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoscaleSetting_STATUS instances for property testing - lazily instantiated by
// AutoscaleSetting_STATUSGenerator()
var autoscaleSetting_STATUSGenerator gopter.Gen

// AutoscaleSetting_STATUSGenerator returns a generator of AutoscaleSetting_STATUS instances for property testing.
// We first initialize autoscaleSetting_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AutoscaleSetting_STATUSGenerator() gopter.Gen {
	if autoscaleSetting_STATUSGenerator != nil {
		return autoscaleSetting_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscaleSetting_STATUS(generators)
	autoscaleSetting_STATUSGenerator = gen.Struct(reflect.TypeOf(AutoscaleSetting_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscaleSetting_STATUS(generators)
	AddRelatedPropertyGeneratorsForAutoscaleSetting_STATUS(generators)
	autoscaleSetting_STATUSGenerator = gen.Struct(reflect.TypeOf(AutoscaleSetting_STATUS{}), generators)

	return autoscaleSetting_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAutoscaleSetting_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoscaleSetting_STATUS(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["TargetResourceLocation"] = gen.PtrOf(gen.AlphaString())
	gens["TargetResourceUri"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAutoscaleSetting_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoscaleSetting_STATUS(gens map[string]gopter.Gen) {
	gens["Notifications"] = gen.SliceOf(AutoscaleNotification_STATUSGenerator())
	gens["PredictiveAutoscalePolicy"] = gen.PtrOf(PredictiveAutoscalePolicy_STATUSGenerator())
	gens["Profiles"] = gen.SliceOf(AutoscaleProfile_STATUSGenerator())
}

func Test_Autoscalesetting_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Autoscalesetting_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoscalesetting_STATUS, Autoscalesetting_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoscalesetting_STATUS runs a test to see if a specific instance of Autoscalesetting_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoscalesetting_STATUS(subject Autoscalesetting_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Autoscalesetting_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Autoscalesetting_STATUS instances for property testing - lazily instantiated by
// Autoscalesetting_STATUSGenerator()
var autoscalesetting_STATUSGenerator gopter.Gen

// Autoscalesetting_STATUSGenerator returns a generator of Autoscalesetting_STATUS instances for property testing.
// We first initialize autoscalesetting_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Autoscalesetting_STATUSGenerator() gopter.Gen {
	if autoscalesetting_STATUSGenerator != nil {
		return autoscalesetting_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscalesetting_STATUS(generators)
	autoscalesetting_STATUSGenerator = gen.Struct(reflect.TypeOf(Autoscalesetting_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscalesetting_STATUS(generators)
	AddRelatedPropertyGeneratorsForAutoscalesetting_STATUS(generators)
	autoscalesetting_STATUSGenerator = gen.Struct(reflect.TypeOf(Autoscalesetting_STATUS{}), generators)

	return autoscalesetting_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAutoscalesetting_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoscalesetting_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAutoscalesetting_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoscalesetting_STATUS(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(AutoscaleSetting_STATUSGenerator())
	gens["SystemData"] = gen.PtrOf(SystemData_STATUSGenerator())
}

func Test_EmailNotification_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EmailNotification_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEmailNotification_STATUS, EmailNotification_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEmailNotification_STATUS runs a test to see if a specific instance of EmailNotification_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEmailNotification_STATUS(subject EmailNotification_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EmailNotification_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EmailNotification_STATUS instances for property testing - lazily instantiated by
// EmailNotification_STATUSGenerator()
var emailNotification_STATUSGenerator gopter.Gen

// EmailNotification_STATUSGenerator returns a generator of EmailNotification_STATUS instances for property testing.
func EmailNotification_STATUSGenerator() gopter.Gen {
	if emailNotification_STATUSGenerator != nil {
		return emailNotification_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEmailNotification_STATUS(generators)
	emailNotification_STATUSGenerator = gen.Struct(reflect.TypeOf(EmailNotification_STATUS{}), generators)

	return emailNotification_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForEmailNotification_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEmailNotification_STATUS(gens map[string]gopter.Gen) {
	gens["CustomEmails"] = gen.SliceOf(gen.AlphaString())
	gens["SendToSubscriptionAdministrator"] = gen.PtrOf(gen.Bool())
	gens["SendToSubscriptionCoAdministrators"] = gen.PtrOf(gen.Bool())
}

func Test_MetricTrigger_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MetricTrigger_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMetricTrigger_STATUS, MetricTrigger_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMetricTrigger_STATUS runs a test to see if a specific instance of MetricTrigger_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForMetricTrigger_STATUS(subject MetricTrigger_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MetricTrigger_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MetricTrigger_STATUS instances for property testing - lazily instantiated by
// MetricTrigger_STATUSGenerator()
var metricTrigger_STATUSGenerator gopter.Gen

// MetricTrigger_STATUSGenerator returns a generator of MetricTrigger_STATUS instances for property testing.
// We first initialize metricTrigger_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func MetricTrigger_STATUSGenerator() gopter.Gen {
	if metricTrigger_STATUSGenerator != nil {
		return metricTrigger_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricTrigger_STATUS(generators)
	metricTrigger_STATUSGenerator = gen.Struct(reflect.TypeOf(MetricTrigger_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricTrigger_STATUS(generators)
	AddRelatedPropertyGeneratorsForMetricTrigger_STATUS(generators)
	metricTrigger_STATUSGenerator = gen.Struct(reflect.TypeOf(MetricTrigger_STATUS{}), generators)

	return metricTrigger_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForMetricTrigger_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMetricTrigger_STATUS(gens map[string]gopter.Gen) {
	gens["DividePerInstance"] = gen.PtrOf(gen.Bool())
	gens["MetricName"] = gen.PtrOf(gen.AlphaString())
	gens["MetricNamespace"] = gen.PtrOf(gen.AlphaString())
	gens["MetricResourceLocation"] = gen.PtrOf(gen.AlphaString())
	gens["MetricResourceUri"] = gen.PtrOf(gen.AlphaString())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		MetricTrigger_Operator_STATUS_Equals,
		MetricTrigger_Operator_STATUS_GreaterThan,
		MetricTrigger_Operator_STATUS_GreaterThanOrEqual,
		MetricTrigger_Operator_STATUS_LessThan,
		MetricTrigger_Operator_STATUS_LessThanOrEqual,
		MetricTrigger_Operator_STATUS_NotEquals))
	gens["Statistic"] = gen.PtrOf(gen.OneConstOf(
		MetricTrigger_Statistic_STATUS_Average,
		MetricTrigger_Statistic_STATUS_Count,
		MetricTrigger_Statistic_STATUS_Max,
		MetricTrigger_Statistic_STATUS_Min,
		MetricTrigger_Statistic_STATUS_Sum))
	gens["Threshold"] = gen.PtrOf(gen.Float64())
	gens["TimeAggregation"] = gen.PtrOf(gen.OneConstOf(
		MetricTrigger_TimeAggregation_STATUS_Average,
		MetricTrigger_TimeAggregation_STATUS_Count,
		MetricTrigger_TimeAggregation_STATUS_Last,
		MetricTrigger_TimeAggregation_STATUS_Maximum,
		MetricTrigger_TimeAggregation_STATUS_Minimum,
		MetricTrigger_TimeAggregation_STATUS_Total))
	gens["TimeGrain"] = gen.PtrOf(gen.AlphaString())
	gens["TimeWindow"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForMetricTrigger_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMetricTrigger_STATUS(gens map[string]gopter.Gen) {
	gens["Dimensions"] = gen.SliceOf(ScaleRuleMetricDimension_STATUSGenerator())
}

func Test_PredictiveAutoscalePolicy_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PredictiveAutoscalePolicy_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPredictiveAutoscalePolicy_STATUS, PredictiveAutoscalePolicy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPredictiveAutoscalePolicy_STATUS runs a test to see if a specific instance of PredictiveAutoscalePolicy_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPredictiveAutoscalePolicy_STATUS(subject PredictiveAutoscalePolicy_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PredictiveAutoscalePolicy_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PredictiveAutoscalePolicy_STATUS instances for property testing - lazily instantiated by
// PredictiveAutoscalePolicy_STATUSGenerator()
var predictiveAutoscalePolicy_STATUSGenerator gopter.Gen

// PredictiveAutoscalePolicy_STATUSGenerator returns a generator of PredictiveAutoscalePolicy_STATUS instances for property testing.
func PredictiveAutoscalePolicy_STATUSGenerator() gopter.Gen {
	if predictiveAutoscalePolicy_STATUSGenerator != nil {
		return predictiveAutoscalePolicy_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPredictiveAutoscalePolicy_STATUS(generators)
	predictiveAutoscalePolicy_STATUSGenerator = gen.Struct(reflect.TypeOf(PredictiveAutoscalePolicy_STATUS{}), generators)

	return predictiveAutoscalePolicy_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForPredictiveAutoscalePolicy_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPredictiveAutoscalePolicy_STATUS(gens map[string]gopter.Gen) {
	gens["ScaleLookAheadTime"] = gen.PtrOf(gen.AlphaString())
	gens["ScaleMode"] = gen.PtrOf(gen.OneConstOf(PredictiveAutoscalePolicy_ScaleMode_STATUS_Disabled, PredictiveAutoscalePolicy_ScaleMode_STATUS_Enabled, PredictiveAutoscalePolicy_ScaleMode_STATUS_ForecastOnly))
}

func Test_Recurrence_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Recurrence_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRecurrence_STATUS, Recurrence_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRecurrence_STATUS runs a test to see if a specific instance of Recurrence_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRecurrence_STATUS(subject Recurrence_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Recurrence_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Recurrence_STATUS instances for property testing - lazily instantiated by Recurrence_STATUSGenerator()
var recurrence_STATUSGenerator gopter.Gen

// Recurrence_STATUSGenerator returns a generator of Recurrence_STATUS instances for property testing.
// We first initialize recurrence_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Recurrence_STATUSGenerator() gopter.Gen {
	if recurrence_STATUSGenerator != nil {
		return recurrence_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRecurrence_STATUS(generators)
	recurrence_STATUSGenerator = gen.Struct(reflect.TypeOf(Recurrence_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRecurrence_STATUS(generators)
	AddRelatedPropertyGeneratorsForRecurrence_STATUS(generators)
	recurrence_STATUSGenerator = gen.Struct(reflect.TypeOf(Recurrence_STATUS{}), generators)

	return recurrence_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForRecurrence_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRecurrence_STATUS(gens map[string]gopter.Gen) {
	gens["Frequency"] = gen.PtrOf(gen.OneConstOf(
		Recurrence_Frequency_STATUS_Day,
		Recurrence_Frequency_STATUS_Hour,
		Recurrence_Frequency_STATUS_Minute,
		Recurrence_Frequency_STATUS_Month,
		Recurrence_Frequency_STATUS_None,
		Recurrence_Frequency_STATUS_Second,
		Recurrence_Frequency_STATUS_Week,
		Recurrence_Frequency_STATUS_Year))
}

// AddRelatedPropertyGeneratorsForRecurrence_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRecurrence_STATUS(gens map[string]gopter.Gen) {
	gens["Schedule"] = gen.PtrOf(RecurrentSchedule_STATUSGenerator())
}

func Test_RecurrentSchedule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RecurrentSchedule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRecurrentSchedule_STATUS, RecurrentSchedule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRecurrentSchedule_STATUS runs a test to see if a specific instance of RecurrentSchedule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRecurrentSchedule_STATUS(subject RecurrentSchedule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RecurrentSchedule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RecurrentSchedule_STATUS instances for property testing - lazily instantiated by
// RecurrentSchedule_STATUSGenerator()
var recurrentSchedule_STATUSGenerator gopter.Gen

// RecurrentSchedule_STATUSGenerator returns a generator of RecurrentSchedule_STATUS instances for property testing.
func RecurrentSchedule_STATUSGenerator() gopter.Gen {
	if recurrentSchedule_STATUSGenerator != nil {
		return recurrentSchedule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRecurrentSchedule_STATUS(generators)
	recurrentSchedule_STATUSGenerator = gen.Struct(reflect.TypeOf(RecurrentSchedule_STATUS{}), generators)

	return recurrentSchedule_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForRecurrentSchedule_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRecurrentSchedule_STATUS(gens map[string]gopter.Gen) {
	gens["Days"] = gen.SliceOf(gen.AlphaString())
	gens["Hours"] = gen.SliceOf(gen.Int())
	gens["Minutes"] = gen.SliceOf(gen.Int())
	gens["TimeZone"] = gen.PtrOf(gen.AlphaString())
}

func Test_ScaleAction_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScaleAction_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScaleAction_STATUS, ScaleAction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScaleAction_STATUS runs a test to see if a specific instance of ScaleAction_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForScaleAction_STATUS(subject ScaleAction_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScaleAction_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScaleAction_STATUS instances for property testing - lazily instantiated by ScaleAction_STATUSGenerator()
var scaleAction_STATUSGenerator gopter.Gen

// ScaleAction_STATUSGenerator returns a generator of ScaleAction_STATUS instances for property testing.
func ScaleAction_STATUSGenerator() gopter.Gen {
	if scaleAction_STATUSGenerator != nil {
		return scaleAction_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScaleAction_STATUS(generators)
	scaleAction_STATUSGenerator = gen.Struct(reflect.TypeOf(ScaleAction_STATUS{}), generators)

	return scaleAction_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForScaleAction_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScaleAction_STATUS(gens map[string]gopter.Gen) {
	gens["Cooldown"] = gen.PtrOf(gen.AlphaString())
	gens["Direction"] = gen.PtrOf(gen.OneConstOf(ScaleAction_Direction_STATUS_Decrease, ScaleAction_Direction_STATUS_Increase, ScaleAction_Direction_STATUS_None))
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ScaleAction_Type_STATUS_ChangeCount,
		ScaleAction_Type_STATUS_ExactCount,
		ScaleAction_Type_STATUS_PercentChangeCount,
		ScaleAction_Type_STATUS_ServiceAllowedNextValue))
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_ScaleCapacity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScaleCapacity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScaleCapacity_STATUS, ScaleCapacity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScaleCapacity_STATUS runs a test to see if a specific instance of ScaleCapacity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForScaleCapacity_STATUS(subject ScaleCapacity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScaleCapacity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScaleCapacity_STATUS instances for property testing - lazily instantiated by
// ScaleCapacity_STATUSGenerator()
var scaleCapacity_STATUSGenerator gopter.Gen

// ScaleCapacity_STATUSGenerator returns a generator of ScaleCapacity_STATUS instances for property testing.
func ScaleCapacity_STATUSGenerator() gopter.Gen {
	if scaleCapacity_STATUSGenerator != nil {
		return scaleCapacity_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScaleCapacity_STATUS(generators)
	scaleCapacity_STATUSGenerator = gen.Struct(reflect.TypeOf(ScaleCapacity_STATUS{}), generators)

	return scaleCapacity_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForScaleCapacity_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScaleCapacity_STATUS(gens map[string]gopter.Gen) {
	gens["Default"] = gen.PtrOf(gen.AlphaString())
	gens["Maximum"] = gen.PtrOf(gen.AlphaString())
	gens["Minimum"] = gen.PtrOf(gen.AlphaString())
}

func Test_ScaleRuleMetricDimension_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScaleRuleMetricDimension_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScaleRuleMetricDimension_STATUS, ScaleRuleMetricDimension_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScaleRuleMetricDimension_STATUS runs a test to see if a specific instance of ScaleRuleMetricDimension_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForScaleRuleMetricDimension_STATUS(subject ScaleRuleMetricDimension_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScaleRuleMetricDimension_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScaleRuleMetricDimension_STATUS instances for property testing - lazily instantiated by
// ScaleRuleMetricDimension_STATUSGenerator()
var scaleRuleMetricDimension_STATUSGenerator gopter.Gen

// ScaleRuleMetricDimension_STATUSGenerator returns a generator of ScaleRuleMetricDimension_STATUS instances for property testing.
func ScaleRuleMetricDimension_STATUSGenerator() gopter.Gen {
	if scaleRuleMetricDimension_STATUSGenerator != nil {
		return scaleRuleMetricDimension_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScaleRuleMetricDimension_STATUS(generators)
	scaleRuleMetricDimension_STATUSGenerator = gen.Struct(reflect.TypeOf(ScaleRuleMetricDimension_STATUS{}), generators)

	return scaleRuleMetricDimension_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForScaleRuleMetricDimension_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScaleRuleMetricDimension_STATUS(gens map[string]gopter.Gen) {
	gens["DimensionName"] = gen.PtrOf(gen.AlphaString())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(ScaleRuleMetricDimension_Operator_STATUS_Equals, ScaleRuleMetricDimension_Operator_STATUS_NotEquals))
	gens["Values"] = gen.SliceOf(gen.AlphaString())
}

func Test_ScaleRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScaleRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScaleRule_STATUS, ScaleRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScaleRule_STATUS runs a test to see if a specific instance of ScaleRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForScaleRule_STATUS(subject ScaleRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScaleRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScaleRule_STATUS instances for property testing - lazily instantiated by ScaleRule_STATUSGenerator()
var scaleRule_STATUSGenerator gopter.Gen

// ScaleRule_STATUSGenerator returns a generator of ScaleRule_STATUS instances for property testing.
func ScaleRule_STATUSGenerator() gopter.Gen {
	if scaleRule_STATUSGenerator != nil {
		return scaleRule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForScaleRule_STATUS(generators)
	scaleRule_STATUSGenerator = gen.Struct(reflect.TypeOf(ScaleRule_STATUS{}), generators)

	return scaleRule_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForScaleRule_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForScaleRule_STATUS(gens map[string]gopter.Gen) {
	gens["MetricTrigger"] = gen.PtrOf(MetricTrigger_STATUSGenerator())
	gens["ScaleAction"] = gen.PtrOf(ScaleAction_STATUSGenerator())
}

func Test_SystemData_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SystemData_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSystemData_STATUS, SystemData_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSystemData_STATUS runs a test to see if a specific instance of SystemData_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSystemData_STATUS(subject SystemData_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SystemData_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SystemData_STATUS instances for property testing - lazily instantiated by SystemData_STATUSGenerator()
var systemData_STATUSGenerator gopter.Gen

// SystemData_STATUSGenerator returns a generator of SystemData_STATUS instances for property testing.
func SystemData_STATUSGenerator() gopter.Gen {
	if systemData_STATUSGenerator != nil {
		return systemData_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSystemData_STATUS(generators)
	systemData_STATUSGenerator = gen.Struct(reflect.TypeOf(SystemData_STATUS{}), generators)

	return systemData_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSystemData_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSystemData_STATUS(gens map[string]gopter.Gen) {
	gens["CreatedAt"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedBy"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemData_CreatedByType_STATUS_Application,
		SystemData_CreatedByType_STATUS_Key,
		SystemData_CreatedByType_STATUS_ManagedIdentity,
		SystemData_CreatedByType_STATUS_User))
	gens["LastModifiedAt"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedBy"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemData_LastModifiedByType_STATUS_Application,
		SystemData_LastModifiedByType_STATUS_Key,
		SystemData_LastModifiedByType_STATUS_ManagedIdentity,
		SystemData_LastModifiedByType_STATUS_User))
}

func Test_TimeWindow_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TimeWindow_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTimeWindow_STATUS, TimeWindow_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTimeWindow_STATUS runs a test to see if a specific instance of TimeWindow_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForTimeWindow_STATUS(subject TimeWindow_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TimeWindow_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TimeWindow_STATUS instances for property testing - lazily instantiated by TimeWindow_STATUSGenerator()
var timeWindow_STATUSGenerator gopter.Gen

// TimeWindow_STATUSGenerator returns a generator of TimeWindow_STATUS instances for property testing.
func TimeWindow_STATUSGenerator() gopter.Gen {
	if timeWindow_STATUSGenerator != nil {
		return timeWindow_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTimeWindow_STATUS(generators)
	timeWindow_STATUSGenerator = gen.Struct(reflect.TypeOf(TimeWindow_STATUS{}), generators)

	return timeWindow_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForTimeWindow_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTimeWindow_STATUS(gens map[string]gopter.Gen) {
	gens["End"] = gen.PtrOf(gen.AlphaString())
	gens["Start"] = gen.PtrOf(gen.AlphaString())
	gens["TimeZone"] = gen.PtrOf(gen.AlphaString())
}

func Test_WebhookNotification_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebhookNotification_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebhookNotification_STATUS, WebhookNotification_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebhookNotification_STATUS runs a test to see if a specific instance of WebhookNotification_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForWebhookNotification_STATUS(subject WebhookNotification_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebhookNotification_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebhookNotification_STATUS instances for property testing - lazily instantiated by
// WebhookNotification_STATUSGenerator()
var webhookNotification_STATUSGenerator gopter.Gen

// WebhookNotification_STATUSGenerator returns a generator of WebhookNotification_STATUS instances for property testing.
func WebhookNotification_STATUSGenerator() gopter.Gen {
	if webhookNotification_STATUSGenerator != nil {
		return webhookNotification_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebhookNotification_STATUS(generators)
	webhookNotification_STATUSGenerator = gen.Struct(reflect.TypeOf(WebhookNotification_STATUS{}), generators)

	return webhookNotification_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForWebhookNotification_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebhookNotification_STATUS(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["ServiceUri"] = gen.PtrOf(gen.AlphaString())
}
