// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package arm

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_AutoscaleNotification_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoscaleNotification via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoscaleNotification, AutoscaleNotificationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoscaleNotification runs a test to see if a specific instance of AutoscaleNotification round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoscaleNotification(subject AutoscaleNotification) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoscaleNotification
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoscaleNotification instances for property testing - lazily instantiated by
// AutoscaleNotificationGenerator()
var autoscaleNotificationGenerator gopter.Gen

// AutoscaleNotificationGenerator returns a generator of AutoscaleNotification instances for property testing.
// We first initialize autoscaleNotificationGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AutoscaleNotificationGenerator() gopter.Gen {
	if autoscaleNotificationGenerator != nil {
		return autoscaleNotificationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscaleNotification(generators)
	autoscaleNotificationGenerator = gen.Struct(reflect.TypeOf(AutoscaleNotification{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscaleNotification(generators)
	AddRelatedPropertyGeneratorsForAutoscaleNotification(generators)
	autoscaleNotificationGenerator = gen.Struct(reflect.TypeOf(AutoscaleNotification{}), generators)

	return autoscaleNotificationGenerator
}

// AddIndependentPropertyGeneratorsForAutoscaleNotification is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoscaleNotification(gens map[string]gopter.Gen) {
	gens["Operation"] = gen.PtrOf(gen.OneConstOf(AutoscaleNotification_Operation_Scale))
}

// AddRelatedPropertyGeneratorsForAutoscaleNotification is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoscaleNotification(gens map[string]gopter.Gen) {
	gens["Email"] = gen.PtrOf(EmailNotificationGenerator())
	gens["Webhooks"] = gen.SliceOf(WebhookNotificationGenerator())
}

func Test_AutoscaleProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoscaleProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoscaleProfile, AutoscaleProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoscaleProfile runs a test to see if a specific instance of AutoscaleProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoscaleProfile(subject AutoscaleProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoscaleProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoscaleProfile instances for property testing - lazily instantiated by AutoscaleProfileGenerator()
var autoscaleProfileGenerator gopter.Gen

// AutoscaleProfileGenerator returns a generator of AutoscaleProfile instances for property testing.
// We first initialize autoscaleProfileGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AutoscaleProfileGenerator() gopter.Gen {
	if autoscaleProfileGenerator != nil {
		return autoscaleProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscaleProfile(generators)
	autoscaleProfileGenerator = gen.Struct(reflect.TypeOf(AutoscaleProfile{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscaleProfile(generators)
	AddRelatedPropertyGeneratorsForAutoscaleProfile(generators)
	autoscaleProfileGenerator = gen.Struct(reflect.TypeOf(AutoscaleProfile{}), generators)

	return autoscaleProfileGenerator
}

// AddIndependentPropertyGeneratorsForAutoscaleProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoscaleProfile(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAutoscaleProfile is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoscaleProfile(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(ScaleCapacityGenerator())
	gens["FixedDate"] = gen.PtrOf(TimeWindowGenerator())
	gens["Recurrence"] = gen.PtrOf(RecurrenceGenerator())
	gens["Rules"] = gen.SliceOf(ScaleRuleGenerator())
}

func Test_AutoscaleSettingProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoscaleSettingProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoscaleSettingProperties, AutoscaleSettingPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoscaleSettingProperties runs a test to see if a specific instance of AutoscaleSettingProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoscaleSettingProperties(subject AutoscaleSettingProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoscaleSettingProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoscaleSettingProperties instances for property testing - lazily instantiated by
// AutoscaleSettingPropertiesGenerator()
var autoscaleSettingPropertiesGenerator gopter.Gen

// AutoscaleSettingPropertiesGenerator returns a generator of AutoscaleSettingProperties instances for property testing.
// We first initialize autoscaleSettingPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AutoscaleSettingPropertiesGenerator() gopter.Gen {
	if autoscaleSettingPropertiesGenerator != nil {
		return autoscaleSettingPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscaleSettingProperties(generators)
	autoscaleSettingPropertiesGenerator = gen.Struct(reflect.TypeOf(AutoscaleSettingProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscaleSettingProperties(generators)
	AddRelatedPropertyGeneratorsForAutoscaleSettingProperties(generators)
	autoscaleSettingPropertiesGenerator = gen.Struct(reflect.TypeOf(AutoscaleSettingProperties{}), generators)

	return autoscaleSettingPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForAutoscaleSettingProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoscaleSettingProperties(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["TargetResourceLocation"] = gen.PtrOf(gen.AlphaString())
	gens["TargetResourceUri"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAutoscaleSettingProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoscaleSettingProperties(gens map[string]gopter.Gen) {
	gens["Notifications"] = gen.SliceOf(AutoscaleNotificationGenerator())
	gens["PredictiveAutoscalePolicy"] = gen.PtrOf(PredictiveAutoscalePolicyGenerator())
	gens["Profiles"] = gen.SliceOf(AutoscaleProfileGenerator())
}

func Test_AutoscaleSetting_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoscaleSetting_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoscaleSetting_Spec, AutoscaleSetting_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoscaleSetting_Spec runs a test to see if a specific instance of AutoscaleSetting_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoscaleSetting_Spec(subject AutoscaleSetting_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoscaleSetting_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoscaleSetting_Spec instances for property testing - lazily instantiated by
// AutoscaleSetting_SpecGenerator()
var autoscaleSetting_SpecGenerator gopter.Gen

// AutoscaleSetting_SpecGenerator returns a generator of AutoscaleSetting_Spec instances for property testing.
// We first initialize autoscaleSetting_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AutoscaleSetting_SpecGenerator() gopter.Gen {
	if autoscaleSetting_SpecGenerator != nil {
		return autoscaleSetting_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscaleSetting_Spec(generators)
	autoscaleSetting_SpecGenerator = gen.Struct(reflect.TypeOf(AutoscaleSetting_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscaleSetting_Spec(generators)
	AddRelatedPropertyGeneratorsForAutoscaleSetting_Spec(generators)
	autoscaleSetting_SpecGenerator = gen.Struct(reflect.TypeOf(AutoscaleSetting_Spec{}), generators)

	return autoscaleSetting_SpecGenerator
}

// AddIndependentPropertyGeneratorsForAutoscaleSetting_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoscaleSetting_Spec(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAutoscaleSetting_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoscaleSetting_Spec(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(AutoscaleSettingPropertiesGenerator())
}

func Test_EmailNotification_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EmailNotification via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEmailNotification, EmailNotificationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEmailNotification runs a test to see if a specific instance of EmailNotification round trips to JSON and back losslessly
func RunJSONSerializationTestForEmailNotification(subject EmailNotification) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EmailNotification
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EmailNotification instances for property testing - lazily instantiated by EmailNotificationGenerator()
var emailNotificationGenerator gopter.Gen

// EmailNotificationGenerator returns a generator of EmailNotification instances for property testing.
func EmailNotificationGenerator() gopter.Gen {
	if emailNotificationGenerator != nil {
		return emailNotificationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEmailNotification(generators)
	emailNotificationGenerator = gen.Struct(reflect.TypeOf(EmailNotification{}), generators)

	return emailNotificationGenerator
}

// AddIndependentPropertyGeneratorsForEmailNotification is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEmailNotification(gens map[string]gopter.Gen) {
	gens["CustomEmails"] = gen.SliceOf(gen.AlphaString())
	gens["SendToSubscriptionAdministrator"] = gen.PtrOf(gen.Bool())
	gens["SendToSubscriptionCoAdministrators"] = gen.PtrOf(gen.Bool())
}

func Test_MetricTrigger_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MetricTrigger via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMetricTrigger, MetricTriggerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMetricTrigger runs a test to see if a specific instance of MetricTrigger round trips to JSON and back losslessly
func RunJSONSerializationTestForMetricTrigger(subject MetricTrigger) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MetricTrigger
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MetricTrigger instances for property testing - lazily instantiated by MetricTriggerGenerator()
var metricTriggerGenerator gopter.Gen

// MetricTriggerGenerator returns a generator of MetricTrigger instances for property testing.
// We first initialize metricTriggerGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func MetricTriggerGenerator() gopter.Gen {
	if metricTriggerGenerator != nil {
		return metricTriggerGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricTrigger(generators)
	metricTriggerGenerator = gen.Struct(reflect.TypeOf(MetricTrigger{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricTrigger(generators)
	AddRelatedPropertyGeneratorsForMetricTrigger(generators)
	metricTriggerGenerator = gen.Struct(reflect.TypeOf(MetricTrigger{}), generators)

	return metricTriggerGenerator
}

// AddIndependentPropertyGeneratorsForMetricTrigger is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMetricTrigger(gens map[string]gopter.Gen) {
	gens["DividePerInstance"] = gen.PtrOf(gen.Bool())
	gens["MetricName"] = gen.PtrOf(gen.AlphaString())
	gens["MetricNamespace"] = gen.PtrOf(gen.AlphaString())
	gens["MetricResourceLocation"] = gen.PtrOf(gen.AlphaString())
	gens["MetricResourceUri"] = gen.PtrOf(gen.AlphaString())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		MetricTrigger_Operator_Equals,
		MetricTrigger_Operator_GreaterThan,
		MetricTrigger_Operator_GreaterThanOrEqual,
		MetricTrigger_Operator_LessThan,
		MetricTrigger_Operator_LessThanOrEqual,
		MetricTrigger_Operator_NotEquals))
	gens["Statistic"] = gen.PtrOf(gen.OneConstOf(
		MetricTrigger_Statistic_Average,
		MetricTrigger_Statistic_Count,
		MetricTrigger_Statistic_Max,
		MetricTrigger_Statistic_Min,
		MetricTrigger_Statistic_Sum))
	gens["Threshold"] = gen.PtrOf(gen.Float64())
	gens["TimeAggregation"] = gen.PtrOf(gen.OneConstOf(
		MetricTrigger_TimeAggregation_Average,
		MetricTrigger_TimeAggregation_Count,
		MetricTrigger_TimeAggregation_Last,
		MetricTrigger_TimeAggregation_Maximum,
		MetricTrigger_TimeAggregation_Minimum,
		MetricTrigger_TimeAggregation_Total))
	gens["TimeGrain"] = gen.PtrOf(gen.AlphaString())
	gens["TimeWindow"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForMetricTrigger is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMetricTrigger(gens map[string]gopter.Gen) {
	gens["Dimensions"] = gen.SliceOf(ScaleRuleMetricDimensionGenerator())
}

func Test_PredictiveAutoscalePolicy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PredictiveAutoscalePolicy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPredictiveAutoscalePolicy, PredictiveAutoscalePolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPredictiveAutoscalePolicy runs a test to see if a specific instance of PredictiveAutoscalePolicy round trips to JSON and back losslessly
func RunJSONSerializationTestForPredictiveAutoscalePolicy(subject PredictiveAutoscalePolicy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PredictiveAutoscalePolicy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PredictiveAutoscalePolicy instances for property testing - lazily instantiated by
// PredictiveAutoscalePolicyGenerator()
var predictiveAutoscalePolicyGenerator gopter.Gen

// PredictiveAutoscalePolicyGenerator returns a generator of PredictiveAutoscalePolicy instances for property testing.
func PredictiveAutoscalePolicyGenerator() gopter.Gen {
	if predictiveAutoscalePolicyGenerator != nil {
		return predictiveAutoscalePolicyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPredictiveAutoscalePolicy(generators)
	predictiveAutoscalePolicyGenerator = gen.Struct(reflect.TypeOf(PredictiveAutoscalePolicy{}), generators)

	return predictiveAutoscalePolicyGenerator
}

// AddIndependentPropertyGeneratorsForPredictiveAutoscalePolicy is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPredictiveAutoscalePolicy(gens map[string]gopter.Gen) {
	gens["ScaleLookAheadTime"] = gen.PtrOf(gen.AlphaString())
	gens["ScaleMode"] = gen.PtrOf(gen.OneConstOf(PredictiveAutoscalePolicy_ScaleMode_Disabled, PredictiveAutoscalePolicy_ScaleMode_Enabled, PredictiveAutoscalePolicy_ScaleMode_ForecastOnly))
}

func Test_Recurrence_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Recurrence via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRecurrence, RecurrenceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRecurrence runs a test to see if a specific instance of Recurrence round trips to JSON and back losslessly
func RunJSONSerializationTestForRecurrence(subject Recurrence) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Recurrence
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Recurrence instances for property testing - lazily instantiated by RecurrenceGenerator()
var recurrenceGenerator gopter.Gen

// RecurrenceGenerator returns a generator of Recurrence instances for property testing.
// We first initialize recurrenceGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RecurrenceGenerator() gopter.Gen {
	if recurrenceGenerator != nil {
		return recurrenceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRecurrence(generators)
	recurrenceGenerator = gen.Struct(reflect.TypeOf(Recurrence{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRecurrence(generators)
	AddRelatedPropertyGeneratorsForRecurrence(generators)
	recurrenceGenerator = gen.Struct(reflect.TypeOf(Recurrence{}), generators)

	return recurrenceGenerator
}

// AddIndependentPropertyGeneratorsForRecurrence is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRecurrence(gens map[string]gopter.Gen) {
	gens["Frequency"] = gen.PtrOf(gen.OneConstOf(
		Recurrence_Frequency_Day,
		Recurrence_Frequency_Hour,
		Recurrence_Frequency_Minute,
		Recurrence_Frequency_Month,
		Recurrence_Frequency_None,
		Recurrence_Frequency_Second,
		Recurrence_Frequency_Week,
		Recurrence_Frequency_Year))
}

// AddRelatedPropertyGeneratorsForRecurrence is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRecurrence(gens map[string]gopter.Gen) {
	gens["Schedule"] = gen.PtrOf(RecurrentScheduleGenerator())
}

func Test_RecurrentSchedule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RecurrentSchedule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRecurrentSchedule, RecurrentScheduleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRecurrentSchedule runs a test to see if a specific instance of RecurrentSchedule round trips to JSON and back losslessly
func RunJSONSerializationTestForRecurrentSchedule(subject RecurrentSchedule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RecurrentSchedule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RecurrentSchedule instances for property testing - lazily instantiated by RecurrentScheduleGenerator()
var recurrentScheduleGenerator gopter.Gen

// RecurrentScheduleGenerator returns a generator of RecurrentSchedule instances for property testing.
func RecurrentScheduleGenerator() gopter.Gen {
	if recurrentScheduleGenerator != nil {
		return recurrentScheduleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRecurrentSchedule(generators)
	recurrentScheduleGenerator = gen.Struct(reflect.TypeOf(RecurrentSchedule{}), generators)

	return recurrentScheduleGenerator
}

// AddIndependentPropertyGeneratorsForRecurrentSchedule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRecurrentSchedule(gens map[string]gopter.Gen) {
	gens["Days"] = gen.SliceOf(gen.AlphaString())
	gens["Hours"] = gen.SliceOf(gen.Int())
	gens["Minutes"] = gen.SliceOf(gen.Int())
	gens["TimeZone"] = gen.PtrOf(gen.AlphaString())
}

func Test_ScaleAction_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScaleAction via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScaleAction, ScaleActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScaleAction runs a test to see if a specific instance of ScaleAction round trips to JSON and back losslessly
func RunJSONSerializationTestForScaleAction(subject ScaleAction) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScaleAction
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScaleAction instances for property testing - lazily instantiated by ScaleActionGenerator()
var scaleActionGenerator gopter.Gen

// ScaleActionGenerator returns a generator of ScaleAction instances for property testing.
func ScaleActionGenerator() gopter.Gen {
	if scaleActionGenerator != nil {
		return scaleActionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScaleAction(generators)
	scaleActionGenerator = gen.Struct(reflect.TypeOf(ScaleAction{}), generators)

	return scaleActionGenerator
}

// AddIndependentPropertyGeneratorsForScaleAction is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScaleAction(gens map[string]gopter.Gen) {
	gens["Cooldown"] = gen.PtrOf(gen.AlphaString())
	gens["Direction"] = gen.PtrOf(gen.OneConstOf(ScaleAction_Direction_Decrease, ScaleAction_Direction_Increase, ScaleAction_Direction_None))
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ScaleAction_Type_ChangeCount,
		ScaleAction_Type_ExactCount,
		ScaleAction_Type_PercentChangeCount,
		ScaleAction_Type_ServiceAllowedNextValue))
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_ScaleCapacity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScaleCapacity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScaleCapacity, ScaleCapacityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScaleCapacity runs a test to see if a specific instance of ScaleCapacity round trips to JSON and back losslessly
func RunJSONSerializationTestForScaleCapacity(subject ScaleCapacity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScaleCapacity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScaleCapacity instances for property testing - lazily instantiated by ScaleCapacityGenerator()
var scaleCapacityGenerator gopter.Gen

// ScaleCapacityGenerator returns a generator of ScaleCapacity instances for property testing.
func ScaleCapacityGenerator() gopter.Gen {
	if scaleCapacityGenerator != nil {
		return scaleCapacityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScaleCapacity(generators)
	scaleCapacityGenerator = gen.Struct(reflect.TypeOf(ScaleCapacity{}), generators)

	return scaleCapacityGenerator
}

// AddIndependentPropertyGeneratorsForScaleCapacity is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScaleCapacity(gens map[string]gopter.Gen) {
	gens["Default"] = gen.PtrOf(gen.AlphaString())
	gens["Maximum"] = gen.PtrOf(gen.AlphaString())
	gens["Minimum"] = gen.PtrOf(gen.AlphaString())
}

func Test_ScaleRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScaleRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScaleRule, ScaleRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScaleRule runs a test to see if a specific instance of ScaleRule round trips to JSON and back losslessly
func RunJSONSerializationTestForScaleRule(subject ScaleRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScaleRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScaleRule instances for property testing - lazily instantiated by ScaleRuleGenerator()
var scaleRuleGenerator gopter.Gen

// ScaleRuleGenerator returns a generator of ScaleRule instances for property testing.
func ScaleRuleGenerator() gopter.Gen {
	if scaleRuleGenerator != nil {
		return scaleRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForScaleRule(generators)
	scaleRuleGenerator = gen.Struct(reflect.TypeOf(ScaleRule{}), generators)

	return scaleRuleGenerator
}

// AddRelatedPropertyGeneratorsForScaleRule is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForScaleRule(gens map[string]gopter.Gen) {
	gens["MetricTrigger"] = gen.PtrOf(MetricTriggerGenerator())
	gens["ScaleAction"] = gen.PtrOf(ScaleActionGenerator())
}

func Test_ScaleRuleMetricDimension_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScaleRuleMetricDimension via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScaleRuleMetricDimension, ScaleRuleMetricDimensionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScaleRuleMetricDimension runs a test to see if a specific instance of ScaleRuleMetricDimension round trips to JSON and back losslessly
func RunJSONSerializationTestForScaleRuleMetricDimension(subject ScaleRuleMetricDimension) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScaleRuleMetricDimension
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScaleRuleMetricDimension instances for property testing - lazily instantiated by
// ScaleRuleMetricDimensionGenerator()
var scaleRuleMetricDimensionGenerator gopter.Gen

// ScaleRuleMetricDimensionGenerator returns a generator of ScaleRuleMetricDimension instances for property testing.
func ScaleRuleMetricDimensionGenerator() gopter.Gen {
	if scaleRuleMetricDimensionGenerator != nil {
		return scaleRuleMetricDimensionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScaleRuleMetricDimension(generators)
	scaleRuleMetricDimensionGenerator = gen.Struct(reflect.TypeOf(ScaleRuleMetricDimension{}), generators)

	return scaleRuleMetricDimensionGenerator
}

// AddIndependentPropertyGeneratorsForScaleRuleMetricDimension is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScaleRuleMetricDimension(gens map[string]gopter.Gen) {
	gens["DimensionName"] = gen.PtrOf(gen.AlphaString())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(ScaleRuleMetricDimension_Operator_Equals, ScaleRuleMetricDimension_Operator_NotEquals))
	gens["Values"] = gen.SliceOf(gen.AlphaString())
}

func Test_TimeWindow_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TimeWindow via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTimeWindow, TimeWindowGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTimeWindow runs a test to see if a specific instance of TimeWindow round trips to JSON and back losslessly
func RunJSONSerializationTestForTimeWindow(subject TimeWindow) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TimeWindow
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TimeWindow instances for property testing - lazily instantiated by TimeWindowGenerator()
var timeWindowGenerator gopter.Gen

// TimeWindowGenerator returns a generator of TimeWindow instances for property testing.
func TimeWindowGenerator() gopter.Gen {
	if timeWindowGenerator != nil {
		return timeWindowGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTimeWindow(generators)
	timeWindowGenerator = gen.Struct(reflect.TypeOf(TimeWindow{}), generators)

	return timeWindowGenerator
}

// AddIndependentPropertyGeneratorsForTimeWindow is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTimeWindow(gens map[string]gopter.Gen) {
	gens["End"] = gen.PtrOf(gen.AlphaString())
	gens["Start"] = gen.PtrOf(gen.AlphaString())
	gens["TimeZone"] = gen.PtrOf(gen.AlphaString())
}

func Test_WebhookNotification_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebhookNotification via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebhookNotification, WebhookNotificationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebhookNotification runs a test to see if a specific instance of WebhookNotification round trips to JSON and back losslessly
func RunJSONSerializationTestForWebhookNotification(subject WebhookNotification) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebhookNotification
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebhookNotification instances for property testing - lazily instantiated by
// WebhookNotificationGenerator()
var webhookNotificationGenerator gopter.Gen

// WebhookNotificationGenerator returns a generator of WebhookNotification instances for property testing.
func WebhookNotificationGenerator() gopter.Gen {
	if webhookNotificationGenerator != nil {
		return webhookNotificationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebhookNotification(generators)
	webhookNotificationGenerator = gen.Struct(reflect.TypeOf(WebhookNotification{}), generators)

	return webhookNotificationGenerator
}

// AddIndependentPropertyGeneratorsForWebhookNotification is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebhookNotification(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["ServiceUri"] = gen.PtrOf(gen.AlphaString())
}
