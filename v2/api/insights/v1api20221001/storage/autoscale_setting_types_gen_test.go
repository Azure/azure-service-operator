// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package storage

import (
	"encoding/json"
	storage "github.com/Azure/azure-service-operator/v2/api/insights/v1api20230311/storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_AutoscaleNotification_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoscaleNotification via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoscaleNotification, AutoscaleNotificationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoscaleNotification runs a test to see if a specific instance of AutoscaleNotification round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoscaleNotification(subject AutoscaleNotification) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoscaleNotification
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoscaleNotification instances for property testing - lazily instantiated by
// AutoscaleNotificationGenerator()
var autoscaleNotificationGenerator gopter.Gen

// AutoscaleNotificationGenerator returns a generator of AutoscaleNotification instances for property testing.
// We first initialize autoscaleNotificationGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AutoscaleNotificationGenerator() gopter.Gen {
	if autoscaleNotificationGenerator != nil {
		return autoscaleNotificationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscaleNotification(generators)
	autoscaleNotificationGenerator = gen.Struct(reflect.TypeOf(AutoscaleNotification{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscaleNotification(generators)
	AddRelatedPropertyGeneratorsForAutoscaleNotification(generators)
	autoscaleNotificationGenerator = gen.Struct(reflect.TypeOf(AutoscaleNotification{}), generators)

	return autoscaleNotificationGenerator
}

// AddIndependentPropertyGeneratorsForAutoscaleNotification is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoscaleNotification(gens map[string]gopter.Gen) {
	gens["Operation"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAutoscaleNotification is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoscaleNotification(gens map[string]gopter.Gen) {
	gens["Email"] = gen.PtrOf(EmailNotificationGenerator())
	gens["Webhooks"] = gen.SliceOf(WebhookNotificationGenerator())
}

func Test_AutoscaleNotification_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoscaleNotification_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoscaleNotification_STATUS, AutoscaleNotification_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoscaleNotification_STATUS runs a test to see if a specific instance of AutoscaleNotification_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoscaleNotification_STATUS(subject AutoscaleNotification_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoscaleNotification_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoscaleNotification_STATUS instances for property testing - lazily instantiated by
// AutoscaleNotification_STATUSGenerator()
var autoscaleNotification_STATUSGenerator gopter.Gen

// AutoscaleNotification_STATUSGenerator returns a generator of AutoscaleNotification_STATUS instances for property testing.
// We first initialize autoscaleNotification_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AutoscaleNotification_STATUSGenerator() gopter.Gen {
	if autoscaleNotification_STATUSGenerator != nil {
		return autoscaleNotification_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscaleNotification_STATUS(generators)
	autoscaleNotification_STATUSGenerator = gen.Struct(reflect.TypeOf(AutoscaleNotification_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscaleNotification_STATUS(generators)
	AddRelatedPropertyGeneratorsForAutoscaleNotification_STATUS(generators)
	autoscaleNotification_STATUSGenerator = gen.Struct(reflect.TypeOf(AutoscaleNotification_STATUS{}), generators)

	return autoscaleNotification_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAutoscaleNotification_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoscaleNotification_STATUS(gens map[string]gopter.Gen) {
	gens["Operation"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAutoscaleNotification_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoscaleNotification_STATUS(gens map[string]gopter.Gen) {
	gens["Email"] = gen.PtrOf(EmailNotification_STATUSGenerator())
	gens["Webhooks"] = gen.SliceOf(WebhookNotification_STATUSGenerator())
}

func Test_AutoscaleProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoscaleProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoscaleProfile, AutoscaleProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoscaleProfile runs a test to see if a specific instance of AutoscaleProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoscaleProfile(subject AutoscaleProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoscaleProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoscaleProfile instances for property testing - lazily instantiated by AutoscaleProfileGenerator()
var autoscaleProfileGenerator gopter.Gen

// AutoscaleProfileGenerator returns a generator of AutoscaleProfile instances for property testing.
// We first initialize autoscaleProfileGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AutoscaleProfileGenerator() gopter.Gen {
	if autoscaleProfileGenerator != nil {
		return autoscaleProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscaleProfile(generators)
	autoscaleProfileGenerator = gen.Struct(reflect.TypeOf(AutoscaleProfile{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscaleProfile(generators)
	AddRelatedPropertyGeneratorsForAutoscaleProfile(generators)
	autoscaleProfileGenerator = gen.Struct(reflect.TypeOf(AutoscaleProfile{}), generators)

	return autoscaleProfileGenerator
}

// AddIndependentPropertyGeneratorsForAutoscaleProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoscaleProfile(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAutoscaleProfile is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoscaleProfile(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(ScaleCapacityGenerator())
	gens["FixedDate"] = gen.PtrOf(TimeWindowGenerator())
	gens["Recurrence"] = gen.PtrOf(RecurrenceGenerator())
	gens["Rules"] = gen.SliceOf(ScaleRuleGenerator())
}

func Test_AutoscaleProfile_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoscaleProfile_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoscaleProfile_STATUS, AutoscaleProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoscaleProfile_STATUS runs a test to see if a specific instance of AutoscaleProfile_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoscaleProfile_STATUS(subject AutoscaleProfile_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoscaleProfile_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoscaleProfile_STATUS instances for property testing - lazily instantiated by
// AutoscaleProfile_STATUSGenerator()
var autoscaleProfile_STATUSGenerator gopter.Gen

// AutoscaleProfile_STATUSGenerator returns a generator of AutoscaleProfile_STATUS instances for property testing.
// We first initialize autoscaleProfile_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AutoscaleProfile_STATUSGenerator() gopter.Gen {
	if autoscaleProfile_STATUSGenerator != nil {
		return autoscaleProfile_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscaleProfile_STATUS(generators)
	autoscaleProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(AutoscaleProfile_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscaleProfile_STATUS(generators)
	AddRelatedPropertyGeneratorsForAutoscaleProfile_STATUS(generators)
	autoscaleProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(AutoscaleProfile_STATUS{}), generators)

	return autoscaleProfile_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAutoscaleProfile_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoscaleProfile_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAutoscaleProfile_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoscaleProfile_STATUS(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(ScaleCapacity_STATUSGenerator())
	gens["FixedDate"] = gen.PtrOf(TimeWindow_STATUSGenerator())
	gens["Recurrence"] = gen.PtrOf(Recurrence_STATUSGenerator())
	gens["Rules"] = gen.SliceOf(ScaleRule_STATUSGenerator())
}

func Test_AutoscaleSetting_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoscaleSetting via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoscaleSetting, AutoscaleSettingGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoscaleSetting runs a test to see if a specific instance of AutoscaleSetting round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoscaleSetting(subject AutoscaleSetting) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoscaleSetting
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoscaleSetting instances for property testing - lazily instantiated by AutoscaleSettingGenerator()
var autoscaleSettingGenerator gopter.Gen

// AutoscaleSettingGenerator returns a generator of AutoscaleSetting instances for property testing.
func AutoscaleSettingGenerator() gopter.Gen {
	if autoscaleSettingGenerator != nil {
		return autoscaleSettingGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForAutoscaleSetting(generators)
	autoscaleSettingGenerator = gen.Struct(reflect.TypeOf(AutoscaleSetting{}), generators)

	return autoscaleSettingGenerator
}

// AddRelatedPropertyGeneratorsForAutoscaleSetting is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoscaleSetting(gens map[string]gopter.Gen) {
	gens["Spec"] = AutoscaleSetting_SpecGenerator()
	gens["Status"] = Autoscalesetting_STATUSGenerator()
}

func Test_AutoscaleSettingOperatorSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoscaleSettingOperatorSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoscaleSettingOperatorSpec, AutoscaleSettingOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoscaleSettingOperatorSpec runs a test to see if a specific instance of AutoscaleSettingOperatorSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoscaleSettingOperatorSpec(subject AutoscaleSettingOperatorSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoscaleSettingOperatorSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoscaleSettingOperatorSpec instances for property testing - lazily instantiated by
// AutoscaleSettingOperatorSpecGenerator()
var autoscaleSettingOperatorSpecGenerator gopter.Gen

// AutoscaleSettingOperatorSpecGenerator returns a generator of AutoscaleSettingOperatorSpec instances for property testing.
func AutoscaleSettingOperatorSpecGenerator() gopter.Gen {
	if autoscaleSettingOperatorSpecGenerator != nil {
		return autoscaleSettingOperatorSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	autoscaleSettingOperatorSpecGenerator = gen.Struct(reflect.TypeOf(AutoscaleSettingOperatorSpec{}), generators)

	return autoscaleSettingOperatorSpecGenerator
}

func Test_AutoscaleSetting_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoscaleSetting_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoscaleSetting_Spec, AutoscaleSetting_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoscaleSetting_Spec runs a test to see if a specific instance of AutoscaleSetting_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoscaleSetting_Spec(subject AutoscaleSetting_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoscaleSetting_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoscaleSetting_Spec instances for property testing - lazily instantiated by
// AutoscaleSetting_SpecGenerator()
var autoscaleSetting_SpecGenerator gopter.Gen

// AutoscaleSetting_SpecGenerator returns a generator of AutoscaleSetting_Spec instances for property testing.
// We first initialize autoscaleSetting_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AutoscaleSetting_SpecGenerator() gopter.Gen {
	if autoscaleSetting_SpecGenerator != nil {
		return autoscaleSetting_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscaleSetting_Spec(generators)
	autoscaleSetting_SpecGenerator = gen.Struct(reflect.TypeOf(AutoscaleSetting_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscaleSetting_Spec(generators)
	AddRelatedPropertyGeneratorsForAutoscaleSetting_Spec(generators)
	autoscaleSetting_SpecGenerator = gen.Struct(reflect.TypeOf(AutoscaleSetting_Spec{}), generators)

	return autoscaleSetting_SpecGenerator
}

// AddIndependentPropertyGeneratorsForAutoscaleSetting_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoscaleSetting_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["OriginalVersion"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["TargetResourceLocation"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAutoscaleSetting_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoscaleSetting_Spec(gens map[string]gopter.Gen) {
	gens["Notifications"] = gen.SliceOf(AutoscaleNotificationGenerator())
	gens["OperatorSpec"] = gen.PtrOf(AutoscaleSettingOperatorSpecGenerator())
	gens["PredictiveAutoscalePolicy"] = gen.PtrOf(PredictiveAutoscalePolicyGenerator())
	gens["Profiles"] = gen.SliceOf(AutoscaleProfileGenerator())
}

func Test_Autoscalesetting_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Autoscalesetting_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoscalesetting_STATUS, Autoscalesetting_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoscalesetting_STATUS runs a test to see if a specific instance of Autoscalesetting_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoscalesetting_STATUS(subject Autoscalesetting_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Autoscalesetting_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Autoscalesetting_STATUS instances for property testing - lazily instantiated by
// Autoscalesetting_STATUSGenerator()
var autoscalesetting_STATUSGenerator gopter.Gen

// Autoscalesetting_STATUSGenerator returns a generator of Autoscalesetting_STATUS instances for property testing.
// We first initialize autoscalesetting_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Autoscalesetting_STATUSGenerator() gopter.Gen {
	if autoscalesetting_STATUSGenerator != nil {
		return autoscalesetting_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscalesetting_STATUS(generators)
	autoscalesetting_STATUSGenerator = gen.Struct(reflect.TypeOf(Autoscalesetting_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscalesetting_STATUS(generators)
	AddRelatedPropertyGeneratorsForAutoscalesetting_STATUS(generators)
	autoscalesetting_STATUSGenerator = gen.Struct(reflect.TypeOf(Autoscalesetting_STATUS{}), generators)

	return autoscalesetting_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAutoscalesetting_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoscalesetting_STATUS(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PropertiesName"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["TargetResourceLocation"] = gen.PtrOf(gen.AlphaString())
	gens["TargetResourceUri"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAutoscalesetting_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAutoscalesetting_STATUS(gens map[string]gopter.Gen) {
	gens["Notifications"] = gen.SliceOf(AutoscaleNotification_STATUSGenerator())
	gens["PredictiveAutoscalePolicy"] = gen.PtrOf(PredictiveAutoscalePolicy_STATUSGenerator())
	gens["Profiles"] = gen.SliceOf(AutoscaleProfile_STATUSGenerator())
	gens["SystemData"] = gen.PtrOf(SystemData_STATUSGenerator())
}

func Test_EmailNotification_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EmailNotification via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEmailNotification, EmailNotificationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEmailNotification runs a test to see if a specific instance of EmailNotification round trips to JSON and back losslessly
func RunJSONSerializationTestForEmailNotification(subject EmailNotification) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EmailNotification
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EmailNotification instances for property testing - lazily instantiated by EmailNotificationGenerator()
var emailNotificationGenerator gopter.Gen

// EmailNotificationGenerator returns a generator of EmailNotification instances for property testing.
func EmailNotificationGenerator() gopter.Gen {
	if emailNotificationGenerator != nil {
		return emailNotificationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEmailNotification(generators)
	emailNotificationGenerator = gen.Struct(reflect.TypeOf(EmailNotification{}), generators)

	return emailNotificationGenerator
}

// AddIndependentPropertyGeneratorsForEmailNotification is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEmailNotification(gens map[string]gopter.Gen) {
	gens["CustomEmails"] = gen.SliceOf(gen.AlphaString())
	gens["SendToSubscriptionAdministrator"] = gen.PtrOf(gen.Bool())
	gens["SendToSubscriptionCoAdministrators"] = gen.PtrOf(gen.Bool())
}

func Test_EmailNotification_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EmailNotification_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEmailNotification_STATUS, EmailNotification_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEmailNotification_STATUS runs a test to see if a specific instance of EmailNotification_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEmailNotification_STATUS(subject EmailNotification_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EmailNotification_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EmailNotification_STATUS instances for property testing - lazily instantiated by
// EmailNotification_STATUSGenerator()
var emailNotification_STATUSGenerator gopter.Gen

// EmailNotification_STATUSGenerator returns a generator of EmailNotification_STATUS instances for property testing.
func EmailNotification_STATUSGenerator() gopter.Gen {
	if emailNotification_STATUSGenerator != nil {
		return emailNotification_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEmailNotification_STATUS(generators)
	emailNotification_STATUSGenerator = gen.Struct(reflect.TypeOf(EmailNotification_STATUS{}), generators)

	return emailNotification_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForEmailNotification_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEmailNotification_STATUS(gens map[string]gopter.Gen) {
	gens["CustomEmails"] = gen.SliceOf(gen.AlphaString())
	gens["SendToSubscriptionAdministrator"] = gen.PtrOf(gen.Bool())
	gens["SendToSubscriptionCoAdministrators"] = gen.PtrOf(gen.Bool())
}

func Test_MetricTrigger_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MetricTrigger via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMetricTrigger, MetricTriggerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMetricTrigger runs a test to see if a specific instance of MetricTrigger round trips to JSON and back losslessly
func RunJSONSerializationTestForMetricTrigger(subject MetricTrigger) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MetricTrigger
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MetricTrigger instances for property testing - lazily instantiated by MetricTriggerGenerator()
var metricTriggerGenerator gopter.Gen

// MetricTriggerGenerator returns a generator of MetricTrigger instances for property testing.
// We first initialize metricTriggerGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func MetricTriggerGenerator() gopter.Gen {
	if metricTriggerGenerator != nil {
		return metricTriggerGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricTrigger(generators)
	metricTriggerGenerator = gen.Struct(reflect.TypeOf(MetricTrigger{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricTrigger(generators)
	AddRelatedPropertyGeneratorsForMetricTrigger(generators)
	metricTriggerGenerator = gen.Struct(reflect.TypeOf(MetricTrigger{}), generators)

	return metricTriggerGenerator
}

// AddIndependentPropertyGeneratorsForMetricTrigger is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMetricTrigger(gens map[string]gopter.Gen) {
	gens["DividePerInstance"] = gen.PtrOf(gen.Bool())
	gens["MetricName"] = gen.PtrOf(gen.AlphaString())
	gens["MetricNamespace"] = gen.PtrOf(gen.AlphaString())
	gens["MetricResourceLocation"] = gen.PtrOf(gen.AlphaString())
	gens["Operator"] = gen.PtrOf(gen.AlphaString())
	gens["Statistic"] = gen.PtrOf(gen.AlphaString())
	gens["Threshold"] = gen.PtrOf(gen.Float64())
	gens["TimeAggregation"] = gen.PtrOf(gen.AlphaString())
	gens["TimeGrain"] = gen.PtrOf(gen.AlphaString())
	gens["TimeWindow"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForMetricTrigger is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMetricTrigger(gens map[string]gopter.Gen) {
	gens["Dimensions"] = gen.SliceOf(ScaleRuleMetricDimensionGenerator())
}

func Test_MetricTrigger_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MetricTrigger_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMetricTrigger_STATUS, MetricTrigger_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMetricTrigger_STATUS runs a test to see if a specific instance of MetricTrigger_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForMetricTrigger_STATUS(subject MetricTrigger_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MetricTrigger_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MetricTrigger_STATUS instances for property testing - lazily instantiated by
// MetricTrigger_STATUSGenerator()
var metricTrigger_STATUSGenerator gopter.Gen

// MetricTrigger_STATUSGenerator returns a generator of MetricTrigger_STATUS instances for property testing.
// We first initialize metricTrigger_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func MetricTrigger_STATUSGenerator() gopter.Gen {
	if metricTrigger_STATUSGenerator != nil {
		return metricTrigger_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricTrigger_STATUS(generators)
	metricTrigger_STATUSGenerator = gen.Struct(reflect.TypeOf(MetricTrigger_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMetricTrigger_STATUS(generators)
	AddRelatedPropertyGeneratorsForMetricTrigger_STATUS(generators)
	metricTrigger_STATUSGenerator = gen.Struct(reflect.TypeOf(MetricTrigger_STATUS{}), generators)

	return metricTrigger_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForMetricTrigger_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMetricTrigger_STATUS(gens map[string]gopter.Gen) {
	gens["DividePerInstance"] = gen.PtrOf(gen.Bool())
	gens["MetricName"] = gen.PtrOf(gen.AlphaString())
	gens["MetricNamespace"] = gen.PtrOf(gen.AlphaString())
	gens["MetricResourceLocation"] = gen.PtrOf(gen.AlphaString())
	gens["MetricResourceUri"] = gen.PtrOf(gen.AlphaString())
	gens["Operator"] = gen.PtrOf(gen.AlphaString())
	gens["Statistic"] = gen.PtrOf(gen.AlphaString())
	gens["Threshold"] = gen.PtrOf(gen.Float64())
	gens["TimeAggregation"] = gen.PtrOf(gen.AlphaString())
	gens["TimeGrain"] = gen.PtrOf(gen.AlphaString())
	gens["TimeWindow"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForMetricTrigger_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMetricTrigger_STATUS(gens map[string]gopter.Gen) {
	gens["Dimensions"] = gen.SliceOf(ScaleRuleMetricDimension_STATUSGenerator())
}

func Test_PredictiveAutoscalePolicy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PredictiveAutoscalePolicy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPredictiveAutoscalePolicy, PredictiveAutoscalePolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPredictiveAutoscalePolicy runs a test to see if a specific instance of PredictiveAutoscalePolicy round trips to JSON and back losslessly
func RunJSONSerializationTestForPredictiveAutoscalePolicy(subject PredictiveAutoscalePolicy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PredictiveAutoscalePolicy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PredictiveAutoscalePolicy instances for property testing - lazily instantiated by
// PredictiveAutoscalePolicyGenerator()
var predictiveAutoscalePolicyGenerator gopter.Gen

// PredictiveAutoscalePolicyGenerator returns a generator of PredictiveAutoscalePolicy instances for property testing.
func PredictiveAutoscalePolicyGenerator() gopter.Gen {
	if predictiveAutoscalePolicyGenerator != nil {
		return predictiveAutoscalePolicyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPredictiveAutoscalePolicy(generators)
	predictiveAutoscalePolicyGenerator = gen.Struct(reflect.TypeOf(PredictiveAutoscalePolicy{}), generators)

	return predictiveAutoscalePolicyGenerator
}

// AddIndependentPropertyGeneratorsForPredictiveAutoscalePolicy is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPredictiveAutoscalePolicy(gens map[string]gopter.Gen) {
	gens["ScaleLookAheadTime"] = gen.PtrOf(gen.AlphaString())
	gens["ScaleMode"] = gen.PtrOf(gen.AlphaString())
}

func Test_PredictiveAutoscalePolicy_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PredictiveAutoscalePolicy_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPredictiveAutoscalePolicy_STATUS, PredictiveAutoscalePolicy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPredictiveAutoscalePolicy_STATUS runs a test to see if a specific instance of PredictiveAutoscalePolicy_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPredictiveAutoscalePolicy_STATUS(subject PredictiveAutoscalePolicy_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PredictiveAutoscalePolicy_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PredictiveAutoscalePolicy_STATUS instances for property testing - lazily instantiated by
// PredictiveAutoscalePolicy_STATUSGenerator()
var predictiveAutoscalePolicy_STATUSGenerator gopter.Gen

// PredictiveAutoscalePolicy_STATUSGenerator returns a generator of PredictiveAutoscalePolicy_STATUS instances for property testing.
func PredictiveAutoscalePolicy_STATUSGenerator() gopter.Gen {
	if predictiveAutoscalePolicy_STATUSGenerator != nil {
		return predictiveAutoscalePolicy_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPredictiveAutoscalePolicy_STATUS(generators)
	predictiveAutoscalePolicy_STATUSGenerator = gen.Struct(reflect.TypeOf(PredictiveAutoscalePolicy_STATUS{}), generators)

	return predictiveAutoscalePolicy_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForPredictiveAutoscalePolicy_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPredictiveAutoscalePolicy_STATUS(gens map[string]gopter.Gen) {
	gens["ScaleLookAheadTime"] = gen.PtrOf(gen.AlphaString())
	gens["ScaleMode"] = gen.PtrOf(gen.AlphaString())
}

func Test_Recurrence_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Recurrence via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRecurrence, RecurrenceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRecurrence runs a test to see if a specific instance of Recurrence round trips to JSON and back losslessly
func RunJSONSerializationTestForRecurrence(subject Recurrence) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Recurrence
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Recurrence instances for property testing - lazily instantiated by RecurrenceGenerator()
var recurrenceGenerator gopter.Gen

// RecurrenceGenerator returns a generator of Recurrence instances for property testing.
// We first initialize recurrenceGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RecurrenceGenerator() gopter.Gen {
	if recurrenceGenerator != nil {
		return recurrenceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRecurrence(generators)
	recurrenceGenerator = gen.Struct(reflect.TypeOf(Recurrence{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRecurrence(generators)
	AddRelatedPropertyGeneratorsForRecurrence(generators)
	recurrenceGenerator = gen.Struct(reflect.TypeOf(Recurrence{}), generators)

	return recurrenceGenerator
}

// AddIndependentPropertyGeneratorsForRecurrence is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRecurrence(gens map[string]gopter.Gen) {
	gens["Frequency"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForRecurrence is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRecurrence(gens map[string]gopter.Gen) {
	gens["Schedule"] = gen.PtrOf(RecurrentScheduleGenerator())
}

func Test_Recurrence_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Recurrence_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRecurrence_STATUS, Recurrence_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRecurrence_STATUS runs a test to see if a specific instance of Recurrence_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRecurrence_STATUS(subject Recurrence_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Recurrence_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Recurrence_STATUS instances for property testing - lazily instantiated by Recurrence_STATUSGenerator()
var recurrence_STATUSGenerator gopter.Gen

// Recurrence_STATUSGenerator returns a generator of Recurrence_STATUS instances for property testing.
// We first initialize recurrence_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Recurrence_STATUSGenerator() gopter.Gen {
	if recurrence_STATUSGenerator != nil {
		return recurrence_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRecurrence_STATUS(generators)
	recurrence_STATUSGenerator = gen.Struct(reflect.TypeOf(Recurrence_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRecurrence_STATUS(generators)
	AddRelatedPropertyGeneratorsForRecurrence_STATUS(generators)
	recurrence_STATUSGenerator = gen.Struct(reflect.TypeOf(Recurrence_STATUS{}), generators)

	return recurrence_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForRecurrence_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRecurrence_STATUS(gens map[string]gopter.Gen) {
	gens["Frequency"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForRecurrence_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRecurrence_STATUS(gens map[string]gopter.Gen) {
	gens["Schedule"] = gen.PtrOf(RecurrentSchedule_STATUSGenerator())
}

func Test_RecurrentSchedule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RecurrentSchedule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRecurrentSchedule, RecurrentScheduleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRecurrentSchedule runs a test to see if a specific instance of RecurrentSchedule round trips to JSON and back losslessly
func RunJSONSerializationTestForRecurrentSchedule(subject RecurrentSchedule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RecurrentSchedule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RecurrentSchedule instances for property testing - lazily instantiated by RecurrentScheduleGenerator()
var recurrentScheduleGenerator gopter.Gen

// RecurrentScheduleGenerator returns a generator of RecurrentSchedule instances for property testing.
func RecurrentScheduleGenerator() gopter.Gen {
	if recurrentScheduleGenerator != nil {
		return recurrentScheduleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRecurrentSchedule(generators)
	recurrentScheduleGenerator = gen.Struct(reflect.TypeOf(RecurrentSchedule{}), generators)

	return recurrentScheduleGenerator
}

// AddIndependentPropertyGeneratorsForRecurrentSchedule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRecurrentSchedule(gens map[string]gopter.Gen) {
	gens["Days"] = gen.SliceOf(gen.AlphaString())
	gens["Hours"] = gen.SliceOf(gen.Int())
	gens["Minutes"] = gen.SliceOf(gen.Int())
	gens["TimeZone"] = gen.PtrOf(gen.AlphaString())
}

func Test_RecurrentSchedule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RecurrentSchedule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRecurrentSchedule_STATUS, RecurrentSchedule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRecurrentSchedule_STATUS runs a test to see if a specific instance of RecurrentSchedule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRecurrentSchedule_STATUS(subject RecurrentSchedule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RecurrentSchedule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RecurrentSchedule_STATUS instances for property testing - lazily instantiated by
// RecurrentSchedule_STATUSGenerator()
var recurrentSchedule_STATUSGenerator gopter.Gen

// RecurrentSchedule_STATUSGenerator returns a generator of RecurrentSchedule_STATUS instances for property testing.
func RecurrentSchedule_STATUSGenerator() gopter.Gen {
	if recurrentSchedule_STATUSGenerator != nil {
		return recurrentSchedule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRecurrentSchedule_STATUS(generators)
	recurrentSchedule_STATUSGenerator = gen.Struct(reflect.TypeOf(RecurrentSchedule_STATUS{}), generators)

	return recurrentSchedule_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForRecurrentSchedule_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRecurrentSchedule_STATUS(gens map[string]gopter.Gen) {
	gens["Days"] = gen.SliceOf(gen.AlphaString())
	gens["Hours"] = gen.SliceOf(gen.Int())
	gens["Minutes"] = gen.SliceOf(gen.Int())
	gens["TimeZone"] = gen.PtrOf(gen.AlphaString())
}

func Test_ScaleAction_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScaleAction via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScaleAction, ScaleActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScaleAction runs a test to see if a specific instance of ScaleAction round trips to JSON and back losslessly
func RunJSONSerializationTestForScaleAction(subject ScaleAction) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScaleAction
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScaleAction instances for property testing - lazily instantiated by ScaleActionGenerator()
var scaleActionGenerator gopter.Gen

// ScaleActionGenerator returns a generator of ScaleAction instances for property testing.
func ScaleActionGenerator() gopter.Gen {
	if scaleActionGenerator != nil {
		return scaleActionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScaleAction(generators)
	scaleActionGenerator = gen.Struct(reflect.TypeOf(ScaleAction{}), generators)

	return scaleActionGenerator
}

// AddIndependentPropertyGeneratorsForScaleAction is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScaleAction(gens map[string]gopter.Gen) {
	gens["Cooldown"] = gen.PtrOf(gen.AlphaString())
	gens["Direction"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_ScaleAction_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScaleAction_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScaleAction_STATUS, ScaleAction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScaleAction_STATUS runs a test to see if a specific instance of ScaleAction_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForScaleAction_STATUS(subject ScaleAction_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScaleAction_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScaleAction_STATUS instances for property testing - lazily instantiated by ScaleAction_STATUSGenerator()
var scaleAction_STATUSGenerator gopter.Gen

// ScaleAction_STATUSGenerator returns a generator of ScaleAction_STATUS instances for property testing.
func ScaleAction_STATUSGenerator() gopter.Gen {
	if scaleAction_STATUSGenerator != nil {
		return scaleAction_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScaleAction_STATUS(generators)
	scaleAction_STATUSGenerator = gen.Struct(reflect.TypeOf(ScaleAction_STATUS{}), generators)

	return scaleAction_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForScaleAction_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScaleAction_STATUS(gens map[string]gopter.Gen) {
	gens["Cooldown"] = gen.PtrOf(gen.AlphaString())
	gens["Direction"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_ScaleCapacity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScaleCapacity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScaleCapacity, ScaleCapacityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScaleCapacity runs a test to see if a specific instance of ScaleCapacity round trips to JSON and back losslessly
func RunJSONSerializationTestForScaleCapacity(subject ScaleCapacity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScaleCapacity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScaleCapacity instances for property testing - lazily instantiated by ScaleCapacityGenerator()
var scaleCapacityGenerator gopter.Gen

// ScaleCapacityGenerator returns a generator of ScaleCapacity instances for property testing.
func ScaleCapacityGenerator() gopter.Gen {
	if scaleCapacityGenerator != nil {
		return scaleCapacityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScaleCapacity(generators)
	scaleCapacityGenerator = gen.Struct(reflect.TypeOf(ScaleCapacity{}), generators)

	return scaleCapacityGenerator
}

// AddIndependentPropertyGeneratorsForScaleCapacity is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScaleCapacity(gens map[string]gopter.Gen) {
	gens["Default"] = gen.PtrOf(gen.AlphaString())
	gens["Maximum"] = gen.PtrOf(gen.AlphaString())
	gens["Minimum"] = gen.PtrOf(gen.AlphaString())
}

func Test_ScaleCapacity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScaleCapacity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScaleCapacity_STATUS, ScaleCapacity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScaleCapacity_STATUS runs a test to see if a specific instance of ScaleCapacity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForScaleCapacity_STATUS(subject ScaleCapacity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScaleCapacity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScaleCapacity_STATUS instances for property testing - lazily instantiated by
// ScaleCapacity_STATUSGenerator()
var scaleCapacity_STATUSGenerator gopter.Gen

// ScaleCapacity_STATUSGenerator returns a generator of ScaleCapacity_STATUS instances for property testing.
func ScaleCapacity_STATUSGenerator() gopter.Gen {
	if scaleCapacity_STATUSGenerator != nil {
		return scaleCapacity_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScaleCapacity_STATUS(generators)
	scaleCapacity_STATUSGenerator = gen.Struct(reflect.TypeOf(ScaleCapacity_STATUS{}), generators)

	return scaleCapacity_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForScaleCapacity_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScaleCapacity_STATUS(gens map[string]gopter.Gen) {
	gens["Default"] = gen.PtrOf(gen.AlphaString())
	gens["Maximum"] = gen.PtrOf(gen.AlphaString())
	gens["Minimum"] = gen.PtrOf(gen.AlphaString())
}

func Test_ScaleRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScaleRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScaleRule, ScaleRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScaleRule runs a test to see if a specific instance of ScaleRule round trips to JSON and back losslessly
func RunJSONSerializationTestForScaleRule(subject ScaleRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScaleRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScaleRule instances for property testing - lazily instantiated by ScaleRuleGenerator()
var scaleRuleGenerator gopter.Gen

// ScaleRuleGenerator returns a generator of ScaleRule instances for property testing.
func ScaleRuleGenerator() gopter.Gen {
	if scaleRuleGenerator != nil {
		return scaleRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForScaleRule(generators)
	scaleRuleGenerator = gen.Struct(reflect.TypeOf(ScaleRule{}), generators)

	return scaleRuleGenerator
}

// AddRelatedPropertyGeneratorsForScaleRule is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForScaleRule(gens map[string]gopter.Gen) {
	gens["MetricTrigger"] = gen.PtrOf(MetricTriggerGenerator())
	gens["ScaleAction"] = gen.PtrOf(ScaleActionGenerator())
}

func Test_ScaleRuleMetricDimension_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScaleRuleMetricDimension via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScaleRuleMetricDimension, ScaleRuleMetricDimensionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScaleRuleMetricDimension runs a test to see if a specific instance of ScaleRuleMetricDimension round trips to JSON and back losslessly
func RunJSONSerializationTestForScaleRuleMetricDimension(subject ScaleRuleMetricDimension) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScaleRuleMetricDimension
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScaleRuleMetricDimension instances for property testing - lazily instantiated by
// ScaleRuleMetricDimensionGenerator()
var scaleRuleMetricDimensionGenerator gopter.Gen

// ScaleRuleMetricDimensionGenerator returns a generator of ScaleRuleMetricDimension instances for property testing.
func ScaleRuleMetricDimensionGenerator() gopter.Gen {
	if scaleRuleMetricDimensionGenerator != nil {
		return scaleRuleMetricDimensionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScaleRuleMetricDimension(generators)
	scaleRuleMetricDimensionGenerator = gen.Struct(reflect.TypeOf(ScaleRuleMetricDimension{}), generators)

	return scaleRuleMetricDimensionGenerator
}

// AddIndependentPropertyGeneratorsForScaleRuleMetricDimension is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScaleRuleMetricDimension(gens map[string]gopter.Gen) {
	gens["DimensionName"] = gen.PtrOf(gen.AlphaString())
	gens["Operator"] = gen.PtrOf(gen.AlphaString())
	gens["Values"] = gen.SliceOf(gen.AlphaString())
}

func Test_ScaleRuleMetricDimension_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScaleRuleMetricDimension_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScaleRuleMetricDimension_STATUS, ScaleRuleMetricDimension_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScaleRuleMetricDimension_STATUS runs a test to see if a specific instance of ScaleRuleMetricDimension_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForScaleRuleMetricDimension_STATUS(subject ScaleRuleMetricDimension_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScaleRuleMetricDimension_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScaleRuleMetricDimension_STATUS instances for property testing - lazily instantiated by
// ScaleRuleMetricDimension_STATUSGenerator()
var scaleRuleMetricDimension_STATUSGenerator gopter.Gen

// ScaleRuleMetricDimension_STATUSGenerator returns a generator of ScaleRuleMetricDimension_STATUS instances for property testing.
func ScaleRuleMetricDimension_STATUSGenerator() gopter.Gen {
	if scaleRuleMetricDimension_STATUSGenerator != nil {
		return scaleRuleMetricDimension_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScaleRuleMetricDimension_STATUS(generators)
	scaleRuleMetricDimension_STATUSGenerator = gen.Struct(reflect.TypeOf(ScaleRuleMetricDimension_STATUS{}), generators)

	return scaleRuleMetricDimension_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForScaleRuleMetricDimension_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScaleRuleMetricDimension_STATUS(gens map[string]gopter.Gen) {
	gens["DimensionName"] = gen.PtrOf(gen.AlphaString())
	gens["Operator"] = gen.PtrOf(gen.AlphaString())
	gens["Values"] = gen.SliceOf(gen.AlphaString())
}

func Test_ScaleRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScaleRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScaleRule_STATUS, ScaleRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScaleRule_STATUS runs a test to see if a specific instance of ScaleRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForScaleRule_STATUS(subject ScaleRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScaleRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScaleRule_STATUS instances for property testing - lazily instantiated by ScaleRule_STATUSGenerator()
var scaleRule_STATUSGenerator gopter.Gen

// ScaleRule_STATUSGenerator returns a generator of ScaleRule_STATUS instances for property testing.
func ScaleRule_STATUSGenerator() gopter.Gen {
	if scaleRule_STATUSGenerator != nil {
		return scaleRule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForScaleRule_STATUS(generators)
	scaleRule_STATUSGenerator = gen.Struct(reflect.TypeOf(ScaleRule_STATUS{}), generators)

	return scaleRule_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForScaleRule_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForScaleRule_STATUS(gens map[string]gopter.Gen) {
	gens["MetricTrigger"] = gen.PtrOf(MetricTrigger_STATUSGenerator())
	gens["ScaleAction"] = gen.PtrOf(ScaleAction_STATUSGenerator())
}

func Test_SystemData_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SystemData_STATUS to SystemData_STATUS via AssignProperties_To_SystemData_STATUS & AssignProperties_From_SystemData_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSystemData_STATUS, SystemData_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSystemData_STATUS tests if a specific instance of SystemData_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSystemData_STATUS(subject SystemData_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.SystemData_STATUS
	err := copied.AssignProperties_To_SystemData_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SystemData_STATUS
	err = actual.AssignProperties_From_SystemData_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SystemData_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SystemData_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSystemData_STATUS, SystemData_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSystemData_STATUS runs a test to see if a specific instance of SystemData_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSystemData_STATUS(subject SystemData_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SystemData_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SystemData_STATUS instances for property testing - lazily instantiated by SystemData_STATUSGenerator()
var systemData_STATUSGenerator gopter.Gen

// SystemData_STATUSGenerator returns a generator of SystemData_STATUS instances for property testing.
func SystemData_STATUSGenerator() gopter.Gen {
	if systemData_STATUSGenerator != nil {
		return systemData_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSystemData_STATUS(generators)
	systemData_STATUSGenerator = gen.Struct(reflect.TypeOf(SystemData_STATUS{}), generators)

	return systemData_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSystemData_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSystemData_STATUS(gens map[string]gopter.Gen) {
	gens["CreatedAt"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedBy"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedByType"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedAt"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedBy"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedByType"] = gen.PtrOf(gen.AlphaString())
}

func Test_TimeWindow_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TimeWindow via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTimeWindow, TimeWindowGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTimeWindow runs a test to see if a specific instance of TimeWindow round trips to JSON and back losslessly
func RunJSONSerializationTestForTimeWindow(subject TimeWindow) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TimeWindow
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TimeWindow instances for property testing - lazily instantiated by TimeWindowGenerator()
var timeWindowGenerator gopter.Gen

// TimeWindowGenerator returns a generator of TimeWindow instances for property testing.
func TimeWindowGenerator() gopter.Gen {
	if timeWindowGenerator != nil {
		return timeWindowGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTimeWindow(generators)
	timeWindowGenerator = gen.Struct(reflect.TypeOf(TimeWindow{}), generators)

	return timeWindowGenerator
}

// AddIndependentPropertyGeneratorsForTimeWindow is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTimeWindow(gens map[string]gopter.Gen) {
	gens["End"] = gen.PtrOf(gen.AlphaString())
	gens["Start"] = gen.PtrOf(gen.AlphaString())
	gens["TimeZone"] = gen.PtrOf(gen.AlphaString())
}

func Test_TimeWindow_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TimeWindow_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTimeWindow_STATUS, TimeWindow_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTimeWindow_STATUS runs a test to see if a specific instance of TimeWindow_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForTimeWindow_STATUS(subject TimeWindow_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TimeWindow_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TimeWindow_STATUS instances for property testing - lazily instantiated by TimeWindow_STATUSGenerator()
var timeWindow_STATUSGenerator gopter.Gen

// TimeWindow_STATUSGenerator returns a generator of TimeWindow_STATUS instances for property testing.
func TimeWindow_STATUSGenerator() gopter.Gen {
	if timeWindow_STATUSGenerator != nil {
		return timeWindow_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTimeWindow_STATUS(generators)
	timeWindow_STATUSGenerator = gen.Struct(reflect.TypeOf(TimeWindow_STATUS{}), generators)

	return timeWindow_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForTimeWindow_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTimeWindow_STATUS(gens map[string]gopter.Gen) {
	gens["End"] = gen.PtrOf(gen.AlphaString())
	gens["Start"] = gen.PtrOf(gen.AlphaString())
	gens["TimeZone"] = gen.PtrOf(gen.AlphaString())
}

func Test_WebhookNotification_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebhookNotification via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebhookNotification, WebhookNotificationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebhookNotification runs a test to see if a specific instance of WebhookNotification round trips to JSON and back losslessly
func RunJSONSerializationTestForWebhookNotification(subject WebhookNotification) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebhookNotification
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebhookNotification instances for property testing - lazily instantiated by
// WebhookNotificationGenerator()
var webhookNotificationGenerator gopter.Gen

// WebhookNotificationGenerator returns a generator of WebhookNotification instances for property testing.
func WebhookNotificationGenerator() gopter.Gen {
	if webhookNotificationGenerator != nil {
		return webhookNotificationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebhookNotification(generators)
	webhookNotificationGenerator = gen.Struct(reflect.TypeOf(WebhookNotification{}), generators)

	return webhookNotificationGenerator
}

// AddIndependentPropertyGeneratorsForWebhookNotification is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebhookNotification(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["ServiceUri"] = gen.PtrOf(gen.AlphaString())
}

func Test_WebhookNotification_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebhookNotification_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebhookNotification_STATUS, WebhookNotification_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebhookNotification_STATUS runs a test to see if a specific instance of WebhookNotification_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForWebhookNotification_STATUS(subject WebhookNotification_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebhookNotification_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebhookNotification_STATUS instances for property testing - lazily instantiated by
// WebhookNotification_STATUSGenerator()
var webhookNotification_STATUSGenerator gopter.Gen

// WebhookNotification_STATUSGenerator returns a generator of WebhookNotification_STATUS instances for property testing.
func WebhookNotification_STATUSGenerator() gopter.Gen {
	if webhookNotification_STATUSGenerator != nil {
		return webhookNotification_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebhookNotification_STATUS(generators)
	webhookNotification_STATUSGenerator = gen.Struct(reflect.TypeOf(WebhookNotification_STATUS{}), generators)

	return webhookNotification_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForWebhookNotification_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebhookNotification_STATUS(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["ServiceUri"] = gen.PtrOf(gen.AlphaString())
}
