// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20210901

import (
	"encoding/json"
	v20210901s "github.com/Azure/azure-service-operator/v2/api/containerregistry/v1beta20210901storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_Registry_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	parameters.MinSuccessfulTests = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Registry to hub returns original",
		prop.ForAll(RunResourceConversionTestForRegistry, RegistryGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForRegistry tests if a specific instance of Registry round trips to the hub storage version and back losslessly
func RunResourceConversionTestForRegistry(subject Registry) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v20210901s.Registry
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual Registry
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Registry_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Registry to Registry via AssignPropertiesToRegistry & AssignPropertiesFromRegistry returns original",
		prop.ForAll(RunPropertyAssignmentTestForRegistry, RegistryGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRegistry tests if a specific instance of Registry can be assigned to v1beta20210901storage and back losslessly
func RunPropertyAssignmentTestForRegistry(subject Registry) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210901s.Registry
	err := copied.AssignPropertiesToRegistry(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Registry
	err = actual.AssignPropertiesFromRegistry(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Registry_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Registry via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRegistry, RegistryGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRegistry runs a test to see if a specific instance of Registry round trips to JSON and back losslessly
func RunJSONSerializationTestForRegistry(subject Registry) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Registry
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Registry instances for property testing - lazily instantiated by RegistryGenerator()
var registryGenerator gopter.Gen

// RegistryGenerator returns a generator of Registry instances for property testing.
func RegistryGenerator() gopter.Gen {
	if registryGenerator != nil {
		return registryGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForRegistry(generators)
	registryGenerator = gen.Struct(reflect.TypeOf(Registry{}), generators)

	return registryGenerator
}

// AddRelatedPropertyGeneratorsForRegistry is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRegistry(gens map[string]gopter.Gen) {
<<<<<<< HEAD
	gens["Spec"] = Registry_SpecGenerator()
	gens["Status"] = Registry_STATUSGenerator()
=======
	gens["Spec"] = RegistriesSpecGenerator()
	gens["Status"] = RegistrySTATUSGenerator()
>>>>>>> main
}

func Test_Registry_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Registry_STATUS to Registry_STATUS via AssignPropertiesToRegistry_STATUS & AssignPropertiesFromRegistry_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForRegistry_STATUS, Registry_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRegistry_STATUS tests if a specific instance of Registry_STATUS can be assigned to v1beta20210901storage and back losslessly
func RunPropertyAssignmentTestForRegistry_STATUS(subject Registry_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210901s.Registry_STATUS
	err := copied.AssignPropertiesToRegistry_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Registry_STATUS
	err = actual.AssignPropertiesFromRegistry_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Registry_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Registry_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRegistry_STATUS, Registry_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRegistry_STATUS runs a test to see if a specific instance of Registry_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRegistry_STATUS(subject Registry_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Registry_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Registry_STATUS instances for property testing - lazily instantiated by Registry_STATUSGenerator()
var registry_STATUSGenerator gopter.Gen

// Registry_STATUSGenerator returns a generator of Registry_STATUS instances for property testing.
// We first initialize registry_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Registry_STATUSGenerator() gopter.Gen {
	if registry_STATUSGenerator != nil {
		return registry_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRegistry_STATUS(generators)
	registry_STATUSGenerator = gen.Struct(reflect.TypeOf(Registry_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRegistry_STATUS(generators)
	AddRelatedPropertyGeneratorsForRegistry_STATUS(generators)
	registry_STATUSGenerator = gen.Struct(reflect.TypeOf(Registry_STATUS{}), generators)

	return registry_STATUSGenerator
}

<<<<<<< HEAD
// AddIndependentPropertyGeneratorsForRegistry_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRegistry_STATUS(gens map[string]gopter.Gen) {
=======
// AddIndependentPropertyGeneratorsForRegistriesSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRegistriesSpec(gens map[string]gopter.Gen) {
	gens["AdminUserEnabled"] = gen.PtrOf(gen.Bool())
	gens["AzureName"] = gen.AlphaString()
	gens["DataEndpointEnabled"] = gen.PtrOf(gen.Bool())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["NetworkRuleBypassOptions"] = gen.PtrOf(gen.OneConstOf(RegistryPropertiesNetworkRuleBypassOptions_AzureServices, RegistryPropertiesNetworkRuleBypassOptions_None))
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(RegistryPropertiesPublicNetworkAccess_Disabled, RegistryPropertiesPublicNetworkAccess_Enabled))
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["ZoneRedundancy"] = gen.PtrOf(gen.OneConstOf(RegistryPropertiesZoneRedundancy_Disabled, RegistryPropertiesZoneRedundancy_Enabled))
}

// AddRelatedPropertyGeneratorsForRegistriesSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRegistriesSpec(gens map[string]gopter.Gen) {
	gens["Encryption"] = gen.PtrOf(EncryptionPropertyGenerator())
	gens["Identity"] = gen.PtrOf(IdentityPropertiesGenerator())
	gens["NetworkRuleSet"] = gen.PtrOf(NetworkRuleSetGenerator())
	gens["Policies"] = gen.PtrOf(PoliciesGenerator())
	gens["Sku"] = gen.PtrOf(SkuGenerator())
}

func Test_Registry_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Registry_STATUS to Registry_STATUS via AssignPropertiesToRegistrySTATUS & AssignPropertiesFromRegistrySTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForRegistrySTATUS, RegistrySTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRegistrySTATUS tests if a specific instance of Registry_STATUS can be assigned to v1beta20210901storage and back losslessly
func RunPropertyAssignmentTestForRegistrySTATUS(subject Registry_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210901s.Registry_STATUS
	err := copied.AssignPropertiesToRegistrySTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Registry_STATUS
	err = actual.AssignPropertiesFromRegistrySTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Registry_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Registry_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRegistrySTATUS, RegistrySTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRegistrySTATUS runs a test to see if a specific instance of Registry_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRegistrySTATUS(subject Registry_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Registry_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Registry_STATUS instances for property testing - lazily instantiated by RegistrySTATUSGenerator()
var registrySTATUSGenerator gopter.Gen

// RegistrySTATUSGenerator returns a generator of Registry_STATUS instances for property testing.
// We first initialize registrySTATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RegistrySTATUSGenerator() gopter.Gen {
	if registrySTATUSGenerator != nil {
		return registrySTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRegistrySTATUS(generators)
	registrySTATUSGenerator = gen.Struct(reflect.TypeOf(Registry_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRegistrySTATUS(generators)
	AddRelatedPropertyGeneratorsForRegistrySTATUS(generators)
	registrySTATUSGenerator = gen.Struct(reflect.TypeOf(Registry_STATUS{}), generators)

	return registrySTATUSGenerator
}

// AddIndependentPropertyGeneratorsForRegistrySTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRegistrySTATUS(gens map[string]gopter.Gen) {
>>>>>>> main
	gens["AdminUserEnabled"] = gen.PtrOf(gen.Bool())
	gens["CreationDate"] = gen.PtrOf(gen.AlphaString())
	gens["DataEndpointEnabled"] = gen.PtrOf(gen.Bool())
	gens["DataEndpointHostNames"] = gen.SliceOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["LoginServer"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
<<<<<<< HEAD
	gens["NetworkRuleBypassOptions"] = gen.PtrOf(gen.OneConstOf(RegistryProperties_NetworkRuleBypassOptions_AzureServices_STATUS, RegistryProperties_NetworkRuleBypassOptions_None_STATUS))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		RegistryProperties_ProvisioningState_Canceled_STATUS,
		RegistryProperties_ProvisioningState_Creating_STATUS,
		RegistryProperties_ProvisioningState_Deleting_STATUS,
		RegistryProperties_ProvisioningState_Failed_STATUS,
		RegistryProperties_ProvisioningState_Succeeded_STATUS,
		RegistryProperties_ProvisioningState_Updating_STATUS))
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(RegistryProperties_PublicNetworkAccess_Disabled_STATUS, RegistryProperties_PublicNetworkAccess_Enabled_STATUS))
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["ZoneRedundancy"] = gen.PtrOf(gen.OneConstOf(RegistryProperties_ZoneRedundancy_Disabled_STATUS, RegistryProperties_ZoneRedundancy_Enabled_STATUS))
}

// AddRelatedPropertyGeneratorsForRegistry_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRegistry_STATUS(gens map[string]gopter.Gen) {
	gens["Encryption"] = gen.PtrOf(EncryptionProperty_STATUSGenerator())
	gens["Identity"] = gen.PtrOf(IdentityProperties_STATUSGenerator())
	gens["NetworkRuleSet"] = gen.PtrOf(NetworkRuleSet_STATUSGenerator())
	gens["Policies"] = gen.PtrOf(Policies_STATUSGenerator())
	gens["PrivateEndpointConnections"] = gen.SliceOf(PrivateEndpointConnection_STATUSGenerator())
	gens["Sku"] = gen.PtrOf(Sku_STATUSGenerator())
	gens["Status"] = gen.PtrOf(Status_STATUSGenerator())
	gens["SystemData"] = gen.PtrOf(SystemData_STATUSGenerator())
}

func Test_Registry_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Registry_Spec to Registry_Spec via AssignPropertiesToRegistry_Spec & AssignPropertiesFromRegistry_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForRegistry_Spec, Registry_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRegistry_Spec tests if a specific instance of Registry_Spec can be assigned to v1beta20210901storage and back losslessly
func RunPropertyAssignmentTestForRegistry_Spec(subject Registry_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210901s.Registry_Spec
	err := copied.AssignPropertiesToRegistry_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Registry_Spec
	err = actual.AssignPropertiesFromRegistry_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Registry_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Registry_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRegistry_Spec, Registry_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRegistry_Spec runs a test to see if a specific instance of Registry_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForRegistry_Spec(subject Registry_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Registry_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Registry_Spec instances for property testing - lazily instantiated by Registry_SpecGenerator()
var registry_SpecGenerator gopter.Gen

// Registry_SpecGenerator returns a generator of Registry_Spec instances for property testing.
// We first initialize registry_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Registry_SpecGenerator() gopter.Gen {
	if registry_SpecGenerator != nil {
		return registry_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRegistry_Spec(generators)
	registry_SpecGenerator = gen.Struct(reflect.TypeOf(Registry_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRegistry_Spec(generators)
	AddRelatedPropertyGeneratorsForRegistry_Spec(generators)
	registry_SpecGenerator = gen.Struct(reflect.TypeOf(Registry_Spec{}), generators)

	return registry_SpecGenerator
}

// AddIndependentPropertyGeneratorsForRegistry_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRegistry_Spec(gens map[string]gopter.Gen) {
	gens["AdminUserEnabled"] = gen.PtrOf(gen.Bool())
	gens["AzureName"] = gen.AlphaString()
	gens["DataEndpointEnabled"] = gen.PtrOf(gen.Bool())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["NetworkRuleBypassOptions"] = gen.PtrOf(gen.OneConstOf(RegistryProperties_NetworkRuleBypassOptions_AzureServices, RegistryProperties_NetworkRuleBypassOptions_None))
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(RegistryProperties_PublicNetworkAccess_Disabled, RegistryProperties_PublicNetworkAccess_Enabled))
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["ZoneRedundancy"] = gen.PtrOf(gen.OneConstOf(RegistryProperties_ZoneRedundancy_Disabled, RegistryProperties_ZoneRedundancy_Enabled))
}

// AddRelatedPropertyGeneratorsForRegistry_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRegistry_Spec(gens map[string]gopter.Gen) {
	gens["Encryption"] = gen.PtrOf(EncryptionPropertyGenerator())
	gens["Identity"] = gen.PtrOf(IdentityPropertiesGenerator())
	gens["NetworkRuleSet"] = gen.PtrOf(NetworkRuleSetGenerator())
	gens["Policies"] = gen.PtrOf(PoliciesGenerator())
	gens["Sku"] = gen.PtrOf(SkuGenerator())
=======
	gens["NetworkRuleBypassOptions"] = gen.PtrOf(gen.OneConstOf(RegistryPropertiesSTATUSNetworkRuleBypassOptions_AzureServices, RegistryPropertiesSTATUSNetworkRuleBypassOptions_None))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		RegistryPropertiesSTATUSProvisioningState_Canceled,
		RegistryPropertiesSTATUSProvisioningState_Creating,
		RegistryPropertiesSTATUSProvisioningState_Deleting,
		RegistryPropertiesSTATUSProvisioningState_Failed,
		RegistryPropertiesSTATUSProvisioningState_Succeeded,
		RegistryPropertiesSTATUSProvisioningState_Updating))
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(RegistryPropertiesSTATUSPublicNetworkAccess_Disabled, RegistryPropertiesSTATUSPublicNetworkAccess_Enabled))
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["ZoneRedundancy"] = gen.PtrOf(gen.OneConstOf(RegistryPropertiesSTATUSZoneRedundancy_Disabled, RegistryPropertiesSTATUSZoneRedundancy_Enabled))
}

// AddRelatedPropertyGeneratorsForRegistrySTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRegistrySTATUS(gens map[string]gopter.Gen) {
	gens["Encryption"] = gen.PtrOf(EncryptionPropertySTATUSGenerator())
	gens["Identity"] = gen.PtrOf(IdentityPropertiesSTATUSGenerator())
	gens["NetworkRuleSet"] = gen.PtrOf(NetworkRuleSetSTATUSGenerator())
	gens["Policies"] = gen.PtrOf(PoliciesSTATUSGenerator())
	gens["PrivateEndpointConnections"] = gen.SliceOf(PrivateEndpointConnectionSTATUSSubResourceEmbeddedGenerator())
	gens["Sku"] = gen.PtrOf(SkuSTATUSGenerator())
	gens["Status"] = gen.PtrOf(StatusSTATUSGenerator())
	gens["SystemData"] = gen.PtrOf(SystemDataSTATUSGenerator())
>>>>>>> main
}

func Test_EncryptionProperty_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EncryptionProperty to EncryptionProperty via AssignPropertiesToEncryptionProperty & AssignPropertiesFromEncryptionProperty returns original",
		prop.ForAll(RunPropertyAssignmentTestForEncryptionProperty, EncryptionPropertyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEncryptionProperty tests if a specific instance of EncryptionProperty can be assigned to v1beta20210901storage and back losslessly
func RunPropertyAssignmentTestForEncryptionProperty(subject EncryptionProperty) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210901s.EncryptionProperty
	err := copied.AssignPropertiesToEncryptionProperty(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EncryptionProperty
	err = actual.AssignPropertiesFromEncryptionProperty(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EncryptionProperty_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionProperty via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionProperty, EncryptionPropertyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionProperty runs a test to see if a specific instance of EncryptionProperty round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionProperty(subject EncryptionProperty) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionProperty
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionProperty instances for property testing - lazily instantiated by EncryptionPropertyGenerator()
var encryptionPropertyGenerator gopter.Gen

// EncryptionPropertyGenerator returns a generator of EncryptionProperty instances for property testing.
// We first initialize encryptionPropertyGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EncryptionPropertyGenerator() gopter.Gen {
	if encryptionPropertyGenerator != nil {
		return encryptionPropertyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionProperty(generators)
	encryptionPropertyGenerator = gen.Struct(reflect.TypeOf(EncryptionProperty{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionProperty(generators)
	AddRelatedPropertyGeneratorsForEncryptionProperty(generators)
	encryptionPropertyGenerator = gen.Struct(reflect.TypeOf(EncryptionProperty{}), generators)

	return encryptionPropertyGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionProperty is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionProperty(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(gen.OneConstOf(EncryptionProperty_Status_Disabled, EncryptionProperty_Status_Enabled))
}

// AddRelatedPropertyGeneratorsForEncryptionProperty is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionProperty(gens map[string]gopter.Gen) {
	gens["KeyVaultProperties"] = gen.PtrOf(KeyVaultPropertiesGenerator())
}

func Test_EncryptionProperty_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
<<<<<<< HEAD
		"Round trip from EncryptionProperty_STATUS to EncryptionProperty_STATUS via AssignPropertiesToEncryptionProperty_STATUS & AssignPropertiesFromEncryptionProperty_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForEncryptionProperty_STATUS, EncryptionProperty_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEncryptionProperty_STATUS tests if a specific instance of EncryptionProperty_STATUS can be assigned to v1beta20210901storage and back losslessly
func RunPropertyAssignmentTestForEncryptionProperty_STATUS(subject EncryptionProperty_STATUS) string {
=======
		"Round trip from EncryptionProperty_STATUS to EncryptionProperty_STATUS via AssignPropertiesToEncryptionPropertySTATUS & AssignPropertiesFromEncryptionPropertySTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForEncryptionPropertySTATUS, EncryptionPropertySTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEncryptionPropertySTATUS tests if a specific instance of EncryptionProperty_STATUS can be assigned to v1beta20210901storage and back losslessly
func RunPropertyAssignmentTestForEncryptionPropertySTATUS(subject EncryptionProperty_STATUS) string {
>>>>>>> main
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210901s.EncryptionProperty_STATUS
<<<<<<< HEAD
	err := copied.AssignPropertiesToEncryptionProperty_STATUS(&other)
=======
	err := copied.AssignPropertiesToEncryptionPropertySTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EncryptionProperty_STATUS
<<<<<<< HEAD
	err = actual.AssignPropertiesFromEncryptionProperty_STATUS(&other)
=======
	err = actual.AssignPropertiesFromEncryptionPropertySTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EncryptionProperty_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionProperty_STATUS via JSON returns original",
<<<<<<< HEAD
		prop.ForAll(RunJSONSerializationTestForEncryptionProperty_STATUS, EncryptionProperty_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionProperty_STATUS runs a test to see if a specific instance of EncryptionProperty_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionProperty_STATUS(subject EncryptionProperty_STATUS) string {
=======
		prop.ForAll(RunJSONSerializationTestForEncryptionPropertySTATUS, EncryptionPropertySTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionPropertySTATUS runs a test to see if a specific instance of EncryptionProperty_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionPropertySTATUS(subject EncryptionProperty_STATUS) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionProperty_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionProperty_STATUS instances for property testing - lazily instantiated by
<<<<<<< HEAD
// EncryptionProperty_STATUSGenerator()
var encryptionProperty_STATUSGenerator gopter.Gen

// EncryptionProperty_STATUSGenerator returns a generator of EncryptionProperty_STATUS instances for property testing.
// We first initialize encryptionProperty_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EncryptionProperty_STATUSGenerator() gopter.Gen {
	if encryptionProperty_STATUSGenerator != nil {
		return encryptionProperty_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionProperty_STATUS(generators)
	encryptionProperty_STATUSGenerator = gen.Struct(reflect.TypeOf(EncryptionProperty_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionProperty_STATUS(generators)
	AddRelatedPropertyGeneratorsForEncryptionProperty_STATUS(generators)
	encryptionProperty_STATUSGenerator = gen.Struct(reflect.TypeOf(EncryptionProperty_STATUS{}), generators)

	return encryptionProperty_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionProperty_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionProperty_STATUS(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(gen.OneConstOf(EncryptionProperty_Status_Disabled_STATUS, EncryptionProperty_Status_Enabled_STATUS))
}

// AddRelatedPropertyGeneratorsForEncryptionProperty_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionProperty_STATUS(gens map[string]gopter.Gen) {
	gens["KeyVaultProperties"] = gen.PtrOf(KeyVaultProperties_STATUSGenerator())
=======
// EncryptionPropertySTATUSGenerator()
var encryptionPropertySTATUSGenerator gopter.Gen

// EncryptionPropertySTATUSGenerator returns a generator of EncryptionProperty_STATUS instances for property testing.
// We first initialize encryptionPropertySTATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EncryptionPropertySTATUSGenerator() gopter.Gen {
	if encryptionPropertySTATUSGenerator != nil {
		return encryptionPropertySTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionPropertySTATUS(generators)
	encryptionPropertySTATUSGenerator = gen.Struct(reflect.TypeOf(EncryptionProperty_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionPropertySTATUS(generators)
	AddRelatedPropertyGeneratorsForEncryptionPropertySTATUS(generators)
	encryptionPropertySTATUSGenerator = gen.Struct(reflect.TypeOf(EncryptionProperty_STATUS{}), generators)

	return encryptionPropertySTATUSGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionPropertySTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionPropertySTATUS(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(gen.OneConstOf(EncryptionPropertySTATUSStatus_Disabled, EncryptionPropertySTATUSStatus_Enabled))
}

// AddRelatedPropertyGeneratorsForEncryptionPropertySTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionPropertySTATUS(gens map[string]gopter.Gen) {
	gens["KeyVaultProperties"] = gen.PtrOf(KeyVaultPropertiesSTATUSGenerator())
>>>>>>> main
}

func Test_IdentityProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IdentityProperties to IdentityProperties via AssignPropertiesToIdentityProperties & AssignPropertiesFromIdentityProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForIdentityProperties, IdentityPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIdentityProperties tests if a specific instance of IdentityProperties can be assigned to v1beta20210901storage and back losslessly
func RunPropertyAssignmentTestForIdentityProperties(subject IdentityProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210901s.IdentityProperties
	err := copied.AssignPropertiesToIdentityProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IdentityProperties
	err = actual.AssignPropertiesFromIdentityProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IdentityProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IdentityProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIdentityProperties, IdentityPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIdentityProperties runs a test to see if a specific instance of IdentityProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForIdentityProperties(subject IdentityProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IdentityProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IdentityProperties instances for property testing - lazily instantiated by IdentityPropertiesGenerator()
var identityPropertiesGenerator gopter.Gen

// IdentityPropertiesGenerator returns a generator of IdentityProperties instances for property testing.
// We first initialize identityPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IdentityPropertiesGenerator() gopter.Gen {
	if identityPropertiesGenerator != nil {
		return identityPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentityProperties(generators)
	identityPropertiesGenerator = gen.Struct(reflect.TypeOf(IdentityProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentityProperties(generators)
	AddRelatedPropertyGeneratorsForIdentityProperties(generators)
	identityPropertiesGenerator = gen.Struct(reflect.TypeOf(IdentityProperties{}), generators)

	return identityPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForIdentityProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIdentityProperties(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		IdentityProperties_Type_None,
		IdentityProperties_Type_SystemAssigned,
		IdentityProperties_Type_SystemAssignedUserAssigned,
		IdentityProperties_Type_UserAssigned))
}

// AddRelatedPropertyGeneratorsForIdentityProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIdentityProperties(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), UserIdentityPropertiesGenerator())
}

func Test_IdentityProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
<<<<<<< HEAD
		"Round trip from IdentityProperties_STATUS to IdentityProperties_STATUS via AssignPropertiesToIdentityProperties_STATUS & AssignPropertiesFromIdentityProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForIdentityProperties_STATUS, IdentityProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIdentityProperties_STATUS tests if a specific instance of IdentityProperties_STATUS can be assigned to v1beta20210901storage and back losslessly
func RunPropertyAssignmentTestForIdentityProperties_STATUS(subject IdentityProperties_STATUS) string {
=======
		"Round trip from IdentityProperties_STATUS to IdentityProperties_STATUS via AssignPropertiesToIdentityPropertiesSTATUS & AssignPropertiesFromIdentityPropertiesSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForIdentityPropertiesSTATUS, IdentityPropertiesSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIdentityPropertiesSTATUS tests if a specific instance of IdentityProperties_STATUS can be assigned to v1beta20210901storage and back losslessly
func RunPropertyAssignmentTestForIdentityPropertiesSTATUS(subject IdentityProperties_STATUS) string {
>>>>>>> main
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210901s.IdentityProperties_STATUS
<<<<<<< HEAD
	err := copied.AssignPropertiesToIdentityProperties_STATUS(&other)
=======
	err := copied.AssignPropertiesToIdentityPropertiesSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IdentityProperties_STATUS
<<<<<<< HEAD
	err = actual.AssignPropertiesFromIdentityProperties_STATUS(&other)
=======
	err = actual.AssignPropertiesFromIdentityPropertiesSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IdentityProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IdentityProperties_STATUS via JSON returns original",
<<<<<<< HEAD
		prop.ForAll(RunJSONSerializationTestForIdentityProperties_STATUS, IdentityProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIdentityProperties_STATUS runs a test to see if a specific instance of IdentityProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForIdentityProperties_STATUS(subject IdentityProperties_STATUS) string {
=======
		prop.ForAll(RunJSONSerializationTestForIdentityPropertiesSTATUS, IdentityPropertiesSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIdentityPropertiesSTATUS runs a test to see if a specific instance of IdentityProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForIdentityPropertiesSTATUS(subject IdentityProperties_STATUS) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IdentityProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IdentityProperties_STATUS instances for property testing - lazily instantiated by
<<<<<<< HEAD
// IdentityProperties_STATUSGenerator()
var identityProperties_STATUSGenerator gopter.Gen

// IdentityProperties_STATUSGenerator returns a generator of IdentityProperties_STATUS instances for property testing.
// We first initialize identityProperties_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IdentityProperties_STATUSGenerator() gopter.Gen {
	if identityProperties_STATUSGenerator != nil {
		return identityProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentityProperties_STATUS(generators)
	identityProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(IdentityProperties_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentityProperties_STATUS(generators)
	AddRelatedPropertyGeneratorsForIdentityProperties_STATUS(generators)
	identityProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(IdentityProperties_STATUS{}), generators)

	return identityProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForIdentityProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIdentityProperties_STATUS(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		IdentityProperties_Type_None_STATUS,
		IdentityProperties_Type_SystemAssigned_STATUS,
		IdentityProperties_Type_SystemAssignedUserAssigned_STATUS,
		IdentityProperties_Type_UserAssigned_STATUS))
}

// AddRelatedPropertyGeneratorsForIdentityProperties_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIdentityProperties_STATUS(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), UserIdentityProperties_STATUSGenerator())
=======
// IdentityPropertiesSTATUSGenerator()
var identityPropertiesSTATUSGenerator gopter.Gen

// IdentityPropertiesSTATUSGenerator returns a generator of IdentityProperties_STATUS instances for property testing.
// We first initialize identityPropertiesSTATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IdentityPropertiesSTATUSGenerator() gopter.Gen {
	if identityPropertiesSTATUSGenerator != nil {
		return identityPropertiesSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentityPropertiesSTATUS(generators)
	identityPropertiesSTATUSGenerator = gen.Struct(reflect.TypeOf(IdentityProperties_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentityPropertiesSTATUS(generators)
	AddRelatedPropertyGeneratorsForIdentityPropertiesSTATUS(generators)
	identityPropertiesSTATUSGenerator = gen.Struct(reflect.TypeOf(IdentityProperties_STATUS{}), generators)

	return identityPropertiesSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForIdentityPropertiesSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIdentityPropertiesSTATUS(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		IdentityPropertiesSTATUSType_None,
		IdentityPropertiesSTATUSType_SystemAssigned,
		IdentityPropertiesSTATUSType_SystemAssignedUserAssigned,
		IdentityPropertiesSTATUSType_UserAssigned))
}

// AddRelatedPropertyGeneratorsForIdentityPropertiesSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIdentityPropertiesSTATUS(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), UserIdentityPropertiesSTATUSGenerator())
>>>>>>> main
}

func Test_NetworkRuleSet_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NetworkRuleSet to NetworkRuleSet via AssignPropertiesToNetworkRuleSet & AssignPropertiesFromNetworkRuleSet returns original",
		prop.ForAll(RunPropertyAssignmentTestForNetworkRuleSet, NetworkRuleSetGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNetworkRuleSet tests if a specific instance of NetworkRuleSet can be assigned to v1beta20210901storage and back losslessly
func RunPropertyAssignmentTestForNetworkRuleSet(subject NetworkRuleSet) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210901s.NetworkRuleSet
	err := copied.AssignPropertiesToNetworkRuleSet(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NetworkRuleSet
	err = actual.AssignPropertiesFromNetworkRuleSet(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NetworkRuleSet_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkRuleSet via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkRuleSet, NetworkRuleSetGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkRuleSet runs a test to see if a specific instance of NetworkRuleSet round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkRuleSet(subject NetworkRuleSet) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkRuleSet
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkRuleSet instances for property testing - lazily instantiated by NetworkRuleSetGenerator()
var networkRuleSetGenerator gopter.Gen

// NetworkRuleSetGenerator returns a generator of NetworkRuleSet instances for property testing.
// We first initialize networkRuleSetGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkRuleSetGenerator() gopter.Gen {
	if networkRuleSetGenerator != nil {
		return networkRuleSetGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSet(generators)
	networkRuleSetGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSet(generators)
	AddRelatedPropertyGeneratorsForNetworkRuleSet(generators)
	networkRuleSetGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet{}), generators)

	return networkRuleSetGenerator
}

// AddIndependentPropertyGeneratorsForNetworkRuleSet is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkRuleSet(gens map[string]gopter.Gen) {
	gens["DefaultAction"] = gen.PtrOf(gen.OneConstOf(NetworkRuleSet_DefaultAction_Allow, NetworkRuleSet_DefaultAction_Deny))
}

// AddRelatedPropertyGeneratorsForNetworkRuleSet is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkRuleSet(gens map[string]gopter.Gen) {
	gens["IpRules"] = gen.SliceOf(IPRuleGenerator())
}

func Test_NetworkRuleSet_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
<<<<<<< HEAD
		"Round trip from NetworkRuleSet_STATUS to NetworkRuleSet_STATUS via AssignPropertiesToNetworkRuleSet_STATUS & AssignPropertiesFromNetworkRuleSet_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForNetworkRuleSet_STATUS, NetworkRuleSet_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNetworkRuleSet_STATUS tests if a specific instance of NetworkRuleSet_STATUS can be assigned to v1beta20210901storage and back losslessly
func RunPropertyAssignmentTestForNetworkRuleSet_STATUS(subject NetworkRuleSet_STATUS) string {
=======
		"Round trip from NetworkRuleSet_STATUS to NetworkRuleSet_STATUS via AssignPropertiesToNetworkRuleSetSTATUS & AssignPropertiesFromNetworkRuleSetSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForNetworkRuleSetSTATUS, NetworkRuleSetSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNetworkRuleSetSTATUS tests if a specific instance of NetworkRuleSet_STATUS can be assigned to v1beta20210901storage and back losslessly
func RunPropertyAssignmentTestForNetworkRuleSetSTATUS(subject NetworkRuleSet_STATUS) string {
>>>>>>> main
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210901s.NetworkRuleSet_STATUS
<<<<<<< HEAD
	err := copied.AssignPropertiesToNetworkRuleSet_STATUS(&other)
=======
	err := copied.AssignPropertiesToNetworkRuleSetSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NetworkRuleSet_STATUS
<<<<<<< HEAD
	err = actual.AssignPropertiesFromNetworkRuleSet_STATUS(&other)
=======
	err = actual.AssignPropertiesFromNetworkRuleSetSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NetworkRuleSet_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkRuleSet_STATUS via JSON returns original",
<<<<<<< HEAD
		prop.ForAll(RunJSONSerializationTestForNetworkRuleSet_STATUS, NetworkRuleSet_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkRuleSet_STATUS runs a test to see if a specific instance of NetworkRuleSet_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkRuleSet_STATUS(subject NetworkRuleSet_STATUS) string {
=======
		prop.ForAll(RunJSONSerializationTestForNetworkRuleSetSTATUS, NetworkRuleSetSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkRuleSetSTATUS runs a test to see if a specific instance of NetworkRuleSet_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkRuleSetSTATUS(subject NetworkRuleSet_STATUS) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkRuleSet_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkRuleSet_STATUS instances for property testing - lazily instantiated by
<<<<<<< HEAD
// NetworkRuleSet_STATUSGenerator()
var networkRuleSet_STATUSGenerator gopter.Gen

// NetworkRuleSet_STATUSGenerator returns a generator of NetworkRuleSet_STATUS instances for property testing.
// We first initialize networkRuleSet_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkRuleSet_STATUSGenerator() gopter.Gen {
	if networkRuleSet_STATUSGenerator != nil {
		return networkRuleSet_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSet_STATUS(generators)
	networkRuleSet_STATUSGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSet_STATUS(generators)
	AddRelatedPropertyGeneratorsForNetworkRuleSet_STATUS(generators)
	networkRuleSet_STATUSGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet_STATUS{}), generators)

	return networkRuleSet_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForNetworkRuleSet_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkRuleSet_STATUS(gens map[string]gopter.Gen) {
	gens["DefaultAction"] = gen.PtrOf(gen.OneConstOf(NetworkRuleSet_DefaultAction_Allow_STATUS, NetworkRuleSet_DefaultAction_Deny_STATUS))
}

// AddRelatedPropertyGeneratorsForNetworkRuleSet_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkRuleSet_STATUS(gens map[string]gopter.Gen) {
	gens["IpRules"] = gen.SliceOf(IPRule_STATUSGenerator())
=======
// NetworkRuleSetSTATUSGenerator()
var networkRuleSetSTATUSGenerator gopter.Gen

// NetworkRuleSetSTATUSGenerator returns a generator of NetworkRuleSet_STATUS instances for property testing.
// We first initialize networkRuleSetSTATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkRuleSetSTATUSGenerator() gopter.Gen {
	if networkRuleSetSTATUSGenerator != nil {
		return networkRuleSetSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSetSTATUS(generators)
	networkRuleSetSTATUSGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSetSTATUS(generators)
	AddRelatedPropertyGeneratorsForNetworkRuleSetSTATUS(generators)
	networkRuleSetSTATUSGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet_STATUS{}), generators)

	return networkRuleSetSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForNetworkRuleSetSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkRuleSetSTATUS(gens map[string]gopter.Gen) {
	gens["DefaultAction"] = gen.PtrOf(gen.OneConstOf(NetworkRuleSetSTATUSDefaultAction_Allow, NetworkRuleSetSTATUSDefaultAction_Deny))
}

// AddRelatedPropertyGeneratorsForNetworkRuleSetSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkRuleSetSTATUS(gens map[string]gopter.Gen) {
	gens["IpRules"] = gen.SliceOf(IPRuleSTATUSGenerator())
>>>>>>> main
}

func Test_Policies_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Policies to Policies via AssignPropertiesToPolicies & AssignPropertiesFromPolicies returns original",
		prop.ForAll(RunPropertyAssignmentTestForPolicies, PoliciesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPolicies tests if a specific instance of Policies can be assigned to v1beta20210901storage and back losslessly
func RunPropertyAssignmentTestForPolicies(subject Policies) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210901s.Policies
	err := copied.AssignPropertiesToPolicies(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Policies
	err = actual.AssignPropertiesFromPolicies(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Policies_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Policies via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPolicies, PoliciesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPolicies runs a test to see if a specific instance of Policies round trips to JSON and back losslessly
func RunJSONSerializationTestForPolicies(subject Policies) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Policies
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Policies instances for property testing - lazily instantiated by PoliciesGenerator()
var policiesGenerator gopter.Gen

// PoliciesGenerator returns a generator of Policies instances for property testing.
func PoliciesGenerator() gopter.Gen {
	if policiesGenerator != nil {
		return policiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForPolicies(generators)
	policiesGenerator = gen.Struct(reflect.TypeOf(Policies{}), generators)

	return policiesGenerator
}

// AddRelatedPropertyGeneratorsForPolicies is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPolicies(gens map[string]gopter.Gen) {
	gens["ExportPolicy"] = gen.PtrOf(ExportPolicyGenerator())
	gens["QuarantinePolicy"] = gen.PtrOf(QuarantinePolicyGenerator())
	gens["RetentionPolicy"] = gen.PtrOf(RetentionPolicyGenerator())
	gens["TrustPolicy"] = gen.PtrOf(TrustPolicyGenerator())
}

func Test_Policies_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
<<<<<<< HEAD
		"Round trip from Policies_STATUS to Policies_STATUS via AssignPropertiesToPolicies_STATUS & AssignPropertiesFromPolicies_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForPolicies_STATUS, Policies_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPolicies_STATUS tests if a specific instance of Policies_STATUS can be assigned to v1beta20210901storage and back losslessly
func RunPropertyAssignmentTestForPolicies_STATUS(subject Policies_STATUS) string {
=======
		"Round trip from Policies_STATUS to Policies_STATUS via AssignPropertiesToPoliciesSTATUS & AssignPropertiesFromPoliciesSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForPoliciesSTATUS, PoliciesSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPoliciesSTATUS tests if a specific instance of Policies_STATUS can be assigned to v1beta20210901storage and back losslessly
func RunPropertyAssignmentTestForPoliciesSTATUS(subject Policies_STATUS) string {
>>>>>>> main
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210901s.Policies_STATUS
<<<<<<< HEAD
	err := copied.AssignPropertiesToPolicies_STATUS(&other)
=======
	err := copied.AssignPropertiesToPoliciesSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Policies_STATUS
<<<<<<< HEAD
	err = actual.AssignPropertiesFromPolicies_STATUS(&other)
=======
	err = actual.AssignPropertiesFromPoliciesSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Policies_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
<<<<<<< HEAD
=======
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Policies_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPoliciesSTATUS, PoliciesSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPoliciesSTATUS runs a test to see if a specific instance of Policies_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPoliciesSTATUS(subject Policies_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Policies_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Policies_STATUS instances for property testing - lazily instantiated by PoliciesSTATUSGenerator()
var policiesSTATUSGenerator gopter.Gen

// PoliciesSTATUSGenerator returns a generator of Policies_STATUS instances for property testing.
func PoliciesSTATUSGenerator() gopter.Gen {
	if policiesSTATUSGenerator != nil {
		return policiesSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForPoliciesSTATUS(generators)
	policiesSTATUSGenerator = gen.Struct(reflect.TypeOf(Policies_STATUS{}), generators)

	return policiesSTATUSGenerator
}

// AddRelatedPropertyGeneratorsForPoliciesSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPoliciesSTATUS(gens map[string]gopter.Gen) {
	gens["ExportPolicy"] = gen.PtrOf(ExportPolicySTATUSGenerator())
	gens["QuarantinePolicy"] = gen.PtrOf(QuarantinePolicySTATUSGenerator())
	gens["RetentionPolicy"] = gen.PtrOf(RetentionPolicySTATUSGenerator())
	gens["TrustPolicy"] = gen.PtrOf(TrustPolicySTATUSGenerator())
}

func Test_PrivateEndpointConnection_STATUS_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PrivateEndpointConnection_STATUS_SubResourceEmbedded to PrivateEndpointConnection_STATUS_SubResourceEmbedded via AssignPropertiesToPrivateEndpointConnectionSTATUSSubResourceEmbedded & AssignPropertiesFromPrivateEndpointConnectionSTATUSSubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForPrivateEndpointConnectionSTATUSSubResourceEmbedded, PrivateEndpointConnectionSTATUSSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPrivateEndpointConnectionSTATUSSubResourceEmbedded tests if a specific instance of PrivateEndpointConnection_STATUS_SubResourceEmbedded can be assigned to v1beta20210901storage and back losslessly
func RunPropertyAssignmentTestForPrivateEndpointConnectionSTATUSSubResourceEmbedded(subject PrivateEndpointConnection_STATUS_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210901s.PrivateEndpointConnection_STATUS_SubResourceEmbedded
	err := copied.AssignPropertiesToPrivateEndpointConnectionSTATUSSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PrivateEndpointConnection_STATUS_SubResourceEmbedded
	err = actual.AssignPropertiesFromPrivateEndpointConnectionSTATUSSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PrivateEndpointConnection_STATUS_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
>>>>>>> main
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
<<<<<<< HEAD
		"Round trip of Policies_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPolicies_STATUS, Policies_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPolicies_STATUS runs a test to see if a specific instance of Policies_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPolicies_STATUS(subject Policies_STATUS) string {
=======
		"Round trip of PrivateEndpointConnection_STATUS_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointConnectionSTATUSSubResourceEmbedded, PrivateEndpointConnectionSTATUSSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointConnectionSTATUSSubResourceEmbedded runs a test to see if a specific instance of PrivateEndpointConnection_STATUS_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointConnectionSTATUSSubResourceEmbedded(subject PrivateEndpointConnection_STATUS_SubResourceEmbedded) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
<<<<<<< HEAD
	var actual Policies_STATUS
=======
	var actual PrivateEndpointConnection_STATUS_SubResourceEmbedded
>>>>>>> main
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

<<<<<<< HEAD
// Generator of Policies_STATUS instances for property testing - lazily instantiated by Policies_STATUSGenerator()
var policies_STATUSGenerator gopter.Gen

// Policies_STATUSGenerator returns a generator of Policies_STATUS instances for property testing.
func Policies_STATUSGenerator() gopter.Gen {
	if policies_STATUSGenerator != nil {
		return policies_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForPolicies_STATUS(generators)
	policies_STATUSGenerator = gen.Struct(reflect.TypeOf(Policies_STATUS{}), generators)

	return policies_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForPolicies_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPolicies_STATUS(gens map[string]gopter.Gen) {
	gens["ExportPolicy"] = gen.PtrOf(ExportPolicy_STATUSGenerator())
	gens["QuarantinePolicy"] = gen.PtrOf(QuarantinePolicy_STATUSGenerator())
	gens["RetentionPolicy"] = gen.PtrOf(RetentionPolicy_STATUSGenerator())
	gens["TrustPolicy"] = gen.PtrOf(TrustPolicy_STATUSGenerator())
}

func Test_PrivateEndpointConnection_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PrivateEndpointConnection_STATUS to PrivateEndpointConnection_STATUS via AssignPropertiesToPrivateEndpointConnection_STATUS & AssignPropertiesFromPrivateEndpointConnection_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForPrivateEndpointConnection_STATUS, PrivateEndpointConnection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPrivateEndpointConnection_STATUS tests if a specific instance of PrivateEndpointConnection_STATUS can be assigned to v1beta20210901storage and back losslessly
func RunPropertyAssignmentTestForPrivateEndpointConnection_STATUS(subject PrivateEndpointConnection_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210901s.PrivateEndpointConnection_STATUS
	err := copied.AssignPropertiesToPrivateEndpointConnection_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PrivateEndpointConnection_STATUS
	err = actual.AssignPropertiesFromPrivateEndpointConnection_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PrivateEndpointConnection_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointConnection_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointConnection_STATUS, PrivateEndpointConnection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointConnection_STATUS runs a test to see if a specific instance of PrivateEndpointConnection_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointConnection_STATUS(subject PrivateEndpointConnection_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointConnection_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointConnection_STATUS instances for property testing - lazily instantiated by
// PrivateEndpointConnection_STATUSGenerator()
var privateEndpointConnection_STATUSGenerator gopter.Gen

// PrivateEndpointConnection_STATUSGenerator returns a generator of PrivateEndpointConnection_STATUS instances for property testing.
// We first initialize privateEndpointConnection_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateEndpointConnection_STATUSGenerator() gopter.Gen {
	if privateEndpointConnection_STATUSGenerator != nil {
		return privateEndpointConnection_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnection_STATUS(generators)
	privateEndpointConnection_STATUSGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnection_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnection_STATUS(generators)
	AddRelatedPropertyGeneratorsForPrivateEndpointConnection_STATUS(generators)
	privateEndpointConnection_STATUSGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnection_STATUS{}), generators)

	return privateEndpointConnection_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointConnection_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointConnection_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPrivateEndpointConnection_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateEndpointConnection_STATUS(gens map[string]gopter.Gen) {
	gens["SystemData"] = gen.PtrOf(SystemData_STATUSGenerator())
=======
// Generator of PrivateEndpointConnection_STATUS_SubResourceEmbedded instances for property testing - lazily
// instantiated by PrivateEndpointConnectionSTATUSSubResourceEmbeddedGenerator()
var privateEndpointConnectionSTATUSSubResourceEmbeddedGenerator gopter.Gen

// PrivateEndpointConnectionSTATUSSubResourceEmbeddedGenerator returns a generator of PrivateEndpointConnection_STATUS_SubResourceEmbedded instances for property testing.
// We first initialize privateEndpointConnectionSTATUSSubResourceEmbeddedGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateEndpointConnectionSTATUSSubResourceEmbeddedGenerator() gopter.Gen {
	if privateEndpointConnectionSTATUSSubResourceEmbeddedGenerator != nil {
		return privateEndpointConnectionSTATUSSubResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnectionSTATUSSubResourceEmbedded(generators)
	privateEndpointConnectionSTATUSSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnection_STATUS_SubResourceEmbedded{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnectionSTATUSSubResourceEmbedded(generators)
	AddRelatedPropertyGeneratorsForPrivateEndpointConnectionSTATUSSubResourceEmbedded(generators)
	privateEndpointConnectionSTATUSSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnection_STATUS_SubResourceEmbedded{}), generators)

	return privateEndpointConnectionSTATUSSubResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointConnectionSTATUSSubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointConnectionSTATUSSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPrivateEndpointConnectionSTATUSSubResourceEmbedded is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateEndpointConnectionSTATUSSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["SystemData"] = gen.PtrOf(SystemDataSTATUSGenerator())
>>>>>>> main
}

func Test_Sku_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Sku to Sku via AssignPropertiesToSku & AssignPropertiesFromSku returns original",
		prop.ForAll(RunPropertyAssignmentTestForSku, SkuGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSku tests if a specific instance of Sku can be assigned to v1beta20210901storage and back losslessly
func RunPropertyAssignmentTestForSku(subject Sku) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210901s.Sku
	err := copied.AssignPropertiesToSku(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Sku
	err = actual.AssignPropertiesFromSku(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Sku_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sku via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSku, SkuGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSku runs a test to see if a specific instance of Sku round trips to JSON and back losslessly
func RunJSONSerializationTestForSku(subject Sku) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sku
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sku instances for property testing - lazily instantiated by SkuGenerator()
var skuGenerator gopter.Gen

// SkuGenerator returns a generator of Sku instances for property testing.
func SkuGenerator() gopter.Gen {
	if skuGenerator != nil {
		return skuGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSku(generators)
	skuGenerator = gen.Struct(reflect.TypeOf(Sku{}), generators)

	return skuGenerator
}

// AddIndependentPropertyGeneratorsForSku is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSku(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(
		Sku_Name_Basic,
		Sku_Name_Classic,
		Sku_Name_Premium,
		Sku_Name_Standard))
}

func Test_Sku_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
<<<<<<< HEAD
		"Round trip from Sku_STATUS to Sku_STATUS via AssignPropertiesToSku_STATUS & AssignPropertiesFromSku_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSku_STATUS, Sku_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSku_STATUS tests if a specific instance of Sku_STATUS can be assigned to v1beta20210901storage and back losslessly
func RunPropertyAssignmentTestForSku_STATUS(subject Sku_STATUS) string {
=======
		"Round trip from Sku_STATUS to Sku_STATUS via AssignPropertiesToSkuSTATUS & AssignPropertiesFromSkuSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSkuSTATUS, SkuSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSkuSTATUS tests if a specific instance of Sku_STATUS can be assigned to v1beta20210901storage and back losslessly
func RunPropertyAssignmentTestForSkuSTATUS(subject Sku_STATUS) string {
>>>>>>> main
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210901s.Sku_STATUS
<<<<<<< HEAD
	err := copied.AssignPropertiesToSku_STATUS(&other)
=======
	err := copied.AssignPropertiesToSkuSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Sku_STATUS
<<<<<<< HEAD
	err = actual.AssignPropertiesFromSku_STATUS(&other)
=======
	err = actual.AssignPropertiesFromSkuSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Sku_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sku_STATUS via JSON returns original",
<<<<<<< HEAD
		prop.ForAll(RunJSONSerializationTestForSku_STATUS, Sku_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSku_STATUS runs a test to see if a specific instance of Sku_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSku_STATUS(subject Sku_STATUS) string {
=======
		prop.ForAll(RunJSONSerializationTestForSkuSTATUS, SkuSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSkuSTATUS runs a test to see if a specific instance of Sku_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSkuSTATUS(subject Sku_STATUS) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sku_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

<<<<<<< HEAD
// Generator of Sku_STATUS instances for property testing - lazily instantiated by Sku_STATUSGenerator()
var sku_STATUSGenerator gopter.Gen

// Sku_STATUSGenerator returns a generator of Sku_STATUS instances for property testing.
func Sku_STATUSGenerator() gopter.Gen {
	if sku_STATUSGenerator != nil {
		return sku_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSku_STATUS(generators)
	sku_STATUSGenerator = gen.Struct(reflect.TypeOf(Sku_STATUS{}), generators)

	return sku_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSku_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSku_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(
		Sku_Name_Basic_STATUS,
		Sku_Name_Classic_STATUS,
		Sku_Name_Premium_STATUS,
		Sku_Name_Standard_STATUS))
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(
		Sku_Tier_Basic_STATUS,
		Sku_Tier_Classic_STATUS,
		Sku_Tier_Premium_STATUS,
		Sku_Tier_Standard_STATUS))
=======
// Generator of Sku_STATUS instances for property testing - lazily instantiated by SkuSTATUSGenerator()
var skuSTATUSGenerator gopter.Gen

// SkuSTATUSGenerator returns a generator of Sku_STATUS instances for property testing.
func SkuSTATUSGenerator() gopter.Gen {
	if skuSTATUSGenerator != nil {
		return skuSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSkuSTATUS(generators)
	skuSTATUSGenerator = gen.Struct(reflect.TypeOf(Sku_STATUS{}), generators)

	return skuSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForSkuSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSkuSTATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(
		SkuSTATUSName_Basic,
		SkuSTATUSName_Classic,
		SkuSTATUSName_Premium,
		SkuSTATUSName_Standard))
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(
		SkuSTATUSTier_Basic,
		SkuSTATUSTier_Classic,
		SkuSTATUSTier_Premium,
		SkuSTATUSTier_Standard))
>>>>>>> main
}

func Test_Status_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
<<<<<<< HEAD
		"Round trip from Status_STATUS to Status_STATUS via AssignPropertiesToStatus_STATUS & AssignPropertiesFromStatus_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForStatus_STATUS, Status_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForStatus_STATUS tests if a specific instance of Status_STATUS can be assigned to v1beta20210901storage and back losslessly
func RunPropertyAssignmentTestForStatus_STATUS(subject Status_STATUS) string {
=======
		"Round trip from Status_STATUS to Status_STATUS via AssignPropertiesToStatusSTATUS & AssignPropertiesFromStatusSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForStatusSTATUS, StatusSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForStatusSTATUS tests if a specific instance of Status_STATUS can be assigned to v1beta20210901storage and back losslessly
func RunPropertyAssignmentTestForStatusSTATUS(subject Status_STATUS) string {
>>>>>>> main
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210901s.Status_STATUS
<<<<<<< HEAD
	err := copied.AssignPropertiesToStatus_STATUS(&other)
=======
	err := copied.AssignPropertiesToStatusSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Status_STATUS
<<<<<<< HEAD
	err = actual.AssignPropertiesFromStatus_STATUS(&other)
=======
	err = actual.AssignPropertiesFromStatusSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Status_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Status_STATUS via JSON returns original",
<<<<<<< HEAD
		prop.ForAll(RunJSONSerializationTestForStatus_STATUS, Status_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStatus_STATUS runs a test to see if a specific instance of Status_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForStatus_STATUS(subject Status_STATUS) string {
=======
		prop.ForAll(RunJSONSerializationTestForStatusSTATUS, StatusSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStatusSTATUS runs a test to see if a specific instance of Status_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForStatusSTATUS(subject Status_STATUS) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Status_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

<<<<<<< HEAD
// Generator of Status_STATUS instances for property testing - lazily instantiated by Status_STATUSGenerator()
var status_STATUSGenerator gopter.Gen

// Status_STATUSGenerator returns a generator of Status_STATUS instances for property testing.
func Status_STATUSGenerator() gopter.Gen {
	if status_STATUSGenerator != nil {
		return status_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStatus_STATUS(generators)
	status_STATUSGenerator = gen.Struct(reflect.TypeOf(Status_STATUS{}), generators)

	return status_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForStatus_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStatus_STATUS(gens map[string]gopter.Gen) {
=======
// Generator of Status_STATUS instances for property testing - lazily instantiated by StatusSTATUSGenerator()
var statusSTATUSGenerator gopter.Gen

// StatusSTATUSGenerator returns a generator of Status_STATUS instances for property testing.
func StatusSTATUSGenerator() gopter.Gen {
	if statusSTATUSGenerator != nil {
		return statusSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStatusSTATUS(generators)
	statusSTATUSGenerator = gen.Struct(reflect.TypeOf(Status_STATUS{}), generators)

	return statusSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForStatusSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStatusSTATUS(gens map[string]gopter.Gen) {
>>>>>>> main
	gens["DisplayStatus"] = gen.PtrOf(gen.AlphaString())
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Timestamp"] = gen.PtrOf(gen.AlphaString())
}

func Test_SystemData_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
<<<<<<< HEAD
		"Round trip from SystemData_STATUS to SystemData_STATUS via AssignPropertiesToSystemData_STATUS & AssignPropertiesFromSystemData_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSystemData_STATUS, SystemData_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSystemData_STATUS tests if a specific instance of SystemData_STATUS can be assigned to v1beta20210901storage and back losslessly
func RunPropertyAssignmentTestForSystemData_STATUS(subject SystemData_STATUS) string {
=======
		"Round trip from SystemData_STATUS to SystemData_STATUS via AssignPropertiesToSystemDataSTATUS & AssignPropertiesFromSystemDataSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSystemDataSTATUS, SystemDataSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSystemDataSTATUS tests if a specific instance of SystemData_STATUS can be assigned to v1beta20210901storage and back losslessly
func RunPropertyAssignmentTestForSystemDataSTATUS(subject SystemData_STATUS) string {
>>>>>>> main
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210901s.SystemData_STATUS
<<<<<<< HEAD
	err := copied.AssignPropertiesToSystemData_STATUS(&other)
=======
	err := copied.AssignPropertiesToSystemDataSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SystemData_STATUS
<<<<<<< HEAD
	err = actual.AssignPropertiesFromSystemData_STATUS(&other)
=======
	err = actual.AssignPropertiesFromSystemDataSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SystemData_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SystemData_STATUS via JSON returns original",
<<<<<<< HEAD
		prop.ForAll(RunJSONSerializationTestForSystemData_STATUS, SystemData_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSystemData_STATUS runs a test to see if a specific instance of SystemData_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSystemData_STATUS(subject SystemData_STATUS) string {
=======
		prop.ForAll(RunJSONSerializationTestForSystemDataSTATUS, SystemDataSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSystemDataSTATUS runs a test to see if a specific instance of SystemData_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSystemDataSTATUS(subject SystemData_STATUS) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SystemData_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

<<<<<<< HEAD
// Generator of SystemData_STATUS instances for property testing - lazily instantiated by SystemData_STATUSGenerator()
var systemData_STATUSGenerator gopter.Gen

// SystemData_STATUSGenerator returns a generator of SystemData_STATUS instances for property testing.
func SystemData_STATUSGenerator() gopter.Gen {
	if systemData_STATUSGenerator != nil {
		return systemData_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSystemData_STATUS(generators)
	systemData_STATUSGenerator = gen.Struct(reflect.TypeOf(SystemData_STATUS{}), generators)

	return systemData_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSystemData_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSystemData_STATUS(gens map[string]gopter.Gen) {
	gens["CreatedAt"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedBy"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemData_CreatedByType_Application_STATUS,
		SystemData_CreatedByType_Key_STATUS,
		SystemData_CreatedByType_ManagedIdentity_STATUS,
		SystemData_CreatedByType_User_STATUS))
	gens["LastModifiedAt"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedBy"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemData_LastModifiedByType_Application_STATUS,
		SystemData_LastModifiedByType_Key_STATUS,
		SystemData_LastModifiedByType_ManagedIdentity_STATUS,
		SystemData_LastModifiedByType_User_STATUS))
=======
// Generator of SystemData_STATUS instances for property testing - lazily instantiated by SystemDataSTATUSGenerator()
var systemDataSTATUSGenerator gopter.Gen

// SystemDataSTATUSGenerator returns a generator of SystemData_STATUS instances for property testing.
func SystemDataSTATUSGenerator() gopter.Gen {
	if systemDataSTATUSGenerator != nil {
		return systemDataSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSystemDataSTATUS(generators)
	systemDataSTATUSGenerator = gen.Struct(reflect.TypeOf(SystemData_STATUS{}), generators)

	return systemDataSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForSystemDataSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSystemDataSTATUS(gens map[string]gopter.Gen) {
	gens["CreatedAt"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedBy"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemDataSTATUSCreatedByType_Application,
		SystemDataSTATUSCreatedByType_Key,
		SystemDataSTATUSCreatedByType_ManagedIdentity,
		SystemDataSTATUSCreatedByType_User))
	gens["LastModifiedAt"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedBy"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemDataSTATUSLastModifiedByType_Application,
		SystemDataSTATUSLastModifiedByType_Key,
		SystemDataSTATUSLastModifiedByType_ManagedIdentity,
		SystemDataSTATUSLastModifiedByType_User))
>>>>>>> main
}

func Test_ExportPolicy_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ExportPolicy to ExportPolicy via AssignPropertiesToExportPolicy & AssignPropertiesFromExportPolicy returns original",
		prop.ForAll(RunPropertyAssignmentTestForExportPolicy, ExportPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExportPolicy tests if a specific instance of ExportPolicy can be assigned to v1beta20210901storage and back losslessly
func RunPropertyAssignmentTestForExportPolicy(subject ExportPolicy) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210901s.ExportPolicy
	err := copied.AssignPropertiesToExportPolicy(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ExportPolicy
	err = actual.AssignPropertiesFromExportPolicy(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ExportPolicy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExportPolicy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExportPolicy, ExportPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExportPolicy runs a test to see if a specific instance of ExportPolicy round trips to JSON and back losslessly
func RunJSONSerializationTestForExportPolicy(subject ExportPolicy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExportPolicy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExportPolicy instances for property testing - lazily instantiated by ExportPolicyGenerator()
var exportPolicyGenerator gopter.Gen

// ExportPolicyGenerator returns a generator of ExportPolicy instances for property testing.
func ExportPolicyGenerator() gopter.Gen {
	if exportPolicyGenerator != nil {
		return exportPolicyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExportPolicy(generators)
	exportPolicyGenerator = gen.Struct(reflect.TypeOf(ExportPolicy{}), generators)

	return exportPolicyGenerator
}

// AddIndependentPropertyGeneratorsForExportPolicy is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExportPolicy(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(gen.OneConstOf(ExportPolicy_Status_Disabled, ExportPolicy_Status_Enabled))
}

func Test_ExportPolicy_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
<<<<<<< HEAD
		"Round trip from ExportPolicy_STATUS to ExportPolicy_STATUS via AssignPropertiesToExportPolicy_STATUS & AssignPropertiesFromExportPolicy_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForExportPolicy_STATUS, ExportPolicy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExportPolicy_STATUS tests if a specific instance of ExportPolicy_STATUS can be assigned to v1beta20210901storage and back losslessly
func RunPropertyAssignmentTestForExportPolicy_STATUS(subject ExportPolicy_STATUS) string {
=======
		"Round trip from ExportPolicy_STATUS to ExportPolicy_STATUS via AssignPropertiesToExportPolicySTATUS & AssignPropertiesFromExportPolicySTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForExportPolicySTATUS, ExportPolicySTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExportPolicySTATUS tests if a specific instance of ExportPolicy_STATUS can be assigned to v1beta20210901storage and back losslessly
func RunPropertyAssignmentTestForExportPolicySTATUS(subject ExportPolicy_STATUS) string {
>>>>>>> main
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210901s.ExportPolicy_STATUS
<<<<<<< HEAD
	err := copied.AssignPropertiesToExportPolicy_STATUS(&other)
=======
	err := copied.AssignPropertiesToExportPolicySTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ExportPolicy_STATUS
<<<<<<< HEAD
	err = actual.AssignPropertiesFromExportPolicy_STATUS(&other)
=======
	err = actual.AssignPropertiesFromExportPolicySTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ExportPolicy_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExportPolicy_STATUS via JSON returns original",
<<<<<<< HEAD
		prop.ForAll(RunJSONSerializationTestForExportPolicy_STATUS, ExportPolicy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExportPolicy_STATUS runs a test to see if a specific instance of ExportPolicy_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForExportPolicy_STATUS(subject ExportPolicy_STATUS) string {
=======
		prop.ForAll(RunJSONSerializationTestForExportPolicySTATUS, ExportPolicySTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExportPolicySTATUS runs a test to see if a specific instance of ExportPolicy_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForExportPolicySTATUS(subject ExportPolicy_STATUS) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExportPolicy_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

<<<<<<< HEAD
// Generator of ExportPolicy_STATUS instances for property testing - lazily instantiated by
// ExportPolicy_STATUSGenerator()
var exportPolicy_STATUSGenerator gopter.Gen

// ExportPolicy_STATUSGenerator returns a generator of ExportPolicy_STATUS instances for property testing.
func ExportPolicy_STATUSGenerator() gopter.Gen {
	if exportPolicy_STATUSGenerator != nil {
		return exportPolicy_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExportPolicy_STATUS(generators)
	exportPolicy_STATUSGenerator = gen.Struct(reflect.TypeOf(ExportPolicy_STATUS{}), generators)

	return exportPolicy_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForExportPolicy_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExportPolicy_STATUS(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(gen.OneConstOf(ExportPolicy_Status_Disabled_STATUS, ExportPolicy_Status_Enabled_STATUS))
=======
// Generator of ExportPolicy_STATUS instances for property testing - lazily instantiated by ExportPolicySTATUSGenerator()
var exportPolicySTATUSGenerator gopter.Gen

// ExportPolicySTATUSGenerator returns a generator of ExportPolicy_STATUS instances for property testing.
func ExportPolicySTATUSGenerator() gopter.Gen {
	if exportPolicySTATUSGenerator != nil {
		return exportPolicySTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExportPolicySTATUS(generators)
	exportPolicySTATUSGenerator = gen.Struct(reflect.TypeOf(ExportPolicy_STATUS{}), generators)

	return exportPolicySTATUSGenerator
}

// AddIndependentPropertyGeneratorsForExportPolicySTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExportPolicySTATUS(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(gen.OneConstOf(ExportPolicySTATUSStatus_Disabled, ExportPolicySTATUSStatus_Enabled))
>>>>>>> main
}

func Test_IPRule_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IPRule to IPRule via AssignPropertiesToIPRule & AssignPropertiesFromIPRule returns original",
		prop.ForAll(RunPropertyAssignmentTestForIPRule, IPRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIPRule tests if a specific instance of IPRule can be assigned to v1beta20210901storage and back losslessly
func RunPropertyAssignmentTestForIPRule(subject IPRule) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210901s.IPRule
	err := copied.AssignPropertiesToIPRule(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IPRule
	err = actual.AssignPropertiesFromIPRule(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IPRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IPRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIPRule, IPRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIPRule runs a test to see if a specific instance of IPRule round trips to JSON and back losslessly
func RunJSONSerializationTestForIPRule(subject IPRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IPRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IPRule instances for property testing - lazily instantiated by IPRuleGenerator()
var ipRuleGenerator gopter.Gen

// IPRuleGenerator returns a generator of IPRule instances for property testing.
func IPRuleGenerator() gopter.Gen {
	if ipRuleGenerator != nil {
		return ipRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPRule(generators)
	ipRuleGenerator = gen.Struct(reflect.TypeOf(IPRule{}), generators)

	return ipRuleGenerator
}

// AddIndependentPropertyGeneratorsForIPRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIPRule(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(IPRule_Action_Allow))
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_IPRule_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
<<<<<<< HEAD
		"Round trip from IPRule_STATUS to IPRule_STATUS via AssignPropertiesToIPRule_STATUS & AssignPropertiesFromIPRule_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForIPRule_STATUS, IPRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIPRule_STATUS tests if a specific instance of IPRule_STATUS can be assigned to v1beta20210901storage and back losslessly
func RunPropertyAssignmentTestForIPRule_STATUS(subject IPRule_STATUS) string {
=======
		"Round trip from IPRule_STATUS to IPRule_STATUS via AssignPropertiesToIPRuleSTATUS & AssignPropertiesFromIPRuleSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForIPRuleSTATUS, IPRuleSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIPRuleSTATUS tests if a specific instance of IPRule_STATUS can be assigned to v1beta20210901storage and back losslessly
func RunPropertyAssignmentTestForIPRuleSTATUS(subject IPRule_STATUS) string {
>>>>>>> main
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210901s.IPRule_STATUS
<<<<<<< HEAD
	err := copied.AssignPropertiesToIPRule_STATUS(&other)
=======
	err := copied.AssignPropertiesToIPRuleSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IPRule_STATUS
<<<<<<< HEAD
	err = actual.AssignPropertiesFromIPRule_STATUS(&other)
=======
	err = actual.AssignPropertiesFromIPRuleSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IPRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IPRule_STATUS via JSON returns original",
<<<<<<< HEAD
		prop.ForAll(RunJSONSerializationTestForIPRule_STATUS, IPRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIPRule_STATUS runs a test to see if a specific instance of IPRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForIPRule_STATUS(subject IPRule_STATUS) string {
=======
		prop.ForAll(RunJSONSerializationTestForIPRuleSTATUS, IPRuleSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIPRuleSTATUS runs a test to see if a specific instance of IPRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForIPRuleSTATUS(subject IPRule_STATUS) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IPRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

<<<<<<< HEAD
// Generator of IPRule_STATUS instances for property testing - lazily instantiated by IPRule_STATUSGenerator()
var ipRule_STATUSGenerator gopter.Gen

// IPRule_STATUSGenerator returns a generator of IPRule_STATUS instances for property testing.
func IPRule_STATUSGenerator() gopter.Gen {
	if ipRule_STATUSGenerator != nil {
		return ipRule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPRule_STATUS(generators)
	ipRule_STATUSGenerator = gen.Struct(reflect.TypeOf(IPRule_STATUS{}), generators)

	return ipRule_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForIPRule_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIPRule_STATUS(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(IPRule_Action_Allow_STATUS))
=======
// Generator of IPRule_STATUS instances for property testing - lazily instantiated by IPRuleSTATUSGenerator()
var ipRuleSTATUSGenerator gopter.Gen

// IPRuleSTATUSGenerator returns a generator of IPRule_STATUS instances for property testing.
func IPRuleSTATUSGenerator() gopter.Gen {
	if ipRuleSTATUSGenerator != nil {
		return ipRuleSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPRuleSTATUS(generators)
	ipRuleSTATUSGenerator = gen.Struct(reflect.TypeOf(IPRule_STATUS{}), generators)

	return ipRuleSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForIPRuleSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIPRuleSTATUS(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(IPRuleSTATUSAction_Allow))
>>>>>>> main
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_KeyVaultProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KeyVaultProperties to KeyVaultProperties via AssignPropertiesToKeyVaultProperties & AssignPropertiesFromKeyVaultProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForKeyVaultProperties, KeyVaultPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKeyVaultProperties tests if a specific instance of KeyVaultProperties can be assigned to v1beta20210901storage and back losslessly
func RunPropertyAssignmentTestForKeyVaultProperties(subject KeyVaultProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210901s.KeyVaultProperties
	err := copied.AssignPropertiesToKeyVaultProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KeyVaultProperties
	err = actual.AssignPropertiesFromKeyVaultProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KeyVaultProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultProperties, KeyVaultPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultProperties runs a test to see if a specific instance of KeyVaultProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultProperties(subject KeyVaultProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultProperties instances for property testing - lazily instantiated by KeyVaultPropertiesGenerator()
var keyVaultPropertiesGenerator gopter.Gen

// KeyVaultPropertiesGenerator returns a generator of KeyVaultProperties instances for property testing.
func KeyVaultPropertiesGenerator() gopter.Gen {
	if keyVaultPropertiesGenerator != nil {
		return keyVaultPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultProperties(generators)
	keyVaultPropertiesGenerator = gen.Struct(reflect.TypeOf(KeyVaultProperties{}), generators)

	return keyVaultPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultProperties(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(gen.AlphaString())
	gens["KeyIdentifier"] = gen.PtrOf(gen.AlphaString())
}

func Test_KeyVaultProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
<<<<<<< HEAD
		"Round trip from KeyVaultProperties_STATUS to KeyVaultProperties_STATUS via AssignPropertiesToKeyVaultProperties_STATUS & AssignPropertiesFromKeyVaultProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForKeyVaultProperties_STATUS, KeyVaultProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKeyVaultProperties_STATUS tests if a specific instance of KeyVaultProperties_STATUS can be assigned to v1beta20210901storage and back losslessly
func RunPropertyAssignmentTestForKeyVaultProperties_STATUS(subject KeyVaultProperties_STATUS) string {
=======
		"Round trip from KeyVaultProperties_STATUS to KeyVaultProperties_STATUS via AssignPropertiesToKeyVaultPropertiesSTATUS & AssignPropertiesFromKeyVaultPropertiesSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForKeyVaultPropertiesSTATUS, KeyVaultPropertiesSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKeyVaultPropertiesSTATUS tests if a specific instance of KeyVaultProperties_STATUS can be assigned to v1beta20210901storage and back losslessly
func RunPropertyAssignmentTestForKeyVaultPropertiesSTATUS(subject KeyVaultProperties_STATUS) string {
>>>>>>> main
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210901s.KeyVaultProperties_STATUS
<<<<<<< HEAD
	err := copied.AssignPropertiesToKeyVaultProperties_STATUS(&other)
=======
	err := copied.AssignPropertiesToKeyVaultPropertiesSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KeyVaultProperties_STATUS
<<<<<<< HEAD
	err = actual.AssignPropertiesFromKeyVaultProperties_STATUS(&other)
=======
	err = actual.AssignPropertiesFromKeyVaultPropertiesSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KeyVaultProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultProperties_STATUS via JSON returns original",
<<<<<<< HEAD
		prop.ForAll(RunJSONSerializationTestForKeyVaultProperties_STATUS, KeyVaultProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultProperties_STATUS runs a test to see if a specific instance of KeyVaultProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultProperties_STATUS(subject KeyVaultProperties_STATUS) string {
=======
		prop.ForAll(RunJSONSerializationTestForKeyVaultPropertiesSTATUS, KeyVaultPropertiesSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultPropertiesSTATUS runs a test to see if a specific instance of KeyVaultProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultPropertiesSTATUS(subject KeyVaultProperties_STATUS) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultProperties_STATUS instances for property testing - lazily instantiated by
<<<<<<< HEAD
// KeyVaultProperties_STATUSGenerator()
var keyVaultProperties_STATUSGenerator gopter.Gen

// KeyVaultProperties_STATUSGenerator returns a generator of KeyVaultProperties_STATUS instances for property testing.
func KeyVaultProperties_STATUSGenerator() gopter.Gen {
	if keyVaultProperties_STATUSGenerator != nil {
		return keyVaultProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultProperties_STATUS(generators)
	keyVaultProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(KeyVaultProperties_STATUS{}), generators)

	return keyVaultProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultProperties_STATUS(gens map[string]gopter.Gen) {
=======
// KeyVaultPropertiesSTATUSGenerator()
var keyVaultPropertiesSTATUSGenerator gopter.Gen

// KeyVaultPropertiesSTATUSGenerator returns a generator of KeyVaultProperties_STATUS instances for property testing.
func KeyVaultPropertiesSTATUSGenerator() gopter.Gen {
	if keyVaultPropertiesSTATUSGenerator != nil {
		return keyVaultPropertiesSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultPropertiesSTATUS(generators)
	keyVaultPropertiesSTATUSGenerator = gen.Struct(reflect.TypeOf(KeyVaultProperties_STATUS{}), generators)

	return keyVaultPropertiesSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultPropertiesSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultPropertiesSTATUS(gens map[string]gopter.Gen) {
>>>>>>> main
	gens["Identity"] = gen.PtrOf(gen.AlphaString())
	gens["KeyIdentifier"] = gen.PtrOf(gen.AlphaString())
	gens["KeyRotationEnabled"] = gen.PtrOf(gen.Bool())
	gens["LastKeyRotationTimestamp"] = gen.PtrOf(gen.AlphaString())
	gens["VersionedKeyIdentifier"] = gen.PtrOf(gen.AlphaString())
}

func Test_QuarantinePolicy_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from QuarantinePolicy to QuarantinePolicy via AssignPropertiesToQuarantinePolicy & AssignPropertiesFromQuarantinePolicy returns original",
		prop.ForAll(RunPropertyAssignmentTestForQuarantinePolicy, QuarantinePolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForQuarantinePolicy tests if a specific instance of QuarantinePolicy can be assigned to v1beta20210901storage and back losslessly
func RunPropertyAssignmentTestForQuarantinePolicy(subject QuarantinePolicy) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210901s.QuarantinePolicy
	err := copied.AssignPropertiesToQuarantinePolicy(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual QuarantinePolicy
	err = actual.AssignPropertiesFromQuarantinePolicy(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_QuarantinePolicy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of QuarantinePolicy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForQuarantinePolicy, QuarantinePolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForQuarantinePolicy runs a test to see if a specific instance of QuarantinePolicy round trips to JSON and back losslessly
func RunJSONSerializationTestForQuarantinePolicy(subject QuarantinePolicy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual QuarantinePolicy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of QuarantinePolicy instances for property testing - lazily instantiated by QuarantinePolicyGenerator()
var quarantinePolicyGenerator gopter.Gen

// QuarantinePolicyGenerator returns a generator of QuarantinePolicy instances for property testing.
func QuarantinePolicyGenerator() gopter.Gen {
	if quarantinePolicyGenerator != nil {
		return quarantinePolicyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForQuarantinePolicy(generators)
	quarantinePolicyGenerator = gen.Struct(reflect.TypeOf(QuarantinePolicy{}), generators)

	return quarantinePolicyGenerator
}

// AddIndependentPropertyGeneratorsForQuarantinePolicy is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForQuarantinePolicy(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(gen.OneConstOf(QuarantinePolicy_Status_Disabled, QuarantinePolicy_Status_Enabled))
}

func Test_QuarantinePolicy_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
<<<<<<< HEAD
		"Round trip from QuarantinePolicy_STATUS to QuarantinePolicy_STATUS via AssignPropertiesToQuarantinePolicy_STATUS & AssignPropertiesFromQuarantinePolicy_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForQuarantinePolicy_STATUS, QuarantinePolicy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForQuarantinePolicy_STATUS tests if a specific instance of QuarantinePolicy_STATUS can be assigned to v1beta20210901storage and back losslessly
func RunPropertyAssignmentTestForQuarantinePolicy_STATUS(subject QuarantinePolicy_STATUS) string {
=======
		"Round trip from QuarantinePolicy_STATUS to QuarantinePolicy_STATUS via AssignPropertiesToQuarantinePolicySTATUS & AssignPropertiesFromQuarantinePolicySTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForQuarantinePolicySTATUS, QuarantinePolicySTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForQuarantinePolicySTATUS tests if a specific instance of QuarantinePolicy_STATUS can be assigned to v1beta20210901storage and back losslessly
func RunPropertyAssignmentTestForQuarantinePolicySTATUS(subject QuarantinePolicy_STATUS) string {
>>>>>>> main
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210901s.QuarantinePolicy_STATUS
<<<<<<< HEAD
	err := copied.AssignPropertiesToQuarantinePolicy_STATUS(&other)
=======
	err := copied.AssignPropertiesToQuarantinePolicySTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual QuarantinePolicy_STATUS
<<<<<<< HEAD
	err = actual.AssignPropertiesFromQuarantinePolicy_STATUS(&other)
=======
	err = actual.AssignPropertiesFromQuarantinePolicySTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_QuarantinePolicy_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of QuarantinePolicy_STATUS via JSON returns original",
<<<<<<< HEAD
		prop.ForAll(RunJSONSerializationTestForQuarantinePolicy_STATUS, QuarantinePolicy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForQuarantinePolicy_STATUS runs a test to see if a specific instance of QuarantinePolicy_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForQuarantinePolicy_STATUS(subject QuarantinePolicy_STATUS) string {
=======
		prop.ForAll(RunJSONSerializationTestForQuarantinePolicySTATUS, QuarantinePolicySTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForQuarantinePolicySTATUS runs a test to see if a specific instance of QuarantinePolicy_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForQuarantinePolicySTATUS(subject QuarantinePolicy_STATUS) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual QuarantinePolicy_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of QuarantinePolicy_STATUS instances for property testing - lazily instantiated by
<<<<<<< HEAD
// QuarantinePolicy_STATUSGenerator()
var quarantinePolicy_STATUSGenerator gopter.Gen

// QuarantinePolicy_STATUSGenerator returns a generator of QuarantinePolicy_STATUS instances for property testing.
func QuarantinePolicy_STATUSGenerator() gopter.Gen {
	if quarantinePolicy_STATUSGenerator != nil {
		return quarantinePolicy_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForQuarantinePolicy_STATUS(generators)
	quarantinePolicy_STATUSGenerator = gen.Struct(reflect.TypeOf(QuarantinePolicy_STATUS{}), generators)

	return quarantinePolicy_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForQuarantinePolicy_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForQuarantinePolicy_STATUS(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(gen.OneConstOf(QuarantinePolicy_Status_Disabled_STATUS, QuarantinePolicy_Status_Enabled_STATUS))
=======
// QuarantinePolicySTATUSGenerator()
var quarantinePolicySTATUSGenerator gopter.Gen

// QuarantinePolicySTATUSGenerator returns a generator of QuarantinePolicy_STATUS instances for property testing.
func QuarantinePolicySTATUSGenerator() gopter.Gen {
	if quarantinePolicySTATUSGenerator != nil {
		return quarantinePolicySTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForQuarantinePolicySTATUS(generators)
	quarantinePolicySTATUSGenerator = gen.Struct(reflect.TypeOf(QuarantinePolicy_STATUS{}), generators)

	return quarantinePolicySTATUSGenerator
}

// AddIndependentPropertyGeneratorsForQuarantinePolicySTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForQuarantinePolicySTATUS(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(gen.OneConstOf(QuarantinePolicySTATUSStatus_Disabled, QuarantinePolicySTATUSStatus_Enabled))
>>>>>>> main
}

func Test_RetentionPolicy_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RetentionPolicy to RetentionPolicy via AssignPropertiesToRetentionPolicy & AssignPropertiesFromRetentionPolicy returns original",
		prop.ForAll(RunPropertyAssignmentTestForRetentionPolicy, RetentionPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRetentionPolicy tests if a specific instance of RetentionPolicy can be assigned to v1beta20210901storage and back losslessly
func RunPropertyAssignmentTestForRetentionPolicy(subject RetentionPolicy) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210901s.RetentionPolicy
	err := copied.AssignPropertiesToRetentionPolicy(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RetentionPolicy
	err = actual.AssignPropertiesFromRetentionPolicy(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RetentionPolicy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RetentionPolicy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRetentionPolicy, RetentionPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRetentionPolicy runs a test to see if a specific instance of RetentionPolicy round trips to JSON and back losslessly
func RunJSONSerializationTestForRetentionPolicy(subject RetentionPolicy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RetentionPolicy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RetentionPolicy instances for property testing - lazily instantiated by RetentionPolicyGenerator()
var retentionPolicyGenerator gopter.Gen

// RetentionPolicyGenerator returns a generator of RetentionPolicy instances for property testing.
func RetentionPolicyGenerator() gopter.Gen {
	if retentionPolicyGenerator != nil {
		return retentionPolicyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRetentionPolicy(generators)
	retentionPolicyGenerator = gen.Struct(reflect.TypeOf(RetentionPolicy{}), generators)

	return retentionPolicyGenerator
}

// AddIndependentPropertyGeneratorsForRetentionPolicy is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRetentionPolicy(gens map[string]gopter.Gen) {
	gens["Days"] = gen.PtrOf(gen.Int())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(RetentionPolicy_Status_Disabled, RetentionPolicy_Status_Enabled))
}

func Test_RetentionPolicy_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
<<<<<<< HEAD
		"Round trip from RetentionPolicy_STATUS to RetentionPolicy_STATUS via AssignPropertiesToRetentionPolicy_STATUS & AssignPropertiesFromRetentionPolicy_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForRetentionPolicy_STATUS, RetentionPolicy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRetentionPolicy_STATUS tests if a specific instance of RetentionPolicy_STATUS can be assigned to v1beta20210901storage and back losslessly
func RunPropertyAssignmentTestForRetentionPolicy_STATUS(subject RetentionPolicy_STATUS) string {
=======
		"Round trip from RetentionPolicy_STATUS to RetentionPolicy_STATUS via AssignPropertiesToRetentionPolicySTATUS & AssignPropertiesFromRetentionPolicySTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForRetentionPolicySTATUS, RetentionPolicySTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRetentionPolicySTATUS tests if a specific instance of RetentionPolicy_STATUS can be assigned to v1beta20210901storage and back losslessly
func RunPropertyAssignmentTestForRetentionPolicySTATUS(subject RetentionPolicy_STATUS) string {
>>>>>>> main
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210901s.RetentionPolicy_STATUS
<<<<<<< HEAD
	err := copied.AssignPropertiesToRetentionPolicy_STATUS(&other)
=======
	err := copied.AssignPropertiesToRetentionPolicySTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RetentionPolicy_STATUS
<<<<<<< HEAD
	err = actual.AssignPropertiesFromRetentionPolicy_STATUS(&other)
=======
	err = actual.AssignPropertiesFromRetentionPolicySTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RetentionPolicy_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RetentionPolicy_STATUS via JSON returns original",
<<<<<<< HEAD
		prop.ForAll(RunJSONSerializationTestForRetentionPolicy_STATUS, RetentionPolicy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRetentionPolicy_STATUS runs a test to see if a specific instance of RetentionPolicy_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRetentionPolicy_STATUS(subject RetentionPolicy_STATUS) string {
=======
		prop.ForAll(RunJSONSerializationTestForRetentionPolicySTATUS, RetentionPolicySTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRetentionPolicySTATUS runs a test to see if a specific instance of RetentionPolicy_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRetentionPolicySTATUS(subject RetentionPolicy_STATUS) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RetentionPolicy_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RetentionPolicy_STATUS instances for property testing - lazily instantiated by
<<<<<<< HEAD
// RetentionPolicy_STATUSGenerator()
var retentionPolicy_STATUSGenerator gopter.Gen

// RetentionPolicy_STATUSGenerator returns a generator of RetentionPolicy_STATUS instances for property testing.
func RetentionPolicy_STATUSGenerator() gopter.Gen {
	if retentionPolicy_STATUSGenerator != nil {
		return retentionPolicy_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRetentionPolicy_STATUS(generators)
	retentionPolicy_STATUSGenerator = gen.Struct(reflect.TypeOf(RetentionPolicy_STATUS{}), generators)

	return retentionPolicy_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForRetentionPolicy_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRetentionPolicy_STATUS(gens map[string]gopter.Gen) {
	gens["Days"] = gen.PtrOf(gen.Int())
	gens["LastUpdatedTime"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(RetentionPolicy_Status_Disabled_STATUS, RetentionPolicy_Status_Enabled_STATUS))
=======
// RetentionPolicySTATUSGenerator()
var retentionPolicySTATUSGenerator gopter.Gen

// RetentionPolicySTATUSGenerator returns a generator of RetentionPolicy_STATUS instances for property testing.
func RetentionPolicySTATUSGenerator() gopter.Gen {
	if retentionPolicySTATUSGenerator != nil {
		return retentionPolicySTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRetentionPolicySTATUS(generators)
	retentionPolicySTATUSGenerator = gen.Struct(reflect.TypeOf(RetentionPolicy_STATUS{}), generators)

	return retentionPolicySTATUSGenerator
}

// AddIndependentPropertyGeneratorsForRetentionPolicySTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRetentionPolicySTATUS(gens map[string]gopter.Gen) {
	gens["Days"] = gen.PtrOf(gen.Int())
	gens["LastUpdatedTime"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(RetentionPolicySTATUSStatus_Disabled, RetentionPolicySTATUSStatus_Enabled))
>>>>>>> main
}

func Test_TrustPolicy_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from TrustPolicy to TrustPolicy via AssignPropertiesToTrustPolicy & AssignPropertiesFromTrustPolicy returns original",
		prop.ForAll(RunPropertyAssignmentTestForTrustPolicy, TrustPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForTrustPolicy tests if a specific instance of TrustPolicy can be assigned to v1beta20210901storage and back losslessly
func RunPropertyAssignmentTestForTrustPolicy(subject TrustPolicy) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210901s.TrustPolicy
	err := copied.AssignPropertiesToTrustPolicy(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual TrustPolicy
	err = actual.AssignPropertiesFromTrustPolicy(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_TrustPolicy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TrustPolicy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTrustPolicy, TrustPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTrustPolicy runs a test to see if a specific instance of TrustPolicy round trips to JSON and back losslessly
func RunJSONSerializationTestForTrustPolicy(subject TrustPolicy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TrustPolicy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TrustPolicy instances for property testing - lazily instantiated by TrustPolicyGenerator()
var trustPolicyGenerator gopter.Gen

// TrustPolicyGenerator returns a generator of TrustPolicy instances for property testing.
func TrustPolicyGenerator() gopter.Gen {
	if trustPolicyGenerator != nil {
		return trustPolicyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTrustPolicy(generators)
	trustPolicyGenerator = gen.Struct(reflect.TypeOf(TrustPolicy{}), generators)

	return trustPolicyGenerator
}

// AddIndependentPropertyGeneratorsForTrustPolicy is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTrustPolicy(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(gen.OneConstOf(TrustPolicy_Status_Disabled, TrustPolicy_Status_Enabled))
	gens["Type"] = gen.PtrOf(gen.OneConstOf(TrustPolicy_Type_Notary))
}

func Test_TrustPolicy_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
<<<<<<< HEAD
		"Round trip from TrustPolicy_STATUS to TrustPolicy_STATUS via AssignPropertiesToTrustPolicy_STATUS & AssignPropertiesFromTrustPolicy_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForTrustPolicy_STATUS, TrustPolicy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForTrustPolicy_STATUS tests if a specific instance of TrustPolicy_STATUS can be assigned to v1beta20210901storage and back losslessly
func RunPropertyAssignmentTestForTrustPolicy_STATUS(subject TrustPolicy_STATUS) string {
=======
		"Round trip from TrustPolicy_STATUS to TrustPolicy_STATUS via AssignPropertiesToTrustPolicySTATUS & AssignPropertiesFromTrustPolicySTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForTrustPolicySTATUS, TrustPolicySTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForTrustPolicySTATUS tests if a specific instance of TrustPolicy_STATUS can be assigned to v1beta20210901storage and back losslessly
func RunPropertyAssignmentTestForTrustPolicySTATUS(subject TrustPolicy_STATUS) string {
>>>>>>> main
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210901s.TrustPolicy_STATUS
<<<<<<< HEAD
	err := copied.AssignPropertiesToTrustPolicy_STATUS(&other)
=======
	err := copied.AssignPropertiesToTrustPolicySTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual TrustPolicy_STATUS
<<<<<<< HEAD
	err = actual.AssignPropertiesFromTrustPolicy_STATUS(&other)
=======
	err = actual.AssignPropertiesFromTrustPolicySTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_TrustPolicy_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TrustPolicy_STATUS via JSON returns original",
<<<<<<< HEAD
		prop.ForAll(RunJSONSerializationTestForTrustPolicy_STATUS, TrustPolicy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTrustPolicy_STATUS runs a test to see if a specific instance of TrustPolicy_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForTrustPolicy_STATUS(subject TrustPolicy_STATUS) string {
=======
		prop.ForAll(RunJSONSerializationTestForTrustPolicySTATUS, TrustPolicySTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTrustPolicySTATUS runs a test to see if a specific instance of TrustPolicy_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForTrustPolicySTATUS(subject TrustPolicy_STATUS) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TrustPolicy_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

<<<<<<< HEAD
// Generator of TrustPolicy_STATUS instances for property testing - lazily instantiated by TrustPolicy_STATUSGenerator()
var trustPolicy_STATUSGenerator gopter.Gen

// TrustPolicy_STATUSGenerator returns a generator of TrustPolicy_STATUS instances for property testing.
func TrustPolicy_STATUSGenerator() gopter.Gen {
	if trustPolicy_STATUSGenerator != nil {
		return trustPolicy_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTrustPolicy_STATUS(generators)
	trustPolicy_STATUSGenerator = gen.Struct(reflect.TypeOf(TrustPolicy_STATUS{}), generators)

	return trustPolicy_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForTrustPolicy_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTrustPolicy_STATUS(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(gen.OneConstOf(TrustPolicy_Status_Disabled_STATUS, TrustPolicy_Status_Enabled_STATUS))
	gens["Type"] = gen.PtrOf(gen.OneConstOf(TrustPolicy_Type_Notary_STATUS))
=======
// Generator of TrustPolicy_STATUS instances for property testing - lazily instantiated by TrustPolicySTATUSGenerator()
var trustPolicySTATUSGenerator gopter.Gen

// TrustPolicySTATUSGenerator returns a generator of TrustPolicy_STATUS instances for property testing.
func TrustPolicySTATUSGenerator() gopter.Gen {
	if trustPolicySTATUSGenerator != nil {
		return trustPolicySTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTrustPolicySTATUS(generators)
	trustPolicySTATUSGenerator = gen.Struct(reflect.TypeOf(TrustPolicy_STATUS{}), generators)

	return trustPolicySTATUSGenerator
}

// AddIndependentPropertyGeneratorsForTrustPolicySTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTrustPolicySTATUS(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(gen.OneConstOf(TrustPolicySTATUSStatus_Disabled, TrustPolicySTATUSStatus_Enabled))
	gens["Type"] = gen.PtrOf(gen.OneConstOf(TrustPolicySTATUSType_Notary))
>>>>>>> main
}

func Test_UserIdentityProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UserIdentityProperties to UserIdentityProperties via AssignPropertiesToUserIdentityProperties & AssignPropertiesFromUserIdentityProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForUserIdentityProperties, UserIdentityPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUserIdentityProperties tests if a specific instance of UserIdentityProperties can be assigned to v1beta20210901storage and back losslessly
func RunPropertyAssignmentTestForUserIdentityProperties(subject UserIdentityProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210901s.UserIdentityProperties
	err := copied.AssignPropertiesToUserIdentityProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UserIdentityProperties
	err = actual.AssignPropertiesFromUserIdentityProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UserIdentityProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserIdentityProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserIdentityProperties, UserIdentityPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserIdentityProperties runs a test to see if a specific instance of UserIdentityProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForUserIdentityProperties(subject UserIdentityProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserIdentityProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserIdentityProperties instances for property testing - lazily instantiated by
// UserIdentityPropertiesGenerator()
var userIdentityPropertiesGenerator gopter.Gen

// UserIdentityPropertiesGenerator returns a generator of UserIdentityProperties instances for property testing.
func UserIdentityPropertiesGenerator() gopter.Gen {
	if userIdentityPropertiesGenerator != nil {
		return userIdentityPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserIdentityProperties(generators)
	userIdentityPropertiesGenerator = gen.Struct(reflect.TypeOf(UserIdentityProperties{}), generators)

	return userIdentityPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForUserIdentityProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserIdentityProperties(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_UserIdentityProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
<<<<<<< HEAD
		"Round trip from UserIdentityProperties_STATUS to UserIdentityProperties_STATUS via AssignPropertiesToUserIdentityProperties_STATUS & AssignPropertiesFromUserIdentityProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForUserIdentityProperties_STATUS, UserIdentityProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUserIdentityProperties_STATUS tests if a specific instance of UserIdentityProperties_STATUS can be assigned to v1beta20210901storage and back losslessly
func RunPropertyAssignmentTestForUserIdentityProperties_STATUS(subject UserIdentityProperties_STATUS) string {
=======
		"Round trip from UserIdentityProperties_STATUS to UserIdentityProperties_STATUS via AssignPropertiesToUserIdentityPropertiesSTATUS & AssignPropertiesFromUserIdentityPropertiesSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForUserIdentityPropertiesSTATUS, UserIdentityPropertiesSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUserIdentityPropertiesSTATUS tests if a specific instance of UserIdentityProperties_STATUS can be assigned to v1beta20210901storage and back losslessly
func RunPropertyAssignmentTestForUserIdentityPropertiesSTATUS(subject UserIdentityProperties_STATUS) string {
>>>>>>> main
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210901s.UserIdentityProperties_STATUS
<<<<<<< HEAD
	err := copied.AssignPropertiesToUserIdentityProperties_STATUS(&other)
=======
	err := copied.AssignPropertiesToUserIdentityPropertiesSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UserIdentityProperties_STATUS
<<<<<<< HEAD
	err = actual.AssignPropertiesFromUserIdentityProperties_STATUS(&other)
=======
	err = actual.AssignPropertiesFromUserIdentityPropertiesSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UserIdentityProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserIdentityProperties_STATUS via JSON returns original",
<<<<<<< HEAD
		prop.ForAll(RunJSONSerializationTestForUserIdentityProperties_STATUS, UserIdentityProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserIdentityProperties_STATUS runs a test to see if a specific instance of UserIdentityProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUserIdentityProperties_STATUS(subject UserIdentityProperties_STATUS) string {
=======
		prop.ForAll(RunJSONSerializationTestForUserIdentityPropertiesSTATUS, UserIdentityPropertiesSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserIdentityPropertiesSTATUS runs a test to see if a specific instance of UserIdentityProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUserIdentityPropertiesSTATUS(subject UserIdentityProperties_STATUS) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserIdentityProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserIdentityProperties_STATUS instances for property testing - lazily instantiated by
<<<<<<< HEAD
// UserIdentityProperties_STATUSGenerator()
var userIdentityProperties_STATUSGenerator gopter.Gen

// UserIdentityProperties_STATUSGenerator returns a generator of UserIdentityProperties_STATUS instances for property testing.
func UserIdentityProperties_STATUSGenerator() gopter.Gen {
	if userIdentityProperties_STATUSGenerator != nil {
		return userIdentityProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserIdentityProperties_STATUS(generators)
	userIdentityProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(UserIdentityProperties_STATUS{}), generators)

	return userIdentityProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForUserIdentityProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserIdentityProperties_STATUS(gens map[string]gopter.Gen) {
=======
// UserIdentityPropertiesSTATUSGenerator()
var userIdentityPropertiesSTATUSGenerator gopter.Gen

// UserIdentityPropertiesSTATUSGenerator returns a generator of UserIdentityProperties_STATUS instances for property testing.
func UserIdentityPropertiesSTATUSGenerator() gopter.Gen {
	if userIdentityPropertiesSTATUSGenerator != nil {
		return userIdentityPropertiesSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserIdentityPropertiesSTATUS(generators)
	userIdentityPropertiesSTATUSGenerator = gen.Struct(reflect.TypeOf(UserIdentityProperties_STATUS{}), generators)

	return userIdentityPropertiesSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForUserIdentityPropertiesSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserIdentityPropertiesSTATUS(gens map[string]gopter.Gen) {
>>>>>>> main
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}
