// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20210901

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_Registry_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Registry_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRegistry_STATUSARM, Registry_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRegistry_STATUSARM runs a test to see if a specific instance of Registry_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRegistry_STATUSARM(subject Registry_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Registry_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Registry_STATUSARM instances for property testing - lazily instantiated by Registry_STATUSARMGenerator()
var registry_STATUSARMGenerator gopter.Gen

// Registry_STATUSARMGenerator returns a generator of Registry_STATUSARM instances for property testing.
// We first initialize registry_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Registry_STATUSARMGenerator() gopter.Gen {
	if registry_STATUSARMGenerator != nil {
		return registry_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRegistry_STATUSARM(generators)
	registry_STATUSARMGenerator = gen.Struct(reflect.TypeOf(Registry_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRegistry_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForRegistry_STATUSARM(generators)
	registry_STATUSARMGenerator = gen.Struct(reflect.TypeOf(Registry_STATUSARM{}), generators)

	return registry_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForRegistry_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRegistry_STATUSARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForRegistry_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRegistry_STATUSARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(IdentityProperties_STATUSARMGenerator())
	gens["Properties"] = gen.PtrOf(RegistryProperties_STATUSARMGenerator())
	gens["Sku"] = gen.PtrOf(Sku_STATUSARMGenerator())
	gens["SystemData"] = gen.PtrOf(SystemData_STATUSARMGenerator())
}

func Test_IdentityProperties_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IdentityProperties_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIdentityProperties_STATUSARM, IdentityProperties_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIdentityProperties_STATUSARM runs a test to see if a specific instance of IdentityProperties_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIdentityProperties_STATUSARM(subject IdentityProperties_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IdentityProperties_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IdentityProperties_STATUSARM instances for property testing - lazily instantiated by
// IdentityProperties_STATUSARMGenerator()
var identityProperties_STATUSARMGenerator gopter.Gen

// IdentityProperties_STATUSARMGenerator returns a generator of IdentityProperties_STATUSARM instances for property testing.
// We first initialize identityProperties_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IdentityProperties_STATUSARMGenerator() gopter.Gen {
	if identityProperties_STATUSARMGenerator != nil {
		return identityProperties_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentityProperties_STATUSARM(generators)
	identityProperties_STATUSARMGenerator = gen.Struct(reflect.TypeOf(IdentityProperties_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentityProperties_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForIdentityProperties_STATUSARM(generators)
	identityProperties_STATUSARMGenerator = gen.Struct(reflect.TypeOf(IdentityProperties_STATUSARM{}), generators)

	return identityProperties_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForIdentityProperties_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIdentityProperties_STATUSARM(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		IdentityProperties_STATUS_Type_None,
		IdentityProperties_STATUS_Type_SystemAssigned,
		IdentityProperties_STATUS_Type_SystemAssignedUserAssigned,
		IdentityProperties_STATUS_Type_UserAssigned))
}

// AddRelatedPropertyGeneratorsForIdentityProperties_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIdentityProperties_STATUSARM(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), UserIdentityProperties_STATUSARMGenerator())
}

func Test_RegistryProperties_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RegistryProperties_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRegistryProperties_STATUSARM, RegistryProperties_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRegistryProperties_STATUSARM runs a test to see if a specific instance of RegistryProperties_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRegistryProperties_STATUSARM(subject RegistryProperties_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RegistryProperties_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RegistryProperties_STATUSARM instances for property testing - lazily instantiated by
// RegistryProperties_STATUSARMGenerator()
var registryProperties_STATUSARMGenerator gopter.Gen

// RegistryProperties_STATUSARMGenerator returns a generator of RegistryProperties_STATUSARM instances for property testing.
// We first initialize registryProperties_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RegistryProperties_STATUSARMGenerator() gopter.Gen {
	if registryProperties_STATUSARMGenerator != nil {
		return registryProperties_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRegistryProperties_STATUSARM(generators)
	registryProperties_STATUSARMGenerator = gen.Struct(reflect.TypeOf(RegistryProperties_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRegistryProperties_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForRegistryProperties_STATUSARM(generators)
	registryProperties_STATUSARMGenerator = gen.Struct(reflect.TypeOf(RegistryProperties_STATUSARM{}), generators)

	return registryProperties_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForRegistryProperties_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRegistryProperties_STATUSARM(gens map[string]gopter.Gen) {
	gens["AdminUserEnabled"] = gen.PtrOf(gen.Bool())
	gens["CreationDate"] = gen.PtrOf(gen.AlphaString())
	gens["DataEndpointEnabled"] = gen.PtrOf(gen.Bool())
	gens["DataEndpointHostNames"] = gen.SliceOf(gen.AlphaString())
	gens["LoginServer"] = gen.PtrOf(gen.AlphaString())
	gens["NetworkRuleBypassOptions"] = gen.PtrOf(gen.OneConstOf(RegistryProperties_STATUS_NetworkRuleBypassOptions_AzureServices, RegistryProperties_STATUS_NetworkRuleBypassOptions_None))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		RegistryProperties_STATUS_ProvisioningState_Canceled,
		RegistryProperties_STATUS_ProvisioningState_Creating,
		RegistryProperties_STATUS_ProvisioningState_Deleting,
		RegistryProperties_STATUS_ProvisioningState_Failed,
		RegistryProperties_STATUS_ProvisioningState_Succeeded,
		RegistryProperties_STATUS_ProvisioningState_Updating))
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(RegistryProperties_STATUS_PublicNetworkAccess_Disabled, RegistryProperties_STATUS_PublicNetworkAccess_Enabled))
	gens["ZoneRedundancy"] = gen.PtrOf(gen.OneConstOf(RegistryProperties_STATUS_ZoneRedundancy_Disabled, RegistryProperties_STATUS_ZoneRedundancy_Enabled))
}

// AddRelatedPropertyGeneratorsForRegistryProperties_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRegistryProperties_STATUSARM(gens map[string]gopter.Gen) {
	gens["Encryption"] = gen.PtrOf(EncryptionProperty_STATUSARMGenerator())
	gens["NetworkRuleSet"] = gen.PtrOf(NetworkRuleSet_STATUSARMGenerator())
	gens["Policies"] = gen.PtrOf(Policies_STATUSARMGenerator())
	gens["PrivateEndpointConnections"] = gen.SliceOf(PrivateEndpointConnection_STATUS_SubResourceEmbeddedARMGenerator())
	gens["Status"] = gen.PtrOf(Status_STATUSARMGenerator())
}

func Test_Sku_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sku_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSku_STATUSARM, Sku_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSku_STATUSARM runs a test to see if a specific instance of Sku_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSku_STATUSARM(subject Sku_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sku_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sku_STATUSARM instances for property testing - lazily instantiated by Sku_STATUSARMGenerator()
var sku_STATUSARMGenerator gopter.Gen

// Sku_STATUSARMGenerator returns a generator of Sku_STATUSARM instances for property testing.
func Sku_STATUSARMGenerator() gopter.Gen {
	if sku_STATUSARMGenerator != nil {
		return sku_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSku_STATUSARM(generators)
	sku_STATUSARMGenerator = gen.Struct(reflect.TypeOf(Sku_STATUSARM{}), generators)

	return sku_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForSku_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSku_STATUSARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(
		Sku_STATUS_Name_Basic,
		Sku_STATUS_Name_Classic,
		Sku_STATUS_Name_Premium,
		Sku_STATUS_Name_Standard))
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(
		Sku_STATUS_Tier_Basic,
		Sku_STATUS_Tier_Classic,
		Sku_STATUS_Tier_Premium,
		Sku_STATUS_Tier_Standard))
}

func Test_SystemData_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SystemData_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSystemData_STATUSARM, SystemData_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSystemData_STATUSARM runs a test to see if a specific instance of SystemData_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSystemData_STATUSARM(subject SystemData_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SystemData_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SystemData_STATUSARM instances for property testing - lazily instantiated by
// SystemData_STATUSARMGenerator()
var systemData_STATUSARMGenerator gopter.Gen

// SystemData_STATUSARMGenerator returns a generator of SystemData_STATUSARM instances for property testing.
func SystemData_STATUSARMGenerator() gopter.Gen {
	if systemData_STATUSARMGenerator != nil {
		return systemData_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSystemData_STATUSARM(generators)
	systemData_STATUSARMGenerator = gen.Struct(reflect.TypeOf(SystemData_STATUSARM{}), generators)

	return systemData_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForSystemData_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSystemData_STATUSARM(gens map[string]gopter.Gen) {
	gens["CreatedAt"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedBy"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemData_STATUS_CreatedByType_Application,
		SystemData_STATUS_CreatedByType_Key,
		SystemData_STATUS_CreatedByType_ManagedIdentity,
		SystemData_STATUS_CreatedByType_User))
	gens["LastModifiedAt"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedBy"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemData_STATUS_LastModifiedByType_Application,
		SystemData_STATUS_LastModifiedByType_Key,
		SystemData_STATUS_LastModifiedByType_ManagedIdentity,
		SystemData_STATUS_LastModifiedByType_User))
}

func Test_EncryptionProperty_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionProperty_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionProperty_STATUSARM, EncryptionProperty_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionProperty_STATUSARM runs a test to see if a specific instance of EncryptionProperty_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionProperty_STATUSARM(subject EncryptionProperty_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionProperty_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionProperty_STATUSARM instances for property testing - lazily instantiated by
// EncryptionProperty_STATUSARMGenerator()
var encryptionProperty_STATUSARMGenerator gopter.Gen

// EncryptionProperty_STATUSARMGenerator returns a generator of EncryptionProperty_STATUSARM instances for property testing.
// We first initialize encryptionProperty_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EncryptionProperty_STATUSARMGenerator() gopter.Gen {
	if encryptionProperty_STATUSARMGenerator != nil {
		return encryptionProperty_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionProperty_STATUSARM(generators)
	encryptionProperty_STATUSARMGenerator = gen.Struct(reflect.TypeOf(EncryptionProperty_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionProperty_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForEncryptionProperty_STATUSARM(generators)
	encryptionProperty_STATUSARMGenerator = gen.Struct(reflect.TypeOf(EncryptionProperty_STATUSARM{}), generators)

	return encryptionProperty_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionProperty_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionProperty_STATUSARM(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(gen.OneConstOf(EncryptionProperty_STATUS_Status_Disabled, EncryptionProperty_STATUS_Status_Enabled))
}

// AddRelatedPropertyGeneratorsForEncryptionProperty_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionProperty_STATUSARM(gens map[string]gopter.Gen) {
	gens["KeyVaultProperties"] = gen.PtrOf(KeyVaultProperties_STATUSARMGenerator())
}

func Test_NetworkRuleSet_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkRuleSet_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkRuleSet_STATUSARM, NetworkRuleSet_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkRuleSet_STATUSARM runs a test to see if a specific instance of NetworkRuleSet_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkRuleSet_STATUSARM(subject NetworkRuleSet_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkRuleSet_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkRuleSet_STATUSARM instances for property testing - lazily instantiated by
// NetworkRuleSet_STATUSARMGenerator()
var networkRuleSet_STATUSARMGenerator gopter.Gen

// NetworkRuleSet_STATUSARMGenerator returns a generator of NetworkRuleSet_STATUSARM instances for property testing.
// We first initialize networkRuleSet_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkRuleSet_STATUSARMGenerator() gopter.Gen {
	if networkRuleSet_STATUSARMGenerator != nil {
		return networkRuleSet_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSet_STATUSARM(generators)
	networkRuleSet_STATUSARMGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSet_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForNetworkRuleSet_STATUSARM(generators)
	networkRuleSet_STATUSARMGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet_STATUSARM{}), generators)

	return networkRuleSet_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkRuleSet_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkRuleSet_STATUSARM(gens map[string]gopter.Gen) {
	gens["DefaultAction"] = gen.PtrOf(gen.OneConstOf(NetworkRuleSet_STATUS_DefaultAction_Allow, NetworkRuleSet_STATUS_DefaultAction_Deny))
}

// AddRelatedPropertyGeneratorsForNetworkRuleSet_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkRuleSet_STATUSARM(gens map[string]gopter.Gen) {
	gens["IpRules"] = gen.SliceOf(IPRule_STATUSARMGenerator())
}

func Test_Policies_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Policies_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPolicies_STATUSARM, Policies_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPolicies_STATUSARM runs a test to see if a specific instance of Policies_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPolicies_STATUSARM(subject Policies_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Policies_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Policies_STATUSARM instances for property testing - lazily instantiated by Policies_STATUSARMGenerator()
var policies_STATUSARMGenerator gopter.Gen

// Policies_STATUSARMGenerator returns a generator of Policies_STATUSARM instances for property testing.
func Policies_STATUSARMGenerator() gopter.Gen {
	if policies_STATUSARMGenerator != nil {
		return policies_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForPolicies_STATUSARM(generators)
	policies_STATUSARMGenerator = gen.Struct(reflect.TypeOf(Policies_STATUSARM{}), generators)

	return policies_STATUSARMGenerator
}

// AddRelatedPropertyGeneratorsForPolicies_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPolicies_STATUSARM(gens map[string]gopter.Gen) {
	gens["ExportPolicy"] = gen.PtrOf(ExportPolicy_STATUSARMGenerator())
	gens["QuarantinePolicy"] = gen.PtrOf(QuarantinePolicy_STATUSARMGenerator())
	gens["RetentionPolicy"] = gen.PtrOf(RetentionPolicy_STATUSARMGenerator())
	gens["TrustPolicy"] = gen.PtrOf(TrustPolicy_STATUSARMGenerator())
}

func Test_PrivateEndpointConnection_STATUS_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointConnection_STATUS_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointConnection_STATUS_SubResourceEmbeddedARM, PrivateEndpointConnection_STATUS_SubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointConnection_STATUS_SubResourceEmbeddedARM runs a test to see if a specific instance of PrivateEndpointConnection_STATUS_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointConnection_STATUS_SubResourceEmbeddedARM(subject PrivateEndpointConnection_STATUS_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointConnection_STATUS_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointConnection_STATUS_SubResourceEmbeddedARM instances for property testing - lazily
// instantiated by PrivateEndpointConnection_STATUS_SubResourceEmbeddedARMGenerator()
var privateEndpointConnection_STATUS_SubResourceEmbeddedARMGenerator gopter.Gen

// PrivateEndpointConnection_STATUS_SubResourceEmbeddedARMGenerator returns a generator of PrivateEndpointConnection_STATUS_SubResourceEmbeddedARM instances for property testing.
// We first initialize privateEndpointConnection_STATUS_SubResourceEmbeddedARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateEndpointConnection_STATUS_SubResourceEmbeddedARMGenerator() gopter.Gen {
	if privateEndpointConnection_STATUS_SubResourceEmbeddedARMGenerator != nil {
		return privateEndpointConnection_STATUS_SubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnection_STATUS_SubResourceEmbeddedARM(generators)
	privateEndpointConnection_STATUS_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnection_STATUS_SubResourceEmbeddedARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnection_STATUS_SubResourceEmbeddedARM(generators)
	AddRelatedPropertyGeneratorsForPrivateEndpointConnection_STATUS_SubResourceEmbeddedARM(generators)
	privateEndpointConnection_STATUS_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnection_STATUS_SubResourceEmbeddedARM{}), generators)

	return privateEndpointConnection_STATUS_SubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointConnection_STATUS_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointConnection_STATUS_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPrivateEndpointConnection_STATUS_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateEndpointConnection_STATUS_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["SystemData"] = gen.PtrOf(SystemData_STATUSARMGenerator())
}

func Test_Status_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Status_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStatus_STATUSARM, Status_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStatus_STATUSARM runs a test to see if a specific instance of Status_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStatus_STATUSARM(subject Status_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Status_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Status_STATUSARM instances for property testing - lazily instantiated by Status_STATUSARMGenerator()
var status_STATUSARMGenerator gopter.Gen

// Status_STATUSARMGenerator returns a generator of Status_STATUSARM instances for property testing.
func Status_STATUSARMGenerator() gopter.Gen {
	if status_STATUSARMGenerator != nil {
		return status_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStatus_STATUSARM(generators)
	status_STATUSARMGenerator = gen.Struct(reflect.TypeOf(Status_STATUSARM{}), generators)

	return status_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForStatus_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStatus_STATUSARM(gens map[string]gopter.Gen) {
	gens["DisplayStatus"] = gen.PtrOf(gen.AlphaString())
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Timestamp"] = gen.PtrOf(gen.AlphaString())
}

func Test_UserIdentityProperties_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserIdentityProperties_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserIdentityProperties_STATUSARM, UserIdentityProperties_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserIdentityProperties_STATUSARM runs a test to see if a specific instance of UserIdentityProperties_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUserIdentityProperties_STATUSARM(subject UserIdentityProperties_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserIdentityProperties_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserIdentityProperties_STATUSARM instances for property testing - lazily instantiated by
// UserIdentityProperties_STATUSARMGenerator()
var userIdentityProperties_STATUSARMGenerator gopter.Gen

// UserIdentityProperties_STATUSARMGenerator returns a generator of UserIdentityProperties_STATUSARM instances for property testing.
func UserIdentityProperties_STATUSARMGenerator() gopter.Gen {
	if userIdentityProperties_STATUSARMGenerator != nil {
		return userIdentityProperties_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserIdentityProperties_STATUSARM(generators)
	userIdentityProperties_STATUSARMGenerator = gen.Struct(reflect.TypeOf(UserIdentityProperties_STATUSARM{}), generators)

	return userIdentityProperties_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForUserIdentityProperties_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserIdentityProperties_STATUSARM(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_ExportPolicy_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExportPolicy_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExportPolicy_STATUSARM, ExportPolicy_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExportPolicy_STATUSARM runs a test to see if a specific instance of ExportPolicy_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForExportPolicy_STATUSARM(subject ExportPolicy_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExportPolicy_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExportPolicy_STATUSARM instances for property testing - lazily instantiated by
// ExportPolicy_STATUSARMGenerator()
var exportPolicy_STATUSARMGenerator gopter.Gen

// ExportPolicy_STATUSARMGenerator returns a generator of ExportPolicy_STATUSARM instances for property testing.
func ExportPolicy_STATUSARMGenerator() gopter.Gen {
	if exportPolicy_STATUSARMGenerator != nil {
		return exportPolicy_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExportPolicy_STATUSARM(generators)
	exportPolicy_STATUSARMGenerator = gen.Struct(reflect.TypeOf(ExportPolicy_STATUSARM{}), generators)

	return exportPolicy_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForExportPolicy_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExportPolicy_STATUSARM(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(gen.OneConstOf(ExportPolicy_STATUS_Status_Disabled, ExportPolicy_STATUS_Status_Enabled))
}

func Test_IPRule_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IPRule_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIPRule_STATUSARM, IPRule_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIPRule_STATUSARM runs a test to see if a specific instance of IPRule_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIPRule_STATUSARM(subject IPRule_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IPRule_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IPRule_STATUSARM instances for property testing - lazily instantiated by IPRule_STATUSARMGenerator()
var ipRule_STATUSARMGenerator gopter.Gen

// IPRule_STATUSARMGenerator returns a generator of IPRule_STATUSARM instances for property testing.
func IPRule_STATUSARMGenerator() gopter.Gen {
	if ipRule_STATUSARMGenerator != nil {
		return ipRule_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPRule_STATUSARM(generators)
	ipRule_STATUSARMGenerator = gen.Struct(reflect.TypeOf(IPRule_STATUSARM{}), generators)

	return ipRule_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForIPRule_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIPRule_STATUSARM(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(IPRule_STATUS_Action_Allow))
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_KeyVaultProperties_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultProperties_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultProperties_STATUSARM, KeyVaultProperties_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultProperties_STATUSARM runs a test to see if a specific instance of KeyVaultProperties_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultProperties_STATUSARM(subject KeyVaultProperties_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultProperties_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultProperties_STATUSARM instances for property testing - lazily instantiated by
// KeyVaultProperties_STATUSARMGenerator()
var keyVaultProperties_STATUSARMGenerator gopter.Gen

// KeyVaultProperties_STATUSARMGenerator returns a generator of KeyVaultProperties_STATUSARM instances for property testing.
func KeyVaultProperties_STATUSARMGenerator() gopter.Gen {
	if keyVaultProperties_STATUSARMGenerator != nil {
		return keyVaultProperties_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultProperties_STATUSARM(generators)
	keyVaultProperties_STATUSARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultProperties_STATUSARM{}), generators)

	return keyVaultProperties_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultProperties_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultProperties_STATUSARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(gen.AlphaString())
	gens["KeyIdentifier"] = gen.PtrOf(gen.AlphaString())
	gens["KeyRotationEnabled"] = gen.PtrOf(gen.Bool())
	gens["LastKeyRotationTimestamp"] = gen.PtrOf(gen.AlphaString())
	gens["VersionedKeyIdentifier"] = gen.PtrOf(gen.AlphaString())
}

func Test_QuarantinePolicy_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of QuarantinePolicy_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForQuarantinePolicy_STATUSARM, QuarantinePolicy_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForQuarantinePolicy_STATUSARM runs a test to see if a specific instance of QuarantinePolicy_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForQuarantinePolicy_STATUSARM(subject QuarantinePolicy_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual QuarantinePolicy_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of QuarantinePolicy_STATUSARM instances for property testing - lazily instantiated by
// QuarantinePolicy_STATUSARMGenerator()
var quarantinePolicy_STATUSARMGenerator gopter.Gen

// QuarantinePolicy_STATUSARMGenerator returns a generator of QuarantinePolicy_STATUSARM instances for property testing.
func QuarantinePolicy_STATUSARMGenerator() gopter.Gen {
	if quarantinePolicy_STATUSARMGenerator != nil {
		return quarantinePolicy_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForQuarantinePolicy_STATUSARM(generators)
	quarantinePolicy_STATUSARMGenerator = gen.Struct(reflect.TypeOf(QuarantinePolicy_STATUSARM{}), generators)

	return quarantinePolicy_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForQuarantinePolicy_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForQuarantinePolicy_STATUSARM(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(gen.OneConstOf(QuarantinePolicy_STATUS_Status_Disabled, QuarantinePolicy_STATUS_Status_Enabled))
}

func Test_RetentionPolicy_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RetentionPolicy_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRetentionPolicy_STATUSARM, RetentionPolicy_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRetentionPolicy_STATUSARM runs a test to see if a specific instance of RetentionPolicy_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRetentionPolicy_STATUSARM(subject RetentionPolicy_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RetentionPolicy_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RetentionPolicy_STATUSARM instances for property testing - lazily instantiated by
// RetentionPolicy_STATUSARMGenerator()
var retentionPolicy_STATUSARMGenerator gopter.Gen

// RetentionPolicy_STATUSARMGenerator returns a generator of RetentionPolicy_STATUSARM instances for property testing.
func RetentionPolicy_STATUSARMGenerator() gopter.Gen {
	if retentionPolicy_STATUSARMGenerator != nil {
		return retentionPolicy_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRetentionPolicy_STATUSARM(generators)
	retentionPolicy_STATUSARMGenerator = gen.Struct(reflect.TypeOf(RetentionPolicy_STATUSARM{}), generators)

	return retentionPolicy_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForRetentionPolicy_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRetentionPolicy_STATUSARM(gens map[string]gopter.Gen) {
	gens["Days"] = gen.PtrOf(gen.Int())
	gens["LastUpdatedTime"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(RetentionPolicy_STATUS_Status_Disabled, RetentionPolicy_STATUS_Status_Enabled))
}

func Test_TrustPolicy_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TrustPolicy_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTrustPolicy_STATUSARM, TrustPolicy_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTrustPolicy_STATUSARM runs a test to see if a specific instance of TrustPolicy_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForTrustPolicy_STATUSARM(subject TrustPolicy_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TrustPolicy_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TrustPolicy_STATUSARM instances for property testing - lazily instantiated by
// TrustPolicy_STATUSARMGenerator()
var trustPolicy_STATUSARMGenerator gopter.Gen

// TrustPolicy_STATUSARMGenerator returns a generator of TrustPolicy_STATUSARM instances for property testing.
func TrustPolicy_STATUSARMGenerator() gopter.Gen {
	if trustPolicy_STATUSARMGenerator != nil {
		return trustPolicy_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTrustPolicy_STATUSARM(generators)
	trustPolicy_STATUSARMGenerator = gen.Struct(reflect.TypeOf(TrustPolicy_STATUSARM{}), generators)

	return trustPolicy_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForTrustPolicy_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTrustPolicy_STATUSARM(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(gen.OneConstOf(TrustPolicy_STATUS_Status_Disabled, TrustPolicy_STATUS_Status_Enabled))
	gens["Type"] = gen.PtrOf(gen.OneConstOf(TrustPolicy_STATUS_Type_Notary))
}
