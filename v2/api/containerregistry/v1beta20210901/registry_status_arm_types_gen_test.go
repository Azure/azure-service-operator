// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20210901

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_Registry_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Registry_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRegistrySTATUSARM, RegistrySTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRegistrySTATUSARM runs a test to see if a specific instance of Registry_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRegistrySTATUSARM(subject Registry_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Registry_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Registry_STATUSARM instances for property testing - lazily instantiated by RegistrySTATUSARMGenerator()
var registrySTATUSARMGenerator gopter.Gen

// RegistrySTATUSARMGenerator returns a generator of Registry_STATUSARM instances for property testing.
// We first initialize registrySTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RegistrySTATUSARMGenerator() gopter.Gen {
	if registrySTATUSARMGenerator != nil {
		return registrySTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRegistrySTATUSARM(generators)
	registrySTATUSARMGenerator = gen.Struct(reflect.TypeOf(Registry_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRegistrySTATUSARM(generators)
	AddRelatedPropertyGeneratorsForRegistrySTATUSARM(generators)
	registrySTATUSARMGenerator = gen.Struct(reflect.TypeOf(Registry_STATUSARM{}), generators)

	return registrySTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForRegistrySTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRegistrySTATUSARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForRegistrySTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRegistrySTATUSARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(IdentityPropertiesSTATUSARMGenerator())
	gens["Properties"] = gen.PtrOf(RegistryPropertiesSTATUSARMGenerator())
	gens["Sku"] = gen.PtrOf(SkuSTATUSARMGenerator())
	gens["SystemData"] = gen.PtrOf(SystemDataSTATUSARMGenerator())
}

func Test_IdentityProperties_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IdentityProperties_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIdentityPropertiesSTATUSARM, IdentityPropertiesSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIdentityPropertiesSTATUSARM runs a test to see if a specific instance of IdentityProperties_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIdentityPropertiesSTATUSARM(subject IdentityProperties_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IdentityProperties_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IdentityProperties_STATUSARM instances for property testing - lazily instantiated by
// IdentityPropertiesSTATUSARMGenerator()
var identityPropertiesSTATUSARMGenerator gopter.Gen

// IdentityPropertiesSTATUSARMGenerator returns a generator of IdentityProperties_STATUSARM instances for property testing.
// We first initialize identityPropertiesSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IdentityPropertiesSTATUSARMGenerator() gopter.Gen {
	if identityPropertiesSTATUSARMGenerator != nil {
		return identityPropertiesSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentityPropertiesSTATUSARM(generators)
	identityPropertiesSTATUSARMGenerator = gen.Struct(reflect.TypeOf(IdentityProperties_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentityPropertiesSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForIdentityPropertiesSTATUSARM(generators)
	identityPropertiesSTATUSARMGenerator = gen.Struct(reflect.TypeOf(IdentityProperties_STATUSARM{}), generators)

	return identityPropertiesSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForIdentityPropertiesSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIdentityPropertiesSTATUSARM(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		IdentityPropertiesSTATUSType_None,
		IdentityPropertiesSTATUSType_SystemAssigned,
		IdentityPropertiesSTATUSType_SystemAssignedUserAssigned,
		IdentityPropertiesSTATUSType_UserAssigned))
}

// AddRelatedPropertyGeneratorsForIdentityPropertiesSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIdentityPropertiesSTATUSARM(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), UserIdentityPropertiesSTATUSARMGenerator())
}

func Test_RegistryProperties_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RegistryProperties_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRegistryPropertiesSTATUSARM, RegistryPropertiesSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRegistryPropertiesSTATUSARM runs a test to see if a specific instance of RegistryProperties_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRegistryPropertiesSTATUSARM(subject RegistryProperties_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RegistryProperties_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RegistryProperties_STATUSARM instances for property testing - lazily instantiated by
// RegistryPropertiesSTATUSARMGenerator()
var registryPropertiesSTATUSARMGenerator gopter.Gen

// RegistryPropertiesSTATUSARMGenerator returns a generator of RegistryProperties_STATUSARM instances for property testing.
// We first initialize registryPropertiesSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RegistryPropertiesSTATUSARMGenerator() gopter.Gen {
	if registryPropertiesSTATUSARMGenerator != nil {
		return registryPropertiesSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRegistryPropertiesSTATUSARM(generators)
	registryPropertiesSTATUSARMGenerator = gen.Struct(reflect.TypeOf(RegistryProperties_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRegistryPropertiesSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForRegistryPropertiesSTATUSARM(generators)
	registryPropertiesSTATUSARMGenerator = gen.Struct(reflect.TypeOf(RegistryProperties_STATUSARM{}), generators)

	return registryPropertiesSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForRegistryPropertiesSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRegistryPropertiesSTATUSARM(gens map[string]gopter.Gen) {
	gens["AdminUserEnabled"] = gen.PtrOf(gen.Bool())
	gens["CreationDate"] = gen.PtrOf(gen.AlphaString())
	gens["DataEndpointEnabled"] = gen.PtrOf(gen.Bool())
	gens["DataEndpointHostNames"] = gen.SliceOf(gen.AlphaString())
	gens["LoginServer"] = gen.PtrOf(gen.AlphaString())
	gens["NetworkRuleBypassOptions"] = gen.PtrOf(gen.OneConstOf(RegistryPropertiesSTATUSNetworkRuleBypassOptions_AzureServices, RegistryPropertiesSTATUSNetworkRuleBypassOptions_None))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		RegistryPropertiesSTATUSProvisioningState_Canceled,
		RegistryPropertiesSTATUSProvisioningState_Creating,
		RegistryPropertiesSTATUSProvisioningState_Deleting,
		RegistryPropertiesSTATUSProvisioningState_Failed,
		RegistryPropertiesSTATUSProvisioningState_Succeeded,
		RegistryPropertiesSTATUSProvisioningState_Updating))
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(RegistryPropertiesSTATUSPublicNetworkAccess_Disabled, RegistryPropertiesSTATUSPublicNetworkAccess_Enabled))
	gens["ZoneRedundancy"] = gen.PtrOf(gen.OneConstOf(RegistryPropertiesSTATUSZoneRedundancy_Disabled, RegistryPropertiesSTATUSZoneRedundancy_Enabled))
}

// AddRelatedPropertyGeneratorsForRegistryPropertiesSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRegistryPropertiesSTATUSARM(gens map[string]gopter.Gen) {
	gens["Encryption"] = gen.PtrOf(EncryptionPropertySTATUSARMGenerator())
	gens["NetworkRuleSet"] = gen.PtrOf(NetworkRuleSetSTATUSARMGenerator())
	gens["Policies"] = gen.PtrOf(PoliciesSTATUSARMGenerator())
	gens["PrivateEndpointConnections"] = gen.SliceOf(PrivateEndpointConnectionSTATUSSubResourceEmbeddedARMGenerator())
	gens["Status"] = gen.PtrOf(StatusSTATUSARMGenerator())
}

func Test_Sku_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sku_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSkuSTATUSARM, SkuSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSkuSTATUSARM runs a test to see if a specific instance of Sku_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSkuSTATUSARM(subject Sku_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sku_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sku_STATUSARM instances for property testing - lazily instantiated by SkuSTATUSARMGenerator()
var skuSTATUSARMGenerator gopter.Gen

// SkuSTATUSARMGenerator returns a generator of Sku_STATUSARM instances for property testing.
func SkuSTATUSARMGenerator() gopter.Gen {
	if skuSTATUSARMGenerator != nil {
		return skuSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSkuSTATUSARM(generators)
	skuSTATUSARMGenerator = gen.Struct(reflect.TypeOf(Sku_STATUSARM{}), generators)

	return skuSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForSkuSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSkuSTATUSARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(
		SkuSTATUSName_Basic,
		SkuSTATUSName_Classic,
		SkuSTATUSName_Premium,
		SkuSTATUSName_Standard))
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(
		SkuSTATUSTier_Basic,
		SkuSTATUSTier_Classic,
		SkuSTATUSTier_Premium,
		SkuSTATUSTier_Standard))
}

func Test_SystemData_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SystemData_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSystemDataSTATUSARM, SystemDataSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSystemDataSTATUSARM runs a test to see if a specific instance of SystemData_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSystemDataSTATUSARM(subject SystemData_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SystemData_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SystemData_STATUSARM instances for property testing - lazily instantiated by
// SystemDataSTATUSARMGenerator()
var systemDataSTATUSARMGenerator gopter.Gen

// SystemDataSTATUSARMGenerator returns a generator of SystemData_STATUSARM instances for property testing.
func SystemDataSTATUSARMGenerator() gopter.Gen {
	if systemDataSTATUSARMGenerator != nil {
		return systemDataSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSystemDataSTATUSARM(generators)
	systemDataSTATUSARMGenerator = gen.Struct(reflect.TypeOf(SystemData_STATUSARM{}), generators)

	return systemDataSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForSystemDataSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSystemDataSTATUSARM(gens map[string]gopter.Gen) {
	gens["CreatedAt"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedBy"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemDataSTATUSCreatedByType_Application,
		SystemDataSTATUSCreatedByType_Key,
		SystemDataSTATUSCreatedByType_ManagedIdentity,
		SystemDataSTATUSCreatedByType_User))
	gens["LastModifiedAt"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedBy"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemDataSTATUSLastModifiedByType_Application,
		SystemDataSTATUSLastModifiedByType_Key,
		SystemDataSTATUSLastModifiedByType_ManagedIdentity,
		SystemDataSTATUSLastModifiedByType_User))
}

func Test_EncryptionProperty_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionProperty_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionPropertySTATUSARM, EncryptionPropertySTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionPropertySTATUSARM runs a test to see if a specific instance of EncryptionProperty_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionPropertySTATUSARM(subject EncryptionProperty_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionProperty_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionProperty_STATUSARM instances for property testing - lazily instantiated by
// EncryptionPropertySTATUSARMGenerator()
var encryptionPropertySTATUSARMGenerator gopter.Gen

// EncryptionPropertySTATUSARMGenerator returns a generator of EncryptionProperty_STATUSARM instances for property testing.
// We first initialize encryptionPropertySTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EncryptionPropertySTATUSARMGenerator() gopter.Gen {
	if encryptionPropertySTATUSARMGenerator != nil {
		return encryptionPropertySTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionPropertySTATUSARM(generators)
	encryptionPropertySTATUSARMGenerator = gen.Struct(reflect.TypeOf(EncryptionProperty_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionPropertySTATUSARM(generators)
	AddRelatedPropertyGeneratorsForEncryptionPropertySTATUSARM(generators)
	encryptionPropertySTATUSARMGenerator = gen.Struct(reflect.TypeOf(EncryptionProperty_STATUSARM{}), generators)

	return encryptionPropertySTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionPropertySTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionPropertySTATUSARM(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(gen.OneConstOf(EncryptionPropertySTATUSStatus_Disabled, EncryptionPropertySTATUSStatus_Enabled))
}

// AddRelatedPropertyGeneratorsForEncryptionPropertySTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionPropertySTATUSARM(gens map[string]gopter.Gen) {
	gens["KeyVaultProperties"] = gen.PtrOf(KeyVaultPropertiesSTATUSARMGenerator())
}

func Test_NetworkRuleSet_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkRuleSet_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkRuleSetSTATUSARM, NetworkRuleSetSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkRuleSetSTATUSARM runs a test to see if a specific instance of NetworkRuleSet_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkRuleSetSTATUSARM(subject NetworkRuleSet_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkRuleSet_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkRuleSet_STATUSARM instances for property testing - lazily instantiated by
// NetworkRuleSetSTATUSARMGenerator()
var networkRuleSetSTATUSARMGenerator gopter.Gen

// NetworkRuleSetSTATUSARMGenerator returns a generator of NetworkRuleSet_STATUSARM instances for property testing.
// We first initialize networkRuleSetSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkRuleSetSTATUSARMGenerator() gopter.Gen {
	if networkRuleSetSTATUSARMGenerator != nil {
		return networkRuleSetSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSetSTATUSARM(generators)
	networkRuleSetSTATUSARMGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSetSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForNetworkRuleSetSTATUSARM(generators)
	networkRuleSetSTATUSARMGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet_STATUSARM{}), generators)

	return networkRuleSetSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkRuleSetSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkRuleSetSTATUSARM(gens map[string]gopter.Gen) {
	gens["DefaultAction"] = gen.PtrOf(gen.OneConstOf(NetworkRuleSetSTATUSDefaultAction_Allow, NetworkRuleSetSTATUSDefaultAction_Deny))
}

// AddRelatedPropertyGeneratorsForNetworkRuleSetSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkRuleSetSTATUSARM(gens map[string]gopter.Gen) {
	gens["IpRules"] = gen.SliceOf(IPRuleSTATUSARMGenerator())
}

func Test_Policies_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Policies_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPoliciesSTATUSARM, PoliciesSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPoliciesSTATUSARM runs a test to see if a specific instance of Policies_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPoliciesSTATUSARM(subject Policies_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Policies_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Policies_STATUSARM instances for property testing - lazily instantiated by PoliciesSTATUSARMGenerator()
var policiesSTATUSARMGenerator gopter.Gen

// PoliciesSTATUSARMGenerator returns a generator of Policies_STATUSARM instances for property testing.
func PoliciesSTATUSARMGenerator() gopter.Gen {
	if policiesSTATUSARMGenerator != nil {
		return policiesSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForPoliciesSTATUSARM(generators)
	policiesSTATUSARMGenerator = gen.Struct(reflect.TypeOf(Policies_STATUSARM{}), generators)

	return policiesSTATUSARMGenerator
}

// AddRelatedPropertyGeneratorsForPoliciesSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPoliciesSTATUSARM(gens map[string]gopter.Gen) {
	gens["ExportPolicy"] = gen.PtrOf(ExportPolicySTATUSARMGenerator())
	gens["QuarantinePolicy"] = gen.PtrOf(QuarantinePolicySTATUSARMGenerator())
	gens["RetentionPolicy"] = gen.PtrOf(RetentionPolicySTATUSARMGenerator())
	gens["TrustPolicy"] = gen.PtrOf(TrustPolicySTATUSARMGenerator())
}

func Test_PrivateEndpointConnection_STATUS_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointConnection_STATUS_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointConnectionSTATUSSubResourceEmbeddedARM, PrivateEndpointConnectionSTATUSSubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointConnectionSTATUSSubResourceEmbeddedARM runs a test to see if a specific instance of PrivateEndpointConnection_STATUS_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointConnectionSTATUSSubResourceEmbeddedARM(subject PrivateEndpointConnection_STATUS_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointConnection_STATUS_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointConnection_STATUS_SubResourceEmbeddedARM instances for property testing - lazily
// instantiated by PrivateEndpointConnectionSTATUSSubResourceEmbeddedARMGenerator()
var privateEndpointConnectionSTATUSSubResourceEmbeddedARMGenerator gopter.Gen

// PrivateEndpointConnectionSTATUSSubResourceEmbeddedARMGenerator returns a generator of PrivateEndpointConnection_STATUS_SubResourceEmbeddedARM instances for property testing.
// We first initialize privateEndpointConnectionSTATUSSubResourceEmbeddedARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateEndpointConnectionSTATUSSubResourceEmbeddedARMGenerator() gopter.Gen {
	if privateEndpointConnectionSTATUSSubResourceEmbeddedARMGenerator != nil {
		return privateEndpointConnectionSTATUSSubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnectionSTATUSSubResourceEmbeddedARM(generators)
	privateEndpointConnectionSTATUSSubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnection_STATUS_SubResourceEmbeddedARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnectionSTATUSSubResourceEmbeddedARM(generators)
	AddRelatedPropertyGeneratorsForPrivateEndpointConnectionSTATUSSubResourceEmbeddedARM(generators)
	privateEndpointConnectionSTATUSSubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnection_STATUS_SubResourceEmbeddedARM{}), generators)

	return privateEndpointConnectionSTATUSSubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointConnectionSTATUSSubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointConnectionSTATUSSubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPrivateEndpointConnectionSTATUSSubResourceEmbeddedARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateEndpointConnectionSTATUSSubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["SystemData"] = gen.PtrOf(SystemDataSTATUSARMGenerator())
}

func Test_Status_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Status_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStatusSTATUSARM, StatusSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStatusSTATUSARM runs a test to see if a specific instance of Status_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStatusSTATUSARM(subject Status_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Status_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Status_STATUSARM instances for property testing - lazily instantiated by StatusSTATUSARMGenerator()
var statusSTATUSARMGenerator gopter.Gen

// StatusSTATUSARMGenerator returns a generator of Status_STATUSARM instances for property testing.
func StatusSTATUSARMGenerator() gopter.Gen {
	if statusSTATUSARMGenerator != nil {
		return statusSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStatusSTATUSARM(generators)
	statusSTATUSARMGenerator = gen.Struct(reflect.TypeOf(Status_STATUSARM{}), generators)

	return statusSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForStatusSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStatusSTATUSARM(gens map[string]gopter.Gen) {
	gens["DisplayStatus"] = gen.PtrOf(gen.AlphaString())
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Timestamp"] = gen.PtrOf(gen.AlphaString())
}

func Test_UserIdentityProperties_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserIdentityProperties_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserIdentityPropertiesSTATUSARM, UserIdentityPropertiesSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserIdentityPropertiesSTATUSARM runs a test to see if a specific instance of UserIdentityProperties_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUserIdentityPropertiesSTATUSARM(subject UserIdentityProperties_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserIdentityProperties_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserIdentityProperties_STATUSARM instances for property testing - lazily instantiated by
// UserIdentityPropertiesSTATUSARMGenerator()
var userIdentityPropertiesSTATUSARMGenerator gopter.Gen

// UserIdentityPropertiesSTATUSARMGenerator returns a generator of UserIdentityProperties_STATUSARM instances for property testing.
func UserIdentityPropertiesSTATUSARMGenerator() gopter.Gen {
	if userIdentityPropertiesSTATUSARMGenerator != nil {
		return userIdentityPropertiesSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserIdentityPropertiesSTATUSARM(generators)
	userIdentityPropertiesSTATUSARMGenerator = gen.Struct(reflect.TypeOf(UserIdentityProperties_STATUSARM{}), generators)

	return userIdentityPropertiesSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForUserIdentityPropertiesSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserIdentityPropertiesSTATUSARM(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_ExportPolicy_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExportPolicy_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExportPolicySTATUSARM, ExportPolicySTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExportPolicySTATUSARM runs a test to see if a specific instance of ExportPolicy_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForExportPolicySTATUSARM(subject ExportPolicy_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExportPolicy_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExportPolicy_STATUSARM instances for property testing - lazily instantiated by
// ExportPolicySTATUSARMGenerator()
var exportPolicySTATUSARMGenerator gopter.Gen

// ExportPolicySTATUSARMGenerator returns a generator of ExportPolicy_STATUSARM instances for property testing.
func ExportPolicySTATUSARMGenerator() gopter.Gen {
	if exportPolicySTATUSARMGenerator != nil {
		return exportPolicySTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExportPolicySTATUSARM(generators)
	exportPolicySTATUSARMGenerator = gen.Struct(reflect.TypeOf(ExportPolicy_STATUSARM{}), generators)

	return exportPolicySTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForExportPolicySTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExportPolicySTATUSARM(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(gen.OneConstOf(ExportPolicySTATUSStatus_Disabled, ExportPolicySTATUSStatus_Enabled))
}

func Test_IPRule_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IPRule_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIPRuleSTATUSARM, IPRuleSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIPRuleSTATUSARM runs a test to see if a specific instance of IPRule_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIPRuleSTATUSARM(subject IPRule_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IPRule_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IPRule_STATUSARM instances for property testing - lazily instantiated by IPRuleSTATUSARMGenerator()
var ipRuleSTATUSARMGenerator gopter.Gen

// IPRuleSTATUSARMGenerator returns a generator of IPRule_STATUSARM instances for property testing.
func IPRuleSTATUSARMGenerator() gopter.Gen {
	if ipRuleSTATUSARMGenerator != nil {
		return ipRuleSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPRuleSTATUSARM(generators)
	ipRuleSTATUSARMGenerator = gen.Struct(reflect.TypeOf(IPRule_STATUSARM{}), generators)

	return ipRuleSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForIPRuleSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIPRuleSTATUSARM(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(IPRuleSTATUSAction_Allow))
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_KeyVaultProperties_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultProperties_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultPropertiesSTATUSARM, KeyVaultPropertiesSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultPropertiesSTATUSARM runs a test to see if a specific instance of KeyVaultProperties_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultPropertiesSTATUSARM(subject KeyVaultProperties_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultProperties_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultProperties_STATUSARM instances for property testing - lazily instantiated by
// KeyVaultPropertiesSTATUSARMGenerator()
var keyVaultPropertiesSTATUSARMGenerator gopter.Gen

// KeyVaultPropertiesSTATUSARMGenerator returns a generator of KeyVaultProperties_STATUSARM instances for property testing.
func KeyVaultPropertiesSTATUSARMGenerator() gopter.Gen {
	if keyVaultPropertiesSTATUSARMGenerator != nil {
		return keyVaultPropertiesSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultPropertiesSTATUSARM(generators)
	keyVaultPropertiesSTATUSARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultProperties_STATUSARM{}), generators)

	return keyVaultPropertiesSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultPropertiesSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultPropertiesSTATUSARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(gen.AlphaString())
	gens["KeyIdentifier"] = gen.PtrOf(gen.AlphaString())
	gens["KeyRotationEnabled"] = gen.PtrOf(gen.Bool())
	gens["LastKeyRotationTimestamp"] = gen.PtrOf(gen.AlphaString())
	gens["VersionedKeyIdentifier"] = gen.PtrOf(gen.AlphaString())
}

func Test_QuarantinePolicy_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of QuarantinePolicy_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForQuarantinePolicySTATUSARM, QuarantinePolicySTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForQuarantinePolicySTATUSARM runs a test to see if a specific instance of QuarantinePolicy_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForQuarantinePolicySTATUSARM(subject QuarantinePolicy_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual QuarantinePolicy_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of QuarantinePolicy_STATUSARM instances for property testing - lazily instantiated by
// QuarantinePolicySTATUSARMGenerator()
var quarantinePolicySTATUSARMGenerator gopter.Gen

// QuarantinePolicySTATUSARMGenerator returns a generator of QuarantinePolicy_STATUSARM instances for property testing.
func QuarantinePolicySTATUSARMGenerator() gopter.Gen {
	if quarantinePolicySTATUSARMGenerator != nil {
		return quarantinePolicySTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForQuarantinePolicySTATUSARM(generators)
	quarantinePolicySTATUSARMGenerator = gen.Struct(reflect.TypeOf(QuarantinePolicy_STATUSARM{}), generators)

	return quarantinePolicySTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForQuarantinePolicySTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForQuarantinePolicySTATUSARM(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(gen.OneConstOf(QuarantinePolicySTATUSStatus_Disabled, QuarantinePolicySTATUSStatus_Enabled))
}

func Test_RetentionPolicy_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RetentionPolicy_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRetentionPolicySTATUSARM, RetentionPolicySTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRetentionPolicySTATUSARM runs a test to see if a specific instance of RetentionPolicy_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRetentionPolicySTATUSARM(subject RetentionPolicy_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RetentionPolicy_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RetentionPolicy_STATUSARM instances for property testing - lazily instantiated by
// RetentionPolicySTATUSARMGenerator()
var retentionPolicySTATUSARMGenerator gopter.Gen

// RetentionPolicySTATUSARMGenerator returns a generator of RetentionPolicy_STATUSARM instances for property testing.
func RetentionPolicySTATUSARMGenerator() gopter.Gen {
	if retentionPolicySTATUSARMGenerator != nil {
		return retentionPolicySTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRetentionPolicySTATUSARM(generators)
	retentionPolicySTATUSARMGenerator = gen.Struct(reflect.TypeOf(RetentionPolicy_STATUSARM{}), generators)

	return retentionPolicySTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForRetentionPolicySTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRetentionPolicySTATUSARM(gens map[string]gopter.Gen) {
	gens["Days"] = gen.PtrOf(gen.Int())
	gens["LastUpdatedTime"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(RetentionPolicySTATUSStatus_Disabled, RetentionPolicySTATUSStatus_Enabled))
}

func Test_TrustPolicy_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TrustPolicy_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTrustPolicySTATUSARM, TrustPolicySTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTrustPolicySTATUSARM runs a test to see if a specific instance of TrustPolicy_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForTrustPolicySTATUSARM(subject TrustPolicy_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TrustPolicy_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TrustPolicy_STATUSARM instances for property testing - lazily instantiated by
// TrustPolicySTATUSARMGenerator()
var trustPolicySTATUSARMGenerator gopter.Gen

// TrustPolicySTATUSARMGenerator returns a generator of TrustPolicy_STATUSARM instances for property testing.
func TrustPolicySTATUSARMGenerator() gopter.Gen {
	if trustPolicySTATUSARMGenerator != nil {
		return trustPolicySTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTrustPolicySTATUSARM(generators)
	trustPolicySTATUSARMGenerator = gen.Struct(reflect.TypeOf(TrustPolicy_STATUSARM{}), generators)

	return trustPolicySTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForTrustPolicySTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTrustPolicySTATUSARM(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(gen.OneConstOf(TrustPolicySTATUSStatus_Disabled, TrustPolicySTATUSStatus_Enabled))
	gens["Type"] = gen.PtrOf(gen.OneConstOf(TrustPolicySTATUSType_Notary))
}
