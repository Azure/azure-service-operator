// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20210901

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_Registry_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Registry_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRegistryStatusARM, RegistryStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRegistryStatusARM runs a test to see if a specific instance of Registry_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRegistryStatusARM(subject Registry_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Registry_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Registry_StatusARM instances for property testing - lazily instantiated by RegistryStatusARMGenerator()
var registryStatusARMGenerator gopter.Gen

// RegistryStatusARMGenerator returns a generator of Registry_StatusARM instances for property testing.
// We first initialize registryStatusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RegistryStatusARMGenerator() gopter.Gen {
	if registryStatusARMGenerator != nil {
		return registryStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRegistryStatusARM(generators)
	registryStatusARMGenerator = gen.Struct(reflect.TypeOf(Registry_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRegistryStatusARM(generators)
	AddRelatedPropertyGeneratorsForRegistryStatusARM(generators)
	registryStatusARMGenerator = gen.Struct(reflect.TypeOf(Registry_StatusARM{}), generators)

	return registryStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForRegistryStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRegistryStatusARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForRegistryStatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRegistryStatusARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(IdentityPropertiesStatusARMGenerator())
	gens["Properties"] = gen.PtrOf(RegistryPropertiesStatusARMGenerator())
	gens["Sku"] = gen.PtrOf(SkuStatusARMGenerator())
	gens["SystemData"] = gen.PtrOf(SystemDataStatusARMGenerator())
}

func Test_IdentityProperties_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IdentityProperties_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIdentityPropertiesStatusARM, IdentityPropertiesStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIdentityPropertiesStatusARM runs a test to see if a specific instance of IdentityProperties_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIdentityPropertiesStatusARM(subject IdentityProperties_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IdentityProperties_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IdentityProperties_StatusARM instances for property testing - lazily instantiated by
// IdentityPropertiesStatusARMGenerator()
var identityPropertiesStatusARMGenerator gopter.Gen

// IdentityPropertiesStatusARMGenerator returns a generator of IdentityProperties_StatusARM instances for property testing.
// We first initialize identityPropertiesStatusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IdentityPropertiesStatusARMGenerator() gopter.Gen {
	if identityPropertiesStatusARMGenerator != nil {
		return identityPropertiesStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentityPropertiesStatusARM(generators)
	identityPropertiesStatusARMGenerator = gen.Struct(reflect.TypeOf(IdentityProperties_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentityPropertiesStatusARM(generators)
	AddRelatedPropertyGeneratorsForIdentityPropertiesStatusARM(generators)
	identityPropertiesStatusARMGenerator = gen.Struct(reflect.TypeOf(IdentityProperties_StatusARM{}), generators)

	return identityPropertiesStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForIdentityPropertiesStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIdentityPropertiesStatusARM(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		IdentityPropertiesStatusType_None,
		IdentityPropertiesStatusType_SystemAssigned,
		IdentityPropertiesStatusType_SystemAssignedUserAssigned,
		IdentityPropertiesStatusType_UserAssigned))
}

// AddRelatedPropertyGeneratorsForIdentityPropertiesStatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIdentityPropertiesStatusARM(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), UserIdentityPropertiesStatusARMGenerator())
}

func Test_RegistryProperties_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RegistryProperties_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRegistryPropertiesStatusARM, RegistryPropertiesStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRegistryPropertiesStatusARM runs a test to see if a specific instance of RegistryProperties_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRegistryPropertiesStatusARM(subject RegistryProperties_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RegistryProperties_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RegistryProperties_StatusARM instances for property testing - lazily instantiated by
// RegistryPropertiesStatusARMGenerator()
var registryPropertiesStatusARMGenerator gopter.Gen

// RegistryPropertiesStatusARMGenerator returns a generator of RegistryProperties_StatusARM instances for property testing.
// We first initialize registryPropertiesStatusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RegistryPropertiesStatusARMGenerator() gopter.Gen {
	if registryPropertiesStatusARMGenerator != nil {
		return registryPropertiesStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRegistryPropertiesStatusARM(generators)
	registryPropertiesStatusARMGenerator = gen.Struct(reflect.TypeOf(RegistryProperties_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRegistryPropertiesStatusARM(generators)
	AddRelatedPropertyGeneratorsForRegistryPropertiesStatusARM(generators)
	registryPropertiesStatusARMGenerator = gen.Struct(reflect.TypeOf(RegistryProperties_StatusARM{}), generators)

	return registryPropertiesStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForRegistryPropertiesStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRegistryPropertiesStatusARM(gens map[string]gopter.Gen) {
	gens["AdminUserEnabled"] = gen.PtrOf(gen.Bool())
	gens["CreationDate"] = gen.PtrOf(gen.AlphaString())
	gens["DataEndpointEnabled"] = gen.PtrOf(gen.Bool())
	gens["DataEndpointHostNames"] = gen.SliceOf(gen.AlphaString())
	gens["LoginServer"] = gen.PtrOf(gen.AlphaString())
	gens["NetworkRuleBypassOptions"] = gen.PtrOf(gen.OneConstOf(RegistryPropertiesStatusNetworkRuleBypassOptions_AzureServices, RegistryPropertiesStatusNetworkRuleBypassOptions_None))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		RegistryPropertiesStatusProvisioningState_Canceled,
		RegistryPropertiesStatusProvisioningState_Creating,
		RegistryPropertiesStatusProvisioningState_Deleting,
		RegistryPropertiesStatusProvisioningState_Failed,
		RegistryPropertiesStatusProvisioningState_Succeeded,
		RegistryPropertiesStatusProvisioningState_Updating))
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(RegistryPropertiesStatusPublicNetworkAccess_Disabled, RegistryPropertiesStatusPublicNetworkAccess_Enabled))
	gens["ZoneRedundancy"] = gen.PtrOf(gen.OneConstOf(RegistryPropertiesStatusZoneRedundancy_Disabled, RegistryPropertiesStatusZoneRedundancy_Enabled))
}

// AddRelatedPropertyGeneratorsForRegistryPropertiesStatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRegistryPropertiesStatusARM(gens map[string]gopter.Gen) {
	gens["Encryption"] = gen.PtrOf(EncryptionPropertyStatusARMGenerator())
	gens["NetworkRuleSet"] = gen.PtrOf(NetworkRuleSetStatusARMGenerator())
	gens["Policies"] = gen.PtrOf(PoliciesStatusARMGenerator())
	gens["PrivateEndpointConnections"] = gen.SliceOf(PrivateEndpointConnectionStatusSubResourceEmbeddedARMGenerator())
	gens["Status"] = gen.PtrOf(StatusStatusARMGenerator())
}

func Test_Sku_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sku_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSkuStatusARM, SkuStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSkuStatusARM runs a test to see if a specific instance of Sku_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSkuStatusARM(subject Sku_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sku_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sku_StatusARM instances for property testing - lazily instantiated by SkuStatusARMGenerator()
var skuStatusARMGenerator gopter.Gen

// SkuStatusARMGenerator returns a generator of Sku_StatusARM instances for property testing.
func SkuStatusARMGenerator() gopter.Gen {
	if skuStatusARMGenerator != nil {
		return skuStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSkuStatusARM(generators)
	skuStatusARMGenerator = gen.Struct(reflect.TypeOf(Sku_StatusARM{}), generators)

	return skuStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForSkuStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSkuStatusARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(
		SkuStatusName_Basic,
		SkuStatusName_Classic,
		SkuStatusName_Premium,
		SkuStatusName_Standard))
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(
		SkuStatusTier_Basic,
		SkuStatusTier_Classic,
		SkuStatusTier_Premium,
		SkuStatusTier_Standard))
}

func Test_SystemData_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SystemData_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSystemDataStatusARM, SystemDataStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSystemDataStatusARM runs a test to see if a specific instance of SystemData_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSystemDataStatusARM(subject SystemData_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SystemData_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SystemData_StatusARM instances for property testing - lazily instantiated by
// SystemDataStatusARMGenerator()
var systemDataStatusARMGenerator gopter.Gen

// SystemDataStatusARMGenerator returns a generator of SystemData_StatusARM instances for property testing.
func SystemDataStatusARMGenerator() gopter.Gen {
	if systemDataStatusARMGenerator != nil {
		return systemDataStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSystemDataStatusARM(generators)
	systemDataStatusARMGenerator = gen.Struct(reflect.TypeOf(SystemData_StatusARM{}), generators)

	return systemDataStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForSystemDataStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSystemDataStatusARM(gens map[string]gopter.Gen) {
	gens["CreatedAt"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedBy"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemDataStatusCreatedByType_Application,
		SystemDataStatusCreatedByType_Key,
		SystemDataStatusCreatedByType_ManagedIdentity,
		SystemDataStatusCreatedByType_User))
	gens["LastModifiedAt"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedBy"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemDataStatusLastModifiedByType_Application,
		SystemDataStatusLastModifiedByType_Key,
		SystemDataStatusLastModifiedByType_ManagedIdentity,
		SystemDataStatusLastModifiedByType_User))
}

func Test_EncryptionProperty_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionProperty_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionPropertyStatusARM, EncryptionPropertyStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionPropertyStatusARM runs a test to see if a specific instance of EncryptionProperty_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionPropertyStatusARM(subject EncryptionProperty_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionProperty_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionProperty_StatusARM instances for property testing - lazily instantiated by
// EncryptionPropertyStatusARMGenerator()
var encryptionPropertyStatusARMGenerator gopter.Gen

// EncryptionPropertyStatusARMGenerator returns a generator of EncryptionProperty_StatusARM instances for property testing.
// We first initialize encryptionPropertyStatusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EncryptionPropertyStatusARMGenerator() gopter.Gen {
	if encryptionPropertyStatusARMGenerator != nil {
		return encryptionPropertyStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionPropertyStatusARM(generators)
	encryptionPropertyStatusARMGenerator = gen.Struct(reflect.TypeOf(EncryptionProperty_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionPropertyStatusARM(generators)
	AddRelatedPropertyGeneratorsForEncryptionPropertyStatusARM(generators)
	encryptionPropertyStatusARMGenerator = gen.Struct(reflect.TypeOf(EncryptionProperty_StatusARM{}), generators)

	return encryptionPropertyStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionPropertyStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionPropertyStatusARM(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(gen.OneConstOf(EncryptionPropertyStatusStatus_Disabled, EncryptionPropertyStatusStatus_Enabled))
}

// AddRelatedPropertyGeneratorsForEncryptionPropertyStatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionPropertyStatusARM(gens map[string]gopter.Gen) {
	gens["KeyVaultProperties"] = gen.PtrOf(KeyVaultPropertiesStatusARMGenerator())
}

func Test_NetworkRuleSet_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkRuleSet_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkRuleSetStatusARM, NetworkRuleSetStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkRuleSetStatusARM runs a test to see if a specific instance of NetworkRuleSet_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkRuleSetStatusARM(subject NetworkRuleSet_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkRuleSet_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkRuleSet_StatusARM instances for property testing - lazily instantiated by
// NetworkRuleSetStatusARMGenerator()
var networkRuleSetStatusARMGenerator gopter.Gen

// NetworkRuleSetStatusARMGenerator returns a generator of NetworkRuleSet_StatusARM instances for property testing.
// We first initialize networkRuleSetStatusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkRuleSetStatusARMGenerator() gopter.Gen {
	if networkRuleSetStatusARMGenerator != nil {
		return networkRuleSetStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSetStatusARM(generators)
	networkRuleSetStatusARMGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSetStatusARM(generators)
	AddRelatedPropertyGeneratorsForNetworkRuleSetStatusARM(generators)
	networkRuleSetStatusARMGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSet_StatusARM{}), generators)

	return networkRuleSetStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkRuleSetStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkRuleSetStatusARM(gens map[string]gopter.Gen) {
	gens["DefaultAction"] = gen.PtrOf(gen.OneConstOf(NetworkRuleSetStatusDefaultAction_Allow, NetworkRuleSetStatusDefaultAction_Deny))
}

// AddRelatedPropertyGeneratorsForNetworkRuleSetStatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkRuleSetStatusARM(gens map[string]gopter.Gen) {
	gens["IpRules"] = gen.SliceOf(IPRuleStatusARMGenerator())
}

func Test_Policies_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Policies_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPoliciesStatusARM, PoliciesStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPoliciesStatusARM runs a test to see if a specific instance of Policies_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPoliciesStatusARM(subject Policies_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Policies_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Policies_StatusARM instances for property testing - lazily instantiated by PoliciesStatusARMGenerator()
var policiesStatusARMGenerator gopter.Gen

// PoliciesStatusARMGenerator returns a generator of Policies_StatusARM instances for property testing.
func PoliciesStatusARMGenerator() gopter.Gen {
	if policiesStatusARMGenerator != nil {
		return policiesStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForPoliciesStatusARM(generators)
	policiesStatusARMGenerator = gen.Struct(reflect.TypeOf(Policies_StatusARM{}), generators)

	return policiesStatusARMGenerator
}

// AddRelatedPropertyGeneratorsForPoliciesStatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPoliciesStatusARM(gens map[string]gopter.Gen) {
	gens["ExportPolicy"] = gen.PtrOf(ExportPolicyStatusARMGenerator())
	gens["QuarantinePolicy"] = gen.PtrOf(QuarantinePolicyStatusARMGenerator())
	gens["RetentionPolicy"] = gen.PtrOf(RetentionPolicyStatusARMGenerator())
	gens["TrustPolicy"] = gen.PtrOf(TrustPolicyStatusARMGenerator())
}

func Test_PrivateEndpointConnection_Status_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointConnection_Status_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointConnectionStatusSubResourceEmbeddedARM, PrivateEndpointConnectionStatusSubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointConnectionStatusSubResourceEmbeddedARM runs a test to see if a specific instance of PrivateEndpointConnection_Status_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointConnectionStatusSubResourceEmbeddedARM(subject PrivateEndpointConnection_Status_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointConnection_Status_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointConnection_Status_SubResourceEmbeddedARM instances for property testing - lazily
// instantiated by PrivateEndpointConnectionStatusSubResourceEmbeddedARMGenerator()
var privateEndpointConnectionStatusSubResourceEmbeddedARMGenerator gopter.Gen

// PrivateEndpointConnectionStatusSubResourceEmbeddedARMGenerator returns a generator of PrivateEndpointConnection_Status_SubResourceEmbeddedARM instances for property testing.
// We first initialize privateEndpointConnectionStatusSubResourceEmbeddedARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateEndpointConnectionStatusSubResourceEmbeddedARMGenerator() gopter.Gen {
	if privateEndpointConnectionStatusSubResourceEmbeddedARMGenerator != nil {
		return privateEndpointConnectionStatusSubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnectionStatusSubResourceEmbeddedARM(generators)
	privateEndpointConnectionStatusSubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnection_Status_SubResourceEmbeddedARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnectionStatusSubResourceEmbeddedARM(generators)
	AddRelatedPropertyGeneratorsForPrivateEndpointConnectionStatusSubResourceEmbeddedARM(generators)
	privateEndpointConnectionStatusSubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnection_Status_SubResourceEmbeddedARM{}), generators)

	return privateEndpointConnectionStatusSubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointConnectionStatusSubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointConnectionStatusSubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPrivateEndpointConnectionStatusSubResourceEmbeddedARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateEndpointConnectionStatusSubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["SystemData"] = gen.PtrOf(SystemDataStatusARMGenerator())
}

func Test_Status_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Status_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStatusStatusARM, StatusStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStatusStatusARM runs a test to see if a specific instance of Status_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStatusStatusARM(subject Status_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Status_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Status_StatusARM instances for property testing - lazily instantiated by StatusStatusARMGenerator()
var statusStatusARMGenerator gopter.Gen

// StatusStatusARMGenerator returns a generator of Status_StatusARM instances for property testing.
func StatusStatusARMGenerator() gopter.Gen {
	if statusStatusARMGenerator != nil {
		return statusStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStatusStatusARM(generators)
	statusStatusARMGenerator = gen.Struct(reflect.TypeOf(Status_StatusARM{}), generators)

	return statusStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForStatusStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStatusStatusARM(gens map[string]gopter.Gen) {
	gens["DisplayStatus"] = gen.PtrOf(gen.AlphaString())
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Timestamp"] = gen.PtrOf(gen.AlphaString())
}

func Test_UserIdentityProperties_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserIdentityProperties_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserIdentityPropertiesStatusARM, UserIdentityPropertiesStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserIdentityPropertiesStatusARM runs a test to see if a specific instance of UserIdentityProperties_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUserIdentityPropertiesStatusARM(subject UserIdentityProperties_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserIdentityProperties_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserIdentityProperties_StatusARM instances for property testing - lazily instantiated by
// UserIdentityPropertiesStatusARMGenerator()
var userIdentityPropertiesStatusARMGenerator gopter.Gen

// UserIdentityPropertiesStatusARMGenerator returns a generator of UserIdentityProperties_StatusARM instances for property testing.
func UserIdentityPropertiesStatusARMGenerator() gopter.Gen {
	if userIdentityPropertiesStatusARMGenerator != nil {
		return userIdentityPropertiesStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserIdentityPropertiesStatusARM(generators)
	userIdentityPropertiesStatusARMGenerator = gen.Struct(reflect.TypeOf(UserIdentityProperties_StatusARM{}), generators)

	return userIdentityPropertiesStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForUserIdentityPropertiesStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserIdentityPropertiesStatusARM(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_ExportPolicy_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExportPolicy_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExportPolicyStatusARM, ExportPolicyStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExportPolicyStatusARM runs a test to see if a specific instance of ExportPolicy_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForExportPolicyStatusARM(subject ExportPolicy_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExportPolicy_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExportPolicy_StatusARM instances for property testing - lazily instantiated by
// ExportPolicyStatusARMGenerator()
var exportPolicyStatusARMGenerator gopter.Gen

// ExportPolicyStatusARMGenerator returns a generator of ExportPolicy_StatusARM instances for property testing.
func ExportPolicyStatusARMGenerator() gopter.Gen {
	if exportPolicyStatusARMGenerator != nil {
		return exportPolicyStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExportPolicyStatusARM(generators)
	exportPolicyStatusARMGenerator = gen.Struct(reflect.TypeOf(ExportPolicy_StatusARM{}), generators)

	return exportPolicyStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForExportPolicyStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExportPolicyStatusARM(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(gen.OneConstOf(ExportPolicyStatusStatus_Disabled, ExportPolicyStatusStatus_Enabled))
}

func Test_IPRule_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IPRule_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIPRuleStatusARM, IPRuleStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIPRuleStatusARM runs a test to see if a specific instance of IPRule_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIPRuleStatusARM(subject IPRule_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IPRule_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IPRule_StatusARM instances for property testing - lazily instantiated by IPRuleStatusARMGenerator()
var ipRuleStatusARMGenerator gopter.Gen

// IPRuleStatusARMGenerator returns a generator of IPRule_StatusARM instances for property testing.
func IPRuleStatusARMGenerator() gopter.Gen {
	if ipRuleStatusARMGenerator != nil {
		return ipRuleStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIPRuleStatusARM(generators)
	ipRuleStatusARMGenerator = gen.Struct(reflect.TypeOf(IPRule_StatusARM{}), generators)

	return ipRuleStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForIPRuleStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIPRuleStatusARM(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(IPRuleStatusAction_Allow))
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_KeyVaultProperties_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultProperties_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultPropertiesStatusARM, KeyVaultPropertiesStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultPropertiesStatusARM runs a test to see if a specific instance of KeyVaultProperties_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultPropertiesStatusARM(subject KeyVaultProperties_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultProperties_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultProperties_StatusARM instances for property testing - lazily instantiated by
// KeyVaultPropertiesStatusARMGenerator()
var keyVaultPropertiesStatusARMGenerator gopter.Gen

// KeyVaultPropertiesStatusARMGenerator returns a generator of KeyVaultProperties_StatusARM instances for property testing.
func KeyVaultPropertiesStatusARMGenerator() gopter.Gen {
	if keyVaultPropertiesStatusARMGenerator != nil {
		return keyVaultPropertiesStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultPropertiesStatusARM(generators)
	keyVaultPropertiesStatusARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultProperties_StatusARM{}), generators)

	return keyVaultPropertiesStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultPropertiesStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultPropertiesStatusARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(gen.AlphaString())
	gens["KeyIdentifier"] = gen.PtrOf(gen.AlphaString())
	gens["KeyRotationEnabled"] = gen.PtrOf(gen.Bool())
	gens["LastKeyRotationTimestamp"] = gen.PtrOf(gen.AlphaString())
	gens["VersionedKeyIdentifier"] = gen.PtrOf(gen.AlphaString())
}

func Test_QuarantinePolicy_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of QuarantinePolicy_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForQuarantinePolicyStatusARM, QuarantinePolicyStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForQuarantinePolicyStatusARM runs a test to see if a specific instance of QuarantinePolicy_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForQuarantinePolicyStatusARM(subject QuarantinePolicy_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual QuarantinePolicy_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of QuarantinePolicy_StatusARM instances for property testing - lazily instantiated by
// QuarantinePolicyStatusARMGenerator()
var quarantinePolicyStatusARMGenerator gopter.Gen

// QuarantinePolicyStatusARMGenerator returns a generator of QuarantinePolicy_StatusARM instances for property testing.
func QuarantinePolicyStatusARMGenerator() gopter.Gen {
	if quarantinePolicyStatusARMGenerator != nil {
		return quarantinePolicyStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForQuarantinePolicyStatusARM(generators)
	quarantinePolicyStatusARMGenerator = gen.Struct(reflect.TypeOf(QuarantinePolicy_StatusARM{}), generators)

	return quarantinePolicyStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForQuarantinePolicyStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForQuarantinePolicyStatusARM(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(gen.OneConstOf(QuarantinePolicyStatusStatus_Disabled, QuarantinePolicyStatusStatus_Enabled))
}

func Test_RetentionPolicy_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RetentionPolicy_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRetentionPolicyStatusARM, RetentionPolicyStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRetentionPolicyStatusARM runs a test to see if a specific instance of RetentionPolicy_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRetentionPolicyStatusARM(subject RetentionPolicy_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RetentionPolicy_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RetentionPolicy_StatusARM instances for property testing - lazily instantiated by
// RetentionPolicyStatusARMGenerator()
var retentionPolicyStatusARMGenerator gopter.Gen

// RetentionPolicyStatusARMGenerator returns a generator of RetentionPolicy_StatusARM instances for property testing.
func RetentionPolicyStatusARMGenerator() gopter.Gen {
	if retentionPolicyStatusARMGenerator != nil {
		return retentionPolicyStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRetentionPolicyStatusARM(generators)
	retentionPolicyStatusARMGenerator = gen.Struct(reflect.TypeOf(RetentionPolicy_StatusARM{}), generators)

	return retentionPolicyStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForRetentionPolicyStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRetentionPolicyStatusARM(gens map[string]gopter.Gen) {
	gens["Days"] = gen.PtrOf(gen.Int())
	gens["LastUpdatedTime"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(RetentionPolicyStatusStatus_Disabled, RetentionPolicyStatusStatus_Enabled))
}

func Test_TrustPolicy_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TrustPolicy_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTrustPolicyStatusARM, TrustPolicyStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTrustPolicyStatusARM runs a test to see if a specific instance of TrustPolicy_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForTrustPolicyStatusARM(subject TrustPolicy_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TrustPolicy_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TrustPolicy_StatusARM instances for property testing - lazily instantiated by
// TrustPolicyStatusARMGenerator()
var trustPolicyStatusARMGenerator gopter.Gen

// TrustPolicyStatusARMGenerator returns a generator of TrustPolicy_StatusARM instances for property testing.
func TrustPolicyStatusARMGenerator() gopter.Gen {
	if trustPolicyStatusARMGenerator != nil {
		return trustPolicyStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTrustPolicyStatusARM(generators)
	trustPolicyStatusARMGenerator = gen.Struct(reflect.TypeOf(TrustPolicy_StatusARM{}), generators)

	return trustPolicyStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForTrustPolicyStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTrustPolicyStatusARM(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(gen.OneConstOf(TrustPolicyStatusStatus_Disabled, TrustPolicyStatusStatus_Enabled))
	gens["Type"] = gen.PtrOf(gen.OneConstOf(TrustPolicyStatusType_Notary))
}
