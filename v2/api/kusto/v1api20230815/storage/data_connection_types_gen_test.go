// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package storage

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_CosmosDbDataConnection_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CosmosDbDataConnection via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCosmosDbDataConnection, CosmosDbDataConnectionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCosmosDbDataConnection runs a test to see if a specific instance of CosmosDbDataConnection round trips to JSON and back losslessly
func RunJSONSerializationTestForCosmosDbDataConnection(subject CosmosDbDataConnection) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CosmosDbDataConnection
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CosmosDbDataConnection instances for property testing - lazily instantiated by
// CosmosDbDataConnectionGenerator()
var cosmosDbDataConnectionGenerator gopter.Gen

// CosmosDbDataConnectionGenerator returns a generator of CosmosDbDataConnection instances for property testing.
func CosmosDbDataConnectionGenerator() gopter.Gen {
	if cosmosDbDataConnectionGenerator != nil {
		return cosmosDbDataConnectionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCosmosDbDataConnection(generators)
	cosmosDbDataConnectionGenerator = gen.Struct(reflect.TypeOf(CosmosDbDataConnection{}), generators)

	return cosmosDbDataConnectionGenerator
}

// AddIndependentPropertyGeneratorsForCosmosDbDataConnection is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCosmosDbDataConnection(gens map[string]gopter.Gen) {
	gens["CosmosDbContainer"] = gen.PtrOf(gen.AlphaString())
	gens["CosmosDbDatabase"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["MappingRuleName"] = gen.PtrOf(gen.AlphaString())
	gens["RetrievalStartDate"] = gen.PtrOf(gen.AlphaString())
	gens["TableName"] = gen.PtrOf(gen.AlphaString())
}

func Test_CosmosDbDataConnection_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CosmosDbDataConnection_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCosmosDbDataConnection_STATUS, CosmosDbDataConnection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCosmosDbDataConnection_STATUS runs a test to see if a specific instance of CosmosDbDataConnection_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForCosmosDbDataConnection_STATUS(subject CosmosDbDataConnection_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CosmosDbDataConnection_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CosmosDbDataConnection_STATUS instances for property testing - lazily instantiated by
// CosmosDbDataConnection_STATUSGenerator()
var cosmosDbDataConnection_STATUSGenerator gopter.Gen

// CosmosDbDataConnection_STATUSGenerator returns a generator of CosmosDbDataConnection_STATUS instances for property testing.
func CosmosDbDataConnection_STATUSGenerator() gopter.Gen {
	if cosmosDbDataConnection_STATUSGenerator != nil {
		return cosmosDbDataConnection_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCosmosDbDataConnection_STATUS(generators)
	cosmosDbDataConnection_STATUSGenerator = gen.Struct(reflect.TypeOf(CosmosDbDataConnection_STATUS{}), generators)

	return cosmosDbDataConnection_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForCosmosDbDataConnection_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCosmosDbDataConnection_STATUS(gens map[string]gopter.Gen) {
	gens["CosmosDbAccountResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["CosmosDbContainer"] = gen.PtrOf(gen.AlphaString())
	gens["CosmosDbDatabase"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["ManagedIdentityObjectId"] = gen.PtrOf(gen.AlphaString())
	gens["ManagedIdentityResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["MappingRuleName"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["RetrievalStartDate"] = gen.PtrOf(gen.AlphaString())
	gens["TableName"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_DataConnection_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataConnection via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataConnection, DataConnectionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataConnection runs a test to see if a specific instance of DataConnection round trips to JSON and back losslessly
func RunJSONSerializationTestForDataConnection(subject DataConnection) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataConnection
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataConnection instances for property testing - lazily instantiated by DataConnectionGenerator()
var dataConnectionGenerator gopter.Gen

// DataConnectionGenerator returns a generator of DataConnection instances for property testing.
func DataConnectionGenerator() gopter.Gen {
	if dataConnectionGenerator != nil {
		return dataConnectionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDataConnection(generators)
	dataConnectionGenerator = gen.Struct(reflect.TypeOf(DataConnection{}), generators)

	return dataConnectionGenerator
}

// AddRelatedPropertyGeneratorsForDataConnection is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataConnection(gens map[string]gopter.Gen) {
	gens["Spec"] = DataConnection_SpecGenerator()
	gens["Status"] = DataConnection_STATUSGenerator()
}

func Test_DataConnectionOperatorSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataConnectionOperatorSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataConnectionOperatorSpec, DataConnectionOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataConnectionOperatorSpec runs a test to see if a specific instance of DataConnectionOperatorSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForDataConnectionOperatorSpec(subject DataConnectionOperatorSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataConnectionOperatorSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataConnectionOperatorSpec instances for property testing - lazily instantiated by
// DataConnectionOperatorSpecGenerator()
var dataConnectionOperatorSpecGenerator gopter.Gen

// DataConnectionOperatorSpecGenerator returns a generator of DataConnectionOperatorSpec instances for property testing.
func DataConnectionOperatorSpecGenerator() gopter.Gen {
	if dataConnectionOperatorSpecGenerator != nil {
		return dataConnectionOperatorSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	dataConnectionOperatorSpecGenerator = gen.Struct(reflect.TypeOf(DataConnectionOperatorSpec{}), generators)

	return dataConnectionOperatorSpecGenerator
}

func Test_DataConnection_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataConnection_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataConnection_STATUS, DataConnection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataConnection_STATUS runs a test to see if a specific instance of DataConnection_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDataConnection_STATUS(subject DataConnection_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataConnection_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataConnection_STATUS instances for property testing - lazily instantiated by
// DataConnection_STATUSGenerator()
var dataConnection_STATUSGenerator gopter.Gen

// DataConnection_STATUSGenerator returns a generator of DataConnection_STATUS instances for property testing.
func DataConnection_STATUSGenerator() gopter.Gen {
	if dataConnection_STATUSGenerator != nil {
		return dataConnection_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDataConnection_STATUS(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		props := map[string]gopter.Gen{propName: propGen}
		gens = append(gens, gen.Struct(reflect.TypeOf(DataConnection_STATUS{}), props))
	}
	dataConnection_STATUSGenerator = gen.OneGenOf(gens...)

	return dataConnection_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDataConnection_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDataConnection_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDataConnection_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataConnection_STATUS(gens map[string]gopter.Gen) {
	gens["CosmosDb"] = CosmosDbDataConnection_STATUSGenerator().Map(func(it CosmosDbDataConnection_STATUS) *CosmosDbDataConnection_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["EventGrid"] = EventGridDataConnection_STATUSGenerator().Map(func(it EventGridDataConnection_STATUS) *EventGridDataConnection_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["EventHub"] = EventHubDataConnection_STATUSGenerator().Map(func(it EventHubDataConnection_STATUS) *EventHubDataConnection_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["IotHub"] = IotHubDataConnection_STATUSGenerator().Map(func(it IotHubDataConnection_STATUS) *IotHubDataConnection_STATUS {
		return &it
	}) // generate one case for OneOf type
}

func Test_DataConnection_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataConnection_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataConnection_Spec, DataConnection_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataConnection_Spec runs a test to see if a specific instance of DataConnection_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForDataConnection_Spec(subject DataConnection_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataConnection_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataConnection_Spec instances for property testing - lazily instantiated by
// DataConnection_SpecGenerator()
var dataConnection_SpecGenerator gopter.Gen

// DataConnection_SpecGenerator returns a generator of DataConnection_Spec instances for property testing.
func DataConnection_SpecGenerator() gopter.Gen {
	if dataConnection_SpecGenerator != nil {
		return dataConnection_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDataConnection_Spec(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		props := map[string]gopter.Gen{propName: propGen}
		gens = append(gens, gen.Struct(reflect.TypeOf(DataConnection_Spec{}), props))
	}
	dataConnection_SpecGenerator = gen.OneGenOf(gens...)

	return dataConnection_SpecGenerator
}

// AddIndependentPropertyGeneratorsForDataConnection_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDataConnection_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["OriginalVersion"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForDataConnection_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataConnection_Spec(gens map[string]gopter.Gen) {
	gens["CosmosDb"] = CosmosDbDataConnectionGenerator().Map(func(it CosmosDbDataConnection) *CosmosDbDataConnection {
		return &it
	}) // generate one case for OneOf type
	gens["EventGrid"] = EventGridDataConnectionGenerator().Map(func(it EventGridDataConnection) *EventGridDataConnection {
		return &it
	}) // generate one case for OneOf type
	gens["EventHub"] = EventHubDataConnectionGenerator().Map(func(it EventHubDataConnection) *EventHubDataConnection {
		return &it
	}) // generate one case for OneOf type
	gens["IotHub"] = IotHubDataConnectionGenerator().Map(func(it IotHubDataConnection) *IotHubDataConnection {
		return &it
	}) // generate one case for OneOf type
	gens["OperatorSpec"] = DataConnectionOperatorSpecGenerator().Map(func(it DataConnectionOperatorSpec) *DataConnectionOperatorSpec {
		return &it
	}) // generate one case for OneOf type
}

func Test_EventGridDataConnection_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventGridDataConnection via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventGridDataConnection, EventGridDataConnectionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventGridDataConnection runs a test to see if a specific instance of EventGridDataConnection round trips to JSON and back losslessly
func RunJSONSerializationTestForEventGridDataConnection(subject EventGridDataConnection) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventGridDataConnection
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventGridDataConnection instances for property testing - lazily instantiated by
// EventGridDataConnectionGenerator()
var eventGridDataConnectionGenerator gopter.Gen

// EventGridDataConnectionGenerator returns a generator of EventGridDataConnection instances for property testing.
func EventGridDataConnectionGenerator() gopter.Gen {
	if eventGridDataConnectionGenerator != nil {
		return eventGridDataConnectionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventGridDataConnection(generators)
	eventGridDataConnectionGenerator = gen.Struct(reflect.TypeOf(EventGridDataConnection{}), generators)

	return eventGridDataConnectionGenerator
}

// AddIndependentPropertyGeneratorsForEventGridDataConnection is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventGridDataConnection(gens map[string]gopter.Gen) {
	gens["BlobStorageEventType"] = gen.PtrOf(gen.AlphaString())
	gens["ConsumerGroup"] = gen.PtrOf(gen.AlphaString())
	gens["DataFormat"] = gen.PtrOf(gen.AlphaString())
	gens["DatabaseRouting"] = gen.PtrOf(gen.AlphaString())
	gens["IgnoreFirstRecord"] = gen.PtrOf(gen.Bool())
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["MappingRuleName"] = gen.PtrOf(gen.AlphaString())
	gens["TableName"] = gen.PtrOf(gen.AlphaString())
}

func Test_EventGridDataConnection_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventGridDataConnection_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventGridDataConnection_STATUS, EventGridDataConnection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventGridDataConnection_STATUS runs a test to see if a specific instance of EventGridDataConnection_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEventGridDataConnection_STATUS(subject EventGridDataConnection_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventGridDataConnection_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventGridDataConnection_STATUS instances for property testing - lazily instantiated by
// EventGridDataConnection_STATUSGenerator()
var eventGridDataConnection_STATUSGenerator gopter.Gen

// EventGridDataConnection_STATUSGenerator returns a generator of EventGridDataConnection_STATUS instances for property testing.
func EventGridDataConnection_STATUSGenerator() gopter.Gen {
	if eventGridDataConnection_STATUSGenerator != nil {
		return eventGridDataConnection_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventGridDataConnection_STATUS(generators)
	eventGridDataConnection_STATUSGenerator = gen.Struct(reflect.TypeOf(EventGridDataConnection_STATUS{}), generators)

	return eventGridDataConnection_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForEventGridDataConnection_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventGridDataConnection_STATUS(gens map[string]gopter.Gen) {
	gens["BlobStorageEventType"] = gen.PtrOf(gen.AlphaString())
	gens["ConsumerGroup"] = gen.PtrOf(gen.AlphaString())
	gens["DataFormat"] = gen.PtrOf(gen.AlphaString())
	gens["DatabaseRouting"] = gen.PtrOf(gen.AlphaString())
	gens["EventGridResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["EventHubResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IgnoreFirstRecord"] = gen.PtrOf(gen.Bool())
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["ManagedIdentityObjectId"] = gen.PtrOf(gen.AlphaString())
	gens["ManagedIdentityResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["MappingRuleName"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["TableName"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_EventHubDataConnection_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventHubDataConnection via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventHubDataConnection, EventHubDataConnectionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventHubDataConnection runs a test to see if a specific instance of EventHubDataConnection round trips to JSON and back losslessly
func RunJSONSerializationTestForEventHubDataConnection(subject EventHubDataConnection) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventHubDataConnection
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventHubDataConnection instances for property testing - lazily instantiated by
// EventHubDataConnectionGenerator()
var eventHubDataConnectionGenerator gopter.Gen

// EventHubDataConnectionGenerator returns a generator of EventHubDataConnection instances for property testing.
func EventHubDataConnectionGenerator() gopter.Gen {
	if eventHubDataConnectionGenerator != nil {
		return eventHubDataConnectionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventHubDataConnection(generators)
	eventHubDataConnectionGenerator = gen.Struct(reflect.TypeOf(EventHubDataConnection{}), generators)

	return eventHubDataConnectionGenerator
}

// AddIndependentPropertyGeneratorsForEventHubDataConnection is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventHubDataConnection(gens map[string]gopter.Gen) {
	gens["Compression"] = gen.PtrOf(gen.AlphaString())
	gens["ConsumerGroup"] = gen.PtrOf(gen.AlphaString())
	gens["DataFormat"] = gen.PtrOf(gen.AlphaString())
	gens["DatabaseRouting"] = gen.PtrOf(gen.AlphaString())
	gens["EventSystemProperties"] = gen.SliceOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["MappingRuleName"] = gen.PtrOf(gen.AlphaString())
	gens["RetrievalStartDate"] = gen.PtrOf(gen.AlphaString())
	gens["TableName"] = gen.PtrOf(gen.AlphaString())
}

func Test_EventHubDataConnection_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventHubDataConnection_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventHubDataConnection_STATUS, EventHubDataConnection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventHubDataConnection_STATUS runs a test to see if a specific instance of EventHubDataConnection_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEventHubDataConnection_STATUS(subject EventHubDataConnection_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventHubDataConnection_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventHubDataConnection_STATUS instances for property testing - lazily instantiated by
// EventHubDataConnection_STATUSGenerator()
var eventHubDataConnection_STATUSGenerator gopter.Gen

// EventHubDataConnection_STATUSGenerator returns a generator of EventHubDataConnection_STATUS instances for property testing.
func EventHubDataConnection_STATUSGenerator() gopter.Gen {
	if eventHubDataConnection_STATUSGenerator != nil {
		return eventHubDataConnection_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventHubDataConnection_STATUS(generators)
	eventHubDataConnection_STATUSGenerator = gen.Struct(reflect.TypeOf(EventHubDataConnection_STATUS{}), generators)

	return eventHubDataConnection_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForEventHubDataConnection_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventHubDataConnection_STATUS(gens map[string]gopter.Gen) {
	gens["Compression"] = gen.PtrOf(gen.AlphaString())
	gens["ConsumerGroup"] = gen.PtrOf(gen.AlphaString())
	gens["DataFormat"] = gen.PtrOf(gen.AlphaString())
	gens["DatabaseRouting"] = gen.PtrOf(gen.AlphaString())
	gens["EventHubResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["EventSystemProperties"] = gen.SliceOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["ManagedIdentityObjectId"] = gen.PtrOf(gen.AlphaString())
	gens["ManagedIdentityResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["MappingRuleName"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["RetrievalStartDate"] = gen.PtrOf(gen.AlphaString())
	gens["TableName"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_IotHubDataConnection_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IotHubDataConnection via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIotHubDataConnection, IotHubDataConnectionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIotHubDataConnection runs a test to see if a specific instance of IotHubDataConnection round trips to JSON and back losslessly
func RunJSONSerializationTestForIotHubDataConnection(subject IotHubDataConnection) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IotHubDataConnection
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IotHubDataConnection instances for property testing - lazily instantiated by
// IotHubDataConnectionGenerator()
var iotHubDataConnectionGenerator gopter.Gen

// IotHubDataConnectionGenerator returns a generator of IotHubDataConnection instances for property testing.
func IotHubDataConnectionGenerator() gopter.Gen {
	if iotHubDataConnectionGenerator != nil {
		return iotHubDataConnectionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIotHubDataConnection(generators)
	iotHubDataConnectionGenerator = gen.Struct(reflect.TypeOf(IotHubDataConnection{}), generators)

	return iotHubDataConnectionGenerator
}

// AddIndependentPropertyGeneratorsForIotHubDataConnection is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIotHubDataConnection(gens map[string]gopter.Gen) {
	gens["ConsumerGroup"] = gen.PtrOf(gen.AlphaString())
	gens["DataFormat"] = gen.PtrOf(gen.AlphaString())
	gens["DatabaseRouting"] = gen.PtrOf(gen.AlphaString())
	gens["EventSystemProperties"] = gen.SliceOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["MappingRuleName"] = gen.PtrOf(gen.AlphaString())
	gens["RetrievalStartDate"] = gen.PtrOf(gen.AlphaString())
	gens["SharedAccessPolicyName"] = gen.PtrOf(gen.AlphaString())
	gens["TableName"] = gen.PtrOf(gen.AlphaString())
}

func Test_IotHubDataConnection_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IotHubDataConnection_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIotHubDataConnection_STATUS, IotHubDataConnection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIotHubDataConnection_STATUS runs a test to see if a specific instance of IotHubDataConnection_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForIotHubDataConnection_STATUS(subject IotHubDataConnection_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IotHubDataConnection_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IotHubDataConnection_STATUS instances for property testing - lazily instantiated by
// IotHubDataConnection_STATUSGenerator()
var iotHubDataConnection_STATUSGenerator gopter.Gen

// IotHubDataConnection_STATUSGenerator returns a generator of IotHubDataConnection_STATUS instances for property testing.
func IotHubDataConnection_STATUSGenerator() gopter.Gen {
	if iotHubDataConnection_STATUSGenerator != nil {
		return iotHubDataConnection_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIotHubDataConnection_STATUS(generators)
	iotHubDataConnection_STATUSGenerator = gen.Struct(reflect.TypeOf(IotHubDataConnection_STATUS{}), generators)

	return iotHubDataConnection_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForIotHubDataConnection_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIotHubDataConnection_STATUS(gens map[string]gopter.Gen) {
	gens["ConsumerGroup"] = gen.PtrOf(gen.AlphaString())
	gens["DataFormat"] = gen.PtrOf(gen.AlphaString())
	gens["DatabaseRouting"] = gen.PtrOf(gen.AlphaString())
	gens["EventSystemProperties"] = gen.SliceOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IotHubResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["MappingRuleName"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["RetrievalStartDate"] = gen.PtrOf(gen.AlphaString())
	gens["SharedAccessPolicyName"] = gen.PtrOf(gen.AlphaString())
	gens["TableName"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}
