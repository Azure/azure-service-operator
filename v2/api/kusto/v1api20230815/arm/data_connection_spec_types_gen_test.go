// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package arm

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_CosmosDbDataConnection_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CosmosDbDataConnection via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCosmosDbDataConnection, CosmosDbDataConnectionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCosmosDbDataConnection runs a test to see if a specific instance of CosmosDbDataConnection round trips to JSON and back losslessly
func RunJSONSerializationTestForCosmosDbDataConnection(subject CosmosDbDataConnection) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CosmosDbDataConnection
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CosmosDbDataConnection instances for property testing - lazily instantiated by
// CosmosDbDataConnectionGenerator()
var cosmosDbDataConnectionGenerator gopter.Gen

// CosmosDbDataConnectionGenerator returns a generator of CosmosDbDataConnection instances for property testing.
// We first initialize cosmosDbDataConnectionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CosmosDbDataConnectionGenerator() gopter.Gen {
	if cosmosDbDataConnectionGenerator != nil {
		return cosmosDbDataConnectionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCosmosDbDataConnection(generators)
	cosmosDbDataConnectionGenerator = gen.Struct(reflect.TypeOf(CosmosDbDataConnection{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCosmosDbDataConnection(generators)
	AddRelatedPropertyGeneratorsForCosmosDbDataConnection(generators)
	cosmosDbDataConnectionGenerator = gen.Struct(reflect.TypeOf(CosmosDbDataConnection{}), generators)

	return cosmosDbDataConnectionGenerator
}

// AddIndependentPropertyGeneratorsForCosmosDbDataConnection is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCosmosDbDataConnection(gens map[string]gopter.Gen) {
	gens["Kind"] = gen.OneConstOf(CosmosDbDataConnection_Kind_CosmosDb)
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForCosmosDbDataConnection is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCosmosDbDataConnection(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(CosmosDbDataConnectionPropertiesGenerator())
}

func Test_CosmosDbDataConnectionProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CosmosDbDataConnectionProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCosmosDbDataConnectionProperties, CosmosDbDataConnectionPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCosmosDbDataConnectionProperties runs a test to see if a specific instance of CosmosDbDataConnectionProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForCosmosDbDataConnectionProperties(subject CosmosDbDataConnectionProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CosmosDbDataConnectionProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CosmosDbDataConnectionProperties instances for property testing - lazily instantiated by
// CosmosDbDataConnectionPropertiesGenerator()
var cosmosDbDataConnectionPropertiesGenerator gopter.Gen

// CosmosDbDataConnectionPropertiesGenerator returns a generator of CosmosDbDataConnectionProperties instances for property testing.
func CosmosDbDataConnectionPropertiesGenerator() gopter.Gen {
	if cosmosDbDataConnectionPropertiesGenerator != nil {
		return cosmosDbDataConnectionPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCosmosDbDataConnectionProperties(generators)
	cosmosDbDataConnectionPropertiesGenerator = gen.Struct(reflect.TypeOf(CosmosDbDataConnectionProperties{}), generators)

	return cosmosDbDataConnectionPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForCosmosDbDataConnectionProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCosmosDbDataConnectionProperties(gens map[string]gopter.Gen) {
	gens["CosmosDbAccountResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["CosmosDbContainer"] = gen.PtrOf(gen.AlphaString())
	gens["CosmosDbDatabase"] = gen.PtrOf(gen.AlphaString())
	gens["ManagedIdentityResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["MappingRuleName"] = gen.PtrOf(gen.AlphaString())
	gens["RetrievalStartDate"] = gen.PtrOf(gen.AlphaString())
	gens["TableName"] = gen.PtrOf(gen.AlphaString())
}

func Test_DataConnection_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataConnection_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataConnection_Spec, DataConnection_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataConnection_Spec runs a test to see if a specific instance of DataConnection_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForDataConnection_Spec(subject DataConnection_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataConnection_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataConnection_Spec instances for property testing - lazily instantiated by
// DataConnection_SpecGenerator()
var dataConnection_SpecGenerator gopter.Gen

// DataConnection_SpecGenerator returns a generator of DataConnection_Spec instances for property testing.
func DataConnection_SpecGenerator() gopter.Gen {
	if dataConnection_SpecGenerator != nil {
		return dataConnection_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDataConnection_Spec(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		props := map[string]gopter.Gen{propName: propGen}
		gens = append(gens, gen.Struct(reflect.TypeOf(DataConnection_Spec{}), props))
	}
	dataConnection_SpecGenerator = gen.OneGenOf(gens...)

	return dataConnection_SpecGenerator
}

// AddIndependentPropertyGeneratorsForDataConnection_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDataConnection_Spec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForDataConnection_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataConnection_Spec(gens map[string]gopter.Gen) {
	gens["CosmosDb"] = CosmosDbDataConnectionGenerator().Map(func(it CosmosDbDataConnection) *CosmosDbDataConnection {
		return &it
	}) // generate one case for OneOf type
	gens["EventGrid"] = EventGridDataConnectionGenerator().Map(func(it EventGridDataConnection) *EventGridDataConnection {
		return &it
	}) // generate one case for OneOf type
	gens["EventHub"] = EventHubDataConnectionGenerator().Map(func(it EventHubDataConnection) *EventHubDataConnection {
		return &it
	}) // generate one case for OneOf type
	gens["IotHub"] = IotHubDataConnectionGenerator().Map(func(it IotHubDataConnection) *IotHubDataConnection {
		return &it
	}) // generate one case for OneOf type
}

func Test_EventGridConnectionProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventGridConnectionProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventGridConnectionProperties, EventGridConnectionPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventGridConnectionProperties runs a test to see if a specific instance of EventGridConnectionProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForEventGridConnectionProperties(subject EventGridConnectionProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventGridConnectionProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventGridConnectionProperties instances for property testing - lazily instantiated by
// EventGridConnectionPropertiesGenerator()
var eventGridConnectionPropertiesGenerator gopter.Gen

// EventGridConnectionPropertiesGenerator returns a generator of EventGridConnectionProperties instances for property testing.
func EventGridConnectionPropertiesGenerator() gopter.Gen {
	if eventGridConnectionPropertiesGenerator != nil {
		return eventGridConnectionPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventGridConnectionProperties(generators)
	eventGridConnectionPropertiesGenerator = gen.Struct(reflect.TypeOf(EventGridConnectionProperties{}), generators)

	return eventGridConnectionPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForEventGridConnectionProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventGridConnectionProperties(gens map[string]gopter.Gen) {
	gens["BlobStorageEventType"] = gen.PtrOf(gen.OneConstOf(BlobStorageEventType_MicrosoftStorageBlobCreated, BlobStorageEventType_MicrosoftStorageBlobRenamed))
	gens["ConsumerGroup"] = gen.PtrOf(gen.AlphaString())
	gens["DataFormat"] = gen.PtrOf(gen.OneConstOf(
		EventGridDataFormat_APACHEAVRO,
		EventGridDataFormat_AVRO,
		EventGridDataFormat_CSV,
		EventGridDataFormat_JSON,
		EventGridDataFormat_MULTIJSON,
		EventGridDataFormat_ORC,
		EventGridDataFormat_PARQUET,
		EventGridDataFormat_PSV,
		EventGridDataFormat_RAW,
		EventGridDataFormat_SCSV,
		EventGridDataFormat_SINGLEJSON,
		EventGridDataFormat_SOHSV,
		EventGridDataFormat_TSV,
		EventGridDataFormat_TSVE,
		EventGridDataFormat_TXT,
		EventGridDataFormat_W3CLOGFILE))
	gens["DatabaseRouting"] = gen.PtrOf(gen.OneConstOf(EventGridConnectionProperties_DatabaseRouting_Multi, EventGridConnectionProperties_DatabaseRouting_Single))
	gens["EventGridResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["EventHubResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["IgnoreFirstRecord"] = gen.PtrOf(gen.Bool())
	gens["ManagedIdentityResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["MappingRuleName"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["TableName"] = gen.PtrOf(gen.AlphaString())
}

func Test_EventGridDataConnection_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventGridDataConnection via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventGridDataConnection, EventGridDataConnectionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventGridDataConnection runs a test to see if a specific instance of EventGridDataConnection round trips to JSON and back losslessly
func RunJSONSerializationTestForEventGridDataConnection(subject EventGridDataConnection) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventGridDataConnection
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventGridDataConnection instances for property testing - lazily instantiated by
// EventGridDataConnectionGenerator()
var eventGridDataConnectionGenerator gopter.Gen

// EventGridDataConnectionGenerator returns a generator of EventGridDataConnection instances for property testing.
// We first initialize eventGridDataConnectionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EventGridDataConnectionGenerator() gopter.Gen {
	if eventGridDataConnectionGenerator != nil {
		return eventGridDataConnectionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventGridDataConnection(generators)
	eventGridDataConnectionGenerator = gen.Struct(reflect.TypeOf(EventGridDataConnection{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventGridDataConnection(generators)
	AddRelatedPropertyGeneratorsForEventGridDataConnection(generators)
	eventGridDataConnectionGenerator = gen.Struct(reflect.TypeOf(EventGridDataConnection{}), generators)

	return eventGridDataConnectionGenerator
}

// AddIndependentPropertyGeneratorsForEventGridDataConnection is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventGridDataConnection(gens map[string]gopter.Gen) {
	gens["Kind"] = gen.OneConstOf(EventGridDataConnection_Kind_EventGrid)
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForEventGridDataConnection is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEventGridDataConnection(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(EventGridConnectionPropertiesGenerator())
}

func Test_EventHubConnectionProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventHubConnectionProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventHubConnectionProperties, EventHubConnectionPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventHubConnectionProperties runs a test to see if a specific instance of EventHubConnectionProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForEventHubConnectionProperties(subject EventHubConnectionProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventHubConnectionProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventHubConnectionProperties instances for property testing - lazily instantiated by
// EventHubConnectionPropertiesGenerator()
var eventHubConnectionPropertiesGenerator gopter.Gen

// EventHubConnectionPropertiesGenerator returns a generator of EventHubConnectionProperties instances for property testing.
func EventHubConnectionPropertiesGenerator() gopter.Gen {
	if eventHubConnectionPropertiesGenerator != nil {
		return eventHubConnectionPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventHubConnectionProperties(generators)
	eventHubConnectionPropertiesGenerator = gen.Struct(reflect.TypeOf(EventHubConnectionProperties{}), generators)

	return eventHubConnectionPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForEventHubConnectionProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventHubConnectionProperties(gens map[string]gopter.Gen) {
	gens["Compression"] = gen.PtrOf(gen.OneConstOf(Compression_GZip, Compression_None))
	gens["ConsumerGroup"] = gen.PtrOf(gen.AlphaString())
	gens["DataFormat"] = gen.PtrOf(gen.OneConstOf(
		EventHubDataFormat_APACHEAVRO,
		EventHubDataFormat_AVRO,
		EventHubDataFormat_CSV,
		EventHubDataFormat_JSON,
		EventHubDataFormat_MULTIJSON,
		EventHubDataFormat_ORC,
		EventHubDataFormat_PARQUET,
		EventHubDataFormat_PSV,
		EventHubDataFormat_RAW,
		EventHubDataFormat_SCSV,
		EventHubDataFormat_SINGLEJSON,
		EventHubDataFormat_SOHSV,
		EventHubDataFormat_TSV,
		EventHubDataFormat_TSVE,
		EventHubDataFormat_TXT,
		EventHubDataFormat_W3CLOGFILE))
	gens["DatabaseRouting"] = gen.PtrOf(gen.OneConstOf(EventHubConnectionProperties_DatabaseRouting_Multi, EventHubConnectionProperties_DatabaseRouting_Single))
	gens["EventHubResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["EventSystemProperties"] = gen.SliceOf(gen.AlphaString())
	gens["ManagedIdentityResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["MappingRuleName"] = gen.PtrOf(gen.AlphaString())
	gens["RetrievalStartDate"] = gen.PtrOf(gen.AlphaString())
	gens["TableName"] = gen.PtrOf(gen.AlphaString())
}

func Test_EventHubDataConnection_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventHubDataConnection via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventHubDataConnection, EventHubDataConnectionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventHubDataConnection runs a test to see if a specific instance of EventHubDataConnection round trips to JSON and back losslessly
func RunJSONSerializationTestForEventHubDataConnection(subject EventHubDataConnection) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventHubDataConnection
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventHubDataConnection instances for property testing - lazily instantiated by
// EventHubDataConnectionGenerator()
var eventHubDataConnectionGenerator gopter.Gen

// EventHubDataConnectionGenerator returns a generator of EventHubDataConnection instances for property testing.
// We first initialize eventHubDataConnectionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EventHubDataConnectionGenerator() gopter.Gen {
	if eventHubDataConnectionGenerator != nil {
		return eventHubDataConnectionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventHubDataConnection(generators)
	eventHubDataConnectionGenerator = gen.Struct(reflect.TypeOf(EventHubDataConnection{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventHubDataConnection(generators)
	AddRelatedPropertyGeneratorsForEventHubDataConnection(generators)
	eventHubDataConnectionGenerator = gen.Struct(reflect.TypeOf(EventHubDataConnection{}), generators)

	return eventHubDataConnectionGenerator
}

// AddIndependentPropertyGeneratorsForEventHubDataConnection is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventHubDataConnection(gens map[string]gopter.Gen) {
	gens["Kind"] = gen.OneConstOf(EventHubDataConnection_Kind_EventHub)
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForEventHubDataConnection is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEventHubDataConnection(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(EventHubConnectionPropertiesGenerator())
}

func Test_IotHubConnectionProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IotHubConnectionProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIotHubConnectionProperties, IotHubConnectionPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIotHubConnectionProperties runs a test to see if a specific instance of IotHubConnectionProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForIotHubConnectionProperties(subject IotHubConnectionProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IotHubConnectionProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IotHubConnectionProperties instances for property testing - lazily instantiated by
// IotHubConnectionPropertiesGenerator()
var iotHubConnectionPropertiesGenerator gopter.Gen

// IotHubConnectionPropertiesGenerator returns a generator of IotHubConnectionProperties instances for property testing.
func IotHubConnectionPropertiesGenerator() gopter.Gen {
	if iotHubConnectionPropertiesGenerator != nil {
		return iotHubConnectionPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIotHubConnectionProperties(generators)
	iotHubConnectionPropertiesGenerator = gen.Struct(reflect.TypeOf(IotHubConnectionProperties{}), generators)

	return iotHubConnectionPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForIotHubConnectionProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIotHubConnectionProperties(gens map[string]gopter.Gen) {
	gens["ConsumerGroup"] = gen.PtrOf(gen.AlphaString())
	gens["DataFormat"] = gen.PtrOf(gen.OneConstOf(
		IotHubDataFormat_APACHEAVRO,
		IotHubDataFormat_AVRO,
		IotHubDataFormat_CSV,
		IotHubDataFormat_JSON,
		IotHubDataFormat_MULTIJSON,
		IotHubDataFormat_ORC,
		IotHubDataFormat_PARQUET,
		IotHubDataFormat_PSV,
		IotHubDataFormat_RAW,
		IotHubDataFormat_SCSV,
		IotHubDataFormat_SINGLEJSON,
		IotHubDataFormat_SOHSV,
		IotHubDataFormat_TSV,
		IotHubDataFormat_TSVE,
		IotHubDataFormat_TXT,
		IotHubDataFormat_W3CLOGFILE))
	gens["DatabaseRouting"] = gen.PtrOf(gen.OneConstOf(IotHubConnectionProperties_DatabaseRouting_Multi, IotHubConnectionProperties_DatabaseRouting_Single))
	gens["EventSystemProperties"] = gen.SliceOf(gen.AlphaString())
	gens["IotHubResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["MappingRuleName"] = gen.PtrOf(gen.AlphaString())
	gens["RetrievalStartDate"] = gen.PtrOf(gen.AlphaString())
	gens["SharedAccessPolicyName"] = gen.PtrOf(gen.AlphaString())
	gens["TableName"] = gen.PtrOf(gen.AlphaString())
}

func Test_IotHubDataConnection_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IotHubDataConnection via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIotHubDataConnection, IotHubDataConnectionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIotHubDataConnection runs a test to see if a specific instance of IotHubDataConnection round trips to JSON and back losslessly
func RunJSONSerializationTestForIotHubDataConnection(subject IotHubDataConnection) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IotHubDataConnection
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IotHubDataConnection instances for property testing - lazily instantiated by
// IotHubDataConnectionGenerator()
var iotHubDataConnectionGenerator gopter.Gen

// IotHubDataConnectionGenerator returns a generator of IotHubDataConnection instances for property testing.
// We first initialize iotHubDataConnectionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IotHubDataConnectionGenerator() gopter.Gen {
	if iotHubDataConnectionGenerator != nil {
		return iotHubDataConnectionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIotHubDataConnection(generators)
	iotHubDataConnectionGenerator = gen.Struct(reflect.TypeOf(IotHubDataConnection{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIotHubDataConnection(generators)
	AddRelatedPropertyGeneratorsForIotHubDataConnection(generators)
	iotHubDataConnectionGenerator = gen.Struct(reflect.TypeOf(IotHubDataConnection{}), generators)

	return iotHubDataConnectionGenerator
}

// AddIndependentPropertyGeneratorsForIotHubDataConnection is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIotHubDataConnection(gens map[string]gopter.Gen) {
	gens["Kind"] = gen.OneConstOf(IotHubDataConnection_Kind_IotHub)
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForIotHubDataConnection is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIotHubDataConnection(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(IotHubConnectionPropertiesGenerator())
}
