// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20230815

import (
	"fmt"
	arm "github.com/Azure/azure-service-operator/v2/api/kusto/v1api20230815/arm"
	storage "github.com/Azure/azure-service-operator/v2/api/kusto/v1api20230815/storage"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/rotisserie/eris"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
)

// +kubebuilder:object:root=true
// +kubebuilder:resource:categories={azure,kusto}
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /azure-kusto/resource-manager/Microsoft.Kusto/stable/2023-08-15/kusto.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}
type Cluster struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              Cluster_Spec   `json:"spec,omitempty"`
	Status            Cluster_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &Cluster{}

// GetConditions returns the conditions of the resource
func (cluster *Cluster) GetConditions() conditions.Conditions {
	return cluster.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (cluster *Cluster) SetConditions(conditions conditions.Conditions) {
	cluster.Status.Conditions = conditions
}

var _ conversion.Convertible = &Cluster{}

// ConvertFrom populates our Cluster from the provided hub Cluster
func (cluster *Cluster) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*storage.Cluster)
	if !ok {
		return fmt.Errorf("expected kusto/v1api20230815/storage/Cluster but received %T instead", hub)
	}

	return cluster.AssignProperties_From_Cluster(source)
}

// ConvertTo populates the provided hub Cluster from our Cluster
func (cluster *Cluster) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*storage.Cluster)
	if !ok {
		return fmt.Errorf("expected kusto/v1api20230815/storage/Cluster but received %T instead", hub)
	}

	return cluster.AssignProperties_To_Cluster(destination)
}

var _ configmaps.Exporter = &Cluster{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (cluster *Cluster) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if cluster.Spec.OperatorSpec == nil {
		return nil
	}
	return cluster.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &Cluster{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (cluster *Cluster) SecretDestinationExpressions() []*core.DestinationExpression {
	if cluster.Spec.OperatorSpec == nil {
		return nil
	}
	return cluster.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.ImportableResource = &Cluster{}

// InitializeSpec initializes the spec for this resource from the given status
func (cluster *Cluster) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*Cluster_STATUS); ok {
		return cluster.Spec.Initialize_From_Cluster_STATUS(s)
	}

	return fmt.Errorf("expected Status of type Cluster_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &Cluster{}

// AzureName returns the Azure name of the resource
func (cluster *Cluster) AzureName() string {
	return cluster.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2023-08-15"
func (cluster Cluster) GetAPIVersion() string {
	return "2023-08-15"
}

// GetResourceScope returns the scope of the resource
func (cluster *Cluster) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (cluster *Cluster) GetSpec() genruntime.ConvertibleSpec {
	return &cluster.Spec
}

// GetStatus returns the status of this resource
func (cluster *Cluster) GetStatus() genruntime.ConvertibleStatus {
	return &cluster.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (cluster *Cluster) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Kusto/clusters"
func (cluster *Cluster) GetType() string {
	return "Microsoft.Kusto/clusters"
}

// NewEmptyStatus returns a new empty (blank) status
func (cluster *Cluster) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &Cluster_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (cluster *Cluster) Owner() *genruntime.ResourceReference {
	if cluster.Spec.Owner == nil {
		return nil
	}

	group, kind := genruntime.LookupOwnerGroupKind(cluster.Spec)
	return cluster.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (cluster *Cluster) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*Cluster_STATUS); ok {
		cluster.Status = *st
		return nil
	}

	// Convert status to required version
	var st Cluster_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return eris.Wrap(err, "failed to convert status")
	}

	cluster.Status = st
	return nil
}

// AssignProperties_From_Cluster populates our Cluster from the provided source Cluster
func (cluster *Cluster) AssignProperties_From_Cluster(source *storage.Cluster) error {

	// ObjectMeta
	cluster.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec Cluster_Spec
	err := spec.AssignProperties_From_Cluster_Spec(&source.Spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_Cluster_Spec() to populate field Spec")
	}
	cluster.Spec = spec

	// Status
	var status Cluster_STATUS
	err = status.AssignProperties_From_Cluster_STATUS(&source.Status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_Cluster_STATUS() to populate field Status")
	}
	cluster.Status = status

	// No error
	return nil
}

// AssignProperties_To_Cluster populates the provided destination Cluster from our Cluster
func (cluster *Cluster) AssignProperties_To_Cluster(destination *storage.Cluster) error {

	// ObjectMeta
	destination.ObjectMeta = *cluster.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.Cluster_Spec
	err := cluster.Spec.AssignProperties_To_Cluster_Spec(&spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_Cluster_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.Cluster_STATUS
	err = cluster.Status.AssignProperties_To_Cluster_STATUS(&status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_Cluster_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (cluster *Cluster) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: cluster.Spec.OriginalVersion(),
		Kind:    "Cluster",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /azure-kusto/resource-manager/Microsoft.Kusto/stable/2023-08-15/kusto.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}
type ClusterList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Cluster `json:"items"`
}

// +kubebuilder:validation:Enum={"2023-08-15"}
type APIVersion string

const APIVersion_Value = APIVersion("2023-08-15")

type Cluster_Spec struct {
	// AcceptedAudiences: The cluster's accepted audiences.
	AcceptedAudiences []AcceptedAudiences `json:"acceptedAudiences,omitempty"`

	// AllowedFqdnList: List of allowed FQDNs(Fully Qualified Domain Name) for egress from Cluster.
	AllowedFqdnList []string `json:"allowedFqdnList,omitempty"`

	// AllowedIpRangeList: The list of ips in the format of CIDR allowed to connect to the cluster.
	AllowedIpRangeList []string `json:"allowedIpRangeList,omitempty"`

	// +kubebuilder:validation:Pattern="^.*$"
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// EnableAutoStop: A boolean value that indicates if the cluster could be automatically stopped (due to lack of data or no
	// activity for many days).
	EnableAutoStop *bool `json:"enableAutoStop,omitempty"`

	// EnableDiskEncryption: A boolean value that indicates if the cluster's disks are encrypted.
	EnableDiskEncryption *bool `json:"enableDiskEncryption,omitempty"`

	// EnableDoubleEncryption: A boolean value that indicates if double encryption is enabled.
	EnableDoubleEncryption *bool `json:"enableDoubleEncryption,omitempty"`

	// EnablePurge: A boolean value that indicates if the purge operations are enabled.
	EnablePurge *bool `json:"enablePurge,omitempty"`

	// EnableStreamingIngest: A boolean value that indicates if the streaming ingest is enabled.
	EnableStreamingIngest *bool `json:"enableStreamingIngest,omitempty"`

	// EngineType: The engine type
	EngineType *ClusterProperties_EngineType `json:"engineType,omitempty"`

	// Identity: The identity of the cluster, if configured.
	Identity *Identity `json:"identity,omitempty"`

	// KeyVaultProperties: KeyVault properties for the cluster encryption.
	KeyVaultProperties *KeyVaultProperties `json:"keyVaultProperties,omitempty"`

	// LanguageExtensions: List of the cluster's language extensions.
	LanguageExtensions *LanguageExtensionsList `json:"languageExtensions,omitempty"`

	// +kubebuilder:validation:Required
	// Location: The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *ClusterOperatorSpec `json:"operatorSpec,omitempty"`

	// OptimizedAutoscale: Optimized auto scale definition.
	OptimizedAutoscale *OptimizedAutoscale `json:"optimizedAutoscale,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`

	// PublicIPType: Indicates what public IP type to create - IPv4 (default), or DualStack (both IPv4 and IPv6)
	PublicIPType *ClusterProperties_PublicIPType `json:"publicIPType,omitempty"`

	// PublicNetworkAccess: Public network access to the cluster is enabled by default. When disabled, only private endpoint
	// connection to the cluster is allowed
	PublicNetworkAccess *ClusterProperties_PublicNetworkAccess `json:"publicNetworkAccess,omitempty"`

	// RestrictOutboundNetworkAccess: Whether or not to restrict outbound network access.  Value is optional but if passed in,
	// must be 'Enabled' or 'Disabled'
	RestrictOutboundNetworkAccess *ClusterProperties_RestrictOutboundNetworkAccess `json:"restrictOutboundNetworkAccess,omitempty"`

	// +kubebuilder:validation:Required
	// Sku: The SKU of the cluster.
	Sku *AzureSku `json:"sku,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// TrustedExternalTenants: The cluster's external tenants.
	TrustedExternalTenants []TrustedExternalTenant `json:"trustedExternalTenants,omitempty"`

	// VirtualClusterGraduationProperties: Virtual Cluster graduation properties
	VirtualClusterGraduationProperties *genruntime.SecretReference `json:"virtualClusterGraduationProperties,omitempty"`

	// VirtualNetworkConfiguration: Virtual network definition.
	VirtualNetworkConfiguration *VirtualNetworkConfiguration `json:"virtualNetworkConfiguration,omitempty"`

	// Zones: The availability zones of the cluster.
	Zones []string `json:"zones,omitempty"`
}

var _ genruntime.ARMTransformer = &Cluster_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (cluster *Cluster_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if cluster == nil {
		return nil, nil
	}
	result := &arm.Cluster_Spec{}

	// Set property "Identity":
	if cluster.Identity != nil {
		identity_ARM, err := (*cluster.Identity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := *identity_ARM.(*arm.Identity)
		result.Identity = &identity
	}

	// Set property "Location":
	if cluster.Location != nil {
		location := *cluster.Location
		result.Location = &location
	}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if cluster.AcceptedAudiences != nil ||
		cluster.AllowedFqdnList != nil ||
		cluster.AllowedIpRangeList != nil ||
		cluster.EnableAutoStop != nil ||
		cluster.EnableDiskEncryption != nil ||
		cluster.EnableDoubleEncryption != nil ||
		cluster.EnablePurge != nil ||
		cluster.EnableStreamingIngest != nil ||
		cluster.EngineType != nil ||
		cluster.KeyVaultProperties != nil ||
		cluster.LanguageExtensions != nil ||
		cluster.OptimizedAutoscale != nil ||
		cluster.PublicIPType != nil ||
		cluster.PublicNetworkAccess != nil ||
		cluster.RestrictOutboundNetworkAccess != nil ||
		cluster.TrustedExternalTenants != nil ||
		cluster.VirtualClusterGraduationProperties != nil ||
		cluster.VirtualNetworkConfiguration != nil {
		result.Properties = &arm.ClusterProperties{}
	}
	for _, item := range cluster.AcceptedAudiences {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.AcceptedAudiences = append(result.Properties.AcceptedAudiences, *item_ARM.(*arm.AcceptedAudiences))
	}
	for _, item := range cluster.AllowedFqdnList {
		result.Properties.AllowedFqdnList = append(result.Properties.AllowedFqdnList, item)
	}
	for _, item := range cluster.AllowedIpRangeList {
		result.Properties.AllowedIpRangeList = append(result.Properties.AllowedIpRangeList, item)
	}
	if cluster.EnableAutoStop != nil {
		enableAutoStop := *cluster.EnableAutoStop
		result.Properties.EnableAutoStop = &enableAutoStop
	}
	if cluster.EnableDiskEncryption != nil {
		enableDiskEncryption := *cluster.EnableDiskEncryption
		result.Properties.EnableDiskEncryption = &enableDiskEncryption
	}
	if cluster.EnableDoubleEncryption != nil {
		enableDoubleEncryption := *cluster.EnableDoubleEncryption
		result.Properties.EnableDoubleEncryption = &enableDoubleEncryption
	}
	if cluster.EnablePurge != nil {
		enablePurge := *cluster.EnablePurge
		result.Properties.EnablePurge = &enablePurge
	}
	if cluster.EnableStreamingIngest != nil {
		enableStreamingIngest := *cluster.EnableStreamingIngest
		result.Properties.EnableStreamingIngest = &enableStreamingIngest
	}
	if cluster.EngineType != nil {
		var temp string
		temp = string(*cluster.EngineType)
		engineType := arm.ClusterProperties_EngineType(temp)
		result.Properties.EngineType = &engineType
	}
	if cluster.KeyVaultProperties != nil {
		keyVaultProperties_ARM, err := (*cluster.KeyVaultProperties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		keyVaultProperties := *keyVaultProperties_ARM.(*arm.KeyVaultProperties)
		result.Properties.KeyVaultProperties = &keyVaultProperties
	}
	if cluster.LanguageExtensions != nil {
		languageExtensions_ARM, err := (*cluster.LanguageExtensions).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		languageExtensions := *languageExtensions_ARM.(*arm.LanguageExtensionsList)
		result.Properties.LanguageExtensions = &languageExtensions
	}
	if cluster.OptimizedAutoscale != nil {
		optimizedAutoscale_ARM, err := (*cluster.OptimizedAutoscale).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		optimizedAutoscale := *optimizedAutoscale_ARM.(*arm.OptimizedAutoscale)
		result.Properties.OptimizedAutoscale = &optimizedAutoscale
	}
	if cluster.PublicIPType != nil {
		var temp string
		temp = string(*cluster.PublicIPType)
		publicIPType := arm.ClusterProperties_PublicIPType(temp)
		result.Properties.PublicIPType = &publicIPType
	}
	if cluster.PublicNetworkAccess != nil {
		var temp string
		temp = string(*cluster.PublicNetworkAccess)
		publicNetworkAccess := arm.ClusterProperties_PublicNetworkAccess(temp)
		result.Properties.PublicNetworkAccess = &publicNetworkAccess
	}
	if cluster.RestrictOutboundNetworkAccess != nil {
		var temp string
		temp = string(*cluster.RestrictOutboundNetworkAccess)
		restrictOutboundNetworkAccess := arm.ClusterProperties_RestrictOutboundNetworkAccess(temp)
		result.Properties.RestrictOutboundNetworkAccess = &restrictOutboundNetworkAccess
	}
	for _, item := range cluster.TrustedExternalTenants {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.TrustedExternalTenants = append(result.Properties.TrustedExternalTenants, *item_ARM.(*arm.TrustedExternalTenant))
	}
	if cluster.VirtualClusterGraduationProperties != nil {
		virtualClusterGraduationPropertiesSecret, err := resolved.ResolvedSecrets.Lookup(*cluster.VirtualClusterGraduationProperties)
		if err != nil {
			return nil, eris.Wrap(err, "looking up secret for property VirtualClusterGraduationProperties")
		}
		virtualClusterGraduationProperties := virtualClusterGraduationPropertiesSecret
		result.Properties.VirtualClusterGraduationProperties = &virtualClusterGraduationProperties
	}
	if cluster.VirtualNetworkConfiguration != nil {
		virtualNetworkConfiguration_ARM, err := (*cluster.VirtualNetworkConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		virtualNetworkConfiguration := *virtualNetworkConfiguration_ARM.(*arm.VirtualNetworkConfiguration)
		result.Properties.VirtualNetworkConfiguration = &virtualNetworkConfiguration
	}

	// Set property "Sku":
	if cluster.Sku != nil {
		sku_ARM, err := (*cluster.Sku).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sku := *sku_ARM.(*arm.AzureSku)
		result.Sku = &sku
	}

	// Set property "Tags":
	if cluster.Tags != nil {
		result.Tags = make(map[string]string, len(cluster.Tags))
		for key, value := range cluster.Tags {
			result.Tags[key] = value
		}
	}

	// Set property "Zones":
	for _, item := range cluster.Zones {
		result.Zones = append(result.Zones, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (cluster *Cluster_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Cluster_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (cluster *Cluster_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Cluster_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Cluster_Spec, got %T", armInput)
	}

	// Set property "AcceptedAudiences":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.AcceptedAudiences {
			var item1 AcceptedAudiences
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			cluster.AcceptedAudiences = append(cluster.AcceptedAudiences, item1)
		}
	}

	// Set property "AllowedFqdnList":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.AllowedFqdnList {
			cluster.AllowedFqdnList = append(cluster.AllowedFqdnList, item)
		}
	}

	// Set property "AllowedIpRangeList":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.AllowedIpRangeList {
			cluster.AllowedIpRangeList = append(cluster.AllowedIpRangeList, item)
		}
	}

	// Set property "AzureName":
	cluster.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "EnableAutoStop":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableAutoStop != nil {
			enableAutoStop := *typedInput.Properties.EnableAutoStop
			cluster.EnableAutoStop = &enableAutoStop
		}
	}

	// Set property "EnableDiskEncryption":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableDiskEncryption != nil {
			enableDiskEncryption := *typedInput.Properties.EnableDiskEncryption
			cluster.EnableDiskEncryption = &enableDiskEncryption
		}
	}

	// Set property "EnableDoubleEncryption":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableDoubleEncryption != nil {
			enableDoubleEncryption := *typedInput.Properties.EnableDoubleEncryption
			cluster.EnableDoubleEncryption = &enableDoubleEncryption
		}
	}

	// Set property "EnablePurge":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnablePurge != nil {
			enablePurge := *typedInput.Properties.EnablePurge
			cluster.EnablePurge = &enablePurge
		}
	}

	// Set property "EnableStreamingIngest":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableStreamingIngest != nil {
			enableStreamingIngest := *typedInput.Properties.EnableStreamingIngest
			cluster.EnableStreamingIngest = &enableStreamingIngest
		}
	}

	// Set property "EngineType":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EngineType != nil {
			var temp string
			temp = string(*typedInput.Properties.EngineType)
			engineType := ClusterProperties_EngineType(temp)
			cluster.EngineType = &engineType
		}
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 Identity
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		cluster.Identity = &identity
	}

	// Set property "KeyVaultProperties":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.KeyVaultProperties != nil {
			var keyVaultProperties1 KeyVaultProperties
			err := keyVaultProperties1.PopulateFromARM(owner, *typedInput.Properties.KeyVaultProperties)
			if err != nil {
				return err
			}
			keyVaultProperties := keyVaultProperties1
			cluster.KeyVaultProperties = &keyVaultProperties
		}
	}

	// Set property "LanguageExtensions":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LanguageExtensions != nil {
			var languageExtensions1 LanguageExtensionsList
			err := languageExtensions1.PopulateFromARM(owner, *typedInput.Properties.LanguageExtensions)
			if err != nil {
				return err
			}
			languageExtensions := languageExtensions1
			cluster.LanguageExtensions = &languageExtensions
		}
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		cluster.Location = &location
	}

	// no assignment for property "OperatorSpec"

	// Set property "OptimizedAutoscale":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.OptimizedAutoscale != nil {
			var optimizedAutoscale1 OptimizedAutoscale
			err := optimizedAutoscale1.PopulateFromARM(owner, *typedInput.Properties.OptimizedAutoscale)
			if err != nil {
				return err
			}
			optimizedAutoscale := optimizedAutoscale1
			cluster.OptimizedAutoscale = &optimizedAutoscale
		}
	}

	// Set property "Owner":
	cluster.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "PublicIPType":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPType != nil {
			var temp string
			temp = string(*typedInput.Properties.PublicIPType)
			publicIPType := ClusterProperties_PublicIPType(temp)
			cluster.PublicIPType = &publicIPType
		}
	}

	// Set property "PublicNetworkAccess":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicNetworkAccess != nil {
			var temp string
			temp = string(*typedInput.Properties.PublicNetworkAccess)
			publicNetworkAccess := ClusterProperties_PublicNetworkAccess(temp)
			cluster.PublicNetworkAccess = &publicNetworkAccess
		}
	}

	// Set property "RestrictOutboundNetworkAccess":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RestrictOutboundNetworkAccess != nil {
			var temp string
			temp = string(*typedInput.Properties.RestrictOutboundNetworkAccess)
			restrictOutboundNetworkAccess := ClusterProperties_RestrictOutboundNetworkAccess(temp)
			cluster.RestrictOutboundNetworkAccess = &restrictOutboundNetworkAccess
		}
	}

	// Set property "Sku":
	if typedInput.Sku != nil {
		var sku1 AzureSku
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		cluster.Sku = &sku
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		cluster.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			cluster.Tags[key] = value
		}
	}

	// Set property "TrustedExternalTenants":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.TrustedExternalTenants {
			var item1 TrustedExternalTenant
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			cluster.TrustedExternalTenants = append(cluster.TrustedExternalTenants, item1)
		}
	}

	// no assignment for property "VirtualClusterGraduationProperties"

	// Set property "VirtualNetworkConfiguration":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VirtualNetworkConfiguration != nil {
			var virtualNetworkConfiguration1 VirtualNetworkConfiguration
			err := virtualNetworkConfiguration1.PopulateFromARM(owner, *typedInput.Properties.VirtualNetworkConfiguration)
			if err != nil {
				return err
			}
			virtualNetworkConfiguration := virtualNetworkConfiguration1
			cluster.VirtualNetworkConfiguration = &virtualNetworkConfiguration
		}
	}

	// Set property "Zones":
	for _, item := range typedInput.Zones {
		cluster.Zones = append(cluster.Zones, item)
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &Cluster_Spec{}

// ConvertSpecFrom populates our Cluster_Spec from the provided source
func (cluster *Cluster_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.Cluster_Spec)
	if ok {
		// Populate our instance from source
		return cluster.AssignProperties_From_Cluster_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.Cluster_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = cluster.AssignProperties_From_Cluster_Spec(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our Cluster_Spec
func (cluster *Cluster_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.Cluster_Spec)
	if ok {
		// Populate destination from our instance
		return cluster.AssignProperties_To_Cluster_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.Cluster_Spec{}
	err := cluster.AssignProperties_To_Cluster_Spec(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_Cluster_Spec populates our Cluster_Spec from the provided source Cluster_Spec
func (cluster *Cluster_Spec) AssignProperties_From_Cluster_Spec(source *storage.Cluster_Spec) error {

	// AcceptedAudiences
	if source.AcceptedAudiences != nil {
		acceptedAudienceList := make([]AcceptedAudiences, len(source.AcceptedAudiences))
		for acceptedAudienceIndex, acceptedAudienceItem := range source.AcceptedAudiences {
			// Shadow the loop variable to avoid aliasing
			acceptedAudienceItem := acceptedAudienceItem
			var acceptedAudience AcceptedAudiences
			err := acceptedAudience.AssignProperties_From_AcceptedAudiences(&acceptedAudienceItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_AcceptedAudiences() to populate field AcceptedAudiences")
			}
			acceptedAudienceList[acceptedAudienceIndex] = acceptedAudience
		}
		cluster.AcceptedAudiences = acceptedAudienceList
	} else {
		cluster.AcceptedAudiences = nil
	}

	// AllowedFqdnList
	cluster.AllowedFqdnList = genruntime.CloneSliceOfString(source.AllowedFqdnList)

	// AllowedIpRangeList
	cluster.AllowedIpRangeList = genruntime.CloneSliceOfString(source.AllowedIpRangeList)

	// AzureName
	cluster.AzureName = source.AzureName

	// EnableAutoStop
	if source.EnableAutoStop != nil {
		enableAutoStop := *source.EnableAutoStop
		cluster.EnableAutoStop = &enableAutoStop
	} else {
		cluster.EnableAutoStop = nil
	}

	// EnableDiskEncryption
	if source.EnableDiskEncryption != nil {
		enableDiskEncryption := *source.EnableDiskEncryption
		cluster.EnableDiskEncryption = &enableDiskEncryption
	} else {
		cluster.EnableDiskEncryption = nil
	}

	// EnableDoubleEncryption
	if source.EnableDoubleEncryption != nil {
		enableDoubleEncryption := *source.EnableDoubleEncryption
		cluster.EnableDoubleEncryption = &enableDoubleEncryption
	} else {
		cluster.EnableDoubleEncryption = nil
	}

	// EnablePurge
	if source.EnablePurge != nil {
		enablePurge := *source.EnablePurge
		cluster.EnablePurge = &enablePurge
	} else {
		cluster.EnablePurge = nil
	}

	// EnableStreamingIngest
	if source.EnableStreamingIngest != nil {
		enableStreamingIngest := *source.EnableStreamingIngest
		cluster.EnableStreamingIngest = &enableStreamingIngest
	} else {
		cluster.EnableStreamingIngest = nil
	}

	// EngineType
	if source.EngineType != nil {
		engineType := *source.EngineType
		engineTypeTemp := genruntime.ToEnum(engineType, clusterProperties_EngineType_Values)
		cluster.EngineType = &engineTypeTemp
	} else {
		cluster.EngineType = nil
	}

	// Identity
	if source.Identity != nil {
		var identity Identity
		err := identity.AssignProperties_From_Identity(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Identity() to populate field Identity")
		}
		cluster.Identity = &identity
	} else {
		cluster.Identity = nil
	}

	// KeyVaultProperties
	if source.KeyVaultProperties != nil {
		var keyVaultProperty KeyVaultProperties
		err := keyVaultProperty.AssignProperties_From_KeyVaultProperties(source.KeyVaultProperties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_KeyVaultProperties() to populate field KeyVaultProperties")
		}
		cluster.KeyVaultProperties = &keyVaultProperty
	} else {
		cluster.KeyVaultProperties = nil
	}

	// LanguageExtensions
	if source.LanguageExtensions != nil {
		var languageExtension LanguageExtensionsList
		err := languageExtension.AssignProperties_From_LanguageExtensionsList(source.LanguageExtensions)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_LanguageExtensionsList() to populate field LanguageExtensions")
		}
		cluster.LanguageExtensions = &languageExtension
	} else {
		cluster.LanguageExtensions = nil
	}

	// Location
	cluster.Location = genruntime.ClonePointerToString(source.Location)

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec ClusterOperatorSpec
		err := operatorSpec.AssignProperties_From_ClusterOperatorSpec(source.OperatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ClusterOperatorSpec() to populate field OperatorSpec")
		}
		cluster.OperatorSpec = &operatorSpec
	} else {
		cluster.OperatorSpec = nil
	}

	// OptimizedAutoscale
	if source.OptimizedAutoscale != nil {
		var optimizedAutoscale OptimizedAutoscale
		err := optimizedAutoscale.AssignProperties_From_OptimizedAutoscale(source.OptimizedAutoscale)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_OptimizedAutoscale() to populate field OptimizedAutoscale")
		}
		cluster.OptimizedAutoscale = &optimizedAutoscale
	} else {
		cluster.OptimizedAutoscale = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		cluster.Owner = &owner
	} else {
		cluster.Owner = nil
	}

	// PublicIPType
	if source.PublicIPType != nil {
		publicIPType := *source.PublicIPType
		publicIPTypeTemp := genruntime.ToEnum(publicIPType, clusterProperties_PublicIPType_Values)
		cluster.PublicIPType = &publicIPTypeTemp
	} else {
		cluster.PublicIPType = nil
	}

	// PublicNetworkAccess
	if source.PublicNetworkAccess != nil {
		publicNetworkAccess := *source.PublicNetworkAccess
		publicNetworkAccessTemp := genruntime.ToEnum(publicNetworkAccess, clusterProperties_PublicNetworkAccess_Values)
		cluster.PublicNetworkAccess = &publicNetworkAccessTemp
	} else {
		cluster.PublicNetworkAccess = nil
	}

	// RestrictOutboundNetworkAccess
	if source.RestrictOutboundNetworkAccess != nil {
		restrictOutboundNetworkAccess := *source.RestrictOutboundNetworkAccess
		restrictOutboundNetworkAccessTemp := genruntime.ToEnum(restrictOutboundNetworkAccess, clusterProperties_RestrictOutboundNetworkAccess_Values)
		cluster.RestrictOutboundNetworkAccess = &restrictOutboundNetworkAccessTemp
	} else {
		cluster.RestrictOutboundNetworkAccess = nil
	}

	// Sku
	if source.Sku != nil {
		var sku AzureSku
		err := sku.AssignProperties_From_AzureSku(source.Sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AzureSku() to populate field Sku")
		}
		cluster.Sku = &sku
	} else {
		cluster.Sku = nil
	}

	// Tags
	cluster.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// TrustedExternalTenants
	if source.TrustedExternalTenants != nil {
		trustedExternalTenantList := make([]TrustedExternalTenant, len(source.TrustedExternalTenants))
		for trustedExternalTenantIndex, trustedExternalTenantItem := range source.TrustedExternalTenants {
			// Shadow the loop variable to avoid aliasing
			trustedExternalTenantItem := trustedExternalTenantItem
			var trustedExternalTenant TrustedExternalTenant
			err := trustedExternalTenant.AssignProperties_From_TrustedExternalTenant(&trustedExternalTenantItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_TrustedExternalTenant() to populate field TrustedExternalTenants")
			}
			trustedExternalTenantList[trustedExternalTenantIndex] = trustedExternalTenant
		}
		cluster.TrustedExternalTenants = trustedExternalTenantList
	} else {
		cluster.TrustedExternalTenants = nil
	}

	// VirtualClusterGraduationProperties
	if source.VirtualClusterGraduationProperties != nil {
		virtualClusterGraduationProperty := source.VirtualClusterGraduationProperties.Copy()
		cluster.VirtualClusterGraduationProperties = &virtualClusterGraduationProperty
	} else {
		cluster.VirtualClusterGraduationProperties = nil
	}

	// VirtualNetworkConfiguration
	if source.VirtualNetworkConfiguration != nil {
		var virtualNetworkConfiguration VirtualNetworkConfiguration
		err := virtualNetworkConfiguration.AssignProperties_From_VirtualNetworkConfiguration(source.VirtualNetworkConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VirtualNetworkConfiguration() to populate field VirtualNetworkConfiguration")
		}
		cluster.VirtualNetworkConfiguration = &virtualNetworkConfiguration
	} else {
		cluster.VirtualNetworkConfiguration = nil
	}

	// Zones
	cluster.Zones = genruntime.CloneSliceOfString(source.Zones)

	// No error
	return nil
}

// AssignProperties_To_Cluster_Spec populates the provided destination Cluster_Spec from our Cluster_Spec
func (cluster *Cluster_Spec) AssignProperties_To_Cluster_Spec(destination *storage.Cluster_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AcceptedAudiences
	if cluster.AcceptedAudiences != nil {
		acceptedAudienceList := make([]storage.AcceptedAudiences, len(cluster.AcceptedAudiences))
		for acceptedAudienceIndex, acceptedAudienceItem := range cluster.AcceptedAudiences {
			// Shadow the loop variable to avoid aliasing
			acceptedAudienceItem := acceptedAudienceItem
			var acceptedAudience storage.AcceptedAudiences
			err := acceptedAudienceItem.AssignProperties_To_AcceptedAudiences(&acceptedAudience)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_AcceptedAudiences() to populate field AcceptedAudiences")
			}
			acceptedAudienceList[acceptedAudienceIndex] = acceptedAudience
		}
		destination.AcceptedAudiences = acceptedAudienceList
	} else {
		destination.AcceptedAudiences = nil
	}

	// AllowedFqdnList
	destination.AllowedFqdnList = genruntime.CloneSliceOfString(cluster.AllowedFqdnList)

	// AllowedIpRangeList
	destination.AllowedIpRangeList = genruntime.CloneSliceOfString(cluster.AllowedIpRangeList)

	// AzureName
	destination.AzureName = cluster.AzureName

	// EnableAutoStop
	if cluster.EnableAutoStop != nil {
		enableAutoStop := *cluster.EnableAutoStop
		destination.EnableAutoStop = &enableAutoStop
	} else {
		destination.EnableAutoStop = nil
	}

	// EnableDiskEncryption
	if cluster.EnableDiskEncryption != nil {
		enableDiskEncryption := *cluster.EnableDiskEncryption
		destination.EnableDiskEncryption = &enableDiskEncryption
	} else {
		destination.EnableDiskEncryption = nil
	}

	// EnableDoubleEncryption
	if cluster.EnableDoubleEncryption != nil {
		enableDoubleEncryption := *cluster.EnableDoubleEncryption
		destination.EnableDoubleEncryption = &enableDoubleEncryption
	} else {
		destination.EnableDoubleEncryption = nil
	}

	// EnablePurge
	if cluster.EnablePurge != nil {
		enablePurge := *cluster.EnablePurge
		destination.EnablePurge = &enablePurge
	} else {
		destination.EnablePurge = nil
	}

	// EnableStreamingIngest
	if cluster.EnableStreamingIngest != nil {
		enableStreamingIngest := *cluster.EnableStreamingIngest
		destination.EnableStreamingIngest = &enableStreamingIngest
	} else {
		destination.EnableStreamingIngest = nil
	}

	// EngineType
	if cluster.EngineType != nil {
		engineType := string(*cluster.EngineType)
		destination.EngineType = &engineType
	} else {
		destination.EngineType = nil
	}

	// Identity
	if cluster.Identity != nil {
		var identity storage.Identity
		err := cluster.Identity.AssignProperties_To_Identity(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Identity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// KeyVaultProperties
	if cluster.KeyVaultProperties != nil {
		var keyVaultProperty storage.KeyVaultProperties
		err := cluster.KeyVaultProperties.AssignProperties_To_KeyVaultProperties(&keyVaultProperty)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_KeyVaultProperties() to populate field KeyVaultProperties")
		}
		destination.KeyVaultProperties = &keyVaultProperty
	} else {
		destination.KeyVaultProperties = nil
	}

	// LanguageExtensions
	if cluster.LanguageExtensions != nil {
		var languageExtension storage.LanguageExtensionsList
		err := cluster.LanguageExtensions.AssignProperties_To_LanguageExtensionsList(&languageExtension)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_LanguageExtensionsList() to populate field LanguageExtensions")
		}
		destination.LanguageExtensions = &languageExtension
	} else {
		destination.LanguageExtensions = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(cluster.Location)

	// OperatorSpec
	if cluster.OperatorSpec != nil {
		var operatorSpec storage.ClusterOperatorSpec
		err := cluster.OperatorSpec.AssignProperties_To_ClusterOperatorSpec(&operatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ClusterOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OptimizedAutoscale
	if cluster.OptimizedAutoscale != nil {
		var optimizedAutoscale storage.OptimizedAutoscale
		err := cluster.OptimizedAutoscale.AssignProperties_To_OptimizedAutoscale(&optimizedAutoscale)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_OptimizedAutoscale() to populate field OptimizedAutoscale")
		}
		destination.OptimizedAutoscale = &optimizedAutoscale
	} else {
		destination.OptimizedAutoscale = nil
	}

	// OriginalVersion
	destination.OriginalVersion = cluster.OriginalVersion()

	// Owner
	if cluster.Owner != nil {
		owner := cluster.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// PublicIPType
	if cluster.PublicIPType != nil {
		publicIPType := string(*cluster.PublicIPType)
		destination.PublicIPType = &publicIPType
	} else {
		destination.PublicIPType = nil
	}

	// PublicNetworkAccess
	if cluster.PublicNetworkAccess != nil {
		publicNetworkAccess := string(*cluster.PublicNetworkAccess)
		destination.PublicNetworkAccess = &publicNetworkAccess
	} else {
		destination.PublicNetworkAccess = nil
	}

	// RestrictOutboundNetworkAccess
	if cluster.RestrictOutboundNetworkAccess != nil {
		restrictOutboundNetworkAccess := string(*cluster.RestrictOutboundNetworkAccess)
		destination.RestrictOutboundNetworkAccess = &restrictOutboundNetworkAccess
	} else {
		destination.RestrictOutboundNetworkAccess = nil
	}

	// Sku
	if cluster.Sku != nil {
		var sku storage.AzureSku
		err := cluster.Sku.AssignProperties_To_AzureSku(&sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AzureSku() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(cluster.Tags)

	// TrustedExternalTenants
	if cluster.TrustedExternalTenants != nil {
		trustedExternalTenantList := make([]storage.TrustedExternalTenant, len(cluster.TrustedExternalTenants))
		for trustedExternalTenantIndex, trustedExternalTenantItem := range cluster.TrustedExternalTenants {
			// Shadow the loop variable to avoid aliasing
			trustedExternalTenantItem := trustedExternalTenantItem
			var trustedExternalTenant storage.TrustedExternalTenant
			err := trustedExternalTenantItem.AssignProperties_To_TrustedExternalTenant(&trustedExternalTenant)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_TrustedExternalTenant() to populate field TrustedExternalTenants")
			}
			trustedExternalTenantList[trustedExternalTenantIndex] = trustedExternalTenant
		}
		destination.TrustedExternalTenants = trustedExternalTenantList
	} else {
		destination.TrustedExternalTenants = nil
	}

	// VirtualClusterGraduationProperties
	if cluster.VirtualClusterGraduationProperties != nil {
		virtualClusterGraduationProperty := cluster.VirtualClusterGraduationProperties.Copy()
		destination.VirtualClusterGraduationProperties = &virtualClusterGraduationProperty
	} else {
		destination.VirtualClusterGraduationProperties = nil
	}

	// VirtualNetworkConfiguration
	if cluster.VirtualNetworkConfiguration != nil {
		var virtualNetworkConfiguration storage.VirtualNetworkConfiguration
		err := cluster.VirtualNetworkConfiguration.AssignProperties_To_VirtualNetworkConfiguration(&virtualNetworkConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VirtualNetworkConfiguration() to populate field VirtualNetworkConfiguration")
		}
		destination.VirtualNetworkConfiguration = &virtualNetworkConfiguration
	} else {
		destination.VirtualNetworkConfiguration = nil
	}

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(cluster.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Cluster_STATUS populates our Cluster_Spec from the provided source Cluster_STATUS
func (cluster *Cluster_Spec) Initialize_From_Cluster_STATUS(source *Cluster_STATUS) error {

	// AcceptedAudiences
	if source.AcceptedAudiences != nil {
		acceptedAudienceList := make([]AcceptedAudiences, len(source.AcceptedAudiences))
		for acceptedAudienceIndex, acceptedAudienceItem := range source.AcceptedAudiences {
			// Shadow the loop variable to avoid aliasing
			acceptedAudienceItem := acceptedAudienceItem
			var acceptedAudience AcceptedAudiences
			err := acceptedAudience.Initialize_From_AcceptedAudiences_STATUS(&acceptedAudienceItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_AcceptedAudiences_STATUS() to populate field AcceptedAudiences")
			}
			acceptedAudienceList[acceptedAudienceIndex] = acceptedAudience
		}
		cluster.AcceptedAudiences = acceptedAudienceList
	} else {
		cluster.AcceptedAudiences = nil
	}

	// AllowedFqdnList
	cluster.AllowedFqdnList = genruntime.CloneSliceOfString(source.AllowedFqdnList)

	// AllowedIpRangeList
	cluster.AllowedIpRangeList = genruntime.CloneSliceOfString(source.AllowedIpRangeList)

	// EnableAutoStop
	if source.EnableAutoStop != nil {
		enableAutoStop := *source.EnableAutoStop
		cluster.EnableAutoStop = &enableAutoStop
	} else {
		cluster.EnableAutoStop = nil
	}

	// EnableDiskEncryption
	if source.EnableDiskEncryption != nil {
		enableDiskEncryption := *source.EnableDiskEncryption
		cluster.EnableDiskEncryption = &enableDiskEncryption
	} else {
		cluster.EnableDiskEncryption = nil
	}

	// EnableDoubleEncryption
	if source.EnableDoubleEncryption != nil {
		enableDoubleEncryption := *source.EnableDoubleEncryption
		cluster.EnableDoubleEncryption = &enableDoubleEncryption
	} else {
		cluster.EnableDoubleEncryption = nil
	}

	// EnablePurge
	if source.EnablePurge != nil {
		enablePurge := *source.EnablePurge
		cluster.EnablePurge = &enablePurge
	} else {
		cluster.EnablePurge = nil
	}

	// EnableStreamingIngest
	if source.EnableStreamingIngest != nil {
		enableStreamingIngest := *source.EnableStreamingIngest
		cluster.EnableStreamingIngest = &enableStreamingIngest
	} else {
		cluster.EnableStreamingIngest = nil
	}

	// EngineType
	if source.EngineType != nil {
		engineType := genruntime.ToEnum(string(*source.EngineType), clusterProperties_EngineType_Values)
		cluster.EngineType = &engineType
	} else {
		cluster.EngineType = nil
	}

	// Identity
	if source.Identity != nil {
		var identity Identity
		err := identity.Initialize_From_Identity_STATUS(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_Identity_STATUS() to populate field Identity")
		}
		cluster.Identity = &identity
	} else {
		cluster.Identity = nil
	}

	// KeyVaultProperties
	if source.KeyVaultProperties != nil {
		var keyVaultProperty KeyVaultProperties
		err := keyVaultProperty.Initialize_From_KeyVaultProperties_STATUS(source.KeyVaultProperties)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_KeyVaultProperties_STATUS() to populate field KeyVaultProperties")
		}
		cluster.KeyVaultProperties = &keyVaultProperty
	} else {
		cluster.KeyVaultProperties = nil
	}

	// LanguageExtensions
	if source.LanguageExtensions != nil {
		var languageExtension LanguageExtensionsList
		err := languageExtension.Initialize_From_LanguageExtensionsList_STATUS(source.LanguageExtensions)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_LanguageExtensionsList_STATUS() to populate field LanguageExtensions")
		}
		cluster.LanguageExtensions = &languageExtension
	} else {
		cluster.LanguageExtensions = nil
	}

	// Location
	cluster.Location = genruntime.ClonePointerToString(source.Location)

	// OptimizedAutoscale
	if source.OptimizedAutoscale != nil {
		var optimizedAutoscale OptimizedAutoscale
		err := optimizedAutoscale.Initialize_From_OptimizedAutoscale_STATUS(source.OptimizedAutoscale)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_OptimizedAutoscale_STATUS() to populate field OptimizedAutoscale")
		}
		cluster.OptimizedAutoscale = &optimizedAutoscale
	} else {
		cluster.OptimizedAutoscale = nil
	}

	// PublicIPType
	if source.PublicIPType != nil {
		publicIPType := genruntime.ToEnum(string(*source.PublicIPType), clusterProperties_PublicIPType_Values)
		cluster.PublicIPType = &publicIPType
	} else {
		cluster.PublicIPType = nil
	}

	// PublicNetworkAccess
	if source.PublicNetworkAccess != nil {
		publicNetworkAccess := genruntime.ToEnum(string(*source.PublicNetworkAccess), clusterProperties_PublicNetworkAccess_Values)
		cluster.PublicNetworkAccess = &publicNetworkAccess
	} else {
		cluster.PublicNetworkAccess = nil
	}

	// RestrictOutboundNetworkAccess
	if source.RestrictOutboundNetworkAccess != nil {
		restrictOutboundNetworkAccess := genruntime.ToEnum(string(*source.RestrictOutboundNetworkAccess), clusterProperties_RestrictOutboundNetworkAccess_Values)
		cluster.RestrictOutboundNetworkAccess = &restrictOutboundNetworkAccess
	} else {
		cluster.RestrictOutboundNetworkAccess = nil
	}

	// Sku
	if source.Sku != nil {
		var sku AzureSku
		err := sku.Initialize_From_AzureSku_STATUS(source.Sku)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_AzureSku_STATUS() to populate field Sku")
		}
		cluster.Sku = &sku
	} else {
		cluster.Sku = nil
	}

	// Tags
	cluster.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// TrustedExternalTenants
	if source.TrustedExternalTenants != nil {
		trustedExternalTenantList := make([]TrustedExternalTenant, len(source.TrustedExternalTenants))
		for trustedExternalTenantIndex, trustedExternalTenantItem := range source.TrustedExternalTenants {
			// Shadow the loop variable to avoid aliasing
			trustedExternalTenantItem := trustedExternalTenantItem
			var trustedExternalTenant TrustedExternalTenant
			err := trustedExternalTenant.Initialize_From_TrustedExternalTenant_STATUS(&trustedExternalTenantItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_TrustedExternalTenant_STATUS() to populate field TrustedExternalTenants")
			}
			trustedExternalTenantList[trustedExternalTenantIndex] = trustedExternalTenant
		}
		cluster.TrustedExternalTenants = trustedExternalTenantList
	} else {
		cluster.TrustedExternalTenants = nil
	}

	// VirtualNetworkConfiguration
	if source.VirtualNetworkConfiguration != nil {
		var virtualNetworkConfiguration VirtualNetworkConfiguration
		err := virtualNetworkConfiguration.Initialize_From_VirtualNetworkConfiguration_STATUS(source.VirtualNetworkConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_VirtualNetworkConfiguration_STATUS() to populate field VirtualNetworkConfiguration")
		}
		cluster.VirtualNetworkConfiguration = &virtualNetworkConfiguration
	} else {
		cluster.VirtualNetworkConfiguration = nil
	}

	// Zones
	cluster.Zones = genruntime.CloneSliceOfString(source.Zones)

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (cluster *Cluster_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (cluster *Cluster_Spec) SetAzureName(azureName string) { cluster.AzureName = azureName }

// Class representing a Kusto cluster.
type Cluster_STATUS struct {
	// AcceptedAudiences: The cluster's accepted audiences.
	AcceptedAudiences []AcceptedAudiences_STATUS `json:"acceptedAudiences,omitempty"`

	// AllowedFqdnList: List of allowed FQDNs(Fully Qualified Domain Name) for egress from Cluster.
	AllowedFqdnList []string `json:"allowedFqdnList,omitempty"`

	// AllowedIpRangeList: The list of ips in the format of CIDR allowed to connect to the cluster.
	AllowedIpRangeList []string `json:"allowedIpRangeList,omitempty"`

	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// DataIngestionUri: The cluster data ingestion URI.
	DataIngestionUri *string `json:"dataIngestionUri,omitempty"`

	// EnableAutoStop: A boolean value that indicates if the cluster could be automatically stopped (due to lack of data or no
	// activity for many days).
	EnableAutoStop *bool `json:"enableAutoStop,omitempty"`

	// EnableDiskEncryption: A boolean value that indicates if the cluster's disks are encrypted.
	EnableDiskEncryption *bool `json:"enableDiskEncryption,omitempty"`

	// EnableDoubleEncryption: A boolean value that indicates if double encryption is enabled.
	EnableDoubleEncryption *bool `json:"enableDoubleEncryption,omitempty"`

	// EnablePurge: A boolean value that indicates if the purge operations are enabled.
	EnablePurge *bool `json:"enablePurge,omitempty"`

	// EnableStreamingIngest: A boolean value that indicates if the streaming ingest is enabled.
	EnableStreamingIngest *bool `json:"enableStreamingIngest,omitempty"`

	// EngineType: The engine type
	EngineType *ClusterProperties_EngineType_STATUS `json:"engineType,omitempty"`

	// Etag: A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	// Id: Fully qualified resource ID for the resource. Ex -
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	Id *string `json:"id,omitempty"`

	// Identity: The identity of the cluster, if configured.
	Identity *Identity_STATUS `json:"identity,omitempty"`

	// KeyVaultProperties: KeyVault properties for the cluster encryption.
	KeyVaultProperties *KeyVaultProperties_STATUS `json:"keyVaultProperties,omitempty"`

	// LanguageExtensions: List of the cluster's language extensions.
	LanguageExtensions *LanguageExtensionsList_STATUS `json:"languageExtensions,omitempty"`

	// Location: The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// MigrationCluster: Properties of the peer cluster involved in a migration to/from this cluster.
	MigrationCluster *MigrationClusterProperties_STATUS `json:"migrationCluster,omitempty"`

	// Name: The name of the resource
	Name *string `json:"name,omitempty"`

	// OptimizedAutoscale: Optimized auto scale definition.
	OptimizedAutoscale *OptimizedAutoscale_STATUS `json:"optimizedAutoscale,omitempty"`

	// PrivateEndpointConnections: A list of private endpoint connections.
	PrivateEndpointConnections []PrivateEndpointConnection_STATUS `json:"privateEndpointConnections,omitempty"`

	// ProvisioningState: The provisioned state of the resource.
	ProvisioningState *ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// PublicIPType: Indicates what public IP type to create - IPv4 (default), or DualStack (both IPv4 and IPv6)
	PublicIPType *ClusterProperties_PublicIPType_STATUS `json:"publicIPType,omitempty"`

	// PublicNetworkAccess: Public network access to the cluster is enabled by default. When disabled, only private endpoint
	// connection to the cluster is allowed
	PublicNetworkAccess *ClusterProperties_PublicNetworkAccess_STATUS `json:"publicNetworkAccess,omitempty"`

	// RestrictOutboundNetworkAccess: Whether or not to restrict outbound network access.  Value is optional but if passed in,
	// must be 'Enabled' or 'Disabled'
	RestrictOutboundNetworkAccess *ClusterProperties_RestrictOutboundNetworkAccess_STATUS `json:"restrictOutboundNetworkAccess,omitempty"`

	// Sku: The SKU of the cluster.
	Sku *AzureSku_STATUS `json:"sku,omitempty"`

	// State: The state of the resource.
	State *ClusterProperties_State_STATUS `json:"state,omitempty"`

	// StateReason: The reason for the cluster's current state.
	StateReason *string `json:"stateReason,omitempty"`

	// SystemData: Metadata pertaining to creation and last modification of the resource.
	SystemData *SystemData_STATUS `json:"systemData,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// TrustedExternalTenants: The cluster's external tenants.
	TrustedExternalTenants []TrustedExternalTenant_STATUS `json:"trustedExternalTenants,omitempty"`

	// Type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`

	// Uri: The cluster URI.
	Uri *string `json:"uri,omitempty"`

	// VirtualNetworkConfiguration: Virtual network definition.
	VirtualNetworkConfiguration *VirtualNetworkConfiguration_STATUS `json:"virtualNetworkConfiguration,omitempty"`

	// Zones: The availability zones of the cluster.
	Zones []string `json:"zones,omitempty"`
}

var _ genruntime.ConvertibleStatus = &Cluster_STATUS{}

// ConvertStatusFrom populates our Cluster_STATUS from the provided source
func (cluster *Cluster_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.Cluster_STATUS)
	if ok {
		// Populate our instance from source
		return cluster.AssignProperties_From_Cluster_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.Cluster_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = cluster.AssignProperties_From_Cluster_STATUS(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our Cluster_STATUS
func (cluster *Cluster_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.Cluster_STATUS)
	if ok {
		// Populate destination from our instance
		return cluster.AssignProperties_To_Cluster_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.Cluster_STATUS{}
	err := cluster.AssignProperties_To_Cluster_STATUS(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &Cluster_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (cluster *Cluster_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Cluster_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (cluster *Cluster_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Cluster_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Cluster_STATUS, got %T", armInput)
	}

	// Set property "AcceptedAudiences":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.AcceptedAudiences {
			var item1 AcceptedAudiences_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			cluster.AcceptedAudiences = append(cluster.AcceptedAudiences, item1)
		}
	}

	// Set property "AllowedFqdnList":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.AllowedFqdnList {
			cluster.AllowedFqdnList = append(cluster.AllowedFqdnList, item)
		}
	}

	// Set property "AllowedIpRangeList":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.AllowedIpRangeList {
			cluster.AllowedIpRangeList = append(cluster.AllowedIpRangeList, item)
		}
	}

	// no assignment for property "Conditions"

	// Set property "DataIngestionUri":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DataIngestionUri != nil {
			dataIngestionUri := *typedInput.Properties.DataIngestionUri
			cluster.DataIngestionUri = &dataIngestionUri
		}
	}

	// Set property "EnableAutoStop":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableAutoStop != nil {
			enableAutoStop := *typedInput.Properties.EnableAutoStop
			cluster.EnableAutoStop = &enableAutoStop
		}
	}

	// Set property "EnableDiskEncryption":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableDiskEncryption != nil {
			enableDiskEncryption := *typedInput.Properties.EnableDiskEncryption
			cluster.EnableDiskEncryption = &enableDiskEncryption
		}
	}

	// Set property "EnableDoubleEncryption":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableDoubleEncryption != nil {
			enableDoubleEncryption := *typedInput.Properties.EnableDoubleEncryption
			cluster.EnableDoubleEncryption = &enableDoubleEncryption
		}
	}

	// Set property "EnablePurge":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnablePurge != nil {
			enablePurge := *typedInput.Properties.EnablePurge
			cluster.EnablePurge = &enablePurge
		}
	}

	// Set property "EnableStreamingIngest":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableStreamingIngest != nil {
			enableStreamingIngest := *typedInput.Properties.EnableStreamingIngest
			cluster.EnableStreamingIngest = &enableStreamingIngest
		}
	}

	// Set property "EngineType":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EngineType != nil {
			var temp string
			temp = string(*typedInput.Properties.EngineType)
			engineType := ClusterProperties_EngineType_STATUS(temp)
			cluster.EngineType = &engineType
		}
	}

	// Set property "Etag":
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		cluster.Etag = &etag
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		cluster.Id = &id
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 Identity_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		cluster.Identity = &identity
	}

	// Set property "KeyVaultProperties":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.KeyVaultProperties != nil {
			var keyVaultProperties1 KeyVaultProperties_STATUS
			err := keyVaultProperties1.PopulateFromARM(owner, *typedInput.Properties.KeyVaultProperties)
			if err != nil {
				return err
			}
			keyVaultProperties := keyVaultProperties1
			cluster.KeyVaultProperties = &keyVaultProperties
		}
	}

	// Set property "LanguageExtensions":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LanguageExtensions != nil {
			var languageExtensions1 LanguageExtensionsList_STATUS
			err := languageExtensions1.PopulateFromARM(owner, *typedInput.Properties.LanguageExtensions)
			if err != nil {
				return err
			}
			languageExtensions := languageExtensions1
			cluster.LanguageExtensions = &languageExtensions
		}
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		cluster.Location = &location
	}

	// Set property "MigrationCluster":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MigrationCluster != nil {
			var migrationCluster1 MigrationClusterProperties_STATUS
			err := migrationCluster1.PopulateFromARM(owner, *typedInput.Properties.MigrationCluster)
			if err != nil {
				return err
			}
			migrationCluster := migrationCluster1
			cluster.MigrationCluster = &migrationCluster
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		cluster.Name = &name
	}

	// Set property "OptimizedAutoscale":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.OptimizedAutoscale != nil {
			var optimizedAutoscale1 OptimizedAutoscale_STATUS
			err := optimizedAutoscale1.PopulateFromARM(owner, *typedInput.Properties.OptimizedAutoscale)
			if err != nil {
				return err
			}
			optimizedAutoscale := optimizedAutoscale1
			cluster.OptimizedAutoscale = &optimizedAutoscale
		}
	}

	// Set property "PrivateEndpointConnections":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.PrivateEndpointConnections {
			var item1 PrivateEndpointConnection_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			cluster.PrivateEndpointConnections = append(cluster.PrivateEndpointConnections, item1)
		}
	}

	// Set property "ProvisioningState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			var temp string
			temp = string(*typedInput.Properties.ProvisioningState)
			provisioningState := ProvisioningState_STATUS(temp)
			cluster.ProvisioningState = &provisioningState
		}
	}

	// Set property "PublicIPType":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPType != nil {
			var temp string
			temp = string(*typedInput.Properties.PublicIPType)
			publicIPType := ClusterProperties_PublicIPType_STATUS(temp)
			cluster.PublicIPType = &publicIPType
		}
	}

	// Set property "PublicNetworkAccess":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicNetworkAccess != nil {
			var temp string
			temp = string(*typedInput.Properties.PublicNetworkAccess)
			publicNetworkAccess := ClusterProperties_PublicNetworkAccess_STATUS(temp)
			cluster.PublicNetworkAccess = &publicNetworkAccess
		}
	}

	// Set property "RestrictOutboundNetworkAccess":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RestrictOutboundNetworkAccess != nil {
			var temp string
			temp = string(*typedInput.Properties.RestrictOutboundNetworkAccess)
			restrictOutboundNetworkAccess := ClusterProperties_RestrictOutboundNetworkAccess_STATUS(temp)
			cluster.RestrictOutboundNetworkAccess = &restrictOutboundNetworkAccess
		}
	}

	// Set property "Sku":
	if typedInput.Sku != nil {
		var sku1 AzureSku_STATUS
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		cluster.Sku = &sku
	}

	// Set property "State":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.State != nil {
			var temp string
			temp = string(*typedInput.Properties.State)
			state := ClusterProperties_State_STATUS(temp)
			cluster.State = &state
		}
	}

	// Set property "StateReason":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.StateReason != nil {
			stateReason := *typedInput.Properties.StateReason
			cluster.StateReason = &stateReason
		}
	}

	// Set property "SystemData":
	if typedInput.SystemData != nil {
		var systemData1 SystemData_STATUS
		err := systemData1.PopulateFromARM(owner, *typedInput.SystemData)
		if err != nil {
			return err
		}
		systemData := systemData1
		cluster.SystemData = &systemData
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		cluster.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			cluster.Tags[key] = value
		}
	}

	// Set property "TrustedExternalTenants":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.TrustedExternalTenants {
			var item1 TrustedExternalTenant_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			cluster.TrustedExternalTenants = append(cluster.TrustedExternalTenants, item1)
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		cluster.Type = &typeVar
	}

	// Set property "Uri":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Uri != nil {
			uri := *typedInput.Properties.Uri
			cluster.Uri = &uri
		}
	}

	// Set property "VirtualNetworkConfiguration":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VirtualNetworkConfiguration != nil {
			var virtualNetworkConfiguration1 VirtualNetworkConfiguration_STATUS
			err := virtualNetworkConfiguration1.PopulateFromARM(owner, *typedInput.Properties.VirtualNetworkConfiguration)
			if err != nil {
				return err
			}
			virtualNetworkConfiguration := virtualNetworkConfiguration1
			cluster.VirtualNetworkConfiguration = &virtualNetworkConfiguration
		}
	}

	// Set property "Zones":
	for _, item := range typedInput.Zones {
		cluster.Zones = append(cluster.Zones, item)
	}

	// No error
	return nil
}

// AssignProperties_From_Cluster_STATUS populates our Cluster_STATUS from the provided source Cluster_STATUS
func (cluster *Cluster_STATUS) AssignProperties_From_Cluster_STATUS(source *storage.Cluster_STATUS) error {

	// AcceptedAudiences
	if source.AcceptedAudiences != nil {
		acceptedAudienceList := make([]AcceptedAudiences_STATUS, len(source.AcceptedAudiences))
		for acceptedAudienceIndex, acceptedAudienceItem := range source.AcceptedAudiences {
			// Shadow the loop variable to avoid aliasing
			acceptedAudienceItem := acceptedAudienceItem
			var acceptedAudience AcceptedAudiences_STATUS
			err := acceptedAudience.AssignProperties_From_AcceptedAudiences_STATUS(&acceptedAudienceItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_AcceptedAudiences_STATUS() to populate field AcceptedAudiences")
			}
			acceptedAudienceList[acceptedAudienceIndex] = acceptedAudience
		}
		cluster.AcceptedAudiences = acceptedAudienceList
	} else {
		cluster.AcceptedAudiences = nil
	}

	// AllowedFqdnList
	cluster.AllowedFqdnList = genruntime.CloneSliceOfString(source.AllowedFqdnList)

	// AllowedIpRangeList
	cluster.AllowedIpRangeList = genruntime.CloneSliceOfString(source.AllowedIpRangeList)

	// Conditions
	cluster.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// DataIngestionUri
	cluster.DataIngestionUri = genruntime.ClonePointerToString(source.DataIngestionUri)

	// EnableAutoStop
	if source.EnableAutoStop != nil {
		enableAutoStop := *source.EnableAutoStop
		cluster.EnableAutoStop = &enableAutoStop
	} else {
		cluster.EnableAutoStop = nil
	}

	// EnableDiskEncryption
	if source.EnableDiskEncryption != nil {
		enableDiskEncryption := *source.EnableDiskEncryption
		cluster.EnableDiskEncryption = &enableDiskEncryption
	} else {
		cluster.EnableDiskEncryption = nil
	}

	// EnableDoubleEncryption
	if source.EnableDoubleEncryption != nil {
		enableDoubleEncryption := *source.EnableDoubleEncryption
		cluster.EnableDoubleEncryption = &enableDoubleEncryption
	} else {
		cluster.EnableDoubleEncryption = nil
	}

	// EnablePurge
	if source.EnablePurge != nil {
		enablePurge := *source.EnablePurge
		cluster.EnablePurge = &enablePurge
	} else {
		cluster.EnablePurge = nil
	}

	// EnableStreamingIngest
	if source.EnableStreamingIngest != nil {
		enableStreamingIngest := *source.EnableStreamingIngest
		cluster.EnableStreamingIngest = &enableStreamingIngest
	} else {
		cluster.EnableStreamingIngest = nil
	}

	// EngineType
	if source.EngineType != nil {
		engineType := *source.EngineType
		engineTypeTemp := genruntime.ToEnum(engineType, clusterProperties_EngineType_STATUS_Values)
		cluster.EngineType = &engineTypeTemp
	} else {
		cluster.EngineType = nil
	}

	// Etag
	cluster.Etag = genruntime.ClonePointerToString(source.Etag)

	// Id
	cluster.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity Identity_STATUS
		err := identity.AssignProperties_From_Identity_STATUS(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Identity_STATUS() to populate field Identity")
		}
		cluster.Identity = &identity
	} else {
		cluster.Identity = nil
	}

	// KeyVaultProperties
	if source.KeyVaultProperties != nil {
		var keyVaultProperty KeyVaultProperties_STATUS
		err := keyVaultProperty.AssignProperties_From_KeyVaultProperties_STATUS(source.KeyVaultProperties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_KeyVaultProperties_STATUS() to populate field KeyVaultProperties")
		}
		cluster.KeyVaultProperties = &keyVaultProperty
	} else {
		cluster.KeyVaultProperties = nil
	}

	// LanguageExtensions
	if source.LanguageExtensions != nil {
		var languageExtension LanguageExtensionsList_STATUS
		err := languageExtension.AssignProperties_From_LanguageExtensionsList_STATUS(source.LanguageExtensions)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_LanguageExtensionsList_STATUS() to populate field LanguageExtensions")
		}
		cluster.LanguageExtensions = &languageExtension
	} else {
		cluster.LanguageExtensions = nil
	}

	// Location
	cluster.Location = genruntime.ClonePointerToString(source.Location)

	// MigrationCluster
	if source.MigrationCluster != nil {
		var migrationCluster MigrationClusterProperties_STATUS
		err := migrationCluster.AssignProperties_From_MigrationClusterProperties_STATUS(source.MigrationCluster)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_MigrationClusterProperties_STATUS() to populate field MigrationCluster")
		}
		cluster.MigrationCluster = &migrationCluster
	} else {
		cluster.MigrationCluster = nil
	}

	// Name
	cluster.Name = genruntime.ClonePointerToString(source.Name)

	// OptimizedAutoscale
	if source.OptimizedAutoscale != nil {
		var optimizedAutoscale OptimizedAutoscale_STATUS
		err := optimizedAutoscale.AssignProperties_From_OptimizedAutoscale_STATUS(source.OptimizedAutoscale)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_OptimizedAutoscale_STATUS() to populate field OptimizedAutoscale")
		}
		cluster.OptimizedAutoscale = &optimizedAutoscale
	} else {
		cluster.OptimizedAutoscale = nil
	}

	// PrivateEndpointConnections
	if source.PrivateEndpointConnections != nil {
		privateEndpointConnectionList := make([]PrivateEndpointConnection_STATUS, len(source.PrivateEndpointConnections))
		for privateEndpointConnectionIndex, privateEndpointConnectionItem := range source.PrivateEndpointConnections {
			// Shadow the loop variable to avoid aliasing
			privateEndpointConnectionItem := privateEndpointConnectionItem
			var privateEndpointConnection PrivateEndpointConnection_STATUS
			err := privateEndpointConnection.AssignProperties_From_PrivateEndpointConnection_STATUS(&privateEndpointConnectionItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_PrivateEndpointConnection_STATUS() to populate field PrivateEndpointConnections")
			}
			privateEndpointConnectionList[privateEndpointConnectionIndex] = privateEndpointConnection
		}
		cluster.PrivateEndpointConnections = privateEndpointConnectionList
	} else {
		cluster.PrivateEndpointConnections = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, provisioningState_STATUS_Values)
		cluster.ProvisioningState = &provisioningStateTemp
	} else {
		cluster.ProvisioningState = nil
	}

	// PublicIPType
	if source.PublicIPType != nil {
		publicIPType := *source.PublicIPType
		publicIPTypeTemp := genruntime.ToEnum(publicIPType, clusterProperties_PublicIPType_STATUS_Values)
		cluster.PublicIPType = &publicIPTypeTemp
	} else {
		cluster.PublicIPType = nil
	}

	// PublicNetworkAccess
	if source.PublicNetworkAccess != nil {
		publicNetworkAccess := *source.PublicNetworkAccess
		publicNetworkAccessTemp := genruntime.ToEnum(publicNetworkAccess, clusterProperties_PublicNetworkAccess_STATUS_Values)
		cluster.PublicNetworkAccess = &publicNetworkAccessTemp
	} else {
		cluster.PublicNetworkAccess = nil
	}

	// RestrictOutboundNetworkAccess
	if source.RestrictOutboundNetworkAccess != nil {
		restrictOutboundNetworkAccess := *source.RestrictOutboundNetworkAccess
		restrictOutboundNetworkAccessTemp := genruntime.ToEnum(restrictOutboundNetworkAccess, clusterProperties_RestrictOutboundNetworkAccess_STATUS_Values)
		cluster.RestrictOutboundNetworkAccess = &restrictOutboundNetworkAccessTemp
	} else {
		cluster.RestrictOutboundNetworkAccess = nil
	}

	// Sku
	if source.Sku != nil {
		var sku AzureSku_STATUS
		err := sku.AssignProperties_From_AzureSku_STATUS(source.Sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AzureSku_STATUS() to populate field Sku")
		}
		cluster.Sku = &sku
	} else {
		cluster.Sku = nil
	}

	// State
	if source.State != nil {
		state := *source.State
		stateTemp := genruntime.ToEnum(state, clusterProperties_State_STATUS_Values)
		cluster.State = &stateTemp
	} else {
		cluster.State = nil
	}

	// StateReason
	cluster.StateReason = genruntime.ClonePointerToString(source.StateReason)

	// SystemData
	if source.SystemData != nil {
		var systemDatum SystemData_STATUS
		err := systemDatum.AssignProperties_From_SystemData_STATUS(source.SystemData)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SystemData_STATUS() to populate field SystemData")
		}
		cluster.SystemData = &systemDatum
	} else {
		cluster.SystemData = nil
	}

	// Tags
	cluster.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// TrustedExternalTenants
	if source.TrustedExternalTenants != nil {
		trustedExternalTenantList := make([]TrustedExternalTenant_STATUS, len(source.TrustedExternalTenants))
		for trustedExternalTenantIndex, trustedExternalTenantItem := range source.TrustedExternalTenants {
			// Shadow the loop variable to avoid aliasing
			trustedExternalTenantItem := trustedExternalTenantItem
			var trustedExternalTenant TrustedExternalTenant_STATUS
			err := trustedExternalTenant.AssignProperties_From_TrustedExternalTenant_STATUS(&trustedExternalTenantItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_TrustedExternalTenant_STATUS() to populate field TrustedExternalTenants")
			}
			trustedExternalTenantList[trustedExternalTenantIndex] = trustedExternalTenant
		}
		cluster.TrustedExternalTenants = trustedExternalTenantList
	} else {
		cluster.TrustedExternalTenants = nil
	}

	// Type
	cluster.Type = genruntime.ClonePointerToString(source.Type)

	// Uri
	cluster.Uri = genruntime.ClonePointerToString(source.Uri)

	// VirtualNetworkConfiguration
	if source.VirtualNetworkConfiguration != nil {
		var virtualNetworkConfiguration VirtualNetworkConfiguration_STATUS
		err := virtualNetworkConfiguration.AssignProperties_From_VirtualNetworkConfiguration_STATUS(source.VirtualNetworkConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VirtualNetworkConfiguration_STATUS() to populate field VirtualNetworkConfiguration")
		}
		cluster.VirtualNetworkConfiguration = &virtualNetworkConfiguration
	} else {
		cluster.VirtualNetworkConfiguration = nil
	}

	// Zones
	cluster.Zones = genruntime.CloneSliceOfString(source.Zones)

	// No error
	return nil
}

// AssignProperties_To_Cluster_STATUS populates the provided destination Cluster_STATUS from our Cluster_STATUS
func (cluster *Cluster_STATUS) AssignProperties_To_Cluster_STATUS(destination *storage.Cluster_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AcceptedAudiences
	if cluster.AcceptedAudiences != nil {
		acceptedAudienceList := make([]storage.AcceptedAudiences_STATUS, len(cluster.AcceptedAudiences))
		for acceptedAudienceIndex, acceptedAudienceItem := range cluster.AcceptedAudiences {
			// Shadow the loop variable to avoid aliasing
			acceptedAudienceItem := acceptedAudienceItem
			var acceptedAudience storage.AcceptedAudiences_STATUS
			err := acceptedAudienceItem.AssignProperties_To_AcceptedAudiences_STATUS(&acceptedAudience)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_AcceptedAudiences_STATUS() to populate field AcceptedAudiences")
			}
			acceptedAudienceList[acceptedAudienceIndex] = acceptedAudience
		}
		destination.AcceptedAudiences = acceptedAudienceList
	} else {
		destination.AcceptedAudiences = nil
	}

	// AllowedFqdnList
	destination.AllowedFqdnList = genruntime.CloneSliceOfString(cluster.AllowedFqdnList)

	// AllowedIpRangeList
	destination.AllowedIpRangeList = genruntime.CloneSliceOfString(cluster.AllowedIpRangeList)

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(cluster.Conditions)

	// DataIngestionUri
	destination.DataIngestionUri = genruntime.ClonePointerToString(cluster.DataIngestionUri)

	// EnableAutoStop
	if cluster.EnableAutoStop != nil {
		enableAutoStop := *cluster.EnableAutoStop
		destination.EnableAutoStop = &enableAutoStop
	} else {
		destination.EnableAutoStop = nil
	}

	// EnableDiskEncryption
	if cluster.EnableDiskEncryption != nil {
		enableDiskEncryption := *cluster.EnableDiskEncryption
		destination.EnableDiskEncryption = &enableDiskEncryption
	} else {
		destination.EnableDiskEncryption = nil
	}

	// EnableDoubleEncryption
	if cluster.EnableDoubleEncryption != nil {
		enableDoubleEncryption := *cluster.EnableDoubleEncryption
		destination.EnableDoubleEncryption = &enableDoubleEncryption
	} else {
		destination.EnableDoubleEncryption = nil
	}

	// EnablePurge
	if cluster.EnablePurge != nil {
		enablePurge := *cluster.EnablePurge
		destination.EnablePurge = &enablePurge
	} else {
		destination.EnablePurge = nil
	}

	// EnableStreamingIngest
	if cluster.EnableStreamingIngest != nil {
		enableStreamingIngest := *cluster.EnableStreamingIngest
		destination.EnableStreamingIngest = &enableStreamingIngest
	} else {
		destination.EnableStreamingIngest = nil
	}

	// EngineType
	if cluster.EngineType != nil {
		engineType := string(*cluster.EngineType)
		destination.EngineType = &engineType
	} else {
		destination.EngineType = nil
	}

	// Etag
	destination.Etag = genruntime.ClonePointerToString(cluster.Etag)

	// Id
	destination.Id = genruntime.ClonePointerToString(cluster.Id)

	// Identity
	if cluster.Identity != nil {
		var identity storage.Identity_STATUS
		err := cluster.Identity.AssignProperties_To_Identity_STATUS(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Identity_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// KeyVaultProperties
	if cluster.KeyVaultProperties != nil {
		var keyVaultProperty storage.KeyVaultProperties_STATUS
		err := cluster.KeyVaultProperties.AssignProperties_To_KeyVaultProperties_STATUS(&keyVaultProperty)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_KeyVaultProperties_STATUS() to populate field KeyVaultProperties")
		}
		destination.KeyVaultProperties = &keyVaultProperty
	} else {
		destination.KeyVaultProperties = nil
	}

	// LanguageExtensions
	if cluster.LanguageExtensions != nil {
		var languageExtension storage.LanguageExtensionsList_STATUS
		err := cluster.LanguageExtensions.AssignProperties_To_LanguageExtensionsList_STATUS(&languageExtension)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_LanguageExtensionsList_STATUS() to populate field LanguageExtensions")
		}
		destination.LanguageExtensions = &languageExtension
	} else {
		destination.LanguageExtensions = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(cluster.Location)

	// MigrationCluster
	if cluster.MigrationCluster != nil {
		var migrationCluster storage.MigrationClusterProperties_STATUS
		err := cluster.MigrationCluster.AssignProperties_To_MigrationClusterProperties_STATUS(&migrationCluster)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_MigrationClusterProperties_STATUS() to populate field MigrationCluster")
		}
		destination.MigrationCluster = &migrationCluster
	} else {
		destination.MigrationCluster = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(cluster.Name)

	// OptimizedAutoscale
	if cluster.OptimizedAutoscale != nil {
		var optimizedAutoscale storage.OptimizedAutoscale_STATUS
		err := cluster.OptimizedAutoscale.AssignProperties_To_OptimizedAutoscale_STATUS(&optimizedAutoscale)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_OptimizedAutoscale_STATUS() to populate field OptimizedAutoscale")
		}
		destination.OptimizedAutoscale = &optimizedAutoscale
	} else {
		destination.OptimizedAutoscale = nil
	}

	// PrivateEndpointConnections
	if cluster.PrivateEndpointConnections != nil {
		privateEndpointConnectionList := make([]storage.PrivateEndpointConnection_STATUS, len(cluster.PrivateEndpointConnections))
		for privateEndpointConnectionIndex, privateEndpointConnectionItem := range cluster.PrivateEndpointConnections {
			// Shadow the loop variable to avoid aliasing
			privateEndpointConnectionItem := privateEndpointConnectionItem
			var privateEndpointConnection storage.PrivateEndpointConnection_STATUS
			err := privateEndpointConnectionItem.AssignProperties_To_PrivateEndpointConnection_STATUS(&privateEndpointConnection)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_PrivateEndpointConnection_STATUS() to populate field PrivateEndpointConnections")
			}
			privateEndpointConnectionList[privateEndpointConnectionIndex] = privateEndpointConnection
		}
		destination.PrivateEndpointConnections = privateEndpointConnectionList
	} else {
		destination.PrivateEndpointConnections = nil
	}

	// ProvisioningState
	if cluster.ProvisioningState != nil {
		provisioningState := string(*cluster.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// PublicIPType
	if cluster.PublicIPType != nil {
		publicIPType := string(*cluster.PublicIPType)
		destination.PublicIPType = &publicIPType
	} else {
		destination.PublicIPType = nil
	}

	// PublicNetworkAccess
	if cluster.PublicNetworkAccess != nil {
		publicNetworkAccess := string(*cluster.PublicNetworkAccess)
		destination.PublicNetworkAccess = &publicNetworkAccess
	} else {
		destination.PublicNetworkAccess = nil
	}

	// RestrictOutboundNetworkAccess
	if cluster.RestrictOutboundNetworkAccess != nil {
		restrictOutboundNetworkAccess := string(*cluster.RestrictOutboundNetworkAccess)
		destination.RestrictOutboundNetworkAccess = &restrictOutboundNetworkAccess
	} else {
		destination.RestrictOutboundNetworkAccess = nil
	}

	// Sku
	if cluster.Sku != nil {
		var sku storage.AzureSku_STATUS
		err := cluster.Sku.AssignProperties_To_AzureSku_STATUS(&sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AzureSku_STATUS() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// State
	if cluster.State != nil {
		state := string(*cluster.State)
		destination.State = &state
	} else {
		destination.State = nil
	}

	// StateReason
	destination.StateReason = genruntime.ClonePointerToString(cluster.StateReason)

	// SystemData
	if cluster.SystemData != nil {
		var systemDatum storage.SystemData_STATUS
		err := cluster.SystemData.AssignProperties_To_SystemData_STATUS(&systemDatum)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SystemData_STATUS() to populate field SystemData")
		}
		destination.SystemData = &systemDatum
	} else {
		destination.SystemData = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(cluster.Tags)

	// TrustedExternalTenants
	if cluster.TrustedExternalTenants != nil {
		trustedExternalTenantList := make([]storage.TrustedExternalTenant_STATUS, len(cluster.TrustedExternalTenants))
		for trustedExternalTenantIndex, trustedExternalTenantItem := range cluster.TrustedExternalTenants {
			// Shadow the loop variable to avoid aliasing
			trustedExternalTenantItem := trustedExternalTenantItem
			var trustedExternalTenant storage.TrustedExternalTenant_STATUS
			err := trustedExternalTenantItem.AssignProperties_To_TrustedExternalTenant_STATUS(&trustedExternalTenant)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_TrustedExternalTenant_STATUS() to populate field TrustedExternalTenants")
			}
			trustedExternalTenantList[trustedExternalTenantIndex] = trustedExternalTenant
		}
		destination.TrustedExternalTenants = trustedExternalTenantList
	} else {
		destination.TrustedExternalTenants = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(cluster.Type)

	// Uri
	destination.Uri = genruntime.ClonePointerToString(cluster.Uri)

	// VirtualNetworkConfiguration
	if cluster.VirtualNetworkConfiguration != nil {
		var virtualNetworkConfiguration storage.VirtualNetworkConfiguration_STATUS
		err := cluster.VirtualNetworkConfiguration.AssignProperties_To_VirtualNetworkConfiguration_STATUS(&virtualNetworkConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VirtualNetworkConfiguration_STATUS() to populate field VirtualNetworkConfiguration")
		}
		destination.VirtualNetworkConfiguration = &virtualNetworkConfiguration
	} else {
		destination.VirtualNetworkConfiguration = nil
	}

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(cluster.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Represents an accepted audience trusted by the cluster.
type AcceptedAudiences struct {
	// Value: GUID or valid URL representing an accepted audience.
	Value *string `json:"value,omitempty"`
}

var _ genruntime.ARMTransformer = &AcceptedAudiences{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (audiences *AcceptedAudiences) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if audiences == nil {
		return nil, nil
	}
	result := &arm.AcceptedAudiences{}

	// Set property "Value":
	if audiences.Value != nil {
		value := *audiences.Value
		result.Value = &value
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (audiences *AcceptedAudiences) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AcceptedAudiences{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (audiences *AcceptedAudiences) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AcceptedAudiences)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AcceptedAudiences, got %T", armInput)
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		audiences.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_AcceptedAudiences populates our AcceptedAudiences from the provided source AcceptedAudiences
func (audiences *AcceptedAudiences) AssignProperties_From_AcceptedAudiences(source *storage.AcceptedAudiences) error {

	// Value
	audiences.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_AcceptedAudiences populates the provided destination AcceptedAudiences from our AcceptedAudiences
func (audiences *AcceptedAudiences) AssignProperties_To_AcceptedAudiences(destination *storage.AcceptedAudiences) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Value
	destination.Value = genruntime.ClonePointerToString(audiences.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AcceptedAudiences_STATUS populates our AcceptedAudiences from the provided source AcceptedAudiences_STATUS
func (audiences *AcceptedAudiences) Initialize_From_AcceptedAudiences_STATUS(source *AcceptedAudiences_STATUS) error {

	// Value
	audiences.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// Represents an accepted audience trusted by the cluster.
type AcceptedAudiences_STATUS struct {
	// Value: GUID or valid URL representing an accepted audience.
	Value *string `json:"value,omitempty"`
}

var _ genruntime.FromARMConverter = &AcceptedAudiences_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (audiences *AcceptedAudiences_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AcceptedAudiences_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (audiences *AcceptedAudiences_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AcceptedAudiences_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AcceptedAudiences_STATUS, got %T", armInput)
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		audiences.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_AcceptedAudiences_STATUS populates our AcceptedAudiences_STATUS from the provided source AcceptedAudiences_STATUS
func (audiences *AcceptedAudiences_STATUS) AssignProperties_From_AcceptedAudiences_STATUS(source *storage.AcceptedAudiences_STATUS) error {

	// Value
	audiences.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_AcceptedAudiences_STATUS populates the provided destination AcceptedAudiences_STATUS from our AcceptedAudiences_STATUS
func (audiences *AcceptedAudiences_STATUS) AssignProperties_To_AcceptedAudiences_STATUS(destination *storage.AcceptedAudiences_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Value
	destination.Value = genruntime.ClonePointerToString(audiences.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Azure SKU definition.
type AzureSku struct {
	// Capacity: The number of instances of the cluster.
	Capacity *int `json:"capacity,omitempty"`

	// +kubebuilder:validation:Required
	// Name: SKU name.
	Name *AzureSku_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Tier: SKU tier.
	Tier *AzureSku_Tier `json:"tier,omitempty"`
}

var _ genruntime.ARMTransformer = &AzureSku{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (azureSku *AzureSku) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if azureSku == nil {
		return nil, nil
	}
	result := &arm.AzureSku{}

	// Set property "Capacity":
	if azureSku.Capacity != nil {
		capacity := *azureSku.Capacity
		result.Capacity = &capacity
	}

	// Set property "Name":
	if azureSku.Name != nil {
		var temp string
		temp = string(*azureSku.Name)
		name := arm.AzureSku_Name(temp)
		result.Name = &name
	}

	// Set property "Tier":
	if azureSku.Tier != nil {
		var temp string
		temp = string(*azureSku.Tier)
		tier := arm.AzureSku_Tier(temp)
		result.Tier = &tier
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (azureSku *AzureSku) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureSku{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (azureSku *AzureSku) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureSku)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureSku, got %T", armInput)
	}

	// Set property "Capacity":
	if typedInput.Capacity != nil {
		capacity := *typedInput.Capacity
		azureSku.Capacity = &capacity
	}

	// Set property "Name":
	if typedInput.Name != nil {
		var temp string
		temp = string(*typedInput.Name)
		name := AzureSku_Name(temp)
		azureSku.Name = &name
	}

	// Set property "Tier":
	if typedInput.Tier != nil {
		var temp string
		temp = string(*typedInput.Tier)
		tier := AzureSku_Tier(temp)
		azureSku.Tier = &tier
	}

	// No error
	return nil
}

// AssignProperties_From_AzureSku populates our AzureSku from the provided source AzureSku
func (azureSku *AzureSku) AssignProperties_From_AzureSku(source *storage.AzureSku) error {

	// Capacity
	azureSku.Capacity = genruntime.ClonePointerToInt(source.Capacity)

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, azureSku_Name_Values)
		azureSku.Name = &nameTemp
	} else {
		azureSku.Name = nil
	}

	// Tier
	if source.Tier != nil {
		tier := *source.Tier
		tierTemp := genruntime.ToEnum(tier, azureSku_Tier_Values)
		azureSku.Tier = &tierTemp
	} else {
		azureSku.Tier = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AzureSku populates the provided destination AzureSku from our AzureSku
func (azureSku *AzureSku) AssignProperties_To_AzureSku(destination *storage.AzureSku) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Capacity
	destination.Capacity = genruntime.ClonePointerToInt(azureSku.Capacity)

	// Name
	if azureSku.Name != nil {
		name := string(*azureSku.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Tier
	if azureSku.Tier != nil {
		tier := string(*azureSku.Tier)
		destination.Tier = &tier
	} else {
		destination.Tier = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AzureSku_STATUS populates our AzureSku from the provided source AzureSku_STATUS
func (azureSku *AzureSku) Initialize_From_AzureSku_STATUS(source *AzureSku_STATUS) error {

	// Capacity
	azureSku.Capacity = genruntime.ClonePointerToInt(source.Capacity)

	// Name
	if source.Name != nil {
		name := genruntime.ToEnum(string(*source.Name), azureSku_Name_Values)
		azureSku.Name = &name
	} else {
		azureSku.Name = nil
	}

	// Tier
	if source.Tier != nil {
		tier := genruntime.ToEnum(string(*source.Tier), azureSku_Tier_Values)
		azureSku.Tier = &tier
	} else {
		azureSku.Tier = nil
	}

	// No error
	return nil
}

// Azure SKU definition.
type AzureSku_STATUS struct {
	// Capacity: The number of instances of the cluster.
	Capacity *int `json:"capacity,omitempty"`

	// Name: SKU name.
	Name *AzureSku_Name_STATUS `json:"name,omitempty"`

	// Tier: SKU tier.
	Tier *AzureSku_Tier_STATUS `json:"tier,omitempty"`
}

var _ genruntime.FromARMConverter = &AzureSku_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (azureSku *AzureSku_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureSku_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (azureSku *AzureSku_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureSku_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureSku_STATUS, got %T", armInput)
	}

	// Set property "Capacity":
	if typedInput.Capacity != nil {
		capacity := *typedInput.Capacity
		azureSku.Capacity = &capacity
	}

	// Set property "Name":
	if typedInput.Name != nil {
		var temp string
		temp = string(*typedInput.Name)
		name := AzureSku_Name_STATUS(temp)
		azureSku.Name = &name
	}

	// Set property "Tier":
	if typedInput.Tier != nil {
		var temp string
		temp = string(*typedInput.Tier)
		tier := AzureSku_Tier_STATUS(temp)
		azureSku.Tier = &tier
	}

	// No error
	return nil
}

// AssignProperties_From_AzureSku_STATUS populates our AzureSku_STATUS from the provided source AzureSku_STATUS
func (azureSku *AzureSku_STATUS) AssignProperties_From_AzureSku_STATUS(source *storage.AzureSku_STATUS) error {

	// Capacity
	azureSku.Capacity = genruntime.ClonePointerToInt(source.Capacity)

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, azureSku_Name_STATUS_Values)
		azureSku.Name = &nameTemp
	} else {
		azureSku.Name = nil
	}

	// Tier
	if source.Tier != nil {
		tier := *source.Tier
		tierTemp := genruntime.ToEnum(tier, azureSku_Tier_STATUS_Values)
		azureSku.Tier = &tierTemp
	} else {
		azureSku.Tier = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AzureSku_STATUS populates the provided destination AzureSku_STATUS from our AzureSku_STATUS
func (azureSku *AzureSku_STATUS) AssignProperties_To_AzureSku_STATUS(destination *storage.AzureSku_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Capacity
	destination.Capacity = genruntime.ClonePointerToInt(azureSku.Capacity)

	// Name
	if azureSku.Name != nil {
		name := string(*azureSku.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Tier
	if azureSku.Tier != nil {
		tier := string(*azureSku.Tier)
		destination.Tier = &tier
	} else {
		destination.Tier = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type ClusterOperatorSpec struct {
	// ConfigMapExpressions: configures where to place operator written dynamic ConfigMaps (created with CEL expressions).
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`

	// SecretExpressions: configures where to place operator written dynamic secrets (created with CEL expressions).
	SecretExpressions []*core.DestinationExpression `json:"secretExpressions,omitempty"`
}

// AssignProperties_From_ClusterOperatorSpec populates our ClusterOperatorSpec from the provided source ClusterOperatorSpec
func (operator *ClusterOperatorSpec) AssignProperties_From_ClusterOperatorSpec(source *storage.ClusterOperatorSpec) error {

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ClusterOperatorSpec populates the provided destination ClusterOperatorSpec from our ClusterOperatorSpec
func (operator *ClusterOperatorSpec) AssignProperties_To_ClusterOperatorSpec(destination *storage.ClusterOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"V2","V3"}
type ClusterProperties_EngineType string

const (
	ClusterProperties_EngineType_V2 = ClusterProperties_EngineType("V2")
	ClusterProperties_EngineType_V3 = ClusterProperties_EngineType("V3")
)

// Mapping from string to ClusterProperties_EngineType
var clusterProperties_EngineType_Values = map[string]ClusterProperties_EngineType{
	"v2": ClusterProperties_EngineType_V2,
	"v3": ClusterProperties_EngineType_V3,
}

type ClusterProperties_EngineType_STATUS string

const (
	ClusterProperties_EngineType_STATUS_V2 = ClusterProperties_EngineType_STATUS("V2")
	ClusterProperties_EngineType_STATUS_V3 = ClusterProperties_EngineType_STATUS("V3")
)

// Mapping from string to ClusterProperties_EngineType_STATUS
var clusterProperties_EngineType_STATUS_Values = map[string]ClusterProperties_EngineType_STATUS{
	"v2": ClusterProperties_EngineType_STATUS_V2,
	"v3": ClusterProperties_EngineType_STATUS_V3,
}

// +kubebuilder:validation:Enum={"DualStack","IPv4"}
type ClusterProperties_PublicIPType string

const (
	ClusterProperties_PublicIPType_DualStack = ClusterProperties_PublicIPType("DualStack")
	ClusterProperties_PublicIPType_IPv4      = ClusterProperties_PublicIPType("IPv4")
)

// Mapping from string to ClusterProperties_PublicIPType
var clusterProperties_PublicIPType_Values = map[string]ClusterProperties_PublicIPType{
	"dualstack": ClusterProperties_PublicIPType_DualStack,
	"ipv4":      ClusterProperties_PublicIPType_IPv4,
}

type ClusterProperties_PublicIPType_STATUS string

const (
	ClusterProperties_PublicIPType_STATUS_DualStack = ClusterProperties_PublicIPType_STATUS("DualStack")
	ClusterProperties_PublicIPType_STATUS_IPv4      = ClusterProperties_PublicIPType_STATUS("IPv4")
)

// Mapping from string to ClusterProperties_PublicIPType_STATUS
var clusterProperties_PublicIPType_STATUS_Values = map[string]ClusterProperties_PublicIPType_STATUS{
	"dualstack": ClusterProperties_PublicIPType_STATUS_DualStack,
	"ipv4":      ClusterProperties_PublicIPType_STATUS_IPv4,
}

// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type ClusterProperties_PublicNetworkAccess string

const (
	ClusterProperties_PublicNetworkAccess_Disabled = ClusterProperties_PublicNetworkAccess("Disabled")
	ClusterProperties_PublicNetworkAccess_Enabled  = ClusterProperties_PublicNetworkAccess("Enabled")
)

// Mapping from string to ClusterProperties_PublicNetworkAccess
var clusterProperties_PublicNetworkAccess_Values = map[string]ClusterProperties_PublicNetworkAccess{
	"disabled": ClusterProperties_PublicNetworkAccess_Disabled,
	"enabled":  ClusterProperties_PublicNetworkAccess_Enabled,
}

type ClusterProperties_PublicNetworkAccess_STATUS string

const (
	ClusterProperties_PublicNetworkAccess_STATUS_Disabled = ClusterProperties_PublicNetworkAccess_STATUS("Disabled")
	ClusterProperties_PublicNetworkAccess_STATUS_Enabled  = ClusterProperties_PublicNetworkAccess_STATUS("Enabled")
)

// Mapping from string to ClusterProperties_PublicNetworkAccess_STATUS
var clusterProperties_PublicNetworkAccess_STATUS_Values = map[string]ClusterProperties_PublicNetworkAccess_STATUS{
	"disabled": ClusterProperties_PublicNetworkAccess_STATUS_Disabled,
	"enabled":  ClusterProperties_PublicNetworkAccess_STATUS_Enabled,
}

// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type ClusterProperties_RestrictOutboundNetworkAccess string

const (
	ClusterProperties_RestrictOutboundNetworkAccess_Disabled = ClusterProperties_RestrictOutboundNetworkAccess("Disabled")
	ClusterProperties_RestrictOutboundNetworkAccess_Enabled  = ClusterProperties_RestrictOutboundNetworkAccess("Enabled")
)

// Mapping from string to ClusterProperties_RestrictOutboundNetworkAccess
var clusterProperties_RestrictOutboundNetworkAccess_Values = map[string]ClusterProperties_RestrictOutboundNetworkAccess{
	"disabled": ClusterProperties_RestrictOutboundNetworkAccess_Disabled,
	"enabled":  ClusterProperties_RestrictOutboundNetworkAccess_Enabled,
}

type ClusterProperties_RestrictOutboundNetworkAccess_STATUS string

const (
	ClusterProperties_RestrictOutboundNetworkAccess_STATUS_Disabled = ClusterProperties_RestrictOutboundNetworkAccess_STATUS("Disabled")
	ClusterProperties_RestrictOutboundNetworkAccess_STATUS_Enabled  = ClusterProperties_RestrictOutboundNetworkAccess_STATUS("Enabled")
)

// Mapping from string to ClusterProperties_RestrictOutboundNetworkAccess_STATUS
var clusterProperties_RestrictOutboundNetworkAccess_STATUS_Values = map[string]ClusterProperties_RestrictOutboundNetworkAccess_STATUS{
	"disabled": ClusterProperties_RestrictOutboundNetworkAccess_STATUS_Disabled,
	"enabled":  ClusterProperties_RestrictOutboundNetworkAccess_STATUS_Enabled,
}

type ClusterProperties_State_STATUS string

const (
	ClusterProperties_State_STATUS_Creating    = ClusterProperties_State_STATUS("Creating")
	ClusterProperties_State_STATUS_Deleted     = ClusterProperties_State_STATUS("Deleted")
	ClusterProperties_State_STATUS_Deleting    = ClusterProperties_State_STATUS("Deleting")
	ClusterProperties_State_STATUS_Migrated    = ClusterProperties_State_STATUS("Migrated")
	ClusterProperties_State_STATUS_Running     = ClusterProperties_State_STATUS("Running")
	ClusterProperties_State_STATUS_Starting    = ClusterProperties_State_STATUS("Starting")
	ClusterProperties_State_STATUS_Stopped     = ClusterProperties_State_STATUS("Stopped")
	ClusterProperties_State_STATUS_Stopping    = ClusterProperties_State_STATUS("Stopping")
	ClusterProperties_State_STATUS_Unavailable = ClusterProperties_State_STATUS("Unavailable")
	ClusterProperties_State_STATUS_Updating    = ClusterProperties_State_STATUS("Updating")
)

// Mapping from string to ClusterProperties_State_STATUS
var clusterProperties_State_STATUS_Values = map[string]ClusterProperties_State_STATUS{
	"creating":    ClusterProperties_State_STATUS_Creating,
	"deleted":     ClusterProperties_State_STATUS_Deleted,
	"deleting":    ClusterProperties_State_STATUS_Deleting,
	"migrated":    ClusterProperties_State_STATUS_Migrated,
	"running":     ClusterProperties_State_STATUS_Running,
	"starting":    ClusterProperties_State_STATUS_Starting,
	"stopped":     ClusterProperties_State_STATUS_Stopped,
	"stopping":    ClusterProperties_State_STATUS_Stopping,
	"unavailable": ClusterProperties_State_STATUS_Unavailable,
	"updating":    ClusterProperties_State_STATUS_Updating,
}

// Identity for the resource.
type Identity struct {
	// +kubebuilder:validation:Required
	// Type: The type of managed identity used. The type 'SystemAssigned, UserAssigned' includes both an implicitly created
	// identity and a set of user-assigned identities. The type 'None' will remove all identities.
	Type *Identity_Type `json:"type,omitempty"`

	// UserAssignedIdentities: The list of user identities associated with the Kusto cluster. The user identity dictionary key
	// references will be ARM resource ids in the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities []UserAssignedIdentityDetails `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.ARMTransformer = &Identity{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (identity *Identity) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if identity == nil {
		return nil, nil
	}
	result := &arm.Identity{}

	// Set property "Type":
	if identity.Type != nil {
		var temp string
		temp = string(*identity.Type)
		typeVar := arm.Identity_Type(temp)
		result.Type = &typeVar
	}

	// Set property "UserAssignedIdentities":
	result.UserAssignedIdentities = make(map[string]arm.UserAssignedIdentityDetails, len(identity.UserAssignedIdentities))
	for _, ident := range identity.UserAssignedIdentities {
		identARMID, err := resolved.ResolvedReferences.Lookup(ident.Reference)
		if err != nil {
			return nil, err
		}
		key := identARMID
		result.UserAssignedIdentities[key] = arm.UserAssignedIdentityDetails{}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *Identity) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Identity{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *Identity) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Identity)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Identity, got %T", armInput)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := Identity_Type(temp)
		identity.Type = &typeVar
	}

	// no assignment for property "UserAssignedIdentities"

	// No error
	return nil
}

// AssignProperties_From_Identity populates our Identity from the provided source Identity
func (identity *Identity) AssignProperties_From_Identity(source *storage.Identity) error {

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, identity_Type_Values)
		identity.Type = &typeTemp
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]UserAssignedIdentityDetails, len(source.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity UserAssignedIdentityDetails
			err := userAssignedIdentity.AssignProperties_From_UserAssignedIdentityDetails(&userAssignedIdentityItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityList
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Identity populates the provided destination Identity from our Identity
func (identity *Identity) AssignProperties_To_Identity(destination *storage.Identity) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]storage.UserAssignedIdentityDetails, len(identity.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity storage.UserAssignedIdentityDetails
			err := userAssignedIdentityItem.AssignProperties_To_UserAssignedIdentityDetails(&userAssignedIdentity)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityList
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Identity_STATUS populates our Identity from the provided source Identity_STATUS
func (identity *Identity) Initialize_From_Identity_STATUS(source *Identity_STATUS) error {

	// Type
	if source.Type != nil {
		typeVar := genruntime.ToEnum(string(*source.Type), identity_Type_Values)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]UserAssignedIdentityDetails, 0, len(source.UserAssignedIdentities))
		for userAssignedIdentitiesKey := range source.UserAssignedIdentities {
			userAssignedIdentitiesRef := genruntime.CreateResourceReferenceFromARMID(userAssignedIdentitiesKey)
			userAssignedIdentityList = append(userAssignedIdentityList, UserAssignedIdentityDetails{Reference: userAssignedIdentitiesRef})
		}
		identity.UserAssignedIdentities = userAssignedIdentityList
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// Identity for the resource.
type Identity_STATUS struct {
	// PrincipalId: The principal ID of resource identity.
	PrincipalId *string `json:"principalId,omitempty"`

	// TenantId: The tenant ID of resource.
	TenantId *string `json:"tenantId,omitempty"`

	// Type: The type of managed identity used. The type 'SystemAssigned, UserAssigned' includes both an implicitly created
	// identity and a set of user-assigned identities. The type 'None' will remove all identities.
	Type *Identity_Type_STATUS `json:"type,omitempty"`

	// UserAssignedIdentities: The list of user identities associated with the Kusto cluster. The user identity dictionary key
	// references will be ARM resource ids in the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities map[string]Identity_UserAssignedIdentities_STATUS `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.FromARMConverter = &Identity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *Identity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Identity_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *Identity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Identity_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Identity_STATUS, got %T", armInput)
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identity.PrincipalId = &principalId
	}

	// Set property "TenantId":
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		identity.TenantId = &tenantId
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := Identity_Type_STATUS(temp)
		identity.Type = &typeVar
	}

	// Set property "UserAssignedIdentities":
	if typedInput.UserAssignedIdentities != nil {
		identity.UserAssignedIdentities = make(map[string]Identity_UserAssignedIdentities_STATUS, len(typedInput.UserAssignedIdentities))
		for key, value := range typedInput.UserAssignedIdentities {
			var value1 Identity_UserAssignedIdentities_STATUS
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			identity.UserAssignedIdentities[key] = value1
		}
	}

	// No error
	return nil
}

// AssignProperties_From_Identity_STATUS populates our Identity_STATUS from the provided source Identity_STATUS
func (identity *Identity_STATUS) AssignProperties_From_Identity_STATUS(source *storage.Identity_STATUS) error {

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// TenantId
	identity.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, identity_Type_STATUS_Values)
		identity.Type = &typeTemp
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]Identity_UserAssignedIdentities_STATUS, len(source.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity Identity_UserAssignedIdentities_STATUS
			err := userAssignedIdentity.AssignProperties_From_Identity_UserAssignedIdentities_STATUS(&userAssignedIdentityValue)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_Identity_UserAssignedIdentities_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Identity_STATUS populates the provided destination Identity_STATUS from our Identity_STATUS
func (identity *Identity_STATUS) AssignProperties_To_Identity_STATUS(destination *storage.Identity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(identity.TenantId)

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]storage.Identity_UserAssignedIdentities_STATUS, len(identity.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity storage.Identity_UserAssignedIdentities_STATUS
			err := userAssignedIdentityValue.AssignProperties_To_Identity_UserAssignedIdentities_STATUS(&userAssignedIdentity)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_Identity_UserAssignedIdentities_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Properties of the key vault.
type KeyVaultProperties struct {
	// KeyName: The name of the key vault key.
	KeyName *string `json:"keyName,omitempty"`

	// KeyVaultUri: The Uri of the key vault.
	KeyVaultUri *string `json:"keyVaultUri,omitempty"`

	// KeyVersion: The version of the key vault key.
	KeyVersion *string `json:"keyVersion,omitempty"`

	// UserIdentityReference: The user assigned identity (ARM resource id) that has access to the key.
	UserIdentityReference *genruntime.ResourceReference `armReference:"UserIdentity" json:"userIdentityReference,omitempty"`
}

var _ genruntime.ARMTransformer = &KeyVaultProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *KeyVaultProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.KeyVaultProperties{}

	// Set property "KeyName":
	if properties.KeyName != nil {
		keyName := *properties.KeyName
		result.KeyName = &keyName
	}

	// Set property "KeyVaultUri":
	if properties.KeyVaultUri != nil {
		keyVaultUri := *properties.KeyVaultUri
		result.KeyVaultUri = &keyVaultUri
	}

	// Set property "KeyVersion":
	if properties.KeyVersion != nil {
		keyVersion := *properties.KeyVersion
		result.KeyVersion = &keyVersion
	}

	// Set property "UserIdentity":
	if properties.UserIdentityReference != nil {
		userIdentityReferenceARMID, err := resolved.ResolvedReferences.Lookup(*properties.UserIdentityReference)
		if err != nil {
			return nil, err
		}
		userIdentityReference := userIdentityReferenceARMID
		result.UserIdentity = &userIdentityReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *KeyVaultProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.KeyVaultProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *KeyVaultProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.KeyVaultProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.KeyVaultProperties, got %T", armInput)
	}

	// Set property "KeyName":
	if typedInput.KeyName != nil {
		keyName := *typedInput.KeyName
		properties.KeyName = &keyName
	}

	// Set property "KeyVaultUri":
	if typedInput.KeyVaultUri != nil {
		keyVaultUri := *typedInput.KeyVaultUri
		properties.KeyVaultUri = &keyVaultUri
	}

	// Set property "KeyVersion":
	if typedInput.KeyVersion != nil {
		keyVersion := *typedInput.KeyVersion
		properties.KeyVersion = &keyVersion
	}

	// no assignment for property "UserIdentityReference"

	// No error
	return nil
}

// AssignProperties_From_KeyVaultProperties populates our KeyVaultProperties from the provided source KeyVaultProperties
func (properties *KeyVaultProperties) AssignProperties_From_KeyVaultProperties(source *storage.KeyVaultProperties) error {

	// KeyName
	properties.KeyName = genruntime.ClonePointerToString(source.KeyName)

	// KeyVaultUri
	properties.KeyVaultUri = genruntime.ClonePointerToString(source.KeyVaultUri)

	// KeyVersion
	properties.KeyVersion = genruntime.ClonePointerToString(source.KeyVersion)

	// UserIdentityReference
	if source.UserIdentityReference != nil {
		userIdentityReference := source.UserIdentityReference.Copy()
		properties.UserIdentityReference = &userIdentityReference
	} else {
		properties.UserIdentityReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_KeyVaultProperties populates the provided destination KeyVaultProperties from our KeyVaultProperties
func (properties *KeyVaultProperties) AssignProperties_To_KeyVaultProperties(destination *storage.KeyVaultProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyName
	destination.KeyName = genruntime.ClonePointerToString(properties.KeyName)

	// KeyVaultUri
	destination.KeyVaultUri = genruntime.ClonePointerToString(properties.KeyVaultUri)

	// KeyVersion
	destination.KeyVersion = genruntime.ClonePointerToString(properties.KeyVersion)

	// UserIdentityReference
	if properties.UserIdentityReference != nil {
		userIdentityReference := properties.UserIdentityReference.Copy()
		destination.UserIdentityReference = &userIdentityReference
	} else {
		destination.UserIdentityReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_KeyVaultProperties_STATUS populates our KeyVaultProperties from the provided source KeyVaultProperties_STATUS
func (properties *KeyVaultProperties) Initialize_From_KeyVaultProperties_STATUS(source *KeyVaultProperties_STATUS) error {

	// KeyName
	properties.KeyName = genruntime.ClonePointerToString(source.KeyName)

	// KeyVaultUri
	properties.KeyVaultUri = genruntime.ClonePointerToString(source.KeyVaultUri)

	// KeyVersion
	properties.KeyVersion = genruntime.ClonePointerToString(source.KeyVersion)

	// No error
	return nil
}

// Properties of the key vault.
type KeyVaultProperties_STATUS struct {
	// KeyName: The name of the key vault key.
	KeyName *string `json:"keyName,omitempty"`

	// KeyVaultUri: The Uri of the key vault.
	KeyVaultUri *string `json:"keyVaultUri,omitempty"`

	// KeyVersion: The version of the key vault key.
	KeyVersion *string `json:"keyVersion,omitempty"`

	// UserIdentity: The user assigned identity (ARM resource id) that has access to the key.
	UserIdentity *string `json:"userIdentity,omitempty"`
}

var _ genruntime.FromARMConverter = &KeyVaultProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *KeyVaultProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.KeyVaultProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *KeyVaultProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.KeyVaultProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.KeyVaultProperties_STATUS, got %T", armInput)
	}

	// Set property "KeyName":
	if typedInput.KeyName != nil {
		keyName := *typedInput.KeyName
		properties.KeyName = &keyName
	}

	// Set property "KeyVaultUri":
	if typedInput.KeyVaultUri != nil {
		keyVaultUri := *typedInput.KeyVaultUri
		properties.KeyVaultUri = &keyVaultUri
	}

	// Set property "KeyVersion":
	if typedInput.KeyVersion != nil {
		keyVersion := *typedInput.KeyVersion
		properties.KeyVersion = &keyVersion
	}

	// Set property "UserIdentity":
	if typedInput.UserIdentity != nil {
		userIdentity := *typedInput.UserIdentity
		properties.UserIdentity = &userIdentity
	}

	// No error
	return nil
}

// AssignProperties_From_KeyVaultProperties_STATUS populates our KeyVaultProperties_STATUS from the provided source KeyVaultProperties_STATUS
func (properties *KeyVaultProperties_STATUS) AssignProperties_From_KeyVaultProperties_STATUS(source *storage.KeyVaultProperties_STATUS) error {

	// KeyName
	properties.KeyName = genruntime.ClonePointerToString(source.KeyName)

	// KeyVaultUri
	properties.KeyVaultUri = genruntime.ClonePointerToString(source.KeyVaultUri)

	// KeyVersion
	properties.KeyVersion = genruntime.ClonePointerToString(source.KeyVersion)

	// UserIdentity
	properties.UserIdentity = genruntime.ClonePointerToString(source.UserIdentity)

	// No error
	return nil
}

// AssignProperties_To_KeyVaultProperties_STATUS populates the provided destination KeyVaultProperties_STATUS from our KeyVaultProperties_STATUS
func (properties *KeyVaultProperties_STATUS) AssignProperties_To_KeyVaultProperties_STATUS(destination *storage.KeyVaultProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyName
	destination.KeyName = genruntime.ClonePointerToString(properties.KeyName)

	// KeyVaultUri
	destination.KeyVaultUri = genruntime.ClonePointerToString(properties.KeyVaultUri)

	// KeyVersion
	destination.KeyVersion = genruntime.ClonePointerToString(properties.KeyVersion)

	// UserIdentity
	destination.UserIdentity = genruntime.ClonePointerToString(properties.UserIdentity)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The list of language extension objects.
type LanguageExtensionsList struct {
	// Value: The list of language extensions.
	Value []LanguageExtension `json:"value,omitempty"`
}

var _ genruntime.ARMTransformer = &LanguageExtensionsList{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (list *LanguageExtensionsList) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if list == nil {
		return nil, nil
	}
	result := &arm.LanguageExtensionsList{}

	// Set property "Value":
	for _, item := range list.Value {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Value = append(result.Value, *item_ARM.(*arm.LanguageExtension))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (list *LanguageExtensionsList) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.LanguageExtensionsList{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (list *LanguageExtensionsList) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.LanguageExtensionsList)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.LanguageExtensionsList, got %T", armInput)
	}

	// Set property "Value":
	for _, item := range typedInput.Value {
		var item1 LanguageExtension
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		list.Value = append(list.Value, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_LanguageExtensionsList populates our LanguageExtensionsList from the provided source LanguageExtensionsList
func (list *LanguageExtensionsList) AssignProperties_From_LanguageExtensionsList(source *storage.LanguageExtensionsList) error {

	// Value
	if source.Value != nil {
		valueList := make([]LanguageExtension, len(source.Value))
		for valueIndex, valueItem := range source.Value {
			// Shadow the loop variable to avoid aliasing
			valueItem := valueItem
			var value LanguageExtension
			err := value.AssignProperties_From_LanguageExtension(&valueItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_LanguageExtension() to populate field Value")
			}
			valueList[valueIndex] = value
		}
		list.Value = valueList
	} else {
		list.Value = nil
	}

	// No error
	return nil
}

// AssignProperties_To_LanguageExtensionsList populates the provided destination LanguageExtensionsList from our LanguageExtensionsList
func (list *LanguageExtensionsList) AssignProperties_To_LanguageExtensionsList(destination *storage.LanguageExtensionsList) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Value
	if list.Value != nil {
		valueList := make([]storage.LanguageExtension, len(list.Value))
		for valueIndex, valueItem := range list.Value {
			// Shadow the loop variable to avoid aliasing
			valueItem := valueItem
			var value storage.LanguageExtension
			err := valueItem.AssignProperties_To_LanguageExtension(&value)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_LanguageExtension() to populate field Value")
			}
			valueList[valueIndex] = value
		}
		destination.Value = valueList
	} else {
		destination.Value = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_LanguageExtensionsList_STATUS populates our LanguageExtensionsList from the provided source LanguageExtensionsList_STATUS
func (list *LanguageExtensionsList) Initialize_From_LanguageExtensionsList_STATUS(source *LanguageExtensionsList_STATUS) error {

	// Value
	if source.Value != nil {
		valueList := make([]LanguageExtension, len(source.Value))
		for valueIndex, valueItem := range source.Value {
			// Shadow the loop variable to avoid aliasing
			valueItem := valueItem
			var value LanguageExtension
			err := value.Initialize_From_LanguageExtension_STATUS(&valueItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_LanguageExtension_STATUS() to populate field Value")
			}
			valueList[valueIndex] = value
		}
		list.Value = valueList
	} else {
		list.Value = nil
	}

	// No error
	return nil
}

// The list of language extension objects.
type LanguageExtensionsList_STATUS struct {
	// Value: The list of language extensions.
	Value []LanguageExtension_STATUS `json:"value,omitempty"`
}

var _ genruntime.FromARMConverter = &LanguageExtensionsList_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (list *LanguageExtensionsList_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.LanguageExtensionsList_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (list *LanguageExtensionsList_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.LanguageExtensionsList_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.LanguageExtensionsList_STATUS, got %T", armInput)
	}

	// Set property "Value":
	for _, item := range typedInput.Value {
		var item1 LanguageExtension_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		list.Value = append(list.Value, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_LanguageExtensionsList_STATUS populates our LanguageExtensionsList_STATUS from the provided source LanguageExtensionsList_STATUS
func (list *LanguageExtensionsList_STATUS) AssignProperties_From_LanguageExtensionsList_STATUS(source *storage.LanguageExtensionsList_STATUS) error {

	// Value
	if source.Value != nil {
		valueList := make([]LanguageExtension_STATUS, len(source.Value))
		for valueIndex, valueItem := range source.Value {
			// Shadow the loop variable to avoid aliasing
			valueItem := valueItem
			var value LanguageExtension_STATUS
			err := value.AssignProperties_From_LanguageExtension_STATUS(&valueItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_LanguageExtension_STATUS() to populate field Value")
			}
			valueList[valueIndex] = value
		}
		list.Value = valueList
	} else {
		list.Value = nil
	}

	// No error
	return nil
}

// AssignProperties_To_LanguageExtensionsList_STATUS populates the provided destination LanguageExtensionsList_STATUS from our LanguageExtensionsList_STATUS
func (list *LanguageExtensionsList_STATUS) AssignProperties_To_LanguageExtensionsList_STATUS(destination *storage.LanguageExtensionsList_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Value
	if list.Value != nil {
		valueList := make([]storage.LanguageExtension_STATUS, len(list.Value))
		for valueIndex, valueItem := range list.Value {
			// Shadow the loop variable to avoid aliasing
			valueItem := valueItem
			var value storage.LanguageExtension_STATUS
			err := valueItem.AssignProperties_To_LanguageExtension_STATUS(&value)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_LanguageExtension_STATUS() to populate field Value")
			}
			valueList[valueIndex] = value
		}
		destination.Value = valueList
	} else {
		destination.Value = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Represents a properties of a cluster that is part of a migration.
type MigrationClusterProperties_STATUS struct {
	// DataIngestionUri: The public data ingestion URL of the cluster.
	DataIngestionUri *string `json:"dataIngestionUri,omitempty"`

	// Id: The resource ID of the cluster.
	Id *string `json:"id,omitempty"`

	// Role: The role of the cluster in the migration process.
	Role *MigrationClusterProperties_Role_STATUS `json:"role,omitempty"`

	// Uri: The public URL of the cluster.
	Uri *string `json:"uri,omitempty"`
}

var _ genruntime.FromARMConverter = &MigrationClusterProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *MigrationClusterProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.MigrationClusterProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *MigrationClusterProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.MigrationClusterProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.MigrationClusterProperties_STATUS, got %T", armInput)
	}

	// Set property "DataIngestionUri":
	if typedInput.DataIngestionUri != nil {
		dataIngestionUri := *typedInput.DataIngestionUri
		properties.DataIngestionUri = &dataIngestionUri
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		properties.Id = &id
	}

	// Set property "Role":
	if typedInput.Role != nil {
		var temp string
		temp = string(*typedInput.Role)
		role := MigrationClusterProperties_Role_STATUS(temp)
		properties.Role = &role
	}

	// Set property "Uri":
	if typedInput.Uri != nil {
		uri := *typedInput.Uri
		properties.Uri = &uri
	}

	// No error
	return nil
}

// AssignProperties_From_MigrationClusterProperties_STATUS populates our MigrationClusterProperties_STATUS from the provided source MigrationClusterProperties_STATUS
func (properties *MigrationClusterProperties_STATUS) AssignProperties_From_MigrationClusterProperties_STATUS(source *storage.MigrationClusterProperties_STATUS) error {

	// DataIngestionUri
	properties.DataIngestionUri = genruntime.ClonePointerToString(source.DataIngestionUri)

	// Id
	properties.Id = genruntime.ClonePointerToString(source.Id)

	// Role
	if source.Role != nil {
		role := *source.Role
		roleTemp := genruntime.ToEnum(role, migrationClusterProperties_Role_STATUS_Values)
		properties.Role = &roleTemp
	} else {
		properties.Role = nil
	}

	// Uri
	properties.Uri = genruntime.ClonePointerToString(source.Uri)

	// No error
	return nil
}

// AssignProperties_To_MigrationClusterProperties_STATUS populates the provided destination MigrationClusterProperties_STATUS from our MigrationClusterProperties_STATUS
func (properties *MigrationClusterProperties_STATUS) AssignProperties_To_MigrationClusterProperties_STATUS(destination *storage.MigrationClusterProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DataIngestionUri
	destination.DataIngestionUri = genruntime.ClonePointerToString(properties.DataIngestionUri)

	// Id
	destination.Id = genruntime.ClonePointerToString(properties.Id)

	// Role
	if properties.Role != nil {
		role := string(*properties.Role)
		destination.Role = &role
	} else {
		destination.Role = nil
	}

	// Uri
	destination.Uri = genruntime.ClonePointerToString(properties.Uri)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// A class that contains the optimized auto scale definition.
type OptimizedAutoscale struct {
	// +kubebuilder:validation:Required
	// IsEnabled: A boolean value that indicate if the optimized autoscale feature is enabled or not.
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// +kubebuilder:validation:Required
	// Maximum: Maximum allowed instances count.
	Maximum *int `json:"maximum,omitempty"`

	// +kubebuilder:validation:Required
	// Minimum: Minimum allowed instances count.
	Minimum *int `json:"minimum,omitempty"`

	// +kubebuilder:validation:Required
	// Version: The version of the template defined, for instance 1.
	Version *int `json:"version,omitempty"`
}

var _ genruntime.ARMTransformer = &OptimizedAutoscale{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (autoscale *OptimizedAutoscale) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if autoscale == nil {
		return nil, nil
	}
	result := &arm.OptimizedAutoscale{}

	// Set property "IsEnabled":
	if autoscale.IsEnabled != nil {
		isEnabled := *autoscale.IsEnabled
		result.IsEnabled = &isEnabled
	}

	// Set property "Maximum":
	if autoscale.Maximum != nil {
		maximum := *autoscale.Maximum
		result.Maximum = &maximum
	}

	// Set property "Minimum":
	if autoscale.Minimum != nil {
		minimum := *autoscale.Minimum
		result.Minimum = &minimum
	}

	// Set property "Version":
	if autoscale.Version != nil {
		version := *autoscale.Version
		result.Version = &version
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (autoscale *OptimizedAutoscale) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.OptimizedAutoscale{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (autoscale *OptimizedAutoscale) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.OptimizedAutoscale)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.OptimizedAutoscale, got %T", armInput)
	}

	// Set property "IsEnabled":
	if typedInput.IsEnabled != nil {
		isEnabled := *typedInput.IsEnabled
		autoscale.IsEnabled = &isEnabled
	}

	// Set property "Maximum":
	if typedInput.Maximum != nil {
		maximum := *typedInput.Maximum
		autoscale.Maximum = &maximum
	}

	// Set property "Minimum":
	if typedInput.Minimum != nil {
		minimum := *typedInput.Minimum
		autoscale.Minimum = &minimum
	}

	// Set property "Version":
	if typedInput.Version != nil {
		version := *typedInput.Version
		autoscale.Version = &version
	}

	// No error
	return nil
}

// AssignProperties_From_OptimizedAutoscale populates our OptimizedAutoscale from the provided source OptimizedAutoscale
func (autoscale *OptimizedAutoscale) AssignProperties_From_OptimizedAutoscale(source *storage.OptimizedAutoscale) error {

	// IsEnabled
	if source.IsEnabled != nil {
		isEnabled := *source.IsEnabled
		autoscale.IsEnabled = &isEnabled
	} else {
		autoscale.IsEnabled = nil
	}

	// Maximum
	autoscale.Maximum = genruntime.ClonePointerToInt(source.Maximum)

	// Minimum
	autoscale.Minimum = genruntime.ClonePointerToInt(source.Minimum)

	// Version
	autoscale.Version = genruntime.ClonePointerToInt(source.Version)

	// No error
	return nil
}

// AssignProperties_To_OptimizedAutoscale populates the provided destination OptimizedAutoscale from our OptimizedAutoscale
func (autoscale *OptimizedAutoscale) AssignProperties_To_OptimizedAutoscale(destination *storage.OptimizedAutoscale) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IsEnabled
	if autoscale.IsEnabled != nil {
		isEnabled := *autoscale.IsEnabled
		destination.IsEnabled = &isEnabled
	} else {
		destination.IsEnabled = nil
	}

	// Maximum
	destination.Maximum = genruntime.ClonePointerToInt(autoscale.Maximum)

	// Minimum
	destination.Minimum = genruntime.ClonePointerToInt(autoscale.Minimum)

	// Version
	destination.Version = genruntime.ClonePointerToInt(autoscale.Version)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_OptimizedAutoscale_STATUS populates our OptimizedAutoscale from the provided source OptimizedAutoscale_STATUS
func (autoscale *OptimizedAutoscale) Initialize_From_OptimizedAutoscale_STATUS(source *OptimizedAutoscale_STATUS) error {

	// IsEnabled
	if source.IsEnabled != nil {
		isEnabled := *source.IsEnabled
		autoscale.IsEnabled = &isEnabled
	} else {
		autoscale.IsEnabled = nil
	}

	// Maximum
	autoscale.Maximum = genruntime.ClonePointerToInt(source.Maximum)

	// Minimum
	autoscale.Minimum = genruntime.ClonePointerToInt(source.Minimum)

	// Version
	autoscale.Version = genruntime.ClonePointerToInt(source.Version)

	// No error
	return nil
}

// A class that contains the optimized auto scale definition.
type OptimizedAutoscale_STATUS struct {
	// IsEnabled: A boolean value that indicate if the optimized autoscale feature is enabled or not.
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// Maximum: Maximum allowed instances count.
	Maximum *int `json:"maximum,omitempty"`

	// Minimum: Minimum allowed instances count.
	Minimum *int `json:"minimum,omitempty"`

	// Version: The version of the template defined, for instance 1.
	Version *int `json:"version,omitempty"`
}

var _ genruntime.FromARMConverter = &OptimizedAutoscale_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (autoscale *OptimizedAutoscale_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.OptimizedAutoscale_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (autoscale *OptimizedAutoscale_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.OptimizedAutoscale_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.OptimizedAutoscale_STATUS, got %T", armInput)
	}

	// Set property "IsEnabled":
	if typedInput.IsEnabled != nil {
		isEnabled := *typedInput.IsEnabled
		autoscale.IsEnabled = &isEnabled
	}

	// Set property "Maximum":
	if typedInput.Maximum != nil {
		maximum := *typedInput.Maximum
		autoscale.Maximum = &maximum
	}

	// Set property "Minimum":
	if typedInput.Minimum != nil {
		minimum := *typedInput.Minimum
		autoscale.Minimum = &minimum
	}

	// Set property "Version":
	if typedInput.Version != nil {
		version := *typedInput.Version
		autoscale.Version = &version
	}

	// No error
	return nil
}

// AssignProperties_From_OptimizedAutoscale_STATUS populates our OptimizedAutoscale_STATUS from the provided source OptimizedAutoscale_STATUS
func (autoscale *OptimizedAutoscale_STATUS) AssignProperties_From_OptimizedAutoscale_STATUS(source *storage.OptimizedAutoscale_STATUS) error {

	// IsEnabled
	if source.IsEnabled != nil {
		isEnabled := *source.IsEnabled
		autoscale.IsEnabled = &isEnabled
	} else {
		autoscale.IsEnabled = nil
	}

	// Maximum
	autoscale.Maximum = genruntime.ClonePointerToInt(source.Maximum)

	// Minimum
	autoscale.Minimum = genruntime.ClonePointerToInt(source.Minimum)

	// Version
	autoscale.Version = genruntime.ClonePointerToInt(source.Version)

	// No error
	return nil
}

// AssignProperties_To_OptimizedAutoscale_STATUS populates the provided destination OptimizedAutoscale_STATUS from our OptimizedAutoscale_STATUS
func (autoscale *OptimizedAutoscale_STATUS) AssignProperties_To_OptimizedAutoscale_STATUS(destination *storage.OptimizedAutoscale_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IsEnabled
	if autoscale.IsEnabled != nil {
		isEnabled := *autoscale.IsEnabled
		destination.IsEnabled = &isEnabled
	} else {
		destination.IsEnabled = nil
	}

	// Maximum
	destination.Maximum = genruntime.ClonePointerToInt(autoscale.Maximum)

	// Minimum
	destination.Minimum = genruntime.ClonePointerToInt(autoscale.Minimum)

	// Version
	destination.Version = genruntime.ClonePointerToInt(autoscale.Version)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// A private endpoint connection
type PrivateEndpointConnection_STATUS struct {
	// Id: Fully qualified resource ID for the resource. Ex -
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &PrivateEndpointConnection_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (connection *PrivateEndpointConnection_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PrivateEndpointConnection_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (connection *PrivateEndpointConnection_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PrivateEndpointConnection_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PrivateEndpointConnection_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		connection.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_PrivateEndpointConnection_STATUS populates our PrivateEndpointConnection_STATUS from the provided source PrivateEndpointConnection_STATUS
func (connection *PrivateEndpointConnection_STATUS) AssignProperties_From_PrivateEndpointConnection_STATUS(source *storage.PrivateEndpointConnection_STATUS) error {

	// Id
	connection.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_PrivateEndpointConnection_STATUS populates the provided destination PrivateEndpointConnection_STATUS from our PrivateEndpointConnection_STATUS
func (connection *PrivateEndpointConnection_STATUS) AssignProperties_To_PrivateEndpointConnection_STATUS(destination *storage.PrivateEndpointConnection_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(connection.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The provisioned state of the resource.
type ProvisioningState_STATUS string

const (
	ProvisioningState_STATUS_Canceled  = ProvisioningState_STATUS("Canceled")
	ProvisioningState_STATUS_Creating  = ProvisioningState_STATUS("Creating")
	ProvisioningState_STATUS_Deleting  = ProvisioningState_STATUS("Deleting")
	ProvisioningState_STATUS_Failed    = ProvisioningState_STATUS("Failed")
	ProvisioningState_STATUS_Moving    = ProvisioningState_STATUS("Moving")
	ProvisioningState_STATUS_Running   = ProvisioningState_STATUS("Running")
	ProvisioningState_STATUS_Succeeded = ProvisioningState_STATUS("Succeeded")
)

// Mapping from string to ProvisioningState_STATUS
var provisioningState_STATUS_Values = map[string]ProvisioningState_STATUS{
	"canceled":  ProvisioningState_STATUS_Canceled,
	"creating":  ProvisioningState_STATUS_Creating,
	"deleting":  ProvisioningState_STATUS_Deleting,
	"failed":    ProvisioningState_STATUS_Failed,
	"moving":    ProvisioningState_STATUS_Moving,
	"running":   ProvisioningState_STATUS_Running,
	"succeeded": ProvisioningState_STATUS_Succeeded,
}

// Metadata pertaining to creation and last modification of the resource.
type SystemData_STATUS struct {
	// CreatedAt: The timestamp of resource creation (UTC).
	CreatedAt *string `json:"createdAt,omitempty"`

	// CreatedBy: The identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty"`

	// CreatedByType: The type of identity that created the resource.
	CreatedByType *SystemData_CreatedByType_STATUS `json:"createdByType,omitempty"`

	// LastModifiedAt: The timestamp of resource last modification (UTC)
	LastModifiedAt *string `json:"lastModifiedAt,omitempty"`

	// LastModifiedBy: The identity that last modified the resource.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`

	// LastModifiedByType: The type of identity that last modified the resource.
	LastModifiedByType *SystemData_LastModifiedByType_STATUS `json:"lastModifiedByType,omitempty"`
}

var _ genruntime.FromARMConverter = &SystemData_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (data *SystemData_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SystemData_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (data *SystemData_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SystemData_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SystemData_STATUS, got %T", armInput)
	}

	// Set property "CreatedAt":
	if typedInput.CreatedAt != nil {
		createdAt := *typedInput.CreatedAt
		data.CreatedAt = &createdAt
	}

	// Set property "CreatedBy":
	if typedInput.CreatedBy != nil {
		createdBy := *typedInput.CreatedBy
		data.CreatedBy = &createdBy
	}

	// Set property "CreatedByType":
	if typedInput.CreatedByType != nil {
		var temp string
		temp = string(*typedInput.CreatedByType)
		createdByType := SystemData_CreatedByType_STATUS(temp)
		data.CreatedByType = &createdByType
	}

	// Set property "LastModifiedAt":
	if typedInput.LastModifiedAt != nil {
		lastModifiedAt := *typedInput.LastModifiedAt
		data.LastModifiedAt = &lastModifiedAt
	}

	// Set property "LastModifiedBy":
	if typedInput.LastModifiedBy != nil {
		lastModifiedBy := *typedInput.LastModifiedBy
		data.LastModifiedBy = &lastModifiedBy
	}

	// Set property "LastModifiedByType":
	if typedInput.LastModifiedByType != nil {
		var temp string
		temp = string(*typedInput.LastModifiedByType)
		lastModifiedByType := SystemData_LastModifiedByType_STATUS(temp)
		data.LastModifiedByType = &lastModifiedByType
	}

	// No error
	return nil
}

// AssignProperties_From_SystemData_STATUS populates our SystemData_STATUS from the provided source SystemData_STATUS
func (data *SystemData_STATUS) AssignProperties_From_SystemData_STATUS(source *storage.SystemData_STATUS) error {

	// CreatedAt
	data.CreatedAt = genruntime.ClonePointerToString(source.CreatedAt)

	// CreatedBy
	data.CreatedBy = genruntime.ClonePointerToString(source.CreatedBy)

	// CreatedByType
	if source.CreatedByType != nil {
		createdByType := *source.CreatedByType
		createdByTypeTemp := genruntime.ToEnum(createdByType, systemData_CreatedByType_STATUS_Values)
		data.CreatedByType = &createdByTypeTemp
	} else {
		data.CreatedByType = nil
	}

	// LastModifiedAt
	data.LastModifiedAt = genruntime.ClonePointerToString(source.LastModifiedAt)

	// LastModifiedBy
	data.LastModifiedBy = genruntime.ClonePointerToString(source.LastModifiedBy)

	// LastModifiedByType
	if source.LastModifiedByType != nil {
		lastModifiedByType := *source.LastModifiedByType
		lastModifiedByTypeTemp := genruntime.ToEnum(lastModifiedByType, systemData_LastModifiedByType_STATUS_Values)
		data.LastModifiedByType = &lastModifiedByTypeTemp
	} else {
		data.LastModifiedByType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SystemData_STATUS populates the provided destination SystemData_STATUS from our SystemData_STATUS
func (data *SystemData_STATUS) AssignProperties_To_SystemData_STATUS(destination *storage.SystemData_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CreatedAt
	destination.CreatedAt = genruntime.ClonePointerToString(data.CreatedAt)

	// CreatedBy
	destination.CreatedBy = genruntime.ClonePointerToString(data.CreatedBy)

	// CreatedByType
	if data.CreatedByType != nil {
		createdByType := string(*data.CreatedByType)
		destination.CreatedByType = &createdByType
	} else {
		destination.CreatedByType = nil
	}

	// LastModifiedAt
	destination.LastModifiedAt = genruntime.ClonePointerToString(data.LastModifiedAt)

	// LastModifiedBy
	destination.LastModifiedBy = genruntime.ClonePointerToString(data.LastModifiedBy)

	// LastModifiedByType
	if data.LastModifiedByType != nil {
		lastModifiedByType := string(*data.LastModifiedByType)
		destination.LastModifiedByType = &lastModifiedByType
	} else {
		destination.LastModifiedByType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Represents a tenant ID that is trusted by the cluster.
type TrustedExternalTenant struct {
	// Value: GUID representing an external tenant.
	Value *string `json:"value,omitempty"`
}

var _ genruntime.ARMTransformer = &TrustedExternalTenant{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (tenant *TrustedExternalTenant) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if tenant == nil {
		return nil, nil
	}
	result := &arm.TrustedExternalTenant{}

	// Set property "Value":
	if tenant.Value != nil {
		value := *tenant.Value
		result.Value = &value
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (tenant *TrustedExternalTenant) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.TrustedExternalTenant{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (tenant *TrustedExternalTenant) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.TrustedExternalTenant)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.TrustedExternalTenant, got %T", armInput)
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		tenant.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_TrustedExternalTenant populates our TrustedExternalTenant from the provided source TrustedExternalTenant
func (tenant *TrustedExternalTenant) AssignProperties_From_TrustedExternalTenant(source *storage.TrustedExternalTenant) error {

	// Value
	tenant.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_TrustedExternalTenant populates the provided destination TrustedExternalTenant from our TrustedExternalTenant
func (tenant *TrustedExternalTenant) AssignProperties_To_TrustedExternalTenant(destination *storage.TrustedExternalTenant) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Value
	destination.Value = genruntime.ClonePointerToString(tenant.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_TrustedExternalTenant_STATUS populates our TrustedExternalTenant from the provided source TrustedExternalTenant_STATUS
func (tenant *TrustedExternalTenant) Initialize_From_TrustedExternalTenant_STATUS(source *TrustedExternalTenant_STATUS) error {

	// Value
	tenant.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// Represents a tenant ID that is trusted by the cluster.
type TrustedExternalTenant_STATUS struct {
	// Value: GUID representing an external tenant.
	Value *string `json:"value,omitempty"`
}

var _ genruntime.FromARMConverter = &TrustedExternalTenant_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (tenant *TrustedExternalTenant_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.TrustedExternalTenant_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (tenant *TrustedExternalTenant_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.TrustedExternalTenant_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.TrustedExternalTenant_STATUS, got %T", armInput)
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		tenant.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_TrustedExternalTenant_STATUS populates our TrustedExternalTenant_STATUS from the provided source TrustedExternalTenant_STATUS
func (tenant *TrustedExternalTenant_STATUS) AssignProperties_From_TrustedExternalTenant_STATUS(source *storage.TrustedExternalTenant_STATUS) error {

	// Value
	tenant.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_TrustedExternalTenant_STATUS populates the provided destination TrustedExternalTenant_STATUS from our TrustedExternalTenant_STATUS
func (tenant *TrustedExternalTenant_STATUS) AssignProperties_To_TrustedExternalTenant_STATUS(destination *storage.TrustedExternalTenant_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Value
	destination.Value = genruntime.ClonePointerToString(tenant.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// A class that contains virtual network definition.
type VirtualNetworkConfiguration struct {
	// +kubebuilder:validation:Required
	// DataManagementPublicIpReference: Data management's service public IP address resource id.
	DataManagementPublicIpReference *genruntime.ResourceReference `armReference:"DataManagementPublicIpId" json:"dataManagementPublicIpReference,omitempty"`

	// +kubebuilder:validation:Required
	// EnginePublicIpReference: Engine service's public IP address resource id.
	EnginePublicIpReference *genruntime.ResourceReference `armReference:"EnginePublicIpId" json:"enginePublicIpReference,omitempty"`

	// State: When enabled, the cluster is deployed into the configured subnet, when disabled it will be removed from the
	// subnet.
	State *VirtualNetworkConfiguration_State `json:"state,omitempty"`

	// +kubebuilder:validation:Required
	// SubnetReference: The subnet resource id.
	SubnetReference *genruntime.ResourceReference `armReference:"SubnetId" json:"subnetReference,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualNetworkConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *VirtualNetworkConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &arm.VirtualNetworkConfiguration{}

	// Set property "DataManagementPublicIpId":
	if configuration.DataManagementPublicIpReference != nil {
		dataManagementPublicIpReferenceARMID, err := resolved.ResolvedReferences.Lookup(*configuration.DataManagementPublicIpReference)
		if err != nil {
			return nil, err
		}
		dataManagementPublicIpReference := dataManagementPublicIpReferenceARMID
		result.DataManagementPublicIpId = &dataManagementPublicIpReference
	}

	// Set property "EnginePublicIpId":
	if configuration.EnginePublicIpReference != nil {
		enginePublicIpReferenceARMID, err := resolved.ResolvedReferences.Lookup(*configuration.EnginePublicIpReference)
		if err != nil {
			return nil, err
		}
		enginePublicIpReference := enginePublicIpReferenceARMID
		result.EnginePublicIpId = &enginePublicIpReference
	}

	// Set property "State":
	if configuration.State != nil {
		var temp string
		temp = string(*configuration.State)
		state := arm.VirtualNetworkConfiguration_State(temp)
		result.State = &state
	}

	// Set property "SubnetId":
	if configuration.SubnetReference != nil {
		subnetReferenceARMID, err := resolved.ResolvedReferences.Lookup(*configuration.SubnetReference)
		if err != nil {
			return nil, err
		}
		subnetReference := subnetReferenceARMID
		result.SubnetId = &subnetReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *VirtualNetworkConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualNetworkConfiguration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *VirtualNetworkConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualNetworkConfiguration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualNetworkConfiguration, got %T", armInput)
	}

	// no assignment for property "DataManagementPublicIpReference"

	// no assignment for property "EnginePublicIpReference"

	// Set property "State":
	if typedInput.State != nil {
		var temp string
		temp = string(*typedInput.State)
		state := VirtualNetworkConfiguration_State(temp)
		configuration.State = &state
	}

	// no assignment for property "SubnetReference"

	// No error
	return nil
}

// AssignProperties_From_VirtualNetworkConfiguration populates our VirtualNetworkConfiguration from the provided source VirtualNetworkConfiguration
func (configuration *VirtualNetworkConfiguration) AssignProperties_From_VirtualNetworkConfiguration(source *storage.VirtualNetworkConfiguration) error {

	// DataManagementPublicIpReference
	if source.DataManagementPublicIpReference != nil {
		dataManagementPublicIpReference := source.DataManagementPublicIpReference.Copy()
		configuration.DataManagementPublicIpReference = &dataManagementPublicIpReference
	} else {
		configuration.DataManagementPublicIpReference = nil
	}

	// EnginePublicIpReference
	if source.EnginePublicIpReference != nil {
		enginePublicIpReference := source.EnginePublicIpReference.Copy()
		configuration.EnginePublicIpReference = &enginePublicIpReference
	} else {
		configuration.EnginePublicIpReference = nil
	}

	// State
	if source.State != nil {
		state := *source.State
		stateTemp := genruntime.ToEnum(state, virtualNetworkConfiguration_State_Values)
		configuration.State = &stateTemp
	} else {
		configuration.State = nil
	}

	// SubnetReference
	if source.SubnetReference != nil {
		subnetReference := source.SubnetReference.Copy()
		configuration.SubnetReference = &subnetReference
	} else {
		configuration.SubnetReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualNetworkConfiguration populates the provided destination VirtualNetworkConfiguration from our VirtualNetworkConfiguration
func (configuration *VirtualNetworkConfiguration) AssignProperties_To_VirtualNetworkConfiguration(destination *storage.VirtualNetworkConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DataManagementPublicIpReference
	if configuration.DataManagementPublicIpReference != nil {
		dataManagementPublicIpReference := configuration.DataManagementPublicIpReference.Copy()
		destination.DataManagementPublicIpReference = &dataManagementPublicIpReference
	} else {
		destination.DataManagementPublicIpReference = nil
	}

	// EnginePublicIpReference
	if configuration.EnginePublicIpReference != nil {
		enginePublicIpReference := configuration.EnginePublicIpReference.Copy()
		destination.EnginePublicIpReference = &enginePublicIpReference
	} else {
		destination.EnginePublicIpReference = nil
	}

	// State
	if configuration.State != nil {
		state := string(*configuration.State)
		destination.State = &state
	} else {
		destination.State = nil
	}

	// SubnetReference
	if configuration.SubnetReference != nil {
		subnetReference := configuration.SubnetReference.Copy()
		destination.SubnetReference = &subnetReference
	} else {
		destination.SubnetReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_VirtualNetworkConfiguration_STATUS populates our VirtualNetworkConfiguration from the provided source VirtualNetworkConfiguration_STATUS
func (configuration *VirtualNetworkConfiguration) Initialize_From_VirtualNetworkConfiguration_STATUS(source *VirtualNetworkConfiguration_STATUS) error {

	// DataManagementPublicIpReference
	if source.DataManagementPublicIpId != nil {
		dataManagementPublicIpReference := genruntime.CreateResourceReferenceFromARMID(*source.DataManagementPublicIpId)
		configuration.DataManagementPublicIpReference = &dataManagementPublicIpReference
	} else {
		configuration.DataManagementPublicIpReference = nil
	}

	// EnginePublicIpReference
	if source.EnginePublicIpId != nil {
		enginePublicIpReference := genruntime.CreateResourceReferenceFromARMID(*source.EnginePublicIpId)
		configuration.EnginePublicIpReference = &enginePublicIpReference
	} else {
		configuration.EnginePublicIpReference = nil
	}

	// State
	if source.State != nil {
		state := genruntime.ToEnum(string(*source.State), virtualNetworkConfiguration_State_Values)
		configuration.State = &state
	} else {
		configuration.State = nil
	}

	// SubnetReference
	if source.SubnetId != nil {
		subnetReference := genruntime.CreateResourceReferenceFromARMID(*source.SubnetId)
		configuration.SubnetReference = &subnetReference
	} else {
		configuration.SubnetReference = nil
	}

	// No error
	return nil
}

// A class that contains virtual network definition.
type VirtualNetworkConfiguration_STATUS struct {
	// DataManagementPublicIpId: Data management's service public IP address resource id.
	DataManagementPublicIpId *string `json:"dataManagementPublicIpId,omitempty"`

	// EnginePublicIpId: Engine service's public IP address resource id.
	EnginePublicIpId *string `json:"enginePublicIpId,omitempty"`

	// State: When enabled, the cluster is deployed into the configured subnet, when disabled it will be removed from the
	// subnet.
	State *VirtualNetworkConfiguration_State_STATUS `json:"state,omitempty"`

	// SubnetId: The subnet resource id.
	SubnetId *string `json:"subnetId,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualNetworkConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *VirtualNetworkConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualNetworkConfiguration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *VirtualNetworkConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualNetworkConfiguration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualNetworkConfiguration_STATUS, got %T", armInput)
	}

	// Set property "DataManagementPublicIpId":
	if typedInput.DataManagementPublicIpId != nil {
		dataManagementPublicIpId := *typedInput.DataManagementPublicIpId
		configuration.DataManagementPublicIpId = &dataManagementPublicIpId
	}

	// Set property "EnginePublicIpId":
	if typedInput.EnginePublicIpId != nil {
		enginePublicIpId := *typedInput.EnginePublicIpId
		configuration.EnginePublicIpId = &enginePublicIpId
	}

	// Set property "State":
	if typedInput.State != nil {
		var temp string
		temp = string(*typedInput.State)
		state := VirtualNetworkConfiguration_State_STATUS(temp)
		configuration.State = &state
	}

	// Set property "SubnetId":
	if typedInput.SubnetId != nil {
		subnetId := *typedInput.SubnetId
		configuration.SubnetId = &subnetId
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualNetworkConfiguration_STATUS populates our VirtualNetworkConfiguration_STATUS from the provided source VirtualNetworkConfiguration_STATUS
func (configuration *VirtualNetworkConfiguration_STATUS) AssignProperties_From_VirtualNetworkConfiguration_STATUS(source *storage.VirtualNetworkConfiguration_STATUS) error {

	// DataManagementPublicIpId
	configuration.DataManagementPublicIpId = genruntime.ClonePointerToString(source.DataManagementPublicIpId)

	// EnginePublicIpId
	configuration.EnginePublicIpId = genruntime.ClonePointerToString(source.EnginePublicIpId)

	// State
	if source.State != nil {
		state := *source.State
		stateTemp := genruntime.ToEnum(state, virtualNetworkConfiguration_State_STATUS_Values)
		configuration.State = &stateTemp
	} else {
		configuration.State = nil
	}

	// SubnetId
	configuration.SubnetId = genruntime.ClonePointerToString(source.SubnetId)

	// No error
	return nil
}

// AssignProperties_To_VirtualNetworkConfiguration_STATUS populates the provided destination VirtualNetworkConfiguration_STATUS from our VirtualNetworkConfiguration_STATUS
func (configuration *VirtualNetworkConfiguration_STATUS) AssignProperties_To_VirtualNetworkConfiguration_STATUS(destination *storage.VirtualNetworkConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DataManagementPublicIpId
	destination.DataManagementPublicIpId = genruntime.ClonePointerToString(configuration.DataManagementPublicIpId)

	// EnginePublicIpId
	destination.EnginePublicIpId = genruntime.ClonePointerToString(configuration.EnginePublicIpId)

	// State
	if configuration.State != nil {
		state := string(*configuration.State)
		destination.State = &state
	} else {
		destination.State = nil
	}

	// SubnetId
	destination.SubnetId = genruntime.ClonePointerToString(configuration.SubnetId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Dev(No SLA)_Standard_D11_v2","Dev(No SLA)_Standard_E2a_v4","Standard_D11_v2","Standard_D12_v2","Standard_D13_v2","Standard_D14_v2","Standard_D16d_v5","Standard_D32d_v4","Standard_D32d_v5","Standard_DS13_v2+1TB_PS","Standard_DS13_v2+2TB_PS","Standard_DS14_v2+3TB_PS","Standard_DS14_v2+4TB_PS","Standard_E16a_v4","Standard_E16ads_v5","Standard_E16as_v4+3TB_PS","Standard_E16as_v4+4TB_PS","Standard_E16as_v5+3TB_PS","Standard_E16as_v5+4TB_PS","Standard_E16d_v4","Standard_E16d_v5","Standard_E16s_v4+3TB_PS","Standard_E16s_v4+4TB_PS","Standard_E16s_v5+3TB_PS","Standard_E16s_v5+4TB_PS","Standard_E2a_v4","Standard_E2ads_v5","Standard_E2d_v4","Standard_E2d_v5","Standard_E4a_v4","Standard_E4ads_v5","Standard_E4d_v4","Standard_E4d_v5","Standard_E64i_v3","Standard_E80ids_v4","Standard_E8a_v4","Standard_E8ads_v5","Standard_E8as_v4+1TB_PS","Standard_E8as_v4+2TB_PS","Standard_E8as_v5+1TB_PS","Standard_E8as_v5+2TB_PS","Standard_E8d_v4","Standard_E8d_v5","Standard_E8s_v4+1TB_PS","Standard_E8s_v4+2TB_PS","Standard_E8s_v5+1TB_PS","Standard_E8s_v5+2TB_PS","Standard_EC16ads_v5","Standard_EC16as_v5+3TB_PS","Standard_EC16as_v5+4TB_PS","Standard_EC8ads_v5","Standard_EC8as_v5+1TB_PS","Standard_EC8as_v5+2TB_PS","Standard_L16as_v3","Standard_L16s","Standard_L16s_v2","Standard_L16s_v3","Standard_L32as_v3","Standard_L32s_v3","Standard_L4s","Standard_L8as_v3","Standard_L8s","Standard_L8s_v2","Standard_L8s_v3"}
type AzureSku_Name string

const (
	AzureSku_Name_DevNoSLA_Standard_D11_V2 = AzureSku_Name("Dev(No SLA)_Standard_D11_v2")
	AzureSku_Name_DevNoSLA_Standard_E2A_V4 = AzureSku_Name("Dev(No SLA)_Standard_E2a_v4")
	AzureSku_Name_Standard_D11_V2          = AzureSku_Name("Standard_D11_v2")
	AzureSku_Name_Standard_D12_V2          = AzureSku_Name("Standard_D12_v2")
	AzureSku_Name_Standard_D13_V2          = AzureSku_Name("Standard_D13_v2")
	AzureSku_Name_Standard_D14_V2          = AzureSku_Name("Standard_D14_v2")
	AzureSku_Name_Standard_D16D_V5         = AzureSku_Name("Standard_D16d_v5")
	AzureSku_Name_Standard_D32D_V4         = AzureSku_Name("Standard_D32d_v4")
	AzureSku_Name_Standard_D32D_V5         = AzureSku_Name("Standard_D32d_v5")
	AzureSku_Name_Standard_DS13_V21TB_PS   = AzureSku_Name("Standard_DS13_v2+1TB_PS")
	AzureSku_Name_Standard_DS13_V22TB_PS   = AzureSku_Name("Standard_DS13_v2+2TB_PS")
	AzureSku_Name_Standard_DS14_V23TB_PS   = AzureSku_Name("Standard_DS14_v2+3TB_PS")
	AzureSku_Name_Standard_DS14_V24TB_PS   = AzureSku_Name("Standard_DS14_v2+4TB_PS")
	AzureSku_Name_Standard_E16A_V4         = AzureSku_Name("Standard_E16a_v4")
	AzureSku_Name_Standard_E16Ads_V5       = AzureSku_Name("Standard_E16ads_v5")
	AzureSku_Name_Standard_E16As_V43TB_PS  = AzureSku_Name("Standard_E16as_v4+3TB_PS")
	AzureSku_Name_Standard_E16As_V44TB_PS  = AzureSku_Name("Standard_E16as_v4+4TB_PS")
	AzureSku_Name_Standard_E16As_V53TB_PS  = AzureSku_Name("Standard_E16as_v5+3TB_PS")
	AzureSku_Name_Standard_E16As_V54TB_PS  = AzureSku_Name("Standard_E16as_v5+4TB_PS")
	AzureSku_Name_Standard_E16D_V4         = AzureSku_Name("Standard_E16d_v4")
	AzureSku_Name_Standard_E16D_V5         = AzureSku_Name("Standard_E16d_v5")
	AzureSku_Name_Standard_E16S_V43TB_PS   = AzureSku_Name("Standard_E16s_v4+3TB_PS")
	AzureSku_Name_Standard_E16S_V44TB_PS   = AzureSku_Name("Standard_E16s_v4+4TB_PS")
	AzureSku_Name_Standard_E16S_V53TB_PS   = AzureSku_Name("Standard_E16s_v5+3TB_PS")
	AzureSku_Name_Standard_E16S_V54TB_PS   = AzureSku_Name("Standard_E16s_v5+4TB_PS")
	AzureSku_Name_Standard_E2A_V4          = AzureSku_Name("Standard_E2a_v4")
	AzureSku_Name_Standard_E2Ads_V5        = AzureSku_Name("Standard_E2ads_v5")
	AzureSku_Name_Standard_E2D_V4          = AzureSku_Name("Standard_E2d_v4")
	AzureSku_Name_Standard_E2D_V5          = AzureSku_Name("Standard_E2d_v5")
	AzureSku_Name_Standard_E4A_V4          = AzureSku_Name("Standard_E4a_v4")
	AzureSku_Name_Standard_E4Ads_V5        = AzureSku_Name("Standard_E4ads_v5")
	AzureSku_Name_Standard_E4D_V4          = AzureSku_Name("Standard_E4d_v4")
	AzureSku_Name_Standard_E4D_V5          = AzureSku_Name("Standard_E4d_v5")
	AzureSku_Name_Standard_E64I_V3         = AzureSku_Name("Standard_E64i_v3")
	AzureSku_Name_Standard_E80Ids_V4       = AzureSku_Name("Standard_E80ids_v4")
	AzureSku_Name_Standard_E8A_V4          = AzureSku_Name("Standard_E8a_v4")
	AzureSku_Name_Standard_E8Ads_V5        = AzureSku_Name("Standard_E8ads_v5")
	AzureSku_Name_Standard_E8As_V41TB_PS   = AzureSku_Name("Standard_E8as_v4+1TB_PS")
	AzureSku_Name_Standard_E8As_V42TB_PS   = AzureSku_Name("Standard_E8as_v4+2TB_PS")
	AzureSku_Name_Standard_E8As_V51TB_PS   = AzureSku_Name("Standard_E8as_v5+1TB_PS")
	AzureSku_Name_Standard_E8As_V52TB_PS   = AzureSku_Name("Standard_E8as_v5+2TB_PS")
	AzureSku_Name_Standard_E8D_V4          = AzureSku_Name("Standard_E8d_v4")
	AzureSku_Name_Standard_E8D_V5          = AzureSku_Name("Standard_E8d_v5")
	AzureSku_Name_Standard_E8S_V41TB_PS    = AzureSku_Name("Standard_E8s_v4+1TB_PS")
	AzureSku_Name_Standard_E8S_V42TB_PS    = AzureSku_Name("Standard_E8s_v4+2TB_PS")
	AzureSku_Name_Standard_E8S_V51TB_PS    = AzureSku_Name("Standard_E8s_v5+1TB_PS")
	AzureSku_Name_Standard_E8S_V52TB_PS    = AzureSku_Name("Standard_E8s_v5+2TB_PS")
	AzureSku_Name_Standard_EC16Ads_V5      = AzureSku_Name("Standard_EC16ads_v5")
	AzureSku_Name_Standard_EC16As_V53TB_PS = AzureSku_Name("Standard_EC16as_v5+3TB_PS")
	AzureSku_Name_Standard_EC16As_V54TB_PS = AzureSku_Name("Standard_EC16as_v5+4TB_PS")
	AzureSku_Name_Standard_EC8Ads_V5       = AzureSku_Name("Standard_EC8ads_v5")
	AzureSku_Name_Standard_EC8As_V51TB_PS  = AzureSku_Name("Standard_EC8as_v5+1TB_PS")
	AzureSku_Name_Standard_EC8As_V52TB_PS  = AzureSku_Name("Standard_EC8as_v5+2TB_PS")
	AzureSku_Name_Standard_L16As_V3        = AzureSku_Name("Standard_L16as_v3")
	AzureSku_Name_Standard_L16S            = AzureSku_Name("Standard_L16s")
	AzureSku_Name_Standard_L16S_V2         = AzureSku_Name("Standard_L16s_v2")
	AzureSku_Name_Standard_L16S_V3         = AzureSku_Name("Standard_L16s_v3")
	AzureSku_Name_Standard_L32As_V3        = AzureSku_Name("Standard_L32as_v3")
	AzureSku_Name_Standard_L32S_V3         = AzureSku_Name("Standard_L32s_v3")
	AzureSku_Name_Standard_L4S             = AzureSku_Name("Standard_L4s")
	AzureSku_Name_Standard_L8As_V3         = AzureSku_Name("Standard_L8as_v3")
	AzureSku_Name_Standard_L8S             = AzureSku_Name("Standard_L8s")
	AzureSku_Name_Standard_L8S_V2          = AzureSku_Name("Standard_L8s_v2")
	AzureSku_Name_Standard_L8S_V3          = AzureSku_Name("Standard_L8s_v3")
)

// Mapping from string to AzureSku_Name
var azureSku_Name_Values = map[string]AzureSku_Name{
	"dev(no sla)_standard_d11_v2": AzureSku_Name_DevNoSLA_Standard_D11_V2,
	"dev(no sla)_standard_e2a_v4": AzureSku_Name_DevNoSLA_Standard_E2A_V4,
	"standard_d11_v2":             AzureSku_Name_Standard_D11_V2,
	"standard_d12_v2":             AzureSku_Name_Standard_D12_V2,
	"standard_d13_v2":             AzureSku_Name_Standard_D13_V2,
	"standard_d14_v2":             AzureSku_Name_Standard_D14_V2,
	"standard_d16d_v5":            AzureSku_Name_Standard_D16D_V5,
	"standard_d32d_v4":            AzureSku_Name_Standard_D32D_V4,
	"standard_d32d_v5":            AzureSku_Name_Standard_D32D_V5,
	"standard_ds13_v2+1tb_ps":     AzureSku_Name_Standard_DS13_V21TB_PS,
	"standard_ds13_v2+2tb_ps":     AzureSku_Name_Standard_DS13_V22TB_PS,
	"standard_ds14_v2+3tb_ps":     AzureSku_Name_Standard_DS14_V23TB_PS,
	"standard_ds14_v2+4tb_ps":     AzureSku_Name_Standard_DS14_V24TB_PS,
	"standard_e16a_v4":            AzureSku_Name_Standard_E16A_V4,
	"standard_e16ads_v5":          AzureSku_Name_Standard_E16Ads_V5,
	"standard_e16as_v4+3tb_ps":    AzureSku_Name_Standard_E16As_V43TB_PS,
	"standard_e16as_v4+4tb_ps":    AzureSku_Name_Standard_E16As_V44TB_PS,
	"standard_e16as_v5+3tb_ps":    AzureSku_Name_Standard_E16As_V53TB_PS,
	"standard_e16as_v5+4tb_ps":    AzureSku_Name_Standard_E16As_V54TB_PS,
	"standard_e16d_v4":            AzureSku_Name_Standard_E16D_V4,
	"standard_e16d_v5":            AzureSku_Name_Standard_E16D_V5,
	"standard_e16s_v4+3tb_ps":     AzureSku_Name_Standard_E16S_V43TB_PS,
	"standard_e16s_v4+4tb_ps":     AzureSku_Name_Standard_E16S_V44TB_PS,
	"standard_e16s_v5+3tb_ps":     AzureSku_Name_Standard_E16S_V53TB_PS,
	"standard_e16s_v5+4tb_ps":     AzureSku_Name_Standard_E16S_V54TB_PS,
	"standard_e2a_v4":             AzureSku_Name_Standard_E2A_V4,
	"standard_e2ads_v5":           AzureSku_Name_Standard_E2Ads_V5,
	"standard_e2d_v4":             AzureSku_Name_Standard_E2D_V4,
	"standard_e2d_v5":             AzureSku_Name_Standard_E2D_V5,
	"standard_e4a_v4":             AzureSku_Name_Standard_E4A_V4,
	"standard_e4ads_v5":           AzureSku_Name_Standard_E4Ads_V5,
	"standard_e4d_v4":             AzureSku_Name_Standard_E4D_V4,
	"standard_e4d_v5":             AzureSku_Name_Standard_E4D_V5,
	"standard_e64i_v3":            AzureSku_Name_Standard_E64I_V3,
	"standard_e80ids_v4":          AzureSku_Name_Standard_E80Ids_V4,
	"standard_e8a_v4":             AzureSku_Name_Standard_E8A_V4,
	"standard_e8ads_v5":           AzureSku_Name_Standard_E8Ads_V5,
	"standard_e8as_v4+1tb_ps":     AzureSku_Name_Standard_E8As_V41TB_PS,
	"standard_e8as_v4+2tb_ps":     AzureSku_Name_Standard_E8As_V42TB_PS,
	"standard_e8as_v5+1tb_ps":     AzureSku_Name_Standard_E8As_V51TB_PS,
	"standard_e8as_v5+2tb_ps":     AzureSku_Name_Standard_E8As_V52TB_PS,
	"standard_e8d_v4":             AzureSku_Name_Standard_E8D_V4,
	"standard_e8d_v5":             AzureSku_Name_Standard_E8D_V5,
	"standard_e8s_v4+1tb_ps":      AzureSku_Name_Standard_E8S_V41TB_PS,
	"standard_e8s_v4+2tb_ps":      AzureSku_Name_Standard_E8S_V42TB_PS,
	"standard_e8s_v5+1tb_ps":      AzureSku_Name_Standard_E8S_V51TB_PS,
	"standard_e8s_v5+2tb_ps":      AzureSku_Name_Standard_E8S_V52TB_PS,
	"standard_ec16ads_v5":         AzureSku_Name_Standard_EC16Ads_V5,
	"standard_ec16as_v5+3tb_ps":   AzureSku_Name_Standard_EC16As_V53TB_PS,
	"standard_ec16as_v5+4tb_ps":   AzureSku_Name_Standard_EC16As_V54TB_PS,
	"standard_ec8ads_v5":          AzureSku_Name_Standard_EC8Ads_V5,
	"standard_ec8as_v5+1tb_ps":    AzureSku_Name_Standard_EC8As_V51TB_PS,
	"standard_ec8as_v5+2tb_ps":    AzureSku_Name_Standard_EC8As_V52TB_PS,
	"standard_l16as_v3":           AzureSku_Name_Standard_L16As_V3,
	"standard_l16s":               AzureSku_Name_Standard_L16S,
	"standard_l16s_v2":            AzureSku_Name_Standard_L16S_V2,
	"standard_l16s_v3":            AzureSku_Name_Standard_L16S_V3,
	"standard_l32as_v3":           AzureSku_Name_Standard_L32As_V3,
	"standard_l32s_v3":            AzureSku_Name_Standard_L32S_V3,
	"standard_l4s":                AzureSku_Name_Standard_L4S,
	"standard_l8as_v3":            AzureSku_Name_Standard_L8As_V3,
	"standard_l8s":                AzureSku_Name_Standard_L8S,
	"standard_l8s_v2":             AzureSku_Name_Standard_L8S_V2,
	"standard_l8s_v3":             AzureSku_Name_Standard_L8S_V3,
}

type AzureSku_Name_STATUS string

const (
	AzureSku_Name_STATUS_DevNoSLA_Standard_D11_V2 = AzureSku_Name_STATUS("Dev(No SLA)_Standard_D11_v2")
	AzureSku_Name_STATUS_DevNoSLA_Standard_E2A_V4 = AzureSku_Name_STATUS("Dev(No SLA)_Standard_E2a_v4")
	AzureSku_Name_STATUS_Standard_D11_V2          = AzureSku_Name_STATUS("Standard_D11_v2")
	AzureSku_Name_STATUS_Standard_D12_V2          = AzureSku_Name_STATUS("Standard_D12_v2")
	AzureSku_Name_STATUS_Standard_D13_V2          = AzureSku_Name_STATUS("Standard_D13_v2")
	AzureSku_Name_STATUS_Standard_D14_V2          = AzureSku_Name_STATUS("Standard_D14_v2")
	AzureSku_Name_STATUS_Standard_D16D_V5         = AzureSku_Name_STATUS("Standard_D16d_v5")
	AzureSku_Name_STATUS_Standard_D32D_V4         = AzureSku_Name_STATUS("Standard_D32d_v4")
	AzureSku_Name_STATUS_Standard_D32D_V5         = AzureSku_Name_STATUS("Standard_D32d_v5")
	AzureSku_Name_STATUS_Standard_DS13_V21TB_PS   = AzureSku_Name_STATUS("Standard_DS13_v2+1TB_PS")
	AzureSku_Name_STATUS_Standard_DS13_V22TB_PS   = AzureSku_Name_STATUS("Standard_DS13_v2+2TB_PS")
	AzureSku_Name_STATUS_Standard_DS14_V23TB_PS   = AzureSku_Name_STATUS("Standard_DS14_v2+3TB_PS")
	AzureSku_Name_STATUS_Standard_DS14_V24TB_PS   = AzureSku_Name_STATUS("Standard_DS14_v2+4TB_PS")
	AzureSku_Name_STATUS_Standard_E16A_V4         = AzureSku_Name_STATUS("Standard_E16a_v4")
	AzureSku_Name_STATUS_Standard_E16Ads_V5       = AzureSku_Name_STATUS("Standard_E16ads_v5")
	AzureSku_Name_STATUS_Standard_E16As_V43TB_PS  = AzureSku_Name_STATUS("Standard_E16as_v4+3TB_PS")
	AzureSku_Name_STATUS_Standard_E16As_V44TB_PS  = AzureSku_Name_STATUS("Standard_E16as_v4+4TB_PS")
	AzureSku_Name_STATUS_Standard_E16As_V53TB_PS  = AzureSku_Name_STATUS("Standard_E16as_v5+3TB_PS")
	AzureSku_Name_STATUS_Standard_E16As_V54TB_PS  = AzureSku_Name_STATUS("Standard_E16as_v5+4TB_PS")
	AzureSku_Name_STATUS_Standard_E16D_V4         = AzureSku_Name_STATUS("Standard_E16d_v4")
	AzureSku_Name_STATUS_Standard_E16D_V5         = AzureSku_Name_STATUS("Standard_E16d_v5")
	AzureSku_Name_STATUS_Standard_E16S_V43TB_PS   = AzureSku_Name_STATUS("Standard_E16s_v4+3TB_PS")
	AzureSku_Name_STATUS_Standard_E16S_V44TB_PS   = AzureSku_Name_STATUS("Standard_E16s_v4+4TB_PS")
	AzureSku_Name_STATUS_Standard_E16S_V53TB_PS   = AzureSku_Name_STATUS("Standard_E16s_v5+3TB_PS")
	AzureSku_Name_STATUS_Standard_E16S_V54TB_PS   = AzureSku_Name_STATUS("Standard_E16s_v5+4TB_PS")
	AzureSku_Name_STATUS_Standard_E2A_V4          = AzureSku_Name_STATUS("Standard_E2a_v4")
	AzureSku_Name_STATUS_Standard_E2Ads_V5        = AzureSku_Name_STATUS("Standard_E2ads_v5")
	AzureSku_Name_STATUS_Standard_E2D_V4          = AzureSku_Name_STATUS("Standard_E2d_v4")
	AzureSku_Name_STATUS_Standard_E2D_V5          = AzureSku_Name_STATUS("Standard_E2d_v5")
	AzureSku_Name_STATUS_Standard_E4A_V4          = AzureSku_Name_STATUS("Standard_E4a_v4")
	AzureSku_Name_STATUS_Standard_E4Ads_V5        = AzureSku_Name_STATUS("Standard_E4ads_v5")
	AzureSku_Name_STATUS_Standard_E4D_V4          = AzureSku_Name_STATUS("Standard_E4d_v4")
	AzureSku_Name_STATUS_Standard_E4D_V5          = AzureSku_Name_STATUS("Standard_E4d_v5")
	AzureSku_Name_STATUS_Standard_E64I_V3         = AzureSku_Name_STATUS("Standard_E64i_v3")
	AzureSku_Name_STATUS_Standard_E80Ids_V4       = AzureSku_Name_STATUS("Standard_E80ids_v4")
	AzureSku_Name_STATUS_Standard_E8A_V4          = AzureSku_Name_STATUS("Standard_E8a_v4")
	AzureSku_Name_STATUS_Standard_E8Ads_V5        = AzureSku_Name_STATUS("Standard_E8ads_v5")
	AzureSku_Name_STATUS_Standard_E8As_V41TB_PS   = AzureSku_Name_STATUS("Standard_E8as_v4+1TB_PS")
	AzureSku_Name_STATUS_Standard_E8As_V42TB_PS   = AzureSku_Name_STATUS("Standard_E8as_v4+2TB_PS")
	AzureSku_Name_STATUS_Standard_E8As_V51TB_PS   = AzureSku_Name_STATUS("Standard_E8as_v5+1TB_PS")
	AzureSku_Name_STATUS_Standard_E8As_V52TB_PS   = AzureSku_Name_STATUS("Standard_E8as_v5+2TB_PS")
	AzureSku_Name_STATUS_Standard_E8D_V4          = AzureSku_Name_STATUS("Standard_E8d_v4")
	AzureSku_Name_STATUS_Standard_E8D_V5          = AzureSku_Name_STATUS("Standard_E8d_v5")
	AzureSku_Name_STATUS_Standard_E8S_V41TB_PS    = AzureSku_Name_STATUS("Standard_E8s_v4+1TB_PS")
	AzureSku_Name_STATUS_Standard_E8S_V42TB_PS    = AzureSku_Name_STATUS("Standard_E8s_v4+2TB_PS")
	AzureSku_Name_STATUS_Standard_E8S_V51TB_PS    = AzureSku_Name_STATUS("Standard_E8s_v5+1TB_PS")
	AzureSku_Name_STATUS_Standard_E8S_V52TB_PS    = AzureSku_Name_STATUS("Standard_E8s_v5+2TB_PS")
	AzureSku_Name_STATUS_Standard_EC16Ads_V5      = AzureSku_Name_STATUS("Standard_EC16ads_v5")
	AzureSku_Name_STATUS_Standard_EC16As_V53TB_PS = AzureSku_Name_STATUS("Standard_EC16as_v5+3TB_PS")
	AzureSku_Name_STATUS_Standard_EC16As_V54TB_PS = AzureSku_Name_STATUS("Standard_EC16as_v5+4TB_PS")
	AzureSku_Name_STATUS_Standard_EC8Ads_V5       = AzureSku_Name_STATUS("Standard_EC8ads_v5")
	AzureSku_Name_STATUS_Standard_EC8As_V51TB_PS  = AzureSku_Name_STATUS("Standard_EC8as_v5+1TB_PS")
	AzureSku_Name_STATUS_Standard_EC8As_V52TB_PS  = AzureSku_Name_STATUS("Standard_EC8as_v5+2TB_PS")
	AzureSku_Name_STATUS_Standard_L16As_V3        = AzureSku_Name_STATUS("Standard_L16as_v3")
	AzureSku_Name_STATUS_Standard_L16S            = AzureSku_Name_STATUS("Standard_L16s")
	AzureSku_Name_STATUS_Standard_L16S_V2         = AzureSku_Name_STATUS("Standard_L16s_v2")
	AzureSku_Name_STATUS_Standard_L16S_V3         = AzureSku_Name_STATUS("Standard_L16s_v3")
	AzureSku_Name_STATUS_Standard_L32As_V3        = AzureSku_Name_STATUS("Standard_L32as_v3")
	AzureSku_Name_STATUS_Standard_L32S_V3         = AzureSku_Name_STATUS("Standard_L32s_v3")
	AzureSku_Name_STATUS_Standard_L4S             = AzureSku_Name_STATUS("Standard_L4s")
	AzureSku_Name_STATUS_Standard_L8As_V3         = AzureSku_Name_STATUS("Standard_L8as_v3")
	AzureSku_Name_STATUS_Standard_L8S             = AzureSku_Name_STATUS("Standard_L8s")
	AzureSku_Name_STATUS_Standard_L8S_V2          = AzureSku_Name_STATUS("Standard_L8s_v2")
	AzureSku_Name_STATUS_Standard_L8S_V3          = AzureSku_Name_STATUS("Standard_L8s_v3")
)

// Mapping from string to AzureSku_Name_STATUS
var azureSku_Name_STATUS_Values = map[string]AzureSku_Name_STATUS{
	"dev(no sla)_standard_d11_v2": AzureSku_Name_STATUS_DevNoSLA_Standard_D11_V2,
	"dev(no sla)_standard_e2a_v4": AzureSku_Name_STATUS_DevNoSLA_Standard_E2A_V4,
	"standard_d11_v2":             AzureSku_Name_STATUS_Standard_D11_V2,
	"standard_d12_v2":             AzureSku_Name_STATUS_Standard_D12_V2,
	"standard_d13_v2":             AzureSku_Name_STATUS_Standard_D13_V2,
	"standard_d14_v2":             AzureSku_Name_STATUS_Standard_D14_V2,
	"standard_d16d_v5":            AzureSku_Name_STATUS_Standard_D16D_V5,
	"standard_d32d_v4":            AzureSku_Name_STATUS_Standard_D32D_V4,
	"standard_d32d_v5":            AzureSku_Name_STATUS_Standard_D32D_V5,
	"standard_ds13_v2+1tb_ps":     AzureSku_Name_STATUS_Standard_DS13_V21TB_PS,
	"standard_ds13_v2+2tb_ps":     AzureSku_Name_STATUS_Standard_DS13_V22TB_PS,
	"standard_ds14_v2+3tb_ps":     AzureSku_Name_STATUS_Standard_DS14_V23TB_PS,
	"standard_ds14_v2+4tb_ps":     AzureSku_Name_STATUS_Standard_DS14_V24TB_PS,
	"standard_e16a_v4":            AzureSku_Name_STATUS_Standard_E16A_V4,
	"standard_e16ads_v5":          AzureSku_Name_STATUS_Standard_E16Ads_V5,
	"standard_e16as_v4+3tb_ps":    AzureSku_Name_STATUS_Standard_E16As_V43TB_PS,
	"standard_e16as_v4+4tb_ps":    AzureSku_Name_STATUS_Standard_E16As_V44TB_PS,
	"standard_e16as_v5+3tb_ps":    AzureSku_Name_STATUS_Standard_E16As_V53TB_PS,
	"standard_e16as_v5+4tb_ps":    AzureSku_Name_STATUS_Standard_E16As_V54TB_PS,
	"standard_e16d_v4":            AzureSku_Name_STATUS_Standard_E16D_V4,
	"standard_e16d_v5":            AzureSku_Name_STATUS_Standard_E16D_V5,
	"standard_e16s_v4+3tb_ps":     AzureSku_Name_STATUS_Standard_E16S_V43TB_PS,
	"standard_e16s_v4+4tb_ps":     AzureSku_Name_STATUS_Standard_E16S_V44TB_PS,
	"standard_e16s_v5+3tb_ps":     AzureSku_Name_STATUS_Standard_E16S_V53TB_PS,
	"standard_e16s_v5+4tb_ps":     AzureSku_Name_STATUS_Standard_E16S_V54TB_PS,
	"standard_e2a_v4":             AzureSku_Name_STATUS_Standard_E2A_V4,
	"standard_e2ads_v5":           AzureSku_Name_STATUS_Standard_E2Ads_V5,
	"standard_e2d_v4":             AzureSku_Name_STATUS_Standard_E2D_V4,
	"standard_e2d_v5":             AzureSku_Name_STATUS_Standard_E2D_V5,
	"standard_e4a_v4":             AzureSku_Name_STATUS_Standard_E4A_V4,
	"standard_e4ads_v5":           AzureSku_Name_STATUS_Standard_E4Ads_V5,
	"standard_e4d_v4":             AzureSku_Name_STATUS_Standard_E4D_V4,
	"standard_e4d_v5":             AzureSku_Name_STATUS_Standard_E4D_V5,
	"standard_e64i_v3":            AzureSku_Name_STATUS_Standard_E64I_V3,
	"standard_e80ids_v4":          AzureSku_Name_STATUS_Standard_E80Ids_V4,
	"standard_e8a_v4":             AzureSku_Name_STATUS_Standard_E8A_V4,
	"standard_e8ads_v5":           AzureSku_Name_STATUS_Standard_E8Ads_V5,
	"standard_e8as_v4+1tb_ps":     AzureSku_Name_STATUS_Standard_E8As_V41TB_PS,
	"standard_e8as_v4+2tb_ps":     AzureSku_Name_STATUS_Standard_E8As_V42TB_PS,
	"standard_e8as_v5+1tb_ps":     AzureSku_Name_STATUS_Standard_E8As_V51TB_PS,
	"standard_e8as_v5+2tb_ps":     AzureSku_Name_STATUS_Standard_E8As_V52TB_PS,
	"standard_e8d_v4":             AzureSku_Name_STATUS_Standard_E8D_V4,
	"standard_e8d_v5":             AzureSku_Name_STATUS_Standard_E8D_V5,
	"standard_e8s_v4+1tb_ps":      AzureSku_Name_STATUS_Standard_E8S_V41TB_PS,
	"standard_e8s_v4+2tb_ps":      AzureSku_Name_STATUS_Standard_E8S_V42TB_PS,
	"standard_e8s_v5+1tb_ps":      AzureSku_Name_STATUS_Standard_E8S_V51TB_PS,
	"standard_e8s_v5+2tb_ps":      AzureSku_Name_STATUS_Standard_E8S_V52TB_PS,
	"standard_ec16ads_v5":         AzureSku_Name_STATUS_Standard_EC16Ads_V5,
	"standard_ec16as_v5+3tb_ps":   AzureSku_Name_STATUS_Standard_EC16As_V53TB_PS,
	"standard_ec16as_v5+4tb_ps":   AzureSku_Name_STATUS_Standard_EC16As_V54TB_PS,
	"standard_ec8ads_v5":          AzureSku_Name_STATUS_Standard_EC8Ads_V5,
	"standard_ec8as_v5+1tb_ps":    AzureSku_Name_STATUS_Standard_EC8As_V51TB_PS,
	"standard_ec8as_v5+2tb_ps":    AzureSku_Name_STATUS_Standard_EC8As_V52TB_PS,
	"standard_l16as_v3":           AzureSku_Name_STATUS_Standard_L16As_V3,
	"standard_l16s":               AzureSku_Name_STATUS_Standard_L16S,
	"standard_l16s_v2":            AzureSku_Name_STATUS_Standard_L16S_V2,
	"standard_l16s_v3":            AzureSku_Name_STATUS_Standard_L16S_V3,
	"standard_l32as_v3":           AzureSku_Name_STATUS_Standard_L32As_V3,
	"standard_l32s_v3":            AzureSku_Name_STATUS_Standard_L32S_V3,
	"standard_l4s":                AzureSku_Name_STATUS_Standard_L4S,
	"standard_l8as_v3":            AzureSku_Name_STATUS_Standard_L8As_V3,
	"standard_l8s":                AzureSku_Name_STATUS_Standard_L8S,
	"standard_l8s_v2":             AzureSku_Name_STATUS_Standard_L8S_V2,
	"standard_l8s_v3":             AzureSku_Name_STATUS_Standard_L8S_V3,
}

// +kubebuilder:validation:Enum={"Basic","Standard"}
type AzureSku_Tier string

const (
	AzureSku_Tier_Basic    = AzureSku_Tier("Basic")
	AzureSku_Tier_Standard = AzureSku_Tier("Standard")
)

// Mapping from string to AzureSku_Tier
var azureSku_Tier_Values = map[string]AzureSku_Tier{
	"basic":    AzureSku_Tier_Basic,
	"standard": AzureSku_Tier_Standard,
}

type AzureSku_Tier_STATUS string

const (
	AzureSku_Tier_STATUS_Basic    = AzureSku_Tier_STATUS("Basic")
	AzureSku_Tier_STATUS_Standard = AzureSku_Tier_STATUS("Standard")
)

// Mapping from string to AzureSku_Tier_STATUS
var azureSku_Tier_STATUS_Values = map[string]AzureSku_Tier_STATUS{
	"basic":    AzureSku_Tier_STATUS_Basic,
	"standard": AzureSku_Tier_STATUS_Standard,
}

// +kubebuilder:validation:Enum={"None","SystemAssigned","SystemAssigned, UserAssigned","UserAssigned"}
type Identity_Type string

const (
	Identity_Type_None                       = Identity_Type("None")
	Identity_Type_SystemAssigned             = Identity_Type("SystemAssigned")
	Identity_Type_SystemAssignedUserAssigned = Identity_Type("SystemAssigned, UserAssigned")
	Identity_Type_UserAssigned               = Identity_Type("UserAssigned")
)

// Mapping from string to Identity_Type
var identity_Type_Values = map[string]Identity_Type{
	"none":                         Identity_Type_None,
	"systemassigned":               Identity_Type_SystemAssigned,
	"systemassigned, userassigned": Identity_Type_SystemAssignedUserAssigned,
	"userassigned":                 Identity_Type_UserAssigned,
}

type Identity_Type_STATUS string

const (
	Identity_Type_STATUS_None                       = Identity_Type_STATUS("None")
	Identity_Type_STATUS_SystemAssigned             = Identity_Type_STATUS("SystemAssigned")
	Identity_Type_STATUS_SystemAssignedUserAssigned = Identity_Type_STATUS("SystemAssigned, UserAssigned")
	Identity_Type_STATUS_UserAssigned               = Identity_Type_STATUS("UserAssigned")
)

// Mapping from string to Identity_Type_STATUS
var identity_Type_STATUS_Values = map[string]Identity_Type_STATUS{
	"none":                         Identity_Type_STATUS_None,
	"systemassigned":               Identity_Type_STATUS_SystemAssigned,
	"systemassigned, userassigned": Identity_Type_STATUS_SystemAssignedUserAssigned,
	"userassigned":                 Identity_Type_STATUS_UserAssigned,
}

type Identity_UserAssignedIdentities_STATUS struct {
	// ClientId: The client id of user assigned identity.
	ClientId *string `json:"clientId,omitempty"`

	// PrincipalId: The principal id of user assigned identity.
	PrincipalId *string `json:"principalId,omitempty"`
}

var _ genruntime.FromARMConverter = &Identity_UserAssignedIdentities_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identities *Identity_UserAssignedIdentities_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Identity_UserAssignedIdentities_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identities *Identity_UserAssignedIdentities_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Identity_UserAssignedIdentities_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Identity_UserAssignedIdentities_STATUS, got %T", armInput)
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		identities.ClientId = &clientId
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identities.PrincipalId = &principalId
	}

	// No error
	return nil
}

// AssignProperties_From_Identity_UserAssignedIdentities_STATUS populates our Identity_UserAssignedIdentities_STATUS from the provided source Identity_UserAssignedIdentities_STATUS
func (identities *Identity_UserAssignedIdentities_STATUS) AssignProperties_From_Identity_UserAssignedIdentities_STATUS(source *storage.Identity_UserAssignedIdentities_STATUS) error {

	// ClientId
	identities.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// PrincipalId
	identities.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// No error
	return nil
}

// AssignProperties_To_Identity_UserAssignedIdentities_STATUS populates the provided destination Identity_UserAssignedIdentities_STATUS from our Identity_UserAssignedIdentities_STATUS
func (identities *Identity_UserAssignedIdentities_STATUS) AssignProperties_To_Identity_UserAssignedIdentities_STATUS(destination *storage.Identity_UserAssignedIdentities_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(identities.ClientId)

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identities.PrincipalId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The language extension object.
type LanguageExtension struct {
	// LanguageExtensionCustomImageName: The language extension custom image name.
	LanguageExtensionCustomImageName *string `json:"languageExtensionCustomImageName,omitempty"`

	// LanguageExtensionImageName: The language extension image name.
	LanguageExtensionImageName *LanguageExtensionImageName `json:"languageExtensionImageName,omitempty"`

	// LanguageExtensionName: The language extension name.
	LanguageExtensionName *LanguageExtensionName `json:"languageExtensionName,omitempty"`
}

var _ genruntime.ARMTransformer = &LanguageExtension{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (extension *LanguageExtension) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if extension == nil {
		return nil, nil
	}
	result := &arm.LanguageExtension{}

	// Set property "LanguageExtensionCustomImageName":
	if extension.LanguageExtensionCustomImageName != nil {
		languageExtensionCustomImageName := *extension.LanguageExtensionCustomImageName
		result.LanguageExtensionCustomImageName = &languageExtensionCustomImageName
	}

	// Set property "LanguageExtensionImageName":
	if extension.LanguageExtensionImageName != nil {
		var temp string
		temp = string(*extension.LanguageExtensionImageName)
		languageExtensionImageName := arm.LanguageExtensionImageName(temp)
		result.LanguageExtensionImageName = &languageExtensionImageName
	}

	// Set property "LanguageExtensionName":
	if extension.LanguageExtensionName != nil {
		var temp string
		temp = string(*extension.LanguageExtensionName)
		languageExtensionName := arm.LanguageExtensionName(temp)
		result.LanguageExtensionName = &languageExtensionName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (extension *LanguageExtension) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.LanguageExtension{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (extension *LanguageExtension) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.LanguageExtension)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.LanguageExtension, got %T", armInput)
	}

	// Set property "LanguageExtensionCustomImageName":
	if typedInput.LanguageExtensionCustomImageName != nil {
		languageExtensionCustomImageName := *typedInput.LanguageExtensionCustomImageName
		extension.LanguageExtensionCustomImageName = &languageExtensionCustomImageName
	}

	// Set property "LanguageExtensionImageName":
	if typedInput.LanguageExtensionImageName != nil {
		var temp string
		temp = string(*typedInput.LanguageExtensionImageName)
		languageExtensionImageName := LanguageExtensionImageName(temp)
		extension.LanguageExtensionImageName = &languageExtensionImageName
	}

	// Set property "LanguageExtensionName":
	if typedInput.LanguageExtensionName != nil {
		var temp string
		temp = string(*typedInput.LanguageExtensionName)
		languageExtensionName := LanguageExtensionName(temp)
		extension.LanguageExtensionName = &languageExtensionName
	}

	// No error
	return nil
}

// AssignProperties_From_LanguageExtension populates our LanguageExtension from the provided source LanguageExtension
func (extension *LanguageExtension) AssignProperties_From_LanguageExtension(source *storage.LanguageExtension) error {

	// LanguageExtensionCustomImageName
	extension.LanguageExtensionCustomImageName = genruntime.ClonePointerToString(source.LanguageExtensionCustomImageName)

	// LanguageExtensionImageName
	if source.LanguageExtensionImageName != nil {
		languageExtensionImageName := *source.LanguageExtensionImageName
		languageExtensionImageNameTemp := genruntime.ToEnum(languageExtensionImageName, languageExtensionImageName_Values)
		extension.LanguageExtensionImageName = &languageExtensionImageNameTemp
	} else {
		extension.LanguageExtensionImageName = nil
	}

	// LanguageExtensionName
	if source.LanguageExtensionName != nil {
		languageExtensionName := *source.LanguageExtensionName
		languageExtensionNameTemp := genruntime.ToEnum(languageExtensionName, languageExtensionName_Values)
		extension.LanguageExtensionName = &languageExtensionNameTemp
	} else {
		extension.LanguageExtensionName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_LanguageExtension populates the provided destination LanguageExtension from our LanguageExtension
func (extension *LanguageExtension) AssignProperties_To_LanguageExtension(destination *storage.LanguageExtension) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// LanguageExtensionCustomImageName
	destination.LanguageExtensionCustomImageName = genruntime.ClonePointerToString(extension.LanguageExtensionCustomImageName)

	// LanguageExtensionImageName
	if extension.LanguageExtensionImageName != nil {
		languageExtensionImageName := string(*extension.LanguageExtensionImageName)
		destination.LanguageExtensionImageName = &languageExtensionImageName
	} else {
		destination.LanguageExtensionImageName = nil
	}

	// LanguageExtensionName
	if extension.LanguageExtensionName != nil {
		languageExtensionName := string(*extension.LanguageExtensionName)
		destination.LanguageExtensionName = &languageExtensionName
	} else {
		destination.LanguageExtensionName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_LanguageExtension_STATUS populates our LanguageExtension from the provided source LanguageExtension_STATUS
func (extension *LanguageExtension) Initialize_From_LanguageExtension_STATUS(source *LanguageExtension_STATUS) error {

	// LanguageExtensionCustomImageName
	extension.LanguageExtensionCustomImageName = genruntime.ClonePointerToString(source.LanguageExtensionCustomImageName)

	// LanguageExtensionImageName
	if source.LanguageExtensionImageName != nil {
		languageExtensionImageName := genruntime.ToEnum(string(*source.LanguageExtensionImageName), languageExtensionImageName_Values)
		extension.LanguageExtensionImageName = &languageExtensionImageName
	} else {
		extension.LanguageExtensionImageName = nil
	}

	// LanguageExtensionName
	if source.LanguageExtensionName != nil {
		languageExtensionName := genruntime.ToEnum(string(*source.LanguageExtensionName), languageExtensionName_Values)
		extension.LanguageExtensionName = &languageExtensionName
	} else {
		extension.LanguageExtensionName = nil
	}

	// No error
	return nil
}

// The language extension object.
type LanguageExtension_STATUS struct {
	// LanguageExtensionCustomImageName: The language extension custom image name.
	LanguageExtensionCustomImageName *string `json:"languageExtensionCustomImageName,omitempty"`

	// LanguageExtensionImageName: The language extension image name.
	LanguageExtensionImageName *LanguageExtensionImageName_STATUS `json:"languageExtensionImageName,omitempty"`

	// LanguageExtensionName: The language extension name.
	LanguageExtensionName *LanguageExtensionName_STATUS `json:"languageExtensionName,omitempty"`
}

var _ genruntime.FromARMConverter = &LanguageExtension_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (extension *LanguageExtension_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.LanguageExtension_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (extension *LanguageExtension_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.LanguageExtension_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.LanguageExtension_STATUS, got %T", armInput)
	}

	// Set property "LanguageExtensionCustomImageName":
	if typedInput.LanguageExtensionCustomImageName != nil {
		languageExtensionCustomImageName := *typedInput.LanguageExtensionCustomImageName
		extension.LanguageExtensionCustomImageName = &languageExtensionCustomImageName
	}

	// Set property "LanguageExtensionImageName":
	if typedInput.LanguageExtensionImageName != nil {
		var temp string
		temp = string(*typedInput.LanguageExtensionImageName)
		languageExtensionImageName := LanguageExtensionImageName_STATUS(temp)
		extension.LanguageExtensionImageName = &languageExtensionImageName
	}

	// Set property "LanguageExtensionName":
	if typedInput.LanguageExtensionName != nil {
		var temp string
		temp = string(*typedInput.LanguageExtensionName)
		languageExtensionName := LanguageExtensionName_STATUS(temp)
		extension.LanguageExtensionName = &languageExtensionName
	}

	// No error
	return nil
}

// AssignProperties_From_LanguageExtension_STATUS populates our LanguageExtension_STATUS from the provided source LanguageExtension_STATUS
func (extension *LanguageExtension_STATUS) AssignProperties_From_LanguageExtension_STATUS(source *storage.LanguageExtension_STATUS) error {

	// LanguageExtensionCustomImageName
	extension.LanguageExtensionCustomImageName = genruntime.ClonePointerToString(source.LanguageExtensionCustomImageName)

	// LanguageExtensionImageName
	if source.LanguageExtensionImageName != nil {
		languageExtensionImageName := *source.LanguageExtensionImageName
		languageExtensionImageNameTemp := genruntime.ToEnum(languageExtensionImageName, languageExtensionImageName_STATUS_Values)
		extension.LanguageExtensionImageName = &languageExtensionImageNameTemp
	} else {
		extension.LanguageExtensionImageName = nil
	}

	// LanguageExtensionName
	if source.LanguageExtensionName != nil {
		languageExtensionName := *source.LanguageExtensionName
		languageExtensionNameTemp := genruntime.ToEnum(languageExtensionName, languageExtensionName_STATUS_Values)
		extension.LanguageExtensionName = &languageExtensionNameTemp
	} else {
		extension.LanguageExtensionName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_LanguageExtension_STATUS populates the provided destination LanguageExtension_STATUS from our LanguageExtension_STATUS
func (extension *LanguageExtension_STATUS) AssignProperties_To_LanguageExtension_STATUS(destination *storage.LanguageExtension_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// LanguageExtensionCustomImageName
	destination.LanguageExtensionCustomImageName = genruntime.ClonePointerToString(extension.LanguageExtensionCustomImageName)

	// LanguageExtensionImageName
	if extension.LanguageExtensionImageName != nil {
		languageExtensionImageName := string(*extension.LanguageExtensionImageName)
		destination.LanguageExtensionImageName = &languageExtensionImageName
	} else {
		destination.LanguageExtensionImageName = nil
	}

	// LanguageExtensionName
	if extension.LanguageExtensionName != nil {
		languageExtensionName := string(*extension.LanguageExtensionName)
		destination.LanguageExtensionName = &languageExtensionName
	} else {
		destination.LanguageExtensionName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type MigrationClusterProperties_Role_STATUS string

const (
	MigrationClusterProperties_Role_STATUS_Destination = MigrationClusterProperties_Role_STATUS("Destination")
	MigrationClusterProperties_Role_STATUS_Source      = MigrationClusterProperties_Role_STATUS("Source")
)

// Mapping from string to MigrationClusterProperties_Role_STATUS
var migrationClusterProperties_Role_STATUS_Values = map[string]MigrationClusterProperties_Role_STATUS{
	"destination": MigrationClusterProperties_Role_STATUS_Destination,
	"source":      MigrationClusterProperties_Role_STATUS_Source,
}

type SystemData_CreatedByType_STATUS string

const (
	SystemData_CreatedByType_STATUS_Application     = SystemData_CreatedByType_STATUS("Application")
	SystemData_CreatedByType_STATUS_Key             = SystemData_CreatedByType_STATUS("Key")
	SystemData_CreatedByType_STATUS_ManagedIdentity = SystemData_CreatedByType_STATUS("ManagedIdentity")
	SystemData_CreatedByType_STATUS_User            = SystemData_CreatedByType_STATUS("User")
)

// Mapping from string to SystemData_CreatedByType_STATUS
var systemData_CreatedByType_STATUS_Values = map[string]SystemData_CreatedByType_STATUS{
	"application":     SystemData_CreatedByType_STATUS_Application,
	"key":             SystemData_CreatedByType_STATUS_Key,
	"managedidentity": SystemData_CreatedByType_STATUS_ManagedIdentity,
	"user":            SystemData_CreatedByType_STATUS_User,
}

type SystemData_LastModifiedByType_STATUS string

const (
	SystemData_LastModifiedByType_STATUS_Application     = SystemData_LastModifiedByType_STATUS("Application")
	SystemData_LastModifiedByType_STATUS_Key             = SystemData_LastModifiedByType_STATUS("Key")
	SystemData_LastModifiedByType_STATUS_ManagedIdentity = SystemData_LastModifiedByType_STATUS("ManagedIdentity")
	SystemData_LastModifiedByType_STATUS_User            = SystemData_LastModifiedByType_STATUS("User")
)

// Mapping from string to SystemData_LastModifiedByType_STATUS
var systemData_LastModifiedByType_STATUS_Values = map[string]SystemData_LastModifiedByType_STATUS{
	"application":     SystemData_LastModifiedByType_STATUS_Application,
	"key":             SystemData_LastModifiedByType_STATUS_Key,
	"managedidentity": SystemData_LastModifiedByType_STATUS_ManagedIdentity,
	"user":            SystemData_LastModifiedByType_STATUS_User,
}

// Information about the user assigned identity for the resource
type UserAssignedIdentityDetails struct {
	Reference genruntime.ResourceReference `armReference:"Reference" json:"reference,omitempty"`
}

// AssignProperties_From_UserAssignedIdentityDetails populates our UserAssignedIdentityDetails from the provided source UserAssignedIdentityDetails
func (details *UserAssignedIdentityDetails) AssignProperties_From_UserAssignedIdentityDetails(source *storage.UserAssignedIdentityDetails) error {

	// Reference
	details.Reference = source.Reference.Copy()

	// No error
	return nil
}

// AssignProperties_To_UserAssignedIdentityDetails populates the provided destination UserAssignedIdentityDetails from our UserAssignedIdentityDetails
func (details *UserAssignedIdentityDetails) AssignProperties_To_UserAssignedIdentityDetails(destination *storage.UserAssignedIdentityDetails) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	destination.Reference = details.Reference.Copy()

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type VirtualNetworkConfiguration_State string

const (
	VirtualNetworkConfiguration_State_Disabled = VirtualNetworkConfiguration_State("Disabled")
	VirtualNetworkConfiguration_State_Enabled  = VirtualNetworkConfiguration_State("Enabled")
)

// Mapping from string to VirtualNetworkConfiguration_State
var virtualNetworkConfiguration_State_Values = map[string]VirtualNetworkConfiguration_State{
	"disabled": VirtualNetworkConfiguration_State_Disabled,
	"enabled":  VirtualNetworkConfiguration_State_Enabled,
}

type VirtualNetworkConfiguration_State_STATUS string

const (
	VirtualNetworkConfiguration_State_STATUS_Disabled = VirtualNetworkConfiguration_State_STATUS("Disabled")
	VirtualNetworkConfiguration_State_STATUS_Enabled  = VirtualNetworkConfiguration_State_STATUS("Enabled")
)

// Mapping from string to VirtualNetworkConfiguration_State_STATUS
var virtualNetworkConfiguration_State_STATUS_Values = map[string]VirtualNetworkConfiguration_State_STATUS{
	"disabled": VirtualNetworkConfiguration_State_STATUS_Disabled,
	"enabled":  VirtualNetworkConfiguration_State_STATUS_Enabled,
}

// Language extension image name.
// +kubebuilder:validation:Enum={"Python3_10_8","Python3_10_8_DL","Python3_6_5","PythonCustomImage","R"}
type LanguageExtensionImageName string

const (
	LanguageExtensionImageName_Python3_10_8      = LanguageExtensionImageName("Python3_10_8")
	LanguageExtensionImageName_Python3_10_8_DL   = LanguageExtensionImageName("Python3_10_8_DL")
	LanguageExtensionImageName_Python3_6_5       = LanguageExtensionImageName("Python3_6_5")
	LanguageExtensionImageName_PythonCustomImage = LanguageExtensionImageName("PythonCustomImage")
	LanguageExtensionImageName_R                 = LanguageExtensionImageName("R")
)

// Mapping from string to LanguageExtensionImageName
var languageExtensionImageName_Values = map[string]LanguageExtensionImageName{
	"python3_10_8":      LanguageExtensionImageName_Python3_10_8,
	"python3_10_8_dl":   LanguageExtensionImageName_Python3_10_8_DL,
	"python3_6_5":       LanguageExtensionImageName_Python3_6_5,
	"pythoncustomimage": LanguageExtensionImageName_PythonCustomImage,
	"r":                 LanguageExtensionImageName_R,
}

// Language extension image name.
type LanguageExtensionImageName_STATUS string

const (
	LanguageExtensionImageName_STATUS_Python3_10_8      = LanguageExtensionImageName_STATUS("Python3_10_8")
	LanguageExtensionImageName_STATUS_Python3_10_8_DL   = LanguageExtensionImageName_STATUS("Python3_10_8_DL")
	LanguageExtensionImageName_STATUS_Python3_6_5       = LanguageExtensionImageName_STATUS("Python3_6_5")
	LanguageExtensionImageName_STATUS_PythonCustomImage = LanguageExtensionImageName_STATUS("PythonCustomImage")
	LanguageExtensionImageName_STATUS_R                 = LanguageExtensionImageName_STATUS("R")
)

// Mapping from string to LanguageExtensionImageName_STATUS
var languageExtensionImageName_STATUS_Values = map[string]LanguageExtensionImageName_STATUS{
	"python3_10_8":      LanguageExtensionImageName_STATUS_Python3_10_8,
	"python3_10_8_dl":   LanguageExtensionImageName_STATUS_Python3_10_8_DL,
	"python3_6_5":       LanguageExtensionImageName_STATUS_Python3_6_5,
	"pythoncustomimage": LanguageExtensionImageName_STATUS_PythonCustomImage,
	"r":                 LanguageExtensionImageName_STATUS_R,
}

// Language extension that can run within KQL query.
// +kubebuilder:validation:Enum={"PYTHON","R"}
type LanguageExtensionName string

const (
	LanguageExtensionName_PYTHON = LanguageExtensionName("PYTHON")
	LanguageExtensionName_R      = LanguageExtensionName("R")
)

// Mapping from string to LanguageExtensionName
var languageExtensionName_Values = map[string]LanguageExtensionName{
	"python": LanguageExtensionName_PYTHON,
	"r":      LanguageExtensionName_R,
}

// Language extension that can run within KQL query.
type LanguageExtensionName_STATUS string

const (
	LanguageExtensionName_STATUS_PYTHON = LanguageExtensionName_STATUS("PYTHON")
	LanguageExtensionName_STATUS_R      = LanguageExtensionName_STATUS("R")
)

// Mapping from string to LanguageExtensionName_STATUS
var languageExtensionName_STATUS_Values = map[string]LanguageExtensionName_STATUS{
	"python": LanguageExtensionName_STATUS_PYTHON,
	"r":      LanguageExtensionName_STATUS_R,
}

func init() {
	SchemeBuilder.Register(&Cluster{}, &ClusterList{})
}
