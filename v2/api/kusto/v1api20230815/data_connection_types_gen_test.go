// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20230815

import (
	"encoding/json"
	storage "github.com/Azure/azure-service-operator/v2/api/kusto/v1api20230815/storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_CosmosDbDataConnection_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CosmosDbDataConnection to CosmosDbDataConnection via AssignProperties_To_CosmosDbDataConnection & AssignProperties_From_CosmosDbDataConnection returns original",
		prop.ForAll(RunPropertyAssignmentTestForCosmosDbDataConnection, CosmosDbDataConnectionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCosmosDbDataConnection tests if a specific instance of CosmosDbDataConnection can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForCosmosDbDataConnection(subject CosmosDbDataConnection) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.CosmosDbDataConnection
	err := copied.AssignProperties_To_CosmosDbDataConnection(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CosmosDbDataConnection
	err = actual.AssignProperties_From_CosmosDbDataConnection(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CosmosDbDataConnection_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CosmosDbDataConnection via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCosmosDbDataConnection, CosmosDbDataConnectionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCosmosDbDataConnection runs a test to see if a specific instance of CosmosDbDataConnection round trips to JSON and back losslessly
func RunJSONSerializationTestForCosmosDbDataConnection(subject CosmosDbDataConnection) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CosmosDbDataConnection
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CosmosDbDataConnection instances for property testing - lazily instantiated by
// CosmosDbDataConnectionGenerator()
var cosmosDbDataConnectionGenerator gopter.Gen

// CosmosDbDataConnectionGenerator returns a generator of CosmosDbDataConnection instances for property testing.
func CosmosDbDataConnectionGenerator() gopter.Gen {
	if cosmosDbDataConnectionGenerator != nil {
		return cosmosDbDataConnectionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCosmosDbDataConnection(generators)
	cosmosDbDataConnectionGenerator = gen.Struct(reflect.TypeOf(CosmosDbDataConnection{}), generators)

	return cosmosDbDataConnectionGenerator
}

// AddIndependentPropertyGeneratorsForCosmosDbDataConnection is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCosmosDbDataConnection(gens map[string]gopter.Gen) {
	gens["CosmosDbContainer"] = gen.PtrOf(gen.AlphaString())
	gens["CosmosDbDatabase"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(CosmosDbDataConnection_Kind_CosmosDb))
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["MappingRuleName"] = gen.PtrOf(gen.AlphaString())
	gens["RetrievalStartDate"] = gen.PtrOf(gen.AlphaString())
	gens["TableName"] = gen.PtrOf(gen.AlphaString())
}

func Test_CosmosDbDataConnection_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CosmosDbDataConnection_STATUS to CosmosDbDataConnection_STATUS via AssignProperties_To_CosmosDbDataConnection_STATUS & AssignProperties_From_CosmosDbDataConnection_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForCosmosDbDataConnection_STATUS, CosmosDbDataConnection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCosmosDbDataConnection_STATUS tests if a specific instance of CosmosDbDataConnection_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForCosmosDbDataConnection_STATUS(subject CosmosDbDataConnection_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.CosmosDbDataConnection_STATUS
	err := copied.AssignProperties_To_CosmosDbDataConnection_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CosmosDbDataConnection_STATUS
	err = actual.AssignProperties_From_CosmosDbDataConnection_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CosmosDbDataConnection_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CosmosDbDataConnection_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCosmosDbDataConnection_STATUS, CosmosDbDataConnection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCosmosDbDataConnection_STATUS runs a test to see if a specific instance of CosmosDbDataConnection_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForCosmosDbDataConnection_STATUS(subject CosmosDbDataConnection_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CosmosDbDataConnection_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CosmosDbDataConnection_STATUS instances for property testing - lazily instantiated by
// CosmosDbDataConnection_STATUSGenerator()
var cosmosDbDataConnection_STATUSGenerator gopter.Gen

// CosmosDbDataConnection_STATUSGenerator returns a generator of CosmosDbDataConnection_STATUS instances for property testing.
func CosmosDbDataConnection_STATUSGenerator() gopter.Gen {
	if cosmosDbDataConnection_STATUSGenerator != nil {
		return cosmosDbDataConnection_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCosmosDbDataConnection_STATUS(generators)
	cosmosDbDataConnection_STATUSGenerator = gen.Struct(reflect.TypeOf(CosmosDbDataConnection_STATUS{}), generators)

	return cosmosDbDataConnection_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForCosmosDbDataConnection_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCosmosDbDataConnection_STATUS(gens map[string]gopter.Gen) {
	gens["CosmosDbAccountResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["CosmosDbContainer"] = gen.PtrOf(gen.AlphaString())
	gens["CosmosDbDatabase"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(CosmosDbDataConnection_Kind_STATUS_CosmosDb))
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["ManagedIdentityObjectId"] = gen.PtrOf(gen.AlphaString())
	gens["ManagedIdentityResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["MappingRuleName"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_STATUS_Canceled,
		ProvisioningState_STATUS_Creating,
		ProvisioningState_STATUS_Deleting,
		ProvisioningState_STATUS_Failed,
		ProvisioningState_STATUS_Moving,
		ProvisioningState_STATUS_Running,
		ProvisioningState_STATUS_Succeeded))
	gens["RetrievalStartDate"] = gen.PtrOf(gen.AlphaString())
	gens["TableName"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_DataConnection_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	parameters.MinSuccessfulTests = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DataConnection to hub returns original",
		prop.ForAll(RunResourceConversionTestForDataConnection, DataConnectionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForDataConnection tests if a specific instance of DataConnection round trips to the hub storage version and back losslessly
func RunResourceConversionTestForDataConnection(subject DataConnection) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub storage.DataConnection
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual DataConnection
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DataConnection_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DataConnection to DataConnection via AssignProperties_To_DataConnection & AssignProperties_From_DataConnection returns original",
		prop.ForAll(RunPropertyAssignmentTestForDataConnection, DataConnectionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDataConnection tests if a specific instance of DataConnection can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForDataConnection(subject DataConnection) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.DataConnection
	err := copied.AssignProperties_To_DataConnection(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DataConnection
	err = actual.AssignProperties_From_DataConnection(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DataConnection_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataConnection via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataConnection, DataConnectionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataConnection runs a test to see if a specific instance of DataConnection round trips to JSON and back losslessly
func RunJSONSerializationTestForDataConnection(subject DataConnection) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataConnection
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataConnection instances for property testing - lazily instantiated by DataConnectionGenerator()
var dataConnectionGenerator gopter.Gen

// DataConnectionGenerator returns a generator of DataConnection instances for property testing.
func DataConnectionGenerator() gopter.Gen {
	if dataConnectionGenerator != nil {
		return dataConnectionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDataConnection(generators)
	dataConnectionGenerator = gen.Struct(reflect.TypeOf(DataConnection{}), generators)

	return dataConnectionGenerator
}

// AddRelatedPropertyGeneratorsForDataConnection is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataConnection(gens map[string]gopter.Gen) {
	gens["Spec"] = DataConnection_SpecGenerator()
	gens["Status"] = DataConnection_STATUSGenerator()
}

func Test_DataConnectionOperatorSpec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DataConnectionOperatorSpec to DataConnectionOperatorSpec via AssignProperties_To_DataConnectionOperatorSpec & AssignProperties_From_DataConnectionOperatorSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForDataConnectionOperatorSpec, DataConnectionOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDataConnectionOperatorSpec tests if a specific instance of DataConnectionOperatorSpec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForDataConnectionOperatorSpec(subject DataConnectionOperatorSpec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.DataConnectionOperatorSpec
	err := copied.AssignProperties_To_DataConnectionOperatorSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DataConnectionOperatorSpec
	err = actual.AssignProperties_From_DataConnectionOperatorSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DataConnectionOperatorSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataConnectionOperatorSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataConnectionOperatorSpec, DataConnectionOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataConnectionOperatorSpec runs a test to see if a specific instance of DataConnectionOperatorSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForDataConnectionOperatorSpec(subject DataConnectionOperatorSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataConnectionOperatorSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataConnectionOperatorSpec instances for property testing - lazily instantiated by
// DataConnectionOperatorSpecGenerator()
var dataConnectionOperatorSpecGenerator gopter.Gen

// DataConnectionOperatorSpecGenerator returns a generator of DataConnectionOperatorSpec instances for property testing.
func DataConnectionOperatorSpecGenerator() gopter.Gen {
	if dataConnectionOperatorSpecGenerator != nil {
		return dataConnectionOperatorSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	dataConnectionOperatorSpecGenerator = gen.Struct(reflect.TypeOf(DataConnectionOperatorSpec{}), generators)

	return dataConnectionOperatorSpecGenerator
}

func Test_DataConnection_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DataConnection_STATUS to DataConnection_STATUS via AssignProperties_To_DataConnection_STATUS & AssignProperties_From_DataConnection_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDataConnection_STATUS, DataConnection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDataConnection_STATUS tests if a specific instance of DataConnection_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForDataConnection_STATUS(subject DataConnection_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.DataConnection_STATUS
	err := copied.AssignProperties_To_DataConnection_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DataConnection_STATUS
	err = actual.AssignProperties_From_DataConnection_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DataConnection_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataConnection_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataConnection_STATUS, DataConnection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataConnection_STATUS runs a test to see if a specific instance of DataConnection_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDataConnection_STATUS(subject DataConnection_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataConnection_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataConnection_STATUS instances for property testing - lazily instantiated by
// DataConnection_STATUSGenerator()
var dataConnection_STATUSGenerator gopter.Gen

// DataConnection_STATUSGenerator returns a generator of DataConnection_STATUS instances for property testing.
func DataConnection_STATUSGenerator() gopter.Gen {
	if dataConnection_STATUSGenerator != nil {
		return dataConnection_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDataConnection_STATUS(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		props := map[string]gopter.Gen{propName: propGen}
		gens = append(gens, gen.Struct(reflect.TypeOf(DataConnection_STATUS{}), props))
	}
	dataConnection_STATUSGenerator = gen.OneGenOf(gens...)

	return dataConnection_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDataConnection_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDataConnection_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDataConnection_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataConnection_STATUS(gens map[string]gopter.Gen) {
	gens["CosmosDb"] = CosmosDbDataConnection_STATUSGenerator().Map(func(it CosmosDbDataConnection_STATUS) *CosmosDbDataConnection_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["EventGrid"] = EventGridDataConnection_STATUSGenerator().Map(func(it EventGridDataConnection_STATUS) *EventGridDataConnection_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["EventHub"] = EventHubDataConnection_STATUSGenerator().Map(func(it EventHubDataConnection_STATUS) *EventHubDataConnection_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["IotHub"] = IotHubDataConnection_STATUSGenerator().Map(func(it IotHubDataConnection_STATUS) *IotHubDataConnection_STATUS {
		return &it
	}) // generate one case for OneOf type
}

func Test_DataConnection_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DataConnection_Spec to DataConnection_Spec via AssignProperties_To_DataConnection_Spec & AssignProperties_From_DataConnection_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForDataConnection_Spec, DataConnection_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDataConnection_Spec tests if a specific instance of DataConnection_Spec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForDataConnection_Spec(subject DataConnection_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.DataConnection_Spec
	err := copied.AssignProperties_To_DataConnection_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DataConnection_Spec
	err = actual.AssignProperties_From_DataConnection_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DataConnection_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataConnection_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataConnection_Spec, DataConnection_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataConnection_Spec runs a test to see if a specific instance of DataConnection_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForDataConnection_Spec(subject DataConnection_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataConnection_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataConnection_Spec instances for property testing - lazily instantiated by
// DataConnection_SpecGenerator()
var dataConnection_SpecGenerator gopter.Gen

// DataConnection_SpecGenerator returns a generator of DataConnection_Spec instances for property testing.
func DataConnection_SpecGenerator() gopter.Gen {
	if dataConnection_SpecGenerator != nil {
		return dataConnection_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDataConnection_Spec(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		props := map[string]gopter.Gen{propName: propGen}
		gens = append(gens, gen.Struct(reflect.TypeOf(DataConnection_Spec{}), props))
	}
	dataConnection_SpecGenerator = gen.OneGenOf(gens...)

	return dataConnection_SpecGenerator
}

// AddIndependentPropertyGeneratorsForDataConnection_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDataConnection_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForDataConnection_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataConnection_Spec(gens map[string]gopter.Gen) {
	gens["CosmosDb"] = CosmosDbDataConnectionGenerator().Map(func(it CosmosDbDataConnection) *CosmosDbDataConnection {
		return &it
	}) // generate one case for OneOf type
	gens["EventGrid"] = EventGridDataConnectionGenerator().Map(func(it EventGridDataConnection) *EventGridDataConnection {
		return &it
	}) // generate one case for OneOf type
	gens["EventHub"] = EventHubDataConnectionGenerator().Map(func(it EventHubDataConnection) *EventHubDataConnection {
		return &it
	}) // generate one case for OneOf type
	gens["IotHub"] = IotHubDataConnectionGenerator().Map(func(it IotHubDataConnection) *IotHubDataConnection {
		return &it
	}) // generate one case for OneOf type
	gens["OperatorSpec"] = DataConnectionOperatorSpecGenerator().Map(func(it DataConnectionOperatorSpec) *DataConnectionOperatorSpec {
		return &it
	}) // generate one case for OneOf type
}

func Test_EventGridDataConnection_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EventGridDataConnection to EventGridDataConnection via AssignProperties_To_EventGridDataConnection & AssignProperties_From_EventGridDataConnection returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventGridDataConnection, EventGridDataConnectionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventGridDataConnection tests if a specific instance of EventGridDataConnection can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForEventGridDataConnection(subject EventGridDataConnection) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.EventGridDataConnection
	err := copied.AssignProperties_To_EventGridDataConnection(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EventGridDataConnection
	err = actual.AssignProperties_From_EventGridDataConnection(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventGridDataConnection_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventGridDataConnection via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventGridDataConnection, EventGridDataConnectionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventGridDataConnection runs a test to see if a specific instance of EventGridDataConnection round trips to JSON and back losslessly
func RunJSONSerializationTestForEventGridDataConnection(subject EventGridDataConnection) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventGridDataConnection
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventGridDataConnection instances for property testing - lazily instantiated by
// EventGridDataConnectionGenerator()
var eventGridDataConnectionGenerator gopter.Gen

// EventGridDataConnectionGenerator returns a generator of EventGridDataConnection instances for property testing.
func EventGridDataConnectionGenerator() gopter.Gen {
	if eventGridDataConnectionGenerator != nil {
		return eventGridDataConnectionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventGridDataConnection(generators)
	eventGridDataConnectionGenerator = gen.Struct(reflect.TypeOf(EventGridDataConnection{}), generators)

	return eventGridDataConnectionGenerator
}

// AddIndependentPropertyGeneratorsForEventGridDataConnection is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventGridDataConnection(gens map[string]gopter.Gen) {
	gens["BlobStorageEventType"] = gen.PtrOf(gen.OneConstOf(BlobStorageEventType_MicrosoftStorageBlobCreated, BlobStorageEventType_MicrosoftStorageBlobRenamed))
	gens["ConsumerGroup"] = gen.PtrOf(gen.AlphaString())
	gens["DataFormat"] = gen.PtrOf(gen.OneConstOf(
		EventGridDataFormat_APACHEAVRO,
		EventGridDataFormat_AVRO,
		EventGridDataFormat_CSV,
		EventGridDataFormat_JSON,
		EventGridDataFormat_MULTIJSON,
		EventGridDataFormat_ORC,
		EventGridDataFormat_PARQUET,
		EventGridDataFormat_PSV,
		EventGridDataFormat_RAW,
		EventGridDataFormat_SCSV,
		EventGridDataFormat_SINGLEJSON,
		EventGridDataFormat_SOHSV,
		EventGridDataFormat_TSV,
		EventGridDataFormat_TSVE,
		EventGridDataFormat_TXT,
		EventGridDataFormat_W3CLOGFILE))
	gens["DatabaseRouting"] = gen.PtrOf(gen.OneConstOf(EventGridConnectionProperties_DatabaseRouting_Multi, EventGridConnectionProperties_DatabaseRouting_Single))
	gens["IgnoreFirstRecord"] = gen.PtrOf(gen.Bool())
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(EventGridDataConnection_Kind_EventGrid))
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["MappingRuleName"] = gen.PtrOf(gen.AlphaString())
	gens["TableName"] = gen.PtrOf(gen.AlphaString())
}

func Test_EventGridDataConnection_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EventGridDataConnection_STATUS to EventGridDataConnection_STATUS via AssignProperties_To_EventGridDataConnection_STATUS & AssignProperties_From_EventGridDataConnection_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventGridDataConnection_STATUS, EventGridDataConnection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventGridDataConnection_STATUS tests if a specific instance of EventGridDataConnection_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForEventGridDataConnection_STATUS(subject EventGridDataConnection_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.EventGridDataConnection_STATUS
	err := copied.AssignProperties_To_EventGridDataConnection_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EventGridDataConnection_STATUS
	err = actual.AssignProperties_From_EventGridDataConnection_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventGridDataConnection_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventGridDataConnection_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventGridDataConnection_STATUS, EventGridDataConnection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventGridDataConnection_STATUS runs a test to see if a specific instance of EventGridDataConnection_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEventGridDataConnection_STATUS(subject EventGridDataConnection_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventGridDataConnection_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventGridDataConnection_STATUS instances for property testing - lazily instantiated by
// EventGridDataConnection_STATUSGenerator()
var eventGridDataConnection_STATUSGenerator gopter.Gen

// EventGridDataConnection_STATUSGenerator returns a generator of EventGridDataConnection_STATUS instances for property testing.
func EventGridDataConnection_STATUSGenerator() gopter.Gen {
	if eventGridDataConnection_STATUSGenerator != nil {
		return eventGridDataConnection_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventGridDataConnection_STATUS(generators)
	eventGridDataConnection_STATUSGenerator = gen.Struct(reflect.TypeOf(EventGridDataConnection_STATUS{}), generators)

	return eventGridDataConnection_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForEventGridDataConnection_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventGridDataConnection_STATUS(gens map[string]gopter.Gen) {
	gens["BlobStorageEventType"] = gen.PtrOf(gen.OneConstOf(BlobStorageEventType_STATUS_MicrosoftStorageBlobCreated, BlobStorageEventType_STATUS_MicrosoftStorageBlobRenamed))
	gens["ConsumerGroup"] = gen.PtrOf(gen.AlphaString())
	gens["DataFormat"] = gen.PtrOf(gen.OneConstOf(
		EventGridDataFormat_STATUS_APACHEAVRO,
		EventGridDataFormat_STATUS_AVRO,
		EventGridDataFormat_STATUS_CSV,
		EventGridDataFormat_STATUS_JSON,
		EventGridDataFormat_STATUS_MULTIJSON,
		EventGridDataFormat_STATUS_ORC,
		EventGridDataFormat_STATUS_PARQUET,
		EventGridDataFormat_STATUS_PSV,
		EventGridDataFormat_STATUS_RAW,
		EventGridDataFormat_STATUS_SCSV,
		EventGridDataFormat_STATUS_SINGLEJSON,
		EventGridDataFormat_STATUS_SOHSV,
		EventGridDataFormat_STATUS_TSV,
		EventGridDataFormat_STATUS_TSVE,
		EventGridDataFormat_STATUS_TXT,
		EventGridDataFormat_STATUS_W3CLOGFILE))
	gens["DatabaseRouting"] = gen.PtrOf(gen.OneConstOf(EventGridConnectionProperties_DatabaseRouting_STATUS_Multi, EventGridConnectionProperties_DatabaseRouting_STATUS_Single))
	gens["EventGridResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["EventHubResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IgnoreFirstRecord"] = gen.PtrOf(gen.Bool())
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(EventGridDataConnection_Kind_STATUS_EventGrid))
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["ManagedIdentityObjectId"] = gen.PtrOf(gen.AlphaString())
	gens["ManagedIdentityResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["MappingRuleName"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_STATUS_Canceled,
		ProvisioningState_STATUS_Creating,
		ProvisioningState_STATUS_Deleting,
		ProvisioningState_STATUS_Failed,
		ProvisioningState_STATUS_Moving,
		ProvisioningState_STATUS_Running,
		ProvisioningState_STATUS_Succeeded))
	gens["StorageAccountResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["TableName"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_EventHubDataConnection_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EventHubDataConnection to EventHubDataConnection via AssignProperties_To_EventHubDataConnection & AssignProperties_From_EventHubDataConnection returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventHubDataConnection, EventHubDataConnectionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventHubDataConnection tests if a specific instance of EventHubDataConnection can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForEventHubDataConnection(subject EventHubDataConnection) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.EventHubDataConnection
	err := copied.AssignProperties_To_EventHubDataConnection(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EventHubDataConnection
	err = actual.AssignProperties_From_EventHubDataConnection(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventHubDataConnection_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventHubDataConnection via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventHubDataConnection, EventHubDataConnectionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventHubDataConnection runs a test to see if a specific instance of EventHubDataConnection round trips to JSON and back losslessly
func RunJSONSerializationTestForEventHubDataConnection(subject EventHubDataConnection) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventHubDataConnection
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventHubDataConnection instances for property testing - lazily instantiated by
// EventHubDataConnectionGenerator()
var eventHubDataConnectionGenerator gopter.Gen

// EventHubDataConnectionGenerator returns a generator of EventHubDataConnection instances for property testing.
func EventHubDataConnectionGenerator() gopter.Gen {
	if eventHubDataConnectionGenerator != nil {
		return eventHubDataConnectionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventHubDataConnection(generators)
	eventHubDataConnectionGenerator = gen.Struct(reflect.TypeOf(EventHubDataConnection{}), generators)

	return eventHubDataConnectionGenerator
}

// AddIndependentPropertyGeneratorsForEventHubDataConnection is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventHubDataConnection(gens map[string]gopter.Gen) {
	gens["Compression"] = gen.PtrOf(gen.OneConstOf(Compression_GZip, Compression_None))
	gens["ConsumerGroup"] = gen.PtrOf(gen.AlphaString())
	gens["DataFormat"] = gen.PtrOf(gen.OneConstOf(
		EventHubDataFormat_APACHEAVRO,
		EventHubDataFormat_AVRO,
		EventHubDataFormat_CSV,
		EventHubDataFormat_JSON,
		EventHubDataFormat_MULTIJSON,
		EventHubDataFormat_ORC,
		EventHubDataFormat_PARQUET,
		EventHubDataFormat_PSV,
		EventHubDataFormat_RAW,
		EventHubDataFormat_SCSV,
		EventHubDataFormat_SINGLEJSON,
		EventHubDataFormat_SOHSV,
		EventHubDataFormat_TSV,
		EventHubDataFormat_TSVE,
		EventHubDataFormat_TXT,
		EventHubDataFormat_W3CLOGFILE))
	gens["DatabaseRouting"] = gen.PtrOf(gen.OneConstOf(EventHubConnectionProperties_DatabaseRouting_Multi, EventHubConnectionProperties_DatabaseRouting_Single))
	gens["EventSystemProperties"] = gen.SliceOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(EventHubDataConnection_Kind_EventHub))
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["MappingRuleName"] = gen.PtrOf(gen.AlphaString())
	gens["RetrievalStartDate"] = gen.PtrOf(gen.AlphaString())
	gens["TableName"] = gen.PtrOf(gen.AlphaString())
}

func Test_EventHubDataConnection_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EventHubDataConnection_STATUS to EventHubDataConnection_STATUS via AssignProperties_To_EventHubDataConnection_STATUS & AssignProperties_From_EventHubDataConnection_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventHubDataConnection_STATUS, EventHubDataConnection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventHubDataConnection_STATUS tests if a specific instance of EventHubDataConnection_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForEventHubDataConnection_STATUS(subject EventHubDataConnection_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.EventHubDataConnection_STATUS
	err := copied.AssignProperties_To_EventHubDataConnection_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EventHubDataConnection_STATUS
	err = actual.AssignProperties_From_EventHubDataConnection_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventHubDataConnection_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventHubDataConnection_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventHubDataConnection_STATUS, EventHubDataConnection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventHubDataConnection_STATUS runs a test to see if a specific instance of EventHubDataConnection_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEventHubDataConnection_STATUS(subject EventHubDataConnection_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventHubDataConnection_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventHubDataConnection_STATUS instances for property testing - lazily instantiated by
// EventHubDataConnection_STATUSGenerator()
var eventHubDataConnection_STATUSGenerator gopter.Gen

// EventHubDataConnection_STATUSGenerator returns a generator of EventHubDataConnection_STATUS instances for property testing.
func EventHubDataConnection_STATUSGenerator() gopter.Gen {
	if eventHubDataConnection_STATUSGenerator != nil {
		return eventHubDataConnection_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventHubDataConnection_STATUS(generators)
	eventHubDataConnection_STATUSGenerator = gen.Struct(reflect.TypeOf(EventHubDataConnection_STATUS{}), generators)

	return eventHubDataConnection_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForEventHubDataConnection_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventHubDataConnection_STATUS(gens map[string]gopter.Gen) {
	gens["Compression"] = gen.PtrOf(gen.OneConstOf(Compression_STATUS_GZip, Compression_STATUS_None))
	gens["ConsumerGroup"] = gen.PtrOf(gen.AlphaString())
	gens["DataFormat"] = gen.PtrOf(gen.OneConstOf(
		EventHubDataFormat_STATUS_APACHEAVRO,
		EventHubDataFormat_STATUS_AVRO,
		EventHubDataFormat_STATUS_CSV,
		EventHubDataFormat_STATUS_JSON,
		EventHubDataFormat_STATUS_MULTIJSON,
		EventHubDataFormat_STATUS_ORC,
		EventHubDataFormat_STATUS_PARQUET,
		EventHubDataFormat_STATUS_PSV,
		EventHubDataFormat_STATUS_RAW,
		EventHubDataFormat_STATUS_SCSV,
		EventHubDataFormat_STATUS_SINGLEJSON,
		EventHubDataFormat_STATUS_SOHSV,
		EventHubDataFormat_STATUS_TSV,
		EventHubDataFormat_STATUS_TSVE,
		EventHubDataFormat_STATUS_TXT,
		EventHubDataFormat_STATUS_W3CLOGFILE))
	gens["DatabaseRouting"] = gen.PtrOf(gen.OneConstOf(EventHubConnectionProperties_DatabaseRouting_STATUS_Multi, EventHubConnectionProperties_DatabaseRouting_STATUS_Single))
	gens["EventHubResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["EventSystemProperties"] = gen.SliceOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(EventHubDataConnection_Kind_STATUS_EventHub))
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["ManagedIdentityObjectId"] = gen.PtrOf(gen.AlphaString())
	gens["ManagedIdentityResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["MappingRuleName"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_STATUS_Canceled,
		ProvisioningState_STATUS_Creating,
		ProvisioningState_STATUS_Deleting,
		ProvisioningState_STATUS_Failed,
		ProvisioningState_STATUS_Moving,
		ProvisioningState_STATUS_Running,
		ProvisioningState_STATUS_Succeeded))
	gens["RetrievalStartDate"] = gen.PtrOf(gen.AlphaString())
	gens["TableName"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_IotHubDataConnection_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IotHubDataConnection to IotHubDataConnection via AssignProperties_To_IotHubDataConnection & AssignProperties_From_IotHubDataConnection returns original",
		prop.ForAll(RunPropertyAssignmentTestForIotHubDataConnection, IotHubDataConnectionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIotHubDataConnection tests if a specific instance of IotHubDataConnection can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForIotHubDataConnection(subject IotHubDataConnection) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.IotHubDataConnection
	err := copied.AssignProperties_To_IotHubDataConnection(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IotHubDataConnection
	err = actual.AssignProperties_From_IotHubDataConnection(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IotHubDataConnection_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IotHubDataConnection via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIotHubDataConnection, IotHubDataConnectionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIotHubDataConnection runs a test to see if a specific instance of IotHubDataConnection round trips to JSON and back losslessly
func RunJSONSerializationTestForIotHubDataConnection(subject IotHubDataConnection) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IotHubDataConnection
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IotHubDataConnection instances for property testing - lazily instantiated by
// IotHubDataConnectionGenerator()
var iotHubDataConnectionGenerator gopter.Gen

// IotHubDataConnectionGenerator returns a generator of IotHubDataConnection instances for property testing.
func IotHubDataConnectionGenerator() gopter.Gen {
	if iotHubDataConnectionGenerator != nil {
		return iotHubDataConnectionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIotHubDataConnection(generators)
	iotHubDataConnectionGenerator = gen.Struct(reflect.TypeOf(IotHubDataConnection{}), generators)

	return iotHubDataConnectionGenerator
}

// AddIndependentPropertyGeneratorsForIotHubDataConnection is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIotHubDataConnection(gens map[string]gopter.Gen) {
	gens["ConsumerGroup"] = gen.PtrOf(gen.AlphaString())
	gens["DataFormat"] = gen.PtrOf(gen.OneConstOf(
		IotHubDataFormat_APACHEAVRO,
		IotHubDataFormat_AVRO,
		IotHubDataFormat_CSV,
		IotHubDataFormat_JSON,
		IotHubDataFormat_MULTIJSON,
		IotHubDataFormat_ORC,
		IotHubDataFormat_PARQUET,
		IotHubDataFormat_PSV,
		IotHubDataFormat_RAW,
		IotHubDataFormat_SCSV,
		IotHubDataFormat_SINGLEJSON,
		IotHubDataFormat_SOHSV,
		IotHubDataFormat_TSV,
		IotHubDataFormat_TSVE,
		IotHubDataFormat_TXT,
		IotHubDataFormat_W3CLOGFILE))
	gens["DatabaseRouting"] = gen.PtrOf(gen.OneConstOf(IotHubConnectionProperties_DatabaseRouting_Multi, IotHubConnectionProperties_DatabaseRouting_Single))
	gens["EventSystemProperties"] = gen.SliceOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(IotHubDataConnection_Kind_IotHub))
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["MappingRuleName"] = gen.PtrOf(gen.AlphaString())
	gens["RetrievalStartDate"] = gen.PtrOf(gen.AlphaString())
	gens["SharedAccessPolicyName"] = gen.PtrOf(gen.AlphaString())
	gens["TableName"] = gen.PtrOf(gen.AlphaString())
}

func Test_IotHubDataConnection_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IotHubDataConnection_STATUS to IotHubDataConnection_STATUS via AssignProperties_To_IotHubDataConnection_STATUS & AssignProperties_From_IotHubDataConnection_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForIotHubDataConnection_STATUS, IotHubDataConnection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIotHubDataConnection_STATUS tests if a specific instance of IotHubDataConnection_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForIotHubDataConnection_STATUS(subject IotHubDataConnection_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.IotHubDataConnection_STATUS
	err := copied.AssignProperties_To_IotHubDataConnection_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IotHubDataConnection_STATUS
	err = actual.AssignProperties_From_IotHubDataConnection_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IotHubDataConnection_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IotHubDataConnection_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIotHubDataConnection_STATUS, IotHubDataConnection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIotHubDataConnection_STATUS runs a test to see if a specific instance of IotHubDataConnection_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForIotHubDataConnection_STATUS(subject IotHubDataConnection_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IotHubDataConnection_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IotHubDataConnection_STATUS instances for property testing - lazily instantiated by
// IotHubDataConnection_STATUSGenerator()
var iotHubDataConnection_STATUSGenerator gopter.Gen

// IotHubDataConnection_STATUSGenerator returns a generator of IotHubDataConnection_STATUS instances for property testing.
func IotHubDataConnection_STATUSGenerator() gopter.Gen {
	if iotHubDataConnection_STATUSGenerator != nil {
		return iotHubDataConnection_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIotHubDataConnection_STATUS(generators)
	iotHubDataConnection_STATUSGenerator = gen.Struct(reflect.TypeOf(IotHubDataConnection_STATUS{}), generators)

	return iotHubDataConnection_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForIotHubDataConnection_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIotHubDataConnection_STATUS(gens map[string]gopter.Gen) {
	gens["ConsumerGroup"] = gen.PtrOf(gen.AlphaString())
	gens["DataFormat"] = gen.PtrOf(gen.OneConstOf(
		IotHubDataFormat_STATUS_APACHEAVRO,
		IotHubDataFormat_STATUS_AVRO,
		IotHubDataFormat_STATUS_CSV,
		IotHubDataFormat_STATUS_JSON,
		IotHubDataFormat_STATUS_MULTIJSON,
		IotHubDataFormat_STATUS_ORC,
		IotHubDataFormat_STATUS_PARQUET,
		IotHubDataFormat_STATUS_PSV,
		IotHubDataFormat_STATUS_RAW,
		IotHubDataFormat_STATUS_SCSV,
		IotHubDataFormat_STATUS_SINGLEJSON,
		IotHubDataFormat_STATUS_SOHSV,
		IotHubDataFormat_STATUS_TSV,
		IotHubDataFormat_STATUS_TSVE,
		IotHubDataFormat_STATUS_TXT,
		IotHubDataFormat_STATUS_W3CLOGFILE))
	gens["DatabaseRouting"] = gen.PtrOf(gen.OneConstOf(IotHubConnectionProperties_DatabaseRouting_STATUS_Multi, IotHubConnectionProperties_DatabaseRouting_STATUS_Single))
	gens["EventSystemProperties"] = gen.SliceOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IotHubResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(IotHubDataConnection_Kind_STATUS_IotHub))
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["MappingRuleName"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_STATUS_Canceled,
		ProvisioningState_STATUS_Creating,
		ProvisioningState_STATUS_Deleting,
		ProvisioningState_STATUS_Failed,
		ProvisioningState_STATUS_Moving,
		ProvisioningState_STATUS_Running,
		ProvisioningState_STATUS_Succeeded))
	gens["RetrievalStartDate"] = gen.PtrOf(gen.AlphaString())
	gens["SharedAccessPolicyName"] = gen.PtrOf(gen.AlphaString())
	gens["TableName"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}
