// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20210101preview

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_Namespaces_SPECARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Namespaces_SPECARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNamespaces_SPECARM, Namespaces_SPECARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNamespaces_SPECARM runs a test to see if a specific instance of Namespaces_SPECARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNamespaces_SPECARM(subject Namespaces_SPECARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Namespaces_SPECARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Namespaces_SPECARM instances for property testing - lazily instantiated by Namespaces_SPECARMGenerator()
var namespaces_specarmGenerator gopter.Gen

// Namespaces_SPECARMGenerator returns a generator of Namespaces_SPECARM instances for property testing.
// We first initialize namespaces_specarmGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Namespaces_SPECARMGenerator() gopter.Gen {
	if namespaces_specarmGenerator != nil {
		return namespaces_specarmGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNamespaces_SPECARM(generators)
	namespaces_specarmGenerator = gen.Struct(reflect.TypeOf(Namespaces_SPECARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNamespaces_SPECARM(generators)
	AddRelatedPropertyGeneratorsForNamespaces_SPECARM(generators)
	namespaces_specarmGenerator = gen.Struct(reflect.TypeOf(Namespaces_SPECARM{}), generators)

	return namespaces_specarmGenerator
}

// AddIndependentPropertyGeneratorsForNamespaces_SPECARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNamespaces_SPECARM(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Location"] = gen.AlphaString()
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNamespaces_SPECARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNamespaces_SPECARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(Identity_SpecARMGenerator())
	gens["Properties"] = gen.PtrOf(SBNamespaceProperties_SpecARMGenerator())
	gens["Sku"] = gen.PtrOf(SBSku_SpecARMGenerator())
}

func Test_Identity_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Identity_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIdentity_SpecARM, Identity_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIdentity_SpecARM runs a test to see if a specific instance of Identity_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIdentity_SpecARM(subject Identity_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Identity_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Identity_SpecARM instances for property testing - lazily instantiated by Identity_SpecARMGenerator()
var identity_specARMGenerator gopter.Gen

// Identity_SpecARMGenerator returns a generator of Identity_SpecARM instances for property testing.
func Identity_SpecARMGenerator() gopter.Gen {
	if identity_specARMGenerator != nil {
		return identity_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentity_SpecARM(generators)
	identity_specARMGenerator = gen.Struct(reflect.TypeOf(Identity_SpecARM{}), generators)

	return identity_specARMGenerator
}

// AddIndependentPropertyGeneratorsForIdentity_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIdentity_SpecARM(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		Identity_Type_SpecNone,
		Identity_Type_SpecSystemAssigned,
		Identity_Type_SpecSystemAssignedUserAssigned,
		Identity_Type_SpecUserAssigned))
}

func Test_SBNamespaceProperties_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SBNamespaceProperties_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSBNamespaceProperties_SpecARM, SBNamespaceProperties_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSBNamespaceProperties_SpecARM runs a test to see if a specific instance of SBNamespaceProperties_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSBNamespaceProperties_SpecARM(subject SBNamespaceProperties_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SBNamespaceProperties_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SBNamespaceProperties_SpecARM instances for property testing - lazily instantiated by
//SBNamespaceProperties_SpecARMGenerator()
var sbNamespaceProperties_specARMGenerator gopter.Gen

// SBNamespaceProperties_SpecARMGenerator returns a generator of SBNamespaceProperties_SpecARM instances for property testing.
// We first initialize sbNamespaceProperties_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SBNamespaceProperties_SpecARMGenerator() gopter.Gen {
	if sbNamespaceProperties_specARMGenerator != nil {
		return sbNamespaceProperties_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSBNamespaceProperties_SpecARM(generators)
	sbNamespaceProperties_specARMGenerator = gen.Struct(reflect.TypeOf(SBNamespaceProperties_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSBNamespaceProperties_SpecARM(generators)
	AddRelatedPropertyGeneratorsForSBNamespaceProperties_SpecARM(generators)
	sbNamespaceProperties_specARMGenerator = gen.Struct(reflect.TypeOf(SBNamespaceProperties_SpecARM{}), generators)

	return sbNamespaceProperties_specARMGenerator
}

// AddIndependentPropertyGeneratorsForSBNamespaceProperties_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSBNamespaceProperties_SpecARM(gens map[string]gopter.Gen) {
	gens["ZoneRedundant"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForSBNamespaceProperties_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSBNamespaceProperties_SpecARM(gens map[string]gopter.Gen) {
	gens["Encryption"] = gen.PtrOf(Encryption_SpecARMGenerator())
	gens["PrivateEndpointConnections"] = gen.SliceOf(PrivateEndpointConnection_SpecARMGenerator())
}

func Test_SBSku_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SBSku_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSBSku_SpecARM, SBSku_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSBSku_SpecARM runs a test to see if a specific instance of SBSku_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSBSku_SpecARM(subject SBSku_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SBSku_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SBSku_SpecARM instances for property testing - lazily instantiated by SBSku_SpecARMGenerator()
var sbSku_specARMGenerator gopter.Gen

// SBSku_SpecARMGenerator returns a generator of SBSku_SpecARM instances for property testing.
func SBSku_SpecARMGenerator() gopter.Gen {
	if sbSku_specARMGenerator != nil {
		return sbSku_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSBSku_SpecARM(generators)
	sbSku_specARMGenerator = gen.Struct(reflect.TypeOf(SBSku_SpecARM{}), generators)

	return sbSku_specARMGenerator
}

// AddIndependentPropertyGeneratorsForSBSku_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSBSku_SpecARM(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.OneConstOf(SBSku_Name_SpecBasic, SBSku_Name_SpecPremium, SBSku_Name_SpecStandard)
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(SBSku_Tier_SpecBasic, SBSku_Tier_SpecPremium, SBSku_Tier_SpecStandard))
}

func Test_Encryption_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Encryption_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryption_SpecARM, Encryption_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryption_SpecARM runs a test to see if a specific instance of Encryption_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryption_SpecARM(subject Encryption_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Encryption_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Encryption_SpecARM instances for property testing - lazily instantiated by Encryption_SpecARMGenerator()
var encryption_specARMGenerator gopter.Gen

// Encryption_SpecARMGenerator returns a generator of Encryption_SpecARM instances for property testing.
// We first initialize encryption_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Encryption_SpecARMGenerator() gopter.Gen {
	if encryption_specARMGenerator != nil {
		return encryption_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryption_SpecARM(generators)
	encryption_specARMGenerator = gen.Struct(reflect.TypeOf(Encryption_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryption_SpecARM(generators)
	AddRelatedPropertyGeneratorsForEncryption_SpecARM(generators)
	encryption_specARMGenerator = gen.Struct(reflect.TypeOf(Encryption_SpecARM{}), generators)

	return encryption_specARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryption_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryption_SpecARM(gens map[string]gopter.Gen) {
	gens["KeySource"] = gen.PtrOf(gen.OneConstOf(Encryption_KeySource_SpecMicrosoftKeyVault))
	gens["RequireInfrastructureEncryption"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForEncryption_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryption_SpecARM(gens map[string]gopter.Gen) {
	gens["KeyVaultProperties"] = gen.SliceOf(KeyVaultProperties_SpecARMGenerator())
}

func Test_PrivateEndpointConnection_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointConnection_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointConnection_SpecARM, PrivateEndpointConnection_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointConnection_SpecARM runs a test to see if a specific instance of PrivateEndpointConnection_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointConnection_SpecARM(subject PrivateEndpointConnection_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointConnection_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointConnection_SpecARM instances for property testing - lazily instantiated by
//PrivateEndpointConnection_SpecARMGenerator()
var privateEndpointConnection_specARMGenerator gopter.Gen

// PrivateEndpointConnection_SpecARMGenerator returns a generator of PrivateEndpointConnection_SpecARM instances for property testing.
func PrivateEndpointConnection_SpecARMGenerator() gopter.Gen {
	if privateEndpointConnection_specARMGenerator != nil {
		return privateEndpointConnection_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForPrivateEndpointConnection_SpecARM(generators)
	privateEndpointConnection_specARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnection_SpecARM{}), generators)

	return privateEndpointConnection_specARMGenerator
}

// AddRelatedPropertyGeneratorsForPrivateEndpointConnection_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateEndpointConnection_SpecARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(PrivateEndpointConnectionProperties_SpecARMGenerator())
}

func Test_KeyVaultProperties_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultProperties_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultProperties_SpecARM, KeyVaultProperties_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultProperties_SpecARM runs a test to see if a specific instance of KeyVaultProperties_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultProperties_SpecARM(subject KeyVaultProperties_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultProperties_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultProperties_SpecARM instances for property testing - lazily instantiated by
//KeyVaultProperties_SpecARMGenerator()
var keyVaultProperties_specARMGenerator gopter.Gen

// KeyVaultProperties_SpecARMGenerator returns a generator of KeyVaultProperties_SpecARM instances for property testing.
// We first initialize keyVaultProperties_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultProperties_SpecARMGenerator() gopter.Gen {
	if keyVaultProperties_specARMGenerator != nil {
		return keyVaultProperties_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultProperties_SpecARM(generators)
	keyVaultProperties_specARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultProperties_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultProperties_SpecARM(generators)
	AddRelatedPropertyGeneratorsForKeyVaultProperties_SpecARM(generators)
	keyVaultProperties_specARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultProperties_SpecARM{}), generators)

	return keyVaultProperties_specARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultProperties_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultProperties_SpecARM(gens map[string]gopter.Gen) {
	gens["KeyName"] = gen.PtrOf(gen.AlphaString())
	gens["KeyVaultUri"] = gen.PtrOf(gen.AlphaString())
	gens["KeyVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForKeyVaultProperties_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultProperties_SpecARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(UserAssignedIdentityProperties_SpecARMGenerator())
}

func Test_PrivateEndpointConnectionProperties_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointConnectionProperties_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointConnectionProperties_SpecARM, PrivateEndpointConnectionProperties_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointConnectionProperties_SpecARM runs a test to see if a specific instance of PrivateEndpointConnectionProperties_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointConnectionProperties_SpecARM(subject PrivateEndpointConnectionProperties_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointConnectionProperties_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointConnectionProperties_SpecARM instances for property testing - lazily instantiated by
//PrivateEndpointConnectionProperties_SpecARMGenerator()
var privateEndpointConnectionProperties_specARMGenerator gopter.Gen

// PrivateEndpointConnectionProperties_SpecARMGenerator returns a generator of PrivateEndpointConnectionProperties_SpecARM instances for property testing.
// We first initialize privateEndpointConnectionProperties_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateEndpointConnectionProperties_SpecARMGenerator() gopter.Gen {
	if privateEndpointConnectionProperties_specARMGenerator != nil {
		return privateEndpointConnectionProperties_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnectionProperties_SpecARM(generators)
	privateEndpointConnectionProperties_specARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnectionProperties_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnectionProperties_SpecARM(generators)
	AddRelatedPropertyGeneratorsForPrivateEndpointConnectionProperties_SpecARM(generators)
	privateEndpointConnectionProperties_specARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnectionProperties_SpecARM{}), generators)

	return privateEndpointConnectionProperties_specARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointConnectionProperties_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointConnectionProperties_SpecARM(gens map[string]gopter.Gen) {
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		PrivateEndpointConnectionProperties_ProvisioningState_SpecCanceled,
		PrivateEndpointConnectionProperties_ProvisioningState_SpecCreating,
		PrivateEndpointConnectionProperties_ProvisioningState_SpecDeleting,
		PrivateEndpointConnectionProperties_ProvisioningState_SpecFailed,
		PrivateEndpointConnectionProperties_ProvisioningState_SpecSucceeded,
		PrivateEndpointConnectionProperties_ProvisioningState_SpecUpdating))
}

// AddRelatedPropertyGeneratorsForPrivateEndpointConnectionProperties_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateEndpointConnectionProperties_SpecARM(gens map[string]gopter.Gen) {
	gens["PrivateEndpoint"] = gen.PtrOf(PrivateEndpoint_SpecARMGenerator())
	gens["PrivateLinkServiceConnectionState"] = gen.PtrOf(ConnectionState_SpecARMGenerator())
}

func Test_ConnectionState_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ConnectionState_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForConnectionState_SpecARM, ConnectionState_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForConnectionState_SpecARM runs a test to see if a specific instance of ConnectionState_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForConnectionState_SpecARM(subject ConnectionState_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ConnectionState_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ConnectionState_SpecARM instances for property testing - lazily instantiated by
//ConnectionState_SpecARMGenerator()
var connectionState_specARMGenerator gopter.Gen

// ConnectionState_SpecARMGenerator returns a generator of ConnectionState_SpecARM instances for property testing.
func ConnectionState_SpecARMGenerator() gopter.Gen {
	if connectionState_specARMGenerator != nil {
		return connectionState_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForConnectionState_SpecARM(generators)
	connectionState_specARMGenerator = gen.Struct(reflect.TypeOf(ConnectionState_SpecARM{}), generators)

	return connectionState_specARMGenerator
}

// AddIndependentPropertyGeneratorsForConnectionState_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForConnectionState_SpecARM(gens map[string]gopter.Gen) {
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(
		ConnectionState_Status_SpecApproved,
		ConnectionState_Status_SpecDisconnected,
		ConnectionState_Status_SpecPending,
		ConnectionState_Status_SpecRejected))
}

func Test_PrivateEndpoint_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpoint_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpoint_SpecARM, PrivateEndpoint_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpoint_SpecARM runs a test to see if a specific instance of PrivateEndpoint_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpoint_SpecARM(subject PrivateEndpoint_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpoint_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpoint_SpecARM instances for property testing - lazily instantiated by
//PrivateEndpoint_SpecARMGenerator()
var privateEndpoint_specARMGenerator gopter.Gen

// PrivateEndpoint_SpecARMGenerator returns a generator of PrivateEndpoint_SpecARM instances for property testing.
func PrivateEndpoint_SpecARMGenerator() gopter.Gen {
	if privateEndpoint_specARMGenerator != nil {
		return privateEndpoint_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpoint_SpecARM(generators)
	privateEndpoint_specARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpoint_SpecARM{}), generators)

	return privateEndpoint_specARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpoint_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpoint_SpecARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_UserAssignedIdentityProperties_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentityProperties_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentityProperties_SpecARM, UserAssignedIdentityProperties_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentityProperties_SpecARM runs a test to see if a specific instance of UserAssignedIdentityProperties_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentityProperties_SpecARM(subject UserAssignedIdentityProperties_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentityProperties_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentityProperties_SpecARM instances for property testing - lazily instantiated by
//UserAssignedIdentityProperties_SpecARMGenerator()
var userAssignedIdentityProperties_specARMGenerator gopter.Gen

// UserAssignedIdentityProperties_SpecARMGenerator returns a generator of UserAssignedIdentityProperties_SpecARM instances for property testing.
func UserAssignedIdentityProperties_SpecARMGenerator() gopter.Gen {
	if userAssignedIdentityProperties_specARMGenerator != nil {
		return userAssignedIdentityProperties_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserAssignedIdentityProperties_SpecARM(generators)
	userAssignedIdentityProperties_specARMGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentityProperties_SpecARM{}), generators)

	return userAssignedIdentityProperties_specARMGenerator
}

// AddIndependentPropertyGeneratorsForUserAssignedIdentityProperties_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserAssignedIdentityProperties_SpecARM(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentity"] = gen.PtrOf(gen.AlphaString())
}
