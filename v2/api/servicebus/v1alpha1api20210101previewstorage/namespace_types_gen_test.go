// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20210101previewstorage

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_Namespace_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Namespace via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNamespace, NamespaceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNamespace runs a test to see if a specific instance of Namespace round trips to JSON and back losslessly
func RunJSONSerializationTestForNamespace(subject Namespace) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Namespace
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Namespace instances for property testing - lazily instantiated by NamespaceGenerator()
var namespaceGenerator gopter.Gen

// NamespaceGenerator returns a generator of Namespace instances for property testing.
func NamespaceGenerator() gopter.Gen {
	if namespaceGenerator != nil {
		return namespaceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForNamespace(generators)
	namespaceGenerator = gen.Struct(reflect.TypeOf(Namespace{}), generators)

	return namespaceGenerator
}

// AddRelatedPropertyGeneratorsForNamespace is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNamespace(gens map[string]gopter.Gen) {
	gens["Spec"] = Namespaces_SPECGenerator()
	gens["Status"] = SBNamespace_StatusGenerator()
}

func Test_Namespaces_SPEC_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Namespaces_SPEC via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNamespaces_SPEC, Namespaces_SPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNamespaces_SPEC runs a test to see if a specific instance of Namespaces_SPEC round trips to JSON and back losslessly
func RunJSONSerializationTestForNamespaces_SPEC(subject Namespaces_SPEC) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Namespaces_SPEC
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Namespaces_SPEC instances for property testing - lazily instantiated by Namespaces_SPECGenerator()
var namespaces_specGenerator gopter.Gen

// Namespaces_SPECGenerator returns a generator of Namespaces_SPEC instances for property testing.
// We first initialize namespaces_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Namespaces_SPECGenerator() gopter.Gen {
	if namespaces_specGenerator != nil {
		return namespaces_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNamespaces_SPEC(generators)
	namespaces_specGenerator = gen.Struct(reflect.TypeOf(Namespaces_SPEC{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNamespaces_SPEC(generators)
	AddRelatedPropertyGeneratorsForNamespaces_SPEC(generators)
	namespaces_specGenerator = gen.Struct(reflect.TypeOf(Namespaces_SPEC{}), generators)

	return namespaces_specGenerator
}

// AddIndependentPropertyGeneratorsForNamespaces_SPEC is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNamespaces_SPEC(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["OriginalVersion"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["ZoneRedundant"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForNamespaces_SPEC is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNamespaces_SPEC(gens map[string]gopter.Gen) {
	gens["Encryption"] = gen.PtrOf(Encryption_SpecGenerator())
	gens["Identity"] = gen.PtrOf(Identity_SpecGenerator())
	gens["PrivateEndpointConnections"] = gen.SliceOf(PrivateEndpointConnection_SpecGenerator())
	gens["Sku"] = gen.PtrOf(SBSku_SpecGenerator())
}

func Test_SBNamespace_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SBNamespace_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSBNamespace_Status, SBNamespace_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSBNamespace_Status runs a test to see if a specific instance of SBNamespace_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSBNamespace_Status(subject SBNamespace_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SBNamespace_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SBNamespace_Status instances for property testing - lazily instantiated by SBNamespace_StatusGenerator()
var sbNamespace_statusGenerator gopter.Gen

// SBNamespace_StatusGenerator returns a generator of SBNamespace_Status instances for property testing.
// We first initialize sbNamespace_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SBNamespace_StatusGenerator() gopter.Gen {
	if sbNamespace_statusGenerator != nil {
		return sbNamespace_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSBNamespace_Status(generators)
	sbNamespace_statusGenerator = gen.Struct(reflect.TypeOf(SBNamespace_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSBNamespace_Status(generators)
	AddRelatedPropertyGeneratorsForSBNamespace_Status(generators)
	sbNamespace_statusGenerator = gen.Struct(reflect.TypeOf(SBNamespace_Status{}), generators)

	return sbNamespace_statusGenerator
}

// AddIndependentPropertyGeneratorsForSBNamespace_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSBNamespace_Status(gens map[string]gopter.Gen) {
	gens["CreatedAt"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["MetricId"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["ServiceBusEndpoint"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["UpdatedAt"] = gen.PtrOf(gen.AlphaString())
	gens["ZoneRedundant"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForSBNamespace_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSBNamespace_Status(gens map[string]gopter.Gen) {
	gens["Encryption"] = gen.PtrOf(Encryption_StatusGenerator())
	gens["Identity"] = gen.PtrOf(Identity_StatusGenerator())
	gens["PrivateEndpointConnections"] = gen.SliceOf(PrivateEndpointConnection_Status_SubResourceEmbeddedGenerator())
	gens["Sku"] = gen.PtrOf(SBSku_StatusGenerator())
	gens["SystemData"] = gen.PtrOf(SystemData_StatusGenerator())
}

func Test_Encryption_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Encryption_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryption_Spec, Encryption_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryption_Spec runs a test to see if a specific instance of Encryption_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryption_Spec(subject Encryption_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Encryption_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Encryption_Spec instances for property testing - lazily instantiated by Encryption_SpecGenerator()
var encryption_specGenerator gopter.Gen

// Encryption_SpecGenerator returns a generator of Encryption_Spec instances for property testing.
// We first initialize encryption_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Encryption_SpecGenerator() gopter.Gen {
	if encryption_specGenerator != nil {
		return encryption_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryption_Spec(generators)
	encryption_specGenerator = gen.Struct(reflect.TypeOf(Encryption_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryption_Spec(generators)
	AddRelatedPropertyGeneratorsForEncryption_Spec(generators)
	encryption_specGenerator = gen.Struct(reflect.TypeOf(Encryption_Spec{}), generators)

	return encryption_specGenerator
}

// AddIndependentPropertyGeneratorsForEncryption_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryption_Spec(gens map[string]gopter.Gen) {
	gens["KeySource"] = gen.PtrOf(gen.AlphaString())
	gens["RequireInfrastructureEncryption"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForEncryption_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryption_Spec(gens map[string]gopter.Gen) {
	gens["KeyVaultProperties"] = gen.SliceOf(KeyVaultProperties_SpecGenerator())
}

func Test_Encryption_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Encryption_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryption_Status, Encryption_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryption_Status runs a test to see if a specific instance of Encryption_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryption_Status(subject Encryption_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Encryption_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Encryption_Status instances for property testing - lazily instantiated by Encryption_StatusGenerator()
var encryption_statusGenerator gopter.Gen

// Encryption_StatusGenerator returns a generator of Encryption_Status instances for property testing.
// We first initialize encryption_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Encryption_StatusGenerator() gopter.Gen {
	if encryption_statusGenerator != nil {
		return encryption_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryption_Status(generators)
	encryption_statusGenerator = gen.Struct(reflect.TypeOf(Encryption_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryption_Status(generators)
	AddRelatedPropertyGeneratorsForEncryption_Status(generators)
	encryption_statusGenerator = gen.Struct(reflect.TypeOf(Encryption_Status{}), generators)

	return encryption_statusGenerator
}

// AddIndependentPropertyGeneratorsForEncryption_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryption_Status(gens map[string]gopter.Gen) {
	gens["KeySource"] = gen.PtrOf(gen.AlphaString())
	gens["RequireInfrastructureEncryption"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForEncryption_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryption_Status(gens map[string]gopter.Gen) {
	gens["KeyVaultProperties"] = gen.SliceOf(KeyVaultProperties_StatusGenerator())
}

func Test_Identity_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Identity_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIdentity_Spec, Identity_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIdentity_Spec runs a test to see if a specific instance of Identity_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForIdentity_Spec(subject Identity_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Identity_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Identity_Spec instances for property testing - lazily instantiated by Identity_SpecGenerator()
var identity_specGenerator gopter.Gen

// Identity_SpecGenerator returns a generator of Identity_Spec instances for property testing.
func Identity_SpecGenerator() gopter.Gen {
	if identity_specGenerator != nil {
		return identity_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentity_Spec(generators)
	identity_specGenerator = gen.Struct(reflect.TypeOf(Identity_Spec{}), generators)

	return identity_specGenerator
}

// AddIndependentPropertyGeneratorsForIdentity_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIdentity_Spec(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_Identity_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Identity_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIdentity_Status, Identity_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIdentity_Status runs a test to see if a specific instance of Identity_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForIdentity_Status(subject Identity_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Identity_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Identity_Status instances for property testing - lazily instantiated by Identity_StatusGenerator()
var identity_statusGenerator gopter.Gen

// Identity_StatusGenerator returns a generator of Identity_Status instances for property testing.
// We first initialize identity_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Identity_StatusGenerator() gopter.Gen {
	if identity_statusGenerator != nil {
		return identity_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentity_Status(generators)
	identity_statusGenerator = gen.Struct(reflect.TypeOf(Identity_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentity_Status(generators)
	AddRelatedPropertyGeneratorsForIdentity_Status(generators)
	identity_statusGenerator = gen.Struct(reflect.TypeOf(Identity_Status{}), generators)

	return identity_statusGenerator
}

// AddIndependentPropertyGeneratorsForIdentity_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIdentity_Status(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForIdentity_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIdentity_Status(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), DictionaryValue_StatusGenerator())
}

func Test_PrivateEndpointConnection_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointConnection_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointConnection_Spec, PrivateEndpointConnection_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointConnection_Spec runs a test to see if a specific instance of PrivateEndpointConnection_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointConnection_Spec(subject PrivateEndpointConnection_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointConnection_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointConnection_Spec instances for property testing - lazily instantiated by
//PrivateEndpointConnection_SpecGenerator()
var privateEndpointConnection_specGenerator gopter.Gen

// PrivateEndpointConnection_SpecGenerator returns a generator of PrivateEndpointConnection_Spec instances for property testing.
// We first initialize privateEndpointConnection_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateEndpointConnection_SpecGenerator() gopter.Gen {
	if privateEndpointConnection_specGenerator != nil {
		return privateEndpointConnection_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnection_Spec(generators)
	privateEndpointConnection_specGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnection_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnection_Spec(generators)
	AddRelatedPropertyGeneratorsForPrivateEndpointConnection_Spec(generators)
	privateEndpointConnection_specGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnection_Spec{}), generators)

	return privateEndpointConnection_specGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointConnection_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointConnection_Spec(gens map[string]gopter.Gen) {
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPrivateEndpointConnection_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateEndpointConnection_Spec(gens map[string]gopter.Gen) {
	gens["PrivateEndpoint"] = gen.PtrOf(PrivateEndpoint_SpecGenerator())
	gens["PrivateLinkServiceConnectionState"] = gen.PtrOf(ConnectionState_SpecGenerator())
}

func Test_PrivateEndpointConnection_Status_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointConnection_Status_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointConnection_Status_SubResourceEmbedded, PrivateEndpointConnection_Status_SubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointConnection_Status_SubResourceEmbedded runs a test to see if a specific instance of PrivateEndpointConnection_Status_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointConnection_Status_SubResourceEmbedded(subject PrivateEndpointConnection_Status_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointConnection_Status_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointConnection_Status_SubResourceEmbedded instances for property testing - lazily
//instantiated by PrivateEndpointConnection_Status_SubResourceEmbeddedGenerator()
var privateEndpointConnection_status_subResourceEmbeddedGenerator gopter.Gen

// PrivateEndpointConnection_Status_SubResourceEmbeddedGenerator returns a generator of PrivateEndpointConnection_Status_SubResourceEmbedded instances for property testing.
// We first initialize privateEndpointConnection_status_subResourceEmbeddedGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateEndpointConnection_Status_SubResourceEmbeddedGenerator() gopter.Gen {
	if privateEndpointConnection_status_subResourceEmbeddedGenerator != nil {
		return privateEndpointConnection_status_subResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnection_Status_SubResourceEmbedded(generators)
	privateEndpointConnection_status_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnection_Status_SubResourceEmbedded{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnection_Status_SubResourceEmbedded(generators)
	AddRelatedPropertyGeneratorsForPrivateEndpointConnection_Status_SubResourceEmbedded(generators)
	privateEndpointConnection_status_subResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnection_Status_SubResourceEmbedded{}), generators)

	return privateEndpointConnection_status_subResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointConnection_Status_SubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointConnection_Status_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPrivateEndpointConnection_Status_SubResourceEmbedded is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateEndpointConnection_Status_SubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["SystemData"] = gen.PtrOf(SystemData_StatusGenerator())
}

func Test_SBSku_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SBSku_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSBSku_Spec, SBSku_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSBSku_Spec runs a test to see if a specific instance of SBSku_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForSBSku_Spec(subject SBSku_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SBSku_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SBSku_Spec instances for property testing - lazily instantiated by SBSku_SpecGenerator()
var sbSku_specGenerator gopter.Gen

// SBSku_SpecGenerator returns a generator of SBSku_Spec instances for property testing.
func SBSku_SpecGenerator() gopter.Gen {
	if sbSku_specGenerator != nil {
		return sbSku_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSBSku_Spec(generators)
	sbSku_specGenerator = gen.Struct(reflect.TypeOf(SBSku_Spec{}), generators)

	return sbSku_specGenerator
}

// AddIndependentPropertyGeneratorsForSBSku_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSBSku_Spec(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
}

func Test_SBSku_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SBSku_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSBSku_Status, SBSku_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSBSku_Status runs a test to see if a specific instance of SBSku_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSBSku_Status(subject SBSku_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SBSku_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SBSku_Status instances for property testing - lazily instantiated by SBSku_StatusGenerator()
var sbSku_statusGenerator gopter.Gen

// SBSku_StatusGenerator returns a generator of SBSku_Status instances for property testing.
func SBSku_StatusGenerator() gopter.Gen {
	if sbSku_statusGenerator != nil {
		return sbSku_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSBSku_Status(generators)
	sbSku_statusGenerator = gen.Struct(reflect.TypeOf(SBSku_Status{}), generators)

	return sbSku_statusGenerator
}

// AddIndependentPropertyGeneratorsForSBSku_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSBSku_Status(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
}

func Test_SystemData_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SystemData_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSystemData_Status, SystemData_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSystemData_Status runs a test to see if a specific instance of SystemData_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSystemData_Status(subject SystemData_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SystemData_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SystemData_Status instances for property testing - lazily instantiated by SystemData_StatusGenerator()
var systemData_statusGenerator gopter.Gen

// SystemData_StatusGenerator returns a generator of SystemData_Status instances for property testing.
func SystemData_StatusGenerator() gopter.Gen {
	if systemData_statusGenerator != nil {
		return systemData_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSystemData_Status(generators)
	systemData_statusGenerator = gen.Struct(reflect.TypeOf(SystemData_Status{}), generators)

	return systemData_statusGenerator
}

// AddIndependentPropertyGeneratorsForSystemData_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSystemData_Status(gens map[string]gopter.Gen) {
	gens["CreatedAt"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedBy"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedByType"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedAt"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedBy"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedByType"] = gen.PtrOf(gen.AlphaString())
}

func Test_ConnectionState_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ConnectionState_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForConnectionState_Spec, ConnectionState_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForConnectionState_Spec runs a test to see if a specific instance of ConnectionState_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForConnectionState_Spec(subject ConnectionState_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ConnectionState_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ConnectionState_Spec instances for property testing - lazily instantiated by
//ConnectionState_SpecGenerator()
var connectionState_specGenerator gopter.Gen

// ConnectionState_SpecGenerator returns a generator of ConnectionState_Spec instances for property testing.
func ConnectionState_SpecGenerator() gopter.Gen {
	if connectionState_specGenerator != nil {
		return connectionState_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForConnectionState_Spec(generators)
	connectionState_specGenerator = gen.Struct(reflect.TypeOf(ConnectionState_Spec{}), generators)

	return connectionState_specGenerator
}

// AddIndependentPropertyGeneratorsForConnectionState_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForConnectionState_Spec(gens map[string]gopter.Gen) {
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.AlphaString())
}

func Test_DictionaryValue_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DictionaryValue_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDictionaryValue_Status, DictionaryValue_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDictionaryValue_Status runs a test to see if a specific instance of DictionaryValue_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForDictionaryValue_Status(subject DictionaryValue_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DictionaryValue_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DictionaryValue_Status instances for property testing - lazily instantiated by
//DictionaryValue_StatusGenerator()
var dictionaryValue_statusGenerator gopter.Gen

// DictionaryValue_StatusGenerator returns a generator of DictionaryValue_Status instances for property testing.
func DictionaryValue_StatusGenerator() gopter.Gen {
	if dictionaryValue_statusGenerator != nil {
		return dictionaryValue_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDictionaryValue_Status(generators)
	dictionaryValue_statusGenerator = gen.Struct(reflect.TypeOf(DictionaryValue_Status{}), generators)

	return dictionaryValue_statusGenerator
}

// AddIndependentPropertyGeneratorsForDictionaryValue_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDictionaryValue_Status(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_KeyVaultProperties_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultProperties_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultProperties_Spec, KeyVaultProperties_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultProperties_Spec runs a test to see if a specific instance of KeyVaultProperties_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultProperties_Spec(subject KeyVaultProperties_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultProperties_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultProperties_Spec instances for property testing - lazily instantiated by
//KeyVaultProperties_SpecGenerator()
var keyVaultProperties_specGenerator gopter.Gen

// KeyVaultProperties_SpecGenerator returns a generator of KeyVaultProperties_Spec instances for property testing.
// We first initialize keyVaultProperties_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultProperties_SpecGenerator() gopter.Gen {
	if keyVaultProperties_specGenerator != nil {
		return keyVaultProperties_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultProperties_Spec(generators)
	keyVaultProperties_specGenerator = gen.Struct(reflect.TypeOf(KeyVaultProperties_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultProperties_Spec(generators)
	AddRelatedPropertyGeneratorsForKeyVaultProperties_Spec(generators)
	keyVaultProperties_specGenerator = gen.Struct(reflect.TypeOf(KeyVaultProperties_Spec{}), generators)

	return keyVaultProperties_specGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultProperties_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultProperties_Spec(gens map[string]gopter.Gen) {
	gens["KeyName"] = gen.PtrOf(gen.AlphaString())
	gens["KeyVaultUri"] = gen.PtrOf(gen.AlphaString())
	gens["KeyVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForKeyVaultProperties_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultProperties_Spec(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(UserAssignedIdentityProperties_SpecGenerator())
}

func Test_KeyVaultProperties_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultProperties_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultProperties_Status, KeyVaultProperties_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultProperties_Status runs a test to see if a specific instance of KeyVaultProperties_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultProperties_Status(subject KeyVaultProperties_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultProperties_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultProperties_Status instances for property testing - lazily instantiated by
//KeyVaultProperties_StatusGenerator()
var keyVaultProperties_statusGenerator gopter.Gen

// KeyVaultProperties_StatusGenerator returns a generator of KeyVaultProperties_Status instances for property testing.
// We first initialize keyVaultProperties_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultProperties_StatusGenerator() gopter.Gen {
	if keyVaultProperties_statusGenerator != nil {
		return keyVaultProperties_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultProperties_Status(generators)
	keyVaultProperties_statusGenerator = gen.Struct(reflect.TypeOf(KeyVaultProperties_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultProperties_Status(generators)
	AddRelatedPropertyGeneratorsForKeyVaultProperties_Status(generators)
	keyVaultProperties_statusGenerator = gen.Struct(reflect.TypeOf(KeyVaultProperties_Status{}), generators)

	return keyVaultProperties_statusGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultProperties_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultProperties_Status(gens map[string]gopter.Gen) {
	gens["KeyName"] = gen.PtrOf(gen.AlphaString())
	gens["KeyVaultUri"] = gen.PtrOf(gen.AlphaString())
	gens["KeyVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForKeyVaultProperties_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultProperties_Status(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(UserAssignedIdentityProperties_StatusGenerator())
}

func Test_PrivateEndpoint_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpoint_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpoint_Spec, PrivateEndpoint_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpoint_Spec runs a test to see if a specific instance of PrivateEndpoint_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpoint_Spec(subject PrivateEndpoint_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpoint_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpoint_Spec instances for property testing - lazily instantiated by
//PrivateEndpoint_SpecGenerator()
var privateEndpoint_specGenerator gopter.Gen

// PrivateEndpoint_SpecGenerator returns a generator of PrivateEndpoint_Spec instances for property testing.
func PrivateEndpoint_SpecGenerator() gopter.Gen {
	if privateEndpoint_specGenerator != nil {
		return privateEndpoint_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	privateEndpoint_specGenerator = gen.Struct(reflect.TypeOf(PrivateEndpoint_Spec{}), generators)

	return privateEndpoint_specGenerator
}

func Test_UserAssignedIdentityProperties_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentityProperties_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentityProperties_Spec, UserAssignedIdentityProperties_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentityProperties_Spec runs a test to see if a specific instance of UserAssignedIdentityProperties_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentityProperties_Spec(subject UserAssignedIdentityProperties_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentityProperties_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentityProperties_Spec instances for property testing - lazily instantiated by
//UserAssignedIdentityProperties_SpecGenerator()
var userAssignedIdentityProperties_specGenerator gopter.Gen

// UserAssignedIdentityProperties_SpecGenerator returns a generator of UserAssignedIdentityProperties_Spec instances for property testing.
func UserAssignedIdentityProperties_SpecGenerator() gopter.Gen {
	if userAssignedIdentityProperties_specGenerator != nil {
		return userAssignedIdentityProperties_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	userAssignedIdentityProperties_specGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentityProperties_Spec{}), generators)

	return userAssignedIdentityProperties_specGenerator
}

func Test_UserAssignedIdentityProperties_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentityProperties_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentityProperties_Status, UserAssignedIdentityProperties_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentityProperties_Status runs a test to see if a specific instance of UserAssignedIdentityProperties_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentityProperties_Status(subject UserAssignedIdentityProperties_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentityProperties_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentityProperties_Status instances for property testing - lazily instantiated by
//UserAssignedIdentityProperties_StatusGenerator()
var userAssignedIdentityProperties_statusGenerator gopter.Gen

// UserAssignedIdentityProperties_StatusGenerator returns a generator of UserAssignedIdentityProperties_Status instances for property testing.
func UserAssignedIdentityProperties_StatusGenerator() gopter.Gen {
	if userAssignedIdentityProperties_statusGenerator != nil {
		return userAssignedIdentityProperties_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserAssignedIdentityProperties_Status(generators)
	userAssignedIdentityProperties_statusGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentityProperties_Status{}), generators)

	return userAssignedIdentityProperties_statusGenerator
}

// AddIndependentPropertyGeneratorsForUserAssignedIdentityProperties_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserAssignedIdentityProperties_Status(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentity"] = gen.PtrOf(gen.AlphaString())
}
