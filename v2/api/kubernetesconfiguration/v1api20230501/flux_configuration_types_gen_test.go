// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20230501

import (
	"encoding/json"
	storage "github.com/Azure/azure-service-operator/v2/api/kubernetesconfiguration/v1api20230501/storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_AzureBlobDefinition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AzureBlobDefinition to AzureBlobDefinition via AssignProperties_To_AzureBlobDefinition & AssignProperties_From_AzureBlobDefinition returns original",
		prop.ForAll(RunPropertyAssignmentTestForAzureBlobDefinition, AzureBlobDefinitionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAzureBlobDefinition tests if a specific instance of AzureBlobDefinition can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAzureBlobDefinition(subject AzureBlobDefinition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AzureBlobDefinition
	err := copied.AssignProperties_To_AzureBlobDefinition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AzureBlobDefinition
	err = actual.AssignProperties_From_AzureBlobDefinition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AzureBlobDefinition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureBlobDefinition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureBlobDefinition, AzureBlobDefinitionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureBlobDefinition runs a test to see if a specific instance of AzureBlobDefinition round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureBlobDefinition(subject AzureBlobDefinition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureBlobDefinition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureBlobDefinition instances for property testing - lazily instantiated by
// AzureBlobDefinitionGenerator()
var azureBlobDefinitionGenerator gopter.Gen

// AzureBlobDefinitionGenerator returns a generator of AzureBlobDefinition instances for property testing.
// We first initialize azureBlobDefinitionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureBlobDefinitionGenerator() gopter.Gen {
	if azureBlobDefinitionGenerator != nil {
		return azureBlobDefinitionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureBlobDefinition(generators)
	azureBlobDefinitionGenerator = gen.Struct(reflect.TypeOf(AzureBlobDefinition{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureBlobDefinition(generators)
	AddRelatedPropertyGeneratorsForAzureBlobDefinition(generators)
	azureBlobDefinitionGenerator = gen.Struct(reflect.TypeOf(AzureBlobDefinition{}), generators)

	return azureBlobDefinitionGenerator
}

// AddIndependentPropertyGeneratorsForAzureBlobDefinition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureBlobDefinition(gens map[string]gopter.Gen) {
	gens["ContainerName"] = gen.PtrOf(gen.AlphaString())
	gens["LocalAuthRef"] = gen.PtrOf(gen.AlphaString())
	gens["SyncIntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["TimeoutInSeconds"] = gen.PtrOf(gen.Int())
	gens["Url"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAzureBlobDefinition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureBlobDefinition(gens map[string]gopter.Gen) {
	gens["ManagedIdentity"] = gen.PtrOf(ManagedIdentityDefinitionGenerator())
	gens["ServicePrincipal"] = gen.PtrOf(ServicePrincipalDefinitionGenerator())
}

func Test_AzureBlobDefinition_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AzureBlobDefinition_STATUS to AzureBlobDefinition_STATUS via AssignProperties_To_AzureBlobDefinition_STATUS & AssignProperties_From_AzureBlobDefinition_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAzureBlobDefinition_STATUS, AzureBlobDefinition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAzureBlobDefinition_STATUS tests if a specific instance of AzureBlobDefinition_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAzureBlobDefinition_STATUS(subject AzureBlobDefinition_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AzureBlobDefinition_STATUS
	err := copied.AssignProperties_To_AzureBlobDefinition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AzureBlobDefinition_STATUS
	err = actual.AssignProperties_From_AzureBlobDefinition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AzureBlobDefinition_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureBlobDefinition_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureBlobDefinition_STATUS, AzureBlobDefinition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureBlobDefinition_STATUS runs a test to see if a specific instance of AzureBlobDefinition_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureBlobDefinition_STATUS(subject AzureBlobDefinition_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureBlobDefinition_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureBlobDefinition_STATUS instances for property testing - lazily instantiated by
// AzureBlobDefinition_STATUSGenerator()
var azureBlobDefinition_STATUSGenerator gopter.Gen

// AzureBlobDefinition_STATUSGenerator returns a generator of AzureBlobDefinition_STATUS instances for property testing.
// We first initialize azureBlobDefinition_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureBlobDefinition_STATUSGenerator() gopter.Gen {
	if azureBlobDefinition_STATUSGenerator != nil {
		return azureBlobDefinition_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureBlobDefinition_STATUS(generators)
	azureBlobDefinition_STATUSGenerator = gen.Struct(reflect.TypeOf(AzureBlobDefinition_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureBlobDefinition_STATUS(generators)
	AddRelatedPropertyGeneratorsForAzureBlobDefinition_STATUS(generators)
	azureBlobDefinition_STATUSGenerator = gen.Struct(reflect.TypeOf(AzureBlobDefinition_STATUS{}), generators)

	return azureBlobDefinition_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAzureBlobDefinition_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureBlobDefinition_STATUS(gens map[string]gopter.Gen) {
	gens["ContainerName"] = gen.PtrOf(gen.AlphaString())
	gens["LocalAuthRef"] = gen.PtrOf(gen.AlphaString())
	gens["SyncIntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["TimeoutInSeconds"] = gen.PtrOf(gen.Int())
	gens["Url"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAzureBlobDefinition_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureBlobDefinition_STATUS(gens map[string]gopter.Gen) {
	gens["ManagedIdentity"] = gen.PtrOf(ManagedIdentityDefinition_STATUSGenerator())
	gens["ServicePrincipal"] = gen.PtrOf(ServicePrincipalDefinition_STATUSGenerator())
}

func Test_BucketDefinition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BucketDefinition to BucketDefinition via AssignProperties_To_BucketDefinition & AssignProperties_From_BucketDefinition returns original",
		prop.ForAll(RunPropertyAssignmentTestForBucketDefinition, BucketDefinitionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBucketDefinition tests if a specific instance of BucketDefinition can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForBucketDefinition(subject BucketDefinition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.BucketDefinition
	err := copied.AssignProperties_To_BucketDefinition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BucketDefinition
	err = actual.AssignProperties_From_BucketDefinition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BucketDefinition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BucketDefinition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBucketDefinition, BucketDefinitionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBucketDefinition runs a test to see if a specific instance of BucketDefinition round trips to JSON and back losslessly
func RunJSONSerializationTestForBucketDefinition(subject BucketDefinition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BucketDefinition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BucketDefinition instances for property testing - lazily instantiated by BucketDefinitionGenerator()
var bucketDefinitionGenerator gopter.Gen

// BucketDefinitionGenerator returns a generator of BucketDefinition instances for property testing.
func BucketDefinitionGenerator() gopter.Gen {
	if bucketDefinitionGenerator != nil {
		return bucketDefinitionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBucketDefinition(generators)
	bucketDefinitionGenerator = gen.Struct(reflect.TypeOf(BucketDefinition{}), generators)

	return bucketDefinitionGenerator
}

// AddIndependentPropertyGeneratorsForBucketDefinition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBucketDefinition(gens map[string]gopter.Gen) {
	gens["BucketName"] = gen.PtrOf(gen.AlphaString())
	gens["Insecure"] = gen.PtrOf(gen.Bool())
	gens["LocalAuthRef"] = gen.PtrOf(gen.AlphaString())
	gens["SyncIntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["TimeoutInSeconds"] = gen.PtrOf(gen.Int())
	gens["Url"] = gen.PtrOf(gen.AlphaString())
}

func Test_BucketDefinition_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BucketDefinition_STATUS to BucketDefinition_STATUS via AssignProperties_To_BucketDefinition_STATUS & AssignProperties_From_BucketDefinition_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForBucketDefinition_STATUS, BucketDefinition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBucketDefinition_STATUS tests if a specific instance of BucketDefinition_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForBucketDefinition_STATUS(subject BucketDefinition_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.BucketDefinition_STATUS
	err := copied.AssignProperties_To_BucketDefinition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BucketDefinition_STATUS
	err = actual.AssignProperties_From_BucketDefinition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BucketDefinition_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BucketDefinition_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBucketDefinition_STATUS, BucketDefinition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBucketDefinition_STATUS runs a test to see if a specific instance of BucketDefinition_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForBucketDefinition_STATUS(subject BucketDefinition_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BucketDefinition_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BucketDefinition_STATUS instances for property testing - lazily instantiated by
// BucketDefinition_STATUSGenerator()
var bucketDefinition_STATUSGenerator gopter.Gen

// BucketDefinition_STATUSGenerator returns a generator of BucketDefinition_STATUS instances for property testing.
func BucketDefinition_STATUSGenerator() gopter.Gen {
	if bucketDefinition_STATUSGenerator != nil {
		return bucketDefinition_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBucketDefinition_STATUS(generators)
	bucketDefinition_STATUSGenerator = gen.Struct(reflect.TypeOf(BucketDefinition_STATUS{}), generators)

	return bucketDefinition_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForBucketDefinition_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBucketDefinition_STATUS(gens map[string]gopter.Gen) {
	gens["BucketName"] = gen.PtrOf(gen.AlphaString())
	gens["Insecure"] = gen.PtrOf(gen.Bool())
	gens["LocalAuthRef"] = gen.PtrOf(gen.AlphaString())
	gens["SyncIntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["TimeoutInSeconds"] = gen.PtrOf(gen.Int())
	gens["Url"] = gen.PtrOf(gen.AlphaString())
}

func Test_FluxConfiguration_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	parameters.MinSuccessfulTests = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FluxConfiguration to hub returns original",
		prop.ForAll(RunResourceConversionTestForFluxConfiguration, FluxConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForFluxConfiguration tests if a specific instance of FluxConfiguration round trips to the hub storage version and back losslessly
func RunResourceConversionTestForFluxConfiguration(subject FluxConfiguration) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub storage.FluxConfiguration
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual FluxConfiguration
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FluxConfiguration_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FluxConfiguration to FluxConfiguration via AssignProperties_To_FluxConfiguration & AssignProperties_From_FluxConfiguration returns original",
		prop.ForAll(RunPropertyAssignmentTestForFluxConfiguration, FluxConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFluxConfiguration tests if a specific instance of FluxConfiguration can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFluxConfiguration(subject FluxConfiguration) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FluxConfiguration
	err := copied.AssignProperties_To_FluxConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FluxConfiguration
	err = actual.AssignProperties_From_FluxConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FluxConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FluxConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFluxConfiguration, FluxConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFluxConfiguration runs a test to see if a specific instance of FluxConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForFluxConfiguration(subject FluxConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FluxConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FluxConfiguration instances for property testing - lazily instantiated by FluxConfigurationGenerator()
var fluxConfigurationGenerator gopter.Gen

// FluxConfigurationGenerator returns a generator of FluxConfiguration instances for property testing.
func FluxConfigurationGenerator() gopter.Gen {
	if fluxConfigurationGenerator != nil {
		return fluxConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForFluxConfiguration(generators)
	fluxConfigurationGenerator = gen.Struct(reflect.TypeOf(FluxConfiguration{}), generators)

	return fluxConfigurationGenerator
}

// AddRelatedPropertyGeneratorsForFluxConfiguration is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFluxConfiguration(gens map[string]gopter.Gen) {
	gens["Spec"] = FluxConfiguration_SpecGenerator()
	gens["Status"] = FluxConfiguration_STATUSGenerator()
}

func Test_FluxConfigurationOperatorSpec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FluxConfigurationOperatorSpec to FluxConfigurationOperatorSpec via AssignProperties_To_FluxConfigurationOperatorSpec & AssignProperties_From_FluxConfigurationOperatorSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForFluxConfigurationOperatorSpec, FluxConfigurationOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFluxConfigurationOperatorSpec tests if a specific instance of FluxConfigurationOperatorSpec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFluxConfigurationOperatorSpec(subject FluxConfigurationOperatorSpec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FluxConfigurationOperatorSpec
	err := copied.AssignProperties_To_FluxConfigurationOperatorSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FluxConfigurationOperatorSpec
	err = actual.AssignProperties_From_FluxConfigurationOperatorSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FluxConfigurationOperatorSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FluxConfigurationOperatorSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFluxConfigurationOperatorSpec, FluxConfigurationOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFluxConfigurationOperatorSpec runs a test to see if a specific instance of FluxConfigurationOperatorSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForFluxConfigurationOperatorSpec(subject FluxConfigurationOperatorSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FluxConfigurationOperatorSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FluxConfigurationOperatorSpec instances for property testing - lazily instantiated by
// FluxConfigurationOperatorSpecGenerator()
var fluxConfigurationOperatorSpecGenerator gopter.Gen

// FluxConfigurationOperatorSpecGenerator returns a generator of FluxConfigurationOperatorSpec instances for property testing.
func FluxConfigurationOperatorSpecGenerator() gopter.Gen {
	if fluxConfigurationOperatorSpecGenerator != nil {
		return fluxConfigurationOperatorSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	fluxConfigurationOperatorSpecGenerator = gen.Struct(reflect.TypeOf(FluxConfigurationOperatorSpec{}), generators)

	return fluxConfigurationOperatorSpecGenerator
}

func Test_FluxConfiguration_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FluxConfiguration_STATUS to FluxConfiguration_STATUS via AssignProperties_To_FluxConfiguration_STATUS & AssignProperties_From_FluxConfiguration_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForFluxConfiguration_STATUS, FluxConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFluxConfiguration_STATUS tests if a specific instance of FluxConfiguration_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFluxConfiguration_STATUS(subject FluxConfiguration_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FluxConfiguration_STATUS
	err := copied.AssignProperties_To_FluxConfiguration_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FluxConfiguration_STATUS
	err = actual.AssignProperties_From_FluxConfiguration_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FluxConfiguration_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FluxConfiguration_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFluxConfiguration_STATUS, FluxConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFluxConfiguration_STATUS runs a test to see if a specific instance of FluxConfiguration_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFluxConfiguration_STATUS(subject FluxConfiguration_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FluxConfiguration_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FluxConfiguration_STATUS instances for property testing - lazily instantiated by
// FluxConfiguration_STATUSGenerator()
var fluxConfiguration_STATUSGenerator gopter.Gen

// FluxConfiguration_STATUSGenerator returns a generator of FluxConfiguration_STATUS instances for property testing.
// We first initialize fluxConfiguration_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FluxConfiguration_STATUSGenerator() gopter.Gen {
	if fluxConfiguration_STATUSGenerator != nil {
		return fluxConfiguration_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFluxConfiguration_STATUS(generators)
	fluxConfiguration_STATUSGenerator = gen.Struct(reflect.TypeOf(FluxConfiguration_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFluxConfiguration_STATUS(generators)
	AddRelatedPropertyGeneratorsForFluxConfiguration_STATUS(generators)
	fluxConfiguration_STATUSGenerator = gen.Struct(reflect.TypeOf(FluxConfiguration_STATUS{}), generators)

	return fluxConfiguration_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFluxConfiguration_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFluxConfiguration_STATUS(gens map[string]gopter.Gen) {
	gens["ComplianceState"] = gen.PtrOf(gen.OneConstOf(
		FluxComplianceStateDefinition_STATUS_Compliant,
		FluxComplianceStateDefinition_STATUS_NonCompliant,
		FluxComplianceStateDefinition_STATUS_Pending,
		FluxComplianceStateDefinition_STATUS_Suspended,
		FluxComplianceStateDefinition_STATUS_Unknown))
	gens["ConfigurationProtectedSettings"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["ErrorMessage"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Namespace"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningStateDefinition_STATUS_Canceled,
		ProvisioningStateDefinition_STATUS_Creating,
		ProvisioningStateDefinition_STATUS_Deleting,
		ProvisioningStateDefinition_STATUS_Failed,
		ProvisioningStateDefinition_STATUS_Succeeded,
		ProvisioningStateDefinition_STATUS_Updating))
	gens["ReconciliationWaitDuration"] = gen.PtrOf(gen.AlphaString())
	gens["RepositoryPublicKey"] = gen.PtrOf(gen.AlphaString())
	gens["Scope"] = gen.PtrOf(gen.OneConstOf(ScopeDefinition_STATUS_Cluster, ScopeDefinition_STATUS_Namespace))
	gens["SourceKind"] = gen.PtrOf(gen.OneConstOf(SourceKindDefinition_STATUS_AzureBlob, SourceKindDefinition_STATUS_Bucket, SourceKindDefinition_STATUS_GitRepository))
	gens["SourceSyncedCommitId"] = gen.PtrOf(gen.AlphaString())
	gens["SourceUpdatedAt"] = gen.PtrOf(gen.AlphaString())
	gens["StatusUpdatedAt"] = gen.PtrOf(gen.AlphaString())
	gens["Suspend"] = gen.PtrOf(gen.Bool())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["WaitForReconciliation"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForFluxConfiguration_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFluxConfiguration_STATUS(gens map[string]gopter.Gen) {
	gens["AzureBlob"] = gen.PtrOf(AzureBlobDefinition_STATUSGenerator())
	gens["Bucket"] = gen.PtrOf(BucketDefinition_STATUSGenerator())
	gens["GitRepository"] = gen.PtrOf(GitRepositoryDefinition_STATUSGenerator())
	gens["Kustomizations"] = gen.MapOf(
		gen.AlphaString(),
		KustomizationDefinition_STATUSGenerator())
	gens["Statuses"] = gen.SliceOf(ObjectStatusDefinition_STATUSGenerator())
}

func Test_FluxConfiguration_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FluxConfiguration_Spec to FluxConfiguration_Spec via AssignProperties_To_FluxConfiguration_Spec & AssignProperties_From_FluxConfiguration_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForFluxConfiguration_Spec, FluxConfiguration_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFluxConfiguration_Spec tests if a specific instance of FluxConfiguration_Spec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFluxConfiguration_Spec(subject FluxConfiguration_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FluxConfiguration_Spec
	err := copied.AssignProperties_To_FluxConfiguration_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FluxConfiguration_Spec
	err = actual.AssignProperties_From_FluxConfiguration_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FluxConfiguration_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FluxConfiguration_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFluxConfiguration_Spec, FluxConfiguration_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFluxConfiguration_Spec runs a test to see if a specific instance of FluxConfiguration_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForFluxConfiguration_Spec(subject FluxConfiguration_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FluxConfiguration_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FluxConfiguration_Spec instances for property testing - lazily instantiated by
// FluxConfiguration_SpecGenerator()
var fluxConfiguration_SpecGenerator gopter.Gen

// FluxConfiguration_SpecGenerator returns a generator of FluxConfiguration_Spec instances for property testing.
// We first initialize fluxConfiguration_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FluxConfiguration_SpecGenerator() gopter.Gen {
	if fluxConfiguration_SpecGenerator != nil {
		return fluxConfiguration_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFluxConfiguration_Spec(generators)
	fluxConfiguration_SpecGenerator = gen.Struct(reflect.TypeOf(FluxConfiguration_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFluxConfiguration_Spec(generators)
	AddRelatedPropertyGeneratorsForFluxConfiguration_Spec(generators)
	fluxConfiguration_SpecGenerator = gen.Struct(reflect.TypeOf(FluxConfiguration_Spec{}), generators)

	return fluxConfiguration_SpecGenerator
}

// AddIndependentPropertyGeneratorsForFluxConfiguration_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFluxConfiguration_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Namespace"] = gen.PtrOf(gen.AlphaString())
	gens["ReconciliationWaitDuration"] = gen.PtrOf(gen.AlphaString())
	gens["Scope"] = gen.PtrOf(gen.OneConstOf(ScopeDefinition_Cluster, ScopeDefinition_Namespace))
	gens["SourceKind"] = gen.PtrOf(gen.OneConstOf(SourceKindDefinition_AzureBlob, SourceKindDefinition_Bucket, SourceKindDefinition_GitRepository))
	gens["Suspend"] = gen.PtrOf(gen.Bool())
	gens["WaitForReconciliation"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForFluxConfiguration_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFluxConfiguration_Spec(gens map[string]gopter.Gen) {
	gens["AzureBlob"] = gen.PtrOf(AzureBlobDefinitionGenerator())
	gens["Bucket"] = gen.PtrOf(BucketDefinitionGenerator())
	gens["GitRepository"] = gen.PtrOf(GitRepositoryDefinitionGenerator())
	gens["Kustomizations"] = gen.MapOf(
		gen.AlphaString(),
		KustomizationDefinitionGenerator())
	gens["OperatorSpec"] = gen.PtrOf(FluxConfigurationOperatorSpecGenerator())
}

func Test_GitRepositoryDefinition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from GitRepositoryDefinition to GitRepositoryDefinition via AssignProperties_To_GitRepositoryDefinition & AssignProperties_From_GitRepositoryDefinition returns original",
		prop.ForAll(RunPropertyAssignmentTestForGitRepositoryDefinition, GitRepositoryDefinitionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForGitRepositoryDefinition tests if a specific instance of GitRepositoryDefinition can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForGitRepositoryDefinition(subject GitRepositoryDefinition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.GitRepositoryDefinition
	err := copied.AssignProperties_To_GitRepositoryDefinition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual GitRepositoryDefinition
	err = actual.AssignProperties_From_GitRepositoryDefinition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_GitRepositoryDefinition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GitRepositoryDefinition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGitRepositoryDefinition, GitRepositoryDefinitionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGitRepositoryDefinition runs a test to see if a specific instance of GitRepositoryDefinition round trips to JSON and back losslessly
func RunJSONSerializationTestForGitRepositoryDefinition(subject GitRepositoryDefinition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GitRepositoryDefinition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GitRepositoryDefinition instances for property testing - lazily instantiated by
// GitRepositoryDefinitionGenerator()
var gitRepositoryDefinitionGenerator gopter.Gen

// GitRepositoryDefinitionGenerator returns a generator of GitRepositoryDefinition instances for property testing.
// We first initialize gitRepositoryDefinitionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func GitRepositoryDefinitionGenerator() gopter.Gen {
	if gitRepositoryDefinitionGenerator != nil {
		return gitRepositoryDefinitionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGitRepositoryDefinition(generators)
	gitRepositoryDefinitionGenerator = gen.Struct(reflect.TypeOf(GitRepositoryDefinition{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGitRepositoryDefinition(generators)
	AddRelatedPropertyGeneratorsForGitRepositoryDefinition(generators)
	gitRepositoryDefinitionGenerator = gen.Struct(reflect.TypeOf(GitRepositoryDefinition{}), generators)

	return gitRepositoryDefinitionGenerator
}

// AddIndependentPropertyGeneratorsForGitRepositoryDefinition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGitRepositoryDefinition(gens map[string]gopter.Gen) {
	gens["HttpsUser"] = gen.PtrOf(gen.AlphaString())
	gens["LocalAuthRef"] = gen.PtrOf(gen.AlphaString())
	gens["SshKnownHosts"] = gen.PtrOf(gen.AlphaString())
	gens["SyncIntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["TimeoutInSeconds"] = gen.PtrOf(gen.Int())
	gens["Url"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForGitRepositoryDefinition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForGitRepositoryDefinition(gens map[string]gopter.Gen) {
	gens["RepositoryRef"] = gen.PtrOf(RepositoryRefDefinitionGenerator())
}

func Test_GitRepositoryDefinition_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from GitRepositoryDefinition_STATUS to GitRepositoryDefinition_STATUS via AssignProperties_To_GitRepositoryDefinition_STATUS & AssignProperties_From_GitRepositoryDefinition_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForGitRepositoryDefinition_STATUS, GitRepositoryDefinition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForGitRepositoryDefinition_STATUS tests if a specific instance of GitRepositoryDefinition_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForGitRepositoryDefinition_STATUS(subject GitRepositoryDefinition_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.GitRepositoryDefinition_STATUS
	err := copied.AssignProperties_To_GitRepositoryDefinition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual GitRepositoryDefinition_STATUS
	err = actual.AssignProperties_From_GitRepositoryDefinition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_GitRepositoryDefinition_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GitRepositoryDefinition_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGitRepositoryDefinition_STATUS, GitRepositoryDefinition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGitRepositoryDefinition_STATUS runs a test to see if a specific instance of GitRepositoryDefinition_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForGitRepositoryDefinition_STATUS(subject GitRepositoryDefinition_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GitRepositoryDefinition_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GitRepositoryDefinition_STATUS instances for property testing - lazily instantiated by
// GitRepositoryDefinition_STATUSGenerator()
var gitRepositoryDefinition_STATUSGenerator gopter.Gen

// GitRepositoryDefinition_STATUSGenerator returns a generator of GitRepositoryDefinition_STATUS instances for property testing.
// We first initialize gitRepositoryDefinition_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func GitRepositoryDefinition_STATUSGenerator() gopter.Gen {
	if gitRepositoryDefinition_STATUSGenerator != nil {
		return gitRepositoryDefinition_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGitRepositoryDefinition_STATUS(generators)
	gitRepositoryDefinition_STATUSGenerator = gen.Struct(reflect.TypeOf(GitRepositoryDefinition_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGitRepositoryDefinition_STATUS(generators)
	AddRelatedPropertyGeneratorsForGitRepositoryDefinition_STATUS(generators)
	gitRepositoryDefinition_STATUSGenerator = gen.Struct(reflect.TypeOf(GitRepositoryDefinition_STATUS{}), generators)

	return gitRepositoryDefinition_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForGitRepositoryDefinition_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGitRepositoryDefinition_STATUS(gens map[string]gopter.Gen) {
	gens["HttpsUser"] = gen.PtrOf(gen.AlphaString())
	gens["LocalAuthRef"] = gen.PtrOf(gen.AlphaString())
	gens["SshKnownHosts"] = gen.PtrOf(gen.AlphaString())
	gens["SyncIntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["TimeoutInSeconds"] = gen.PtrOf(gen.Int())
	gens["Url"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForGitRepositoryDefinition_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForGitRepositoryDefinition_STATUS(gens map[string]gopter.Gen) {
	gens["RepositoryRef"] = gen.PtrOf(RepositoryRefDefinition_STATUSGenerator())
}

func Test_HelmReleasePropertiesDefinition_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HelmReleasePropertiesDefinition_STATUS to HelmReleasePropertiesDefinition_STATUS via AssignProperties_To_HelmReleasePropertiesDefinition_STATUS & AssignProperties_From_HelmReleasePropertiesDefinition_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForHelmReleasePropertiesDefinition_STATUS, HelmReleasePropertiesDefinition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHelmReleasePropertiesDefinition_STATUS tests if a specific instance of HelmReleasePropertiesDefinition_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForHelmReleasePropertiesDefinition_STATUS(subject HelmReleasePropertiesDefinition_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.HelmReleasePropertiesDefinition_STATUS
	err := copied.AssignProperties_To_HelmReleasePropertiesDefinition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HelmReleasePropertiesDefinition_STATUS
	err = actual.AssignProperties_From_HelmReleasePropertiesDefinition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HelmReleasePropertiesDefinition_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HelmReleasePropertiesDefinition_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHelmReleasePropertiesDefinition_STATUS, HelmReleasePropertiesDefinition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHelmReleasePropertiesDefinition_STATUS runs a test to see if a specific instance of HelmReleasePropertiesDefinition_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForHelmReleasePropertiesDefinition_STATUS(subject HelmReleasePropertiesDefinition_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HelmReleasePropertiesDefinition_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HelmReleasePropertiesDefinition_STATUS instances for property testing - lazily instantiated by
// HelmReleasePropertiesDefinition_STATUSGenerator()
var helmReleasePropertiesDefinition_STATUSGenerator gopter.Gen

// HelmReleasePropertiesDefinition_STATUSGenerator returns a generator of HelmReleasePropertiesDefinition_STATUS instances for property testing.
// We first initialize helmReleasePropertiesDefinition_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func HelmReleasePropertiesDefinition_STATUSGenerator() gopter.Gen {
	if helmReleasePropertiesDefinition_STATUSGenerator != nil {
		return helmReleasePropertiesDefinition_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHelmReleasePropertiesDefinition_STATUS(generators)
	helmReleasePropertiesDefinition_STATUSGenerator = gen.Struct(reflect.TypeOf(HelmReleasePropertiesDefinition_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHelmReleasePropertiesDefinition_STATUS(generators)
	AddRelatedPropertyGeneratorsForHelmReleasePropertiesDefinition_STATUS(generators)
	helmReleasePropertiesDefinition_STATUSGenerator = gen.Struct(reflect.TypeOf(HelmReleasePropertiesDefinition_STATUS{}), generators)

	return helmReleasePropertiesDefinition_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForHelmReleasePropertiesDefinition_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHelmReleasePropertiesDefinition_STATUS(gens map[string]gopter.Gen) {
	gens["FailureCount"] = gen.PtrOf(gen.Int())
	gens["InstallFailureCount"] = gen.PtrOf(gen.Int())
	gens["LastRevisionApplied"] = gen.PtrOf(gen.Int())
	gens["UpgradeFailureCount"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForHelmReleasePropertiesDefinition_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForHelmReleasePropertiesDefinition_STATUS(gens map[string]gopter.Gen) {
	gens["HelmChartRef"] = gen.PtrOf(ObjectReferenceDefinition_STATUSGenerator())
}

func Test_KustomizationDefinition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KustomizationDefinition to KustomizationDefinition via AssignProperties_To_KustomizationDefinition & AssignProperties_From_KustomizationDefinition returns original",
		prop.ForAll(RunPropertyAssignmentTestForKustomizationDefinition, KustomizationDefinitionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKustomizationDefinition tests if a specific instance of KustomizationDefinition can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForKustomizationDefinition(subject KustomizationDefinition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.KustomizationDefinition
	err := copied.AssignProperties_To_KustomizationDefinition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KustomizationDefinition
	err = actual.AssignProperties_From_KustomizationDefinition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KustomizationDefinition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KustomizationDefinition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKustomizationDefinition, KustomizationDefinitionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKustomizationDefinition runs a test to see if a specific instance of KustomizationDefinition round trips to JSON and back losslessly
func RunJSONSerializationTestForKustomizationDefinition(subject KustomizationDefinition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KustomizationDefinition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KustomizationDefinition instances for property testing - lazily instantiated by
// KustomizationDefinitionGenerator()
var kustomizationDefinitionGenerator gopter.Gen

// KustomizationDefinitionGenerator returns a generator of KustomizationDefinition instances for property testing.
// We first initialize kustomizationDefinitionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KustomizationDefinitionGenerator() gopter.Gen {
	if kustomizationDefinitionGenerator != nil {
		return kustomizationDefinitionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKustomizationDefinition(generators)
	kustomizationDefinitionGenerator = gen.Struct(reflect.TypeOf(KustomizationDefinition{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKustomizationDefinition(generators)
	AddRelatedPropertyGeneratorsForKustomizationDefinition(generators)
	kustomizationDefinitionGenerator = gen.Struct(reflect.TypeOf(KustomizationDefinition{}), generators)

	return kustomizationDefinitionGenerator
}

// AddIndependentPropertyGeneratorsForKustomizationDefinition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKustomizationDefinition(gens map[string]gopter.Gen) {
	gens["DependsOn"] = gen.SliceOf(gen.AlphaString())
	gens["Force"] = gen.PtrOf(gen.Bool())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["Prune"] = gen.PtrOf(gen.Bool())
	gens["RetryIntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["SyncIntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["TimeoutInSeconds"] = gen.PtrOf(gen.Int())
	gens["Wait"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForKustomizationDefinition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKustomizationDefinition(gens map[string]gopter.Gen) {
	gens["PostBuild"] = gen.PtrOf(PostBuildDefinitionGenerator())
}

func Test_KustomizationDefinition_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KustomizationDefinition_STATUS to KustomizationDefinition_STATUS via AssignProperties_To_KustomizationDefinition_STATUS & AssignProperties_From_KustomizationDefinition_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForKustomizationDefinition_STATUS, KustomizationDefinition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKustomizationDefinition_STATUS tests if a specific instance of KustomizationDefinition_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForKustomizationDefinition_STATUS(subject KustomizationDefinition_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.KustomizationDefinition_STATUS
	err := copied.AssignProperties_To_KustomizationDefinition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KustomizationDefinition_STATUS
	err = actual.AssignProperties_From_KustomizationDefinition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KustomizationDefinition_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KustomizationDefinition_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKustomizationDefinition_STATUS, KustomizationDefinition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKustomizationDefinition_STATUS runs a test to see if a specific instance of KustomizationDefinition_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForKustomizationDefinition_STATUS(subject KustomizationDefinition_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KustomizationDefinition_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KustomizationDefinition_STATUS instances for property testing - lazily instantiated by
// KustomizationDefinition_STATUSGenerator()
var kustomizationDefinition_STATUSGenerator gopter.Gen

// KustomizationDefinition_STATUSGenerator returns a generator of KustomizationDefinition_STATUS instances for property testing.
// We first initialize kustomizationDefinition_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KustomizationDefinition_STATUSGenerator() gopter.Gen {
	if kustomizationDefinition_STATUSGenerator != nil {
		return kustomizationDefinition_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKustomizationDefinition_STATUS(generators)
	kustomizationDefinition_STATUSGenerator = gen.Struct(reflect.TypeOf(KustomizationDefinition_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKustomizationDefinition_STATUS(generators)
	AddRelatedPropertyGeneratorsForKustomizationDefinition_STATUS(generators)
	kustomizationDefinition_STATUSGenerator = gen.Struct(reflect.TypeOf(KustomizationDefinition_STATUS{}), generators)

	return kustomizationDefinition_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForKustomizationDefinition_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKustomizationDefinition_STATUS(gens map[string]gopter.Gen) {
	gens["DependsOn"] = gen.SliceOf(gen.AlphaString())
	gens["Force"] = gen.PtrOf(gen.Bool())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["Prune"] = gen.PtrOf(gen.Bool())
	gens["RetryIntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["SyncIntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["TimeoutInSeconds"] = gen.PtrOf(gen.Int())
	gens["Wait"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForKustomizationDefinition_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKustomizationDefinition_STATUS(gens map[string]gopter.Gen) {
	gens["PostBuild"] = gen.PtrOf(PostBuildDefinition_STATUSGenerator())
}

func Test_ManagedIdentityDefinition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedIdentityDefinition to ManagedIdentityDefinition via AssignProperties_To_ManagedIdentityDefinition & AssignProperties_From_ManagedIdentityDefinition returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedIdentityDefinition, ManagedIdentityDefinitionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedIdentityDefinition tests if a specific instance of ManagedIdentityDefinition can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedIdentityDefinition(subject ManagedIdentityDefinition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ManagedIdentityDefinition
	err := copied.AssignProperties_To_ManagedIdentityDefinition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedIdentityDefinition
	err = actual.AssignProperties_From_ManagedIdentityDefinition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedIdentityDefinition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedIdentityDefinition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedIdentityDefinition, ManagedIdentityDefinitionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedIdentityDefinition runs a test to see if a specific instance of ManagedIdentityDefinition round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedIdentityDefinition(subject ManagedIdentityDefinition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedIdentityDefinition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedIdentityDefinition instances for property testing - lazily instantiated by
// ManagedIdentityDefinitionGenerator()
var managedIdentityDefinitionGenerator gopter.Gen

// ManagedIdentityDefinitionGenerator returns a generator of ManagedIdentityDefinition instances for property testing.
func ManagedIdentityDefinitionGenerator() gopter.Gen {
	if managedIdentityDefinitionGenerator != nil {
		return managedIdentityDefinitionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedIdentityDefinition(generators)
	managedIdentityDefinitionGenerator = gen.Struct(reflect.TypeOf(ManagedIdentityDefinition{}), generators)

	return managedIdentityDefinitionGenerator
}

// AddIndependentPropertyGeneratorsForManagedIdentityDefinition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedIdentityDefinition(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedIdentityDefinition_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedIdentityDefinition_STATUS to ManagedIdentityDefinition_STATUS via AssignProperties_To_ManagedIdentityDefinition_STATUS & AssignProperties_From_ManagedIdentityDefinition_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedIdentityDefinition_STATUS, ManagedIdentityDefinition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedIdentityDefinition_STATUS tests if a specific instance of ManagedIdentityDefinition_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedIdentityDefinition_STATUS(subject ManagedIdentityDefinition_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ManagedIdentityDefinition_STATUS
	err := copied.AssignProperties_To_ManagedIdentityDefinition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedIdentityDefinition_STATUS
	err = actual.AssignProperties_From_ManagedIdentityDefinition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedIdentityDefinition_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedIdentityDefinition_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedIdentityDefinition_STATUS, ManagedIdentityDefinition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedIdentityDefinition_STATUS runs a test to see if a specific instance of ManagedIdentityDefinition_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedIdentityDefinition_STATUS(subject ManagedIdentityDefinition_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedIdentityDefinition_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedIdentityDefinition_STATUS instances for property testing - lazily instantiated by
// ManagedIdentityDefinition_STATUSGenerator()
var managedIdentityDefinition_STATUSGenerator gopter.Gen

// ManagedIdentityDefinition_STATUSGenerator returns a generator of ManagedIdentityDefinition_STATUS instances for property testing.
func ManagedIdentityDefinition_STATUSGenerator() gopter.Gen {
	if managedIdentityDefinition_STATUSGenerator != nil {
		return managedIdentityDefinition_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedIdentityDefinition_STATUS(generators)
	managedIdentityDefinition_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedIdentityDefinition_STATUS{}), generators)

	return managedIdentityDefinition_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForManagedIdentityDefinition_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedIdentityDefinition_STATUS(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
}

func Test_ObjectReferenceDefinition_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ObjectReferenceDefinition_STATUS to ObjectReferenceDefinition_STATUS via AssignProperties_To_ObjectReferenceDefinition_STATUS & AssignProperties_From_ObjectReferenceDefinition_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForObjectReferenceDefinition_STATUS, ObjectReferenceDefinition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForObjectReferenceDefinition_STATUS tests if a specific instance of ObjectReferenceDefinition_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForObjectReferenceDefinition_STATUS(subject ObjectReferenceDefinition_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ObjectReferenceDefinition_STATUS
	err := copied.AssignProperties_To_ObjectReferenceDefinition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ObjectReferenceDefinition_STATUS
	err = actual.AssignProperties_From_ObjectReferenceDefinition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ObjectReferenceDefinition_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ObjectReferenceDefinition_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForObjectReferenceDefinition_STATUS, ObjectReferenceDefinition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForObjectReferenceDefinition_STATUS runs a test to see if a specific instance of ObjectReferenceDefinition_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForObjectReferenceDefinition_STATUS(subject ObjectReferenceDefinition_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ObjectReferenceDefinition_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ObjectReferenceDefinition_STATUS instances for property testing - lazily instantiated by
// ObjectReferenceDefinition_STATUSGenerator()
var objectReferenceDefinition_STATUSGenerator gopter.Gen

// ObjectReferenceDefinition_STATUSGenerator returns a generator of ObjectReferenceDefinition_STATUS instances for property testing.
func ObjectReferenceDefinition_STATUSGenerator() gopter.Gen {
	if objectReferenceDefinition_STATUSGenerator != nil {
		return objectReferenceDefinition_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForObjectReferenceDefinition_STATUS(generators)
	objectReferenceDefinition_STATUSGenerator = gen.Struct(reflect.TypeOf(ObjectReferenceDefinition_STATUS{}), generators)

	return objectReferenceDefinition_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForObjectReferenceDefinition_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForObjectReferenceDefinition_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Namespace"] = gen.PtrOf(gen.AlphaString())
}

func Test_ObjectStatusConditionDefinition_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ObjectStatusConditionDefinition_STATUS to ObjectStatusConditionDefinition_STATUS via AssignProperties_To_ObjectStatusConditionDefinition_STATUS & AssignProperties_From_ObjectStatusConditionDefinition_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForObjectStatusConditionDefinition_STATUS, ObjectStatusConditionDefinition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForObjectStatusConditionDefinition_STATUS tests if a specific instance of ObjectStatusConditionDefinition_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForObjectStatusConditionDefinition_STATUS(subject ObjectStatusConditionDefinition_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ObjectStatusConditionDefinition_STATUS
	err := copied.AssignProperties_To_ObjectStatusConditionDefinition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ObjectStatusConditionDefinition_STATUS
	err = actual.AssignProperties_From_ObjectStatusConditionDefinition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ObjectStatusConditionDefinition_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ObjectStatusConditionDefinition_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForObjectStatusConditionDefinition_STATUS, ObjectStatusConditionDefinition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForObjectStatusConditionDefinition_STATUS runs a test to see if a specific instance of ObjectStatusConditionDefinition_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForObjectStatusConditionDefinition_STATUS(subject ObjectStatusConditionDefinition_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ObjectStatusConditionDefinition_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ObjectStatusConditionDefinition_STATUS instances for property testing - lazily instantiated by
// ObjectStatusConditionDefinition_STATUSGenerator()
var objectStatusConditionDefinition_STATUSGenerator gopter.Gen

// ObjectStatusConditionDefinition_STATUSGenerator returns a generator of ObjectStatusConditionDefinition_STATUS instances for property testing.
func ObjectStatusConditionDefinition_STATUSGenerator() gopter.Gen {
	if objectStatusConditionDefinition_STATUSGenerator != nil {
		return objectStatusConditionDefinition_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForObjectStatusConditionDefinition_STATUS(generators)
	objectStatusConditionDefinition_STATUSGenerator = gen.Struct(reflect.TypeOf(ObjectStatusConditionDefinition_STATUS{}), generators)

	return objectStatusConditionDefinition_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForObjectStatusConditionDefinition_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForObjectStatusConditionDefinition_STATUS(gens map[string]gopter.Gen) {
	gens["LastTransitionTime"] = gen.PtrOf(gen.AlphaString())
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Reason"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_ObjectStatusDefinition_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ObjectStatusDefinition_STATUS to ObjectStatusDefinition_STATUS via AssignProperties_To_ObjectStatusDefinition_STATUS & AssignProperties_From_ObjectStatusDefinition_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForObjectStatusDefinition_STATUS, ObjectStatusDefinition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForObjectStatusDefinition_STATUS tests if a specific instance of ObjectStatusDefinition_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForObjectStatusDefinition_STATUS(subject ObjectStatusDefinition_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ObjectStatusDefinition_STATUS
	err := copied.AssignProperties_To_ObjectStatusDefinition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ObjectStatusDefinition_STATUS
	err = actual.AssignProperties_From_ObjectStatusDefinition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ObjectStatusDefinition_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ObjectStatusDefinition_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForObjectStatusDefinition_STATUS, ObjectStatusDefinition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForObjectStatusDefinition_STATUS runs a test to see if a specific instance of ObjectStatusDefinition_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForObjectStatusDefinition_STATUS(subject ObjectStatusDefinition_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ObjectStatusDefinition_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ObjectStatusDefinition_STATUS instances for property testing - lazily instantiated by
// ObjectStatusDefinition_STATUSGenerator()
var objectStatusDefinition_STATUSGenerator gopter.Gen

// ObjectStatusDefinition_STATUSGenerator returns a generator of ObjectStatusDefinition_STATUS instances for property testing.
// We first initialize objectStatusDefinition_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ObjectStatusDefinition_STATUSGenerator() gopter.Gen {
	if objectStatusDefinition_STATUSGenerator != nil {
		return objectStatusDefinition_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForObjectStatusDefinition_STATUS(generators)
	objectStatusDefinition_STATUSGenerator = gen.Struct(reflect.TypeOf(ObjectStatusDefinition_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForObjectStatusDefinition_STATUS(generators)
	AddRelatedPropertyGeneratorsForObjectStatusDefinition_STATUS(generators)
	objectStatusDefinition_STATUSGenerator = gen.Struct(reflect.TypeOf(ObjectStatusDefinition_STATUS{}), generators)

	return objectStatusDefinition_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForObjectStatusDefinition_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForObjectStatusDefinition_STATUS(gens map[string]gopter.Gen) {
	gens["ComplianceState"] = gen.PtrOf(gen.OneConstOf(
		FluxComplianceStateDefinition_STATUS_Compliant,
		FluxComplianceStateDefinition_STATUS_NonCompliant,
		FluxComplianceStateDefinition_STATUS_Pending,
		FluxComplianceStateDefinition_STATUS_Suspended,
		FluxComplianceStateDefinition_STATUS_Unknown))
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Namespace"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForObjectStatusDefinition_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForObjectStatusDefinition_STATUS(gens map[string]gopter.Gen) {
	gens["AppliedBy"] = gen.PtrOf(ObjectReferenceDefinition_STATUSGenerator())
	gens["HelmReleaseProperties"] = gen.PtrOf(HelmReleasePropertiesDefinition_STATUSGenerator())
	gens["StatusConditions"] = gen.SliceOf(ObjectStatusConditionDefinition_STATUSGenerator())
}

func Test_PostBuildDefinition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PostBuildDefinition to PostBuildDefinition via AssignProperties_To_PostBuildDefinition & AssignProperties_From_PostBuildDefinition returns original",
		prop.ForAll(RunPropertyAssignmentTestForPostBuildDefinition, PostBuildDefinitionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPostBuildDefinition tests if a specific instance of PostBuildDefinition can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForPostBuildDefinition(subject PostBuildDefinition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.PostBuildDefinition
	err := copied.AssignProperties_To_PostBuildDefinition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PostBuildDefinition
	err = actual.AssignProperties_From_PostBuildDefinition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PostBuildDefinition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PostBuildDefinition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPostBuildDefinition, PostBuildDefinitionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPostBuildDefinition runs a test to see if a specific instance of PostBuildDefinition round trips to JSON and back losslessly
func RunJSONSerializationTestForPostBuildDefinition(subject PostBuildDefinition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PostBuildDefinition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PostBuildDefinition instances for property testing - lazily instantiated by
// PostBuildDefinitionGenerator()
var postBuildDefinitionGenerator gopter.Gen

// PostBuildDefinitionGenerator returns a generator of PostBuildDefinition instances for property testing.
// We first initialize postBuildDefinitionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PostBuildDefinitionGenerator() gopter.Gen {
	if postBuildDefinitionGenerator != nil {
		return postBuildDefinitionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPostBuildDefinition(generators)
	postBuildDefinitionGenerator = gen.Struct(reflect.TypeOf(PostBuildDefinition{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPostBuildDefinition(generators)
	AddRelatedPropertyGeneratorsForPostBuildDefinition(generators)
	postBuildDefinitionGenerator = gen.Struct(reflect.TypeOf(PostBuildDefinition{}), generators)

	return postBuildDefinitionGenerator
}

// AddIndependentPropertyGeneratorsForPostBuildDefinition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPostBuildDefinition(gens map[string]gopter.Gen) {
	gens["Substitute"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPostBuildDefinition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPostBuildDefinition(gens map[string]gopter.Gen) {
	gens["SubstituteFrom"] = gen.SliceOf(SubstituteFromDefinitionGenerator())
}

func Test_PostBuildDefinition_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PostBuildDefinition_STATUS to PostBuildDefinition_STATUS via AssignProperties_To_PostBuildDefinition_STATUS & AssignProperties_From_PostBuildDefinition_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForPostBuildDefinition_STATUS, PostBuildDefinition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPostBuildDefinition_STATUS tests if a specific instance of PostBuildDefinition_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForPostBuildDefinition_STATUS(subject PostBuildDefinition_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.PostBuildDefinition_STATUS
	err := copied.AssignProperties_To_PostBuildDefinition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PostBuildDefinition_STATUS
	err = actual.AssignProperties_From_PostBuildDefinition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PostBuildDefinition_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PostBuildDefinition_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPostBuildDefinition_STATUS, PostBuildDefinition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPostBuildDefinition_STATUS runs a test to see if a specific instance of PostBuildDefinition_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPostBuildDefinition_STATUS(subject PostBuildDefinition_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PostBuildDefinition_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PostBuildDefinition_STATUS instances for property testing - lazily instantiated by
// PostBuildDefinition_STATUSGenerator()
var postBuildDefinition_STATUSGenerator gopter.Gen

// PostBuildDefinition_STATUSGenerator returns a generator of PostBuildDefinition_STATUS instances for property testing.
// We first initialize postBuildDefinition_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PostBuildDefinition_STATUSGenerator() gopter.Gen {
	if postBuildDefinition_STATUSGenerator != nil {
		return postBuildDefinition_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPostBuildDefinition_STATUS(generators)
	postBuildDefinition_STATUSGenerator = gen.Struct(reflect.TypeOf(PostBuildDefinition_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPostBuildDefinition_STATUS(generators)
	AddRelatedPropertyGeneratorsForPostBuildDefinition_STATUS(generators)
	postBuildDefinition_STATUSGenerator = gen.Struct(reflect.TypeOf(PostBuildDefinition_STATUS{}), generators)

	return postBuildDefinition_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForPostBuildDefinition_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPostBuildDefinition_STATUS(gens map[string]gopter.Gen) {
	gens["Substitute"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPostBuildDefinition_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPostBuildDefinition_STATUS(gens map[string]gopter.Gen) {
	gens["SubstituteFrom"] = gen.SliceOf(SubstituteFromDefinition_STATUSGenerator())
}

func Test_RepositoryRefDefinition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RepositoryRefDefinition to RepositoryRefDefinition via AssignProperties_To_RepositoryRefDefinition & AssignProperties_From_RepositoryRefDefinition returns original",
		prop.ForAll(RunPropertyAssignmentTestForRepositoryRefDefinition, RepositoryRefDefinitionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRepositoryRefDefinition tests if a specific instance of RepositoryRefDefinition can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForRepositoryRefDefinition(subject RepositoryRefDefinition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.RepositoryRefDefinition
	err := copied.AssignProperties_To_RepositoryRefDefinition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RepositoryRefDefinition
	err = actual.AssignProperties_From_RepositoryRefDefinition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RepositoryRefDefinition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RepositoryRefDefinition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRepositoryRefDefinition, RepositoryRefDefinitionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRepositoryRefDefinition runs a test to see if a specific instance of RepositoryRefDefinition round trips to JSON and back losslessly
func RunJSONSerializationTestForRepositoryRefDefinition(subject RepositoryRefDefinition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RepositoryRefDefinition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RepositoryRefDefinition instances for property testing - lazily instantiated by
// RepositoryRefDefinitionGenerator()
var repositoryRefDefinitionGenerator gopter.Gen

// RepositoryRefDefinitionGenerator returns a generator of RepositoryRefDefinition instances for property testing.
func RepositoryRefDefinitionGenerator() gopter.Gen {
	if repositoryRefDefinitionGenerator != nil {
		return repositoryRefDefinitionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRepositoryRefDefinition(generators)
	repositoryRefDefinitionGenerator = gen.Struct(reflect.TypeOf(RepositoryRefDefinition{}), generators)

	return repositoryRefDefinitionGenerator
}

// AddIndependentPropertyGeneratorsForRepositoryRefDefinition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRepositoryRefDefinition(gens map[string]gopter.Gen) {
	gens["Branch"] = gen.PtrOf(gen.AlphaString())
	gens["Commit"] = gen.PtrOf(gen.AlphaString())
	gens["Semver"] = gen.PtrOf(gen.AlphaString())
	gens["Tag"] = gen.PtrOf(gen.AlphaString())
}

func Test_RepositoryRefDefinition_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RepositoryRefDefinition_STATUS to RepositoryRefDefinition_STATUS via AssignProperties_To_RepositoryRefDefinition_STATUS & AssignProperties_From_RepositoryRefDefinition_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForRepositoryRefDefinition_STATUS, RepositoryRefDefinition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRepositoryRefDefinition_STATUS tests if a specific instance of RepositoryRefDefinition_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForRepositoryRefDefinition_STATUS(subject RepositoryRefDefinition_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.RepositoryRefDefinition_STATUS
	err := copied.AssignProperties_To_RepositoryRefDefinition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RepositoryRefDefinition_STATUS
	err = actual.AssignProperties_From_RepositoryRefDefinition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RepositoryRefDefinition_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RepositoryRefDefinition_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRepositoryRefDefinition_STATUS, RepositoryRefDefinition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRepositoryRefDefinition_STATUS runs a test to see if a specific instance of RepositoryRefDefinition_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRepositoryRefDefinition_STATUS(subject RepositoryRefDefinition_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RepositoryRefDefinition_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RepositoryRefDefinition_STATUS instances for property testing - lazily instantiated by
// RepositoryRefDefinition_STATUSGenerator()
var repositoryRefDefinition_STATUSGenerator gopter.Gen

// RepositoryRefDefinition_STATUSGenerator returns a generator of RepositoryRefDefinition_STATUS instances for property testing.
func RepositoryRefDefinition_STATUSGenerator() gopter.Gen {
	if repositoryRefDefinition_STATUSGenerator != nil {
		return repositoryRefDefinition_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRepositoryRefDefinition_STATUS(generators)
	repositoryRefDefinition_STATUSGenerator = gen.Struct(reflect.TypeOf(RepositoryRefDefinition_STATUS{}), generators)

	return repositoryRefDefinition_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForRepositoryRefDefinition_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRepositoryRefDefinition_STATUS(gens map[string]gopter.Gen) {
	gens["Branch"] = gen.PtrOf(gen.AlphaString())
	gens["Commit"] = gen.PtrOf(gen.AlphaString())
	gens["Semver"] = gen.PtrOf(gen.AlphaString())
	gens["Tag"] = gen.PtrOf(gen.AlphaString())
}

func Test_ServicePrincipalDefinition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ServicePrincipalDefinition to ServicePrincipalDefinition via AssignProperties_To_ServicePrincipalDefinition & AssignProperties_From_ServicePrincipalDefinition returns original",
		prop.ForAll(RunPropertyAssignmentTestForServicePrincipalDefinition, ServicePrincipalDefinitionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForServicePrincipalDefinition tests if a specific instance of ServicePrincipalDefinition can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForServicePrincipalDefinition(subject ServicePrincipalDefinition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ServicePrincipalDefinition
	err := copied.AssignProperties_To_ServicePrincipalDefinition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ServicePrincipalDefinition
	err = actual.AssignProperties_From_ServicePrincipalDefinition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ServicePrincipalDefinition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServicePrincipalDefinition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServicePrincipalDefinition, ServicePrincipalDefinitionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServicePrincipalDefinition runs a test to see if a specific instance of ServicePrincipalDefinition round trips to JSON and back losslessly
func RunJSONSerializationTestForServicePrincipalDefinition(subject ServicePrincipalDefinition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServicePrincipalDefinition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServicePrincipalDefinition instances for property testing - lazily instantiated by
// ServicePrincipalDefinitionGenerator()
var servicePrincipalDefinitionGenerator gopter.Gen

// ServicePrincipalDefinitionGenerator returns a generator of ServicePrincipalDefinition instances for property testing.
func ServicePrincipalDefinitionGenerator() gopter.Gen {
	if servicePrincipalDefinitionGenerator != nil {
		return servicePrincipalDefinitionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServicePrincipalDefinition(generators)
	servicePrincipalDefinitionGenerator = gen.Struct(reflect.TypeOf(ServicePrincipalDefinition{}), generators)

	return servicePrincipalDefinitionGenerator
}

// AddIndependentPropertyGeneratorsForServicePrincipalDefinition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServicePrincipalDefinition(gens map[string]gopter.Gen) {
	gens["ClientCertificateSendChain"] = gen.PtrOf(gen.Bool())
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
}

func Test_ServicePrincipalDefinition_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ServicePrincipalDefinition_STATUS to ServicePrincipalDefinition_STATUS via AssignProperties_To_ServicePrincipalDefinition_STATUS & AssignProperties_From_ServicePrincipalDefinition_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForServicePrincipalDefinition_STATUS, ServicePrincipalDefinition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForServicePrincipalDefinition_STATUS tests if a specific instance of ServicePrincipalDefinition_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForServicePrincipalDefinition_STATUS(subject ServicePrincipalDefinition_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ServicePrincipalDefinition_STATUS
	err := copied.AssignProperties_To_ServicePrincipalDefinition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ServicePrincipalDefinition_STATUS
	err = actual.AssignProperties_From_ServicePrincipalDefinition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ServicePrincipalDefinition_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServicePrincipalDefinition_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServicePrincipalDefinition_STATUS, ServicePrincipalDefinition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServicePrincipalDefinition_STATUS runs a test to see if a specific instance of ServicePrincipalDefinition_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForServicePrincipalDefinition_STATUS(subject ServicePrincipalDefinition_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServicePrincipalDefinition_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServicePrincipalDefinition_STATUS instances for property testing - lazily instantiated by
// ServicePrincipalDefinition_STATUSGenerator()
var servicePrincipalDefinition_STATUSGenerator gopter.Gen

// ServicePrincipalDefinition_STATUSGenerator returns a generator of ServicePrincipalDefinition_STATUS instances for property testing.
func ServicePrincipalDefinition_STATUSGenerator() gopter.Gen {
	if servicePrincipalDefinition_STATUSGenerator != nil {
		return servicePrincipalDefinition_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServicePrincipalDefinition_STATUS(generators)
	servicePrincipalDefinition_STATUSGenerator = gen.Struct(reflect.TypeOf(ServicePrincipalDefinition_STATUS{}), generators)

	return servicePrincipalDefinition_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForServicePrincipalDefinition_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServicePrincipalDefinition_STATUS(gens map[string]gopter.Gen) {
	gens["ClientCertificateSendChain"] = gen.PtrOf(gen.Bool())
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
}

func Test_SubstituteFromDefinition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SubstituteFromDefinition to SubstituteFromDefinition via AssignProperties_To_SubstituteFromDefinition & AssignProperties_From_SubstituteFromDefinition returns original",
		prop.ForAll(RunPropertyAssignmentTestForSubstituteFromDefinition, SubstituteFromDefinitionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSubstituteFromDefinition tests if a specific instance of SubstituteFromDefinition can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSubstituteFromDefinition(subject SubstituteFromDefinition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.SubstituteFromDefinition
	err := copied.AssignProperties_To_SubstituteFromDefinition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SubstituteFromDefinition
	err = actual.AssignProperties_From_SubstituteFromDefinition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SubstituteFromDefinition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SubstituteFromDefinition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubstituteFromDefinition, SubstituteFromDefinitionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubstituteFromDefinition runs a test to see if a specific instance of SubstituteFromDefinition round trips to JSON and back losslessly
func RunJSONSerializationTestForSubstituteFromDefinition(subject SubstituteFromDefinition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SubstituteFromDefinition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SubstituteFromDefinition instances for property testing - lazily instantiated by
// SubstituteFromDefinitionGenerator()
var substituteFromDefinitionGenerator gopter.Gen

// SubstituteFromDefinitionGenerator returns a generator of SubstituteFromDefinition instances for property testing.
func SubstituteFromDefinitionGenerator() gopter.Gen {
	if substituteFromDefinitionGenerator != nil {
		return substituteFromDefinitionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSubstituteFromDefinition(generators)
	substituteFromDefinitionGenerator = gen.Struct(reflect.TypeOf(SubstituteFromDefinition{}), generators)

	return substituteFromDefinitionGenerator
}

// AddIndependentPropertyGeneratorsForSubstituteFromDefinition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSubstituteFromDefinition(gens map[string]gopter.Gen) {
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Optional"] = gen.PtrOf(gen.Bool())
}

func Test_SubstituteFromDefinition_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SubstituteFromDefinition_STATUS to SubstituteFromDefinition_STATUS via AssignProperties_To_SubstituteFromDefinition_STATUS & AssignProperties_From_SubstituteFromDefinition_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSubstituteFromDefinition_STATUS, SubstituteFromDefinition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSubstituteFromDefinition_STATUS tests if a specific instance of SubstituteFromDefinition_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSubstituteFromDefinition_STATUS(subject SubstituteFromDefinition_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.SubstituteFromDefinition_STATUS
	err := copied.AssignProperties_To_SubstituteFromDefinition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SubstituteFromDefinition_STATUS
	err = actual.AssignProperties_From_SubstituteFromDefinition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SubstituteFromDefinition_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SubstituteFromDefinition_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSubstituteFromDefinition_STATUS, SubstituteFromDefinition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSubstituteFromDefinition_STATUS runs a test to see if a specific instance of SubstituteFromDefinition_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSubstituteFromDefinition_STATUS(subject SubstituteFromDefinition_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SubstituteFromDefinition_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SubstituteFromDefinition_STATUS instances for property testing - lazily instantiated by
// SubstituteFromDefinition_STATUSGenerator()
var substituteFromDefinition_STATUSGenerator gopter.Gen

// SubstituteFromDefinition_STATUSGenerator returns a generator of SubstituteFromDefinition_STATUS instances for property testing.
func SubstituteFromDefinition_STATUSGenerator() gopter.Gen {
	if substituteFromDefinition_STATUSGenerator != nil {
		return substituteFromDefinition_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSubstituteFromDefinition_STATUS(generators)
	substituteFromDefinition_STATUSGenerator = gen.Struct(reflect.TypeOf(SubstituteFromDefinition_STATUS{}), generators)

	return substituteFromDefinition_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSubstituteFromDefinition_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSubstituteFromDefinition_STATUS(gens map[string]gopter.Gen) {
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Optional"] = gen.PtrOf(gen.Bool())
}
