// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package arm

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_Extension_Properties_AksAssignedIdentity_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Extension_Properties_AksAssignedIdentity_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtension_Properties_AksAssignedIdentity_Spec, Extension_Properties_AksAssignedIdentity_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtension_Properties_AksAssignedIdentity_Spec runs a test to see if a specific instance of Extension_Properties_AksAssignedIdentity_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForExtension_Properties_AksAssignedIdentity_Spec(subject Extension_Properties_AksAssignedIdentity_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Extension_Properties_AksAssignedIdentity_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Extension_Properties_AksAssignedIdentity_Spec instances for property testing - lazily instantiated by
// Extension_Properties_AksAssignedIdentity_SpecGenerator()
var extension_Properties_AksAssignedIdentity_SpecGenerator gopter.Gen

// Extension_Properties_AksAssignedIdentity_SpecGenerator returns a generator of Extension_Properties_AksAssignedIdentity_Spec instances for property testing.
func Extension_Properties_AksAssignedIdentity_SpecGenerator() gopter.Gen {
	if extension_Properties_AksAssignedIdentity_SpecGenerator != nil {
		return extension_Properties_AksAssignedIdentity_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtension_Properties_AksAssignedIdentity_Spec(generators)
	extension_Properties_AksAssignedIdentity_SpecGenerator = gen.Struct(reflect.TypeOf(Extension_Properties_AksAssignedIdentity_Spec{}), generators)

	return extension_Properties_AksAssignedIdentity_SpecGenerator
}

// AddIndependentPropertyGeneratorsForExtension_Properties_AksAssignedIdentity_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtension_Properties_AksAssignedIdentity_Spec(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(Extension_Properties_AksAssignedIdentity_Type_Spec_SystemAssigned, Extension_Properties_AksAssignedIdentity_Type_Spec_UserAssigned))
}

func Test_Extension_Properties_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Extension_Properties_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtension_Properties_Spec, Extension_Properties_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtension_Properties_Spec runs a test to see if a specific instance of Extension_Properties_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForExtension_Properties_Spec(subject Extension_Properties_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Extension_Properties_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Extension_Properties_Spec instances for property testing - lazily instantiated by
// Extension_Properties_SpecGenerator()
var extension_Properties_SpecGenerator gopter.Gen

// Extension_Properties_SpecGenerator returns a generator of Extension_Properties_Spec instances for property testing.
// We first initialize extension_Properties_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Extension_Properties_SpecGenerator() gopter.Gen {
	if extension_Properties_SpecGenerator != nil {
		return extension_Properties_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtension_Properties_Spec(generators)
	extension_Properties_SpecGenerator = gen.Struct(reflect.TypeOf(Extension_Properties_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtension_Properties_Spec(generators)
	AddRelatedPropertyGeneratorsForExtension_Properties_Spec(generators)
	extension_Properties_SpecGenerator = gen.Struct(reflect.TypeOf(Extension_Properties_Spec{}), generators)

	return extension_Properties_SpecGenerator
}

// AddIndependentPropertyGeneratorsForExtension_Properties_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtension_Properties_Spec(gens map[string]gopter.Gen) {
	gens["AutoUpgradeMinorVersion"] = gen.PtrOf(gen.Bool())
	gens["ConfigurationProtectedSettings"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["ConfigurationSettings"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["ExtensionType"] = gen.PtrOf(gen.AlphaString())
	gens["ReleaseTrain"] = gen.PtrOf(gen.AlphaString())
	gens["Version"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForExtension_Properties_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForExtension_Properties_Spec(gens map[string]gopter.Gen) {
	gens["AksAssignedIdentity"] = gen.PtrOf(Extension_Properties_AksAssignedIdentity_SpecGenerator())
	gens["Scope"] = gen.PtrOf(ScopeGenerator())
}

func Test_Extension_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Extension_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtension_Spec, Extension_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtension_Spec runs a test to see if a specific instance of Extension_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForExtension_Spec(subject Extension_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Extension_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Extension_Spec instances for property testing - lazily instantiated by Extension_SpecGenerator()
var extension_SpecGenerator gopter.Gen

// Extension_SpecGenerator returns a generator of Extension_Spec instances for property testing.
// We first initialize extension_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Extension_SpecGenerator() gopter.Gen {
	if extension_SpecGenerator != nil {
		return extension_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtension_Spec(generators)
	extension_SpecGenerator = gen.Struct(reflect.TypeOf(Extension_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtension_Spec(generators)
	AddRelatedPropertyGeneratorsForExtension_Spec(generators)
	extension_SpecGenerator = gen.Struct(reflect.TypeOf(Extension_Spec{}), generators)

	return extension_SpecGenerator
}

// AddIndependentPropertyGeneratorsForExtension_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtension_Spec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForExtension_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForExtension_Spec(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(IdentityGenerator())
	gens["Plan"] = gen.PtrOf(PlanGenerator())
	gens["Properties"] = gen.PtrOf(Extension_Properties_SpecGenerator())
	gens["SystemData"] = gen.PtrOf(SystemDataGenerator())
}

func Test_Identity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Identity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIdentity, IdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIdentity runs a test to see if a specific instance of Identity round trips to JSON and back losslessly
func RunJSONSerializationTestForIdentity(subject Identity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Identity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Identity instances for property testing - lazily instantiated by IdentityGenerator()
var identityGenerator gopter.Gen

// IdentityGenerator returns a generator of Identity instances for property testing.
func IdentityGenerator() gopter.Gen {
	if identityGenerator != nil {
		return identityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentity(generators)
	identityGenerator = gen.Struct(reflect.TypeOf(Identity{}), generators)

	return identityGenerator
}

// AddIndependentPropertyGeneratorsForIdentity is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIdentity(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(Identity_Type_SystemAssigned))
}

func Test_Plan_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Plan via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPlan, PlanGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPlan runs a test to see if a specific instance of Plan round trips to JSON and back losslessly
func RunJSONSerializationTestForPlan(subject Plan) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Plan
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Plan instances for property testing - lazily instantiated by PlanGenerator()
var planGenerator gopter.Gen

// PlanGenerator returns a generator of Plan instances for property testing.
func PlanGenerator() gopter.Gen {
	if planGenerator != nil {
		return planGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPlan(generators)
	planGenerator = gen.Struct(reflect.TypeOf(Plan{}), generators)

	return planGenerator
}

// AddIndependentPropertyGeneratorsForPlan is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPlan(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Product"] = gen.PtrOf(gen.AlphaString())
	gens["PromotionCode"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
	gens["Version"] = gen.PtrOf(gen.AlphaString())
}

func Test_Scope_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Scope via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScope, ScopeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScope runs a test to see if a specific instance of Scope round trips to JSON and back losslessly
func RunJSONSerializationTestForScope(subject Scope) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Scope
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Scope instances for property testing - lazily instantiated by ScopeGenerator()
var scopeGenerator gopter.Gen

// ScopeGenerator returns a generator of Scope instances for property testing.
func ScopeGenerator() gopter.Gen {
	if scopeGenerator != nil {
		return scopeGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForScope(generators)
	scopeGenerator = gen.Struct(reflect.TypeOf(Scope{}), generators)

	return scopeGenerator
}

// AddRelatedPropertyGeneratorsForScope is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForScope(gens map[string]gopter.Gen) {
	gens["Cluster"] = gen.PtrOf(ScopeClusterGenerator())
	gens["Namespace"] = gen.PtrOf(ScopeNamespaceGenerator())
}

func Test_ScopeCluster_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScopeCluster via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScopeCluster, ScopeClusterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScopeCluster runs a test to see if a specific instance of ScopeCluster round trips to JSON and back losslessly
func RunJSONSerializationTestForScopeCluster(subject ScopeCluster) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScopeCluster
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScopeCluster instances for property testing - lazily instantiated by ScopeClusterGenerator()
var scopeClusterGenerator gopter.Gen

// ScopeClusterGenerator returns a generator of ScopeCluster instances for property testing.
func ScopeClusterGenerator() gopter.Gen {
	if scopeClusterGenerator != nil {
		return scopeClusterGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScopeCluster(generators)
	scopeClusterGenerator = gen.Struct(reflect.TypeOf(ScopeCluster{}), generators)

	return scopeClusterGenerator
}

// AddIndependentPropertyGeneratorsForScopeCluster is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScopeCluster(gens map[string]gopter.Gen) {
	gens["ReleaseNamespace"] = gen.PtrOf(gen.AlphaString())
}

func Test_ScopeNamespace_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScopeNamespace via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScopeNamespace, ScopeNamespaceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScopeNamespace runs a test to see if a specific instance of ScopeNamespace round trips to JSON and back losslessly
func RunJSONSerializationTestForScopeNamespace(subject ScopeNamespace) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScopeNamespace
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScopeNamespace instances for property testing - lazily instantiated by ScopeNamespaceGenerator()
var scopeNamespaceGenerator gopter.Gen

// ScopeNamespaceGenerator returns a generator of ScopeNamespace instances for property testing.
func ScopeNamespaceGenerator() gopter.Gen {
	if scopeNamespaceGenerator != nil {
		return scopeNamespaceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScopeNamespace(generators)
	scopeNamespaceGenerator = gen.Struct(reflect.TypeOf(ScopeNamespace{}), generators)

	return scopeNamespaceGenerator
}

// AddIndependentPropertyGeneratorsForScopeNamespace is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScopeNamespace(gens map[string]gopter.Gen) {
	gens["TargetNamespace"] = gen.PtrOf(gen.AlphaString())
}

func Test_SystemData_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SystemData via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSystemData, SystemDataGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSystemData runs a test to see if a specific instance of SystemData round trips to JSON and back losslessly
func RunJSONSerializationTestForSystemData(subject SystemData) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SystemData
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SystemData instances for property testing - lazily instantiated by SystemDataGenerator()
var systemDataGenerator gopter.Gen

// SystemDataGenerator returns a generator of SystemData instances for property testing.
func SystemDataGenerator() gopter.Gen {
	if systemDataGenerator != nil {
		return systemDataGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSystemData(generators)
	systemDataGenerator = gen.Struct(reflect.TypeOf(SystemData{}), generators)

	return systemDataGenerator
}

// AddIndependentPropertyGeneratorsForSystemData is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSystemData(gens map[string]gopter.Gen) {
	gens["CreatedAt"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedBy"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemData_CreatedByType_Application,
		SystemData_CreatedByType_Key,
		SystemData_CreatedByType_ManagedIdentity,
		SystemData_CreatedByType_User))
	gens["LastModifiedAt"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedBy"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemData_LastModifiedByType_Application,
		SystemData_LastModifiedByType_Key,
		SystemData_LastModifiedByType_ManagedIdentity,
		SystemData_LastModifiedByType_User))
}
