// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package storage

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_Extension_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Extension via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtension, ExtensionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtension runs a test to see if a specific instance of Extension round trips to JSON and back losslessly
func RunJSONSerializationTestForExtension(subject Extension) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Extension
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Extension instances for property testing - lazily instantiated by ExtensionGenerator()
var extensionGenerator gopter.Gen

// ExtensionGenerator returns a generator of Extension instances for property testing.
func ExtensionGenerator() gopter.Gen {
	if extensionGenerator != nil {
		return extensionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForExtension(generators)
	extensionGenerator = gen.Struct(reflect.TypeOf(Extension{}), generators)

	return extensionGenerator
}

// AddRelatedPropertyGeneratorsForExtension is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForExtension(gens map[string]gopter.Gen) {
	gens["Spec"] = Extension_SpecGenerator()
	gens["Status"] = Extension_STATUSGenerator()
}

func Test_Extension_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Extension_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtension_Spec, Extension_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtension_Spec runs a test to see if a specific instance of Extension_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForExtension_Spec(subject Extension_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Extension_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Extension_Spec instances for property testing - lazily instantiated by Extension_SpecGenerator()
var extension_SpecGenerator gopter.Gen

// Extension_SpecGenerator returns a generator of Extension_Spec instances for property testing.
// We first initialize extension_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Extension_SpecGenerator() gopter.Gen {
	if extension_SpecGenerator != nil {
		return extension_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtension_Spec(generators)
	extension_SpecGenerator = gen.Struct(reflect.TypeOf(Extension_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtension_Spec(generators)
	AddRelatedPropertyGeneratorsForExtension_Spec(generators)
	extension_SpecGenerator = gen.Struct(reflect.TypeOf(Extension_Spec{}), generators)

	return extension_SpecGenerator
}

// AddIndependentPropertyGeneratorsForExtension_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtension_Spec(gens map[string]gopter.Gen) {
	gens["AutoUpgradeMinorVersion"] = gen.PtrOf(gen.Bool())
	gens["AzureName"] = gen.AlphaString()
	gens["ConfigurationSettings"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["ExtensionType"] = gen.PtrOf(gen.AlphaString())
	gens["OriginalVersion"] = gen.AlphaString()
	gens["ReleaseTrain"] = gen.PtrOf(gen.AlphaString())
	gens["Version"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForExtension_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForExtension_Spec(gens map[string]gopter.Gen) {
	gens["AksAssignedIdentity"] = gen.PtrOf(Extension_Properties_AksAssignedIdentity_SpecGenerator())
	gens["Identity"] = gen.PtrOf(IdentityGenerator())
	gens["Plan"] = gen.PtrOf(PlanGenerator())
	gens["Scope"] = gen.PtrOf(ScopeGenerator())
	gens["SystemData"] = gen.PtrOf(SystemDataGenerator())
}

func Test_Extension_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Extension_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtension_STATUS, Extension_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtension_STATUS runs a test to see if a specific instance of Extension_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForExtension_STATUS(subject Extension_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Extension_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Extension_STATUS instances for property testing - lazily instantiated by Extension_STATUSGenerator()
var extension_STATUSGenerator gopter.Gen

// Extension_STATUSGenerator returns a generator of Extension_STATUS instances for property testing.
// We first initialize extension_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Extension_STATUSGenerator() gopter.Gen {
	if extension_STATUSGenerator != nil {
		return extension_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtension_STATUS(generators)
	extension_STATUSGenerator = gen.Struct(reflect.TypeOf(Extension_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtension_STATUS(generators)
	AddRelatedPropertyGeneratorsForExtension_STATUS(generators)
	extension_STATUSGenerator = gen.Struct(reflect.TypeOf(Extension_STATUS{}), generators)

	return extension_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForExtension_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtension_STATUS(gens map[string]gopter.Gen) {
	gens["AutoUpgradeMinorVersion"] = gen.PtrOf(gen.Bool())
	gens["ConfigurationProtectedSettings"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["ConfigurationSettings"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["CurrentVersion"] = gen.PtrOf(gen.AlphaString())
	gens["CustomLocationSettings"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["ExtensionType"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IsSystemExtension"] = gen.PtrOf(gen.Bool())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PackageUri"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["ReleaseTrain"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["Version"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForExtension_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForExtension_STATUS(gens map[string]gopter.Gen) {
	gens["AksAssignedIdentity"] = gen.PtrOf(Extension_Properties_AksAssignedIdentity_STATUSGenerator())
	gens["ErrorInfo"] = gen.PtrOf(ErrorDetail_STATUSGenerator())
	gens["Identity"] = gen.PtrOf(Identity_STATUSGenerator())
	gens["Plan"] = gen.PtrOf(Plan_STATUSGenerator())
	gens["Scope"] = gen.PtrOf(Scope_STATUSGenerator())
	gens["Statuses"] = gen.SliceOf(ExtensionStatus_STATUSGenerator())
	gens["SystemData"] = gen.PtrOf(SystemData_STATUSGenerator())
}

func Test_ErrorDetail_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ErrorDetail_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForErrorDetail_STATUS, ErrorDetail_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForErrorDetail_STATUS runs a test to see if a specific instance of ErrorDetail_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForErrorDetail_STATUS(subject ErrorDetail_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ErrorDetail_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ErrorDetail_STATUS instances for property testing - lazily instantiated by ErrorDetail_STATUSGenerator()
var errorDetail_STATUSGenerator gopter.Gen

// ErrorDetail_STATUSGenerator returns a generator of ErrorDetail_STATUS instances for property testing.
// We first initialize errorDetail_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ErrorDetail_STATUSGenerator() gopter.Gen {
	if errorDetail_STATUSGenerator != nil {
		return errorDetail_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForErrorDetail_STATUS(generators)
	errorDetail_STATUSGenerator = gen.Struct(reflect.TypeOf(ErrorDetail_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForErrorDetail_STATUS(generators)
	AddRelatedPropertyGeneratorsForErrorDetail_STATUS(generators)
	errorDetail_STATUSGenerator = gen.Struct(reflect.TypeOf(ErrorDetail_STATUS{}), generators)

	return errorDetail_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForErrorDetail_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForErrorDetail_STATUS(gens map[string]gopter.Gen) {
	gens["Code"] = gen.PtrOf(gen.AlphaString())
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForErrorDetail_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForErrorDetail_STATUS(gens map[string]gopter.Gen) {
	gens["AdditionalInfo"] = gen.SliceOf(ErrorAdditionalInfo_STATUSGenerator())
	gens["Details"] = gen.SliceOf(ErrorDetail_STATUS_UnrolledGenerator())
}

func Test_Extension_Properties_AksAssignedIdentity_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Extension_Properties_AksAssignedIdentity_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtension_Properties_AksAssignedIdentity_Spec, Extension_Properties_AksAssignedIdentity_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtension_Properties_AksAssignedIdentity_Spec runs a test to see if a specific instance of Extension_Properties_AksAssignedIdentity_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForExtension_Properties_AksAssignedIdentity_Spec(subject Extension_Properties_AksAssignedIdentity_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Extension_Properties_AksAssignedIdentity_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Extension_Properties_AksAssignedIdentity_Spec instances for property testing - lazily instantiated by
// Extension_Properties_AksAssignedIdentity_SpecGenerator()
var extension_Properties_AksAssignedIdentity_SpecGenerator gopter.Gen

// Extension_Properties_AksAssignedIdentity_SpecGenerator returns a generator of Extension_Properties_AksAssignedIdentity_Spec instances for property testing.
func Extension_Properties_AksAssignedIdentity_SpecGenerator() gopter.Gen {
	if extension_Properties_AksAssignedIdentity_SpecGenerator != nil {
		return extension_Properties_AksAssignedIdentity_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtension_Properties_AksAssignedIdentity_Spec(generators)
	extension_Properties_AksAssignedIdentity_SpecGenerator = gen.Struct(reflect.TypeOf(Extension_Properties_AksAssignedIdentity_Spec{}), generators)

	return extension_Properties_AksAssignedIdentity_SpecGenerator
}

// AddIndependentPropertyGeneratorsForExtension_Properties_AksAssignedIdentity_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtension_Properties_AksAssignedIdentity_Spec(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_Extension_Properties_AksAssignedIdentity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Extension_Properties_AksAssignedIdentity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtension_Properties_AksAssignedIdentity_STATUS, Extension_Properties_AksAssignedIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtension_Properties_AksAssignedIdentity_STATUS runs a test to see if a specific instance of Extension_Properties_AksAssignedIdentity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForExtension_Properties_AksAssignedIdentity_STATUS(subject Extension_Properties_AksAssignedIdentity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Extension_Properties_AksAssignedIdentity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Extension_Properties_AksAssignedIdentity_STATUS instances for property testing - lazily instantiated by
// Extension_Properties_AksAssignedIdentity_STATUSGenerator()
var extension_Properties_AksAssignedIdentity_STATUSGenerator gopter.Gen

// Extension_Properties_AksAssignedIdentity_STATUSGenerator returns a generator of Extension_Properties_AksAssignedIdentity_STATUS instances for property testing.
func Extension_Properties_AksAssignedIdentity_STATUSGenerator() gopter.Gen {
	if extension_Properties_AksAssignedIdentity_STATUSGenerator != nil {
		return extension_Properties_AksAssignedIdentity_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtension_Properties_AksAssignedIdentity_STATUS(generators)
	extension_Properties_AksAssignedIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(Extension_Properties_AksAssignedIdentity_STATUS{}), generators)

	return extension_Properties_AksAssignedIdentity_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForExtension_Properties_AksAssignedIdentity_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtension_Properties_AksAssignedIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_ExtensionStatus_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtensionStatus_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtensionStatus_STATUS, ExtensionStatus_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtensionStatus_STATUS runs a test to see if a specific instance of ExtensionStatus_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForExtensionStatus_STATUS(subject ExtensionStatus_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtensionStatus_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtensionStatus_STATUS instances for property testing - lazily instantiated by
// ExtensionStatus_STATUSGenerator()
var extensionStatus_STATUSGenerator gopter.Gen

// ExtensionStatus_STATUSGenerator returns a generator of ExtensionStatus_STATUS instances for property testing.
func ExtensionStatus_STATUSGenerator() gopter.Gen {
	if extensionStatus_STATUSGenerator != nil {
		return extensionStatus_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtensionStatus_STATUS(generators)
	extensionStatus_STATUSGenerator = gen.Struct(reflect.TypeOf(ExtensionStatus_STATUS{}), generators)

	return extensionStatus_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForExtensionStatus_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtensionStatus_STATUS(gens map[string]gopter.Gen) {
	gens["Code"] = gen.PtrOf(gen.AlphaString())
	gens["DisplayStatus"] = gen.PtrOf(gen.AlphaString())
	gens["Level"] = gen.PtrOf(gen.AlphaString())
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Time"] = gen.PtrOf(gen.AlphaString())
}

func Test_Identity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Identity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIdentity, IdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIdentity runs a test to see if a specific instance of Identity round trips to JSON and back losslessly
func RunJSONSerializationTestForIdentity(subject Identity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Identity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Identity instances for property testing - lazily instantiated by IdentityGenerator()
var identityGenerator gopter.Gen

// IdentityGenerator returns a generator of Identity instances for property testing.
func IdentityGenerator() gopter.Gen {
	if identityGenerator != nil {
		return identityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentity(generators)
	identityGenerator = gen.Struct(reflect.TypeOf(Identity{}), generators)

	return identityGenerator
}

// AddIndependentPropertyGeneratorsForIdentity is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIdentity(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_Identity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Identity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIdentity_STATUS, Identity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIdentity_STATUS runs a test to see if a specific instance of Identity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForIdentity_STATUS(subject Identity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Identity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Identity_STATUS instances for property testing - lazily instantiated by Identity_STATUSGenerator()
var identity_STATUSGenerator gopter.Gen

// Identity_STATUSGenerator returns a generator of Identity_STATUS instances for property testing.
func Identity_STATUSGenerator() gopter.Gen {
	if identity_STATUSGenerator != nil {
		return identity_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentity_STATUS(generators)
	identity_STATUSGenerator = gen.Struct(reflect.TypeOf(Identity_STATUS{}), generators)

	return identity_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForIdentity_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_Plan_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Plan via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPlan, PlanGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPlan runs a test to see if a specific instance of Plan round trips to JSON and back losslessly
func RunJSONSerializationTestForPlan(subject Plan) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Plan
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Plan instances for property testing - lazily instantiated by PlanGenerator()
var planGenerator gopter.Gen

// PlanGenerator returns a generator of Plan instances for property testing.
func PlanGenerator() gopter.Gen {
	if planGenerator != nil {
		return planGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPlan(generators)
	planGenerator = gen.Struct(reflect.TypeOf(Plan{}), generators)

	return planGenerator
}

// AddIndependentPropertyGeneratorsForPlan is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPlan(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Product"] = gen.PtrOf(gen.AlphaString())
	gens["PromotionCode"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
	gens["Version"] = gen.PtrOf(gen.AlphaString())
}

func Test_Plan_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Plan_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPlan_STATUS, Plan_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPlan_STATUS runs a test to see if a specific instance of Plan_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPlan_STATUS(subject Plan_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Plan_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Plan_STATUS instances for property testing - lazily instantiated by Plan_STATUSGenerator()
var plan_STATUSGenerator gopter.Gen

// Plan_STATUSGenerator returns a generator of Plan_STATUS instances for property testing.
func Plan_STATUSGenerator() gopter.Gen {
	if plan_STATUSGenerator != nil {
		return plan_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPlan_STATUS(generators)
	plan_STATUSGenerator = gen.Struct(reflect.TypeOf(Plan_STATUS{}), generators)

	return plan_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForPlan_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPlan_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Product"] = gen.PtrOf(gen.AlphaString())
	gens["PromotionCode"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
	gens["Version"] = gen.PtrOf(gen.AlphaString())
}

func Test_Scope_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Scope via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScope, ScopeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScope runs a test to see if a specific instance of Scope round trips to JSON and back losslessly
func RunJSONSerializationTestForScope(subject Scope) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Scope
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Scope instances for property testing - lazily instantiated by ScopeGenerator()
var scopeGenerator gopter.Gen

// ScopeGenerator returns a generator of Scope instances for property testing.
func ScopeGenerator() gopter.Gen {
	if scopeGenerator != nil {
		return scopeGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForScope(generators)
	scopeGenerator = gen.Struct(reflect.TypeOf(Scope{}), generators)

	return scopeGenerator
}

// AddRelatedPropertyGeneratorsForScope is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForScope(gens map[string]gopter.Gen) {
	gens["Cluster"] = gen.PtrOf(ScopeClusterGenerator())
	gens["Namespace"] = gen.PtrOf(ScopeNamespaceGenerator())
}

func Test_Scope_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Scope_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScope_STATUS, Scope_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScope_STATUS runs a test to see if a specific instance of Scope_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForScope_STATUS(subject Scope_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Scope_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Scope_STATUS instances for property testing - lazily instantiated by Scope_STATUSGenerator()
var scope_STATUSGenerator gopter.Gen

// Scope_STATUSGenerator returns a generator of Scope_STATUS instances for property testing.
func Scope_STATUSGenerator() gopter.Gen {
	if scope_STATUSGenerator != nil {
		return scope_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForScope_STATUS(generators)
	scope_STATUSGenerator = gen.Struct(reflect.TypeOf(Scope_STATUS{}), generators)

	return scope_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForScope_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForScope_STATUS(gens map[string]gopter.Gen) {
	gens["Cluster"] = gen.PtrOf(ScopeCluster_STATUSGenerator())
	gens["Namespace"] = gen.PtrOf(ScopeNamespace_STATUSGenerator())
}

func Test_SystemData_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SystemData via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSystemData, SystemDataGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSystemData runs a test to see if a specific instance of SystemData round trips to JSON and back losslessly
func RunJSONSerializationTestForSystemData(subject SystemData) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SystemData
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SystemData instances for property testing - lazily instantiated by SystemDataGenerator()
var systemDataGenerator gopter.Gen

// SystemDataGenerator returns a generator of SystemData instances for property testing.
func SystemDataGenerator() gopter.Gen {
	if systemDataGenerator != nil {
		return systemDataGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSystemData(generators)
	systemDataGenerator = gen.Struct(reflect.TypeOf(SystemData{}), generators)

	return systemDataGenerator
}

// AddIndependentPropertyGeneratorsForSystemData is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSystemData(gens map[string]gopter.Gen) {
	gens["CreatedAt"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedBy"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedByType"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedAt"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedBy"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedByType"] = gen.PtrOf(gen.AlphaString())
}

func Test_SystemData_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SystemData_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSystemData_STATUS, SystemData_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSystemData_STATUS runs a test to see if a specific instance of SystemData_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSystemData_STATUS(subject SystemData_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SystemData_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SystemData_STATUS instances for property testing - lazily instantiated by SystemData_STATUSGenerator()
var systemData_STATUSGenerator gopter.Gen

// SystemData_STATUSGenerator returns a generator of SystemData_STATUS instances for property testing.
func SystemData_STATUSGenerator() gopter.Gen {
	if systemData_STATUSGenerator != nil {
		return systemData_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSystemData_STATUS(generators)
	systemData_STATUSGenerator = gen.Struct(reflect.TypeOf(SystemData_STATUS{}), generators)

	return systemData_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSystemData_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSystemData_STATUS(gens map[string]gopter.Gen) {
	gens["CreatedAt"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedBy"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedByType"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedAt"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedBy"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedByType"] = gen.PtrOf(gen.AlphaString())
}

func Test_ErrorAdditionalInfo_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ErrorAdditionalInfo_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForErrorAdditionalInfo_STATUS, ErrorAdditionalInfo_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForErrorAdditionalInfo_STATUS runs a test to see if a specific instance of ErrorAdditionalInfo_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForErrorAdditionalInfo_STATUS(subject ErrorAdditionalInfo_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ErrorAdditionalInfo_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ErrorAdditionalInfo_STATUS instances for property testing - lazily instantiated by
// ErrorAdditionalInfo_STATUSGenerator()
var errorAdditionalInfo_STATUSGenerator gopter.Gen

// ErrorAdditionalInfo_STATUSGenerator returns a generator of ErrorAdditionalInfo_STATUS instances for property testing.
func ErrorAdditionalInfo_STATUSGenerator() gopter.Gen {
	if errorAdditionalInfo_STATUSGenerator != nil {
		return errorAdditionalInfo_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForErrorAdditionalInfo_STATUS(generators)
	errorAdditionalInfo_STATUSGenerator = gen.Struct(reflect.TypeOf(ErrorAdditionalInfo_STATUS{}), generators)

	return errorAdditionalInfo_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForErrorAdditionalInfo_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForErrorAdditionalInfo_STATUS(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_ErrorDetail_STATUS_Unrolled_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ErrorDetail_STATUS_Unrolled via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForErrorDetail_STATUS_Unrolled, ErrorDetail_STATUS_UnrolledGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForErrorDetail_STATUS_Unrolled runs a test to see if a specific instance of ErrorDetail_STATUS_Unrolled round trips to JSON and back losslessly
func RunJSONSerializationTestForErrorDetail_STATUS_Unrolled(subject ErrorDetail_STATUS_Unrolled) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ErrorDetail_STATUS_Unrolled
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ErrorDetail_STATUS_Unrolled instances for property testing - lazily instantiated by
// ErrorDetail_STATUS_UnrolledGenerator()
var errorDetail_STATUS_UnrolledGenerator gopter.Gen

// ErrorDetail_STATUS_UnrolledGenerator returns a generator of ErrorDetail_STATUS_Unrolled instances for property testing.
// We first initialize errorDetail_STATUS_UnrolledGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ErrorDetail_STATUS_UnrolledGenerator() gopter.Gen {
	if errorDetail_STATUS_UnrolledGenerator != nil {
		return errorDetail_STATUS_UnrolledGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForErrorDetail_STATUS_Unrolled(generators)
	errorDetail_STATUS_UnrolledGenerator = gen.Struct(reflect.TypeOf(ErrorDetail_STATUS_Unrolled{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForErrorDetail_STATUS_Unrolled(generators)
	AddRelatedPropertyGeneratorsForErrorDetail_STATUS_Unrolled(generators)
	errorDetail_STATUS_UnrolledGenerator = gen.Struct(reflect.TypeOf(ErrorDetail_STATUS_Unrolled{}), generators)

	return errorDetail_STATUS_UnrolledGenerator
}

// AddIndependentPropertyGeneratorsForErrorDetail_STATUS_Unrolled is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForErrorDetail_STATUS_Unrolled(gens map[string]gopter.Gen) {
	gens["Code"] = gen.PtrOf(gen.AlphaString())
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForErrorDetail_STATUS_Unrolled is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForErrorDetail_STATUS_Unrolled(gens map[string]gopter.Gen) {
	gens["AdditionalInfo"] = gen.SliceOf(ErrorAdditionalInfo_STATUSGenerator())
}

func Test_ScopeCluster_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScopeCluster via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScopeCluster, ScopeClusterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScopeCluster runs a test to see if a specific instance of ScopeCluster round trips to JSON and back losslessly
func RunJSONSerializationTestForScopeCluster(subject ScopeCluster) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScopeCluster
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScopeCluster instances for property testing - lazily instantiated by ScopeClusterGenerator()
var scopeClusterGenerator gopter.Gen

// ScopeClusterGenerator returns a generator of ScopeCluster instances for property testing.
func ScopeClusterGenerator() gopter.Gen {
	if scopeClusterGenerator != nil {
		return scopeClusterGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScopeCluster(generators)
	scopeClusterGenerator = gen.Struct(reflect.TypeOf(ScopeCluster{}), generators)

	return scopeClusterGenerator
}

// AddIndependentPropertyGeneratorsForScopeCluster is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScopeCluster(gens map[string]gopter.Gen) {
	gens["ReleaseNamespace"] = gen.PtrOf(gen.AlphaString())
}

func Test_ScopeCluster_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScopeCluster_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScopeCluster_STATUS, ScopeCluster_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScopeCluster_STATUS runs a test to see if a specific instance of ScopeCluster_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForScopeCluster_STATUS(subject ScopeCluster_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScopeCluster_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScopeCluster_STATUS instances for property testing - lazily instantiated by
// ScopeCluster_STATUSGenerator()
var scopeCluster_STATUSGenerator gopter.Gen

// ScopeCluster_STATUSGenerator returns a generator of ScopeCluster_STATUS instances for property testing.
func ScopeCluster_STATUSGenerator() gopter.Gen {
	if scopeCluster_STATUSGenerator != nil {
		return scopeCluster_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScopeCluster_STATUS(generators)
	scopeCluster_STATUSGenerator = gen.Struct(reflect.TypeOf(ScopeCluster_STATUS{}), generators)

	return scopeCluster_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForScopeCluster_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScopeCluster_STATUS(gens map[string]gopter.Gen) {
	gens["ReleaseNamespace"] = gen.PtrOf(gen.AlphaString())
}

func Test_ScopeNamespace_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScopeNamespace via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScopeNamespace, ScopeNamespaceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScopeNamespace runs a test to see if a specific instance of ScopeNamespace round trips to JSON and back losslessly
func RunJSONSerializationTestForScopeNamespace(subject ScopeNamespace) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScopeNamespace
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScopeNamespace instances for property testing - lazily instantiated by ScopeNamespaceGenerator()
var scopeNamespaceGenerator gopter.Gen

// ScopeNamespaceGenerator returns a generator of ScopeNamespace instances for property testing.
func ScopeNamespaceGenerator() gopter.Gen {
	if scopeNamespaceGenerator != nil {
		return scopeNamespaceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScopeNamespace(generators)
	scopeNamespaceGenerator = gen.Struct(reflect.TypeOf(ScopeNamespace{}), generators)

	return scopeNamespaceGenerator
}

// AddIndependentPropertyGeneratorsForScopeNamespace is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScopeNamespace(gens map[string]gopter.Gen) {
	gens["TargetNamespace"] = gen.PtrOf(gen.AlphaString())
}

func Test_ScopeNamespace_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScopeNamespace_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScopeNamespace_STATUS, ScopeNamespace_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScopeNamespace_STATUS runs a test to see if a specific instance of ScopeNamespace_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForScopeNamespace_STATUS(subject ScopeNamespace_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScopeNamespace_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScopeNamespace_STATUS instances for property testing - lazily instantiated by
// ScopeNamespace_STATUSGenerator()
var scopeNamespace_STATUSGenerator gopter.Gen

// ScopeNamespace_STATUSGenerator returns a generator of ScopeNamespace_STATUS instances for property testing.
func ScopeNamespace_STATUSGenerator() gopter.Gen {
	if scopeNamespace_STATUSGenerator != nil {
		return scopeNamespace_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScopeNamespace_STATUS(generators)
	scopeNamespace_STATUSGenerator = gen.Struct(reflect.TypeOf(ScopeNamespace_STATUS{}), generators)

	return scopeNamespace_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForScopeNamespace_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScopeNamespace_STATUS(gens map[string]gopter.Gen) {
	gens["TargetNamespace"] = gen.PtrOf(gen.AlphaString())
}
