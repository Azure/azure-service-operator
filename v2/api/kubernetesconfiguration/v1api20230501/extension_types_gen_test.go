// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20230501

import (
	"encoding/json"
	v20230501s "github.com/Azure/azure-service-operator/v2/api/kubernetesconfiguration/v1api20230501/storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_Extension_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	parameters.MinSuccessfulTests = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Extension to hub returns original",
		prop.ForAll(RunResourceConversionTestForExtension, ExtensionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForExtension tests if a specific instance of Extension round trips to the hub storage version and back losslessly
func RunResourceConversionTestForExtension(subject Extension) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v20230501s.Extension
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual Extension
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Extension_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Extension to Extension via AssignProperties_To_Extension & AssignProperties_From_Extension returns original",
		prop.ForAll(RunPropertyAssignmentTestForExtension, ExtensionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExtension tests if a specific instance of Extension can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForExtension(subject Extension) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230501s.Extension
	err := copied.AssignProperties_To_Extension(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Extension
	err = actual.AssignProperties_From_Extension(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Extension_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Extension via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtension, ExtensionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtension runs a test to see if a specific instance of Extension round trips to JSON and back losslessly
func RunJSONSerializationTestForExtension(subject Extension) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Extension
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Extension instances for property testing - lazily instantiated by ExtensionGenerator()
var extensionGenerator gopter.Gen

// ExtensionGenerator returns a generator of Extension instances for property testing.
func ExtensionGenerator() gopter.Gen {
	if extensionGenerator != nil {
		return extensionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForExtension(generators)
	extensionGenerator = gen.Struct(reflect.TypeOf(Extension{}), generators)

	return extensionGenerator
}

// AddRelatedPropertyGeneratorsForExtension is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForExtension(gens map[string]gopter.Gen) {
	gens["Spec"] = Extension_SpecGenerator()
	gens["Status"] = Extension_STATUSGenerator()
}

func Test_Extension_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Extension_Spec to Extension_Spec via AssignProperties_To_Extension_Spec & AssignProperties_From_Extension_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForExtension_Spec, Extension_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExtension_Spec tests if a specific instance of Extension_Spec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForExtension_Spec(subject Extension_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230501s.Extension_Spec
	err := copied.AssignProperties_To_Extension_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Extension_Spec
	err = actual.AssignProperties_From_Extension_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Extension_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Extension_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtension_Spec, Extension_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtension_Spec runs a test to see if a specific instance of Extension_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForExtension_Spec(subject Extension_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Extension_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Extension_Spec instances for property testing - lazily instantiated by Extension_SpecGenerator()
var extension_SpecGenerator gopter.Gen

// Extension_SpecGenerator returns a generator of Extension_Spec instances for property testing.
// We first initialize extension_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Extension_SpecGenerator() gopter.Gen {
	if extension_SpecGenerator != nil {
		return extension_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtension_Spec(generators)
	extension_SpecGenerator = gen.Struct(reflect.TypeOf(Extension_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtension_Spec(generators)
	AddRelatedPropertyGeneratorsForExtension_Spec(generators)
	extension_SpecGenerator = gen.Struct(reflect.TypeOf(Extension_Spec{}), generators)

	return extension_SpecGenerator
}

// AddIndependentPropertyGeneratorsForExtension_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtension_Spec(gens map[string]gopter.Gen) {
	gens["AutoUpgradeMinorVersion"] = gen.PtrOf(gen.Bool())
	gens["AzureName"] = gen.AlphaString()
	gens["ConfigurationSettings"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["ExtensionType"] = gen.PtrOf(gen.AlphaString())
	gens["ReleaseTrain"] = gen.PtrOf(gen.AlphaString())
	gens["Version"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForExtension_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForExtension_Spec(gens map[string]gopter.Gen) {
	gens["AksAssignedIdentity"] = gen.PtrOf(Extension_Properties_AksAssignedIdentity_SpecGenerator())
	gens["Identity"] = gen.PtrOf(IdentityGenerator())
	gens["Plan"] = gen.PtrOf(PlanGenerator())
	gens["Scope"] = gen.PtrOf(ScopeGenerator())
	gens["SystemData"] = gen.PtrOf(SystemDataGenerator())
}

func Test_Extension_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Extension_STATUS to Extension_STATUS via AssignProperties_To_Extension_STATUS & AssignProperties_From_Extension_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForExtension_STATUS, Extension_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExtension_STATUS tests if a specific instance of Extension_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForExtension_STATUS(subject Extension_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230501s.Extension_STATUS
	err := copied.AssignProperties_To_Extension_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Extension_STATUS
	err = actual.AssignProperties_From_Extension_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Extension_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Extension_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtension_STATUS, Extension_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtension_STATUS runs a test to see if a specific instance of Extension_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForExtension_STATUS(subject Extension_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Extension_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Extension_STATUS instances for property testing - lazily instantiated by Extension_STATUSGenerator()
var extension_STATUSGenerator gopter.Gen

// Extension_STATUSGenerator returns a generator of Extension_STATUS instances for property testing.
// We first initialize extension_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Extension_STATUSGenerator() gopter.Gen {
	if extension_STATUSGenerator != nil {
		return extension_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtension_STATUS(generators)
	extension_STATUSGenerator = gen.Struct(reflect.TypeOf(Extension_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtension_STATUS(generators)
	AddRelatedPropertyGeneratorsForExtension_STATUS(generators)
	extension_STATUSGenerator = gen.Struct(reflect.TypeOf(Extension_STATUS{}), generators)

	return extension_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForExtension_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtension_STATUS(gens map[string]gopter.Gen) {
	gens["AutoUpgradeMinorVersion"] = gen.PtrOf(gen.Bool())
	gens["ConfigurationProtectedSettings"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["ConfigurationSettings"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["CurrentVersion"] = gen.PtrOf(gen.AlphaString())
	gens["CustomLocationSettings"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["ExtensionType"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IsSystemExtension"] = gen.PtrOf(gen.Bool())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PackageUri"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningStateDefinition_STATUS_Canceled,
		ProvisioningStateDefinition_STATUS_Creating,
		ProvisioningStateDefinition_STATUS_Deleting,
		ProvisioningStateDefinition_STATUS_Failed,
		ProvisioningStateDefinition_STATUS_Succeeded,
		ProvisioningStateDefinition_STATUS_Updating))
	gens["ReleaseTrain"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["Version"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForExtension_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForExtension_STATUS(gens map[string]gopter.Gen) {
	gens["AksAssignedIdentity"] = gen.PtrOf(Extension_Properties_AksAssignedIdentity_STATUSGenerator())
	gens["ErrorInfo"] = gen.PtrOf(ErrorDetail_STATUSGenerator())
	gens["Identity"] = gen.PtrOf(Identity_STATUSGenerator())
	gens["Plan"] = gen.PtrOf(Plan_STATUSGenerator())
	gens["Scope"] = gen.PtrOf(Scope_STATUSGenerator())
	gens["Statuses"] = gen.SliceOf(ExtensionStatus_STATUSGenerator())
	gens["SystemData"] = gen.PtrOf(SystemData_STATUSGenerator())
}

func Test_ErrorDetail_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ErrorDetail_STATUS to ErrorDetail_STATUS via AssignProperties_To_ErrorDetail_STATUS & AssignProperties_From_ErrorDetail_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForErrorDetail_STATUS, ErrorDetail_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForErrorDetail_STATUS tests if a specific instance of ErrorDetail_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForErrorDetail_STATUS(subject ErrorDetail_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230501s.ErrorDetail_STATUS
	err := copied.AssignProperties_To_ErrorDetail_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ErrorDetail_STATUS
	err = actual.AssignProperties_From_ErrorDetail_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ErrorDetail_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ErrorDetail_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForErrorDetail_STATUS, ErrorDetail_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForErrorDetail_STATUS runs a test to see if a specific instance of ErrorDetail_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForErrorDetail_STATUS(subject ErrorDetail_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ErrorDetail_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ErrorDetail_STATUS instances for property testing - lazily instantiated by ErrorDetail_STATUSGenerator()
var errorDetail_STATUSGenerator gopter.Gen

// ErrorDetail_STATUSGenerator returns a generator of ErrorDetail_STATUS instances for property testing.
// We first initialize errorDetail_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ErrorDetail_STATUSGenerator() gopter.Gen {
	if errorDetail_STATUSGenerator != nil {
		return errorDetail_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForErrorDetail_STATUS(generators)
	errorDetail_STATUSGenerator = gen.Struct(reflect.TypeOf(ErrorDetail_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForErrorDetail_STATUS(generators)
	AddRelatedPropertyGeneratorsForErrorDetail_STATUS(generators)
	errorDetail_STATUSGenerator = gen.Struct(reflect.TypeOf(ErrorDetail_STATUS{}), generators)

	return errorDetail_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForErrorDetail_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForErrorDetail_STATUS(gens map[string]gopter.Gen) {
	gens["Code"] = gen.PtrOf(gen.AlphaString())
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForErrorDetail_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForErrorDetail_STATUS(gens map[string]gopter.Gen) {
	gens["AdditionalInfo"] = gen.SliceOf(ErrorAdditionalInfo_STATUSGenerator())
	gens["Details"] = gen.SliceOf(ErrorDetail_STATUS_UnrolledGenerator())
}

func Test_Extension_Properties_AksAssignedIdentity_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Extension_Properties_AksAssignedIdentity_Spec to Extension_Properties_AksAssignedIdentity_Spec via AssignProperties_To_Extension_Properties_AksAssignedIdentity_Spec & AssignProperties_From_Extension_Properties_AksAssignedIdentity_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForExtension_Properties_AksAssignedIdentity_Spec, Extension_Properties_AksAssignedIdentity_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExtension_Properties_AksAssignedIdentity_Spec tests if a specific instance of Extension_Properties_AksAssignedIdentity_Spec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForExtension_Properties_AksAssignedIdentity_Spec(subject Extension_Properties_AksAssignedIdentity_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230501s.Extension_Properties_AksAssignedIdentity_Spec
	err := copied.AssignProperties_To_Extension_Properties_AksAssignedIdentity_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Extension_Properties_AksAssignedIdentity_Spec
	err = actual.AssignProperties_From_Extension_Properties_AksAssignedIdentity_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Extension_Properties_AksAssignedIdentity_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Extension_Properties_AksAssignedIdentity_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtension_Properties_AksAssignedIdentity_Spec, Extension_Properties_AksAssignedIdentity_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtension_Properties_AksAssignedIdentity_Spec runs a test to see if a specific instance of Extension_Properties_AksAssignedIdentity_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForExtension_Properties_AksAssignedIdentity_Spec(subject Extension_Properties_AksAssignedIdentity_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Extension_Properties_AksAssignedIdentity_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Extension_Properties_AksAssignedIdentity_Spec instances for property testing - lazily instantiated by
// Extension_Properties_AksAssignedIdentity_SpecGenerator()
var extension_Properties_AksAssignedIdentity_SpecGenerator gopter.Gen

// Extension_Properties_AksAssignedIdentity_SpecGenerator returns a generator of Extension_Properties_AksAssignedIdentity_Spec instances for property testing.
func Extension_Properties_AksAssignedIdentity_SpecGenerator() gopter.Gen {
	if extension_Properties_AksAssignedIdentity_SpecGenerator != nil {
		return extension_Properties_AksAssignedIdentity_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtension_Properties_AksAssignedIdentity_Spec(generators)
	extension_Properties_AksAssignedIdentity_SpecGenerator = gen.Struct(reflect.TypeOf(Extension_Properties_AksAssignedIdentity_Spec{}), generators)

	return extension_Properties_AksAssignedIdentity_SpecGenerator
}

// AddIndependentPropertyGeneratorsForExtension_Properties_AksAssignedIdentity_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtension_Properties_AksAssignedIdentity_Spec(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(Extension_Properties_AksAssignedIdentity_Type_Spec_SystemAssigned, Extension_Properties_AksAssignedIdentity_Type_Spec_UserAssigned))
}

func Test_Extension_Properties_AksAssignedIdentity_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Extension_Properties_AksAssignedIdentity_STATUS to Extension_Properties_AksAssignedIdentity_STATUS via AssignProperties_To_Extension_Properties_AksAssignedIdentity_STATUS & AssignProperties_From_Extension_Properties_AksAssignedIdentity_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForExtension_Properties_AksAssignedIdentity_STATUS, Extension_Properties_AksAssignedIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExtension_Properties_AksAssignedIdentity_STATUS tests if a specific instance of Extension_Properties_AksAssignedIdentity_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForExtension_Properties_AksAssignedIdentity_STATUS(subject Extension_Properties_AksAssignedIdentity_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230501s.Extension_Properties_AksAssignedIdentity_STATUS
	err := copied.AssignProperties_To_Extension_Properties_AksAssignedIdentity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Extension_Properties_AksAssignedIdentity_STATUS
	err = actual.AssignProperties_From_Extension_Properties_AksAssignedIdentity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Extension_Properties_AksAssignedIdentity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Extension_Properties_AksAssignedIdentity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtension_Properties_AksAssignedIdentity_STATUS, Extension_Properties_AksAssignedIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtension_Properties_AksAssignedIdentity_STATUS runs a test to see if a specific instance of Extension_Properties_AksAssignedIdentity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForExtension_Properties_AksAssignedIdentity_STATUS(subject Extension_Properties_AksAssignedIdentity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Extension_Properties_AksAssignedIdentity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Extension_Properties_AksAssignedIdentity_STATUS instances for property testing - lazily instantiated by
// Extension_Properties_AksAssignedIdentity_STATUSGenerator()
var extension_Properties_AksAssignedIdentity_STATUSGenerator gopter.Gen

// Extension_Properties_AksAssignedIdentity_STATUSGenerator returns a generator of Extension_Properties_AksAssignedIdentity_STATUS instances for property testing.
func Extension_Properties_AksAssignedIdentity_STATUSGenerator() gopter.Gen {
	if extension_Properties_AksAssignedIdentity_STATUSGenerator != nil {
		return extension_Properties_AksAssignedIdentity_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtension_Properties_AksAssignedIdentity_STATUS(generators)
	extension_Properties_AksAssignedIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(Extension_Properties_AksAssignedIdentity_STATUS{}), generators)

	return extension_Properties_AksAssignedIdentity_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForExtension_Properties_AksAssignedIdentity_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtension_Properties_AksAssignedIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(Extension_Properties_AksAssignedIdentity_Type_STATUS_SystemAssigned, Extension_Properties_AksAssignedIdentity_Type_STATUS_UserAssigned))
}

func Test_ExtensionStatus_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ExtensionStatus_STATUS to ExtensionStatus_STATUS via AssignProperties_To_ExtensionStatus_STATUS & AssignProperties_From_ExtensionStatus_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForExtensionStatus_STATUS, ExtensionStatus_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExtensionStatus_STATUS tests if a specific instance of ExtensionStatus_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForExtensionStatus_STATUS(subject ExtensionStatus_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230501s.ExtensionStatus_STATUS
	err := copied.AssignProperties_To_ExtensionStatus_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ExtensionStatus_STATUS
	err = actual.AssignProperties_From_ExtensionStatus_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ExtensionStatus_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtensionStatus_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtensionStatus_STATUS, ExtensionStatus_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtensionStatus_STATUS runs a test to see if a specific instance of ExtensionStatus_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForExtensionStatus_STATUS(subject ExtensionStatus_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtensionStatus_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtensionStatus_STATUS instances for property testing - lazily instantiated by
// ExtensionStatus_STATUSGenerator()
var extensionStatus_STATUSGenerator gopter.Gen

// ExtensionStatus_STATUSGenerator returns a generator of ExtensionStatus_STATUS instances for property testing.
func ExtensionStatus_STATUSGenerator() gopter.Gen {
	if extensionStatus_STATUSGenerator != nil {
		return extensionStatus_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtensionStatus_STATUS(generators)
	extensionStatus_STATUSGenerator = gen.Struct(reflect.TypeOf(ExtensionStatus_STATUS{}), generators)

	return extensionStatus_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForExtensionStatus_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtensionStatus_STATUS(gens map[string]gopter.Gen) {
	gens["Code"] = gen.PtrOf(gen.AlphaString())
	gens["DisplayStatus"] = gen.PtrOf(gen.AlphaString())
	gens["Level"] = gen.PtrOf(gen.OneConstOf(ExtensionStatus_Level_STATUS_Error, ExtensionStatus_Level_STATUS_Information, ExtensionStatus_Level_STATUS_Warning))
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Time"] = gen.PtrOf(gen.AlphaString())
}

func Test_Identity_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Identity to Identity via AssignProperties_To_Identity & AssignProperties_From_Identity returns original",
		prop.ForAll(RunPropertyAssignmentTestForIdentity, IdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIdentity tests if a specific instance of Identity can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForIdentity(subject Identity) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230501s.Identity
	err := copied.AssignProperties_To_Identity(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Identity
	err = actual.AssignProperties_From_Identity(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Identity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Identity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIdentity, IdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIdentity runs a test to see if a specific instance of Identity round trips to JSON and back losslessly
func RunJSONSerializationTestForIdentity(subject Identity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Identity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Identity instances for property testing - lazily instantiated by IdentityGenerator()
var identityGenerator gopter.Gen

// IdentityGenerator returns a generator of Identity instances for property testing.
func IdentityGenerator() gopter.Gen {
	if identityGenerator != nil {
		return identityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentity(generators)
	identityGenerator = gen.Struct(reflect.TypeOf(Identity{}), generators)

	return identityGenerator
}

// AddIndependentPropertyGeneratorsForIdentity is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIdentity(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(Identity_Type_SystemAssigned))
}

func Test_Identity_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Identity_STATUS to Identity_STATUS via AssignProperties_To_Identity_STATUS & AssignProperties_From_Identity_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForIdentity_STATUS, Identity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIdentity_STATUS tests if a specific instance of Identity_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForIdentity_STATUS(subject Identity_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230501s.Identity_STATUS
	err := copied.AssignProperties_To_Identity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Identity_STATUS
	err = actual.AssignProperties_From_Identity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Identity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Identity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIdentity_STATUS, Identity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIdentity_STATUS runs a test to see if a specific instance of Identity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForIdentity_STATUS(subject Identity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Identity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Identity_STATUS instances for property testing - lazily instantiated by Identity_STATUSGenerator()
var identity_STATUSGenerator gopter.Gen

// Identity_STATUSGenerator returns a generator of Identity_STATUS instances for property testing.
func Identity_STATUSGenerator() gopter.Gen {
	if identity_STATUSGenerator != nil {
		return identity_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIdentity_STATUS(generators)
	identity_STATUSGenerator = gen.Struct(reflect.TypeOf(Identity_STATUS{}), generators)

	return identity_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForIdentity_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(Identity_Type_STATUS_SystemAssigned))
}

func Test_Plan_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Plan to Plan via AssignProperties_To_Plan & AssignProperties_From_Plan returns original",
		prop.ForAll(RunPropertyAssignmentTestForPlan, PlanGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPlan tests if a specific instance of Plan can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForPlan(subject Plan) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230501s.Plan
	err := copied.AssignProperties_To_Plan(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Plan
	err = actual.AssignProperties_From_Plan(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Plan_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Plan via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPlan, PlanGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPlan runs a test to see if a specific instance of Plan round trips to JSON and back losslessly
func RunJSONSerializationTestForPlan(subject Plan) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Plan
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Plan instances for property testing - lazily instantiated by PlanGenerator()
var planGenerator gopter.Gen

// PlanGenerator returns a generator of Plan instances for property testing.
func PlanGenerator() gopter.Gen {
	if planGenerator != nil {
		return planGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPlan(generators)
	planGenerator = gen.Struct(reflect.TypeOf(Plan{}), generators)

	return planGenerator
}

// AddIndependentPropertyGeneratorsForPlan is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPlan(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Product"] = gen.PtrOf(gen.AlphaString())
	gens["PromotionCode"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
	gens["Version"] = gen.PtrOf(gen.AlphaString())
}

func Test_Plan_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Plan_STATUS to Plan_STATUS via AssignProperties_To_Plan_STATUS & AssignProperties_From_Plan_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForPlan_STATUS, Plan_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPlan_STATUS tests if a specific instance of Plan_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForPlan_STATUS(subject Plan_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230501s.Plan_STATUS
	err := copied.AssignProperties_To_Plan_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Plan_STATUS
	err = actual.AssignProperties_From_Plan_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Plan_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Plan_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPlan_STATUS, Plan_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPlan_STATUS runs a test to see if a specific instance of Plan_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPlan_STATUS(subject Plan_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Plan_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Plan_STATUS instances for property testing - lazily instantiated by Plan_STATUSGenerator()
var plan_STATUSGenerator gopter.Gen

// Plan_STATUSGenerator returns a generator of Plan_STATUS instances for property testing.
func Plan_STATUSGenerator() gopter.Gen {
	if plan_STATUSGenerator != nil {
		return plan_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPlan_STATUS(generators)
	plan_STATUSGenerator = gen.Struct(reflect.TypeOf(Plan_STATUS{}), generators)

	return plan_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForPlan_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPlan_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Product"] = gen.PtrOf(gen.AlphaString())
	gens["PromotionCode"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
	gens["Version"] = gen.PtrOf(gen.AlphaString())
}

func Test_Scope_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Scope to Scope via AssignProperties_To_Scope & AssignProperties_From_Scope returns original",
		prop.ForAll(RunPropertyAssignmentTestForScope, ScopeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForScope tests if a specific instance of Scope can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForScope(subject Scope) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230501s.Scope
	err := copied.AssignProperties_To_Scope(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Scope
	err = actual.AssignProperties_From_Scope(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Scope_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Scope via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScope, ScopeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScope runs a test to see if a specific instance of Scope round trips to JSON and back losslessly
func RunJSONSerializationTestForScope(subject Scope) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Scope
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Scope instances for property testing - lazily instantiated by ScopeGenerator()
var scopeGenerator gopter.Gen

// ScopeGenerator returns a generator of Scope instances for property testing.
func ScopeGenerator() gopter.Gen {
	if scopeGenerator != nil {
		return scopeGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForScope(generators)
	scopeGenerator = gen.Struct(reflect.TypeOf(Scope{}), generators)

	return scopeGenerator
}

// AddRelatedPropertyGeneratorsForScope is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForScope(gens map[string]gopter.Gen) {
	gens["Cluster"] = gen.PtrOf(ScopeClusterGenerator())
	gens["Namespace"] = gen.PtrOf(ScopeNamespaceGenerator())
}

func Test_Scope_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Scope_STATUS to Scope_STATUS via AssignProperties_To_Scope_STATUS & AssignProperties_From_Scope_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForScope_STATUS, Scope_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForScope_STATUS tests if a specific instance of Scope_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForScope_STATUS(subject Scope_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230501s.Scope_STATUS
	err := copied.AssignProperties_To_Scope_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Scope_STATUS
	err = actual.AssignProperties_From_Scope_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Scope_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Scope_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScope_STATUS, Scope_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScope_STATUS runs a test to see if a specific instance of Scope_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForScope_STATUS(subject Scope_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Scope_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Scope_STATUS instances for property testing - lazily instantiated by Scope_STATUSGenerator()
var scope_STATUSGenerator gopter.Gen

// Scope_STATUSGenerator returns a generator of Scope_STATUS instances for property testing.
func Scope_STATUSGenerator() gopter.Gen {
	if scope_STATUSGenerator != nil {
		return scope_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForScope_STATUS(generators)
	scope_STATUSGenerator = gen.Struct(reflect.TypeOf(Scope_STATUS{}), generators)

	return scope_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForScope_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForScope_STATUS(gens map[string]gopter.Gen) {
	gens["Cluster"] = gen.PtrOf(ScopeCluster_STATUSGenerator())
	gens["Namespace"] = gen.PtrOf(ScopeNamespace_STATUSGenerator())
}

func Test_SystemData_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SystemData to SystemData via AssignProperties_To_SystemData & AssignProperties_From_SystemData returns original",
		prop.ForAll(RunPropertyAssignmentTestForSystemData, SystemDataGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSystemData tests if a specific instance of SystemData can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSystemData(subject SystemData) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230501s.SystemData
	err := copied.AssignProperties_To_SystemData(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SystemData
	err = actual.AssignProperties_From_SystemData(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SystemData_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SystemData via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSystemData, SystemDataGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSystemData runs a test to see if a specific instance of SystemData round trips to JSON and back losslessly
func RunJSONSerializationTestForSystemData(subject SystemData) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SystemData
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SystemData instances for property testing - lazily instantiated by SystemDataGenerator()
var systemDataGenerator gopter.Gen

// SystemDataGenerator returns a generator of SystemData instances for property testing.
func SystemDataGenerator() gopter.Gen {
	if systemDataGenerator != nil {
		return systemDataGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSystemData(generators)
	systemDataGenerator = gen.Struct(reflect.TypeOf(SystemData{}), generators)

	return systemDataGenerator
}

// AddIndependentPropertyGeneratorsForSystemData is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSystemData(gens map[string]gopter.Gen) {
	gens["CreatedAt"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedBy"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemData_CreatedByType_Application,
		SystemData_CreatedByType_Key,
		SystemData_CreatedByType_ManagedIdentity,
		SystemData_CreatedByType_User))
	gens["LastModifiedAt"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedBy"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemData_LastModifiedByType_Application,
		SystemData_LastModifiedByType_Key,
		SystemData_LastModifiedByType_ManagedIdentity,
		SystemData_LastModifiedByType_User))
}

func Test_SystemData_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SystemData_STATUS to SystemData_STATUS via AssignProperties_To_SystemData_STATUS & AssignProperties_From_SystemData_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSystemData_STATUS, SystemData_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSystemData_STATUS tests if a specific instance of SystemData_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSystemData_STATUS(subject SystemData_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230501s.SystemData_STATUS
	err := copied.AssignProperties_To_SystemData_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SystemData_STATUS
	err = actual.AssignProperties_From_SystemData_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SystemData_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SystemData_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSystemData_STATUS, SystemData_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSystemData_STATUS runs a test to see if a specific instance of SystemData_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSystemData_STATUS(subject SystemData_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SystemData_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SystemData_STATUS instances for property testing - lazily instantiated by SystemData_STATUSGenerator()
var systemData_STATUSGenerator gopter.Gen

// SystemData_STATUSGenerator returns a generator of SystemData_STATUS instances for property testing.
func SystemData_STATUSGenerator() gopter.Gen {
	if systemData_STATUSGenerator != nil {
		return systemData_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSystemData_STATUS(generators)
	systemData_STATUSGenerator = gen.Struct(reflect.TypeOf(SystemData_STATUS{}), generators)

	return systemData_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSystemData_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSystemData_STATUS(gens map[string]gopter.Gen) {
	gens["CreatedAt"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedBy"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemData_CreatedByType_STATUS_Application,
		SystemData_CreatedByType_STATUS_Key,
		SystemData_CreatedByType_STATUS_ManagedIdentity,
		SystemData_CreatedByType_STATUS_User))
	gens["LastModifiedAt"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedBy"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemData_LastModifiedByType_STATUS_Application,
		SystemData_LastModifiedByType_STATUS_Key,
		SystemData_LastModifiedByType_STATUS_ManagedIdentity,
		SystemData_LastModifiedByType_STATUS_User))
}

func Test_ErrorAdditionalInfo_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ErrorAdditionalInfo_STATUS to ErrorAdditionalInfo_STATUS via AssignProperties_To_ErrorAdditionalInfo_STATUS & AssignProperties_From_ErrorAdditionalInfo_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForErrorAdditionalInfo_STATUS, ErrorAdditionalInfo_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForErrorAdditionalInfo_STATUS tests if a specific instance of ErrorAdditionalInfo_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForErrorAdditionalInfo_STATUS(subject ErrorAdditionalInfo_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230501s.ErrorAdditionalInfo_STATUS
	err := copied.AssignProperties_To_ErrorAdditionalInfo_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ErrorAdditionalInfo_STATUS
	err = actual.AssignProperties_From_ErrorAdditionalInfo_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ErrorAdditionalInfo_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ErrorAdditionalInfo_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForErrorAdditionalInfo_STATUS, ErrorAdditionalInfo_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForErrorAdditionalInfo_STATUS runs a test to see if a specific instance of ErrorAdditionalInfo_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForErrorAdditionalInfo_STATUS(subject ErrorAdditionalInfo_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ErrorAdditionalInfo_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ErrorAdditionalInfo_STATUS instances for property testing - lazily instantiated by
// ErrorAdditionalInfo_STATUSGenerator()
var errorAdditionalInfo_STATUSGenerator gopter.Gen

// ErrorAdditionalInfo_STATUSGenerator returns a generator of ErrorAdditionalInfo_STATUS instances for property testing.
func ErrorAdditionalInfo_STATUSGenerator() gopter.Gen {
	if errorAdditionalInfo_STATUSGenerator != nil {
		return errorAdditionalInfo_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForErrorAdditionalInfo_STATUS(generators)
	errorAdditionalInfo_STATUSGenerator = gen.Struct(reflect.TypeOf(ErrorAdditionalInfo_STATUS{}), generators)

	return errorAdditionalInfo_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForErrorAdditionalInfo_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForErrorAdditionalInfo_STATUS(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_ErrorDetail_STATUS_Unrolled_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ErrorDetail_STATUS_Unrolled to ErrorDetail_STATUS_Unrolled via AssignProperties_To_ErrorDetail_STATUS_Unrolled & AssignProperties_From_ErrorDetail_STATUS_Unrolled returns original",
		prop.ForAll(RunPropertyAssignmentTestForErrorDetail_STATUS_Unrolled, ErrorDetail_STATUS_UnrolledGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForErrorDetail_STATUS_Unrolled tests if a specific instance of ErrorDetail_STATUS_Unrolled can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForErrorDetail_STATUS_Unrolled(subject ErrorDetail_STATUS_Unrolled) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230501s.ErrorDetail_STATUS_Unrolled
	err := copied.AssignProperties_To_ErrorDetail_STATUS_Unrolled(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ErrorDetail_STATUS_Unrolled
	err = actual.AssignProperties_From_ErrorDetail_STATUS_Unrolled(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ErrorDetail_STATUS_Unrolled_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ErrorDetail_STATUS_Unrolled via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForErrorDetail_STATUS_Unrolled, ErrorDetail_STATUS_UnrolledGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForErrorDetail_STATUS_Unrolled runs a test to see if a specific instance of ErrorDetail_STATUS_Unrolled round trips to JSON and back losslessly
func RunJSONSerializationTestForErrorDetail_STATUS_Unrolled(subject ErrorDetail_STATUS_Unrolled) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ErrorDetail_STATUS_Unrolled
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ErrorDetail_STATUS_Unrolled instances for property testing - lazily instantiated by
// ErrorDetail_STATUS_UnrolledGenerator()
var errorDetail_STATUS_UnrolledGenerator gopter.Gen

// ErrorDetail_STATUS_UnrolledGenerator returns a generator of ErrorDetail_STATUS_Unrolled instances for property testing.
// We first initialize errorDetail_STATUS_UnrolledGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ErrorDetail_STATUS_UnrolledGenerator() gopter.Gen {
	if errorDetail_STATUS_UnrolledGenerator != nil {
		return errorDetail_STATUS_UnrolledGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForErrorDetail_STATUS_Unrolled(generators)
	errorDetail_STATUS_UnrolledGenerator = gen.Struct(reflect.TypeOf(ErrorDetail_STATUS_Unrolled{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForErrorDetail_STATUS_Unrolled(generators)
	AddRelatedPropertyGeneratorsForErrorDetail_STATUS_Unrolled(generators)
	errorDetail_STATUS_UnrolledGenerator = gen.Struct(reflect.TypeOf(ErrorDetail_STATUS_Unrolled{}), generators)

	return errorDetail_STATUS_UnrolledGenerator
}

// AddIndependentPropertyGeneratorsForErrorDetail_STATUS_Unrolled is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForErrorDetail_STATUS_Unrolled(gens map[string]gopter.Gen) {
	gens["Code"] = gen.PtrOf(gen.AlphaString())
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForErrorDetail_STATUS_Unrolled is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForErrorDetail_STATUS_Unrolled(gens map[string]gopter.Gen) {
	gens["AdditionalInfo"] = gen.SliceOf(ErrorAdditionalInfo_STATUSGenerator())
}

func Test_ScopeCluster_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ScopeCluster to ScopeCluster via AssignProperties_To_ScopeCluster & AssignProperties_From_ScopeCluster returns original",
		prop.ForAll(RunPropertyAssignmentTestForScopeCluster, ScopeClusterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForScopeCluster tests if a specific instance of ScopeCluster can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForScopeCluster(subject ScopeCluster) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230501s.ScopeCluster
	err := copied.AssignProperties_To_ScopeCluster(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ScopeCluster
	err = actual.AssignProperties_From_ScopeCluster(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ScopeCluster_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScopeCluster via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScopeCluster, ScopeClusterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScopeCluster runs a test to see if a specific instance of ScopeCluster round trips to JSON and back losslessly
func RunJSONSerializationTestForScopeCluster(subject ScopeCluster) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScopeCluster
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScopeCluster instances for property testing - lazily instantiated by ScopeClusterGenerator()
var scopeClusterGenerator gopter.Gen

// ScopeClusterGenerator returns a generator of ScopeCluster instances for property testing.
func ScopeClusterGenerator() gopter.Gen {
	if scopeClusterGenerator != nil {
		return scopeClusterGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScopeCluster(generators)
	scopeClusterGenerator = gen.Struct(reflect.TypeOf(ScopeCluster{}), generators)

	return scopeClusterGenerator
}

// AddIndependentPropertyGeneratorsForScopeCluster is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScopeCluster(gens map[string]gopter.Gen) {
	gens["ReleaseNamespace"] = gen.PtrOf(gen.AlphaString())
}

func Test_ScopeCluster_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ScopeCluster_STATUS to ScopeCluster_STATUS via AssignProperties_To_ScopeCluster_STATUS & AssignProperties_From_ScopeCluster_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForScopeCluster_STATUS, ScopeCluster_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForScopeCluster_STATUS tests if a specific instance of ScopeCluster_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForScopeCluster_STATUS(subject ScopeCluster_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230501s.ScopeCluster_STATUS
	err := copied.AssignProperties_To_ScopeCluster_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ScopeCluster_STATUS
	err = actual.AssignProperties_From_ScopeCluster_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ScopeCluster_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScopeCluster_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScopeCluster_STATUS, ScopeCluster_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScopeCluster_STATUS runs a test to see if a specific instance of ScopeCluster_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForScopeCluster_STATUS(subject ScopeCluster_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScopeCluster_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScopeCluster_STATUS instances for property testing - lazily instantiated by
// ScopeCluster_STATUSGenerator()
var scopeCluster_STATUSGenerator gopter.Gen

// ScopeCluster_STATUSGenerator returns a generator of ScopeCluster_STATUS instances for property testing.
func ScopeCluster_STATUSGenerator() gopter.Gen {
	if scopeCluster_STATUSGenerator != nil {
		return scopeCluster_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScopeCluster_STATUS(generators)
	scopeCluster_STATUSGenerator = gen.Struct(reflect.TypeOf(ScopeCluster_STATUS{}), generators)

	return scopeCluster_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForScopeCluster_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScopeCluster_STATUS(gens map[string]gopter.Gen) {
	gens["ReleaseNamespace"] = gen.PtrOf(gen.AlphaString())
}

func Test_ScopeNamespace_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ScopeNamespace to ScopeNamespace via AssignProperties_To_ScopeNamespace & AssignProperties_From_ScopeNamespace returns original",
		prop.ForAll(RunPropertyAssignmentTestForScopeNamespace, ScopeNamespaceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForScopeNamespace tests if a specific instance of ScopeNamespace can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForScopeNamespace(subject ScopeNamespace) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230501s.ScopeNamespace
	err := copied.AssignProperties_To_ScopeNamespace(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ScopeNamespace
	err = actual.AssignProperties_From_ScopeNamespace(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ScopeNamespace_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScopeNamespace via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScopeNamespace, ScopeNamespaceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScopeNamespace runs a test to see if a specific instance of ScopeNamespace round trips to JSON and back losslessly
func RunJSONSerializationTestForScopeNamespace(subject ScopeNamespace) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScopeNamespace
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScopeNamespace instances for property testing - lazily instantiated by ScopeNamespaceGenerator()
var scopeNamespaceGenerator gopter.Gen

// ScopeNamespaceGenerator returns a generator of ScopeNamespace instances for property testing.
func ScopeNamespaceGenerator() gopter.Gen {
	if scopeNamespaceGenerator != nil {
		return scopeNamespaceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScopeNamespace(generators)
	scopeNamespaceGenerator = gen.Struct(reflect.TypeOf(ScopeNamespace{}), generators)

	return scopeNamespaceGenerator
}

// AddIndependentPropertyGeneratorsForScopeNamespace is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScopeNamespace(gens map[string]gopter.Gen) {
	gens["TargetNamespace"] = gen.PtrOf(gen.AlphaString())
}

func Test_ScopeNamespace_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ScopeNamespace_STATUS to ScopeNamespace_STATUS via AssignProperties_To_ScopeNamespace_STATUS & AssignProperties_From_ScopeNamespace_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForScopeNamespace_STATUS, ScopeNamespace_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForScopeNamespace_STATUS tests if a specific instance of ScopeNamespace_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForScopeNamespace_STATUS(subject ScopeNamespace_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230501s.ScopeNamespace_STATUS
	err := copied.AssignProperties_To_ScopeNamespace_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ScopeNamespace_STATUS
	err = actual.AssignProperties_From_ScopeNamespace_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ScopeNamespace_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScopeNamespace_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScopeNamespace_STATUS, ScopeNamespace_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScopeNamespace_STATUS runs a test to see if a specific instance of ScopeNamespace_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForScopeNamespace_STATUS(subject ScopeNamespace_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScopeNamespace_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScopeNamespace_STATUS instances for property testing - lazily instantiated by
// ScopeNamespace_STATUSGenerator()
var scopeNamespace_STATUSGenerator gopter.Gen

// ScopeNamespace_STATUSGenerator returns a generator of ScopeNamespace_STATUS instances for property testing.
func ScopeNamespace_STATUSGenerator() gopter.Gen {
	if scopeNamespace_STATUSGenerator != nil {
		return scopeNamespace_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForScopeNamespace_STATUS(generators)
	scopeNamespace_STATUSGenerator = gen.Struct(reflect.TypeOf(ScopeNamespace_STATUS{}), generators)

	return scopeNamespace_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForScopeNamespace_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForScopeNamespace_STATUS(gens map[string]gopter.Gen) {
	gens["TargetNamespace"] = gen.PtrOf(gen.AlphaString())
}
