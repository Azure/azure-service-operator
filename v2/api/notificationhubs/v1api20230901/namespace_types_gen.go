// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20230901

import (
	"context"
	"fmt"
	arm "github.com/Azure/azure-service-operator/v2/api/notificationhubs/v1api20230901/arm"
	storage "github.com/Azure/azure-service-operator/v2/api/notificationhubs/v1api20230901/storage"
	"github.com/Azure/azure-service-operator/v2/internal/genericarmclient"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/go-logr/logr"
	"github.com/rotisserie/eris"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
)

// +kubebuilder:object:root=true
// +kubebuilder:resource:categories={azure,notificationhubs}
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /notificationhubs/resource-manager/Microsoft.NotificationHubs/stable/2023-09-01/notificationhubs.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NotificationHubs/namespaces/{namespaceName}
type Namespace struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              Namespace_Spec   `json:"spec,omitempty"`
	Status            Namespace_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &Namespace{}

// GetConditions returns the conditions of the resource
func (namespace *Namespace) GetConditions() conditions.Conditions {
	return namespace.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (namespace *Namespace) SetConditions(conditions conditions.Conditions) {
	namespace.Status.Conditions = conditions
}

var _ conversion.Convertible = &Namespace{}

// ConvertFrom populates our Namespace from the provided hub Namespace
func (namespace *Namespace) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*storage.Namespace)
	if !ok {
		return fmt.Errorf("expected notificationhubs/v1api20230901/storage/Namespace but received %T instead", hub)
	}

	return namespace.AssignProperties_From_Namespace(source)
}

// ConvertTo populates the provided hub Namespace from our Namespace
func (namespace *Namespace) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*storage.Namespace)
	if !ok {
		return fmt.Errorf("expected notificationhubs/v1api20230901/storage/Namespace but received %T instead", hub)
	}

	return namespace.AssignProperties_To_Namespace(destination)
}

var _ configmaps.Exporter = &Namespace{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (namespace *Namespace) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if namespace.Spec.OperatorSpec == nil {
		return nil
	}
	return namespace.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &Namespace{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (namespace *Namespace) SecretDestinationExpressions() []*core.DestinationExpression {
	if namespace.Spec.OperatorSpec == nil {
		return nil
	}
	return namespace.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.ImportableResource = &Namespace{}

// InitializeSpec initializes the spec for this resource from the given status
func (namespace *Namespace) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*Namespace_STATUS); ok {
		return namespace.Spec.Initialize_From_Namespace_STATUS(s)
	}

	return fmt.Errorf("expected Status of type Namespace_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesConfigExporter = &Namespace{}

// ExportKubernetesConfigMaps defines a resource which can create ConfigMaps in Kubernetes.
func (namespace *Namespace) ExportKubernetesConfigMaps(_ context.Context, _ genruntime.MetaObject, _ *genericarmclient.GenericClient, _ logr.Logger) ([]client.Object, error) {
	collector := configmaps.NewCollector(namespace.Namespace)
	if namespace.Spec.OperatorSpec != nil && namespace.Spec.OperatorSpec.ConfigMaps != nil {
		if namespace.Status.Properties != nil {
			if namespace.Status.Properties.ServiceBusEndpoint != nil {
				collector.AddValue(namespace.Spec.OperatorSpec.ConfigMaps.ServiceBusEndpoint, *namespace.Status.Properties.ServiceBusEndpoint)
			}
		}
	}
	result, err := collector.Values()
	if err != nil {
		return nil, err
	}
	return configmaps.SliceToClientObjectSlice(result), nil
}

var _ genruntime.KubernetesResource = &Namespace{}

// AzureName returns the Azure name of the resource
func (namespace *Namespace) AzureName() string {
	return namespace.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2023-09-01"
func (namespace Namespace) GetAPIVersion() string {
	return "2023-09-01"
}

// GetResourceScope returns the scope of the resource
func (namespace *Namespace) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (namespace *Namespace) GetSpec() genruntime.ConvertibleSpec {
	return &namespace.Spec
}

// GetStatus returns the status of this resource
func (namespace *Namespace) GetStatus() genruntime.ConvertibleStatus {
	return &namespace.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (namespace *Namespace) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.NotificationHubs/namespaces"
func (namespace *Namespace) GetType() string {
	return "Microsoft.NotificationHubs/namespaces"
}

// NewEmptyStatus returns a new empty (blank) status
func (namespace *Namespace) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &Namespace_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (namespace *Namespace) Owner() *genruntime.ResourceReference {
	if namespace.Spec.Owner == nil {
		return nil
	}

	group, kind := genruntime.LookupOwnerGroupKind(namespace.Spec)
	return namespace.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (namespace *Namespace) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*Namespace_STATUS); ok {
		namespace.Status = *st
		return nil
	}

	// Convert status to required version
	var st Namespace_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return eris.Wrap(err, "failed to convert status")
	}

	namespace.Status = st
	return nil
}

// AssignProperties_From_Namespace populates our Namespace from the provided source Namespace
func (namespace *Namespace) AssignProperties_From_Namespace(source *storage.Namespace) error {

	// ObjectMeta
	namespace.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec Namespace_Spec
	err := spec.AssignProperties_From_Namespace_Spec(&source.Spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_Namespace_Spec() to populate field Spec")
	}
	namespace.Spec = spec

	// Status
	var status Namespace_STATUS
	err = status.AssignProperties_From_Namespace_STATUS(&source.Status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_Namespace_STATUS() to populate field Status")
	}
	namespace.Status = status

	// No error
	return nil
}

// AssignProperties_To_Namespace populates the provided destination Namespace from our Namespace
func (namespace *Namespace) AssignProperties_To_Namespace(destination *storage.Namespace) error {

	// ObjectMeta
	destination.ObjectMeta = *namespace.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.Namespace_Spec
	err := namespace.Spec.AssignProperties_To_Namespace_Spec(&spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_Namespace_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.Namespace_STATUS
	err = namespace.Status.AssignProperties_To_Namespace_STATUS(&status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_Namespace_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (namespace *Namespace) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: namespace.Spec.OriginalVersion(),
		Kind:    "Namespace",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /notificationhubs/resource-manager/Microsoft.NotificationHubs/stable/2023-09-01/notificationhubs.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NotificationHubs/namespaces/{namespaceName}
type NamespaceList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Namespace `json:"items"`
}

// +kubebuilder:validation:Enum={"2023-09-01"}
type APIVersion string

const APIVersion_Value = APIVersion("2023-09-01")

type Namespace_Spec struct {
	// +kubebuilder:validation:MaxLength=50
	// +kubebuilder:validation:MinLength=1
	// +kubebuilder:validation:Pattern="^[a-zA-Z][a-zA-Z0-9-]*$"
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// +kubebuilder:validation:Required
	// Location: The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *NamespaceOperatorSpec `json:"operatorSpec,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`

	// Properties: Represents namespace properties.
	Properties *NamespaceProperties `json:"properties,omitempty"`

	// +kubebuilder:validation:Required
	// Sku: The Sku description for a namespace
	Sku *Sku `json:"sku,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`
}

var _ genruntime.ARMTransformer = &Namespace_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (namespace *Namespace_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if namespace == nil {
		return nil, nil
	}
	result := &arm.Namespace_Spec{}

	// Set property "Location":
	if namespace.Location != nil {
		location := *namespace.Location
		result.Location = &location
	}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if namespace.Properties != nil {
		properties_ARM, err := (*namespace.Properties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		properties := *properties_ARM.(*arm.NamespaceProperties)
		result.Properties = &properties
	}

	// Set property "Sku":
	if namespace.Sku != nil {
		sku_ARM, err := (*namespace.Sku).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sku := *sku_ARM.(*arm.Sku)
		result.Sku = &sku
	}

	// Set property "Tags":
	if namespace.Tags != nil {
		result.Tags = make(map[string]string, len(namespace.Tags))
		for key, value := range namespace.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (namespace *Namespace_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Namespace_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (namespace *Namespace_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Namespace_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Namespace_Spec, got %T", armInput)
	}

	// Set property "AzureName":
	namespace.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		namespace.Location = &location
	}

	// no assignment for property "OperatorSpec"

	// Set property "Owner":
	namespace.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 NamespaceProperties
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		namespace.Properties = &properties
	}

	// Set property "Sku":
	if typedInput.Sku != nil {
		var sku1 Sku
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		namespace.Sku = &sku
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		namespace.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			namespace.Tags[key] = value
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &Namespace_Spec{}

// ConvertSpecFrom populates our Namespace_Spec from the provided source
func (namespace *Namespace_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.Namespace_Spec)
	if ok {
		// Populate our instance from source
		return namespace.AssignProperties_From_Namespace_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.Namespace_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = namespace.AssignProperties_From_Namespace_Spec(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our Namespace_Spec
func (namespace *Namespace_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.Namespace_Spec)
	if ok {
		// Populate destination from our instance
		return namespace.AssignProperties_To_Namespace_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.Namespace_Spec{}
	err := namespace.AssignProperties_To_Namespace_Spec(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_Namespace_Spec populates our Namespace_Spec from the provided source Namespace_Spec
func (namespace *Namespace_Spec) AssignProperties_From_Namespace_Spec(source *storage.Namespace_Spec) error {

	// AzureName
	namespace.AzureName = source.AzureName

	// Location
	namespace.Location = genruntime.ClonePointerToString(source.Location)

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec NamespaceOperatorSpec
		err := operatorSpec.AssignProperties_From_NamespaceOperatorSpec(source.OperatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_NamespaceOperatorSpec() to populate field OperatorSpec")
		}
		namespace.OperatorSpec = &operatorSpec
	} else {
		namespace.OperatorSpec = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		namespace.Owner = &owner
	} else {
		namespace.Owner = nil
	}

	// Properties
	if source.Properties != nil {
		var property NamespaceProperties
		err := property.AssignProperties_From_NamespaceProperties(source.Properties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_NamespaceProperties() to populate field Properties")
		}
		namespace.Properties = &property
	} else {
		namespace.Properties = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku
		err := sku.AssignProperties_From_Sku(source.Sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Sku() to populate field Sku")
		}
		namespace.Sku = &sku
	} else {
		namespace.Sku = nil
	}

	// Tags
	namespace.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// AssignProperties_To_Namespace_Spec populates the provided destination Namespace_Spec from our Namespace_Spec
func (namespace *Namespace_Spec) AssignProperties_To_Namespace_Spec(destination *storage.Namespace_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = namespace.AzureName

	// Location
	destination.Location = genruntime.ClonePointerToString(namespace.Location)

	// OperatorSpec
	if namespace.OperatorSpec != nil {
		var operatorSpec storage.NamespaceOperatorSpec
		err := namespace.OperatorSpec.AssignProperties_To_NamespaceOperatorSpec(&operatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_NamespaceOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = namespace.OriginalVersion()

	// Owner
	if namespace.Owner != nil {
		owner := namespace.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// Properties
	if namespace.Properties != nil {
		var property storage.NamespaceProperties
		err := namespace.Properties.AssignProperties_To_NamespaceProperties(&property)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_NamespaceProperties() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// Sku
	if namespace.Sku != nil {
		var sku storage.Sku
		err := namespace.Sku.AssignProperties_To_Sku(&sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Sku() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(namespace.Tags)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Namespace_STATUS populates our Namespace_Spec from the provided source Namespace_STATUS
func (namespace *Namespace_Spec) Initialize_From_Namespace_STATUS(source *Namespace_STATUS) error {

	// Location
	namespace.Location = genruntime.ClonePointerToString(source.Location)

	// Properties
	if source.Properties != nil {
		var property NamespaceProperties
		err := property.Initialize_From_NamespaceProperties_STATUS(source.Properties)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_NamespaceProperties_STATUS() to populate field Properties")
		}
		namespace.Properties = &property
	} else {
		namespace.Properties = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku
		err := sku.Initialize_From_Sku_STATUS(source.Sku)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_Sku_STATUS() to populate field Sku")
		}
		namespace.Sku = &sku
	} else {
		namespace.Sku = nil
	}

	// Tags
	namespace.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (namespace *Namespace_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (namespace *Namespace_Spec) SetAzureName(azureName string) { namespace.AzureName = azureName }

type Namespace_STATUS struct {
	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// Id: Fully qualified resource ID for the resource. E.g.
	// "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}"
	Id *string `json:"id,omitempty"`

	// Location: The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// Name: The name of the resource
	Name *string `json:"name,omitempty"`

	// Properties: Represents namespace properties.
	Properties *NamespaceProperties_STATUS `json:"properties,omitempty"`

	// Sku: The Sku description for a namespace
	Sku *Sku_STATUS `json:"sku,omitempty"`

	// SystemData: Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData_STATUS `json:"systemData,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// Type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &Namespace_STATUS{}

// ConvertStatusFrom populates our Namespace_STATUS from the provided source
func (namespace *Namespace_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.Namespace_STATUS)
	if ok {
		// Populate our instance from source
		return namespace.AssignProperties_From_Namespace_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.Namespace_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = namespace.AssignProperties_From_Namespace_STATUS(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our Namespace_STATUS
func (namespace *Namespace_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.Namespace_STATUS)
	if ok {
		// Populate destination from our instance
		return namespace.AssignProperties_To_Namespace_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.Namespace_STATUS{}
	err := namespace.AssignProperties_To_Namespace_STATUS(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &Namespace_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (namespace *Namespace_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Namespace_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (namespace *Namespace_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Namespace_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Namespace_STATUS, got %T", armInput)
	}

	// no assignment for property "Conditions"

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		namespace.Id = &id
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		namespace.Location = &location
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		namespace.Name = &name
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 NamespaceProperties_STATUS
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		namespace.Properties = &properties
	}

	// Set property "Sku":
	if typedInput.Sku != nil {
		var sku1 Sku_STATUS
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		namespace.Sku = &sku
	}

	// Set property "SystemData":
	if typedInput.SystemData != nil {
		var systemData1 SystemData_STATUS
		err := systemData1.PopulateFromARM(owner, *typedInput.SystemData)
		if err != nil {
			return err
		}
		systemData := systemData1
		namespace.SystemData = &systemData
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		namespace.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			namespace.Tags[key] = value
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		namespace.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_Namespace_STATUS populates our Namespace_STATUS from the provided source Namespace_STATUS
func (namespace *Namespace_STATUS) AssignProperties_From_Namespace_STATUS(source *storage.Namespace_STATUS) error {

	// Conditions
	namespace.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// Id
	namespace.Id = genruntime.ClonePointerToString(source.Id)

	// Location
	namespace.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	namespace.Name = genruntime.ClonePointerToString(source.Name)

	// Properties
	if source.Properties != nil {
		var property NamespaceProperties_STATUS
		err := property.AssignProperties_From_NamespaceProperties_STATUS(source.Properties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_NamespaceProperties_STATUS() to populate field Properties")
		}
		namespace.Properties = &property
	} else {
		namespace.Properties = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku_STATUS
		err := sku.AssignProperties_From_Sku_STATUS(source.Sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Sku_STATUS() to populate field Sku")
		}
		namespace.Sku = &sku
	} else {
		namespace.Sku = nil
	}

	// SystemData
	if source.SystemData != nil {
		var systemDatum SystemData_STATUS
		err := systemDatum.AssignProperties_From_SystemData_STATUS(source.SystemData)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SystemData_STATUS() to populate field SystemData")
		}
		namespace.SystemData = &systemDatum
	} else {
		namespace.SystemData = nil
	}

	// Tags
	namespace.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	namespace.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_Namespace_STATUS populates the provided destination Namespace_STATUS from our Namespace_STATUS
func (namespace *Namespace_STATUS) AssignProperties_To_Namespace_STATUS(destination *storage.Namespace_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(namespace.Conditions)

	// Id
	destination.Id = genruntime.ClonePointerToString(namespace.Id)

	// Location
	destination.Location = genruntime.ClonePointerToString(namespace.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(namespace.Name)

	// Properties
	if namespace.Properties != nil {
		var property storage.NamespaceProperties_STATUS
		err := namespace.Properties.AssignProperties_To_NamespaceProperties_STATUS(&property)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_NamespaceProperties_STATUS() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// Sku
	if namespace.Sku != nil {
		var sku storage.Sku_STATUS
		err := namespace.Sku.AssignProperties_To_Sku_STATUS(&sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Sku_STATUS() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// SystemData
	if namespace.SystemData != nil {
		var systemDatum storage.SystemData_STATUS
		err := namespace.SystemData.AssignProperties_To_SystemData_STATUS(&systemDatum)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SystemData_STATUS() to populate field SystemData")
		}
		destination.SystemData = &systemDatum
	} else {
		destination.SystemData = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(namespace.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(namespace.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type NamespaceOperatorSpec struct {
	// ConfigMapExpressions: configures where to place operator written dynamic ConfigMaps (created with CEL expressions).
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`

	// ConfigMaps: configures where to place operator written ConfigMaps.
	ConfigMaps *NamespaceOperatorConfigMaps `json:"configMaps,omitempty"`

	// SecretExpressions: configures where to place operator written dynamic secrets (created with CEL expressions).
	SecretExpressions []*core.DestinationExpression `json:"secretExpressions,omitempty"`

	// Secrets: configures where to place Azure generated secrets.
	Secrets *NamespaceOperatorSecrets `json:"secrets,omitempty"`
}

// AssignProperties_From_NamespaceOperatorSpec populates our NamespaceOperatorSpec from the provided source NamespaceOperatorSpec
func (operator *NamespaceOperatorSpec) AssignProperties_From_NamespaceOperatorSpec(source *storage.NamespaceOperatorSpec) error {

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// ConfigMaps
	if source.ConfigMaps != nil {
		var configMap NamespaceOperatorConfigMaps
		err := configMap.AssignProperties_From_NamespaceOperatorConfigMaps(source.ConfigMaps)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_NamespaceOperatorConfigMaps() to populate field ConfigMaps")
		}
		operator.ConfigMaps = &configMap
	} else {
		operator.ConfigMaps = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// Secrets
	if source.Secrets != nil {
		var secret NamespaceOperatorSecrets
		err := secret.AssignProperties_From_NamespaceOperatorSecrets(source.Secrets)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_NamespaceOperatorSecrets() to populate field Secrets")
		}
		operator.Secrets = &secret
	} else {
		operator.Secrets = nil
	}

	// No error
	return nil
}

// AssignProperties_To_NamespaceOperatorSpec populates the provided destination NamespaceOperatorSpec from our NamespaceOperatorSpec
func (operator *NamespaceOperatorSpec) AssignProperties_To_NamespaceOperatorSpec(destination *storage.NamespaceOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// ConfigMaps
	if operator.ConfigMaps != nil {
		var configMap storage.NamespaceOperatorConfigMaps
		err := operator.ConfigMaps.AssignProperties_To_NamespaceOperatorConfigMaps(&configMap)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_NamespaceOperatorConfigMaps() to populate field ConfigMaps")
		}
		destination.ConfigMaps = &configMap
	} else {
		destination.ConfigMaps = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Secrets
	if operator.Secrets != nil {
		var secret storage.NamespaceOperatorSecrets
		err := operator.Secrets.AssignProperties_To_NamespaceOperatorSecrets(&secret)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_NamespaceOperatorSecrets() to populate field Secrets")
		}
		destination.Secrets = &secret
	} else {
		destination.Secrets = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Represents namespace properties.
type NamespaceProperties struct {
	// DataCenter: Deprecated.
	DataCenter *string `json:"dataCenter,omitempty"`

	// NamespaceType: Defines values for NamespaceType.
	NamespaceType *NamespaceType `json:"namespaceType,omitempty"`

	// NetworkAcls: A collection of network authorization rules.
	NetworkAcls *NetworkAcls `json:"networkAcls,omitempty"`

	// PnsCredentials: Collection of Notification Hub or Notification Hub Namespace PNS credentials.
	PnsCredentials *PnsCredentials `json:"pnsCredentials,omitempty"`

	// PublicNetworkAccess: Type of public network access.
	PublicNetworkAccess *PublicNetworkAccess `json:"publicNetworkAccess,omitempty"`

	// ReplicationRegion: Allowed replication region
	ReplicationRegion *ReplicationRegion `json:"replicationRegion,omitempty"`

	// ScaleUnit: Gets or sets scaleUnit where the namespace gets created
	ScaleUnit *string `json:"scaleUnit,omitempty"`

	// ZoneRedundancy: Namespace SKU name.
	ZoneRedundancy *ZoneRedundancyPreference `json:"zoneRedundancy,omitempty"`
}

var _ genruntime.ARMTransformer = &NamespaceProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *NamespaceProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.NamespaceProperties{}

	// Set property "DataCenter":
	if properties.DataCenter != nil {
		dataCenter := *properties.DataCenter
		result.DataCenter = &dataCenter
	}

	// Set property "NamespaceType":
	if properties.NamespaceType != nil {
		var temp string
		temp = string(*properties.NamespaceType)
		namespaceType := arm.NamespaceType(temp)
		result.NamespaceType = &namespaceType
	}

	// Set property "NetworkAcls":
	if properties.NetworkAcls != nil {
		networkAcls_ARM, err := (*properties.NetworkAcls).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		networkAcls := *networkAcls_ARM.(*arm.NetworkAcls)
		result.NetworkAcls = &networkAcls
	}

	// Set property "PnsCredentials":
	if properties.PnsCredentials != nil {
		pnsCredentials_ARM, err := (*properties.PnsCredentials).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		pnsCredentials := *pnsCredentials_ARM.(*arm.PnsCredentials)
		result.PnsCredentials = &pnsCredentials
	}

	// Set property "PublicNetworkAccess":
	if properties.PublicNetworkAccess != nil {
		var temp string
		temp = string(*properties.PublicNetworkAccess)
		publicNetworkAccess := arm.PublicNetworkAccess(temp)
		result.PublicNetworkAccess = &publicNetworkAccess
	}

	// Set property "ReplicationRegion":
	if properties.ReplicationRegion != nil {
		var temp string
		temp = string(*properties.ReplicationRegion)
		replicationRegion := arm.ReplicationRegion(temp)
		result.ReplicationRegion = &replicationRegion
	}

	// Set property "ScaleUnit":
	if properties.ScaleUnit != nil {
		scaleUnit := *properties.ScaleUnit
		result.ScaleUnit = &scaleUnit
	}

	// Set property "ZoneRedundancy":
	if properties.ZoneRedundancy != nil {
		var temp string
		temp = string(*properties.ZoneRedundancy)
		zoneRedundancy := arm.ZoneRedundancyPreference(temp)
		result.ZoneRedundancy = &zoneRedundancy
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *NamespaceProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.NamespaceProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *NamespaceProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.NamespaceProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.NamespaceProperties, got %T", armInput)
	}

	// Set property "DataCenter":
	if typedInput.DataCenter != nil {
		dataCenter := *typedInput.DataCenter
		properties.DataCenter = &dataCenter
	}

	// Set property "NamespaceType":
	if typedInput.NamespaceType != nil {
		var temp string
		temp = string(*typedInput.NamespaceType)
		namespaceType := NamespaceType(temp)
		properties.NamespaceType = &namespaceType
	}

	// Set property "NetworkAcls":
	if typedInput.NetworkAcls != nil {
		var networkAcls1 NetworkAcls
		err := networkAcls1.PopulateFromARM(owner, *typedInput.NetworkAcls)
		if err != nil {
			return err
		}
		networkAcls := networkAcls1
		properties.NetworkAcls = &networkAcls
	}

	// Set property "PnsCredentials":
	if typedInput.PnsCredentials != nil {
		var pnsCredentials1 PnsCredentials
		err := pnsCredentials1.PopulateFromARM(owner, *typedInput.PnsCredentials)
		if err != nil {
			return err
		}
		pnsCredentials := pnsCredentials1
		properties.PnsCredentials = &pnsCredentials
	}

	// Set property "PublicNetworkAccess":
	if typedInput.PublicNetworkAccess != nil {
		var temp string
		temp = string(*typedInput.PublicNetworkAccess)
		publicNetworkAccess := PublicNetworkAccess(temp)
		properties.PublicNetworkAccess = &publicNetworkAccess
	}

	// Set property "ReplicationRegion":
	if typedInput.ReplicationRegion != nil {
		var temp string
		temp = string(*typedInput.ReplicationRegion)
		replicationRegion := ReplicationRegion(temp)
		properties.ReplicationRegion = &replicationRegion
	}

	// Set property "ScaleUnit":
	if typedInput.ScaleUnit != nil {
		scaleUnit := *typedInput.ScaleUnit
		properties.ScaleUnit = &scaleUnit
	}

	// Set property "ZoneRedundancy":
	if typedInput.ZoneRedundancy != nil {
		var temp string
		temp = string(*typedInput.ZoneRedundancy)
		zoneRedundancy := ZoneRedundancyPreference(temp)
		properties.ZoneRedundancy = &zoneRedundancy
	}

	// No error
	return nil
}

// AssignProperties_From_NamespaceProperties populates our NamespaceProperties from the provided source NamespaceProperties
func (properties *NamespaceProperties) AssignProperties_From_NamespaceProperties(source *storage.NamespaceProperties) error {

	// DataCenter
	properties.DataCenter = genruntime.ClonePointerToString(source.DataCenter)

	// NamespaceType
	if source.NamespaceType != nil {
		namespaceType := *source.NamespaceType
		namespaceTypeTemp := genruntime.ToEnum(namespaceType, namespaceType_Values)
		properties.NamespaceType = &namespaceTypeTemp
	} else {
		properties.NamespaceType = nil
	}

	// NetworkAcls
	if source.NetworkAcls != nil {
		var networkAcl NetworkAcls
		err := networkAcl.AssignProperties_From_NetworkAcls(source.NetworkAcls)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_NetworkAcls() to populate field NetworkAcls")
		}
		properties.NetworkAcls = &networkAcl
	} else {
		properties.NetworkAcls = nil
	}

	// PnsCredentials
	if source.PnsCredentials != nil {
		var pnsCredential PnsCredentials
		err := pnsCredential.AssignProperties_From_PnsCredentials(source.PnsCredentials)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_PnsCredentials() to populate field PnsCredentials")
		}
		properties.PnsCredentials = &pnsCredential
	} else {
		properties.PnsCredentials = nil
	}

	// PublicNetworkAccess
	if source.PublicNetworkAccess != nil {
		publicNetworkAccess := *source.PublicNetworkAccess
		publicNetworkAccessTemp := genruntime.ToEnum(publicNetworkAccess, publicNetworkAccess_Values)
		properties.PublicNetworkAccess = &publicNetworkAccessTemp
	} else {
		properties.PublicNetworkAccess = nil
	}

	// ReplicationRegion
	if source.ReplicationRegion != nil {
		replicationRegion := *source.ReplicationRegion
		replicationRegionTemp := genruntime.ToEnum(replicationRegion, replicationRegion_Values)
		properties.ReplicationRegion = &replicationRegionTemp
	} else {
		properties.ReplicationRegion = nil
	}

	// ScaleUnit
	properties.ScaleUnit = genruntime.ClonePointerToString(source.ScaleUnit)

	// ZoneRedundancy
	if source.ZoneRedundancy != nil {
		zoneRedundancy := *source.ZoneRedundancy
		zoneRedundancyTemp := genruntime.ToEnum(zoneRedundancy, zoneRedundancyPreference_Values)
		properties.ZoneRedundancy = &zoneRedundancyTemp
	} else {
		properties.ZoneRedundancy = nil
	}

	// No error
	return nil
}

// AssignProperties_To_NamespaceProperties populates the provided destination NamespaceProperties from our NamespaceProperties
func (properties *NamespaceProperties) AssignProperties_To_NamespaceProperties(destination *storage.NamespaceProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DataCenter
	destination.DataCenter = genruntime.ClonePointerToString(properties.DataCenter)

	// NamespaceType
	if properties.NamespaceType != nil {
		namespaceType := string(*properties.NamespaceType)
		destination.NamespaceType = &namespaceType
	} else {
		destination.NamespaceType = nil
	}

	// NetworkAcls
	if properties.NetworkAcls != nil {
		var networkAcl storage.NetworkAcls
		err := properties.NetworkAcls.AssignProperties_To_NetworkAcls(&networkAcl)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_NetworkAcls() to populate field NetworkAcls")
		}
		destination.NetworkAcls = &networkAcl
	} else {
		destination.NetworkAcls = nil
	}

	// PnsCredentials
	if properties.PnsCredentials != nil {
		var pnsCredential storage.PnsCredentials
		err := properties.PnsCredentials.AssignProperties_To_PnsCredentials(&pnsCredential)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_PnsCredentials() to populate field PnsCredentials")
		}
		destination.PnsCredentials = &pnsCredential
	} else {
		destination.PnsCredentials = nil
	}

	// PublicNetworkAccess
	if properties.PublicNetworkAccess != nil {
		publicNetworkAccess := string(*properties.PublicNetworkAccess)
		destination.PublicNetworkAccess = &publicNetworkAccess
	} else {
		destination.PublicNetworkAccess = nil
	}

	// ReplicationRegion
	if properties.ReplicationRegion != nil {
		replicationRegion := string(*properties.ReplicationRegion)
		destination.ReplicationRegion = &replicationRegion
	} else {
		destination.ReplicationRegion = nil
	}

	// ScaleUnit
	destination.ScaleUnit = genruntime.ClonePointerToString(properties.ScaleUnit)

	// ZoneRedundancy
	if properties.ZoneRedundancy != nil {
		zoneRedundancy := string(*properties.ZoneRedundancy)
		destination.ZoneRedundancy = &zoneRedundancy
	} else {
		destination.ZoneRedundancy = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_NamespaceProperties_STATUS populates our NamespaceProperties from the provided source NamespaceProperties_STATUS
func (properties *NamespaceProperties) Initialize_From_NamespaceProperties_STATUS(source *NamespaceProperties_STATUS) error {

	// DataCenter
	properties.DataCenter = genruntime.ClonePointerToString(source.DataCenter)

	// NamespaceType
	if source.NamespaceType != nil {
		namespaceType := genruntime.ToEnum(string(*source.NamespaceType), namespaceType_Values)
		properties.NamespaceType = &namespaceType
	} else {
		properties.NamespaceType = nil
	}

	// NetworkAcls
	if source.NetworkAcls != nil {
		var networkAcl NetworkAcls
		err := networkAcl.Initialize_From_NetworkAcls_STATUS(source.NetworkAcls)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_NetworkAcls_STATUS() to populate field NetworkAcls")
		}
		properties.NetworkAcls = &networkAcl
	} else {
		properties.NetworkAcls = nil
	}

	// PnsCredentials
	if source.PnsCredentials != nil {
		var pnsCredential PnsCredentials
		err := pnsCredential.Initialize_From_PnsCredentials_STATUS(source.PnsCredentials)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_PnsCredentials_STATUS() to populate field PnsCredentials")
		}
		properties.PnsCredentials = &pnsCredential
	} else {
		properties.PnsCredentials = nil
	}

	// PublicNetworkAccess
	if source.PublicNetworkAccess != nil {
		publicNetworkAccess := genruntime.ToEnum(string(*source.PublicNetworkAccess), publicNetworkAccess_Values)
		properties.PublicNetworkAccess = &publicNetworkAccess
	} else {
		properties.PublicNetworkAccess = nil
	}

	// ReplicationRegion
	if source.ReplicationRegion != nil {
		replicationRegion := genruntime.ToEnum(string(*source.ReplicationRegion), replicationRegion_Values)
		properties.ReplicationRegion = &replicationRegion
	} else {
		properties.ReplicationRegion = nil
	}

	// ScaleUnit
	properties.ScaleUnit = genruntime.ClonePointerToString(source.ScaleUnit)

	// ZoneRedundancy
	if source.ZoneRedundancy != nil {
		zoneRedundancy := genruntime.ToEnum(string(*source.ZoneRedundancy), zoneRedundancyPreference_Values)
		properties.ZoneRedundancy = &zoneRedundancy
	} else {
		properties.ZoneRedundancy = nil
	}

	// No error
	return nil
}

// Represents namespace properties.
type NamespaceProperties_STATUS struct {
	// CreatedAt: Time when the namespace was created.
	CreatedAt *string `json:"createdAt,omitempty"`

	// Critical: Gets or sets whether or not the namespace is set as Critical.
	Critical *bool `json:"critical,omitempty"`

	// DataCenter: Deprecated.
	DataCenter *string `json:"dataCenter,omitempty"`

	// Enabled: Gets or sets whether or not the namespace is currently enabled.
	Enabled *bool `json:"enabled,omitempty"`

	// MetricId: Azure Insights Metrics id.
	MetricId *string `json:"metricId,omitempty"`

	// Name: Name of the Notification Hubs namespace. This is immutable property, set automatically
	// by the service when the namespace is created.
	Name *string `json:"name,omitempty"`

	// NamespaceType: Defines values for NamespaceType.
	NamespaceType *NamespaceType_STATUS `json:"namespaceType,omitempty"`

	// NetworkAcls: A collection of network authorization rules.
	NetworkAcls *NetworkAcls_STATUS `json:"networkAcls,omitempty"`

	// PnsCredentials: Collection of Notification Hub or Notification Hub Namespace PNS credentials.
	PnsCredentials *PnsCredentials_STATUS `json:"pnsCredentials,omitempty"`

	// PrivateEndpointConnections: Private Endpoint Connections for namespace
	PrivateEndpointConnections []PrivateEndpointConnectionResource_STATUS `json:"privateEndpointConnections,omitempty"`

	// ProvisioningState: Defines values for OperationProvisioningState.
	ProvisioningState *OperationProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// PublicNetworkAccess: Type of public network access.
	PublicNetworkAccess *PublicNetworkAccess_STATUS `json:"publicNetworkAccess,omitempty"`

	// Region: Region. The value is always set to the same value as Namespace.Location, so we are deprecating
	// this property.
	Region *string `json:"region,omitempty"`

	// ReplicationRegion: Allowed replication region
	ReplicationRegion *ReplicationRegion_STATUS `json:"replicationRegion,omitempty"`

	// ScaleUnit: Gets or sets scaleUnit where the namespace gets created
	ScaleUnit *string `json:"scaleUnit,omitempty"`

	// ServiceBusEndpoint: Gets or sets endpoint you can use to perform NotificationHub
	// operations.
	ServiceBusEndpoint *string `json:"serviceBusEndpoint,omitempty"`

	// Status: Namespace status.
	Status *NamespaceStatus_STATUS `json:"status,omitempty"`

	// SubscriptionId: Namespace subscription id.
	SubscriptionId *string `json:"subscriptionId,omitempty"`

	// UpdatedAt: Time when the namespace was updated.
	UpdatedAt *string `json:"updatedAt,omitempty"`

	// ZoneRedundancy: Namespace SKU name.
	ZoneRedundancy *ZoneRedundancyPreference_STATUS `json:"zoneRedundancy,omitempty"`
}

var _ genruntime.FromARMConverter = &NamespaceProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *NamespaceProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.NamespaceProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *NamespaceProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.NamespaceProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.NamespaceProperties_STATUS, got %T", armInput)
	}

	// Set property "CreatedAt":
	if typedInput.CreatedAt != nil {
		createdAt := *typedInput.CreatedAt
		properties.CreatedAt = &createdAt
	}

	// Set property "Critical":
	if typedInput.Critical != nil {
		critical := *typedInput.Critical
		properties.Critical = &critical
	}

	// Set property "DataCenter":
	if typedInput.DataCenter != nil {
		dataCenter := *typedInput.DataCenter
		properties.DataCenter = &dataCenter
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		properties.Enabled = &enabled
	}

	// Set property "MetricId":
	if typedInput.MetricId != nil {
		metricId := *typedInput.MetricId
		properties.MetricId = &metricId
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		properties.Name = &name
	}

	// Set property "NamespaceType":
	if typedInput.NamespaceType != nil {
		var temp string
		temp = string(*typedInput.NamespaceType)
		namespaceType := NamespaceType_STATUS(temp)
		properties.NamespaceType = &namespaceType
	}

	// Set property "NetworkAcls":
	if typedInput.NetworkAcls != nil {
		var networkAcls1 NetworkAcls_STATUS
		err := networkAcls1.PopulateFromARM(owner, *typedInput.NetworkAcls)
		if err != nil {
			return err
		}
		networkAcls := networkAcls1
		properties.NetworkAcls = &networkAcls
	}

	// Set property "PnsCredentials":
	if typedInput.PnsCredentials != nil {
		var pnsCredentials1 PnsCredentials_STATUS
		err := pnsCredentials1.PopulateFromARM(owner, *typedInput.PnsCredentials)
		if err != nil {
			return err
		}
		pnsCredentials := pnsCredentials1
		properties.PnsCredentials = &pnsCredentials
	}

	// Set property "PrivateEndpointConnections":
	for _, item := range typedInput.PrivateEndpointConnections {
		var item1 PrivateEndpointConnectionResource_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		properties.PrivateEndpointConnections = append(properties.PrivateEndpointConnections, item1)
	}

	// Set property "ProvisioningState":
	if typedInput.ProvisioningState != nil {
		var temp string
		temp = string(*typedInput.ProvisioningState)
		provisioningState := OperationProvisioningState_STATUS(temp)
		properties.ProvisioningState = &provisioningState
	}

	// Set property "PublicNetworkAccess":
	if typedInput.PublicNetworkAccess != nil {
		var temp string
		temp = string(*typedInput.PublicNetworkAccess)
		publicNetworkAccess := PublicNetworkAccess_STATUS(temp)
		properties.PublicNetworkAccess = &publicNetworkAccess
	}

	// Set property "Region":
	if typedInput.Region != nil {
		region := *typedInput.Region
		properties.Region = &region
	}

	// Set property "ReplicationRegion":
	if typedInput.ReplicationRegion != nil {
		var temp string
		temp = string(*typedInput.ReplicationRegion)
		replicationRegion := ReplicationRegion_STATUS(temp)
		properties.ReplicationRegion = &replicationRegion
	}

	// Set property "ScaleUnit":
	if typedInput.ScaleUnit != nil {
		scaleUnit := *typedInput.ScaleUnit
		properties.ScaleUnit = &scaleUnit
	}

	// Set property "ServiceBusEndpoint":
	if typedInput.ServiceBusEndpoint != nil {
		serviceBusEndpoint := *typedInput.ServiceBusEndpoint
		properties.ServiceBusEndpoint = &serviceBusEndpoint
	}

	// Set property "Status":
	if typedInput.Status != nil {
		var temp string
		temp = string(*typedInput.Status)
		status := NamespaceStatus_STATUS(temp)
		properties.Status = &status
	}

	// Set property "SubscriptionId":
	if typedInput.SubscriptionId != nil {
		subscriptionId := *typedInput.SubscriptionId
		properties.SubscriptionId = &subscriptionId
	}

	// Set property "UpdatedAt":
	if typedInput.UpdatedAt != nil {
		updatedAt := *typedInput.UpdatedAt
		properties.UpdatedAt = &updatedAt
	}

	// Set property "ZoneRedundancy":
	if typedInput.ZoneRedundancy != nil {
		var temp string
		temp = string(*typedInput.ZoneRedundancy)
		zoneRedundancy := ZoneRedundancyPreference_STATUS(temp)
		properties.ZoneRedundancy = &zoneRedundancy
	}

	// No error
	return nil
}

// AssignProperties_From_NamespaceProperties_STATUS populates our NamespaceProperties_STATUS from the provided source NamespaceProperties_STATUS
func (properties *NamespaceProperties_STATUS) AssignProperties_From_NamespaceProperties_STATUS(source *storage.NamespaceProperties_STATUS) error {

	// CreatedAt
	properties.CreatedAt = genruntime.ClonePointerToString(source.CreatedAt)

	// Critical
	if source.Critical != nil {
		critical := *source.Critical
		properties.Critical = &critical
	} else {
		properties.Critical = nil
	}

	// DataCenter
	properties.DataCenter = genruntime.ClonePointerToString(source.DataCenter)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		properties.Enabled = &enabled
	} else {
		properties.Enabled = nil
	}

	// MetricId
	properties.MetricId = genruntime.ClonePointerToString(source.MetricId)

	// Name
	properties.Name = genruntime.ClonePointerToString(source.Name)

	// NamespaceType
	if source.NamespaceType != nil {
		namespaceType := *source.NamespaceType
		namespaceTypeTemp := genruntime.ToEnum(namespaceType, namespaceType_STATUS_Values)
		properties.NamespaceType = &namespaceTypeTemp
	} else {
		properties.NamespaceType = nil
	}

	// NetworkAcls
	if source.NetworkAcls != nil {
		var networkAcl NetworkAcls_STATUS
		err := networkAcl.AssignProperties_From_NetworkAcls_STATUS(source.NetworkAcls)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_NetworkAcls_STATUS() to populate field NetworkAcls")
		}
		properties.NetworkAcls = &networkAcl
	} else {
		properties.NetworkAcls = nil
	}

	// PnsCredentials
	if source.PnsCredentials != nil {
		var pnsCredential PnsCredentials_STATUS
		err := pnsCredential.AssignProperties_From_PnsCredentials_STATUS(source.PnsCredentials)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_PnsCredentials_STATUS() to populate field PnsCredentials")
		}
		properties.PnsCredentials = &pnsCredential
	} else {
		properties.PnsCredentials = nil
	}

	// PrivateEndpointConnections
	if source.PrivateEndpointConnections != nil {
		privateEndpointConnectionList := make([]PrivateEndpointConnectionResource_STATUS, len(source.PrivateEndpointConnections))
		for privateEndpointConnectionIndex, privateEndpointConnectionItem := range source.PrivateEndpointConnections {
			// Shadow the loop variable to avoid aliasing
			privateEndpointConnectionItem := privateEndpointConnectionItem
			var privateEndpointConnection PrivateEndpointConnectionResource_STATUS
			err := privateEndpointConnection.AssignProperties_From_PrivateEndpointConnectionResource_STATUS(&privateEndpointConnectionItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_PrivateEndpointConnectionResource_STATUS() to populate field PrivateEndpointConnections")
			}
			privateEndpointConnectionList[privateEndpointConnectionIndex] = privateEndpointConnection
		}
		properties.PrivateEndpointConnections = privateEndpointConnectionList
	} else {
		properties.PrivateEndpointConnections = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, operationProvisioningState_STATUS_Values)
		properties.ProvisioningState = &provisioningStateTemp
	} else {
		properties.ProvisioningState = nil
	}

	// PublicNetworkAccess
	if source.PublicNetworkAccess != nil {
		publicNetworkAccess := *source.PublicNetworkAccess
		publicNetworkAccessTemp := genruntime.ToEnum(publicNetworkAccess, publicNetworkAccess_STATUS_Values)
		properties.PublicNetworkAccess = &publicNetworkAccessTemp
	} else {
		properties.PublicNetworkAccess = nil
	}

	// Region
	properties.Region = genruntime.ClonePointerToString(source.Region)

	// ReplicationRegion
	if source.ReplicationRegion != nil {
		replicationRegion := *source.ReplicationRegion
		replicationRegionTemp := genruntime.ToEnum(replicationRegion, replicationRegion_STATUS_Values)
		properties.ReplicationRegion = &replicationRegionTemp
	} else {
		properties.ReplicationRegion = nil
	}

	// ScaleUnit
	properties.ScaleUnit = genruntime.ClonePointerToString(source.ScaleUnit)

	// ServiceBusEndpoint
	properties.ServiceBusEndpoint = genruntime.ClonePointerToString(source.ServiceBusEndpoint)

	// Status
	if source.Status != nil {
		status := *source.Status
		statusTemp := genruntime.ToEnum(status, namespaceStatus_STATUS_Values)
		properties.Status = &statusTemp
	} else {
		properties.Status = nil
	}

	// SubscriptionId
	properties.SubscriptionId = genruntime.ClonePointerToString(source.SubscriptionId)

	// UpdatedAt
	properties.UpdatedAt = genruntime.ClonePointerToString(source.UpdatedAt)

	// ZoneRedundancy
	if source.ZoneRedundancy != nil {
		zoneRedundancy := *source.ZoneRedundancy
		zoneRedundancyTemp := genruntime.ToEnum(zoneRedundancy, zoneRedundancyPreference_STATUS_Values)
		properties.ZoneRedundancy = &zoneRedundancyTemp
	} else {
		properties.ZoneRedundancy = nil
	}

	// No error
	return nil
}

// AssignProperties_To_NamespaceProperties_STATUS populates the provided destination NamespaceProperties_STATUS from our NamespaceProperties_STATUS
func (properties *NamespaceProperties_STATUS) AssignProperties_To_NamespaceProperties_STATUS(destination *storage.NamespaceProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CreatedAt
	destination.CreatedAt = genruntime.ClonePointerToString(properties.CreatedAt)

	// Critical
	if properties.Critical != nil {
		critical := *properties.Critical
		destination.Critical = &critical
	} else {
		destination.Critical = nil
	}

	// DataCenter
	destination.DataCenter = genruntime.ClonePointerToString(properties.DataCenter)

	// Enabled
	if properties.Enabled != nil {
		enabled := *properties.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// MetricId
	destination.MetricId = genruntime.ClonePointerToString(properties.MetricId)

	// Name
	destination.Name = genruntime.ClonePointerToString(properties.Name)

	// NamespaceType
	if properties.NamespaceType != nil {
		namespaceType := string(*properties.NamespaceType)
		destination.NamespaceType = &namespaceType
	} else {
		destination.NamespaceType = nil
	}

	// NetworkAcls
	if properties.NetworkAcls != nil {
		var networkAcl storage.NetworkAcls_STATUS
		err := properties.NetworkAcls.AssignProperties_To_NetworkAcls_STATUS(&networkAcl)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_NetworkAcls_STATUS() to populate field NetworkAcls")
		}
		destination.NetworkAcls = &networkAcl
	} else {
		destination.NetworkAcls = nil
	}

	// PnsCredentials
	if properties.PnsCredentials != nil {
		var pnsCredential storage.PnsCredentials_STATUS
		err := properties.PnsCredentials.AssignProperties_To_PnsCredentials_STATUS(&pnsCredential)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_PnsCredentials_STATUS() to populate field PnsCredentials")
		}
		destination.PnsCredentials = &pnsCredential
	} else {
		destination.PnsCredentials = nil
	}

	// PrivateEndpointConnections
	if properties.PrivateEndpointConnections != nil {
		privateEndpointConnectionList := make([]storage.PrivateEndpointConnectionResource_STATUS, len(properties.PrivateEndpointConnections))
		for privateEndpointConnectionIndex, privateEndpointConnectionItem := range properties.PrivateEndpointConnections {
			// Shadow the loop variable to avoid aliasing
			privateEndpointConnectionItem := privateEndpointConnectionItem
			var privateEndpointConnection storage.PrivateEndpointConnectionResource_STATUS
			err := privateEndpointConnectionItem.AssignProperties_To_PrivateEndpointConnectionResource_STATUS(&privateEndpointConnection)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_PrivateEndpointConnectionResource_STATUS() to populate field PrivateEndpointConnections")
			}
			privateEndpointConnectionList[privateEndpointConnectionIndex] = privateEndpointConnection
		}
		destination.PrivateEndpointConnections = privateEndpointConnectionList
	} else {
		destination.PrivateEndpointConnections = nil
	}

	// ProvisioningState
	if properties.ProvisioningState != nil {
		provisioningState := string(*properties.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// PublicNetworkAccess
	if properties.PublicNetworkAccess != nil {
		publicNetworkAccess := string(*properties.PublicNetworkAccess)
		destination.PublicNetworkAccess = &publicNetworkAccess
	} else {
		destination.PublicNetworkAccess = nil
	}

	// Region
	destination.Region = genruntime.ClonePointerToString(properties.Region)

	// ReplicationRegion
	if properties.ReplicationRegion != nil {
		replicationRegion := string(*properties.ReplicationRegion)
		destination.ReplicationRegion = &replicationRegion
	} else {
		destination.ReplicationRegion = nil
	}

	// ScaleUnit
	destination.ScaleUnit = genruntime.ClonePointerToString(properties.ScaleUnit)

	// ServiceBusEndpoint
	destination.ServiceBusEndpoint = genruntime.ClonePointerToString(properties.ServiceBusEndpoint)

	// Status
	if properties.Status != nil {
		status := string(*properties.Status)
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// SubscriptionId
	destination.SubscriptionId = genruntime.ClonePointerToString(properties.SubscriptionId)

	// UpdatedAt
	destination.UpdatedAt = genruntime.ClonePointerToString(properties.UpdatedAt)

	// ZoneRedundancy
	if properties.ZoneRedundancy != nil {
		zoneRedundancy := string(*properties.ZoneRedundancy)
		destination.ZoneRedundancy = &zoneRedundancy
	} else {
		destination.ZoneRedundancy = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The Sku description for a namespace
type Sku struct {
	// Capacity: Gets or sets the capacity of the resource
	Capacity *int `json:"capacity,omitempty"`

	// Family: Gets or sets the Sku Family
	Family *string `json:"family,omitempty"`

	// +kubebuilder:validation:Required
	// Name: Namespace SKU name.
	Name *SkuName `json:"name,omitempty"`

	// Size: Gets or sets the Sku size
	Size *string `json:"size,omitempty"`

	// Tier: Gets or sets the tier of particular sku
	Tier *string `json:"tier,omitempty"`
}

var _ genruntime.ARMTransformer = &Sku{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (sku *Sku) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if sku == nil {
		return nil, nil
	}
	result := &arm.Sku{}

	// Set property "Capacity":
	if sku.Capacity != nil {
		capacity := *sku.Capacity
		result.Capacity = &capacity
	}

	// Set property "Family":
	if sku.Family != nil {
		family := *sku.Family
		result.Family = &family
	}

	// Set property "Name":
	if sku.Name != nil {
		var temp string
		temp = string(*sku.Name)
		name := arm.SkuName(temp)
		result.Name = &name
	}

	// Set property "Size":
	if sku.Size != nil {
		size := *sku.Size
		result.Size = &size
	}

	// Set property "Tier":
	if sku.Tier != nil {
		tier := *sku.Tier
		result.Tier = &tier
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sku *Sku) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Sku{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sku *Sku) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Sku)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Sku, got %T", armInput)
	}

	// Set property "Capacity":
	if typedInput.Capacity != nil {
		capacity := *typedInput.Capacity
		sku.Capacity = &capacity
	}

	// Set property "Family":
	if typedInput.Family != nil {
		family := *typedInput.Family
		sku.Family = &family
	}

	// Set property "Name":
	if typedInput.Name != nil {
		var temp string
		temp = string(*typedInput.Name)
		name := SkuName(temp)
		sku.Name = &name
	}

	// Set property "Size":
	if typedInput.Size != nil {
		size := *typedInput.Size
		sku.Size = &size
	}

	// Set property "Tier":
	if typedInput.Tier != nil {
		tier := *typedInput.Tier
		sku.Tier = &tier
	}

	// No error
	return nil
}

// AssignProperties_From_Sku populates our Sku from the provided source Sku
func (sku *Sku) AssignProperties_From_Sku(source *storage.Sku) error {

	// Capacity
	sku.Capacity = genruntime.ClonePointerToInt(source.Capacity)

	// Family
	sku.Family = genruntime.ClonePointerToString(source.Family)

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, skuName_Values)
		sku.Name = &nameTemp
	} else {
		sku.Name = nil
	}

	// Size
	sku.Size = genruntime.ClonePointerToString(source.Size)

	// Tier
	sku.Tier = genruntime.ClonePointerToString(source.Tier)

	// No error
	return nil
}

// AssignProperties_To_Sku populates the provided destination Sku from our Sku
func (sku *Sku) AssignProperties_To_Sku(destination *storage.Sku) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Capacity
	destination.Capacity = genruntime.ClonePointerToInt(sku.Capacity)

	// Family
	destination.Family = genruntime.ClonePointerToString(sku.Family)

	// Name
	if sku.Name != nil {
		name := string(*sku.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Size
	destination.Size = genruntime.ClonePointerToString(sku.Size)

	// Tier
	destination.Tier = genruntime.ClonePointerToString(sku.Tier)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Sku_STATUS populates our Sku from the provided source Sku_STATUS
func (sku *Sku) Initialize_From_Sku_STATUS(source *Sku_STATUS) error {

	// Capacity
	sku.Capacity = genruntime.ClonePointerToInt(source.Capacity)

	// Family
	sku.Family = genruntime.ClonePointerToString(source.Family)

	// Name
	if source.Name != nil {
		name := genruntime.ToEnum(string(*source.Name), skuName_Values)
		sku.Name = &name
	} else {
		sku.Name = nil
	}

	// Size
	sku.Size = genruntime.ClonePointerToString(source.Size)

	// Tier
	sku.Tier = genruntime.ClonePointerToString(source.Tier)

	// No error
	return nil
}

// The Sku description for a namespace
type Sku_STATUS struct {
	// Capacity: Gets or sets the capacity of the resource
	Capacity *int `json:"capacity,omitempty"`

	// Family: Gets or sets the Sku Family
	Family *string `json:"family,omitempty"`

	// Name: Namespace SKU name.
	Name *SkuName_STATUS `json:"name,omitempty"`

	// Size: Gets or sets the Sku size
	Size *string `json:"size,omitempty"`

	// Tier: Gets or sets the tier of particular sku
	Tier *string `json:"tier,omitempty"`
}

var _ genruntime.FromARMConverter = &Sku_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sku *Sku_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Sku_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sku *Sku_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Sku_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Sku_STATUS, got %T", armInput)
	}

	// Set property "Capacity":
	if typedInput.Capacity != nil {
		capacity := *typedInput.Capacity
		sku.Capacity = &capacity
	}

	// Set property "Family":
	if typedInput.Family != nil {
		family := *typedInput.Family
		sku.Family = &family
	}

	// Set property "Name":
	if typedInput.Name != nil {
		var temp string
		temp = string(*typedInput.Name)
		name := SkuName_STATUS(temp)
		sku.Name = &name
	}

	// Set property "Size":
	if typedInput.Size != nil {
		size := *typedInput.Size
		sku.Size = &size
	}

	// Set property "Tier":
	if typedInput.Tier != nil {
		tier := *typedInput.Tier
		sku.Tier = &tier
	}

	// No error
	return nil
}

// AssignProperties_From_Sku_STATUS populates our Sku_STATUS from the provided source Sku_STATUS
func (sku *Sku_STATUS) AssignProperties_From_Sku_STATUS(source *storage.Sku_STATUS) error {

	// Capacity
	sku.Capacity = genruntime.ClonePointerToInt(source.Capacity)

	// Family
	sku.Family = genruntime.ClonePointerToString(source.Family)

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, skuName_STATUS_Values)
		sku.Name = &nameTemp
	} else {
		sku.Name = nil
	}

	// Size
	sku.Size = genruntime.ClonePointerToString(source.Size)

	// Tier
	sku.Tier = genruntime.ClonePointerToString(source.Tier)

	// No error
	return nil
}

// AssignProperties_To_Sku_STATUS populates the provided destination Sku_STATUS from our Sku_STATUS
func (sku *Sku_STATUS) AssignProperties_To_Sku_STATUS(destination *storage.Sku_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Capacity
	destination.Capacity = genruntime.ClonePointerToInt(sku.Capacity)

	// Family
	destination.Family = genruntime.ClonePointerToString(sku.Family)

	// Name
	if sku.Name != nil {
		name := string(*sku.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Size
	destination.Size = genruntime.ClonePointerToString(sku.Size)

	// Tier
	destination.Tier = genruntime.ClonePointerToString(sku.Tier)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Metadata pertaining to creation and last modification of the resource.
type SystemData_STATUS struct {
	// CreatedAt: The timestamp of resource creation (UTC).
	CreatedAt *string `json:"createdAt,omitempty"`

	// CreatedBy: The identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty"`

	// CreatedByType: The type of identity that created the resource.
	CreatedByType *SystemData_CreatedByType_STATUS `json:"createdByType,omitempty"`

	// LastModifiedAt: The timestamp of resource last modification (UTC)
	LastModifiedAt *string `json:"lastModifiedAt,omitempty"`

	// LastModifiedBy: The identity that last modified the resource.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`

	// LastModifiedByType: The type of identity that last modified the resource.
	LastModifiedByType *SystemData_LastModifiedByType_STATUS `json:"lastModifiedByType,omitempty"`
}

var _ genruntime.FromARMConverter = &SystemData_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (data *SystemData_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SystemData_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (data *SystemData_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SystemData_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SystemData_STATUS, got %T", armInput)
	}

	// Set property "CreatedAt":
	if typedInput.CreatedAt != nil {
		createdAt := *typedInput.CreatedAt
		data.CreatedAt = &createdAt
	}

	// Set property "CreatedBy":
	if typedInput.CreatedBy != nil {
		createdBy := *typedInput.CreatedBy
		data.CreatedBy = &createdBy
	}

	// Set property "CreatedByType":
	if typedInput.CreatedByType != nil {
		var temp string
		temp = string(*typedInput.CreatedByType)
		createdByType := SystemData_CreatedByType_STATUS(temp)
		data.CreatedByType = &createdByType
	}

	// Set property "LastModifiedAt":
	if typedInput.LastModifiedAt != nil {
		lastModifiedAt := *typedInput.LastModifiedAt
		data.LastModifiedAt = &lastModifiedAt
	}

	// Set property "LastModifiedBy":
	if typedInput.LastModifiedBy != nil {
		lastModifiedBy := *typedInput.LastModifiedBy
		data.LastModifiedBy = &lastModifiedBy
	}

	// Set property "LastModifiedByType":
	if typedInput.LastModifiedByType != nil {
		var temp string
		temp = string(*typedInput.LastModifiedByType)
		lastModifiedByType := SystemData_LastModifiedByType_STATUS(temp)
		data.LastModifiedByType = &lastModifiedByType
	}

	// No error
	return nil
}

// AssignProperties_From_SystemData_STATUS populates our SystemData_STATUS from the provided source SystemData_STATUS
func (data *SystemData_STATUS) AssignProperties_From_SystemData_STATUS(source *storage.SystemData_STATUS) error {

	// CreatedAt
	data.CreatedAt = genruntime.ClonePointerToString(source.CreatedAt)

	// CreatedBy
	data.CreatedBy = genruntime.ClonePointerToString(source.CreatedBy)

	// CreatedByType
	if source.CreatedByType != nil {
		createdByType := *source.CreatedByType
		createdByTypeTemp := genruntime.ToEnum(createdByType, systemData_CreatedByType_STATUS_Values)
		data.CreatedByType = &createdByTypeTemp
	} else {
		data.CreatedByType = nil
	}

	// LastModifiedAt
	data.LastModifiedAt = genruntime.ClonePointerToString(source.LastModifiedAt)

	// LastModifiedBy
	data.LastModifiedBy = genruntime.ClonePointerToString(source.LastModifiedBy)

	// LastModifiedByType
	if source.LastModifiedByType != nil {
		lastModifiedByType := *source.LastModifiedByType
		lastModifiedByTypeTemp := genruntime.ToEnum(lastModifiedByType, systemData_LastModifiedByType_STATUS_Values)
		data.LastModifiedByType = &lastModifiedByTypeTemp
	} else {
		data.LastModifiedByType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SystemData_STATUS populates the provided destination SystemData_STATUS from our SystemData_STATUS
func (data *SystemData_STATUS) AssignProperties_To_SystemData_STATUS(destination *storage.SystemData_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CreatedAt
	destination.CreatedAt = genruntime.ClonePointerToString(data.CreatedAt)

	// CreatedBy
	destination.CreatedBy = genruntime.ClonePointerToString(data.CreatedBy)

	// CreatedByType
	if data.CreatedByType != nil {
		createdByType := string(*data.CreatedByType)
		destination.CreatedByType = &createdByType
	} else {
		destination.CreatedByType = nil
	}

	// LastModifiedAt
	destination.LastModifiedAt = genruntime.ClonePointerToString(data.LastModifiedAt)

	// LastModifiedBy
	destination.LastModifiedBy = genruntime.ClonePointerToString(data.LastModifiedBy)

	// LastModifiedByType
	if data.LastModifiedByType != nil {
		lastModifiedByType := string(*data.LastModifiedByType)
		destination.LastModifiedByType = &lastModifiedByType
	} else {
		destination.LastModifiedByType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type NamespaceOperatorConfigMaps struct {
	// ServiceBusEndpoint: indicates where the ServiceBusEndpoint config map should be placed. If omitted, no config map will
	// be created.
	ServiceBusEndpoint *genruntime.ConfigMapDestination `json:"serviceBusEndpoint,omitempty"`
}

// AssignProperties_From_NamespaceOperatorConfigMaps populates our NamespaceOperatorConfigMaps from the provided source NamespaceOperatorConfigMaps
func (maps *NamespaceOperatorConfigMaps) AssignProperties_From_NamespaceOperatorConfigMaps(source *storage.NamespaceOperatorConfigMaps) error {

	// ServiceBusEndpoint
	if source.ServiceBusEndpoint != nil {
		serviceBusEndpoint := source.ServiceBusEndpoint.Copy()
		maps.ServiceBusEndpoint = &serviceBusEndpoint
	} else {
		maps.ServiceBusEndpoint = nil
	}

	// No error
	return nil
}

// AssignProperties_To_NamespaceOperatorConfigMaps populates the provided destination NamespaceOperatorConfigMaps from our NamespaceOperatorConfigMaps
func (maps *NamespaceOperatorConfigMaps) AssignProperties_To_NamespaceOperatorConfigMaps(destination *storage.NamespaceOperatorConfigMaps) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ServiceBusEndpoint
	if maps.ServiceBusEndpoint != nil {
		serviceBusEndpoint := maps.ServiceBusEndpoint.Copy()
		destination.ServiceBusEndpoint = &serviceBusEndpoint
	} else {
		destination.ServiceBusEndpoint = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type NamespaceOperatorSecrets struct {
	// PrimaryConnectionString: indicates where the PrimaryConnectionString secret should be placed. If omitted, the secret
	// will not be retrieved from Azure.
	PrimaryConnectionString *genruntime.SecretDestination `json:"primaryConnectionString,omitempty"`

	// PrimaryKey: indicates where the PrimaryKey secret should be placed. If omitted, the secret will not be retrieved from
	// Azure.
	PrimaryKey *genruntime.SecretDestination `json:"primaryKey,omitempty"`

	// SecondaryConnectionString: indicates where the SecondaryConnectionString secret should be placed. If omitted, the secret
	// will not be retrieved from Azure.
	SecondaryConnectionString *genruntime.SecretDestination `json:"secondaryConnectionString,omitempty"`

	// SecondaryKey: indicates where the SecondaryKey secret should be placed. If omitted, the secret will not be retrieved
	// from Azure.
	SecondaryKey *genruntime.SecretDestination `json:"secondaryKey,omitempty"`
}

// AssignProperties_From_NamespaceOperatorSecrets populates our NamespaceOperatorSecrets from the provided source NamespaceOperatorSecrets
func (secrets *NamespaceOperatorSecrets) AssignProperties_From_NamespaceOperatorSecrets(source *storage.NamespaceOperatorSecrets) error {

	// PrimaryConnectionString
	if source.PrimaryConnectionString != nil {
		primaryConnectionString := source.PrimaryConnectionString.Copy()
		secrets.PrimaryConnectionString = &primaryConnectionString
	} else {
		secrets.PrimaryConnectionString = nil
	}

	// PrimaryKey
	if source.PrimaryKey != nil {
		primaryKey := source.PrimaryKey.Copy()
		secrets.PrimaryKey = &primaryKey
	} else {
		secrets.PrimaryKey = nil
	}

	// SecondaryConnectionString
	if source.SecondaryConnectionString != nil {
		secondaryConnectionString := source.SecondaryConnectionString.Copy()
		secrets.SecondaryConnectionString = &secondaryConnectionString
	} else {
		secrets.SecondaryConnectionString = nil
	}

	// SecondaryKey
	if source.SecondaryKey != nil {
		secondaryKey := source.SecondaryKey.Copy()
		secrets.SecondaryKey = &secondaryKey
	} else {
		secrets.SecondaryKey = nil
	}

	// No error
	return nil
}

// AssignProperties_To_NamespaceOperatorSecrets populates the provided destination NamespaceOperatorSecrets from our NamespaceOperatorSecrets
func (secrets *NamespaceOperatorSecrets) AssignProperties_To_NamespaceOperatorSecrets(destination *storage.NamespaceOperatorSecrets) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrimaryConnectionString
	if secrets.PrimaryConnectionString != nil {
		primaryConnectionString := secrets.PrimaryConnectionString.Copy()
		destination.PrimaryConnectionString = &primaryConnectionString
	} else {
		destination.PrimaryConnectionString = nil
	}

	// PrimaryKey
	if secrets.PrimaryKey != nil {
		primaryKey := secrets.PrimaryKey.Copy()
		destination.PrimaryKey = &primaryKey
	} else {
		destination.PrimaryKey = nil
	}

	// SecondaryConnectionString
	if secrets.SecondaryConnectionString != nil {
		secondaryConnectionString := secrets.SecondaryConnectionString.Copy()
		destination.SecondaryConnectionString = &secondaryConnectionString
	} else {
		destination.SecondaryConnectionString = nil
	}

	// SecondaryKey
	if secrets.SecondaryKey != nil {
		secondaryKey := secrets.SecondaryKey.Copy()
		destination.SecondaryKey = &secondaryKey
	} else {
		destination.SecondaryKey = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Namespace status.
type NamespaceStatus_STATUS string

const (
	NamespaceStatus_STATUS_Created   = NamespaceStatus_STATUS("Created")
	NamespaceStatus_STATUS_Creating  = NamespaceStatus_STATUS("Creating")
	NamespaceStatus_STATUS_Deleting  = NamespaceStatus_STATUS("Deleting")
	NamespaceStatus_STATUS_Suspended = NamespaceStatus_STATUS("Suspended")
)

// Mapping from string to NamespaceStatus_STATUS
var namespaceStatus_STATUS_Values = map[string]NamespaceStatus_STATUS{
	"created":   NamespaceStatus_STATUS_Created,
	"creating":  NamespaceStatus_STATUS_Creating,
	"deleting":  NamespaceStatus_STATUS_Deleting,
	"suspended": NamespaceStatus_STATUS_Suspended,
}

// Defines values for NamespaceType.
// +kubebuilder:validation:Enum={"Messaging","NotificationHub"}
type NamespaceType string

const (
	NamespaceType_Messaging       = NamespaceType("Messaging")
	NamespaceType_NotificationHub = NamespaceType("NotificationHub")
)

// Mapping from string to NamespaceType
var namespaceType_Values = map[string]NamespaceType{
	"messaging":       NamespaceType_Messaging,
	"notificationhub": NamespaceType_NotificationHub,
}

// Defines values for NamespaceType.
type NamespaceType_STATUS string

const (
	NamespaceType_STATUS_Messaging       = NamespaceType_STATUS("Messaging")
	NamespaceType_STATUS_NotificationHub = NamespaceType_STATUS("NotificationHub")
)

// Mapping from string to NamespaceType_STATUS
var namespaceType_STATUS_Values = map[string]NamespaceType_STATUS{
	"messaging":       NamespaceType_STATUS_Messaging,
	"notificationhub": NamespaceType_STATUS_NotificationHub,
}

// A collection of network authorization rules.
type NetworkAcls struct {
	// IpRules: List of IP rules.
	IpRules []IpRule `json:"ipRules,omitempty"`

	// PublicNetworkRule: A default (public Internet) network authorization rule, which contains rights if no other network
	// rule matches.
	PublicNetworkRule *PublicInternetAuthorizationRule `json:"publicNetworkRule,omitempty"`
}

var _ genruntime.ARMTransformer = &NetworkAcls{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (acls *NetworkAcls) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if acls == nil {
		return nil, nil
	}
	result := &arm.NetworkAcls{}

	// Set property "IpRules":
	for _, item := range acls.IpRules {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.IpRules = append(result.IpRules, *item_ARM.(*arm.IpRule))
	}

	// Set property "PublicNetworkRule":
	if acls.PublicNetworkRule != nil {
		publicNetworkRule_ARM, err := (*acls.PublicNetworkRule).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		publicNetworkRule := *publicNetworkRule_ARM.(*arm.PublicInternetAuthorizationRule)
		result.PublicNetworkRule = &publicNetworkRule
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (acls *NetworkAcls) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.NetworkAcls{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (acls *NetworkAcls) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.NetworkAcls)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.NetworkAcls, got %T", armInput)
	}

	// Set property "IpRules":
	for _, item := range typedInput.IpRules {
		var item1 IpRule
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		acls.IpRules = append(acls.IpRules, item1)
	}

	// Set property "PublicNetworkRule":
	if typedInput.PublicNetworkRule != nil {
		var publicNetworkRule1 PublicInternetAuthorizationRule
		err := publicNetworkRule1.PopulateFromARM(owner, *typedInput.PublicNetworkRule)
		if err != nil {
			return err
		}
		publicNetworkRule := publicNetworkRule1
		acls.PublicNetworkRule = &publicNetworkRule
	}

	// No error
	return nil
}

// AssignProperties_From_NetworkAcls populates our NetworkAcls from the provided source NetworkAcls
func (acls *NetworkAcls) AssignProperties_From_NetworkAcls(source *storage.NetworkAcls) error {

	// IpRules
	if source.IpRules != nil {
		ipRuleList := make([]IpRule, len(source.IpRules))
		for ipRuleIndex, ipRuleItem := range source.IpRules {
			// Shadow the loop variable to avoid aliasing
			ipRuleItem := ipRuleItem
			var ipRule IpRule
			err := ipRule.AssignProperties_From_IpRule(&ipRuleItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_IpRule() to populate field IpRules")
			}
			ipRuleList[ipRuleIndex] = ipRule
		}
		acls.IpRules = ipRuleList
	} else {
		acls.IpRules = nil
	}

	// PublicNetworkRule
	if source.PublicNetworkRule != nil {
		var publicNetworkRule PublicInternetAuthorizationRule
		err := publicNetworkRule.AssignProperties_From_PublicInternetAuthorizationRule(source.PublicNetworkRule)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_PublicInternetAuthorizationRule() to populate field PublicNetworkRule")
		}
		acls.PublicNetworkRule = &publicNetworkRule
	} else {
		acls.PublicNetworkRule = nil
	}

	// No error
	return nil
}

// AssignProperties_To_NetworkAcls populates the provided destination NetworkAcls from our NetworkAcls
func (acls *NetworkAcls) AssignProperties_To_NetworkAcls(destination *storage.NetworkAcls) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IpRules
	if acls.IpRules != nil {
		ipRuleList := make([]storage.IpRule, len(acls.IpRules))
		for ipRuleIndex, ipRuleItem := range acls.IpRules {
			// Shadow the loop variable to avoid aliasing
			ipRuleItem := ipRuleItem
			var ipRule storage.IpRule
			err := ipRuleItem.AssignProperties_To_IpRule(&ipRule)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_IpRule() to populate field IpRules")
			}
			ipRuleList[ipRuleIndex] = ipRule
		}
		destination.IpRules = ipRuleList
	} else {
		destination.IpRules = nil
	}

	// PublicNetworkRule
	if acls.PublicNetworkRule != nil {
		var publicNetworkRule storage.PublicInternetAuthorizationRule
		err := acls.PublicNetworkRule.AssignProperties_To_PublicInternetAuthorizationRule(&publicNetworkRule)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_PublicInternetAuthorizationRule() to populate field PublicNetworkRule")
		}
		destination.PublicNetworkRule = &publicNetworkRule
	} else {
		destination.PublicNetworkRule = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_NetworkAcls_STATUS populates our NetworkAcls from the provided source NetworkAcls_STATUS
func (acls *NetworkAcls) Initialize_From_NetworkAcls_STATUS(source *NetworkAcls_STATUS) error {

	// IpRules
	if source.IpRules != nil {
		ipRuleList := make([]IpRule, len(source.IpRules))
		for ipRuleIndex, ipRuleItem := range source.IpRules {
			// Shadow the loop variable to avoid aliasing
			ipRuleItem := ipRuleItem
			var ipRule IpRule
			err := ipRule.Initialize_From_IpRule_STATUS(&ipRuleItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_IpRule_STATUS() to populate field IpRules")
			}
			ipRuleList[ipRuleIndex] = ipRule
		}
		acls.IpRules = ipRuleList
	} else {
		acls.IpRules = nil
	}

	// PublicNetworkRule
	if source.PublicNetworkRule != nil {
		var publicNetworkRule PublicInternetAuthorizationRule
		err := publicNetworkRule.Initialize_From_PublicInternetAuthorizationRule_STATUS(source.PublicNetworkRule)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_PublicInternetAuthorizationRule_STATUS() to populate field PublicNetworkRule")
		}
		acls.PublicNetworkRule = &publicNetworkRule
	} else {
		acls.PublicNetworkRule = nil
	}

	// No error
	return nil
}

// A collection of network authorization rules.
type NetworkAcls_STATUS struct {
	// IpRules: List of IP rules.
	IpRules []IpRule_STATUS `json:"ipRules,omitempty"`

	// PublicNetworkRule: A default (public Internet) network authorization rule, which contains rights if no other network
	// rule matches.
	PublicNetworkRule *PublicInternetAuthorizationRule_STATUS `json:"publicNetworkRule,omitempty"`
}

var _ genruntime.FromARMConverter = &NetworkAcls_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (acls *NetworkAcls_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.NetworkAcls_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (acls *NetworkAcls_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.NetworkAcls_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.NetworkAcls_STATUS, got %T", armInput)
	}

	// Set property "IpRules":
	for _, item := range typedInput.IpRules {
		var item1 IpRule_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		acls.IpRules = append(acls.IpRules, item1)
	}

	// Set property "PublicNetworkRule":
	if typedInput.PublicNetworkRule != nil {
		var publicNetworkRule1 PublicInternetAuthorizationRule_STATUS
		err := publicNetworkRule1.PopulateFromARM(owner, *typedInput.PublicNetworkRule)
		if err != nil {
			return err
		}
		publicNetworkRule := publicNetworkRule1
		acls.PublicNetworkRule = &publicNetworkRule
	}

	// No error
	return nil
}

// AssignProperties_From_NetworkAcls_STATUS populates our NetworkAcls_STATUS from the provided source NetworkAcls_STATUS
func (acls *NetworkAcls_STATUS) AssignProperties_From_NetworkAcls_STATUS(source *storage.NetworkAcls_STATUS) error {

	// IpRules
	if source.IpRules != nil {
		ipRuleList := make([]IpRule_STATUS, len(source.IpRules))
		for ipRuleIndex, ipRuleItem := range source.IpRules {
			// Shadow the loop variable to avoid aliasing
			ipRuleItem := ipRuleItem
			var ipRule IpRule_STATUS
			err := ipRule.AssignProperties_From_IpRule_STATUS(&ipRuleItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_IpRule_STATUS() to populate field IpRules")
			}
			ipRuleList[ipRuleIndex] = ipRule
		}
		acls.IpRules = ipRuleList
	} else {
		acls.IpRules = nil
	}

	// PublicNetworkRule
	if source.PublicNetworkRule != nil {
		var publicNetworkRule PublicInternetAuthorizationRule_STATUS
		err := publicNetworkRule.AssignProperties_From_PublicInternetAuthorizationRule_STATUS(source.PublicNetworkRule)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_PublicInternetAuthorizationRule_STATUS() to populate field PublicNetworkRule")
		}
		acls.PublicNetworkRule = &publicNetworkRule
	} else {
		acls.PublicNetworkRule = nil
	}

	// No error
	return nil
}

// AssignProperties_To_NetworkAcls_STATUS populates the provided destination NetworkAcls_STATUS from our NetworkAcls_STATUS
func (acls *NetworkAcls_STATUS) AssignProperties_To_NetworkAcls_STATUS(destination *storage.NetworkAcls_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IpRules
	if acls.IpRules != nil {
		ipRuleList := make([]storage.IpRule_STATUS, len(acls.IpRules))
		for ipRuleIndex, ipRuleItem := range acls.IpRules {
			// Shadow the loop variable to avoid aliasing
			ipRuleItem := ipRuleItem
			var ipRule storage.IpRule_STATUS
			err := ipRuleItem.AssignProperties_To_IpRule_STATUS(&ipRule)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_IpRule_STATUS() to populate field IpRules")
			}
			ipRuleList[ipRuleIndex] = ipRule
		}
		destination.IpRules = ipRuleList
	} else {
		destination.IpRules = nil
	}

	// PublicNetworkRule
	if acls.PublicNetworkRule != nil {
		var publicNetworkRule storage.PublicInternetAuthorizationRule_STATUS
		err := acls.PublicNetworkRule.AssignProperties_To_PublicInternetAuthorizationRule_STATUS(&publicNetworkRule)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_PublicInternetAuthorizationRule_STATUS() to populate field PublicNetworkRule")
		}
		destination.PublicNetworkRule = &publicNetworkRule
	} else {
		destination.PublicNetworkRule = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines values for OperationProvisioningState.
type OperationProvisioningState_STATUS string

const (
	OperationProvisioningState_STATUS_Canceled   = OperationProvisioningState_STATUS("Canceled")
	OperationProvisioningState_STATUS_Disabled   = OperationProvisioningState_STATUS("Disabled")
	OperationProvisioningState_STATUS_Failed     = OperationProvisioningState_STATUS("Failed")
	OperationProvisioningState_STATUS_InProgress = OperationProvisioningState_STATUS("InProgress")
	OperationProvisioningState_STATUS_Pending    = OperationProvisioningState_STATUS("Pending")
	OperationProvisioningState_STATUS_Succeeded  = OperationProvisioningState_STATUS("Succeeded")
	OperationProvisioningState_STATUS_Unknown    = OperationProvisioningState_STATUS("Unknown")
)

// Mapping from string to OperationProvisioningState_STATUS
var operationProvisioningState_STATUS_Values = map[string]OperationProvisioningState_STATUS{
	"canceled":   OperationProvisioningState_STATUS_Canceled,
	"disabled":   OperationProvisioningState_STATUS_Disabled,
	"failed":     OperationProvisioningState_STATUS_Failed,
	"inprogress": OperationProvisioningState_STATUS_InProgress,
	"pending":    OperationProvisioningState_STATUS_Pending,
	"succeeded":  OperationProvisioningState_STATUS_Succeeded,
	"unknown":    OperationProvisioningState_STATUS_Unknown,
}

// Collection of Notification Hub or Notification Hub Namespace PNS credentials.
type PnsCredentials struct {
	// AdmCredential: Description of a NotificationHub AdmCredential.
	AdmCredential *AdmCredential `json:"admCredential,omitempty"`

	// ApnsCredential: Description of a NotificationHub ApnsCredential.
	ApnsCredential *ApnsCredential `json:"apnsCredential,omitempty"`

	// BaiduCredential: Description of a NotificationHub BaiduCredential.
	BaiduCredential *BaiduCredential `json:"baiduCredential,omitempty"`

	// BrowserCredential: Description of a NotificationHub BrowserCredential.
	BrowserCredential *BrowserCredential `json:"browserCredential,omitempty"`

	// GcmCredential: Description of a NotificationHub GcmCredential.
	GcmCredential *GcmCredential `json:"gcmCredential,omitempty"`

	// MpnsCredential: Description of a NotificationHub MpnsCredential.
	MpnsCredential *MpnsCredential `json:"mpnsCredential,omitempty"`

	// WnsCredential: Description of a NotificationHub WnsCredential.
	WnsCredential *WnsCredential `json:"wnsCredential,omitempty"`

	// XiaomiCredential: Description of a NotificationHub XiaomiCredential.
	XiaomiCredential *XiaomiCredential `json:"xiaomiCredential,omitempty"`
}

var _ genruntime.ARMTransformer = &PnsCredentials{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (credentials *PnsCredentials) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if credentials == nil {
		return nil, nil
	}
	result := &arm.PnsCredentials{}

	// Set property "AdmCredential":
	if credentials.AdmCredential != nil {
		admCredential_ARM, err := (*credentials.AdmCredential).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		admCredential := *admCredential_ARM.(*arm.AdmCredential)
		result.AdmCredential = &admCredential
	}

	// Set property "ApnsCredential":
	if credentials.ApnsCredential != nil {
		apnsCredential_ARM, err := (*credentials.ApnsCredential).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		apnsCredential := *apnsCredential_ARM.(*arm.ApnsCredential)
		result.ApnsCredential = &apnsCredential
	}

	// Set property "BaiduCredential":
	if credentials.BaiduCredential != nil {
		baiduCredential_ARM, err := (*credentials.BaiduCredential).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		baiduCredential := *baiduCredential_ARM.(*arm.BaiduCredential)
		result.BaiduCredential = &baiduCredential
	}

	// Set property "BrowserCredential":
	if credentials.BrowserCredential != nil {
		browserCredential_ARM, err := (*credentials.BrowserCredential).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		browserCredential := *browserCredential_ARM.(*arm.BrowserCredential)
		result.BrowserCredential = &browserCredential
	}

	// Set property "GcmCredential":
	if credentials.GcmCredential != nil {
		gcmCredential_ARM, err := (*credentials.GcmCredential).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		gcmCredential := *gcmCredential_ARM.(*arm.GcmCredential)
		result.GcmCredential = &gcmCredential
	}

	// Set property "MpnsCredential":
	if credentials.MpnsCredential != nil {
		mpnsCredential_ARM, err := (*credentials.MpnsCredential).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		mpnsCredential := *mpnsCredential_ARM.(*arm.MpnsCredential)
		result.MpnsCredential = &mpnsCredential
	}

	// Set property "WnsCredential":
	if credentials.WnsCredential != nil {
		wnsCredential_ARM, err := (*credentials.WnsCredential).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		wnsCredential := *wnsCredential_ARM.(*arm.WnsCredential)
		result.WnsCredential = &wnsCredential
	}

	// Set property "XiaomiCredential":
	if credentials.XiaomiCredential != nil {
		xiaomiCredential_ARM, err := (*credentials.XiaomiCredential).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		xiaomiCredential := *xiaomiCredential_ARM.(*arm.XiaomiCredential)
		result.XiaomiCredential = &xiaomiCredential
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (credentials *PnsCredentials) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PnsCredentials{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (credentials *PnsCredentials) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PnsCredentials)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PnsCredentials, got %T", armInput)
	}

	// Set property "AdmCredential":
	if typedInput.AdmCredential != nil {
		var admCredential1 AdmCredential
		err := admCredential1.PopulateFromARM(owner, *typedInput.AdmCredential)
		if err != nil {
			return err
		}
		admCredential := admCredential1
		credentials.AdmCredential = &admCredential
	}

	// Set property "ApnsCredential":
	if typedInput.ApnsCredential != nil {
		var apnsCredential1 ApnsCredential
		err := apnsCredential1.PopulateFromARM(owner, *typedInput.ApnsCredential)
		if err != nil {
			return err
		}
		apnsCredential := apnsCredential1
		credentials.ApnsCredential = &apnsCredential
	}

	// Set property "BaiduCredential":
	if typedInput.BaiduCredential != nil {
		var baiduCredential1 BaiduCredential
		err := baiduCredential1.PopulateFromARM(owner, *typedInput.BaiduCredential)
		if err != nil {
			return err
		}
		baiduCredential := baiduCredential1
		credentials.BaiduCredential = &baiduCredential
	}

	// Set property "BrowserCredential":
	if typedInput.BrowserCredential != nil {
		var browserCredential1 BrowserCredential
		err := browserCredential1.PopulateFromARM(owner, *typedInput.BrowserCredential)
		if err != nil {
			return err
		}
		browserCredential := browserCredential1
		credentials.BrowserCredential = &browserCredential
	}

	// Set property "GcmCredential":
	if typedInput.GcmCredential != nil {
		var gcmCredential1 GcmCredential
		err := gcmCredential1.PopulateFromARM(owner, *typedInput.GcmCredential)
		if err != nil {
			return err
		}
		gcmCredential := gcmCredential1
		credentials.GcmCredential = &gcmCredential
	}

	// Set property "MpnsCredential":
	if typedInput.MpnsCredential != nil {
		var mpnsCredential1 MpnsCredential
		err := mpnsCredential1.PopulateFromARM(owner, *typedInput.MpnsCredential)
		if err != nil {
			return err
		}
		mpnsCredential := mpnsCredential1
		credentials.MpnsCredential = &mpnsCredential
	}

	// Set property "WnsCredential":
	if typedInput.WnsCredential != nil {
		var wnsCredential1 WnsCredential
		err := wnsCredential1.PopulateFromARM(owner, *typedInput.WnsCredential)
		if err != nil {
			return err
		}
		wnsCredential := wnsCredential1
		credentials.WnsCredential = &wnsCredential
	}

	// Set property "XiaomiCredential":
	if typedInput.XiaomiCredential != nil {
		var xiaomiCredential1 XiaomiCredential
		err := xiaomiCredential1.PopulateFromARM(owner, *typedInput.XiaomiCredential)
		if err != nil {
			return err
		}
		xiaomiCredential := xiaomiCredential1
		credentials.XiaomiCredential = &xiaomiCredential
	}

	// No error
	return nil
}

// AssignProperties_From_PnsCredentials populates our PnsCredentials from the provided source PnsCredentials
func (credentials *PnsCredentials) AssignProperties_From_PnsCredentials(source *storage.PnsCredentials) error {

	// AdmCredential
	if source.AdmCredential != nil {
		var admCredential AdmCredential
		err := admCredential.AssignProperties_From_AdmCredential(source.AdmCredential)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AdmCredential() to populate field AdmCredential")
		}
		credentials.AdmCredential = &admCredential
	} else {
		credentials.AdmCredential = nil
	}

	// ApnsCredential
	if source.ApnsCredential != nil {
		var apnsCredential ApnsCredential
		err := apnsCredential.AssignProperties_From_ApnsCredential(source.ApnsCredential)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ApnsCredential() to populate field ApnsCredential")
		}
		credentials.ApnsCredential = &apnsCredential
	} else {
		credentials.ApnsCredential = nil
	}

	// BaiduCredential
	if source.BaiduCredential != nil {
		var baiduCredential BaiduCredential
		err := baiduCredential.AssignProperties_From_BaiduCredential(source.BaiduCredential)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_BaiduCredential() to populate field BaiduCredential")
		}
		credentials.BaiduCredential = &baiduCredential
	} else {
		credentials.BaiduCredential = nil
	}

	// BrowserCredential
	if source.BrowserCredential != nil {
		var browserCredential BrowserCredential
		err := browserCredential.AssignProperties_From_BrowserCredential(source.BrowserCredential)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_BrowserCredential() to populate field BrowserCredential")
		}
		credentials.BrowserCredential = &browserCredential
	} else {
		credentials.BrowserCredential = nil
	}

	// GcmCredential
	if source.GcmCredential != nil {
		var gcmCredential GcmCredential
		err := gcmCredential.AssignProperties_From_GcmCredential(source.GcmCredential)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_GcmCredential() to populate field GcmCredential")
		}
		credentials.GcmCredential = &gcmCredential
	} else {
		credentials.GcmCredential = nil
	}

	// MpnsCredential
	if source.MpnsCredential != nil {
		var mpnsCredential MpnsCredential
		err := mpnsCredential.AssignProperties_From_MpnsCredential(source.MpnsCredential)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_MpnsCredential() to populate field MpnsCredential")
		}
		credentials.MpnsCredential = &mpnsCredential
	} else {
		credentials.MpnsCredential = nil
	}

	// WnsCredential
	if source.WnsCredential != nil {
		var wnsCredential WnsCredential
		err := wnsCredential.AssignProperties_From_WnsCredential(source.WnsCredential)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_WnsCredential() to populate field WnsCredential")
		}
		credentials.WnsCredential = &wnsCredential
	} else {
		credentials.WnsCredential = nil
	}

	// XiaomiCredential
	if source.XiaomiCredential != nil {
		var xiaomiCredential XiaomiCredential
		err := xiaomiCredential.AssignProperties_From_XiaomiCredential(source.XiaomiCredential)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_XiaomiCredential() to populate field XiaomiCredential")
		}
		credentials.XiaomiCredential = &xiaomiCredential
	} else {
		credentials.XiaomiCredential = nil
	}

	// No error
	return nil
}

// AssignProperties_To_PnsCredentials populates the provided destination PnsCredentials from our PnsCredentials
func (credentials *PnsCredentials) AssignProperties_To_PnsCredentials(destination *storage.PnsCredentials) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdmCredential
	if credentials.AdmCredential != nil {
		var admCredential storage.AdmCredential
		err := credentials.AdmCredential.AssignProperties_To_AdmCredential(&admCredential)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AdmCredential() to populate field AdmCredential")
		}
		destination.AdmCredential = &admCredential
	} else {
		destination.AdmCredential = nil
	}

	// ApnsCredential
	if credentials.ApnsCredential != nil {
		var apnsCredential storage.ApnsCredential
		err := credentials.ApnsCredential.AssignProperties_To_ApnsCredential(&apnsCredential)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ApnsCredential() to populate field ApnsCredential")
		}
		destination.ApnsCredential = &apnsCredential
	} else {
		destination.ApnsCredential = nil
	}

	// BaiduCredential
	if credentials.BaiduCredential != nil {
		var baiduCredential storage.BaiduCredential
		err := credentials.BaiduCredential.AssignProperties_To_BaiduCredential(&baiduCredential)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_BaiduCredential() to populate field BaiduCredential")
		}
		destination.BaiduCredential = &baiduCredential
	} else {
		destination.BaiduCredential = nil
	}

	// BrowserCredential
	if credentials.BrowserCredential != nil {
		var browserCredential storage.BrowserCredential
		err := credentials.BrowserCredential.AssignProperties_To_BrowserCredential(&browserCredential)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_BrowserCredential() to populate field BrowserCredential")
		}
		destination.BrowserCredential = &browserCredential
	} else {
		destination.BrowserCredential = nil
	}

	// GcmCredential
	if credentials.GcmCredential != nil {
		var gcmCredential storage.GcmCredential
		err := credentials.GcmCredential.AssignProperties_To_GcmCredential(&gcmCredential)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_GcmCredential() to populate field GcmCredential")
		}
		destination.GcmCredential = &gcmCredential
	} else {
		destination.GcmCredential = nil
	}

	// MpnsCredential
	if credentials.MpnsCredential != nil {
		var mpnsCredential storage.MpnsCredential
		err := credentials.MpnsCredential.AssignProperties_To_MpnsCredential(&mpnsCredential)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_MpnsCredential() to populate field MpnsCredential")
		}
		destination.MpnsCredential = &mpnsCredential
	} else {
		destination.MpnsCredential = nil
	}

	// WnsCredential
	if credentials.WnsCredential != nil {
		var wnsCredential storage.WnsCredential
		err := credentials.WnsCredential.AssignProperties_To_WnsCredential(&wnsCredential)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_WnsCredential() to populate field WnsCredential")
		}
		destination.WnsCredential = &wnsCredential
	} else {
		destination.WnsCredential = nil
	}

	// XiaomiCredential
	if credentials.XiaomiCredential != nil {
		var xiaomiCredential storage.XiaomiCredential
		err := credentials.XiaomiCredential.AssignProperties_To_XiaomiCredential(&xiaomiCredential)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_XiaomiCredential() to populate field XiaomiCredential")
		}
		destination.XiaomiCredential = &xiaomiCredential
	} else {
		destination.XiaomiCredential = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_PnsCredentials_STATUS populates our PnsCredentials from the provided source PnsCredentials_STATUS
func (credentials *PnsCredentials) Initialize_From_PnsCredentials_STATUS(source *PnsCredentials_STATUS) error {

	// AdmCredential
	if source.AdmCredential != nil {
		var admCredential AdmCredential
		err := admCredential.Initialize_From_AdmCredential_STATUS(source.AdmCredential)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_AdmCredential_STATUS() to populate field AdmCredential")
		}
		credentials.AdmCredential = &admCredential
	} else {
		credentials.AdmCredential = nil
	}

	// ApnsCredential
	if source.ApnsCredential != nil {
		var apnsCredential ApnsCredential
		err := apnsCredential.Initialize_From_ApnsCredential_STATUS(source.ApnsCredential)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ApnsCredential_STATUS() to populate field ApnsCredential")
		}
		credentials.ApnsCredential = &apnsCredential
	} else {
		credentials.ApnsCredential = nil
	}

	// BaiduCredential
	if source.BaiduCredential != nil {
		var baiduCredential BaiduCredential
		err := baiduCredential.Initialize_From_BaiduCredential_STATUS(source.BaiduCredential)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_BaiduCredential_STATUS() to populate field BaiduCredential")
		}
		credentials.BaiduCredential = &baiduCredential
	} else {
		credentials.BaiduCredential = nil
	}

	// BrowserCredential
	if source.BrowserCredential != nil {
		var browserCredential BrowserCredential
		err := browserCredential.Initialize_From_BrowserCredential_STATUS(source.BrowserCredential)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_BrowserCredential_STATUS() to populate field BrowserCredential")
		}
		credentials.BrowserCredential = &browserCredential
	} else {
		credentials.BrowserCredential = nil
	}

	// GcmCredential
	if source.GcmCredential != nil {
		var gcmCredential GcmCredential
		err := gcmCredential.Initialize_From_GcmCredential_STATUS(source.GcmCredential)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_GcmCredential_STATUS() to populate field GcmCredential")
		}
		credentials.GcmCredential = &gcmCredential
	} else {
		credentials.GcmCredential = nil
	}

	// MpnsCredential
	if source.MpnsCredential != nil {
		var mpnsCredential MpnsCredential
		err := mpnsCredential.Initialize_From_MpnsCredential_STATUS(source.MpnsCredential)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_MpnsCredential_STATUS() to populate field MpnsCredential")
		}
		credentials.MpnsCredential = &mpnsCredential
	} else {
		credentials.MpnsCredential = nil
	}

	// WnsCredential
	if source.WnsCredential != nil {
		var wnsCredential WnsCredential
		err := wnsCredential.Initialize_From_WnsCredential_STATUS(source.WnsCredential)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_WnsCredential_STATUS() to populate field WnsCredential")
		}
		credentials.WnsCredential = &wnsCredential
	} else {
		credentials.WnsCredential = nil
	}

	// XiaomiCredential
	if source.XiaomiCredential != nil {
		var xiaomiCredential XiaomiCredential
		err := xiaomiCredential.Initialize_From_XiaomiCredential_STATUS(source.XiaomiCredential)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_XiaomiCredential_STATUS() to populate field XiaomiCredential")
		}
		credentials.XiaomiCredential = &xiaomiCredential
	} else {
		credentials.XiaomiCredential = nil
	}

	// No error
	return nil
}

// Collection of Notification Hub or Notification Hub Namespace PNS credentials.
type PnsCredentials_STATUS struct {
	// AdmCredential: Description of a NotificationHub AdmCredential.
	AdmCredential *AdmCredential_STATUS `json:"admCredential,omitempty"`

	// ApnsCredential: Description of a NotificationHub ApnsCredential.
	ApnsCredential *ApnsCredential_STATUS `json:"apnsCredential,omitempty"`

	// BaiduCredential: Description of a NotificationHub BaiduCredential.
	BaiduCredential *BaiduCredential_STATUS `json:"baiduCredential,omitempty"`

	// BrowserCredential: Description of a NotificationHub BrowserCredential.
	BrowserCredential *BrowserCredential_STATUS `json:"browserCredential,omitempty"`

	// GcmCredential: Description of a NotificationHub GcmCredential.
	GcmCredential *GcmCredential_STATUS `json:"gcmCredential,omitempty"`

	// MpnsCredential: Description of a NotificationHub MpnsCredential.
	MpnsCredential *MpnsCredential_STATUS `json:"mpnsCredential,omitempty"`

	// WnsCredential: Description of a NotificationHub WnsCredential.
	WnsCredential *WnsCredential_STATUS `json:"wnsCredential,omitempty"`

	// XiaomiCredential: Description of a NotificationHub XiaomiCredential.
	XiaomiCredential *XiaomiCredential_STATUS `json:"xiaomiCredential,omitempty"`
}

var _ genruntime.FromARMConverter = &PnsCredentials_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (credentials *PnsCredentials_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PnsCredentials_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (credentials *PnsCredentials_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PnsCredentials_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PnsCredentials_STATUS, got %T", armInput)
	}

	// Set property "AdmCredential":
	if typedInput.AdmCredential != nil {
		var admCredential1 AdmCredential_STATUS
		err := admCredential1.PopulateFromARM(owner, *typedInput.AdmCredential)
		if err != nil {
			return err
		}
		admCredential := admCredential1
		credentials.AdmCredential = &admCredential
	}

	// Set property "ApnsCredential":
	if typedInput.ApnsCredential != nil {
		var apnsCredential1 ApnsCredential_STATUS
		err := apnsCredential1.PopulateFromARM(owner, *typedInput.ApnsCredential)
		if err != nil {
			return err
		}
		apnsCredential := apnsCredential1
		credentials.ApnsCredential = &apnsCredential
	}

	// Set property "BaiduCredential":
	if typedInput.BaiduCredential != nil {
		var baiduCredential1 BaiduCredential_STATUS
		err := baiduCredential1.PopulateFromARM(owner, *typedInput.BaiduCredential)
		if err != nil {
			return err
		}
		baiduCredential := baiduCredential1
		credentials.BaiduCredential = &baiduCredential
	}

	// Set property "BrowserCredential":
	if typedInput.BrowserCredential != nil {
		var browserCredential1 BrowserCredential_STATUS
		err := browserCredential1.PopulateFromARM(owner, *typedInput.BrowserCredential)
		if err != nil {
			return err
		}
		browserCredential := browserCredential1
		credentials.BrowserCredential = &browserCredential
	}

	// Set property "GcmCredential":
	if typedInput.GcmCredential != nil {
		var gcmCredential1 GcmCredential_STATUS
		err := gcmCredential1.PopulateFromARM(owner, *typedInput.GcmCredential)
		if err != nil {
			return err
		}
		gcmCredential := gcmCredential1
		credentials.GcmCredential = &gcmCredential
	}

	// Set property "MpnsCredential":
	if typedInput.MpnsCredential != nil {
		var mpnsCredential1 MpnsCredential_STATUS
		err := mpnsCredential1.PopulateFromARM(owner, *typedInput.MpnsCredential)
		if err != nil {
			return err
		}
		mpnsCredential := mpnsCredential1
		credentials.MpnsCredential = &mpnsCredential
	}

	// Set property "WnsCredential":
	if typedInput.WnsCredential != nil {
		var wnsCredential1 WnsCredential_STATUS
		err := wnsCredential1.PopulateFromARM(owner, *typedInput.WnsCredential)
		if err != nil {
			return err
		}
		wnsCredential := wnsCredential1
		credentials.WnsCredential = &wnsCredential
	}

	// Set property "XiaomiCredential":
	if typedInput.XiaomiCredential != nil {
		var xiaomiCredential1 XiaomiCredential_STATUS
		err := xiaomiCredential1.PopulateFromARM(owner, *typedInput.XiaomiCredential)
		if err != nil {
			return err
		}
		xiaomiCredential := xiaomiCredential1
		credentials.XiaomiCredential = &xiaomiCredential
	}

	// No error
	return nil
}

// AssignProperties_From_PnsCredentials_STATUS populates our PnsCredentials_STATUS from the provided source PnsCredentials_STATUS
func (credentials *PnsCredentials_STATUS) AssignProperties_From_PnsCredentials_STATUS(source *storage.PnsCredentials_STATUS) error {

	// AdmCredential
	if source.AdmCredential != nil {
		var admCredential AdmCredential_STATUS
		err := admCredential.AssignProperties_From_AdmCredential_STATUS(source.AdmCredential)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AdmCredential_STATUS() to populate field AdmCredential")
		}
		credentials.AdmCredential = &admCredential
	} else {
		credentials.AdmCredential = nil
	}

	// ApnsCredential
	if source.ApnsCredential != nil {
		var apnsCredential ApnsCredential_STATUS
		err := apnsCredential.AssignProperties_From_ApnsCredential_STATUS(source.ApnsCredential)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ApnsCredential_STATUS() to populate field ApnsCredential")
		}
		credentials.ApnsCredential = &apnsCredential
	} else {
		credentials.ApnsCredential = nil
	}

	// BaiduCredential
	if source.BaiduCredential != nil {
		var baiduCredential BaiduCredential_STATUS
		err := baiduCredential.AssignProperties_From_BaiduCredential_STATUS(source.BaiduCredential)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_BaiduCredential_STATUS() to populate field BaiduCredential")
		}
		credentials.BaiduCredential = &baiduCredential
	} else {
		credentials.BaiduCredential = nil
	}

	// BrowserCredential
	if source.BrowserCredential != nil {
		var browserCredential BrowserCredential_STATUS
		err := browserCredential.AssignProperties_From_BrowserCredential_STATUS(source.BrowserCredential)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_BrowserCredential_STATUS() to populate field BrowserCredential")
		}
		credentials.BrowserCredential = &browserCredential
	} else {
		credentials.BrowserCredential = nil
	}

	// GcmCredential
	if source.GcmCredential != nil {
		var gcmCredential GcmCredential_STATUS
		err := gcmCredential.AssignProperties_From_GcmCredential_STATUS(source.GcmCredential)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_GcmCredential_STATUS() to populate field GcmCredential")
		}
		credentials.GcmCredential = &gcmCredential
	} else {
		credentials.GcmCredential = nil
	}

	// MpnsCredential
	if source.MpnsCredential != nil {
		var mpnsCredential MpnsCredential_STATUS
		err := mpnsCredential.AssignProperties_From_MpnsCredential_STATUS(source.MpnsCredential)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_MpnsCredential_STATUS() to populate field MpnsCredential")
		}
		credentials.MpnsCredential = &mpnsCredential
	} else {
		credentials.MpnsCredential = nil
	}

	// WnsCredential
	if source.WnsCredential != nil {
		var wnsCredential WnsCredential_STATUS
		err := wnsCredential.AssignProperties_From_WnsCredential_STATUS(source.WnsCredential)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_WnsCredential_STATUS() to populate field WnsCredential")
		}
		credentials.WnsCredential = &wnsCredential
	} else {
		credentials.WnsCredential = nil
	}

	// XiaomiCredential
	if source.XiaomiCredential != nil {
		var xiaomiCredential XiaomiCredential_STATUS
		err := xiaomiCredential.AssignProperties_From_XiaomiCredential_STATUS(source.XiaomiCredential)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_XiaomiCredential_STATUS() to populate field XiaomiCredential")
		}
		credentials.XiaomiCredential = &xiaomiCredential
	} else {
		credentials.XiaomiCredential = nil
	}

	// No error
	return nil
}

// AssignProperties_To_PnsCredentials_STATUS populates the provided destination PnsCredentials_STATUS from our PnsCredentials_STATUS
func (credentials *PnsCredentials_STATUS) AssignProperties_To_PnsCredentials_STATUS(destination *storage.PnsCredentials_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdmCredential
	if credentials.AdmCredential != nil {
		var admCredential storage.AdmCredential_STATUS
		err := credentials.AdmCredential.AssignProperties_To_AdmCredential_STATUS(&admCredential)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AdmCredential_STATUS() to populate field AdmCredential")
		}
		destination.AdmCredential = &admCredential
	} else {
		destination.AdmCredential = nil
	}

	// ApnsCredential
	if credentials.ApnsCredential != nil {
		var apnsCredential storage.ApnsCredential_STATUS
		err := credentials.ApnsCredential.AssignProperties_To_ApnsCredential_STATUS(&apnsCredential)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ApnsCredential_STATUS() to populate field ApnsCredential")
		}
		destination.ApnsCredential = &apnsCredential
	} else {
		destination.ApnsCredential = nil
	}

	// BaiduCredential
	if credentials.BaiduCredential != nil {
		var baiduCredential storage.BaiduCredential_STATUS
		err := credentials.BaiduCredential.AssignProperties_To_BaiduCredential_STATUS(&baiduCredential)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_BaiduCredential_STATUS() to populate field BaiduCredential")
		}
		destination.BaiduCredential = &baiduCredential
	} else {
		destination.BaiduCredential = nil
	}

	// BrowserCredential
	if credentials.BrowserCredential != nil {
		var browserCredential storage.BrowserCredential_STATUS
		err := credentials.BrowserCredential.AssignProperties_To_BrowserCredential_STATUS(&browserCredential)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_BrowserCredential_STATUS() to populate field BrowserCredential")
		}
		destination.BrowserCredential = &browserCredential
	} else {
		destination.BrowserCredential = nil
	}

	// GcmCredential
	if credentials.GcmCredential != nil {
		var gcmCredential storage.GcmCredential_STATUS
		err := credentials.GcmCredential.AssignProperties_To_GcmCredential_STATUS(&gcmCredential)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_GcmCredential_STATUS() to populate field GcmCredential")
		}
		destination.GcmCredential = &gcmCredential
	} else {
		destination.GcmCredential = nil
	}

	// MpnsCredential
	if credentials.MpnsCredential != nil {
		var mpnsCredential storage.MpnsCredential_STATUS
		err := credentials.MpnsCredential.AssignProperties_To_MpnsCredential_STATUS(&mpnsCredential)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_MpnsCredential_STATUS() to populate field MpnsCredential")
		}
		destination.MpnsCredential = &mpnsCredential
	} else {
		destination.MpnsCredential = nil
	}

	// WnsCredential
	if credentials.WnsCredential != nil {
		var wnsCredential storage.WnsCredential_STATUS
		err := credentials.WnsCredential.AssignProperties_To_WnsCredential_STATUS(&wnsCredential)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_WnsCredential_STATUS() to populate field WnsCredential")
		}
		destination.WnsCredential = &wnsCredential
	} else {
		destination.WnsCredential = nil
	}

	// XiaomiCredential
	if credentials.XiaomiCredential != nil {
		var xiaomiCredential storage.XiaomiCredential_STATUS
		err := credentials.XiaomiCredential.AssignProperties_To_XiaomiCredential_STATUS(&xiaomiCredential)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_XiaomiCredential_STATUS() to populate field XiaomiCredential")
		}
		destination.XiaomiCredential = &xiaomiCredential
	} else {
		destination.XiaomiCredential = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Represents a Private Endpoint Connection ARM resource - a sub-resource of Notification Hubs namespace.
type PrivateEndpointConnectionResource_STATUS struct {
	// Id: Fully qualified resource ID for the resource. E.g.
	// "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}"
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &PrivateEndpointConnectionResource_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resource *PrivateEndpointConnectionResource_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PrivateEndpointConnectionResource_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resource *PrivateEndpointConnectionResource_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PrivateEndpointConnectionResource_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PrivateEndpointConnectionResource_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		resource.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_PrivateEndpointConnectionResource_STATUS populates our PrivateEndpointConnectionResource_STATUS from the provided source PrivateEndpointConnectionResource_STATUS
func (resource *PrivateEndpointConnectionResource_STATUS) AssignProperties_From_PrivateEndpointConnectionResource_STATUS(source *storage.PrivateEndpointConnectionResource_STATUS) error {

	// Id
	resource.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_PrivateEndpointConnectionResource_STATUS populates the provided destination PrivateEndpointConnectionResource_STATUS from our PrivateEndpointConnectionResource_STATUS
func (resource *PrivateEndpointConnectionResource_STATUS) AssignProperties_To_PrivateEndpointConnectionResource_STATUS(destination *storage.PrivateEndpointConnectionResource_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(resource.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Type of public network access.
// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type PublicNetworkAccess string

const (
	PublicNetworkAccess_Disabled = PublicNetworkAccess("Disabled")
	PublicNetworkAccess_Enabled  = PublicNetworkAccess("Enabled")
)

// Mapping from string to PublicNetworkAccess
var publicNetworkAccess_Values = map[string]PublicNetworkAccess{
	"disabled": PublicNetworkAccess_Disabled,
	"enabled":  PublicNetworkAccess_Enabled,
}

// Type of public network access.
type PublicNetworkAccess_STATUS string

const (
	PublicNetworkAccess_STATUS_Disabled = PublicNetworkAccess_STATUS("Disabled")
	PublicNetworkAccess_STATUS_Enabled  = PublicNetworkAccess_STATUS("Enabled")
)

// Mapping from string to PublicNetworkAccess_STATUS
var publicNetworkAccess_STATUS_Values = map[string]PublicNetworkAccess_STATUS{
	"disabled": PublicNetworkAccess_STATUS_Disabled,
	"enabled":  PublicNetworkAccess_STATUS_Enabled,
}

// Allowed replication region
// +kubebuilder:validation:Enum={"AustraliaEast","BrazilSouth","Default","None","NorthEurope","SouthAfricaNorth","SouthEastAsia","WestUs2"}
type ReplicationRegion string

const (
	ReplicationRegion_AustraliaEast    = ReplicationRegion("AustraliaEast")
	ReplicationRegion_BrazilSouth      = ReplicationRegion("BrazilSouth")
	ReplicationRegion_Default          = ReplicationRegion("Default")
	ReplicationRegion_None             = ReplicationRegion("None")
	ReplicationRegion_NorthEurope      = ReplicationRegion("NorthEurope")
	ReplicationRegion_SouthAfricaNorth = ReplicationRegion("SouthAfricaNorth")
	ReplicationRegion_SouthEastAsia    = ReplicationRegion("SouthEastAsia")
	ReplicationRegion_WestUs2          = ReplicationRegion("WestUs2")
)

// Mapping from string to ReplicationRegion
var replicationRegion_Values = map[string]ReplicationRegion{
	"australiaeast":    ReplicationRegion_AustraliaEast,
	"brazilsouth":      ReplicationRegion_BrazilSouth,
	"default":          ReplicationRegion_Default,
	"none":             ReplicationRegion_None,
	"northeurope":      ReplicationRegion_NorthEurope,
	"southafricanorth": ReplicationRegion_SouthAfricaNorth,
	"southeastasia":    ReplicationRegion_SouthEastAsia,
	"westus2":          ReplicationRegion_WestUs2,
}

// Allowed replication region
type ReplicationRegion_STATUS string

const (
	ReplicationRegion_STATUS_AustraliaEast    = ReplicationRegion_STATUS("AustraliaEast")
	ReplicationRegion_STATUS_BrazilSouth      = ReplicationRegion_STATUS("BrazilSouth")
	ReplicationRegion_STATUS_Default          = ReplicationRegion_STATUS("Default")
	ReplicationRegion_STATUS_None             = ReplicationRegion_STATUS("None")
	ReplicationRegion_STATUS_NorthEurope      = ReplicationRegion_STATUS("NorthEurope")
	ReplicationRegion_STATUS_SouthAfricaNorth = ReplicationRegion_STATUS("SouthAfricaNorth")
	ReplicationRegion_STATUS_SouthEastAsia    = ReplicationRegion_STATUS("SouthEastAsia")
	ReplicationRegion_STATUS_WestUs2          = ReplicationRegion_STATUS("WestUs2")
)

// Mapping from string to ReplicationRegion_STATUS
var replicationRegion_STATUS_Values = map[string]ReplicationRegion_STATUS{
	"australiaeast":    ReplicationRegion_STATUS_AustraliaEast,
	"brazilsouth":      ReplicationRegion_STATUS_BrazilSouth,
	"default":          ReplicationRegion_STATUS_Default,
	"none":             ReplicationRegion_STATUS_None,
	"northeurope":      ReplicationRegion_STATUS_NorthEurope,
	"southafricanorth": ReplicationRegion_STATUS_SouthAfricaNorth,
	"southeastasia":    ReplicationRegion_STATUS_SouthEastAsia,
	"westus2":          ReplicationRegion_STATUS_WestUs2,
}

// Namespace SKU name.
// +kubebuilder:validation:Enum={"Basic","Free","Standard"}
type SkuName string

const (
	SkuName_Basic    = SkuName("Basic")
	SkuName_Free     = SkuName("Free")
	SkuName_Standard = SkuName("Standard")
)

// Mapping from string to SkuName
var skuName_Values = map[string]SkuName{
	"basic":    SkuName_Basic,
	"free":     SkuName_Free,
	"standard": SkuName_Standard,
}

// Namespace SKU name.
type SkuName_STATUS string

const (
	SkuName_STATUS_Basic    = SkuName_STATUS("Basic")
	SkuName_STATUS_Free     = SkuName_STATUS("Free")
	SkuName_STATUS_Standard = SkuName_STATUS("Standard")
)

// Mapping from string to SkuName_STATUS
var skuName_STATUS_Values = map[string]SkuName_STATUS{
	"basic":    SkuName_STATUS_Basic,
	"free":     SkuName_STATUS_Free,
	"standard": SkuName_STATUS_Standard,
}

type SystemData_CreatedByType_STATUS string

const (
	SystemData_CreatedByType_STATUS_Application     = SystemData_CreatedByType_STATUS("Application")
	SystemData_CreatedByType_STATUS_Key             = SystemData_CreatedByType_STATUS("Key")
	SystemData_CreatedByType_STATUS_ManagedIdentity = SystemData_CreatedByType_STATUS("ManagedIdentity")
	SystemData_CreatedByType_STATUS_User            = SystemData_CreatedByType_STATUS("User")
)

// Mapping from string to SystemData_CreatedByType_STATUS
var systemData_CreatedByType_STATUS_Values = map[string]SystemData_CreatedByType_STATUS{
	"application":     SystemData_CreatedByType_STATUS_Application,
	"key":             SystemData_CreatedByType_STATUS_Key,
	"managedidentity": SystemData_CreatedByType_STATUS_ManagedIdentity,
	"user":            SystemData_CreatedByType_STATUS_User,
}

type SystemData_LastModifiedByType_STATUS string

const (
	SystemData_LastModifiedByType_STATUS_Application     = SystemData_LastModifiedByType_STATUS("Application")
	SystemData_LastModifiedByType_STATUS_Key             = SystemData_LastModifiedByType_STATUS("Key")
	SystemData_LastModifiedByType_STATUS_ManagedIdentity = SystemData_LastModifiedByType_STATUS("ManagedIdentity")
	SystemData_LastModifiedByType_STATUS_User            = SystemData_LastModifiedByType_STATUS("User")
)

// Mapping from string to SystemData_LastModifiedByType_STATUS
var systemData_LastModifiedByType_STATUS_Values = map[string]SystemData_LastModifiedByType_STATUS{
	"application":     SystemData_LastModifiedByType_STATUS_Application,
	"key":             SystemData_LastModifiedByType_STATUS_Key,
	"managedidentity": SystemData_LastModifiedByType_STATUS_ManagedIdentity,
	"user":            SystemData_LastModifiedByType_STATUS_User,
}

// Namespace SKU name.
// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type ZoneRedundancyPreference string

const (
	ZoneRedundancyPreference_Disabled = ZoneRedundancyPreference("Disabled")
	ZoneRedundancyPreference_Enabled  = ZoneRedundancyPreference("Enabled")
)

// Mapping from string to ZoneRedundancyPreference
var zoneRedundancyPreference_Values = map[string]ZoneRedundancyPreference{
	"disabled": ZoneRedundancyPreference_Disabled,
	"enabled":  ZoneRedundancyPreference_Enabled,
}

// Namespace SKU name.
type ZoneRedundancyPreference_STATUS string

const (
	ZoneRedundancyPreference_STATUS_Disabled = ZoneRedundancyPreference_STATUS("Disabled")
	ZoneRedundancyPreference_STATUS_Enabled  = ZoneRedundancyPreference_STATUS("Enabled")
)

// Mapping from string to ZoneRedundancyPreference_STATUS
var zoneRedundancyPreference_STATUS_Values = map[string]ZoneRedundancyPreference_STATUS{
	"disabled": ZoneRedundancyPreference_STATUS_Disabled,
	"enabled":  ZoneRedundancyPreference_STATUS_Enabled,
}

// A network authorization rule that filters traffic based on IP address.
type IpRule struct {
	// +kubebuilder:validation:Required
	// +kubebuilder:validation:MinLength=1
	// IpMask: IP mask.
	IpMask *string `json:"ipMask,omitempty"`

	// +kubebuilder:validation:Required
	// Rights: List of access rights.
	Rights []AccessRights `json:"rights,omitempty"`
}

var _ genruntime.ARMTransformer = &IpRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *IpRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &arm.IpRule{}

	// Set property "IpMask":
	if rule.IpMask != nil {
		ipMask := *rule.IpMask
		result.IpMask = &ipMask
	}

	// Set property "Rights":
	for _, item := range rule.Rights {
		var temp string
		temp = string(item)
		result.Rights = append(result.Rights, arm.AccessRights(temp))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *IpRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.IpRule{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *IpRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.IpRule)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.IpRule, got %T", armInput)
	}

	// Set property "IpMask":
	if typedInput.IpMask != nil {
		ipMask := *typedInput.IpMask
		rule.IpMask = &ipMask
	}

	// Set property "Rights":
	for _, item := range typedInput.Rights {
		var temp string
		temp = string(item)
		rule.Rights = append(rule.Rights, AccessRights(temp))
	}

	// No error
	return nil
}

// AssignProperties_From_IpRule populates our IpRule from the provided source IpRule
func (rule *IpRule) AssignProperties_From_IpRule(source *storage.IpRule) error {

	// IpMask
	rule.IpMask = genruntime.ClonePointerToString(source.IpMask)

	// Rights
	if source.Rights != nil {
		rightList := make([]AccessRights, len(source.Rights))
		for rightIndex, rightItem := range source.Rights {
			// Shadow the loop variable to avoid aliasing
			rightItem := rightItem
			rightList[rightIndex] = genruntime.ToEnum(rightItem, accessRights_Values)
		}
		rule.Rights = rightList
	} else {
		rule.Rights = nil
	}

	// No error
	return nil
}

// AssignProperties_To_IpRule populates the provided destination IpRule from our IpRule
func (rule *IpRule) AssignProperties_To_IpRule(destination *storage.IpRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IpMask
	destination.IpMask = genruntime.ClonePointerToString(rule.IpMask)

	// Rights
	if rule.Rights != nil {
		rightList := make([]string, len(rule.Rights))
		for rightIndex, rightItem := range rule.Rights {
			// Shadow the loop variable to avoid aliasing
			rightItem := rightItem
			rightList[rightIndex] = string(rightItem)
		}
		destination.Rights = rightList
	} else {
		destination.Rights = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_IpRule_STATUS populates our IpRule from the provided source IpRule_STATUS
func (rule *IpRule) Initialize_From_IpRule_STATUS(source *IpRule_STATUS) error {

	// IpMask
	rule.IpMask = genruntime.ClonePointerToString(source.IpMask)

	// Rights
	if source.Rights != nil {
		rightList := make([]AccessRights, len(source.Rights))
		for rightIndex, rightItem := range source.Rights {
			// Shadow the loop variable to avoid aliasing
			rightItem := rightItem
			right := genruntime.ToEnum(string(rightItem), accessRights_Values)
			rightList[rightIndex] = right
		}
		rule.Rights = rightList
	} else {
		rule.Rights = nil
	}

	// No error
	return nil
}

// A network authorization rule that filters traffic based on IP address.
type IpRule_STATUS struct {
	// IpMask: IP mask.
	IpMask *string `json:"ipMask,omitempty"`

	// Rights: List of access rights.
	Rights []AccessRights_STATUS `json:"rights,omitempty"`
}

var _ genruntime.FromARMConverter = &IpRule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *IpRule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.IpRule_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *IpRule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.IpRule_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.IpRule_STATUS, got %T", armInput)
	}

	// Set property "IpMask":
	if typedInput.IpMask != nil {
		ipMask := *typedInput.IpMask
		rule.IpMask = &ipMask
	}

	// Set property "Rights":
	for _, item := range typedInput.Rights {
		var temp string
		temp = string(item)
		rule.Rights = append(rule.Rights, AccessRights_STATUS(temp))
	}

	// No error
	return nil
}

// AssignProperties_From_IpRule_STATUS populates our IpRule_STATUS from the provided source IpRule_STATUS
func (rule *IpRule_STATUS) AssignProperties_From_IpRule_STATUS(source *storage.IpRule_STATUS) error {

	// IpMask
	rule.IpMask = genruntime.ClonePointerToString(source.IpMask)

	// Rights
	if source.Rights != nil {
		rightList := make([]AccessRights_STATUS, len(source.Rights))
		for rightIndex, rightItem := range source.Rights {
			// Shadow the loop variable to avoid aliasing
			rightItem := rightItem
			rightList[rightIndex] = genruntime.ToEnum(rightItem, accessRights_STATUS_Values)
		}
		rule.Rights = rightList
	} else {
		rule.Rights = nil
	}

	// No error
	return nil
}

// AssignProperties_To_IpRule_STATUS populates the provided destination IpRule_STATUS from our IpRule_STATUS
func (rule *IpRule_STATUS) AssignProperties_To_IpRule_STATUS(destination *storage.IpRule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IpMask
	destination.IpMask = genruntime.ClonePointerToString(rule.IpMask)

	// Rights
	if rule.Rights != nil {
		rightList := make([]string, len(rule.Rights))
		for rightIndex, rightItem := range rule.Rights {
			// Shadow the loop variable to avoid aliasing
			rightItem := rightItem
			rightList[rightIndex] = string(rightItem)
		}
		destination.Rights = rightList
	} else {
		destination.Rights = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// A default (public Internet) network authorization rule, which contains rights if no other network rule matches.
type PublicInternetAuthorizationRule struct {
	// +kubebuilder:validation:Required
	// Rights: List of access rights.
	Rights []AccessRights `json:"rights,omitempty"`
}

var _ genruntime.ARMTransformer = &PublicInternetAuthorizationRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *PublicInternetAuthorizationRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &arm.PublicInternetAuthorizationRule{}

	// Set property "Rights":
	for _, item := range rule.Rights {
		var temp string
		temp = string(item)
		result.Rights = append(result.Rights, arm.AccessRights(temp))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *PublicInternetAuthorizationRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PublicInternetAuthorizationRule{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *PublicInternetAuthorizationRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PublicInternetAuthorizationRule)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PublicInternetAuthorizationRule, got %T", armInput)
	}

	// Set property "Rights":
	for _, item := range typedInput.Rights {
		var temp string
		temp = string(item)
		rule.Rights = append(rule.Rights, AccessRights(temp))
	}

	// No error
	return nil
}

// AssignProperties_From_PublicInternetAuthorizationRule populates our PublicInternetAuthorizationRule from the provided source PublicInternetAuthorizationRule
func (rule *PublicInternetAuthorizationRule) AssignProperties_From_PublicInternetAuthorizationRule(source *storage.PublicInternetAuthorizationRule) error {

	// Rights
	if source.Rights != nil {
		rightList := make([]AccessRights, len(source.Rights))
		for rightIndex, rightItem := range source.Rights {
			// Shadow the loop variable to avoid aliasing
			rightItem := rightItem
			rightList[rightIndex] = genruntime.ToEnum(rightItem, accessRights_Values)
		}
		rule.Rights = rightList
	} else {
		rule.Rights = nil
	}

	// No error
	return nil
}

// AssignProperties_To_PublicInternetAuthorizationRule populates the provided destination PublicInternetAuthorizationRule from our PublicInternetAuthorizationRule
func (rule *PublicInternetAuthorizationRule) AssignProperties_To_PublicInternetAuthorizationRule(destination *storage.PublicInternetAuthorizationRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Rights
	if rule.Rights != nil {
		rightList := make([]string, len(rule.Rights))
		for rightIndex, rightItem := range rule.Rights {
			// Shadow the loop variable to avoid aliasing
			rightItem := rightItem
			rightList[rightIndex] = string(rightItem)
		}
		destination.Rights = rightList
	} else {
		destination.Rights = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_PublicInternetAuthorizationRule_STATUS populates our PublicInternetAuthorizationRule from the provided source PublicInternetAuthorizationRule_STATUS
func (rule *PublicInternetAuthorizationRule) Initialize_From_PublicInternetAuthorizationRule_STATUS(source *PublicInternetAuthorizationRule_STATUS) error {

	// Rights
	if source.Rights != nil {
		rightList := make([]AccessRights, len(source.Rights))
		for rightIndex, rightItem := range source.Rights {
			// Shadow the loop variable to avoid aliasing
			rightItem := rightItem
			right := genruntime.ToEnum(string(rightItem), accessRights_Values)
			rightList[rightIndex] = right
		}
		rule.Rights = rightList
	} else {
		rule.Rights = nil
	}

	// No error
	return nil
}

// A default (public Internet) network authorization rule, which contains rights if no other network rule matches.
type PublicInternetAuthorizationRule_STATUS struct {
	// Rights: List of access rights.
	Rights []AccessRights_STATUS `json:"rights,omitempty"`
}

var _ genruntime.FromARMConverter = &PublicInternetAuthorizationRule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *PublicInternetAuthorizationRule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PublicInternetAuthorizationRule_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *PublicInternetAuthorizationRule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PublicInternetAuthorizationRule_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PublicInternetAuthorizationRule_STATUS, got %T", armInput)
	}

	// Set property "Rights":
	for _, item := range typedInput.Rights {
		var temp string
		temp = string(item)
		rule.Rights = append(rule.Rights, AccessRights_STATUS(temp))
	}

	// No error
	return nil
}

// AssignProperties_From_PublicInternetAuthorizationRule_STATUS populates our PublicInternetAuthorizationRule_STATUS from the provided source PublicInternetAuthorizationRule_STATUS
func (rule *PublicInternetAuthorizationRule_STATUS) AssignProperties_From_PublicInternetAuthorizationRule_STATUS(source *storage.PublicInternetAuthorizationRule_STATUS) error {

	// Rights
	if source.Rights != nil {
		rightList := make([]AccessRights_STATUS, len(source.Rights))
		for rightIndex, rightItem := range source.Rights {
			// Shadow the loop variable to avoid aliasing
			rightItem := rightItem
			rightList[rightIndex] = genruntime.ToEnum(rightItem, accessRights_STATUS_Values)
		}
		rule.Rights = rightList
	} else {
		rule.Rights = nil
	}

	// No error
	return nil
}

// AssignProperties_To_PublicInternetAuthorizationRule_STATUS populates the provided destination PublicInternetAuthorizationRule_STATUS from our PublicInternetAuthorizationRule_STATUS
func (rule *PublicInternetAuthorizationRule_STATUS) AssignProperties_To_PublicInternetAuthorizationRule_STATUS(destination *storage.PublicInternetAuthorizationRule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Rights
	if rule.Rights != nil {
		rightList := make([]string, len(rule.Rights))
		for rightIndex, rightItem := range rule.Rights {
			// Shadow the loop variable to avoid aliasing
			rightItem := rightItem
			rightList[rightIndex] = string(rightItem)
		}
		destination.Rights = rightList
	} else {
		destination.Rights = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&Namespace{}, &NamespaceList{})
}
