// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package storage

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_IpRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpRule, IpRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpRule runs a test to see if a specific instance of IpRule round trips to JSON and back losslessly
func RunJSONSerializationTestForIpRule(subject IpRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpRule instances for property testing - lazily instantiated by IpRuleGenerator()
var ipRuleGenerator gopter.Gen

// IpRuleGenerator returns a generator of IpRule instances for property testing.
func IpRuleGenerator() gopter.Gen {
	if ipRuleGenerator != nil {
		return ipRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpRule(generators)
	ipRuleGenerator = gen.Struct(reflect.TypeOf(IpRule{}), generators)

	return ipRuleGenerator
}

// AddIndependentPropertyGeneratorsForIpRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpRule(gens map[string]gopter.Gen) {
	gens["IpMask"] = gen.PtrOf(gen.AlphaString())
	gens["Rights"] = gen.SliceOf(gen.AlphaString())
}

func Test_IpRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpRule_STATUS, IpRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpRule_STATUS runs a test to see if a specific instance of IpRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForIpRule_STATUS(subject IpRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpRule_STATUS instances for property testing - lazily instantiated by IpRule_STATUSGenerator()
var ipRule_STATUSGenerator gopter.Gen

// IpRule_STATUSGenerator returns a generator of IpRule_STATUS instances for property testing.
func IpRule_STATUSGenerator() gopter.Gen {
	if ipRule_STATUSGenerator != nil {
		return ipRule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpRule_STATUS(generators)
	ipRule_STATUSGenerator = gen.Struct(reflect.TypeOf(IpRule_STATUS{}), generators)

	return ipRule_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForIpRule_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpRule_STATUS(gens map[string]gopter.Gen) {
	gens["IpMask"] = gen.PtrOf(gen.AlphaString())
	gens["Rights"] = gen.SliceOf(gen.AlphaString())
}

func Test_Namespace_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Namespace via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNamespace, NamespaceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNamespace runs a test to see if a specific instance of Namespace round trips to JSON and back losslessly
func RunJSONSerializationTestForNamespace(subject Namespace) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Namespace
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Namespace instances for property testing - lazily instantiated by NamespaceGenerator()
var namespaceGenerator gopter.Gen

// NamespaceGenerator returns a generator of Namespace instances for property testing.
func NamespaceGenerator() gopter.Gen {
	if namespaceGenerator != nil {
		return namespaceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForNamespace(generators)
	namespaceGenerator = gen.Struct(reflect.TypeOf(Namespace{}), generators)

	return namespaceGenerator
}

// AddRelatedPropertyGeneratorsForNamespace is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNamespace(gens map[string]gopter.Gen) {
	gens["Spec"] = Namespace_SpecGenerator()
	gens["Status"] = Namespace_STATUSGenerator()
}

func Test_NamespaceOperatorConfigMaps_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NamespaceOperatorConfigMaps via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNamespaceOperatorConfigMaps, NamespaceOperatorConfigMapsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNamespaceOperatorConfigMaps runs a test to see if a specific instance of NamespaceOperatorConfigMaps round trips to JSON and back losslessly
func RunJSONSerializationTestForNamespaceOperatorConfigMaps(subject NamespaceOperatorConfigMaps) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NamespaceOperatorConfigMaps
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NamespaceOperatorConfigMaps instances for property testing - lazily instantiated by
// NamespaceOperatorConfigMapsGenerator()
var namespaceOperatorConfigMapsGenerator gopter.Gen

// NamespaceOperatorConfigMapsGenerator returns a generator of NamespaceOperatorConfigMaps instances for property testing.
func NamespaceOperatorConfigMapsGenerator() gopter.Gen {
	if namespaceOperatorConfigMapsGenerator != nil {
		return namespaceOperatorConfigMapsGenerator
	}

	generators := make(map[string]gopter.Gen)
	namespaceOperatorConfigMapsGenerator = gen.Struct(reflect.TypeOf(NamespaceOperatorConfigMaps{}), generators)

	return namespaceOperatorConfigMapsGenerator
}

func Test_NamespaceOperatorSecrets_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NamespaceOperatorSecrets via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNamespaceOperatorSecrets, NamespaceOperatorSecretsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNamespaceOperatorSecrets runs a test to see if a specific instance of NamespaceOperatorSecrets round trips to JSON and back losslessly
func RunJSONSerializationTestForNamespaceOperatorSecrets(subject NamespaceOperatorSecrets) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NamespaceOperatorSecrets
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NamespaceOperatorSecrets instances for property testing - lazily instantiated by
// NamespaceOperatorSecretsGenerator()
var namespaceOperatorSecretsGenerator gopter.Gen

// NamespaceOperatorSecretsGenerator returns a generator of NamespaceOperatorSecrets instances for property testing.
func NamespaceOperatorSecretsGenerator() gopter.Gen {
	if namespaceOperatorSecretsGenerator != nil {
		return namespaceOperatorSecretsGenerator
	}

	generators := make(map[string]gopter.Gen)
	namespaceOperatorSecretsGenerator = gen.Struct(reflect.TypeOf(NamespaceOperatorSecrets{}), generators)

	return namespaceOperatorSecretsGenerator
}

func Test_NamespaceOperatorSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NamespaceOperatorSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNamespaceOperatorSpec, NamespaceOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNamespaceOperatorSpec runs a test to see if a specific instance of NamespaceOperatorSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForNamespaceOperatorSpec(subject NamespaceOperatorSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NamespaceOperatorSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NamespaceOperatorSpec instances for property testing - lazily instantiated by
// NamespaceOperatorSpecGenerator()
var namespaceOperatorSpecGenerator gopter.Gen

// NamespaceOperatorSpecGenerator returns a generator of NamespaceOperatorSpec instances for property testing.
func NamespaceOperatorSpecGenerator() gopter.Gen {
	if namespaceOperatorSpecGenerator != nil {
		return namespaceOperatorSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForNamespaceOperatorSpec(generators)
	namespaceOperatorSpecGenerator = gen.Struct(reflect.TypeOf(NamespaceOperatorSpec{}), generators)

	return namespaceOperatorSpecGenerator
}

// AddRelatedPropertyGeneratorsForNamespaceOperatorSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNamespaceOperatorSpec(gens map[string]gopter.Gen) {
	gens["ConfigMaps"] = gen.PtrOf(NamespaceOperatorConfigMapsGenerator())
	gens["Secrets"] = gen.PtrOf(NamespaceOperatorSecretsGenerator())
}

func Test_NamespaceProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NamespaceProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNamespaceProperties, NamespacePropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNamespaceProperties runs a test to see if a specific instance of NamespaceProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForNamespaceProperties(subject NamespaceProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NamespaceProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NamespaceProperties instances for property testing - lazily instantiated by
// NamespacePropertiesGenerator()
var namespacePropertiesGenerator gopter.Gen

// NamespacePropertiesGenerator returns a generator of NamespaceProperties instances for property testing.
// We first initialize namespacePropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NamespacePropertiesGenerator() gopter.Gen {
	if namespacePropertiesGenerator != nil {
		return namespacePropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNamespaceProperties(generators)
	namespacePropertiesGenerator = gen.Struct(reflect.TypeOf(NamespaceProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNamespaceProperties(generators)
	AddRelatedPropertyGeneratorsForNamespaceProperties(generators)
	namespacePropertiesGenerator = gen.Struct(reflect.TypeOf(NamespaceProperties{}), generators)

	return namespacePropertiesGenerator
}

// AddIndependentPropertyGeneratorsForNamespaceProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNamespaceProperties(gens map[string]gopter.Gen) {
	gens["DataCenter"] = gen.PtrOf(gen.AlphaString())
	gens["NamespaceType"] = gen.PtrOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.AlphaString())
	gens["ReplicationRegion"] = gen.PtrOf(gen.AlphaString())
	gens["ScaleUnit"] = gen.PtrOf(gen.AlphaString())
	gens["ZoneRedundancy"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNamespaceProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNamespaceProperties(gens map[string]gopter.Gen) {
	gens["NetworkAcls"] = gen.PtrOf(NetworkAclsGenerator())
	gens["PnsCredentials"] = gen.PtrOf(PnsCredentialsGenerator())
}

func Test_NamespaceProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NamespaceProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNamespaceProperties_STATUS, NamespaceProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNamespaceProperties_STATUS runs a test to see if a specific instance of NamespaceProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForNamespaceProperties_STATUS(subject NamespaceProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NamespaceProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NamespaceProperties_STATUS instances for property testing - lazily instantiated by
// NamespaceProperties_STATUSGenerator()
var namespaceProperties_STATUSGenerator gopter.Gen

// NamespaceProperties_STATUSGenerator returns a generator of NamespaceProperties_STATUS instances for property testing.
// We first initialize namespaceProperties_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NamespaceProperties_STATUSGenerator() gopter.Gen {
	if namespaceProperties_STATUSGenerator != nil {
		return namespaceProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNamespaceProperties_STATUS(generators)
	namespaceProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(NamespaceProperties_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNamespaceProperties_STATUS(generators)
	AddRelatedPropertyGeneratorsForNamespaceProperties_STATUS(generators)
	namespaceProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(NamespaceProperties_STATUS{}), generators)

	return namespaceProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForNamespaceProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNamespaceProperties_STATUS(gens map[string]gopter.Gen) {
	gens["CreatedAt"] = gen.PtrOf(gen.AlphaString())
	gens["Critical"] = gen.PtrOf(gen.Bool())
	gens["DataCenter"] = gen.PtrOf(gen.AlphaString())
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["MetricId"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["NamespaceType"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.AlphaString())
	gens["Region"] = gen.PtrOf(gen.AlphaString())
	gens["ReplicationRegion"] = gen.PtrOf(gen.AlphaString())
	gens["ScaleUnit"] = gen.PtrOf(gen.AlphaString())
	gens["ServiceBusEndpoint"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.AlphaString())
	gens["SubscriptionId"] = gen.PtrOf(gen.AlphaString())
	gens["UpdatedAt"] = gen.PtrOf(gen.AlphaString())
	gens["ZoneRedundancy"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNamespaceProperties_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNamespaceProperties_STATUS(gens map[string]gopter.Gen) {
	gens["NetworkAcls"] = gen.PtrOf(NetworkAcls_STATUSGenerator())
	gens["PnsCredentials"] = gen.PtrOf(PnsCredentials_STATUSGenerator())
	gens["PrivateEndpointConnections"] = gen.SliceOf(PrivateEndpointConnectionResource_STATUSGenerator())
}

func Test_Namespace_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Namespace_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNamespace_STATUS, Namespace_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNamespace_STATUS runs a test to see if a specific instance of Namespace_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForNamespace_STATUS(subject Namespace_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Namespace_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Namespace_STATUS instances for property testing - lazily instantiated by Namespace_STATUSGenerator()
var namespace_STATUSGenerator gopter.Gen

// Namespace_STATUSGenerator returns a generator of Namespace_STATUS instances for property testing.
// We first initialize namespace_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Namespace_STATUSGenerator() gopter.Gen {
	if namespace_STATUSGenerator != nil {
		return namespace_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNamespace_STATUS(generators)
	namespace_STATUSGenerator = gen.Struct(reflect.TypeOf(Namespace_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNamespace_STATUS(generators)
	AddRelatedPropertyGeneratorsForNamespace_STATUS(generators)
	namespace_STATUSGenerator = gen.Struct(reflect.TypeOf(Namespace_STATUS{}), generators)

	return namespace_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForNamespace_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNamespace_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNamespace_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNamespace_STATUS(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(NamespaceProperties_STATUSGenerator())
	gens["Sku"] = gen.PtrOf(Sku_STATUSGenerator())
	gens["SystemData"] = gen.PtrOf(SystemData_STATUSGenerator())
}

func Test_Namespace_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Namespace_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNamespace_Spec, Namespace_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNamespace_Spec runs a test to see if a specific instance of Namespace_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForNamespace_Spec(subject Namespace_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Namespace_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Namespace_Spec instances for property testing - lazily instantiated by Namespace_SpecGenerator()
var namespace_SpecGenerator gopter.Gen

// Namespace_SpecGenerator returns a generator of Namespace_Spec instances for property testing.
// We first initialize namespace_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Namespace_SpecGenerator() gopter.Gen {
	if namespace_SpecGenerator != nil {
		return namespace_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNamespace_Spec(generators)
	namespace_SpecGenerator = gen.Struct(reflect.TypeOf(Namespace_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNamespace_Spec(generators)
	AddRelatedPropertyGeneratorsForNamespace_Spec(generators)
	namespace_SpecGenerator = gen.Struct(reflect.TypeOf(Namespace_Spec{}), generators)

	return namespace_SpecGenerator
}

// AddIndependentPropertyGeneratorsForNamespace_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNamespace_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["OriginalVersion"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNamespace_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNamespace_Spec(gens map[string]gopter.Gen) {
	gens["OperatorSpec"] = gen.PtrOf(NamespaceOperatorSpecGenerator())
	gens["Properties"] = gen.PtrOf(NamespacePropertiesGenerator())
	gens["Sku"] = gen.PtrOf(SkuGenerator())
}

func Test_NetworkAcls_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkAcls via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkAcls, NetworkAclsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkAcls runs a test to see if a specific instance of NetworkAcls round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkAcls(subject NetworkAcls) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkAcls
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkAcls instances for property testing - lazily instantiated by NetworkAclsGenerator()
var networkAclsGenerator gopter.Gen

// NetworkAclsGenerator returns a generator of NetworkAcls instances for property testing.
func NetworkAclsGenerator() gopter.Gen {
	if networkAclsGenerator != nil {
		return networkAclsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForNetworkAcls(generators)
	networkAclsGenerator = gen.Struct(reflect.TypeOf(NetworkAcls{}), generators)

	return networkAclsGenerator
}

// AddRelatedPropertyGeneratorsForNetworkAcls is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkAcls(gens map[string]gopter.Gen) {
	gens["IpRules"] = gen.SliceOf(IpRuleGenerator())
	gens["PublicNetworkRule"] = gen.PtrOf(PublicInternetAuthorizationRuleGenerator())
}

func Test_NetworkAcls_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkAcls_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkAcls_STATUS, NetworkAcls_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkAcls_STATUS runs a test to see if a specific instance of NetworkAcls_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkAcls_STATUS(subject NetworkAcls_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkAcls_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkAcls_STATUS instances for property testing - lazily instantiated by NetworkAcls_STATUSGenerator()
var networkAcls_STATUSGenerator gopter.Gen

// NetworkAcls_STATUSGenerator returns a generator of NetworkAcls_STATUS instances for property testing.
func NetworkAcls_STATUSGenerator() gopter.Gen {
	if networkAcls_STATUSGenerator != nil {
		return networkAcls_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForNetworkAcls_STATUS(generators)
	networkAcls_STATUSGenerator = gen.Struct(reflect.TypeOf(NetworkAcls_STATUS{}), generators)

	return networkAcls_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForNetworkAcls_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkAcls_STATUS(gens map[string]gopter.Gen) {
	gens["IpRules"] = gen.SliceOf(IpRule_STATUSGenerator())
	gens["PublicNetworkRule"] = gen.PtrOf(PublicInternetAuthorizationRule_STATUSGenerator())
}

func Test_PnsCredentials_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PnsCredentials via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPnsCredentials, PnsCredentialsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPnsCredentials runs a test to see if a specific instance of PnsCredentials round trips to JSON and back losslessly
func RunJSONSerializationTestForPnsCredentials(subject PnsCredentials) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PnsCredentials
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PnsCredentials instances for property testing - lazily instantiated by PnsCredentialsGenerator()
var pnsCredentialsGenerator gopter.Gen

// PnsCredentialsGenerator returns a generator of PnsCredentials instances for property testing.
func PnsCredentialsGenerator() gopter.Gen {
	if pnsCredentialsGenerator != nil {
		return pnsCredentialsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForPnsCredentials(generators)
	pnsCredentialsGenerator = gen.Struct(reflect.TypeOf(PnsCredentials{}), generators)

	return pnsCredentialsGenerator
}

// AddRelatedPropertyGeneratorsForPnsCredentials is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPnsCredentials(gens map[string]gopter.Gen) {
	gens["AdmCredential"] = gen.PtrOf(AdmCredentialGenerator())
	gens["ApnsCredential"] = gen.PtrOf(ApnsCredentialGenerator())
	gens["BaiduCredential"] = gen.PtrOf(BaiduCredentialGenerator())
	gens["BrowserCredential"] = gen.PtrOf(BrowserCredentialGenerator())
	gens["GcmCredential"] = gen.PtrOf(GcmCredentialGenerator())
	gens["MpnsCredential"] = gen.PtrOf(MpnsCredentialGenerator())
	gens["WnsCredential"] = gen.PtrOf(WnsCredentialGenerator())
	gens["XiaomiCredential"] = gen.PtrOf(XiaomiCredentialGenerator())
}

func Test_PnsCredentials_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PnsCredentials_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPnsCredentials_STATUS, PnsCredentials_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPnsCredentials_STATUS runs a test to see if a specific instance of PnsCredentials_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPnsCredentials_STATUS(subject PnsCredentials_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PnsCredentials_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PnsCredentials_STATUS instances for property testing - lazily instantiated by
// PnsCredentials_STATUSGenerator()
var pnsCredentials_STATUSGenerator gopter.Gen

// PnsCredentials_STATUSGenerator returns a generator of PnsCredentials_STATUS instances for property testing.
func PnsCredentials_STATUSGenerator() gopter.Gen {
	if pnsCredentials_STATUSGenerator != nil {
		return pnsCredentials_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForPnsCredentials_STATUS(generators)
	pnsCredentials_STATUSGenerator = gen.Struct(reflect.TypeOf(PnsCredentials_STATUS{}), generators)

	return pnsCredentials_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForPnsCredentials_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPnsCredentials_STATUS(gens map[string]gopter.Gen) {
	gens["AdmCredential"] = gen.PtrOf(AdmCredential_STATUSGenerator())
	gens["ApnsCredential"] = gen.PtrOf(ApnsCredential_STATUSGenerator())
	gens["BaiduCredential"] = gen.PtrOf(BaiduCredential_STATUSGenerator())
	gens["BrowserCredential"] = gen.PtrOf(BrowserCredential_STATUSGenerator())
	gens["GcmCredential"] = gen.PtrOf(GcmCredential_STATUSGenerator())
	gens["MpnsCredential"] = gen.PtrOf(MpnsCredential_STATUSGenerator())
	gens["WnsCredential"] = gen.PtrOf(WnsCredential_STATUSGenerator())
	gens["XiaomiCredential"] = gen.PtrOf(XiaomiCredential_STATUSGenerator())
}

func Test_PrivateEndpointConnectionResource_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointConnectionResource_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointConnectionResource_STATUS, PrivateEndpointConnectionResource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointConnectionResource_STATUS runs a test to see if a specific instance of PrivateEndpointConnectionResource_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointConnectionResource_STATUS(subject PrivateEndpointConnectionResource_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointConnectionResource_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointConnectionResource_STATUS instances for property testing - lazily instantiated by
// PrivateEndpointConnectionResource_STATUSGenerator()
var privateEndpointConnectionResource_STATUSGenerator gopter.Gen

// PrivateEndpointConnectionResource_STATUSGenerator returns a generator of PrivateEndpointConnectionResource_STATUS instances for property testing.
func PrivateEndpointConnectionResource_STATUSGenerator() gopter.Gen {
	if privateEndpointConnectionResource_STATUSGenerator != nil {
		return privateEndpointConnectionResource_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnectionResource_STATUS(generators)
	privateEndpointConnectionResource_STATUSGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnectionResource_STATUS{}), generators)

	return privateEndpointConnectionResource_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointConnectionResource_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointConnectionResource_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_PublicInternetAuthorizationRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicInternetAuthorizationRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicInternetAuthorizationRule, PublicInternetAuthorizationRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicInternetAuthorizationRule runs a test to see if a specific instance of PublicInternetAuthorizationRule round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicInternetAuthorizationRule(subject PublicInternetAuthorizationRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicInternetAuthorizationRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicInternetAuthorizationRule instances for property testing - lazily instantiated by
// PublicInternetAuthorizationRuleGenerator()
var publicInternetAuthorizationRuleGenerator gopter.Gen

// PublicInternetAuthorizationRuleGenerator returns a generator of PublicInternetAuthorizationRule instances for property testing.
func PublicInternetAuthorizationRuleGenerator() gopter.Gen {
	if publicInternetAuthorizationRuleGenerator != nil {
		return publicInternetAuthorizationRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicInternetAuthorizationRule(generators)
	publicInternetAuthorizationRuleGenerator = gen.Struct(reflect.TypeOf(PublicInternetAuthorizationRule{}), generators)

	return publicInternetAuthorizationRuleGenerator
}

// AddIndependentPropertyGeneratorsForPublicInternetAuthorizationRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicInternetAuthorizationRule(gens map[string]gopter.Gen) {
	gens["Rights"] = gen.SliceOf(gen.AlphaString())
}

func Test_PublicInternetAuthorizationRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicInternetAuthorizationRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicInternetAuthorizationRule_STATUS, PublicInternetAuthorizationRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicInternetAuthorizationRule_STATUS runs a test to see if a specific instance of PublicInternetAuthorizationRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicInternetAuthorizationRule_STATUS(subject PublicInternetAuthorizationRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicInternetAuthorizationRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicInternetAuthorizationRule_STATUS instances for property testing - lazily instantiated by
// PublicInternetAuthorizationRule_STATUSGenerator()
var publicInternetAuthorizationRule_STATUSGenerator gopter.Gen

// PublicInternetAuthorizationRule_STATUSGenerator returns a generator of PublicInternetAuthorizationRule_STATUS instances for property testing.
func PublicInternetAuthorizationRule_STATUSGenerator() gopter.Gen {
	if publicInternetAuthorizationRule_STATUSGenerator != nil {
		return publicInternetAuthorizationRule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicInternetAuthorizationRule_STATUS(generators)
	publicInternetAuthorizationRule_STATUSGenerator = gen.Struct(reflect.TypeOf(PublicInternetAuthorizationRule_STATUS{}), generators)

	return publicInternetAuthorizationRule_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForPublicInternetAuthorizationRule_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicInternetAuthorizationRule_STATUS(gens map[string]gopter.Gen) {
	gens["Rights"] = gen.SliceOf(gen.AlphaString())
}

func Test_Sku_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sku via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSku, SkuGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSku runs a test to see if a specific instance of Sku round trips to JSON and back losslessly
func RunJSONSerializationTestForSku(subject Sku) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sku
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sku instances for property testing - lazily instantiated by SkuGenerator()
var skuGenerator gopter.Gen

// SkuGenerator returns a generator of Sku instances for property testing.
func SkuGenerator() gopter.Gen {
	if skuGenerator != nil {
		return skuGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSku(generators)
	skuGenerator = gen.Struct(reflect.TypeOf(Sku{}), generators)

	return skuGenerator
}

// AddIndependentPropertyGeneratorsForSku is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSku(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Family"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Size"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
}

func Test_Sku_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sku_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSku_STATUS, Sku_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSku_STATUS runs a test to see if a specific instance of Sku_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSku_STATUS(subject Sku_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sku_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sku_STATUS instances for property testing - lazily instantiated by Sku_STATUSGenerator()
var sku_STATUSGenerator gopter.Gen

// Sku_STATUSGenerator returns a generator of Sku_STATUS instances for property testing.
func Sku_STATUSGenerator() gopter.Gen {
	if sku_STATUSGenerator != nil {
		return sku_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSku_STATUS(generators)
	sku_STATUSGenerator = gen.Struct(reflect.TypeOf(Sku_STATUS{}), generators)

	return sku_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSku_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSku_STATUS(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Family"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Size"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
}

func Test_SystemData_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SystemData_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSystemData_STATUS, SystemData_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSystemData_STATUS runs a test to see if a specific instance of SystemData_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSystemData_STATUS(subject SystemData_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SystemData_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SystemData_STATUS instances for property testing - lazily instantiated by SystemData_STATUSGenerator()
var systemData_STATUSGenerator gopter.Gen

// SystemData_STATUSGenerator returns a generator of SystemData_STATUS instances for property testing.
func SystemData_STATUSGenerator() gopter.Gen {
	if systemData_STATUSGenerator != nil {
		return systemData_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSystemData_STATUS(generators)
	systemData_STATUSGenerator = gen.Struct(reflect.TypeOf(SystemData_STATUS{}), generators)

	return systemData_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSystemData_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSystemData_STATUS(gens map[string]gopter.Gen) {
	gens["CreatedAt"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedBy"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedByType"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedAt"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedBy"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedByType"] = gen.PtrOf(gen.AlphaString())
}
