// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20230901

import (
	"encoding/json"
	storage "github.com/Azure/azure-service-operator/v2/api/notificationhubs/v1api20230901/storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_IpRule_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IpRule to IpRule via AssignProperties_To_IpRule & AssignProperties_From_IpRule returns original",
		prop.ForAll(RunPropertyAssignmentTestForIpRule, IpRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIpRule tests if a specific instance of IpRule can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForIpRule(subject IpRule) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.IpRule
	err := copied.AssignProperties_To_IpRule(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IpRule
	err = actual.AssignProperties_From_IpRule(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IpRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpRule, IpRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpRule runs a test to see if a specific instance of IpRule round trips to JSON and back losslessly
func RunJSONSerializationTestForIpRule(subject IpRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpRule instances for property testing - lazily instantiated by IpRuleGenerator()
var ipRuleGenerator gopter.Gen

// IpRuleGenerator returns a generator of IpRule instances for property testing.
func IpRuleGenerator() gopter.Gen {
	if ipRuleGenerator != nil {
		return ipRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpRule(generators)
	ipRuleGenerator = gen.Struct(reflect.TypeOf(IpRule{}), generators)

	return ipRuleGenerator
}

// AddIndependentPropertyGeneratorsForIpRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpRule(gens map[string]gopter.Gen) {
	gens["IpMask"] = gen.PtrOf(gen.AlphaString())
	gens["Rights"] = gen.SliceOf(gen.OneConstOf(AccessRights_Listen, AccessRights_Manage, AccessRights_Send))
}

func Test_IpRule_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IpRule_STATUS to IpRule_STATUS via AssignProperties_To_IpRule_STATUS & AssignProperties_From_IpRule_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForIpRule_STATUS, IpRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIpRule_STATUS tests if a specific instance of IpRule_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForIpRule_STATUS(subject IpRule_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.IpRule_STATUS
	err := copied.AssignProperties_To_IpRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IpRule_STATUS
	err = actual.AssignProperties_From_IpRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IpRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpRule_STATUS, IpRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpRule_STATUS runs a test to see if a specific instance of IpRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForIpRule_STATUS(subject IpRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpRule_STATUS instances for property testing - lazily instantiated by IpRule_STATUSGenerator()
var ipRule_STATUSGenerator gopter.Gen

// IpRule_STATUSGenerator returns a generator of IpRule_STATUS instances for property testing.
func IpRule_STATUSGenerator() gopter.Gen {
	if ipRule_STATUSGenerator != nil {
		return ipRule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpRule_STATUS(generators)
	ipRule_STATUSGenerator = gen.Struct(reflect.TypeOf(IpRule_STATUS{}), generators)

	return ipRule_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForIpRule_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpRule_STATUS(gens map[string]gopter.Gen) {
	gens["IpMask"] = gen.PtrOf(gen.AlphaString())
	gens["Rights"] = gen.SliceOf(gen.OneConstOf(AccessRights_STATUS_Listen, AccessRights_STATUS_Manage, AccessRights_STATUS_Send))
}

func Test_Namespace_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	parameters.MinSuccessfulTests = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Namespace to hub returns original",
		prop.ForAll(RunResourceConversionTestForNamespace, NamespaceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForNamespace tests if a specific instance of Namespace round trips to the hub storage version and back losslessly
func RunResourceConversionTestForNamespace(subject Namespace) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub storage.Namespace
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual Namespace
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Namespace_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Namespace to Namespace via AssignProperties_To_Namespace & AssignProperties_From_Namespace returns original",
		prop.ForAll(RunPropertyAssignmentTestForNamespace, NamespaceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNamespace tests if a specific instance of Namespace can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForNamespace(subject Namespace) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.Namespace
	err := copied.AssignProperties_To_Namespace(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Namespace
	err = actual.AssignProperties_From_Namespace(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Namespace_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Namespace via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNamespace, NamespaceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNamespace runs a test to see if a specific instance of Namespace round trips to JSON and back losslessly
func RunJSONSerializationTestForNamespace(subject Namespace) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Namespace
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Namespace instances for property testing - lazily instantiated by NamespaceGenerator()
var namespaceGenerator gopter.Gen

// NamespaceGenerator returns a generator of Namespace instances for property testing.
func NamespaceGenerator() gopter.Gen {
	if namespaceGenerator != nil {
		return namespaceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForNamespace(generators)
	namespaceGenerator = gen.Struct(reflect.TypeOf(Namespace{}), generators)

	return namespaceGenerator
}

// AddRelatedPropertyGeneratorsForNamespace is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNamespace(gens map[string]gopter.Gen) {
	gens["Spec"] = Namespace_SpecGenerator()
	gens["Status"] = Namespace_STATUSGenerator()
}

func Test_NamespaceOperatorConfigMaps_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NamespaceOperatorConfigMaps to NamespaceOperatorConfigMaps via AssignProperties_To_NamespaceOperatorConfigMaps & AssignProperties_From_NamespaceOperatorConfigMaps returns original",
		prop.ForAll(RunPropertyAssignmentTestForNamespaceOperatorConfigMaps, NamespaceOperatorConfigMapsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNamespaceOperatorConfigMaps tests if a specific instance of NamespaceOperatorConfigMaps can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForNamespaceOperatorConfigMaps(subject NamespaceOperatorConfigMaps) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.NamespaceOperatorConfigMaps
	err := copied.AssignProperties_To_NamespaceOperatorConfigMaps(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NamespaceOperatorConfigMaps
	err = actual.AssignProperties_From_NamespaceOperatorConfigMaps(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NamespaceOperatorConfigMaps_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NamespaceOperatorConfigMaps via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNamespaceOperatorConfigMaps, NamespaceOperatorConfigMapsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNamespaceOperatorConfigMaps runs a test to see if a specific instance of NamespaceOperatorConfigMaps round trips to JSON and back losslessly
func RunJSONSerializationTestForNamespaceOperatorConfigMaps(subject NamespaceOperatorConfigMaps) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NamespaceOperatorConfigMaps
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NamespaceOperatorConfigMaps instances for property testing - lazily instantiated by
// NamespaceOperatorConfigMapsGenerator()
var namespaceOperatorConfigMapsGenerator gopter.Gen

// NamespaceOperatorConfigMapsGenerator returns a generator of NamespaceOperatorConfigMaps instances for property testing.
func NamespaceOperatorConfigMapsGenerator() gopter.Gen {
	if namespaceOperatorConfigMapsGenerator != nil {
		return namespaceOperatorConfigMapsGenerator
	}

	generators := make(map[string]gopter.Gen)
	namespaceOperatorConfigMapsGenerator = gen.Struct(reflect.TypeOf(NamespaceOperatorConfigMaps{}), generators)

	return namespaceOperatorConfigMapsGenerator
}

func Test_NamespaceOperatorSecrets_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NamespaceOperatorSecrets to NamespaceOperatorSecrets via AssignProperties_To_NamespaceOperatorSecrets & AssignProperties_From_NamespaceOperatorSecrets returns original",
		prop.ForAll(RunPropertyAssignmentTestForNamespaceOperatorSecrets, NamespaceOperatorSecretsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNamespaceOperatorSecrets tests if a specific instance of NamespaceOperatorSecrets can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForNamespaceOperatorSecrets(subject NamespaceOperatorSecrets) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.NamespaceOperatorSecrets
	err := copied.AssignProperties_To_NamespaceOperatorSecrets(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NamespaceOperatorSecrets
	err = actual.AssignProperties_From_NamespaceOperatorSecrets(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NamespaceOperatorSecrets_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NamespaceOperatorSecrets via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNamespaceOperatorSecrets, NamespaceOperatorSecretsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNamespaceOperatorSecrets runs a test to see if a specific instance of NamespaceOperatorSecrets round trips to JSON and back losslessly
func RunJSONSerializationTestForNamespaceOperatorSecrets(subject NamespaceOperatorSecrets) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NamespaceOperatorSecrets
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NamespaceOperatorSecrets instances for property testing - lazily instantiated by
// NamespaceOperatorSecretsGenerator()
var namespaceOperatorSecretsGenerator gopter.Gen

// NamespaceOperatorSecretsGenerator returns a generator of NamespaceOperatorSecrets instances for property testing.
func NamespaceOperatorSecretsGenerator() gopter.Gen {
	if namespaceOperatorSecretsGenerator != nil {
		return namespaceOperatorSecretsGenerator
	}

	generators := make(map[string]gopter.Gen)
	namespaceOperatorSecretsGenerator = gen.Struct(reflect.TypeOf(NamespaceOperatorSecrets{}), generators)

	return namespaceOperatorSecretsGenerator
}

func Test_NamespaceOperatorSpec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NamespaceOperatorSpec to NamespaceOperatorSpec via AssignProperties_To_NamespaceOperatorSpec & AssignProperties_From_NamespaceOperatorSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForNamespaceOperatorSpec, NamespaceOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNamespaceOperatorSpec tests if a specific instance of NamespaceOperatorSpec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForNamespaceOperatorSpec(subject NamespaceOperatorSpec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.NamespaceOperatorSpec
	err := copied.AssignProperties_To_NamespaceOperatorSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NamespaceOperatorSpec
	err = actual.AssignProperties_From_NamespaceOperatorSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NamespaceOperatorSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NamespaceOperatorSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNamespaceOperatorSpec, NamespaceOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNamespaceOperatorSpec runs a test to see if a specific instance of NamespaceOperatorSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForNamespaceOperatorSpec(subject NamespaceOperatorSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NamespaceOperatorSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NamespaceOperatorSpec instances for property testing - lazily instantiated by
// NamespaceOperatorSpecGenerator()
var namespaceOperatorSpecGenerator gopter.Gen

// NamespaceOperatorSpecGenerator returns a generator of NamespaceOperatorSpec instances for property testing.
func NamespaceOperatorSpecGenerator() gopter.Gen {
	if namespaceOperatorSpecGenerator != nil {
		return namespaceOperatorSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForNamespaceOperatorSpec(generators)
	namespaceOperatorSpecGenerator = gen.Struct(reflect.TypeOf(NamespaceOperatorSpec{}), generators)

	return namespaceOperatorSpecGenerator
}

// AddRelatedPropertyGeneratorsForNamespaceOperatorSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNamespaceOperatorSpec(gens map[string]gopter.Gen) {
	gens["ConfigMaps"] = gen.PtrOf(NamespaceOperatorConfigMapsGenerator())
	gens["Secrets"] = gen.PtrOf(NamespaceOperatorSecretsGenerator())
}

func Test_NamespaceProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NamespaceProperties to NamespaceProperties via AssignProperties_To_NamespaceProperties & AssignProperties_From_NamespaceProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForNamespaceProperties, NamespacePropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNamespaceProperties tests if a specific instance of NamespaceProperties can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForNamespaceProperties(subject NamespaceProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.NamespaceProperties
	err := copied.AssignProperties_To_NamespaceProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NamespaceProperties
	err = actual.AssignProperties_From_NamespaceProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NamespaceProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NamespaceProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNamespaceProperties, NamespacePropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNamespaceProperties runs a test to see if a specific instance of NamespaceProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForNamespaceProperties(subject NamespaceProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NamespaceProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NamespaceProperties instances for property testing - lazily instantiated by
// NamespacePropertiesGenerator()
var namespacePropertiesGenerator gopter.Gen

// NamespacePropertiesGenerator returns a generator of NamespaceProperties instances for property testing.
// We first initialize namespacePropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NamespacePropertiesGenerator() gopter.Gen {
	if namespacePropertiesGenerator != nil {
		return namespacePropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNamespaceProperties(generators)
	namespacePropertiesGenerator = gen.Struct(reflect.TypeOf(NamespaceProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNamespaceProperties(generators)
	AddRelatedPropertyGeneratorsForNamespaceProperties(generators)
	namespacePropertiesGenerator = gen.Struct(reflect.TypeOf(NamespaceProperties{}), generators)

	return namespacePropertiesGenerator
}

// AddIndependentPropertyGeneratorsForNamespaceProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNamespaceProperties(gens map[string]gopter.Gen) {
	gens["DataCenter"] = gen.PtrOf(gen.AlphaString())
	gens["NamespaceType"] = gen.PtrOf(gen.OneConstOf(NamespaceType_Messaging, NamespaceType_NotificationHub))
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(PublicNetworkAccess_Disabled, PublicNetworkAccess_Enabled))
	gens["ReplicationRegion"] = gen.PtrOf(gen.OneConstOf(
		ReplicationRegion_AustraliaEast,
		ReplicationRegion_BrazilSouth,
		ReplicationRegion_Default,
		ReplicationRegion_None,
		ReplicationRegion_NorthEurope,
		ReplicationRegion_SouthAfricaNorth,
		ReplicationRegion_SouthEastAsia,
		ReplicationRegion_WestUs2))
	gens["ScaleUnit"] = gen.PtrOf(gen.AlphaString())
	gens["ZoneRedundancy"] = gen.PtrOf(gen.OneConstOf(ZoneRedundancyPreference_Disabled, ZoneRedundancyPreference_Enabled))
}

// AddRelatedPropertyGeneratorsForNamespaceProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNamespaceProperties(gens map[string]gopter.Gen) {
	gens["NetworkAcls"] = gen.PtrOf(NetworkAclsGenerator())
	gens["PnsCredentials"] = gen.PtrOf(PnsCredentialsGenerator())
}

func Test_NamespaceProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NamespaceProperties_STATUS to NamespaceProperties_STATUS via AssignProperties_To_NamespaceProperties_STATUS & AssignProperties_From_NamespaceProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForNamespaceProperties_STATUS, NamespaceProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNamespaceProperties_STATUS tests if a specific instance of NamespaceProperties_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForNamespaceProperties_STATUS(subject NamespaceProperties_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.NamespaceProperties_STATUS
	err := copied.AssignProperties_To_NamespaceProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NamespaceProperties_STATUS
	err = actual.AssignProperties_From_NamespaceProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NamespaceProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NamespaceProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNamespaceProperties_STATUS, NamespaceProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNamespaceProperties_STATUS runs a test to see if a specific instance of NamespaceProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForNamespaceProperties_STATUS(subject NamespaceProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NamespaceProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NamespaceProperties_STATUS instances for property testing - lazily instantiated by
// NamespaceProperties_STATUSGenerator()
var namespaceProperties_STATUSGenerator gopter.Gen

// NamespaceProperties_STATUSGenerator returns a generator of NamespaceProperties_STATUS instances for property testing.
// We first initialize namespaceProperties_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NamespaceProperties_STATUSGenerator() gopter.Gen {
	if namespaceProperties_STATUSGenerator != nil {
		return namespaceProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNamespaceProperties_STATUS(generators)
	namespaceProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(NamespaceProperties_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNamespaceProperties_STATUS(generators)
	AddRelatedPropertyGeneratorsForNamespaceProperties_STATUS(generators)
	namespaceProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(NamespaceProperties_STATUS{}), generators)

	return namespaceProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForNamespaceProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNamespaceProperties_STATUS(gens map[string]gopter.Gen) {
	gens["CreatedAt"] = gen.PtrOf(gen.AlphaString())
	gens["Critical"] = gen.PtrOf(gen.Bool())
	gens["DataCenter"] = gen.PtrOf(gen.AlphaString())
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["MetricId"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["NamespaceType"] = gen.PtrOf(gen.OneConstOf(NamespaceType_STATUS_Messaging, NamespaceType_STATUS_NotificationHub))
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		OperationProvisioningState_STATUS_Canceled,
		OperationProvisioningState_STATUS_Disabled,
		OperationProvisioningState_STATUS_Failed,
		OperationProvisioningState_STATUS_InProgress,
		OperationProvisioningState_STATUS_Pending,
		OperationProvisioningState_STATUS_Succeeded,
		OperationProvisioningState_STATUS_Unknown))
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(PublicNetworkAccess_STATUS_Disabled, PublicNetworkAccess_STATUS_Enabled))
	gens["Region"] = gen.PtrOf(gen.AlphaString())
	gens["ReplicationRegion"] = gen.PtrOf(gen.OneConstOf(
		ReplicationRegion_STATUS_AustraliaEast,
		ReplicationRegion_STATUS_BrazilSouth,
		ReplicationRegion_STATUS_Default,
		ReplicationRegion_STATUS_None,
		ReplicationRegion_STATUS_NorthEurope,
		ReplicationRegion_STATUS_SouthAfricaNorth,
		ReplicationRegion_STATUS_SouthEastAsia,
		ReplicationRegion_STATUS_WestUs2))
	gens["ScaleUnit"] = gen.PtrOf(gen.AlphaString())
	gens["ServiceBusEndpoint"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(
		NamespaceStatus_STATUS_Created,
		NamespaceStatus_STATUS_Creating,
		NamespaceStatus_STATUS_Deleting,
		NamespaceStatus_STATUS_Suspended))
	gens["SubscriptionId"] = gen.PtrOf(gen.AlphaString())
	gens["UpdatedAt"] = gen.PtrOf(gen.AlphaString())
	gens["ZoneRedundancy"] = gen.PtrOf(gen.OneConstOf(ZoneRedundancyPreference_STATUS_Disabled, ZoneRedundancyPreference_STATUS_Enabled))
}

// AddRelatedPropertyGeneratorsForNamespaceProperties_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNamespaceProperties_STATUS(gens map[string]gopter.Gen) {
	gens["NetworkAcls"] = gen.PtrOf(NetworkAcls_STATUSGenerator())
	gens["PnsCredentials"] = gen.PtrOf(PnsCredentials_STATUSGenerator())
	gens["PrivateEndpointConnections"] = gen.SliceOf(PrivateEndpointConnectionResource_STATUSGenerator())
}

func Test_Namespace_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Namespace_STATUS to Namespace_STATUS via AssignProperties_To_Namespace_STATUS & AssignProperties_From_Namespace_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForNamespace_STATUS, Namespace_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNamespace_STATUS tests if a specific instance of Namespace_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForNamespace_STATUS(subject Namespace_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.Namespace_STATUS
	err := copied.AssignProperties_To_Namespace_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Namespace_STATUS
	err = actual.AssignProperties_From_Namespace_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Namespace_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Namespace_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNamespace_STATUS, Namespace_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNamespace_STATUS runs a test to see if a specific instance of Namespace_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForNamespace_STATUS(subject Namespace_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Namespace_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Namespace_STATUS instances for property testing - lazily instantiated by Namespace_STATUSGenerator()
var namespace_STATUSGenerator gopter.Gen

// Namespace_STATUSGenerator returns a generator of Namespace_STATUS instances for property testing.
// We first initialize namespace_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Namespace_STATUSGenerator() gopter.Gen {
	if namespace_STATUSGenerator != nil {
		return namespace_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNamespace_STATUS(generators)
	namespace_STATUSGenerator = gen.Struct(reflect.TypeOf(Namespace_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNamespace_STATUS(generators)
	AddRelatedPropertyGeneratorsForNamespace_STATUS(generators)
	namespace_STATUSGenerator = gen.Struct(reflect.TypeOf(Namespace_STATUS{}), generators)

	return namespace_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForNamespace_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNamespace_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNamespace_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNamespace_STATUS(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(NamespaceProperties_STATUSGenerator())
	gens["Sku"] = gen.PtrOf(Sku_STATUSGenerator())
	gens["SystemData"] = gen.PtrOf(SystemData_STATUSGenerator())
}

func Test_Namespace_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Namespace_Spec to Namespace_Spec via AssignProperties_To_Namespace_Spec & AssignProperties_From_Namespace_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForNamespace_Spec, Namespace_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNamespace_Spec tests if a specific instance of Namespace_Spec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForNamespace_Spec(subject Namespace_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.Namespace_Spec
	err := copied.AssignProperties_To_Namespace_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Namespace_Spec
	err = actual.AssignProperties_From_Namespace_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Namespace_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Namespace_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNamespace_Spec, Namespace_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNamespace_Spec runs a test to see if a specific instance of Namespace_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForNamespace_Spec(subject Namespace_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Namespace_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Namespace_Spec instances for property testing - lazily instantiated by Namespace_SpecGenerator()
var namespace_SpecGenerator gopter.Gen

// Namespace_SpecGenerator returns a generator of Namespace_Spec instances for property testing.
// We first initialize namespace_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Namespace_SpecGenerator() gopter.Gen {
	if namespace_SpecGenerator != nil {
		return namespace_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNamespace_Spec(generators)
	namespace_SpecGenerator = gen.Struct(reflect.TypeOf(Namespace_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNamespace_Spec(generators)
	AddRelatedPropertyGeneratorsForNamespace_Spec(generators)
	namespace_SpecGenerator = gen.Struct(reflect.TypeOf(Namespace_Spec{}), generators)

	return namespace_SpecGenerator
}

// AddIndependentPropertyGeneratorsForNamespace_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNamespace_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNamespace_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNamespace_Spec(gens map[string]gopter.Gen) {
	gens["OperatorSpec"] = gen.PtrOf(NamespaceOperatorSpecGenerator())
	gens["Properties"] = gen.PtrOf(NamespacePropertiesGenerator())
	gens["Sku"] = gen.PtrOf(SkuGenerator())
}

func Test_NetworkAcls_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NetworkAcls to NetworkAcls via AssignProperties_To_NetworkAcls & AssignProperties_From_NetworkAcls returns original",
		prop.ForAll(RunPropertyAssignmentTestForNetworkAcls, NetworkAclsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNetworkAcls tests if a specific instance of NetworkAcls can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForNetworkAcls(subject NetworkAcls) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.NetworkAcls
	err := copied.AssignProperties_To_NetworkAcls(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NetworkAcls
	err = actual.AssignProperties_From_NetworkAcls(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NetworkAcls_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkAcls via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkAcls, NetworkAclsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkAcls runs a test to see if a specific instance of NetworkAcls round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkAcls(subject NetworkAcls) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkAcls
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkAcls instances for property testing - lazily instantiated by NetworkAclsGenerator()
var networkAclsGenerator gopter.Gen

// NetworkAclsGenerator returns a generator of NetworkAcls instances for property testing.
func NetworkAclsGenerator() gopter.Gen {
	if networkAclsGenerator != nil {
		return networkAclsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForNetworkAcls(generators)
	networkAclsGenerator = gen.Struct(reflect.TypeOf(NetworkAcls{}), generators)

	return networkAclsGenerator
}

// AddRelatedPropertyGeneratorsForNetworkAcls is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkAcls(gens map[string]gopter.Gen) {
	gens["IpRules"] = gen.SliceOf(IpRuleGenerator())
	gens["PublicNetworkRule"] = gen.PtrOf(PublicInternetAuthorizationRuleGenerator())
}

func Test_NetworkAcls_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NetworkAcls_STATUS to NetworkAcls_STATUS via AssignProperties_To_NetworkAcls_STATUS & AssignProperties_From_NetworkAcls_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForNetworkAcls_STATUS, NetworkAcls_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNetworkAcls_STATUS tests if a specific instance of NetworkAcls_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForNetworkAcls_STATUS(subject NetworkAcls_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.NetworkAcls_STATUS
	err := copied.AssignProperties_To_NetworkAcls_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NetworkAcls_STATUS
	err = actual.AssignProperties_From_NetworkAcls_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NetworkAcls_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkAcls_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkAcls_STATUS, NetworkAcls_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkAcls_STATUS runs a test to see if a specific instance of NetworkAcls_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkAcls_STATUS(subject NetworkAcls_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkAcls_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkAcls_STATUS instances for property testing - lazily instantiated by NetworkAcls_STATUSGenerator()
var networkAcls_STATUSGenerator gopter.Gen

// NetworkAcls_STATUSGenerator returns a generator of NetworkAcls_STATUS instances for property testing.
func NetworkAcls_STATUSGenerator() gopter.Gen {
	if networkAcls_STATUSGenerator != nil {
		return networkAcls_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForNetworkAcls_STATUS(generators)
	networkAcls_STATUSGenerator = gen.Struct(reflect.TypeOf(NetworkAcls_STATUS{}), generators)

	return networkAcls_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForNetworkAcls_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkAcls_STATUS(gens map[string]gopter.Gen) {
	gens["IpRules"] = gen.SliceOf(IpRule_STATUSGenerator())
	gens["PublicNetworkRule"] = gen.PtrOf(PublicInternetAuthorizationRule_STATUSGenerator())
}

func Test_PnsCredentials_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PnsCredentials to PnsCredentials via AssignProperties_To_PnsCredentials & AssignProperties_From_PnsCredentials returns original",
		prop.ForAll(RunPropertyAssignmentTestForPnsCredentials, PnsCredentialsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPnsCredentials tests if a specific instance of PnsCredentials can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForPnsCredentials(subject PnsCredentials) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.PnsCredentials
	err := copied.AssignProperties_To_PnsCredentials(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PnsCredentials
	err = actual.AssignProperties_From_PnsCredentials(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PnsCredentials_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PnsCredentials via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPnsCredentials, PnsCredentialsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPnsCredentials runs a test to see if a specific instance of PnsCredentials round trips to JSON and back losslessly
func RunJSONSerializationTestForPnsCredentials(subject PnsCredentials) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PnsCredentials
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PnsCredentials instances for property testing - lazily instantiated by PnsCredentialsGenerator()
var pnsCredentialsGenerator gopter.Gen

// PnsCredentialsGenerator returns a generator of PnsCredentials instances for property testing.
func PnsCredentialsGenerator() gopter.Gen {
	if pnsCredentialsGenerator != nil {
		return pnsCredentialsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForPnsCredentials(generators)
	pnsCredentialsGenerator = gen.Struct(reflect.TypeOf(PnsCredentials{}), generators)

	return pnsCredentialsGenerator
}

// AddRelatedPropertyGeneratorsForPnsCredentials is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPnsCredentials(gens map[string]gopter.Gen) {
	gens["AdmCredential"] = gen.PtrOf(AdmCredentialGenerator())
	gens["ApnsCredential"] = gen.PtrOf(ApnsCredentialGenerator())
	gens["BaiduCredential"] = gen.PtrOf(BaiduCredentialGenerator())
	gens["BrowserCredential"] = gen.PtrOf(BrowserCredentialGenerator())
	gens["GcmCredential"] = gen.PtrOf(GcmCredentialGenerator())
	gens["MpnsCredential"] = gen.PtrOf(MpnsCredentialGenerator())
	gens["WnsCredential"] = gen.PtrOf(WnsCredentialGenerator())
	gens["XiaomiCredential"] = gen.PtrOf(XiaomiCredentialGenerator())
}

func Test_PnsCredentials_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PnsCredentials_STATUS to PnsCredentials_STATUS via AssignProperties_To_PnsCredentials_STATUS & AssignProperties_From_PnsCredentials_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForPnsCredentials_STATUS, PnsCredentials_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPnsCredentials_STATUS tests if a specific instance of PnsCredentials_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForPnsCredentials_STATUS(subject PnsCredentials_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.PnsCredentials_STATUS
	err := copied.AssignProperties_To_PnsCredentials_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PnsCredentials_STATUS
	err = actual.AssignProperties_From_PnsCredentials_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PnsCredentials_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PnsCredentials_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPnsCredentials_STATUS, PnsCredentials_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPnsCredentials_STATUS runs a test to see if a specific instance of PnsCredentials_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPnsCredentials_STATUS(subject PnsCredentials_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PnsCredentials_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PnsCredentials_STATUS instances for property testing - lazily instantiated by
// PnsCredentials_STATUSGenerator()
var pnsCredentials_STATUSGenerator gopter.Gen

// PnsCredentials_STATUSGenerator returns a generator of PnsCredentials_STATUS instances for property testing.
func PnsCredentials_STATUSGenerator() gopter.Gen {
	if pnsCredentials_STATUSGenerator != nil {
		return pnsCredentials_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForPnsCredentials_STATUS(generators)
	pnsCredentials_STATUSGenerator = gen.Struct(reflect.TypeOf(PnsCredentials_STATUS{}), generators)

	return pnsCredentials_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForPnsCredentials_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPnsCredentials_STATUS(gens map[string]gopter.Gen) {
	gens["AdmCredential"] = gen.PtrOf(AdmCredential_STATUSGenerator())
	gens["ApnsCredential"] = gen.PtrOf(ApnsCredential_STATUSGenerator())
	gens["BaiduCredential"] = gen.PtrOf(BaiduCredential_STATUSGenerator())
	gens["BrowserCredential"] = gen.PtrOf(BrowserCredential_STATUSGenerator())
	gens["GcmCredential"] = gen.PtrOf(GcmCredential_STATUSGenerator())
	gens["MpnsCredential"] = gen.PtrOf(MpnsCredential_STATUSGenerator())
	gens["WnsCredential"] = gen.PtrOf(WnsCredential_STATUSGenerator())
	gens["XiaomiCredential"] = gen.PtrOf(XiaomiCredential_STATUSGenerator())
}

func Test_PrivateEndpointConnectionResource_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PrivateEndpointConnectionResource_STATUS to PrivateEndpointConnectionResource_STATUS via AssignProperties_To_PrivateEndpointConnectionResource_STATUS & AssignProperties_From_PrivateEndpointConnectionResource_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForPrivateEndpointConnectionResource_STATUS, PrivateEndpointConnectionResource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPrivateEndpointConnectionResource_STATUS tests if a specific instance of PrivateEndpointConnectionResource_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForPrivateEndpointConnectionResource_STATUS(subject PrivateEndpointConnectionResource_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.PrivateEndpointConnectionResource_STATUS
	err := copied.AssignProperties_To_PrivateEndpointConnectionResource_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PrivateEndpointConnectionResource_STATUS
	err = actual.AssignProperties_From_PrivateEndpointConnectionResource_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PrivateEndpointConnectionResource_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointConnectionResource_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointConnectionResource_STATUS, PrivateEndpointConnectionResource_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointConnectionResource_STATUS runs a test to see if a specific instance of PrivateEndpointConnectionResource_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointConnectionResource_STATUS(subject PrivateEndpointConnectionResource_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointConnectionResource_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointConnectionResource_STATUS instances for property testing - lazily instantiated by
// PrivateEndpointConnectionResource_STATUSGenerator()
var privateEndpointConnectionResource_STATUSGenerator gopter.Gen

// PrivateEndpointConnectionResource_STATUSGenerator returns a generator of PrivateEndpointConnectionResource_STATUS instances for property testing.
func PrivateEndpointConnectionResource_STATUSGenerator() gopter.Gen {
	if privateEndpointConnectionResource_STATUSGenerator != nil {
		return privateEndpointConnectionResource_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnectionResource_STATUS(generators)
	privateEndpointConnectionResource_STATUSGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnectionResource_STATUS{}), generators)

	return privateEndpointConnectionResource_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointConnectionResource_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointConnectionResource_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_PublicInternetAuthorizationRule_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PublicInternetAuthorizationRule to PublicInternetAuthorizationRule via AssignProperties_To_PublicInternetAuthorizationRule & AssignProperties_From_PublicInternetAuthorizationRule returns original",
		prop.ForAll(RunPropertyAssignmentTestForPublicInternetAuthorizationRule, PublicInternetAuthorizationRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPublicInternetAuthorizationRule tests if a specific instance of PublicInternetAuthorizationRule can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForPublicInternetAuthorizationRule(subject PublicInternetAuthorizationRule) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.PublicInternetAuthorizationRule
	err := copied.AssignProperties_To_PublicInternetAuthorizationRule(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PublicInternetAuthorizationRule
	err = actual.AssignProperties_From_PublicInternetAuthorizationRule(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PublicInternetAuthorizationRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicInternetAuthorizationRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicInternetAuthorizationRule, PublicInternetAuthorizationRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicInternetAuthorizationRule runs a test to see if a specific instance of PublicInternetAuthorizationRule round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicInternetAuthorizationRule(subject PublicInternetAuthorizationRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicInternetAuthorizationRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicInternetAuthorizationRule instances for property testing - lazily instantiated by
// PublicInternetAuthorizationRuleGenerator()
var publicInternetAuthorizationRuleGenerator gopter.Gen

// PublicInternetAuthorizationRuleGenerator returns a generator of PublicInternetAuthorizationRule instances for property testing.
func PublicInternetAuthorizationRuleGenerator() gopter.Gen {
	if publicInternetAuthorizationRuleGenerator != nil {
		return publicInternetAuthorizationRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicInternetAuthorizationRule(generators)
	publicInternetAuthorizationRuleGenerator = gen.Struct(reflect.TypeOf(PublicInternetAuthorizationRule{}), generators)

	return publicInternetAuthorizationRuleGenerator
}

// AddIndependentPropertyGeneratorsForPublicInternetAuthorizationRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicInternetAuthorizationRule(gens map[string]gopter.Gen) {
	gens["Rights"] = gen.SliceOf(gen.OneConstOf(AccessRights_Listen, AccessRights_Manage, AccessRights_Send))
}

func Test_PublicInternetAuthorizationRule_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PublicInternetAuthorizationRule_STATUS to PublicInternetAuthorizationRule_STATUS via AssignProperties_To_PublicInternetAuthorizationRule_STATUS & AssignProperties_From_PublicInternetAuthorizationRule_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForPublicInternetAuthorizationRule_STATUS, PublicInternetAuthorizationRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPublicInternetAuthorizationRule_STATUS tests if a specific instance of PublicInternetAuthorizationRule_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForPublicInternetAuthorizationRule_STATUS(subject PublicInternetAuthorizationRule_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.PublicInternetAuthorizationRule_STATUS
	err := copied.AssignProperties_To_PublicInternetAuthorizationRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PublicInternetAuthorizationRule_STATUS
	err = actual.AssignProperties_From_PublicInternetAuthorizationRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PublicInternetAuthorizationRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicInternetAuthorizationRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicInternetAuthorizationRule_STATUS, PublicInternetAuthorizationRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicInternetAuthorizationRule_STATUS runs a test to see if a specific instance of PublicInternetAuthorizationRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicInternetAuthorizationRule_STATUS(subject PublicInternetAuthorizationRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicInternetAuthorizationRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicInternetAuthorizationRule_STATUS instances for property testing - lazily instantiated by
// PublicInternetAuthorizationRule_STATUSGenerator()
var publicInternetAuthorizationRule_STATUSGenerator gopter.Gen

// PublicInternetAuthorizationRule_STATUSGenerator returns a generator of PublicInternetAuthorizationRule_STATUS instances for property testing.
func PublicInternetAuthorizationRule_STATUSGenerator() gopter.Gen {
	if publicInternetAuthorizationRule_STATUSGenerator != nil {
		return publicInternetAuthorizationRule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicInternetAuthorizationRule_STATUS(generators)
	publicInternetAuthorizationRule_STATUSGenerator = gen.Struct(reflect.TypeOf(PublicInternetAuthorizationRule_STATUS{}), generators)

	return publicInternetAuthorizationRule_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForPublicInternetAuthorizationRule_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicInternetAuthorizationRule_STATUS(gens map[string]gopter.Gen) {
	gens["Rights"] = gen.SliceOf(gen.OneConstOf(AccessRights_STATUS_Listen, AccessRights_STATUS_Manage, AccessRights_STATUS_Send))
}

func Test_Sku_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Sku to Sku via AssignProperties_To_Sku & AssignProperties_From_Sku returns original",
		prop.ForAll(RunPropertyAssignmentTestForSku, SkuGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSku tests if a specific instance of Sku can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSku(subject Sku) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.Sku
	err := copied.AssignProperties_To_Sku(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Sku
	err = actual.AssignProperties_From_Sku(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Sku_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sku via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSku, SkuGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSku runs a test to see if a specific instance of Sku round trips to JSON and back losslessly
func RunJSONSerializationTestForSku(subject Sku) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sku
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sku instances for property testing - lazily instantiated by SkuGenerator()
var skuGenerator gopter.Gen

// SkuGenerator returns a generator of Sku instances for property testing.
func SkuGenerator() gopter.Gen {
	if skuGenerator != nil {
		return skuGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSku(generators)
	skuGenerator = gen.Struct(reflect.TypeOf(Sku{}), generators)

	return skuGenerator
}

// AddIndependentPropertyGeneratorsForSku is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSku(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Family"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.OneConstOf(SkuName_Basic, SkuName_Free, SkuName_Standard))
	gens["Size"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
}

func Test_Sku_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Sku_STATUS to Sku_STATUS via AssignProperties_To_Sku_STATUS & AssignProperties_From_Sku_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSku_STATUS, Sku_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSku_STATUS tests if a specific instance of Sku_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSku_STATUS(subject Sku_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.Sku_STATUS
	err := copied.AssignProperties_To_Sku_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Sku_STATUS
	err = actual.AssignProperties_From_Sku_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Sku_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sku_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSku_STATUS, Sku_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSku_STATUS runs a test to see if a specific instance of Sku_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSku_STATUS(subject Sku_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sku_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sku_STATUS instances for property testing - lazily instantiated by Sku_STATUSGenerator()
var sku_STATUSGenerator gopter.Gen

// Sku_STATUSGenerator returns a generator of Sku_STATUS instances for property testing.
func Sku_STATUSGenerator() gopter.Gen {
	if sku_STATUSGenerator != nil {
		return sku_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSku_STATUS(generators)
	sku_STATUSGenerator = gen.Struct(reflect.TypeOf(Sku_STATUS{}), generators)

	return sku_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSku_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSku_STATUS(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Family"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.OneConstOf(SkuName_STATUS_Basic, SkuName_STATUS_Free, SkuName_STATUS_Standard))
	gens["Size"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
}

func Test_SystemData_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SystemData_STATUS to SystemData_STATUS via AssignProperties_To_SystemData_STATUS & AssignProperties_From_SystemData_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSystemData_STATUS, SystemData_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSystemData_STATUS tests if a specific instance of SystemData_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSystemData_STATUS(subject SystemData_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.SystemData_STATUS
	err := copied.AssignProperties_To_SystemData_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SystemData_STATUS
	err = actual.AssignProperties_From_SystemData_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SystemData_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SystemData_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSystemData_STATUS, SystemData_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSystemData_STATUS runs a test to see if a specific instance of SystemData_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSystemData_STATUS(subject SystemData_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SystemData_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SystemData_STATUS instances for property testing - lazily instantiated by SystemData_STATUSGenerator()
var systemData_STATUSGenerator gopter.Gen

// SystemData_STATUSGenerator returns a generator of SystemData_STATUS instances for property testing.
func SystemData_STATUSGenerator() gopter.Gen {
	if systemData_STATUSGenerator != nil {
		return systemData_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSystemData_STATUS(generators)
	systemData_STATUSGenerator = gen.Struct(reflect.TypeOf(SystemData_STATUS{}), generators)

	return systemData_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSystemData_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSystemData_STATUS(gens map[string]gopter.Gen) {
	gens["CreatedAt"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedBy"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemData_CreatedByType_STATUS_Application,
		SystemData_CreatedByType_STATUS_Key,
		SystemData_CreatedByType_STATUS_ManagedIdentity,
		SystemData_CreatedByType_STATUS_User))
	gens["LastModifiedAt"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedBy"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemData_LastModifiedByType_STATUS_Application,
		SystemData_LastModifiedByType_STATUS_Key,
		SystemData_LastModifiedByType_STATUS_ManagedIdentity,
		SystemData_LastModifiedByType_STATUS_User))
}
