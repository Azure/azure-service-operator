// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20230901

import (
	"encoding/json"
	storage "github.com/Azure/azure-service-operator/v2/api/notificationhubs/v1api20230901/storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_AdmCredential_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AdmCredential to AdmCredential via AssignProperties_To_AdmCredential & AssignProperties_From_AdmCredential returns original",
		prop.ForAll(RunPropertyAssignmentTestForAdmCredential, AdmCredentialGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAdmCredential tests if a specific instance of AdmCredential can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAdmCredential(subject AdmCredential) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AdmCredential
	err := copied.AssignProperties_To_AdmCredential(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AdmCredential
	err = actual.AssignProperties_From_AdmCredential(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AdmCredential_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdmCredential via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdmCredential, AdmCredentialGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdmCredential runs a test to see if a specific instance of AdmCredential round trips to JSON and back losslessly
func RunJSONSerializationTestForAdmCredential(subject AdmCredential) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdmCredential
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdmCredential instances for property testing - lazily instantiated by AdmCredentialGenerator()
var admCredentialGenerator gopter.Gen

// AdmCredentialGenerator returns a generator of AdmCredential instances for property testing.
func AdmCredentialGenerator() gopter.Gen {
	if admCredentialGenerator != nil {
		return admCredentialGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForAdmCredential(generators)
	admCredentialGenerator = gen.Struct(reflect.TypeOf(AdmCredential{}), generators)

	return admCredentialGenerator
}

// AddRelatedPropertyGeneratorsForAdmCredential is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAdmCredential(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(AdmCredentialPropertiesGenerator())
}

func Test_AdmCredentialProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AdmCredentialProperties to AdmCredentialProperties via AssignProperties_To_AdmCredentialProperties & AssignProperties_From_AdmCredentialProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForAdmCredentialProperties, AdmCredentialPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAdmCredentialProperties tests if a specific instance of AdmCredentialProperties can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAdmCredentialProperties(subject AdmCredentialProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AdmCredentialProperties
	err := copied.AssignProperties_To_AdmCredentialProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AdmCredentialProperties
	err = actual.AssignProperties_From_AdmCredentialProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AdmCredentialProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdmCredentialProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdmCredentialProperties, AdmCredentialPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdmCredentialProperties runs a test to see if a specific instance of AdmCredentialProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForAdmCredentialProperties(subject AdmCredentialProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdmCredentialProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdmCredentialProperties instances for property testing - lazily instantiated by
// AdmCredentialPropertiesGenerator()
var admCredentialPropertiesGenerator gopter.Gen

// AdmCredentialPropertiesGenerator returns a generator of AdmCredentialProperties instances for property testing.
func AdmCredentialPropertiesGenerator() gopter.Gen {
	if admCredentialPropertiesGenerator != nil {
		return admCredentialPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	admCredentialPropertiesGenerator = gen.Struct(reflect.TypeOf(AdmCredentialProperties{}), generators)

	return admCredentialPropertiesGenerator
}

func Test_AdmCredentialProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AdmCredentialProperties_STATUS to AdmCredentialProperties_STATUS via AssignProperties_To_AdmCredentialProperties_STATUS & AssignProperties_From_AdmCredentialProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAdmCredentialProperties_STATUS, AdmCredentialProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAdmCredentialProperties_STATUS tests if a specific instance of AdmCredentialProperties_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAdmCredentialProperties_STATUS(subject AdmCredentialProperties_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AdmCredentialProperties_STATUS
	err := copied.AssignProperties_To_AdmCredentialProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AdmCredentialProperties_STATUS
	err = actual.AssignProperties_From_AdmCredentialProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AdmCredentialProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdmCredentialProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdmCredentialProperties_STATUS, AdmCredentialProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdmCredentialProperties_STATUS runs a test to see if a specific instance of AdmCredentialProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAdmCredentialProperties_STATUS(subject AdmCredentialProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdmCredentialProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdmCredentialProperties_STATUS instances for property testing - lazily instantiated by
// AdmCredentialProperties_STATUSGenerator()
var admCredentialProperties_STATUSGenerator gopter.Gen

// AdmCredentialProperties_STATUSGenerator returns a generator of AdmCredentialProperties_STATUS instances for property testing.
func AdmCredentialProperties_STATUSGenerator() gopter.Gen {
	if admCredentialProperties_STATUSGenerator != nil {
		return admCredentialProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	admCredentialProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(AdmCredentialProperties_STATUS{}), generators)

	return admCredentialProperties_STATUSGenerator
}

func Test_AdmCredential_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AdmCredential_STATUS to AdmCredential_STATUS via AssignProperties_To_AdmCredential_STATUS & AssignProperties_From_AdmCredential_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAdmCredential_STATUS, AdmCredential_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAdmCredential_STATUS tests if a specific instance of AdmCredential_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAdmCredential_STATUS(subject AdmCredential_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.AdmCredential_STATUS
	err := copied.AssignProperties_To_AdmCredential_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AdmCredential_STATUS
	err = actual.AssignProperties_From_AdmCredential_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AdmCredential_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdmCredential_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdmCredential_STATUS, AdmCredential_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdmCredential_STATUS runs a test to see if a specific instance of AdmCredential_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAdmCredential_STATUS(subject AdmCredential_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdmCredential_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdmCredential_STATUS instances for property testing - lazily instantiated by
// AdmCredential_STATUSGenerator()
var admCredential_STATUSGenerator gopter.Gen

// AdmCredential_STATUSGenerator returns a generator of AdmCredential_STATUS instances for property testing.
func AdmCredential_STATUSGenerator() gopter.Gen {
	if admCredential_STATUSGenerator != nil {
		return admCredential_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForAdmCredential_STATUS(generators)
	admCredential_STATUSGenerator = gen.Struct(reflect.TypeOf(AdmCredential_STATUS{}), generators)

	return admCredential_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForAdmCredential_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAdmCredential_STATUS(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(AdmCredentialProperties_STATUSGenerator())
}

func Test_ApnsCredential_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ApnsCredential to ApnsCredential via AssignProperties_To_ApnsCredential & AssignProperties_From_ApnsCredential returns original",
		prop.ForAll(RunPropertyAssignmentTestForApnsCredential, ApnsCredentialGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForApnsCredential tests if a specific instance of ApnsCredential can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForApnsCredential(subject ApnsCredential) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ApnsCredential
	err := copied.AssignProperties_To_ApnsCredential(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ApnsCredential
	err = actual.AssignProperties_From_ApnsCredential(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ApnsCredential_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApnsCredential via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApnsCredential, ApnsCredentialGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApnsCredential runs a test to see if a specific instance of ApnsCredential round trips to JSON and back losslessly
func RunJSONSerializationTestForApnsCredential(subject ApnsCredential) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApnsCredential
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApnsCredential instances for property testing - lazily instantiated by ApnsCredentialGenerator()
var apnsCredentialGenerator gopter.Gen

// ApnsCredentialGenerator returns a generator of ApnsCredential instances for property testing.
func ApnsCredentialGenerator() gopter.Gen {
	if apnsCredentialGenerator != nil {
		return apnsCredentialGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForApnsCredential(generators)
	apnsCredentialGenerator = gen.Struct(reflect.TypeOf(ApnsCredential{}), generators)

	return apnsCredentialGenerator
}

// AddRelatedPropertyGeneratorsForApnsCredential is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForApnsCredential(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(ApnsCredentialPropertiesGenerator())
}

func Test_ApnsCredentialProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ApnsCredentialProperties to ApnsCredentialProperties via AssignProperties_To_ApnsCredentialProperties & AssignProperties_From_ApnsCredentialProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForApnsCredentialProperties, ApnsCredentialPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForApnsCredentialProperties tests if a specific instance of ApnsCredentialProperties can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForApnsCredentialProperties(subject ApnsCredentialProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ApnsCredentialProperties
	err := copied.AssignProperties_To_ApnsCredentialProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ApnsCredentialProperties
	err = actual.AssignProperties_From_ApnsCredentialProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ApnsCredentialProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApnsCredentialProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApnsCredentialProperties, ApnsCredentialPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApnsCredentialProperties runs a test to see if a specific instance of ApnsCredentialProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForApnsCredentialProperties(subject ApnsCredentialProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApnsCredentialProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApnsCredentialProperties instances for property testing - lazily instantiated by
// ApnsCredentialPropertiesGenerator()
var apnsCredentialPropertiesGenerator gopter.Gen

// ApnsCredentialPropertiesGenerator returns a generator of ApnsCredentialProperties instances for property testing.
func ApnsCredentialPropertiesGenerator() gopter.Gen {
	if apnsCredentialPropertiesGenerator != nil {
		return apnsCredentialPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	apnsCredentialPropertiesGenerator = gen.Struct(reflect.TypeOf(ApnsCredentialProperties{}), generators)

	return apnsCredentialPropertiesGenerator
}

func Test_ApnsCredentialProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ApnsCredentialProperties_STATUS to ApnsCredentialProperties_STATUS via AssignProperties_To_ApnsCredentialProperties_STATUS & AssignProperties_From_ApnsCredentialProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForApnsCredentialProperties_STATUS, ApnsCredentialProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForApnsCredentialProperties_STATUS tests if a specific instance of ApnsCredentialProperties_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForApnsCredentialProperties_STATUS(subject ApnsCredentialProperties_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ApnsCredentialProperties_STATUS
	err := copied.AssignProperties_To_ApnsCredentialProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ApnsCredentialProperties_STATUS
	err = actual.AssignProperties_From_ApnsCredentialProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ApnsCredentialProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApnsCredentialProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApnsCredentialProperties_STATUS, ApnsCredentialProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApnsCredentialProperties_STATUS runs a test to see if a specific instance of ApnsCredentialProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForApnsCredentialProperties_STATUS(subject ApnsCredentialProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApnsCredentialProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApnsCredentialProperties_STATUS instances for property testing - lazily instantiated by
// ApnsCredentialProperties_STATUSGenerator()
var apnsCredentialProperties_STATUSGenerator gopter.Gen

// ApnsCredentialProperties_STATUSGenerator returns a generator of ApnsCredentialProperties_STATUS instances for property testing.
func ApnsCredentialProperties_STATUSGenerator() gopter.Gen {
	if apnsCredentialProperties_STATUSGenerator != nil {
		return apnsCredentialProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	apnsCredentialProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(ApnsCredentialProperties_STATUS{}), generators)

	return apnsCredentialProperties_STATUSGenerator
}

func Test_ApnsCredential_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ApnsCredential_STATUS to ApnsCredential_STATUS via AssignProperties_To_ApnsCredential_STATUS & AssignProperties_From_ApnsCredential_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForApnsCredential_STATUS, ApnsCredential_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForApnsCredential_STATUS tests if a specific instance of ApnsCredential_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForApnsCredential_STATUS(subject ApnsCredential_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ApnsCredential_STATUS
	err := copied.AssignProperties_To_ApnsCredential_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ApnsCredential_STATUS
	err = actual.AssignProperties_From_ApnsCredential_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ApnsCredential_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApnsCredential_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApnsCredential_STATUS, ApnsCredential_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApnsCredential_STATUS runs a test to see if a specific instance of ApnsCredential_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForApnsCredential_STATUS(subject ApnsCredential_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApnsCredential_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApnsCredential_STATUS instances for property testing - lazily instantiated by
// ApnsCredential_STATUSGenerator()
var apnsCredential_STATUSGenerator gopter.Gen

// ApnsCredential_STATUSGenerator returns a generator of ApnsCredential_STATUS instances for property testing.
func ApnsCredential_STATUSGenerator() gopter.Gen {
	if apnsCredential_STATUSGenerator != nil {
		return apnsCredential_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForApnsCredential_STATUS(generators)
	apnsCredential_STATUSGenerator = gen.Struct(reflect.TypeOf(ApnsCredential_STATUS{}), generators)

	return apnsCredential_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForApnsCredential_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForApnsCredential_STATUS(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(ApnsCredentialProperties_STATUSGenerator())
}

func Test_BaiduCredential_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BaiduCredential to BaiduCredential via AssignProperties_To_BaiduCredential & AssignProperties_From_BaiduCredential returns original",
		prop.ForAll(RunPropertyAssignmentTestForBaiduCredential, BaiduCredentialGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBaiduCredential tests if a specific instance of BaiduCredential can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForBaiduCredential(subject BaiduCredential) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.BaiduCredential
	err := copied.AssignProperties_To_BaiduCredential(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BaiduCredential
	err = actual.AssignProperties_From_BaiduCredential(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BaiduCredential_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BaiduCredential via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBaiduCredential, BaiduCredentialGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBaiduCredential runs a test to see if a specific instance of BaiduCredential round trips to JSON and back losslessly
func RunJSONSerializationTestForBaiduCredential(subject BaiduCredential) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BaiduCredential
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BaiduCredential instances for property testing - lazily instantiated by BaiduCredentialGenerator()
var baiduCredentialGenerator gopter.Gen

// BaiduCredentialGenerator returns a generator of BaiduCredential instances for property testing.
func BaiduCredentialGenerator() gopter.Gen {
	if baiduCredentialGenerator != nil {
		return baiduCredentialGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForBaiduCredential(generators)
	baiduCredentialGenerator = gen.Struct(reflect.TypeOf(BaiduCredential{}), generators)

	return baiduCredentialGenerator
}

// AddRelatedPropertyGeneratorsForBaiduCredential is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBaiduCredential(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(BaiduCredentialPropertiesGenerator())
}

func Test_BaiduCredentialProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BaiduCredentialProperties to BaiduCredentialProperties via AssignProperties_To_BaiduCredentialProperties & AssignProperties_From_BaiduCredentialProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForBaiduCredentialProperties, BaiduCredentialPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBaiduCredentialProperties tests if a specific instance of BaiduCredentialProperties can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForBaiduCredentialProperties(subject BaiduCredentialProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.BaiduCredentialProperties
	err := copied.AssignProperties_To_BaiduCredentialProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BaiduCredentialProperties
	err = actual.AssignProperties_From_BaiduCredentialProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BaiduCredentialProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BaiduCredentialProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBaiduCredentialProperties, BaiduCredentialPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBaiduCredentialProperties runs a test to see if a specific instance of BaiduCredentialProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForBaiduCredentialProperties(subject BaiduCredentialProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BaiduCredentialProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BaiduCredentialProperties instances for property testing - lazily instantiated by
// BaiduCredentialPropertiesGenerator()
var baiduCredentialPropertiesGenerator gopter.Gen

// BaiduCredentialPropertiesGenerator returns a generator of BaiduCredentialProperties instances for property testing.
func BaiduCredentialPropertiesGenerator() gopter.Gen {
	if baiduCredentialPropertiesGenerator != nil {
		return baiduCredentialPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	baiduCredentialPropertiesGenerator = gen.Struct(reflect.TypeOf(BaiduCredentialProperties{}), generators)

	return baiduCredentialPropertiesGenerator
}

func Test_BaiduCredentialProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BaiduCredentialProperties_STATUS to BaiduCredentialProperties_STATUS via AssignProperties_To_BaiduCredentialProperties_STATUS & AssignProperties_From_BaiduCredentialProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForBaiduCredentialProperties_STATUS, BaiduCredentialProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBaiduCredentialProperties_STATUS tests if a specific instance of BaiduCredentialProperties_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForBaiduCredentialProperties_STATUS(subject BaiduCredentialProperties_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.BaiduCredentialProperties_STATUS
	err := copied.AssignProperties_To_BaiduCredentialProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BaiduCredentialProperties_STATUS
	err = actual.AssignProperties_From_BaiduCredentialProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BaiduCredentialProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BaiduCredentialProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBaiduCredentialProperties_STATUS, BaiduCredentialProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBaiduCredentialProperties_STATUS runs a test to see if a specific instance of BaiduCredentialProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForBaiduCredentialProperties_STATUS(subject BaiduCredentialProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BaiduCredentialProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BaiduCredentialProperties_STATUS instances for property testing - lazily instantiated by
// BaiduCredentialProperties_STATUSGenerator()
var baiduCredentialProperties_STATUSGenerator gopter.Gen

// BaiduCredentialProperties_STATUSGenerator returns a generator of BaiduCredentialProperties_STATUS instances for property testing.
func BaiduCredentialProperties_STATUSGenerator() gopter.Gen {
	if baiduCredentialProperties_STATUSGenerator != nil {
		return baiduCredentialProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	baiduCredentialProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(BaiduCredentialProperties_STATUS{}), generators)

	return baiduCredentialProperties_STATUSGenerator
}

func Test_BaiduCredential_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BaiduCredential_STATUS to BaiduCredential_STATUS via AssignProperties_To_BaiduCredential_STATUS & AssignProperties_From_BaiduCredential_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForBaiduCredential_STATUS, BaiduCredential_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBaiduCredential_STATUS tests if a specific instance of BaiduCredential_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForBaiduCredential_STATUS(subject BaiduCredential_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.BaiduCredential_STATUS
	err := copied.AssignProperties_To_BaiduCredential_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BaiduCredential_STATUS
	err = actual.AssignProperties_From_BaiduCredential_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BaiduCredential_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BaiduCredential_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBaiduCredential_STATUS, BaiduCredential_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBaiduCredential_STATUS runs a test to see if a specific instance of BaiduCredential_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForBaiduCredential_STATUS(subject BaiduCredential_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BaiduCredential_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BaiduCredential_STATUS instances for property testing - lazily instantiated by
// BaiduCredential_STATUSGenerator()
var baiduCredential_STATUSGenerator gopter.Gen

// BaiduCredential_STATUSGenerator returns a generator of BaiduCredential_STATUS instances for property testing.
func BaiduCredential_STATUSGenerator() gopter.Gen {
	if baiduCredential_STATUSGenerator != nil {
		return baiduCredential_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForBaiduCredential_STATUS(generators)
	baiduCredential_STATUSGenerator = gen.Struct(reflect.TypeOf(BaiduCredential_STATUS{}), generators)

	return baiduCredential_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForBaiduCredential_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBaiduCredential_STATUS(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(BaiduCredentialProperties_STATUSGenerator())
}

func Test_BrowserCredential_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BrowserCredential to BrowserCredential via AssignProperties_To_BrowserCredential & AssignProperties_From_BrowserCredential returns original",
		prop.ForAll(RunPropertyAssignmentTestForBrowserCredential, BrowserCredentialGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBrowserCredential tests if a specific instance of BrowserCredential can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForBrowserCredential(subject BrowserCredential) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.BrowserCredential
	err := copied.AssignProperties_To_BrowserCredential(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BrowserCredential
	err = actual.AssignProperties_From_BrowserCredential(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BrowserCredential_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BrowserCredential via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBrowserCredential, BrowserCredentialGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBrowserCredential runs a test to see if a specific instance of BrowserCredential round trips to JSON and back losslessly
func RunJSONSerializationTestForBrowserCredential(subject BrowserCredential) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BrowserCredential
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BrowserCredential instances for property testing - lazily instantiated by BrowserCredentialGenerator()
var browserCredentialGenerator gopter.Gen

// BrowserCredentialGenerator returns a generator of BrowserCredential instances for property testing.
func BrowserCredentialGenerator() gopter.Gen {
	if browserCredentialGenerator != nil {
		return browserCredentialGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForBrowserCredential(generators)
	browserCredentialGenerator = gen.Struct(reflect.TypeOf(BrowserCredential{}), generators)

	return browserCredentialGenerator
}

// AddRelatedPropertyGeneratorsForBrowserCredential is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBrowserCredential(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(BrowserCredentialPropertiesGenerator())
}

func Test_BrowserCredentialProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BrowserCredentialProperties to BrowserCredentialProperties via AssignProperties_To_BrowserCredentialProperties & AssignProperties_From_BrowserCredentialProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForBrowserCredentialProperties, BrowserCredentialPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBrowserCredentialProperties tests if a specific instance of BrowserCredentialProperties can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForBrowserCredentialProperties(subject BrowserCredentialProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.BrowserCredentialProperties
	err := copied.AssignProperties_To_BrowserCredentialProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BrowserCredentialProperties
	err = actual.AssignProperties_From_BrowserCredentialProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BrowserCredentialProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BrowserCredentialProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBrowserCredentialProperties, BrowserCredentialPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBrowserCredentialProperties runs a test to see if a specific instance of BrowserCredentialProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForBrowserCredentialProperties(subject BrowserCredentialProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BrowserCredentialProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BrowserCredentialProperties instances for property testing - lazily instantiated by
// BrowserCredentialPropertiesGenerator()
var browserCredentialPropertiesGenerator gopter.Gen

// BrowserCredentialPropertiesGenerator returns a generator of BrowserCredentialProperties instances for property testing.
func BrowserCredentialPropertiesGenerator() gopter.Gen {
	if browserCredentialPropertiesGenerator != nil {
		return browserCredentialPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	browserCredentialPropertiesGenerator = gen.Struct(reflect.TypeOf(BrowserCredentialProperties{}), generators)

	return browserCredentialPropertiesGenerator
}

func Test_BrowserCredentialProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BrowserCredentialProperties_STATUS to BrowserCredentialProperties_STATUS via AssignProperties_To_BrowserCredentialProperties_STATUS & AssignProperties_From_BrowserCredentialProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForBrowserCredentialProperties_STATUS, BrowserCredentialProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBrowserCredentialProperties_STATUS tests if a specific instance of BrowserCredentialProperties_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForBrowserCredentialProperties_STATUS(subject BrowserCredentialProperties_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.BrowserCredentialProperties_STATUS
	err := copied.AssignProperties_To_BrowserCredentialProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BrowserCredentialProperties_STATUS
	err = actual.AssignProperties_From_BrowserCredentialProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BrowserCredentialProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BrowserCredentialProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBrowserCredentialProperties_STATUS, BrowserCredentialProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBrowserCredentialProperties_STATUS runs a test to see if a specific instance of BrowserCredentialProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForBrowserCredentialProperties_STATUS(subject BrowserCredentialProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BrowserCredentialProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BrowserCredentialProperties_STATUS instances for property testing - lazily instantiated by
// BrowserCredentialProperties_STATUSGenerator()
var browserCredentialProperties_STATUSGenerator gopter.Gen

// BrowserCredentialProperties_STATUSGenerator returns a generator of BrowserCredentialProperties_STATUS instances for property testing.
func BrowserCredentialProperties_STATUSGenerator() gopter.Gen {
	if browserCredentialProperties_STATUSGenerator != nil {
		return browserCredentialProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	browserCredentialProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(BrowserCredentialProperties_STATUS{}), generators)

	return browserCredentialProperties_STATUSGenerator
}

func Test_BrowserCredential_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BrowserCredential_STATUS to BrowserCredential_STATUS via AssignProperties_To_BrowserCredential_STATUS & AssignProperties_From_BrowserCredential_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForBrowserCredential_STATUS, BrowserCredential_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBrowserCredential_STATUS tests if a specific instance of BrowserCredential_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForBrowserCredential_STATUS(subject BrowserCredential_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.BrowserCredential_STATUS
	err := copied.AssignProperties_To_BrowserCredential_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BrowserCredential_STATUS
	err = actual.AssignProperties_From_BrowserCredential_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BrowserCredential_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BrowserCredential_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBrowserCredential_STATUS, BrowserCredential_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBrowserCredential_STATUS runs a test to see if a specific instance of BrowserCredential_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForBrowserCredential_STATUS(subject BrowserCredential_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BrowserCredential_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BrowserCredential_STATUS instances for property testing - lazily instantiated by
// BrowserCredential_STATUSGenerator()
var browserCredential_STATUSGenerator gopter.Gen

// BrowserCredential_STATUSGenerator returns a generator of BrowserCredential_STATUS instances for property testing.
func BrowserCredential_STATUSGenerator() gopter.Gen {
	if browserCredential_STATUSGenerator != nil {
		return browserCredential_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForBrowserCredential_STATUS(generators)
	browserCredential_STATUSGenerator = gen.Struct(reflect.TypeOf(BrowserCredential_STATUS{}), generators)

	return browserCredential_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForBrowserCredential_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBrowserCredential_STATUS(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(BrowserCredentialProperties_STATUSGenerator())
}

func Test_GcmCredential_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from GcmCredential to GcmCredential via AssignProperties_To_GcmCredential & AssignProperties_From_GcmCredential returns original",
		prop.ForAll(RunPropertyAssignmentTestForGcmCredential, GcmCredentialGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForGcmCredential tests if a specific instance of GcmCredential can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForGcmCredential(subject GcmCredential) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.GcmCredential
	err := copied.AssignProperties_To_GcmCredential(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual GcmCredential
	err = actual.AssignProperties_From_GcmCredential(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_GcmCredential_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GcmCredential via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGcmCredential, GcmCredentialGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGcmCredential runs a test to see if a specific instance of GcmCredential round trips to JSON and back losslessly
func RunJSONSerializationTestForGcmCredential(subject GcmCredential) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GcmCredential
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GcmCredential instances for property testing - lazily instantiated by GcmCredentialGenerator()
var gcmCredentialGenerator gopter.Gen

// GcmCredentialGenerator returns a generator of GcmCredential instances for property testing.
func GcmCredentialGenerator() gopter.Gen {
	if gcmCredentialGenerator != nil {
		return gcmCredentialGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForGcmCredential(generators)
	gcmCredentialGenerator = gen.Struct(reflect.TypeOf(GcmCredential{}), generators)

	return gcmCredentialGenerator
}

// AddRelatedPropertyGeneratorsForGcmCredential is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForGcmCredential(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(GcmCredentialPropertiesGenerator())
}

func Test_GcmCredentialProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from GcmCredentialProperties to GcmCredentialProperties via AssignProperties_To_GcmCredentialProperties & AssignProperties_From_GcmCredentialProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForGcmCredentialProperties, GcmCredentialPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForGcmCredentialProperties tests if a specific instance of GcmCredentialProperties can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForGcmCredentialProperties(subject GcmCredentialProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.GcmCredentialProperties
	err := copied.AssignProperties_To_GcmCredentialProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual GcmCredentialProperties
	err = actual.AssignProperties_From_GcmCredentialProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_GcmCredentialProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GcmCredentialProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGcmCredentialProperties, GcmCredentialPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGcmCredentialProperties runs a test to see if a specific instance of GcmCredentialProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForGcmCredentialProperties(subject GcmCredentialProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GcmCredentialProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GcmCredentialProperties instances for property testing - lazily instantiated by
// GcmCredentialPropertiesGenerator()
var gcmCredentialPropertiesGenerator gopter.Gen

// GcmCredentialPropertiesGenerator returns a generator of GcmCredentialProperties instances for property testing.
func GcmCredentialPropertiesGenerator() gopter.Gen {
	if gcmCredentialPropertiesGenerator != nil {
		return gcmCredentialPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	gcmCredentialPropertiesGenerator = gen.Struct(reflect.TypeOf(GcmCredentialProperties{}), generators)

	return gcmCredentialPropertiesGenerator
}

func Test_GcmCredentialProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from GcmCredentialProperties_STATUS to GcmCredentialProperties_STATUS via AssignProperties_To_GcmCredentialProperties_STATUS & AssignProperties_From_GcmCredentialProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForGcmCredentialProperties_STATUS, GcmCredentialProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForGcmCredentialProperties_STATUS tests if a specific instance of GcmCredentialProperties_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForGcmCredentialProperties_STATUS(subject GcmCredentialProperties_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.GcmCredentialProperties_STATUS
	err := copied.AssignProperties_To_GcmCredentialProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual GcmCredentialProperties_STATUS
	err = actual.AssignProperties_From_GcmCredentialProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_GcmCredentialProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GcmCredentialProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGcmCredentialProperties_STATUS, GcmCredentialProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGcmCredentialProperties_STATUS runs a test to see if a specific instance of GcmCredentialProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForGcmCredentialProperties_STATUS(subject GcmCredentialProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GcmCredentialProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GcmCredentialProperties_STATUS instances for property testing - lazily instantiated by
// GcmCredentialProperties_STATUSGenerator()
var gcmCredentialProperties_STATUSGenerator gopter.Gen

// GcmCredentialProperties_STATUSGenerator returns a generator of GcmCredentialProperties_STATUS instances for property testing.
func GcmCredentialProperties_STATUSGenerator() gopter.Gen {
	if gcmCredentialProperties_STATUSGenerator != nil {
		return gcmCredentialProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	gcmCredentialProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(GcmCredentialProperties_STATUS{}), generators)

	return gcmCredentialProperties_STATUSGenerator
}

func Test_GcmCredential_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from GcmCredential_STATUS to GcmCredential_STATUS via AssignProperties_To_GcmCredential_STATUS & AssignProperties_From_GcmCredential_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForGcmCredential_STATUS, GcmCredential_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForGcmCredential_STATUS tests if a specific instance of GcmCredential_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForGcmCredential_STATUS(subject GcmCredential_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.GcmCredential_STATUS
	err := copied.AssignProperties_To_GcmCredential_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual GcmCredential_STATUS
	err = actual.AssignProperties_From_GcmCredential_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_GcmCredential_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GcmCredential_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGcmCredential_STATUS, GcmCredential_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGcmCredential_STATUS runs a test to see if a specific instance of GcmCredential_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForGcmCredential_STATUS(subject GcmCredential_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GcmCredential_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GcmCredential_STATUS instances for property testing - lazily instantiated by
// GcmCredential_STATUSGenerator()
var gcmCredential_STATUSGenerator gopter.Gen

// GcmCredential_STATUSGenerator returns a generator of GcmCredential_STATUS instances for property testing.
func GcmCredential_STATUSGenerator() gopter.Gen {
	if gcmCredential_STATUSGenerator != nil {
		return gcmCredential_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForGcmCredential_STATUS(generators)
	gcmCredential_STATUSGenerator = gen.Struct(reflect.TypeOf(GcmCredential_STATUS{}), generators)

	return gcmCredential_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForGcmCredential_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForGcmCredential_STATUS(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(GcmCredentialProperties_STATUSGenerator())
}

func Test_MpnsCredential_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MpnsCredential to MpnsCredential via AssignProperties_To_MpnsCredential & AssignProperties_From_MpnsCredential returns original",
		prop.ForAll(RunPropertyAssignmentTestForMpnsCredential, MpnsCredentialGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMpnsCredential tests if a specific instance of MpnsCredential can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForMpnsCredential(subject MpnsCredential) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.MpnsCredential
	err := copied.AssignProperties_To_MpnsCredential(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual MpnsCredential
	err = actual.AssignProperties_From_MpnsCredential(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MpnsCredential_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MpnsCredential via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMpnsCredential, MpnsCredentialGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMpnsCredential runs a test to see if a specific instance of MpnsCredential round trips to JSON and back losslessly
func RunJSONSerializationTestForMpnsCredential(subject MpnsCredential) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MpnsCredential
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MpnsCredential instances for property testing - lazily instantiated by MpnsCredentialGenerator()
var mpnsCredentialGenerator gopter.Gen

// MpnsCredentialGenerator returns a generator of MpnsCredential instances for property testing.
func MpnsCredentialGenerator() gopter.Gen {
	if mpnsCredentialGenerator != nil {
		return mpnsCredentialGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForMpnsCredential(generators)
	mpnsCredentialGenerator = gen.Struct(reflect.TypeOf(MpnsCredential{}), generators)

	return mpnsCredentialGenerator
}

// AddRelatedPropertyGeneratorsForMpnsCredential is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMpnsCredential(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(MpnsCredentialPropertiesGenerator())
}

func Test_MpnsCredentialProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MpnsCredentialProperties to MpnsCredentialProperties via AssignProperties_To_MpnsCredentialProperties & AssignProperties_From_MpnsCredentialProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForMpnsCredentialProperties, MpnsCredentialPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMpnsCredentialProperties tests if a specific instance of MpnsCredentialProperties can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForMpnsCredentialProperties(subject MpnsCredentialProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.MpnsCredentialProperties
	err := copied.AssignProperties_To_MpnsCredentialProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual MpnsCredentialProperties
	err = actual.AssignProperties_From_MpnsCredentialProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MpnsCredentialProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MpnsCredentialProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMpnsCredentialProperties, MpnsCredentialPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMpnsCredentialProperties runs a test to see if a specific instance of MpnsCredentialProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForMpnsCredentialProperties(subject MpnsCredentialProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MpnsCredentialProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MpnsCredentialProperties instances for property testing - lazily instantiated by
// MpnsCredentialPropertiesGenerator()
var mpnsCredentialPropertiesGenerator gopter.Gen

// MpnsCredentialPropertiesGenerator returns a generator of MpnsCredentialProperties instances for property testing.
func MpnsCredentialPropertiesGenerator() gopter.Gen {
	if mpnsCredentialPropertiesGenerator != nil {
		return mpnsCredentialPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	mpnsCredentialPropertiesGenerator = gen.Struct(reflect.TypeOf(MpnsCredentialProperties{}), generators)

	return mpnsCredentialPropertiesGenerator
}

func Test_MpnsCredentialProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MpnsCredentialProperties_STATUS to MpnsCredentialProperties_STATUS via AssignProperties_To_MpnsCredentialProperties_STATUS & AssignProperties_From_MpnsCredentialProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForMpnsCredentialProperties_STATUS, MpnsCredentialProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMpnsCredentialProperties_STATUS tests if a specific instance of MpnsCredentialProperties_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForMpnsCredentialProperties_STATUS(subject MpnsCredentialProperties_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.MpnsCredentialProperties_STATUS
	err := copied.AssignProperties_To_MpnsCredentialProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual MpnsCredentialProperties_STATUS
	err = actual.AssignProperties_From_MpnsCredentialProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MpnsCredentialProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MpnsCredentialProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMpnsCredentialProperties_STATUS, MpnsCredentialProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMpnsCredentialProperties_STATUS runs a test to see if a specific instance of MpnsCredentialProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForMpnsCredentialProperties_STATUS(subject MpnsCredentialProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MpnsCredentialProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MpnsCredentialProperties_STATUS instances for property testing - lazily instantiated by
// MpnsCredentialProperties_STATUSGenerator()
var mpnsCredentialProperties_STATUSGenerator gopter.Gen

// MpnsCredentialProperties_STATUSGenerator returns a generator of MpnsCredentialProperties_STATUS instances for property testing.
func MpnsCredentialProperties_STATUSGenerator() gopter.Gen {
	if mpnsCredentialProperties_STATUSGenerator != nil {
		return mpnsCredentialProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	mpnsCredentialProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(MpnsCredentialProperties_STATUS{}), generators)

	return mpnsCredentialProperties_STATUSGenerator
}

func Test_MpnsCredential_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MpnsCredential_STATUS to MpnsCredential_STATUS via AssignProperties_To_MpnsCredential_STATUS & AssignProperties_From_MpnsCredential_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForMpnsCredential_STATUS, MpnsCredential_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMpnsCredential_STATUS tests if a specific instance of MpnsCredential_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForMpnsCredential_STATUS(subject MpnsCredential_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.MpnsCredential_STATUS
	err := copied.AssignProperties_To_MpnsCredential_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual MpnsCredential_STATUS
	err = actual.AssignProperties_From_MpnsCredential_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MpnsCredential_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MpnsCredential_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMpnsCredential_STATUS, MpnsCredential_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMpnsCredential_STATUS runs a test to see if a specific instance of MpnsCredential_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForMpnsCredential_STATUS(subject MpnsCredential_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MpnsCredential_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MpnsCredential_STATUS instances for property testing - lazily instantiated by
// MpnsCredential_STATUSGenerator()
var mpnsCredential_STATUSGenerator gopter.Gen

// MpnsCredential_STATUSGenerator returns a generator of MpnsCredential_STATUS instances for property testing.
func MpnsCredential_STATUSGenerator() gopter.Gen {
	if mpnsCredential_STATUSGenerator != nil {
		return mpnsCredential_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForMpnsCredential_STATUS(generators)
	mpnsCredential_STATUSGenerator = gen.Struct(reflect.TypeOf(MpnsCredential_STATUS{}), generators)

	return mpnsCredential_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForMpnsCredential_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMpnsCredential_STATUS(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(MpnsCredentialProperties_STATUSGenerator())
}

func Test_NotificationHub_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	parameters.MinSuccessfulTests = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NotificationHub to hub returns original",
		prop.ForAll(RunResourceConversionTestForNotificationHub, NotificationHubGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForNotificationHub tests if a specific instance of NotificationHub round trips to the hub storage version and back losslessly
func RunResourceConversionTestForNotificationHub(subject NotificationHub) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub storage.NotificationHub
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual NotificationHub
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NotificationHub_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NotificationHub to NotificationHub via AssignProperties_To_NotificationHub & AssignProperties_From_NotificationHub returns original",
		prop.ForAll(RunPropertyAssignmentTestForNotificationHub, NotificationHubGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNotificationHub tests if a specific instance of NotificationHub can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForNotificationHub(subject NotificationHub) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.NotificationHub
	err := copied.AssignProperties_To_NotificationHub(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NotificationHub
	err = actual.AssignProperties_From_NotificationHub(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NotificationHub_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NotificationHub via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNotificationHub, NotificationHubGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNotificationHub runs a test to see if a specific instance of NotificationHub round trips to JSON and back losslessly
func RunJSONSerializationTestForNotificationHub(subject NotificationHub) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NotificationHub
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NotificationHub instances for property testing - lazily instantiated by NotificationHubGenerator()
var notificationHubGenerator gopter.Gen

// NotificationHubGenerator returns a generator of NotificationHub instances for property testing.
func NotificationHubGenerator() gopter.Gen {
	if notificationHubGenerator != nil {
		return notificationHubGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForNotificationHub(generators)
	notificationHubGenerator = gen.Struct(reflect.TypeOf(NotificationHub{}), generators)

	return notificationHubGenerator
}

// AddRelatedPropertyGeneratorsForNotificationHub is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNotificationHub(gens map[string]gopter.Gen) {
	gens["Spec"] = NotificationHub_SpecGenerator()
	gens["Status"] = NotificationHub_STATUSGenerator()
}

func Test_NotificationHubOperatorSecrets_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NotificationHubOperatorSecrets to NotificationHubOperatorSecrets via AssignProperties_To_NotificationHubOperatorSecrets & AssignProperties_From_NotificationHubOperatorSecrets returns original",
		prop.ForAll(RunPropertyAssignmentTestForNotificationHubOperatorSecrets, NotificationHubOperatorSecretsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNotificationHubOperatorSecrets tests if a specific instance of NotificationHubOperatorSecrets can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForNotificationHubOperatorSecrets(subject NotificationHubOperatorSecrets) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.NotificationHubOperatorSecrets
	err := copied.AssignProperties_To_NotificationHubOperatorSecrets(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NotificationHubOperatorSecrets
	err = actual.AssignProperties_From_NotificationHubOperatorSecrets(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NotificationHubOperatorSecrets_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NotificationHubOperatorSecrets via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNotificationHubOperatorSecrets, NotificationHubOperatorSecretsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNotificationHubOperatorSecrets runs a test to see if a specific instance of NotificationHubOperatorSecrets round trips to JSON and back losslessly
func RunJSONSerializationTestForNotificationHubOperatorSecrets(subject NotificationHubOperatorSecrets) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NotificationHubOperatorSecrets
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NotificationHubOperatorSecrets instances for property testing - lazily instantiated by
// NotificationHubOperatorSecretsGenerator()
var notificationHubOperatorSecretsGenerator gopter.Gen

// NotificationHubOperatorSecretsGenerator returns a generator of NotificationHubOperatorSecrets instances for property testing.
func NotificationHubOperatorSecretsGenerator() gopter.Gen {
	if notificationHubOperatorSecretsGenerator != nil {
		return notificationHubOperatorSecretsGenerator
	}

	generators := make(map[string]gopter.Gen)
	notificationHubOperatorSecretsGenerator = gen.Struct(reflect.TypeOf(NotificationHubOperatorSecrets{}), generators)

	return notificationHubOperatorSecretsGenerator
}

func Test_NotificationHubOperatorSpec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NotificationHubOperatorSpec to NotificationHubOperatorSpec via AssignProperties_To_NotificationHubOperatorSpec & AssignProperties_From_NotificationHubOperatorSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForNotificationHubOperatorSpec, NotificationHubOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNotificationHubOperatorSpec tests if a specific instance of NotificationHubOperatorSpec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForNotificationHubOperatorSpec(subject NotificationHubOperatorSpec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.NotificationHubOperatorSpec
	err := copied.AssignProperties_To_NotificationHubOperatorSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NotificationHubOperatorSpec
	err = actual.AssignProperties_From_NotificationHubOperatorSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NotificationHubOperatorSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NotificationHubOperatorSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNotificationHubOperatorSpec, NotificationHubOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNotificationHubOperatorSpec runs a test to see if a specific instance of NotificationHubOperatorSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForNotificationHubOperatorSpec(subject NotificationHubOperatorSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NotificationHubOperatorSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NotificationHubOperatorSpec instances for property testing - lazily instantiated by
// NotificationHubOperatorSpecGenerator()
var notificationHubOperatorSpecGenerator gopter.Gen

// NotificationHubOperatorSpecGenerator returns a generator of NotificationHubOperatorSpec instances for property testing.
func NotificationHubOperatorSpecGenerator() gopter.Gen {
	if notificationHubOperatorSpecGenerator != nil {
		return notificationHubOperatorSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForNotificationHubOperatorSpec(generators)
	notificationHubOperatorSpecGenerator = gen.Struct(reflect.TypeOf(NotificationHubOperatorSpec{}), generators)

	return notificationHubOperatorSpecGenerator
}

// AddRelatedPropertyGeneratorsForNotificationHubOperatorSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNotificationHubOperatorSpec(gens map[string]gopter.Gen) {
	gens["Secrets"] = gen.PtrOf(NotificationHubOperatorSecretsGenerator())
}

func Test_NotificationHubProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NotificationHubProperties to NotificationHubProperties via AssignProperties_To_NotificationHubProperties & AssignProperties_From_NotificationHubProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForNotificationHubProperties, NotificationHubPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNotificationHubProperties tests if a specific instance of NotificationHubProperties can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForNotificationHubProperties(subject NotificationHubProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.NotificationHubProperties
	err := copied.AssignProperties_To_NotificationHubProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NotificationHubProperties
	err = actual.AssignProperties_From_NotificationHubProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NotificationHubProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NotificationHubProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNotificationHubProperties, NotificationHubPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNotificationHubProperties runs a test to see if a specific instance of NotificationHubProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForNotificationHubProperties(subject NotificationHubProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NotificationHubProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NotificationHubProperties instances for property testing - lazily instantiated by
// NotificationHubPropertiesGenerator()
var notificationHubPropertiesGenerator gopter.Gen

// NotificationHubPropertiesGenerator returns a generator of NotificationHubProperties instances for property testing.
// We first initialize notificationHubPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NotificationHubPropertiesGenerator() gopter.Gen {
	if notificationHubPropertiesGenerator != nil {
		return notificationHubPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNotificationHubProperties(generators)
	notificationHubPropertiesGenerator = gen.Struct(reflect.TypeOf(NotificationHubProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNotificationHubProperties(generators)
	AddRelatedPropertyGeneratorsForNotificationHubProperties(generators)
	notificationHubPropertiesGenerator = gen.Struct(reflect.TypeOf(NotificationHubProperties{}), generators)

	return notificationHubPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForNotificationHubProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNotificationHubProperties(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["RegistrationTtl"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNotificationHubProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNotificationHubProperties(gens map[string]gopter.Gen) {
	gens["AdmCredential"] = gen.PtrOf(AdmCredentialGenerator())
	gens["ApnsCredential"] = gen.PtrOf(ApnsCredentialGenerator())
	gens["BaiduCredential"] = gen.PtrOf(BaiduCredentialGenerator())
	gens["BrowserCredential"] = gen.PtrOf(BrowserCredentialGenerator())
	gens["GcmCredential"] = gen.PtrOf(GcmCredentialGenerator())
	gens["MpnsCredential"] = gen.PtrOf(MpnsCredentialGenerator())
	gens["WnsCredential"] = gen.PtrOf(WnsCredentialGenerator())
	gens["XiaomiCredential"] = gen.PtrOf(XiaomiCredentialGenerator())
}

func Test_NotificationHubProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NotificationHubProperties_STATUS to NotificationHubProperties_STATUS via AssignProperties_To_NotificationHubProperties_STATUS & AssignProperties_From_NotificationHubProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForNotificationHubProperties_STATUS, NotificationHubProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNotificationHubProperties_STATUS tests if a specific instance of NotificationHubProperties_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForNotificationHubProperties_STATUS(subject NotificationHubProperties_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.NotificationHubProperties_STATUS
	err := copied.AssignProperties_To_NotificationHubProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NotificationHubProperties_STATUS
	err = actual.AssignProperties_From_NotificationHubProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NotificationHubProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NotificationHubProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNotificationHubProperties_STATUS, NotificationHubProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNotificationHubProperties_STATUS runs a test to see if a specific instance of NotificationHubProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForNotificationHubProperties_STATUS(subject NotificationHubProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NotificationHubProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NotificationHubProperties_STATUS instances for property testing - lazily instantiated by
// NotificationHubProperties_STATUSGenerator()
var notificationHubProperties_STATUSGenerator gopter.Gen

// NotificationHubProperties_STATUSGenerator returns a generator of NotificationHubProperties_STATUS instances for property testing.
// We first initialize notificationHubProperties_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NotificationHubProperties_STATUSGenerator() gopter.Gen {
	if notificationHubProperties_STATUSGenerator != nil {
		return notificationHubProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNotificationHubProperties_STATUS(generators)
	notificationHubProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(NotificationHubProperties_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNotificationHubProperties_STATUS(generators)
	AddRelatedPropertyGeneratorsForNotificationHubProperties_STATUS(generators)
	notificationHubProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(NotificationHubProperties_STATUS{}), generators)

	return notificationHubProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForNotificationHubProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNotificationHubProperties_STATUS(gens map[string]gopter.Gen) {
	gens["DailyMaxActiveDevices"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["RegistrationTtl"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNotificationHubProperties_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNotificationHubProperties_STATUS(gens map[string]gopter.Gen) {
	gens["AdmCredential"] = gen.PtrOf(AdmCredential_STATUSGenerator())
	gens["ApnsCredential"] = gen.PtrOf(ApnsCredential_STATUSGenerator())
	gens["AuthorizationRules"] = gen.SliceOf(SharedAccessAuthorizationRuleProperties_STATUSGenerator())
	gens["BaiduCredential"] = gen.PtrOf(BaiduCredential_STATUSGenerator())
	gens["BrowserCredential"] = gen.PtrOf(BrowserCredential_STATUSGenerator())
	gens["GcmCredential"] = gen.PtrOf(GcmCredential_STATUSGenerator())
	gens["MpnsCredential"] = gen.PtrOf(MpnsCredential_STATUSGenerator())
	gens["WnsCredential"] = gen.PtrOf(WnsCredential_STATUSGenerator())
	gens["XiaomiCredential"] = gen.PtrOf(XiaomiCredential_STATUSGenerator())
}

func Test_NotificationHub_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NotificationHub_STATUS to NotificationHub_STATUS via AssignProperties_To_NotificationHub_STATUS & AssignProperties_From_NotificationHub_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForNotificationHub_STATUS, NotificationHub_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNotificationHub_STATUS tests if a specific instance of NotificationHub_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForNotificationHub_STATUS(subject NotificationHub_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.NotificationHub_STATUS
	err := copied.AssignProperties_To_NotificationHub_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NotificationHub_STATUS
	err = actual.AssignProperties_From_NotificationHub_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NotificationHub_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NotificationHub_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNotificationHub_STATUS, NotificationHub_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNotificationHub_STATUS runs a test to see if a specific instance of NotificationHub_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForNotificationHub_STATUS(subject NotificationHub_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NotificationHub_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NotificationHub_STATUS instances for property testing - lazily instantiated by
// NotificationHub_STATUSGenerator()
var notificationHub_STATUSGenerator gopter.Gen

// NotificationHub_STATUSGenerator returns a generator of NotificationHub_STATUS instances for property testing.
// We first initialize notificationHub_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NotificationHub_STATUSGenerator() gopter.Gen {
	if notificationHub_STATUSGenerator != nil {
		return notificationHub_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNotificationHub_STATUS(generators)
	notificationHub_STATUSGenerator = gen.Struct(reflect.TypeOf(NotificationHub_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNotificationHub_STATUS(generators)
	AddRelatedPropertyGeneratorsForNotificationHub_STATUS(generators)
	notificationHub_STATUSGenerator = gen.Struct(reflect.TypeOf(NotificationHub_STATUS{}), generators)

	return notificationHub_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForNotificationHub_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNotificationHub_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNotificationHub_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNotificationHub_STATUS(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(NotificationHubProperties_STATUSGenerator())
	gens["Sku"] = gen.PtrOf(Sku_STATUSGenerator())
	gens["SystemData"] = gen.PtrOf(SystemData_STATUSGenerator())
}

func Test_NotificationHub_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NotificationHub_Spec to NotificationHub_Spec via AssignProperties_To_NotificationHub_Spec & AssignProperties_From_NotificationHub_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForNotificationHub_Spec, NotificationHub_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNotificationHub_Spec tests if a specific instance of NotificationHub_Spec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForNotificationHub_Spec(subject NotificationHub_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.NotificationHub_Spec
	err := copied.AssignProperties_To_NotificationHub_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NotificationHub_Spec
	err = actual.AssignProperties_From_NotificationHub_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NotificationHub_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NotificationHub_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNotificationHub_Spec, NotificationHub_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNotificationHub_Spec runs a test to see if a specific instance of NotificationHub_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForNotificationHub_Spec(subject NotificationHub_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NotificationHub_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NotificationHub_Spec instances for property testing - lazily instantiated by
// NotificationHub_SpecGenerator()
var notificationHub_SpecGenerator gopter.Gen

// NotificationHub_SpecGenerator returns a generator of NotificationHub_Spec instances for property testing.
// We first initialize notificationHub_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NotificationHub_SpecGenerator() gopter.Gen {
	if notificationHub_SpecGenerator != nil {
		return notificationHub_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNotificationHub_Spec(generators)
	notificationHub_SpecGenerator = gen.Struct(reflect.TypeOf(NotificationHub_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNotificationHub_Spec(generators)
	AddRelatedPropertyGeneratorsForNotificationHub_Spec(generators)
	notificationHub_SpecGenerator = gen.Struct(reflect.TypeOf(NotificationHub_Spec{}), generators)

	return notificationHub_SpecGenerator
}

// AddIndependentPropertyGeneratorsForNotificationHub_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNotificationHub_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNotificationHub_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNotificationHub_Spec(gens map[string]gopter.Gen) {
	gens["OperatorSpec"] = gen.PtrOf(NotificationHubOperatorSpecGenerator())
	gens["Properties"] = gen.PtrOf(NotificationHubPropertiesGenerator())
	gens["Sku"] = gen.PtrOf(SkuGenerator())
}

func Test_WnsCredential_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WnsCredential to WnsCredential via AssignProperties_To_WnsCredential & AssignProperties_From_WnsCredential returns original",
		prop.ForAll(RunPropertyAssignmentTestForWnsCredential, WnsCredentialGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWnsCredential tests if a specific instance of WnsCredential can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWnsCredential(subject WnsCredential) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.WnsCredential
	err := copied.AssignProperties_To_WnsCredential(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WnsCredential
	err = actual.AssignProperties_From_WnsCredential(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WnsCredential_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WnsCredential via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWnsCredential, WnsCredentialGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWnsCredential runs a test to see if a specific instance of WnsCredential round trips to JSON and back losslessly
func RunJSONSerializationTestForWnsCredential(subject WnsCredential) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WnsCredential
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WnsCredential instances for property testing - lazily instantiated by WnsCredentialGenerator()
var wnsCredentialGenerator gopter.Gen

// WnsCredentialGenerator returns a generator of WnsCredential instances for property testing.
func WnsCredentialGenerator() gopter.Gen {
	if wnsCredentialGenerator != nil {
		return wnsCredentialGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForWnsCredential(generators)
	wnsCredentialGenerator = gen.Struct(reflect.TypeOf(WnsCredential{}), generators)

	return wnsCredentialGenerator
}

// AddRelatedPropertyGeneratorsForWnsCredential is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWnsCredential(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(WnsCredentialPropertiesGenerator())
}

func Test_WnsCredentialProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WnsCredentialProperties to WnsCredentialProperties via AssignProperties_To_WnsCredentialProperties & AssignProperties_From_WnsCredentialProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForWnsCredentialProperties, WnsCredentialPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWnsCredentialProperties tests if a specific instance of WnsCredentialProperties can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWnsCredentialProperties(subject WnsCredentialProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.WnsCredentialProperties
	err := copied.AssignProperties_To_WnsCredentialProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WnsCredentialProperties
	err = actual.AssignProperties_From_WnsCredentialProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WnsCredentialProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WnsCredentialProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWnsCredentialProperties, WnsCredentialPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWnsCredentialProperties runs a test to see if a specific instance of WnsCredentialProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForWnsCredentialProperties(subject WnsCredentialProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WnsCredentialProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WnsCredentialProperties instances for property testing - lazily instantiated by
// WnsCredentialPropertiesGenerator()
var wnsCredentialPropertiesGenerator gopter.Gen

// WnsCredentialPropertiesGenerator returns a generator of WnsCredentialProperties instances for property testing.
func WnsCredentialPropertiesGenerator() gopter.Gen {
	if wnsCredentialPropertiesGenerator != nil {
		return wnsCredentialPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	wnsCredentialPropertiesGenerator = gen.Struct(reflect.TypeOf(WnsCredentialProperties{}), generators)

	return wnsCredentialPropertiesGenerator
}

func Test_WnsCredentialProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WnsCredentialProperties_STATUS to WnsCredentialProperties_STATUS via AssignProperties_To_WnsCredentialProperties_STATUS & AssignProperties_From_WnsCredentialProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForWnsCredentialProperties_STATUS, WnsCredentialProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWnsCredentialProperties_STATUS tests if a specific instance of WnsCredentialProperties_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWnsCredentialProperties_STATUS(subject WnsCredentialProperties_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.WnsCredentialProperties_STATUS
	err := copied.AssignProperties_To_WnsCredentialProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WnsCredentialProperties_STATUS
	err = actual.AssignProperties_From_WnsCredentialProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WnsCredentialProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WnsCredentialProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWnsCredentialProperties_STATUS, WnsCredentialProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWnsCredentialProperties_STATUS runs a test to see if a specific instance of WnsCredentialProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForWnsCredentialProperties_STATUS(subject WnsCredentialProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WnsCredentialProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WnsCredentialProperties_STATUS instances for property testing - lazily instantiated by
// WnsCredentialProperties_STATUSGenerator()
var wnsCredentialProperties_STATUSGenerator gopter.Gen

// WnsCredentialProperties_STATUSGenerator returns a generator of WnsCredentialProperties_STATUS instances for property testing.
func WnsCredentialProperties_STATUSGenerator() gopter.Gen {
	if wnsCredentialProperties_STATUSGenerator != nil {
		return wnsCredentialProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	wnsCredentialProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(WnsCredentialProperties_STATUS{}), generators)

	return wnsCredentialProperties_STATUSGenerator
}

func Test_WnsCredential_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WnsCredential_STATUS to WnsCredential_STATUS via AssignProperties_To_WnsCredential_STATUS & AssignProperties_From_WnsCredential_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForWnsCredential_STATUS, WnsCredential_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWnsCredential_STATUS tests if a specific instance of WnsCredential_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWnsCredential_STATUS(subject WnsCredential_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.WnsCredential_STATUS
	err := copied.AssignProperties_To_WnsCredential_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WnsCredential_STATUS
	err = actual.AssignProperties_From_WnsCredential_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WnsCredential_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WnsCredential_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWnsCredential_STATUS, WnsCredential_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWnsCredential_STATUS runs a test to see if a specific instance of WnsCredential_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForWnsCredential_STATUS(subject WnsCredential_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WnsCredential_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WnsCredential_STATUS instances for property testing - lazily instantiated by
// WnsCredential_STATUSGenerator()
var wnsCredential_STATUSGenerator gopter.Gen

// WnsCredential_STATUSGenerator returns a generator of WnsCredential_STATUS instances for property testing.
func WnsCredential_STATUSGenerator() gopter.Gen {
	if wnsCredential_STATUSGenerator != nil {
		return wnsCredential_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForWnsCredential_STATUS(generators)
	wnsCredential_STATUSGenerator = gen.Struct(reflect.TypeOf(WnsCredential_STATUS{}), generators)

	return wnsCredential_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForWnsCredential_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWnsCredential_STATUS(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(WnsCredentialProperties_STATUSGenerator())
}

func Test_XiaomiCredential_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from XiaomiCredential to XiaomiCredential via AssignProperties_To_XiaomiCredential & AssignProperties_From_XiaomiCredential returns original",
		prop.ForAll(RunPropertyAssignmentTestForXiaomiCredential, XiaomiCredentialGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForXiaomiCredential tests if a specific instance of XiaomiCredential can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForXiaomiCredential(subject XiaomiCredential) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.XiaomiCredential
	err := copied.AssignProperties_To_XiaomiCredential(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual XiaomiCredential
	err = actual.AssignProperties_From_XiaomiCredential(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_XiaomiCredential_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of XiaomiCredential via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForXiaomiCredential, XiaomiCredentialGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForXiaomiCredential runs a test to see if a specific instance of XiaomiCredential round trips to JSON and back losslessly
func RunJSONSerializationTestForXiaomiCredential(subject XiaomiCredential) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual XiaomiCredential
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of XiaomiCredential instances for property testing - lazily instantiated by XiaomiCredentialGenerator()
var xiaomiCredentialGenerator gopter.Gen

// XiaomiCredentialGenerator returns a generator of XiaomiCredential instances for property testing.
func XiaomiCredentialGenerator() gopter.Gen {
	if xiaomiCredentialGenerator != nil {
		return xiaomiCredentialGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForXiaomiCredential(generators)
	xiaomiCredentialGenerator = gen.Struct(reflect.TypeOf(XiaomiCredential{}), generators)

	return xiaomiCredentialGenerator
}

// AddRelatedPropertyGeneratorsForXiaomiCredential is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForXiaomiCredential(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(XiaomiCredentialPropertiesGenerator())
}

func Test_XiaomiCredentialProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from XiaomiCredentialProperties to XiaomiCredentialProperties via AssignProperties_To_XiaomiCredentialProperties & AssignProperties_From_XiaomiCredentialProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForXiaomiCredentialProperties, XiaomiCredentialPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForXiaomiCredentialProperties tests if a specific instance of XiaomiCredentialProperties can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForXiaomiCredentialProperties(subject XiaomiCredentialProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.XiaomiCredentialProperties
	err := copied.AssignProperties_To_XiaomiCredentialProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual XiaomiCredentialProperties
	err = actual.AssignProperties_From_XiaomiCredentialProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_XiaomiCredentialProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of XiaomiCredentialProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForXiaomiCredentialProperties, XiaomiCredentialPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForXiaomiCredentialProperties runs a test to see if a specific instance of XiaomiCredentialProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForXiaomiCredentialProperties(subject XiaomiCredentialProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual XiaomiCredentialProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of XiaomiCredentialProperties instances for property testing - lazily instantiated by
// XiaomiCredentialPropertiesGenerator()
var xiaomiCredentialPropertiesGenerator gopter.Gen

// XiaomiCredentialPropertiesGenerator returns a generator of XiaomiCredentialProperties instances for property testing.
func XiaomiCredentialPropertiesGenerator() gopter.Gen {
	if xiaomiCredentialPropertiesGenerator != nil {
		return xiaomiCredentialPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	xiaomiCredentialPropertiesGenerator = gen.Struct(reflect.TypeOf(XiaomiCredentialProperties{}), generators)

	return xiaomiCredentialPropertiesGenerator
}

func Test_XiaomiCredentialProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from XiaomiCredentialProperties_STATUS to XiaomiCredentialProperties_STATUS via AssignProperties_To_XiaomiCredentialProperties_STATUS & AssignProperties_From_XiaomiCredentialProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForXiaomiCredentialProperties_STATUS, XiaomiCredentialProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForXiaomiCredentialProperties_STATUS tests if a specific instance of XiaomiCredentialProperties_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForXiaomiCredentialProperties_STATUS(subject XiaomiCredentialProperties_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.XiaomiCredentialProperties_STATUS
	err := copied.AssignProperties_To_XiaomiCredentialProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual XiaomiCredentialProperties_STATUS
	err = actual.AssignProperties_From_XiaomiCredentialProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_XiaomiCredentialProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of XiaomiCredentialProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForXiaomiCredentialProperties_STATUS, XiaomiCredentialProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForXiaomiCredentialProperties_STATUS runs a test to see if a specific instance of XiaomiCredentialProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForXiaomiCredentialProperties_STATUS(subject XiaomiCredentialProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual XiaomiCredentialProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of XiaomiCredentialProperties_STATUS instances for property testing - lazily instantiated by
// XiaomiCredentialProperties_STATUSGenerator()
var xiaomiCredentialProperties_STATUSGenerator gopter.Gen

// XiaomiCredentialProperties_STATUSGenerator returns a generator of XiaomiCredentialProperties_STATUS instances for property testing.
func XiaomiCredentialProperties_STATUSGenerator() gopter.Gen {
	if xiaomiCredentialProperties_STATUSGenerator != nil {
		return xiaomiCredentialProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	xiaomiCredentialProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(XiaomiCredentialProperties_STATUS{}), generators)

	return xiaomiCredentialProperties_STATUSGenerator
}

func Test_XiaomiCredential_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from XiaomiCredential_STATUS to XiaomiCredential_STATUS via AssignProperties_To_XiaomiCredential_STATUS & AssignProperties_From_XiaomiCredential_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForXiaomiCredential_STATUS, XiaomiCredential_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForXiaomiCredential_STATUS tests if a specific instance of XiaomiCredential_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForXiaomiCredential_STATUS(subject XiaomiCredential_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.XiaomiCredential_STATUS
	err := copied.AssignProperties_To_XiaomiCredential_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual XiaomiCredential_STATUS
	err = actual.AssignProperties_From_XiaomiCredential_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_XiaomiCredential_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of XiaomiCredential_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForXiaomiCredential_STATUS, XiaomiCredential_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForXiaomiCredential_STATUS runs a test to see if a specific instance of XiaomiCredential_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForXiaomiCredential_STATUS(subject XiaomiCredential_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual XiaomiCredential_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of XiaomiCredential_STATUS instances for property testing - lazily instantiated by
// XiaomiCredential_STATUSGenerator()
var xiaomiCredential_STATUSGenerator gopter.Gen

// XiaomiCredential_STATUSGenerator returns a generator of XiaomiCredential_STATUS instances for property testing.
func XiaomiCredential_STATUSGenerator() gopter.Gen {
	if xiaomiCredential_STATUSGenerator != nil {
		return xiaomiCredential_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForXiaomiCredential_STATUS(generators)
	xiaomiCredential_STATUSGenerator = gen.Struct(reflect.TypeOf(XiaomiCredential_STATUS{}), generators)

	return xiaomiCredential_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForXiaomiCredential_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForXiaomiCredential_STATUS(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(XiaomiCredentialProperties_STATUSGenerator())
}
