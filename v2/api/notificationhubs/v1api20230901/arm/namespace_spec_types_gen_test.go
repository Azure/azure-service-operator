// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package arm

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_IpRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpRule, IpRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpRule runs a test to see if a specific instance of IpRule round trips to JSON and back losslessly
func RunJSONSerializationTestForIpRule(subject IpRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpRule instances for property testing - lazily instantiated by IpRuleGenerator()
var ipRuleGenerator gopter.Gen

// IpRuleGenerator returns a generator of IpRule instances for property testing.
func IpRuleGenerator() gopter.Gen {
	if ipRuleGenerator != nil {
		return ipRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpRule(generators)
	ipRuleGenerator = gen.Struct(reflect.TypeOf(IpRule{}), generators)

	return ipRuleGenerator
}

// AddIndependentPropertyGeneratorsForIpRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpRule(gens map[string]gopter.Gen) {
	gens["IpMask"] = gen.PtrOf(gen.AlphaString())
	gens["Rights"] = gen.SliceOf(gen.OneConstOf(AccessRights_Listen, AccessRights_Manage, AccessRights_Send))
}

func Test_NamespaceProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NamespaceProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNamespaceProperties, NamespacePropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNamespaceProperties runs a test to see if a specific instance of NamespaceProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForNamespaceProperties(subject NamespaceProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NamespaceProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NamespaceProperties instances for property testing - lazily instantiated by
// NamespacePropertiesGenerator()
var namespacePropertiesGenerator gopter.Gen

// NamespacePropertiesGenerator returns a generator of NamespaceProperties instances for property testing.
// We first initialize namespacePropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NamespacePropertiesGenerator() gopter.Gen {
	if namespacePropertiesGenerator != nil {
		return namespacePropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNamespaceProperties(generators)
	namespacePropertiesGenerator = gen.Struct(reflect.TypeOf(NamespaceProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNamespaceProperties(generators)
	AddRelatedPropertyGeneratorsForNamespaceProperties(generators)
	namespacePropertiesGenerator = gen.Struct(reflect.TypeOf(NamespaceProperties{}), generators)

	return namespacePropertiesGenerator
}

// AddIndependentPropertyGeneratorsForNamespaceProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNamespaceProperties(gens map[string]gopter.Gen) {
	gens["DataCenter"] = gen.PtrOf(gen.AlphaString())
	gens["NamespaceType"] = gen.PtrOf(gen.OneConstOf(NamespaceType_Messaging, NamespaceType_NotificationHub))
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(PublicNetworkAccess_Disabled, PublicNetworkAccess_Enabled))
	gens["ReplicationRegion"] = gen.PtrOf(gen.OneConstOf(
		ReplicationRegion_AustraliaEast,
		ReplicationRegion_BrazilSouth,
		ReplicationRegion_Default,
		ReplicationRegion_None,
		ReplicationRegion_NorthEurope,
		ReplicationRegion_SouthAfricaNorth,
		ReplicationRegion_SouthEastAsia,
		ReplicationRegion_WestUs2))
	gens["ScaleUnit"] = gen.PtrOf(gen.AlphaString())
	gens["ZoneRedundancy"] = gen.PtrOf(gen.OneConstOf(ZoneRedundancyPreference_Disabled, ZoneRedundancyPreference_Enabled))
}

// AddRelatedPropertyGeneratorsForNamespaceProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNamespaceProperties(gens map[string]gopter.Gen) {
	gens["NetworkAcls"] = gen.PtrOf(NetworkAclsGenerator())
	gens["PnsCredentials"] = gen.PtrOf(PnsCredentialsGenerator())
}

func Test_Namespace_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Namespace_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNamespace_Spec, Namespace_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNamespace_Spec runs a test to see if a specific instance of Namespace_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForNamespace_Spec(subject Namespace_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Namespace_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Namespace_Spec instances for property testing - lazily instantiated by Namespace_SpecGenerator()
var namespace_SpecGenerator gopter.Gen

// Namespace_SpecGenerator returns a generator of Namespace_Spec instances for property testing.
// We first initialize namespace_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Namespace_SpecGenerator() gopter.Gen {
	if namespace_SpecGenerator != nil {
		return namespace_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNamespace_Spec(generators)
	namespace_SpecGenerator = gen.Struct(reflect.TypeOf(Namespace_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNamespace_Spec(generators)
	AddRelatedPropertyGeneratorsForNamespace_Spec(generators)
	namespace_SpecGenerator = gen.Struct(reflect.TypeOf(Namespace_Spec{}), generators)

	return namespace_SpecGenerator
}

// AddIndependentPropertyGeneratorsForNamespace_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNamespace_Spec(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNamespace_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNamespace_Spec(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(NamespacePropertiesGenerator())
	gens["Sku"] = gen.PtrOf(SkuGenerator())
}

func Test_NetworkAcls_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkAcls via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkAcls, NetworkAclsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkAcls runs a test to see if a specific instance of NetworkAcls round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkAcls(subject NetworkAcls) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkAcls
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkAcls instances for property testing - lazily instantiated by NetworkAclsGenerator()
var networkAclsGenerator gopter.Gen

// NetworkAclsGenerator returns a generator of NetworkAcls instances for property testing.
func NetworkAclsGenerator() gopter.Gen {
	if networkAclsGenerator != nil {
		return networkAclsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForNetworkAcls(generators)
	networkAclsGenerator = gen.Struct(reflect.TypeOf(NetworkAcls{}), generators)

	return networkAclsGenerator
}

// AddRelatedPropertyGeneratorsForNetworkAcls is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkAcls(gens map[string]gopter.Gen) {
	gens["IpRules"] = gen.SliceOf(IpRuleGenerator())
	gens["PublicNetworkRule"] = gen.PtrOf(PublicInternetAuthorizationRuleGenerator())
}

func Test_PnsCredentials_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PnsCredentials via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPnsCredentials, PnsCredentialsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPnsCredentials runs a test to see if a specific instance of PnsCredentials round trips to JSON and back losslessly
func RunJSONSerializationTestForPnsCredentials(subject PnsCredentials) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PnsCredentials
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PnsCredentials instances for property testing - lazily instantiated by PnsCredentialsGenerator()
var pnsCredentialsGenerator gopter.Gen

// PnsCredentialsGenerator returns a generator of PnsCredentials instances for property testing.
func PnsCredentialsGenerator() gopter.Gen {
	if pnsCredentialsGenerator != nil {
		return pnsCredentialsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForPnsCredentials(generators)
	pnsCredentialsGenerator = gen.Struct(reflect.TypeOf(PnsCredentials{}), generators)

	return pnsCredentialsGenerator
}

// AddRelatedPropertyGeneratorsForPnsCredentials is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPnsCredentials(gens map[string]gopter.Gen) {
	gens["AdmCredential"] = gen.PtrOf(AdmCredentialGenerator())
	gens["ApnsCredential"] = gen.PtrOf(ApnsCredentialGenerator())
	gens["BaiduCredential"] = gen.PtrOf(BaiduCredentialGenerator())
	gens["BrowserCredential"] = gen.PtrOf(BrowserCredentialGenerator())
	gens["GcmCredential"] = gen.PtrOf(GcmCredentialGenerator())
	gens["MpnsCredential"] = gen.PtrOf(MpnsCredentialGenerator())
	gens["WnsCredential"] = gen.PtrOf(WnsCredentialGenerator())
	gens["XiaomiCredential"] = gen.PtrOf(XiaomiCredentialGenerator())
}

func Test_PublicInternetAuthorizationRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicInternetAuthorizationRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicInternetAuthorizationRule, PublicInternetAuthorizationRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicInternetAuthorizationRule runs a test to see if a specific instance of PublicInternetAuthorizationRule round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicInternetAuthorizationRule(subject PublicInternetAuthorizationRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicInternetAuthorizationRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicInternetAuthorizationRule instances for property testing - lazily instantiated by
// PublicInternetAuthorizationRuleGenerator()
var publicInternetAuthorizationRuleGenerator gopter.Gen

// PublicInternetAuthorizationRuleGenerator returns a generator of PublicInternetAuthorizationRule instances for property testing.
func PublicInternetAuthorizationRuleGenerator() gopter.Gen {
	if publicInternetAuthorizationRuleGenerator != nil {
		return publicInternetAuthorizationRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicInternetAuthorizationRule(generators)
	publicInternetAuthorizationRuleGenerator = gen.Struct(reflect.TypeOf(PublicInternetAuthorizationRule{}), generators)

	return publicInternetAuthorizationRuleGenerator
}

// AddIndependentPropertyGeneratorsForPublicInternetAuthorizationRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicInternetAuthorizationRule(gens map[string]gopter.Gen) {
	gens["Rights"] = gen.SliceOf(gen.OneConstOf(AccessRights_Listen, AccessRights_Manage, AccessRights_Send))
}

func Test_Sku_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sku via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSku, SkuGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSku runs a test to see if a specific instance of Sku round trips to JSON and back losslessly
func RunJSONSerializationTestForSku(subject Sku) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sku
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sku instances for property testing - lazily instantiated by SkuGenerator()
var skuGenerator gopter.Gen

// SkuGenerator returns a generator of Sku instances for property testing.
func SkuGenerator() gopter.Gen {
	if skuGenerator != nil {
		return skuGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSku(generators)
	skuGenerator = gen.Struct(reflect.TypeOf(Sku{}), generators)

	return skuGenerator
}

// AddIndependentPropertyGeneratorsForSku is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSku(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Family"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.OneConstOf(SkuName_Basic, SkuName_Free, SkuName_Standard))
	gens["Size"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
}
