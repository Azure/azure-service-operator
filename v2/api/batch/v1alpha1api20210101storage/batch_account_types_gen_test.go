// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20210101storage

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_BatchAccount_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BatchAccount via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBatchAccount, BatchAccountGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBatchAccount runs a test to see if a specific instance of BatchAccount round trips to JSON and back losslessly
func RunJSONSerializationTestForBatchAccount(subject BatchAccount) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BatchAccount
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BatchAccount instances for property testing - lazily instantiated by BatchAccountGenerator()
var batchAccountGenerator gopter.Gen

// BatchAccountGenerator returns a generator of BatchAccount instances for property testing.
func BatchAccountGenerator() gopter.Gen {
	if batchAccountGenerator != nil {
		return batchAccountGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForBatchAccount(generators)
	batchAccountGenerator = gen.Struct(reflect.TypeOf(BatchAccount{}), generators)

	return batchAccountGenerator
}

// AddRelatedPropertyGeneratorsForBatchAccount is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBatchAccount(gens map[string]gopter.Gen) {
	gens["Spec"] = BatchAccounts_SPECGenerator()
	gens["Status"] = BatchAccount_StatusGenerator()
}

func Test_BatchAccount_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BatchAccount_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBatchAccount_Status, BatchAccount_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBatchAccount_Status runs a test to see if a specific instance of BatchAccount_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForBatchAccount_Status(subject BatchAccount_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BatchAccount_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BatchAccount_Status instances for property testing - lazily instantiated by
//BatchAccount_StatusGenerator()
var batchAccount_statusGenerator gopter.Gen

// BatchAccount_StatusGenerator returns a generator of BatchAccount_Status instances for property testing.
// We first initialize batchAccount_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BatchAccount_StatusGenerator() gopter.Gen {
	if batchAccount_statusGenerator != nil {
		return batchAccount_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccount_Status(generators)
	batchAccount_statusGenerator = gen.Struct(reflect.TypeOf(BatchAccount_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccount_Status(generators)
	AddRelatedPropertyGeneratorsForBatchAccount_Status(generators)
	batchAccount_statusGenerator = gen.Struct(reflect.TypeOf(BatchAccount_Status{}), generators)

	return batchAccount_statusGenerator
}

// AddIndependentPropertyGeneratorsForBatchAccount_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBatchAccount_Status(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["PoolAllocationMode"] = gen.PtrOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForBatchAccount_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBatchAccount_Status(gens map[string]gopter.Gen) {
	gens["AutoStorage"] = gen.PtrOf(AutoStorageBaseProperties_StatusGenerator())
	gens["Encryption"] = gen.PtrOf(EncryptionProperties_StatusGenerator())
	gens["Identity"] = gen.PtrOf(BatchAccountIdentity_StatusGenerator())
	gens["KeyVaultReference"] = gen.PtrOf(KeyVaultReference_StatusGenerator())
}

func Test_BatchAccounts_SPEC_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BatchAccounts_SPEC via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBatchAccounts_SPEC, BatchAccounts_SPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBatchAccounts_SPEC runs a test to see if a specific instance of BatchAccounts_SPEC round trips to JSON and back losslessly
func RunJSONSerializationTestForBatchAccounts_SPEC(subject BatchAccounts_SPEC) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BatchAccounts_SPEC
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BatchAccounts_SPEC instances for property testing - lazily instantiated by BatchAccounts_SPECGenerator()
var batchAccounts_specGenerator gopter.Gen

// BatchAccounts_SPECGenerator returns a generator of BatchAccounts_SPEC instances for property testing.
// We first initialize batchAccounts_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BatchAccounts_SPECGenerator() gopter.Gen {
	if batchAccounts_specGenerator != nil {
		return batchAccounts_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccounts_SPEC(generators)
	batchAccounts_specGenerator = gen.Struct(reflect.TypeOf(BatchAccounts_SPEC{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccounts_SPEC(generators)
	AddRelatedPropertyGeneratorsForBatchAccounts_SPEC(generators)
	batchAccounts_specGenerator = gen.Struct(reflect.TypeOf(BatchAccounts_SPEC{}), generators)

	return batchAccounts_specGenerator
}

// AddIndependentPropertyGeneratorsForBatchAccounts_SPEC is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBatchAccounts_SPEC(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["OriginalVersion"] = gen.AlphaString()
	gens["PoolAllocationMode"] = gen.PtrOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForBatchAccounts_SPEC is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBatchAccounts_SPEC(gens map[string]gopter.Gen) {
	gens["AutoStorage"] = gen.PtrOf(AutoStorageBaseProperties_SpecGenerator())
	gens["Encryption"] = gen.PtrOf(EncryptionProperties_SpecGenerator())
	gens["Identity"] = gen.PtrOf(BatchAccountIdentity_SpecGenerator())
	gens["KeyVaultReference"] = gen.PtrOf(KeyVaultReference_SpecGenerator())
}

func Test_AutoStorageBaseProperties_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoStorageBaseProperties_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoStorageBaseProperties_Spec, AutoStorageBaseProperties_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoStorageBaseProperties_Spec runs a test to see if a specific instance of AutoStorageBaseProperties_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoStorageBaseProperties_Spec(subject AutoStorageBaseProperties_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoStorageBaseProperties_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoStorageBaseProperties_Spec instances for property testing - lazily instantiated by
//AutoStorageBaseProperties_SpecGenerator()
var autoStorageBaseProperties_specGenerator gopter.Gen

// AutoStorageBaseProperties_SpecGenerator returns a generator of AutoStorageBaseProperties_Spec instances for property testing.
func AutoStorageBaseProperties_SpecGenerator() gopter.Gen {
	if autoStorageBaseProperties_specGenerator != nil {
		return autoStorageBaseProperties_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	autoStorageBaseProperties_specGenerator = gen.Struct(reflect.TypeOf(AutoStorageBaseProperties_Spec{}), generators)

	return autoStorageBaseProperties_specGenerator
}

func Test_AutoStorageBaseProperties_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoStorageBaseProperties_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoStorageBaseProperties_Status, AutoStorageBaseProperties_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoStorageBaseProperties_Status runs a test to see if a specific instance of AutoStorageBaseProperties_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoStorageBaseProperties_Status(subject AutoStorageBaseProperties_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoStorageBaseProperties_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoStorageBaseProperties_Status instances for property testing - lazily instantiated by
//AutoStorageBaseProperties_StatusGenerator()
var autoStorageBaseProperties_statusGenerator gopter.Gen

// AutoStorageBaseProperties_StatusGenerator returns a generator of AutoStorageBaseProperties_Status instances for property testing.
func AutoStorageBaseProperties_StatusGenerator() gopter.Gen {
	if autoStorageBaseProperties_statusGenerator != nil {
		return autoStorageBaseProperties_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoStorageBaseProperties_Status(generators)
	autoStorageBaseProperties_statusGenerator = gen.Struct(reflect.TypeOf(AutoStorageBaseProperties_Status{}), generators)

	return autoStorageBaseProperties_statusGenerator
}

// AddIndependentPropertyGeneratorsForAutoStorageBaseProperties_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoStorageBaseProperties_Status(gens map[string]gopter.Gen) {
	gens["StorageAccountId"] = gen.PtrOf(gen.AlphaString())
}

func Test_BatchAccountIdentity_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BatchAccountIdentity_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBatchAccountIdentity_Spec, BatchAccountIdentity_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBatchAccountIdentity_Spec runs a test to see if a specific instance of BatchAccountIdentity_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForBatchAccountIdentity_Spec(subject BatchAccountIdentity_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BatchAccountIdentity_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BatchAccountIdentity_Spec instances for property testing - lazily instantiated by
//BatchAccountIdentity_SpecGenerator()
var batchAccountIdentity_specGenerator gopter.Gen

// BatchAccountIdentity_SpecGenerator returns a generator of BatchAccountIdentity_Spec instances for property testing.
func BatchAccountIdentity_SpecGenerator() gopter.Gen {
	if batchAccountIdentity_specGenerator != nil {
		return batchAccountIdentity_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccountIdentity_Spec(generators)
	batchAccountIdentity_specGenerator = gen.Struct(reflect.TypeOf(BatchAccountIdentity_Spec{}), generators)

	return batchAccountIdentity_specGenerator
}

// AddIndependentPropertyGeneratorsForBatchAccountIdentity_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBatchAccountIdentity_Spec(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_BatchAccountIdentity_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BatchAccountIdentity_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBatchAccountIdentity_Status, BatchAccountIdentity_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBatchAccountIdentity_Status runs a test to see if a specific instance of BatchAccountIdentity_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForBatchAccountIdentity_Status(subject BatchAccountIdentity_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BatchAccountIdentity_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BatchAccountIdentity_Status instances for property testing - lazily instantiated by
//BatchAccountIdentity_StatusGenerator()
var batchAccountIdentity_statusGenerator gopter.Gen

// BatchAccountIdentity_StatusGenerator returns a generator of BatchAccountIdentity_Status instances for property testing.
// We first initialize batchAccountIdentity_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BatchAccountIdentity_StatusGenerator() gopter.Gen {
	if batchAccountIdentity_statusGenerator != nil {
		return batchAccountIdentity_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccountIdentity_Status(generators)
	batchAccountIdentity_statusGenerator = gen.Struct(reflect.TypeOf(BatchAccountIdentity_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccountIdentity_Status(generators)
	AddRelatedPropertyGeneratorsForBatchAccountIdentity_Status(generators)
	batchAccountIdentity_statusGenerator = gen.Struct(reflect.TypeOf(BatchAccountIdentity_Status{}), generators)

	return batchAccountIdentity_statusGenerator
}

// AddIndependentPropertyGeneratorsForBatchAccountIdentity_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBatchAccountIdentity_Status(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForBatchAccountIdentity_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBatchAccountIdentity_Status(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), BatchAccountIdentity_UserAssignedIdentities_StatusGenerator())
}

func Test_EncryptionProperties_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionProperties_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionProperties_Spec, EncryptionProperties_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionProperties_Spec runs a test to see if a specific instance of EncryptionProperties_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionProperties_Spec(subject EncryptionProperties_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionProperties_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionProperties_Spec instances for property testing - lazily instantiated by
//EncryptionProperties_SpecGenerator()
var encryptionProperties_specGenerator gopter.Gen

// EncryptionProperties_SpecGenerator returns a generator of EncryptionProperties_Spec instances for property testing.
// We first initialize encryptionProperties_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EncryptionProperties_SpecGenerator() gopter.Gen {
	if encryptionProperties_specGenerator != nil {
		return encryptionProperties_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionProperties_Spec(generators)
	encryptionProperties_specGenerator = gen.Struct(reflect.TypeOf(EncryptionProperties_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionProperties_Spec(generators)
	AddRelatedPropertyGeneratorsForEncryptionProperties_Spec(generators)
	encryptionProperties_specGenerator = gen.Struct(reflect.TypeOf(EncryptionProperties_Spec{}), generators)

	return encryptionProperties_specGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionProperties_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionProperties_Spec(gens map[string]gopter.Gen) {
	gens["KeySource"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEncryptionProperties_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionProperties_Spec(gens map[string]gopter.Gen) {
	gens["KeyVaultProperties"] = gen.PtrOf(KeyVaultProperties_SpecGenerator())
}

func Test_EncryptionProperties_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionProperties_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionProperties_Status, EncryptionProperties_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionProperties_Status runs a test to see if a specific instance of EncryptionProperties_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionProperties_Status(subject EncryptionProperties_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionProperties_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionProperties_Status instances for property testing - lazily instantiated by
//EncryptionProperties_StatusGenerator()
var encryptionProperties_statusGenerator gopter.Gen

// EncryptionProperties_StatusGenerator returns a generator of EncryptionProperties_Status instances for property testing.
// We first initialize encryptionProperties_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EncryptionProperties_StatusGenerator() gopter.Gen {
	if encryptionProperties_statusGenerator != nil {
		return encryptionProperties_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionProperties_Status(generators)
	encryptionProperties_statusGenerator = gen.Struct(reflect.TypeOf(EncryptionProperties_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionProperties_Status(generators)
	AddRelatedPropertyGeneratorsForEncryptionProperties_Status(generators)
	encryptionProperties_statusGenerator = gen.Struct(reflect.TypeOf(EncryptionProperties_Status{}), generators)

	return encryptionProperties_statusGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionProperties_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionProperties_Status(gens map[string]gopter.Gen) {
	gens["KeySource"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEncryptionProperties_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionProperties_Status(gens map[string]gopter.Gen) {
	gens["KeyVaultProperties"] = gen.PtrOf(KeyVaultProperties_StatusGenerator())
}

func Test_KeyVaultReference_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultReference_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultReference_Spec, KeyVaultReference_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultReference_Spec runs a test to see if a specific instance of KeyVaultReference_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultReference_Spec(subject KeyVaultReference_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultReference_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultReference_Spec instances for property testing - lazily instantiated by
//KeyVaultReference_SpecGenerator()
var keyVaultReference_specGenerator gopter.Gen

// KeyVaultReference_SpecGenerator returns a generator of KeyVaultReference_Spec instances for property testing.
func KeyVaultReference_SpecGenerator() gopter.Gen {
	if keyVaultReference_specGenerator != nil {
		return keyVaultReference_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultReference_Spec(generators)
	keyVaultReference_specGenerator = gen.Struct(reflect.TypeOf(KeyVaultReference_Spec{}), generators)

	return keyVaultReference_specGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultReference_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultReference_Spec(gens map[string]gopter.Gen) {
	gens["Url"] = gen.PtrOf(gen.AlphaString())
}

func Test_KeyVaultReference_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultReference_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultReference_Status, KeyVaultReference_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultReference_Status runs a test to see if a specific instance of KeyVaultReference_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultReference_Status(subject KeyVaultReference_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultReference_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultReference_Status instances for property testing - lazily instantiated by
//KeyVaultReference_StatusGenerator()
var keyVaultReference_statusGenerator gopter.Gen

// KeyVaultReference_StatusGenerator returns a generator of KeyVaultReference_Status instances for property testing.
func KeyVaultReference_StatusGenerator() gopter.Gen {
	if keyVaultReference_statusGenerator != nil {
		return keyVaultReference_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultReference_Status(generators)
	keyVaultReference_statusGenerator = gen.Struct(reflect.TypeOf(KeyVaultReference_Status{}), generators)

	return keyVaultReference_statusGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultReference_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultReference_Status(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Url"] = gen.PtrOf(gen.AlphaString())
}

func Test_BatchAccountIdentity_UserAssignedIdentities_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BatchAccountIdentity_UserAssignedIdentities_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBatchAccountIdentity_UserAssignedIdentities_Status, BatchAccountIdentity_UserAssignedIdentities_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBatchAccountIdentity_UserAssignedIdentities_Status runs a test to see if a specific instance of BatchAccountIdentity_UserAssignedIdentities_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForBatchAccountIdentity_UserAssignedIdentities_Status(subject BatchAccountIdentity_UserAssignedIdentities_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BatchAccountIdentity_UserAssignedIdentities_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BatchAccountIdentity_UserAssignedIdentities_Status instances for property testing - lazily instantiated
//by BatchAccountIdentity_UserAssignedIdentities_StatusGenerator()
var batchAccountIdentity_userAssignedIdentities_statusGenerator gopter.Gen

// BatchAccountIdentity_UserAssignedIdentities_StatusGenerator returns a generator of BatchAccountIdentity_UserAssignedIdentities_Status instances for property testing.
func BatchAccountIdentity_UserAssignedIdentities_StatusGenerator() gopter.Gen {
	if batchAccountIdentity_userAssignedIdentities_statusGenerator != nil {
		return batchAccountIdentity_userAssignedIdentities_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccountIdentity_UserAssignedIdentities_Status(generators)
	batchAccountIdentity_userAssignedIdentities_statusGenerator = gen.Struct(reflect.TypeOf(BatchAccountIdentity_UserAssignedIdentities_Status{}), generators)

	return batchAccountIdentity_userAssignedIdentities_statusGenerator
}

// AddIndependentPropertyGeneratorsForBatchAccountIdentity_UserAssignedIdentities_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBatchAccountIdentity_UserAssignedIdentities_Status(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_KeyVaultProperties_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultProperties_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultProperties_Spec, KeyVaultProperties_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultProperties_Spec runs a test to see if a specific instance of KeyVaultProperties_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultProperties_Spec(subject KeyVaultProperties_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultProperties_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultProperties_Spec instances for property testing - lazily instantiated by
//KeyVaultProperties_SpecGenerator()
var keyVaultProperties_specGenerator gopter.Gen

// KeyVaultProperties_SpecGenerator returns a generator of KeyVaultProperties_Spec instances for property testing.
func KeyVaultProperties_SpecGenerator() gopter.Gen {
	if keyVaultProperties_specGenerator != nil {
		return keyVaultProperties_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultProperties_Spec(generators)
	keyVaultProperties_specGenerator = gen.Struct(reflect.TypeOf(KeyVaultProperties_Spec{}), generators)

	return keyVaultProperties_specGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultProperties_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultProperties_Spec(gens map[string]gopter.Gen) {
	gens["KeyIdentifier"] = gen.PtrOf(gen.AlphaString())
}

func Test_KeyVaultProperties_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultProperties_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultProperties_Status, KeyVaultProperties_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultProperties_Status runs a test to see if a specific instance of KeyVaultProperties_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultProperties_Status(subject KeyVaultProperties_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultProperties_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultProperties_Status instances for property testing - lazily instantiated by
//KeyVaultProperties_StatusGenerator()
var keyVaultProperties_statusGenerator gopter.Gen

// KeyVaultProperties_StatusGenerator returns a generator of KeyVaultProperties_Status instances for property testing.
func KeyVaultProperties_StatusGenerator() gopter.Gen {
	if keyVaultProperties_statusGenerator != nil {
		return keyVaultProperties_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultProperties_Status(generators)
	keyVaultProperties_statusGenerator = gen.Struct(reflect.TypeOf(KeyVaultProperties_Status{}), generators)

	return keyVaultProperties_statusGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultProperties_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultProperties_Status(gens map[string]gopter.Gen) {
	gens["KeyIdentifier"] = gen.PtrOf(gen.AlphaString())
}
