// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20210101

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_BatchAccount_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BatchAccount_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBatchAccountStatusARM, BatchAccountStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBatchAccountStatusARM runs a test to see if a specific instance of BatchAccount_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBatchAccountStatusARM(subject BatchAccount_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BatchAccount_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BatchAccount_StatusARM instances for property testing - lazily instantiated by
// BatchAccountStatusARMGenerator()
var batchAccountStatusARMGenerator gopter.Gen

// BatchAccountStatusARMGenerator returns a generator of BatchAccount_StatusARM instances for property testing.
// We first initialize batchAccountStatusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BatchAccountStatusARMGenerator() gopter.Gen {
	if batchAccountStatusARMGenerator != nil {
		return batchAccountStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccountStatusARM(generators)
	batchAccountStatusARMGenerator = gen.Struct(reflect.TypeOf(BatchAccount_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccountStatusARM(generators)
	AddRelatedPropertyGeneratorsForBatchAccountStatusARM(generators)
	batchAccountStatusARMGenerator = gen.Struct(reflect.TypeOf(BatchAccount_StatusARM{}), generators)

	return batchAccountStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForBatchAccountStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBatchAccountStatusARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForBatchAccountStatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBatchAccountStatusARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(BatchAccountIdentityStatusARMGenerator())
	gens["Properties"] = gen.PtrOf(BatchAccountPropertiesStatusARMGenerator())
}

func Test_BatchAccountIdentity_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BatchAccountIdentity_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBatchAccountIdentityStatusARM, BatchAccountIdentityStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBatchAccountIdentityStatusARM runs a test to see if a specific instance of BatchAccountIdentity_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBatchAccountIdentityStatusARM(subject BatchAccountIdentity_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BatchAccountIdentity_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BatchAccountIdentity_StatusARM instances for property testing - lazily instantiated by
// BatchAccountIdentityStatusARMGenerator()
var batchAccountIdentityStatusARMGenerator gopter.Gen

// BatchAccountIdentityStatusARMGenerator returns a generator of BatchAccountIdentity_StatusARM instances for property testing.
// We first initialize batchAccountIdentityStatusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BatchAccountIdentityStatusARMGenerator() gopter.Gen {
	if batchAccountIdentityStatusARMGenerator != nil {
		return batchAccountIdentityStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccountIdentityStatusARM(generators)
	batchAccountIdentityStatusARMGenerator = gen.Struct(reflect.TypeOf(BatchAccountIdentity_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccountIdentityStatusARM(generators)
	AddRelatedPropertyGeneratorsForBatchAccountIdentityStatusARM(generators)
	batchAccountIdentityStatusARMGenerator = gen.Struct(reflect.TypeOf(BatchAccountIdentity_StatusARM{}), generators)

	return batchAccountIdentityStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForBatchAccountIdentityStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBatchAccountIdentityStatusARM(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(BatchAccountIdentityStatusTypeNone, BatchAccountIdentityStatusTypeSystemAssigned, BatchAccountIdentityStatusTypeUserAssigned))
}

// AddRelatedPropertyGeneratorsForBatchAccountIdentityStatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBatchAccountIdentityStatusARM(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), BatchAccountIdentityStatusUserAssignedIdentitiesARMGenerator())
}

func Test_BatchAccountProperties_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BatchAccountProperties_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBatchAccountPropertiesStatusARM, BatchAccountPropertiesStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBatchAccountPropertiesStatusARM runs a test to see if a specific instance of BatchAccountProperties_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBatchAccountPropertiesStatusARM(subject BatchAccountProperties_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BatchAccountProperties_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BatchAccountProperties_StatusARM instances for property testing - lazily instantiated by
// BatchAccountPropertiesStatusARMGenerator()
var batchAccountPropertiesStatusARMGenerator gopter.Gen

// BatchAccountPropertiesStatusARMGenerator returns a generator of BatchAccountProperties_StatusARM instances for property testing.
// We first initialize batchAccountPropertiesStatusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BatchAccountPropertiesStatusARMGenerator() gopter.Gen {
	if batchAccountPropertiesStatusARMGenerator != nil {
		return batchAccountPropertiesStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccountPropertiesStatusARM(generators)
	batchAccountPropertiesStatusARMGenerator = gen.Struct(reflect.TypeOf(BatchAccountProperties_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccountPropertiesStatusARM(generators)
	AddRelatedPropertyGeneratorsForBatchAccountPropertiesStatusARM(generators)
	batchAccountPropertiesStatusARMGenerator = gen.Struct(reflect.TypeOf(BatchAccountProperties_StatusARM{}), generators)

	return batchAccountPropertiesStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForBatchAccountPropertiesStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBatchAccountPropertiesStatusARM(gens map[string]gopter.Gen) {
	gens["AccountEndpoint"] = gen.PtrOf(gen.AlphaString())
	gens["ActiveJobAndJobScheduleQuota"] = gen.PtrOf(gen.Int())
	gens["DedicatedCoreQuota"] = gen.PtrOf(gen.Int())
	gens["DedicatedCoreQuotaPerVMFamilyEnforced"] = gen.PtrOf(gen.Bool())
	gens["LowPriorityCoreQuota"] = gen.PtrOf(gen.Int())
	gens["PoolAllocationMode"] = gen.PtrOf(gen.OneConstOf(PoolAllocationMode_StatusBatchService, PoolAllocationMode_StatusUserSubscription))
	gens["PoolQuota"] = gen.PtrOf(gen.Int())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		BatchAccountPropertiesStatusProvisioningStateCancelled,
		BatchAccountPropertiesStatusProvisioningStateCreating,
		BatchAccountPropertiesStatusProvisioningStateDeleting,
		BatchAccountPropertiesStatusProvisioningStateFailed,
		BatchAccountPropertiesStatusProvisioningStateInvalid,
		BatchAccountPropertiesStatusProvisioningStateSucceeded))
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(PublicNetworkAccessType_StatusDisabled, PublicNetworkAccessType_StatusEnabled))
}

// AddRelatedPropertyGeneratorsForBatchAccountPropertiesStatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBatchAccountPropertiesStatusARM(gens map[string]gopter.Gen) {
	gens["AutoStorage"] = gen.PtrOf(AutoStoragePropertiesStatusARMGenerator())
	gens["DedicatedCoreQuotaPerVMFamily"] = gen.SliceOf(VirtualMachineFamilyCoreQuotaStatusARMGenerator())
	gens["Encryption"] = gen.PtrOf(EncryptionPropertiesStatusARMGenerator())
	gens["KeyVaultReference"] = gen.PtrOf(KeyVaultReferenceStatusARMGenerator())
	gens["PrivateEndpointConnections"] = gen.SliceOf(PrivateEndpointConnectionStatusARMGenerator())
}

func Test_AutoStorageProperties_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoStorageProperties_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoStoragePropertiesStatusARM, AutoStoragePropertiesStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoStoragePropertiesStatusARM runs a test to see if a specific instance of AutoStorageProperties_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoStoragePropertiesStatusARM(subject AutoStorageProperties_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoStorageProperties_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoStorageProperties_StatusARM instances for property testing - lazily instantiated by
// AutoStoragePropertiesStatusARMGenerator()
var autoStoragePropertiesStatusARMGenerator gopter.Gen

// AutoStoragePropertiesStatusARMGenerator returns a generator of AutoStorageProperties_StatusARM instances for property testing.
func AutoStoragePropertiesStatusARMGenerator() gopter.Gen {
	if autoStoragePropertiesStatusARMGenerator != nil {
		return autoStoragePropertiesStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoStoragePropertiesStatusARM(generators)
	autoStoragePropertiesStatusARMGenerator = gen.Struct(reflect.TypeOf(AutoStorageProperties_StatusARM{}), generators)

	return autoStoragePropertiesStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForAutoStoragePropertiesStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoStoragePropertiesStatusARM(gens map[string]gopter.Gen) {
	gens["LastKeySync"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountId"] = gen.PtrOf(gen.AlphaString())
}

func Test_BatchAccountIdentity_Status_UserAssignedIdentitiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BatchAccountIdentity_Status_UserAssignedIdentitiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBatchAccountIdentityStatusUserAssignedIdentitiesARM, BatchAccountIdentityStatusUserAssignedIdentitiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBatchAccountIdentityStatusUserAssignedIdentitiesARM runs a test to see if a specific instance of BatchAccountIdentity_Status_UserAssignedIdentitiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBatchAccountIdentityStatusUserAssignedIdentitiesARM(subject BatchAccountIdentity_Status_UserAssignedIdentitiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BatchAccountIdentity_Status_UserAssignedIdentitiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BatchAccountIdentity_Status_UserAssignedIdentitiesARM instances for property testing - lazily
// instantiated by BatchAccountIdentityStatusUserAssignedIdentitiesARMGenerator()
var batchAccountIdentityStatusUserAssignedIdentitiesARMGenerator gopter.Gen

// BatchAccountIdentityStatusUserAssignedIdentitiesARMGenerator returns a generator of BatchAccountIdentity_Status_UserAssignedIdentitiesARM instances for property testing.
func BatchAccountIdentityStatusUserAssignedIdentitiesARMGenerator() gopter.Gen {
	if batchAccountIdentityStatusUserAssignedIdentitiesARMGenerator != nil {
		return batchAccountIdentityStatusUserAssignedIdentitiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccountIdentityStatusUserAssignedIdentitiesARM(generators)
	batchAccountIdentityStatusUserAssignedIdentitiesARMGenerator = gen.Struct(reflect.TypeOf(BatchAccountIdentity_Status_UserAssignedIdentitiesARM{}), generators)

	return batchAccountIdentityStatusUserAssignedIdentitiesARMGenerator
}

// AddIndependentPropertyGeneratorsForBatchAccountIdentityStatusUserAssignedIdentitiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBatchAccountIdentityStatusUserAssignedIdentitiesARM(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionProperties_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionProperties_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionPropertiesStatusARM, EncryptionPropertiesStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionPropertiesStatusARM runs a test to see if a specific instance of EncryptionProperties_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionPropertiesStatusARM(subject EncryptionProperties_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionProperties_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionProperties_StatusARM instances for property testing - lazily instantiated by
// EncryptionPropertiesStatusARMGenerator()
var encryptionPropertiesStatusARMGenerator gopter.Gen

// EncryptionPropertiesStatusARMGenerator returns a generator of EncryptionProperties_StatusARM instances for property testing.
// We first initialize encryptionPropertiesStatusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EncryptionPropertiesStatusARMGenerator() gopter.Gen {
	if encryptionPropertiesStatusARMGenerator != nil {
		return encryptionPropertiesStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionPropertiesStatusARM(generators)
	encryptionPropertiesStatusARMGenerator = gen.Struct(reflect.TypeOf(EncryptionProperties_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionPropertiesStatusARM(generators)
	AddRelatedPropertyGeneratorsForEncryptionPropertiesStatusARM(generators)
	encryptionPropertiesStatusARMGenerator = gen.Struct(reflect.TypeOf(EncryptionProperties_StatusARM{}), generators)

	return encryptionPropertiesStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionPropertiesStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionPropertiesStatusARM(gens map[string]gopter.Gen) {
	gens["KeySource"] = gen.PtrOf(gen.OneConstOf(EncryptionPropertiesStatusKeySourceMicrosoftBatch, EncryptionPropertiesStatusKeySourceMicrosoftKeyVault))
}

// AddRelatedPropertyGeneratorsForEncryptionPropertiesStatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionPropertiesStatusARM(gens map[string]gopter.Gen) {
	gens["KeyVaultProperties"] = gen.PtrOf(KeyVaultPropertiesStatusARMGenerator())
}

func Test_KeyVaultReference_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultReference_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultReferenceStatusARM, KeyVaultReferenceStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultReferenceStatusARM runs a test to see if a specific instance of KeyVaultReference_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultReferenceStatusARM(subject KeyVaultReference_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultReference_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultReference_StatusARM instances for property testing - lazily instantiated by
// KeyVaultReferenceStatusARMGenerator()
var keyVaultReferenceStatusARMGenerator gopter.Gen

// KeyVaultReferenceStatusARMGenerator returns a generator of KeyVaultReference_StatusARM instances for property testing.
func KeyVaultReferenceStatusARMGenerator() gopter.Gen {
	if keyVaultReferenceStatusARMGenerator != nil {
		return keyVaultReferenceStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultReferenceStatusARM(generators)
	keyVaultReferenceStatusARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultReference_StatusARM{}), generators)

	return keyVaultReferenceStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultReferenceStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultReferenceStatusARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Url"] = gen.PtrOf(gen.AlphaString())
}

func Test_PrivateEndpointConnection_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointConnection_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointConnectionStatusARM, PrivateEndpointConnectionStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointConnectionStatusARM runs a test to see if a specific instance of PrivateEndpointConnection_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointConnectionStatusARM(subject PrivateEndpointConnection_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointConnection_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointConnection_StatusARM instances for property testing - lazily instantiated by
// PrivateEndpointConnectionStatusARMGenerator()
var privateEndpointConnectionStatusARMGenerator gopter.Gen

// PrivateEndpointConnectionStatusARMGenerator returns a generator of PrivateEndpointConnection_StatusARM instances for property testing.
// We first initialize privateEndpointConnectionStatusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateEndpointConnectionStatusARMGenerator() gopter.Gen {
	if privateEndpointConnectionStatusARMGenerator != nil {
		return privateEndpointConnectionStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnectionStatusARM(generators)
	privateEndpointConnectionStatusARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnection_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnectionStatusARM(generators)
	AddRelatedPropertyGeneratorsForPrivateEndpointConnectionStatusARM(generators)
	privateEndpointConnectionStatusARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnection_StatusARM{}), generators)

	return privateEndpointConnectionStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointConnectionStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointConnectionStatusARM(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPrivateEndpointConnectionStatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateEndpointConnectionStatusARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(PrivateEndpointConnectionPropertiesStatusARMGenerator())
}

func Test_VirtualMachineFamilyCoreQuota_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineFamilyCoreQuota_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineFamilyCoreQuotaStatusARM, VirtualMachineFamilyCoreQuotaStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineFamilyCoreQuotaStatusARM runs a test to see if a specific instance of VirtualMachineFamilyCoreQuota_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineFamilyCoreQuotaStatusARM(subject VirtualMachineFamilyCoreQuota_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineFamilyCoreQuota_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineFamilyCoreQuota_StatusARM instances for property testing - lazily instantiated by
// VirtualMachineFamilyCoreQuotaStatusARMGenerator()
var virtualMachineFamilyCoreQuotaStatusARMGenerator gopter.Gen

// VirtualMachineFamilyCoreQuotaStatusARMGenerator returns a generator of VirtualMachineFamilyCoreQuota_StatusARM instances for property testing.
func VirtualMachineFamilyCoreQuotaStatusARMGenerator() gopter.Gen {
	if virtualMachineFamilyCoreQuotaStatusARMGenerator != nil {
		return virtualMachineFamilyCoreQuotaStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineFamilyCoreQuotaStatusARM(generators)
	virtualMachineFamilyCoreQuotaStatusARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineFamilyCoreQuota_StatusARM{}), generators)

	return virtualMachineFamilyCoreQuotaStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineFamilyCoreQuotaStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineFamilyCoreQuotaStatusARM(gens map[string]gopter.Gen) {
	gens["CoreQuota"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_KeyVaultProperties_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultProperties_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultPropertiesStatusARM, KeyVaultPropertiesStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultPropertiesStatusARM runs a test to see if a specific instance of KeyVaultProperties_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultPropertiesStatusARM(subject KeyVaultProperties_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultProperties_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultProperties_StatusARM instances for property testing - lazily instantiated by
// KeyVaultPropertiesStatusARMGenerator()
var keyVaultPropertiesStatusARMGenerator gopter.Gen

// KeyVaultPropertiesStatusARMGenerator returns a generator of KeyVaultProperties_StatusARM instances for property testing.
func KeyVaultPropertiesStatusARMGenerator() gopter.Gen {
	if keyVaultPropertiesStatusARMGenerator != nil {
		return keyVaultPropertiesStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultPropertiesStatusARM(generators)
	keyVaultPropertiesStatusARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultProperties_StatusARM{}), generators)

	return keyVaultPropertiesStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultPropertiesStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultPropertiesStatusARM(gens map[string]gopter.Gen) {
	gens["KeyIdentifier"] = gen.PtrOf(gen.AlphaString())
}

func Test_PrivateEndpointConnectionProperties_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointConnectionProperties_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointConnectionPropertiesStatusARM, PrivateEndpointConnectionPropertiesStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointConnectionPropertiesStatusARM runs a test to see if a specific instance of PrivateEndpointConnectionProperties_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointConnectionPropertiesStatusARM(subject PrivateEndpointConnectionProperties_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointConnectionProperties_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointConnectionProperties_StatusARM instances for property testing - lazily instantiated by
// PrivateEndpointConnectionPropertiesStatusARMGenerator()
var privateEndpointConnectionPropertiesStatusARMGenerator gopter.Gen

// PrivateEndpointConnectionPropertiesStatusARMGenerator returns a generator of PrivateEndpointConnectionProperties_StatusARM instances for property testing.
// We first initialize privateEndpointConnectionPropertiesStatusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateEndpointConnectionPropertiesStatusARMGenerator() gopter.Gen {
	if privateEndpointConnectionPropertiesStatusARMGenerator != nil {
		return privateEndpointConnectionPropertiesStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnectionPropertiesStatusARM(generators)
	privateEndpointConnectionPropertiesStatusARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnectionProperties_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnectionPropertiesStatusARM(generators)
	AddRelatedPropertyGeneratorsForPrivateEndpointConnectionPropertiesStatusARM(generators)
	privateEndpointConnectionPropertiesStatusARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnectionProperties_StatusARM{}), generators)

	return privateEndpointConnectionPropertiesStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointConnectionPropertiesStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointConnectionPropertiesStatusARM(gens map[string]gopter.Gen) {
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(PrivateEndpointConnectionPropertiesStatusProvisioningStateFailed, PrivateEndpointConnectionPropertiesStatusProvisioningStateSucceeded, PrivateEndpointConnectionPropertiesStatusProvisioningStateUpdating))
}

// AddRelatedPropertyGeneratorsForPrivateEndpointConnectionPropertiesStatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateEndpointConnectionPropertiesStatusARM(gens map[string]gopter.Gen) {
	gens["PrivateEndpoint"] = gen.PtrOf(PrivateEndpointStatusARMGenerator())
	gens["PrivateLinkServiceConnectionState"] = gen.PtrOf(PrivateLinkServiceConnectionStateStatusARMGenerator())
}

func Test_PrivateEndpoint_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpoint_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointStatusARM, PrivateEndpointStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointStatusARM runs a test to see if a specific instance of PrivateEndpoint_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointStatusARM(subject PrivateEndpoint_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpoint_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpoint_StatusARM instances for property testing - lazily instantiated by
// PrivateEndpointStatusARMGenerator()
var privateEndpointStatusARMGenerator gopter.Gen

// PrivateEndpointStatusARMGenerator returns a generator of PrivateEndpoint_StatusARM instances for property testing.
func PrivateEndpointStatusARMGenerator() gopter.Gen {
	if privateEndpointStatusARMGenerator != nil {
		return privateEndpointStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointStatusARM(generators)
	privateEndpointStatusARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpoint_StatusARM{}), generators)

	return privateEndpointStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointStatusARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_PrivateLinkServiceConnectionState_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateLinkServiceConnectionState_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateLinkServiceConnectionStateStatusARM, PrivateLinkServiceConnectionStateStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateLinkServiceConnectionStateStatusARM runs a test to see if a specific instance of PrivateLinkServiceConnectionState_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateLinkServiceConnectionStateStatusARM(subject PrivateLinkServiceConnectionState_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateLinkServiceConnectionState_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateLinkServiceConnectionState_StatusARM instances for property testing - lazily instantiated by
// PrivateLinkServiceConnectionStateStatusARMGenerator()
var privateLinkServiceConnectionStateStatusARMGenerator gopter.Gen

// PrivateLinkServiceConnectionStateStatusARMGenerator returns a generator of PrivateLinkServiceConnectionState_StatusARM instances for property testing.
func PrivateLinkServiceConnectionStateStatusARMGenerator() gopter.Gen {
	if privateLinkServiceConnectionStateStatusARMGenerator != nil {
		return privateLinkServiceConnectionStateStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkServiceConnectionStateStatusARM(generators)
	privateLinkServiceConnectionStateStatusARMGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServiceConnectionState_StatusARM{}), generators)

	return privateLinkServiceConnectionStateStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateLinkServiceConnectionStateStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateLinkServiceConnectionStateStatusARM(gens map[string]gopter.Gen) {
	gens["ActionRequired"] = gen.PtrOf(gen.AlphaString())
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(
		PrivateLinkServiceConnectionStatus_StatusApproved,
		PrivateLinkServiceConnectionStatus_StatusDisconnected,
		PrivateLinkServiceConnectionStatus_StatusPending,
		PrivateLinkServiceConnectionStatus_StatusRejected))
}
