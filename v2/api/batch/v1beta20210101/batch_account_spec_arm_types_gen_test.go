// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20210101

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_BatchAccount_Spec_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BatchAccount_Spec_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBatchAccount_Spec_ARM, BatchAccount_Spec_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBatchAccount_Spec_ARM runs a test to see if a specific instance of BatchAccount_Spec_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBatchAccount_Spec_ARM(subject BatchAccount_Spec_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BatchAccount_Spec_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BatchAccount_Spec_ARM instances for property testing - lazily instantiated by
// BatchAccount_Spec_ARMGenerator()
var batchAccount_Spec_ARMGenerator gopter.Gen

// BatchAccount_Spec_ARMGenerator returns a generator of BatchAccount_Spec_ARM instances for property testing.
// We first initialize batchAccount_Spec_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BatchAccount_Spec_ARMGenerator() gopter.Gen {
	if batchAccount_Spec_ARMGenerator != nil {
		return batchAccount_Spec_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccount_Spec_ARM(generators)
	batchAccount_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(BatchAccount_Spec_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccount_Spec_ARM(generators)
	AddRelatedPropertyGeneratorsForBatchAccount_Spec_ARM(generators)
	batchAccount_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(BatchAccount_Spec_ARM{}), generators)

	return batchAccount_Spec_ARMGenerator
}

// AddIndependentPropertyGeneratorsForBatchAccount_Spec_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBatchAccount_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForBatchAccount_Spec_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBatchAccount_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(BatchAccountIdentity_ARMGenerator())
	gens["Properties"] = gen.PtrOf(BatchAccountCreateProperties_ARMGenerator())
}

func Test_BatchAccountCreateProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BatchAccountCreateProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBatchAccountCreateProperties_ARM, BatchAccountCreateProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBatchAccountCreateProperties_ARM runs a test to see if a specific instance of BatchAccountCreateProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBatchAccountCreateProperties_ARM(subject BatchAccountCreateProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BatchAccountCreateProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BatchAccountCreateProperties_ARM instances for property testing - lazily instantiated by
// BatchAccountCreateProperties_ARMGenerator()
var batchAccountCreateProperties_ARMGenerator gopter.Gen

// BatchAccountCreateProperties_ARMGenerator returns a generator of BatchAccountCreateProperties_ARM instances for property testing.
// We first initialize batchAccountCreateProperties_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BatchAccountCreateProperties_ARMGenerator() gopter.Gen {
	if batchAccountCreateProperties_ARMGenerator != nil {
		return batchAccountCreateProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccountCreateProperties_ARM(generators)
	batchAccountCreateProperties_ARMGenerator = gen.Struct(reflect.TypeOf(BatchAccountCreateProperties_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccountCreateProperties_ARM(generators)
	AddRelatedPropertyGeneratorsForBatchAccountCreateProperties_ARM(generators)
	batchAccountCreateProperties_ARMGenerator = gen.Struct(reflect.TypeOf(BatchAccountCreateProperties_ARM{}), generators)

	return batchAccountCreateProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForBatchAccountCreateProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBatchAccountCreateProperties_ARM(gens map[string]gopter.Gen) {
	gens["PoolAllocationMode"] = gen.PtrOf(gen.OneConstOf(PoolAllocationMode_BatchService, PoolAllocationMode_UserSubscription))
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(PublicNetworkAccessType_Disabled, PublicNetworkAccessType_Enabled))
}

// AddRelatedPropertyGeneratorsForBatchAccountCreateProperties_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBatchAccountCreateProperties_ARM(gens map[string]gopter.Gen) {
	gens["AutoStorage"] = gen.PtrOf(AutoStorageBaseProperties_ARMGenerator())
	gens["Encryption"] = gen.PtrOf(EncryptionProperties_ARMGenerator())
	gens["KeyVaultReference"] = gen.PtrOf(KeyVaultReference_ARMGenerator())
}

func Test_BatchAccountIdentity_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BatchAccountIdentity_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBatchAccountIdentity_ARM, BatchAccountIdentity_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBatchAccountIdentity_ARM runs a test to see if a specific instance of BatchAccountIdentity_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBatchAccountIdentity_ARM(subject BatchAccountIdentity_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BatchAccountIdentity_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BatchAccountIdentity_ARM instances for property testing - lazily instantiated by
// BatchAccountIdentity_ARMGenerator()
var batchAccountIdentity_ARMGenerator gopter.Gen

// BatchAccountIdentity_ARMGenerator returns a generator of BatchAccountIdentity_ARM instances for property testing.
// We first initialize batchAccountIdentity_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BatchAccountIdentity_ARMGenerator() gopter.Gen {
	if batchAccountIdentity_ARMGenerator != nil {
		return batchAccountIdentity_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccountIdentity_ARM(generators)
	batchAccountIdentity_ARMGenerator = gen.Struct(reflect.TypeOf(BatchAccountIdentity_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccountIdentity_ARM(generators)
	AddRelatedPropertyGeneratorsForBatchAccountIdentity_ARM(generators)
	batchAccountIdentity_ARMGenerator = gen.Struct(reflect.TypeOf(BatchAccountIdentity_ARM{}), generators)

	return batchAccountIdentity_ARMGenerator
}

// AddIndependentPropertyGeneratorsForBatchAccountIdentity_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBatchAccountIdentity_ARM(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(BatchAccountIdentity_Type_None, BatchAccountIdentity_Type_SystemAssigned, BatchAccountIdentity_Type_UserAssigned))
}

// AddRelatedPropertyGeneratorsForBatchAccountIdentity_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBatchAccountIdentity_ARM(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), UserAssignedIdentityDetails_ARMGenerator())
}

func Test_AutoStorageBaseProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoStorageBaseProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoStorageBaseProperties_ARM, AutoStorageBaseProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoStorageBaseProperties_ARM runs a test to see if a specific instance of AutoStorageBaseProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoStorageBaseProperties_ARM(subject AutoStorageBaseProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoStorageBaseProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoStorageBaseProperties_ARM instances for property testing - lazily instantiated by
// AutoStorageBaseProperties_ARMGenerator()
var autoStorageBaseProperties_ARMGenerator gopter.Gen

// AutoStorageBaseProperties_ARMGenerator returns a generator of AutoStorageBaseProperties_ARM instances for property testing.
func AutoStorageBaseProperties_ARMGenerator() gopter.Gen {
	if autoStorageBaseProperties_ARMGenerator != nil {
		return autoStorageBaseProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoStorageBaseProperties_ARM(generators)
	autoStorageBaseProperties_ARMGenerator = gen.Struct(reflect.TypeOf(AutoStorageBaseProperties_ARM{}), generators)

	return autoStorageBaseProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForAutoStorageBaseProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoStorageBaseProperties_ARM(gens map[string]gopter.Gen) {
	gens["StorageAccountId"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionProperties_ARM, EncryptionProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionProperties_ARM runs a test to see if a specific instance of EncryptionProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionProperties_ARM(subject EncryptionProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionProperties_ARM instances for property testing - lazily instantiated by
// EncryptionProperties_ARMGenerator()
var encryptionProperties_ARMGenerator gopter.Gen

// EncryptionProperties_ARMGenerator returns a generator of EncryptionProperties_ARM instances for property testing.
// We first initialize encryptionProperties_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EncryptionProperties_ARMGenerator() gopter.Gen {
	if encryptionProperties_ARMGenerator != nil {
		return encryptionProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionProperties_ARM(generators)
	encryptionProperties_ARMGenerator = gen.Struct(reflect.TypeOf(EncryptionProperties_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionProperties_ARM(generators)
	AddRelatedPropertyGeneratorsForEncryptionProperties_ARM(generators)
	encryptionProperties_ARMGenerator = gen.Struct(reflect.TypeOf(EncryptionProperties_ARM{}), generators)

	return encryptionProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionProperties_ARM(gens map[string]gopter.Gen) {
	gens["KeySource"] = gen.PtrOf(gen.OneConstOf(EncryptionProperties_KeySource_MicrosoftBatch, EncryptionProperties_KeySource_MicrosoftKeyVault))
}

// AddRelatedPropertyGeneratorsForEncryptionProperties_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionProperties_ARM(gens map[string]gopter.Gen) {
	gens["KeyVaultProperties"] = gen.PtrOf(KeyVaultProperties_ARMGenerator())
}

func Test_KeyVaultReference_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultReference_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultReference_ARM, KeyVaultReference_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultReference_ARM runs a test to see if a specific instance of KeyVaultReference_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultReference_ARM(subject KeyVaultReference_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultReference_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultReference_ARM instances for property testing - lazily instantiated by
// KeyVaultReference_ARMGenerator()
var keyVaultReference_ARMGenerator gopter.Gen

// KeyVaultReference_ARMGenerator returns a generator of KeyVaultReference_ARM instances for property testing.
func KeyVaultReference_ARMGenerator() gopter.Gen {
	if keyVaultReference_ARMGenerator != nil {
		return keyVaultReference_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultReference_ARM(generators)
	keyVaultReference_ARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultReference_ARM{}), generators)

	return keyVaultReference_ARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultReference_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultReference_ARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Url"] = gen.PtrOf(gen.AlphaString())
}

func Test_UserAssignedIdentityDetails_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentityDetails_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentityDetails_ARM, UserAssignedIdentityDetails_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentityDetails_ARM runs a test to see if a specific instance of UserAssignedIdentityDetails_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentityDetails_ARM(subject UserAssignedIdentityDetails_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentityDetails_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentityDetails_ARM instances for property testing - lazily instantiated by
// UserAssignedIdentityDetails_ARMGenerator()
var userAssignedIdentityDetails_ARMGenerator gopter.Gen

// UserAssignedIdentityDetails_ARMGenerator returns a generator of UserAssignedIdentityDetails_ARM instances for property testing.
func UserAssignedIdentityDetails_ARMGenerator() gopter.Gen {
	if userAssignedIdentityDetails_ARMGenerator != nil {
		return userAssignedIdentityDetails_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	userAssignedIdentityDetails_ARMGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentityDetails_ARM{}), generators)

	return userAssignedIdentityDetails_ARMGenerator
}

func Test_KeyVaultProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultProperties_ARM, KeyVaultProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultProperties_ARM runs a test to see if a specific instance of KeyVaultProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultProperties_ARM(subject KeyVaultProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultProperties_ARM instances for property testing - lazily instantiated by
// KeyVaultProperties_ARMGenerator()
var keyVaultProperties_ARMGenerator gopter.Gen

// KeyVaultProperties_ARMGenerator returns a generator of KeyVaultProperties_ARM instances for property testing.
func KeyVaultProperties_ARMGenerator() gopter.Gen {
	if keyVaultProperties_ARMGenerator != nil {
		return keyVaultProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultProperties_ARM(generators)
	keyVaultProperties_ARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultProperties_ARM{}), generators)

	return keyVaultProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultProperties_ARM(gens map[string]gopter.Gen) {
	gens["KeyIdentifier"] = gen.PtrOf(gen.AlphaString())
}
