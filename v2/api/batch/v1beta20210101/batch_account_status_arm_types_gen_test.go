// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20210101

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_BatchAccount_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BatchAccount_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBatchAccountSTATUSARM, BatchAccountSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBatchAccountSTATUSARM runs a test to see if a specific instance of BatchAccount_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBatchAccountSTATUSARM(subject BatchAccount_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BatchAccount_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BatchAccount_STATUSARM instances for property testing - lazily instantiated by
// BatchAccountSTATUSARMGenerator()
var batchAccountSTATUSARMGenerator gopter.Gen

// BatchAccountSTATUSARMGenerator returns a generator of BatchAccount_STATUSARM instances for property testing.
// We first initialize batchAccountSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BatchAccountSTATUSARMGenerator() gopter.Gen {
	if batchAccountSTATUSARMGenerator != nil {
		return batchAccountSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccountSTATUSARM(generators)
	batchAccountSTATUSARMGenerator = gen.Struct(reflect.TypeOf(BatchAccount_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccountSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForBatchAccountSTATUSARM(generators)
	batchAccountSTATUSARMGenerator = gen.Struct(reflect.TypeOf(BatchAccount_STATUSARM{}), generators)

	return batchAccountSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForBatchAccountSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBatchAccountSTATUSARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForBatchAccountSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBatchAccountSTATUSARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(BatchAccountIdentitySTATUSARMGenerator())
	gens["Properties"] = gen.PtrOf(BatchAccountPropertiesSTATUSARMGenerator())
}

func Test_BatchAccountIdentity_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BatchAccountIdentity_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBatchAccountIdentitySTATUSARM, BatchAccountIdentitySTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBatchAccountIdentitySTATUSARM runs a test to see if a specific instance of BatchAccountIdentity_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBatchAccountIdentitySTATUSARM(subject BatchAccountIdentity_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BatchAccountIdentity_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BatchAccountIdentity_STATUSARM instances for property testing - lazily instantiated by
// BatchAccountIdentitySTATUSARMGenerator()
var batchAccountIdentitySTATUSARMGenerator gopter.Gen

// BatchAccountIdentitySTATUSARMGenerator returns a generator of BatchAccountIdentity_STATUSARM instances for property testing.
// We first initialize batchAccountIdentitySTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BatchAccountIdentitySTATUSARMGenerator() gopter.Gen {
	if batchAccountIdentitySTATUSARMGenerator != nil {
		return batchAccountIdentitySTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccountIdentitySTATUSARM(generators)
	batchAccountIdentitySTATUSARMGenerator = gen.Struct(reflect.TypeOf(BatchAccountIdentity_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccountIdentitySTATUSARM(generators)
	AddRelatedPropertyGeneratorsForBatchAccountIdentitySTATUSARM(generators)
	batchAccountIdentitySTATUSARMGenerator = gen.Struct(reflect.TypeOf(BatchAccountIdentity_STATUSARM{}), generators)

	return batchAccountIdentitySTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForBatchAccountIdentitySTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBatchAccountIdentitySTATUSARM(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(BatchAccountIdentitySTATUSType_None, BatchAccountIdentitySTATUSType_SystemAssigned, BatchAccountIdentitySTATUSType_UserAssigned))
}

// AddRelatedPropertyGeneratorsForBatchAccountIdentitySTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBatchAccountIdentitySTATUSARM(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), BatchAccountIdentitySTATUSUserAssignedIdentitiesARMGenerator())
}

func Test_BatchAccountProperties_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BatchAccountProperties_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBatchAccountPropertiesSTATUSARM, BatchAccountPropertiesSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBatchAccountPropertiesSTATUSARM runs a test to see if a specific instance of BatchAccountProperties_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBatchAccountPropertiesSTATUSARM(subject BatchAccountProperties_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BatchAccountProperties_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BatchAccountProperties_STATUSARM instances for property testing - lazily instantiated by
// BatchAccountPropertiesSTATUSARMGenerator()
var batchAccountPropertiesSTATUSARMGenerator gopter.Gen

// BatchAccountPropertiesSTATUSARMGenerator returns a generator of BatchAccountProperties_STATUSARM instances for property testing.
// We first initialize batchAccountPropertiesSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BatchAccountPropertiesSTATUSARMGenerator() gopter.Gen {
	if batchAccountPropertiesSTATUSARMGenerator != nil {
		return batchAccountPropertiesSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccountPropertiesSTATUSARM(generators)
	batchAccountPropertiesSTATUSARMGenerator = gen.Struct(reflect.TypeOf(BatchAccountProperties_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccountPropertiesSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForBatchAccountPropertiesSTATUSARM(generators)
	batchAccountPropertiesSTATUSARMGenerator = gen.Struct(reflect.TypeOf(BatchAccountProperties_STATUSARM{}), generators)

	return batchAccountPropertiesSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForBatchAccountPropertiesSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBatchAccountPropertiesSTATUSARM(gens map[string]gopter.Gen) {
	gens["AccountEndpoint"] = gen.PtrOf(gen.AlphaString())
	gens["ActiveJobAndJobScheduleQuota"] = gen.PtrOf(gen.Int())
	gens["DedicatedCoreQuota"] = gen.PtrOf(gen.Int())
	gens["DedicatedCoreQuotaPerVMFamilyEnforced"] = gen.PtrOf(gen.Bool())
	gens["LowPriorityCoreQuota"] = gen.PtrOf(gen.Int())
	gens["PoolAllocationMode"] = gen.PtrOf(gen.OneConstOf(PoolAllocationMode_STATUS_BatchService, PoolAllocationMode_STATUS_UserSubscription))
	gens["PoolQuota"] = gen.PtrOf(gen.Int())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		BatchAccountPropertiesSTATUSProvisioningState_Cancelled,
		BatchAccountPropertiesSTATUSProvisioningState_Creating,
		BatchAccountPropertiesSTATUSProvisioningState_Deleting,
		BatchAccountPropertiesSTATUSProvisioningState_Failed,
		BatchAccountPropertiesSTATUSProvisioningState_Invalid,
		BatchAccountPropertiesSTATUSProvisioningState_Succeeded))
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(PublicNetworkAccessType_STATUS_Disabled, PublicNetworkAccessType_STATUS_Enabled))
}

// AddRelatedPropertyGeneratorsForBatchAccountPropertiesSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBatchAccountPropertiesSTATUSARM(gens map[string]gopter.Gen) {
	gens["AutoStorage"] = gen.PtrOf(AutoStoragePropertiesSTATUSARMGenerator())
	gens["DedicatedCoreQuotaPerVMFamily"] = gen.SliceOf(VirtualMachineFamilyCoreQuotaSTATUSARMGenerator())
	gens["Encryption"] = gen.PtrOf(EncryptionPropertiesSTATUSARMGenerator())
	gens["KeyVaultReference"] = gen.PtrOf(KeyVaultReferenceSTATUSARMGenerator())
	gens["PrivateEndpointConnections"] = gen.SliceOf(PrivateEndpointConnectionSTATUSARMGenerator())
}

func Test_AutoStorageProperties_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoStorageProperties_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoStoragePropertiesSTATUSARM, AutoStoragePropertiesSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoStoragePropertiesSTATUSARM runs a test to see if a specific instance of AutoStorageProperties_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoStoragePropertiesSTATUSARM(subject AutoStorageProperties_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoStorageProperties_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoStorageProperties_STATUSARM instances for property testing - lazily instantiated by
// AutoStoragePropertiesSTATUSARMGenerator()
var autoStoragePropertiesSTATUSARMGenerator gopter.Gen

// AutoStoragePropertiesSTATUSARMGenerator returns a generator of AutoStorageProperties_STATUSARM instances for property testing.
func AutoStoragePropertiesSTATUSARMGenerator() gopter.Gen {
	if autoStoragePropertiesSTATUSARMGenerator != nil {
		return autoStoragePropertiesSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoStoragePropertiesSTATUSARM(generators)
	autoStoragePropertiesSTATUSARMGenerator = gen.Struct(reflect.TypeOf(AutoStorageProperties_STATUSARM{}), generators)

	return autoStoragePropertiesSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForAutoStoragePropertiesSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoStoragePropertiesSTATUSARM(gens map[string]gopter.Gen) {
	gens["LastKeySync"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountId"] = gen.PtrOf(gen.AlphaString())
}

func Test_BatchAccountIdentity_STATUS_UserAssignedIdentitiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BatchAccountIdentity_STATUS_UserAssignedIdentitiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBatchAccountIdentitySTATUSUserAssignedIdentitiesARM, BatchAccountIdentitySTATUSUserAssignedIdentitiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBatchAccountIdentitySTATUSUserAssignedIdentitiesARM runs a test to see if a specific instance of BatchAccountIdentity_STATUS_UserAssignedIdentitiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBatchAccountIdentitySTATUSUserAssignedIdentitiesARM(subject BatchAccountIdentity_STATUS_UserAssignedIdentitiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BatchAccountIdentity_STATUS_UserAssignedIdentitiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BatchAccountIdentity_STATUS_UserAssignedIdentitiesARM instances for property testing - lazily
// instantiated by BatchAccountIdentitySTATUSUserAssignedIdentitiesARMGenerator()
var batchAccountIdentitySTATUSUserAssignedIdentitiesARMGenerator gopter.Gen

// BatchAccountIdentitySTATUSUserAssignedIdentitiesARMGenerator returns a generator of BatchAccountIdentity_STATUS_UserAssignedIdentitiesARM instances for property testing.
func BatchAccountIdentitySTATUSUserAssignedIdentitiesARMGenerator() gopter.Gen {
	if batchAccountIdentitySTATUSUserAssignedIdentitiesARMGenerator != nil {
		return batchAccountIdentitySTATUSUserAssignedIdentitiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccountIdentitySTATUSUserAssignedIdentitiesARM(generators)
	batchAccountIdentitySTATUSUserAssignedIdentitiesARMGenerator = gen.Struct(reflect.TypeOf(BatchAccountIdentity_STATUS_UserAssignedIdentitiesARM{}), generators)

	return batchAccountIdentitySTATUSUserAssignedIdentitiesARMGenerator
}

// AddIndependentPropertyGeneratorsForBatchAccountIdentitySTATUSUserAssignedIdentitiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBatchAccountIdentitySTATUSUserAssignedIdentitiesARM(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionProperties_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionProperties_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionPropertiesSTATUSARM, EncryptionPropertiesSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionPropertiesSTATUSARM runs a test to see if a specific instance of EncryptionProperties_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionPropertiesSTATUSARM(subject EncryptionProperties_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionProperties_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionProperties_STATUSARM instances for property testing - lazily instantiated by
// EncryptionPropertiesSTATUSARMGenerator()
var encryptionPropertiesSTATUSARMGenerator gopter.Gen

// EncryptionPropertiesSTATUSARMGenerator returns a generator of EncryptionProperties_STATUSARM instances for property testing.
// We first initialize encryptionPropertiesSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EncryptionPropertiesSTATUSARMGenerator() gopter.Gen {
	if encryptionPropertiesSTATUSARMGenerator != nil {
		return encryptionPropertiesSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionPropertiesSTATUSARM(generators)
	encryptionPropertiesSTATUSARMGenerator = gen.Struct(reflect.TypeOf(EncryptionProperties_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionPropertiesSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForEncryptionPropertiesSTATUSARM(generators)
	encryptionPropertiesSTATUSARMGenerator = gen.Struct(reflect.TypeOf(EncryptionProperties_STATUSARM{}), generators)

	return encryptionPropertiesSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionPropertiesSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionPropertiesSTATUSARM(gens map[string]gopter.Gen) {
	gens["KeySource"] = gen.PtrOf(gen.OneConstOf(EncryptionPropertiesSTATUSKeySource_MicrosoftBatch, EncryptionPropertiesSTATUSKeySource_MicrosoftKeyVault))
}

// AddRelatedPropertyGeneratorsForEncryptionPropertiesSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionPropertiesSTATUSARM(gens map[string]gopter.Gen) {
	gens["KeyVaultProperties"] = gen.PtrOf(KeyVaultPropertiesSTATUSARMGenerator())
}

func Test_KeyVaultReference_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultReference_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultReferenceSTATUSARM, KeyVaultReferenceSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultReferenceSTATUSARM runs a test to see if a specific instance of KeyVaultReference_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultReferenceSTATUSARM(subject KeyVaultReference_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultReference_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultReference_STATUSARM instances for property testing - lazily instantiated by
// KeyVaultReferenceSTATUSARMGenerator()
var keyVaultReferenceSTATUSARMGenerator gopter.Gen

// KeyVaultReferenceSTATUSARMGenerator returns a generator of KeyVaultReference_STATUSARM instances for property testing.
func KeyVaultReferenceSTATUSARMGenerator() gopter.Gen {
	if keyVaultReferenceSTATUSARMGenerator != nil {
		return keyVaultReferenceSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultReferenceSTATUSARM(generators)
	keyVaultReferenceSTATUSARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultReference_STATUSARM{}), generators)

	return keyVaultReferenceSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultReferenceSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultReferenceSTATUSARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Url"] = gen.PtrOf(gen.AlphaString())
}

func Test_PrivateEndpointConnection_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointConnection_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointConnectionSTATUSARM, PrivateEndpointConnectionSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointConnectionSTATUSARM runs a test to see if a specific instance of PrivateEndpointConnection_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointConnectionSTATUSARM(subject PrivateEndpointConnection_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointConnection_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointConnection_STATUSARM instances for property testing - lazily instantiated by
// PrivateEndpointConnectionSTATUSARMGenerator()
var privateEndpointConnectionSTATUSARMGenerator gopter.Gen

// PrivateEndpointConnectionSTATUSARMGenerator returns a generator of PrivateEndpointConnection_STATUSARM instances for property testing.
// We first initialize privateEndpointConnectionSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateEndpointConnectionSTATUSARMGenerator() gopter.Gen {
	if privateEndpointConnectionSTATUSARMGenerator != nil {
		return privateEndpointConnectionSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnectionSTATUSARM(generators)
	privateEndpointConnectionSTATUSARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnection_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnectionSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForPrivateEndpointConnectionSTATUSARM(generators)
	privateEndpointConnectionSTATUSARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnection_STATUSARM{}), generators)

	return privateEndpointConnectionSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointConnectionSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointConnectionSTATUSARM(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPrivateEndpointConnectionSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateEndpointConnectionSTATUSARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(PrivateEndpointConnectionPropertiesSTATUSARMGenerator())
}

func Test_VirtualMachineFamilyCoreQuota_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineFamilyCoreQuota_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineFamilyCoreQuotaSTATUSARM, VirtualMachineFamilyCoreQuotaSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineFamilyCoreQuotaSTATUSARM runs a test to see if a specific instance of VirtualMachineFamilyCoreQuota_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineFamilyCoreQuotaSTATUSARM(subject VirtualMachineFamilyCoreQuota_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineFamilyCoreQuota_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineFamilyCoreQuota_STATUSARM instances for property testing - lazily instantiated by
// VirtualMachineFamilyCoreQuotaSTATUSARMGenerator()
var virtualMachineFamilyCoreQuotaSTATUSARMGenerator gopter.Gen

// VirtualMachineFamilyCoreQuotaSTATUSARMGenerator returns a generator of VirtualMachineFamilyCoreQuota_STATUSARM instances for property testing.
func VirtualMachineFamilyCoreQuotaSTATUSARMGenerator() gopter.Gen {
	if virtualMachineFamilyCoreQuotaSTATUSARMGenerator != nil {
		return virtualMachineFamilyCoreQuotaSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineFamilyCoreQuotaSTATUSARM(generators)
	virtualMachineFamilyCoreQuotaSTATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineFamilyCoreQuota_STATUSARM{}), generators)

	return virtualMachineFamilyCoreQuotaSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineFamilyCoreQuotaSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineFamilyCoreQuotaSTATUSARM(gens map[string]gopter.Gen) {
	gens["CoreQuota"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_KeyVaultProperties_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultProperties_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultPropertiesSTATUSARM, KeyVaultPropertiesSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultPropertiesSTATUSARM runs a test to see if a specific instance of KeyVaultProperties_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultPropertiesSTATUSARM(subject KeyVaultProperties_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultProperties_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultProperties_STATUSARM instances for property testing - lazily instantiated by
// KeyVaultPropertiesSTATUSARMGenerator()
var keyVaultPropertiesSTATUSARMGenerator gopter.Gen

// KeyVaultPropertiesSTATUSARMGenerator returns a generator of KeyVaultProperties_STATUSARM instances for property testing.
func KeyVaultPropertiesSTATUSARMGenerator() gopter.Gen {
	if keyVaultPropertiesSTATUSARMGenerator != nil {
		return keyVaultPropertiesSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultPropertiesSTATUSARM(generators)
	keyVaultPropertiesSTATUSARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultProperties_STATUSARM{}), generators)

	return keyVaultPropertiesSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultPropertiesSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultPropertiesSTATUSARM(gens map[string]gopter.Gen) {
	gens["KeyIdentifier"] = gen.PtrOf(gen.AlphaString())
}

func Test_PrivateEndpointConnectionProperties_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointConnectionProperties_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointConnectionPropertiesSTATUSARM, PrivateEndpointConnectionPropertiesSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointConnectionPropertiesSTATUSARM runs a test to see if a specific instance of PrivateEndpointConnectionProperties_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointConnectionPropertiesSTATUSARM(subject PrivateEndpointConnectionProperties_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointConnectionProperties_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointConnectionProperties_STATUSARM instances for property testing - lazily instantiated by
// PrivateEndpointConnectionPropertiesSTATUSARMGenerator()
var privateEndpointConnectionPropertiesSTATUSARMGenerator gopter.Gen

// PrivateEndpointConnectionPropertiesSTATUSARMGenerator returns a generator of PrivateEndpointConnectionProperties_STATUSARM instances for property testing.
// We first initialize privateEndpointConnectionPropertiesSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateEndpointConnectionPropertiesSTATUSARMGenerator() gopter.Gen {
	if privateEndpointConnectionPropertiesSTATUSARMGenerator != nil {
		return privateEndpointConnectionPropertiesSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnectionPropertiesSTATUSARM(generators)
	privateEndpointConnectionPropertiesSTATUSARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnectionProperties_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnectionPropertiesSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForPrivateEndpointConnectionPropertiesSTATUSARM(generators)
	privateEndpointConnectionPropertiesSTATUSARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnectionProperties_STATUSARM{}), generators)

	return privateEndpointConnectionPropertiesSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointConnectionPropertiesSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointConnectionPropertiesSTATUSARM(gens map[string]gopter.Gen) {
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(PrivateEndpointConnectionPropertiesSTATUSProvisioningState_Failed, PrivateEndpointConnectionPropertiesSTATUSProvisioningState_Succeeded, PrivateEndpointConnectionPropertiesSTATUSProvisioningState_Updating))
}

// AddRelatedPropertyGeneratorsForPrivateEndpointConnectionPropertiesSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateEndpointConnectionPropertiesSTATUSARM(gens map[string]gopter.Gen) {
	gens["PrivateEndpoint"] = gen.PtrOf(PrivateEndpointSTATUSARMGenerator())
	gens["PrivateLinkServiceConnectionState"] = gen.PtrOf(PrivateLinkServiceConnectionStateSTATUSARMGenerator())
}

func Test_PrivateEndpoint_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpoint_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointSTATUSARM, PrivateEndpointSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointSTATUSARM runs a test to see if a specific instance of PrivateEndpoint_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointSTATUSARM(subject PrivateEndpoint_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpoint_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpoint_STATUSARM instances for property testing - lazily instantiated by
// PrivateEndpointSTATUSARMGenerator()
var privateEndpointSTATUSARMGenerator gopter.Gen

// PrivateEndpointSTATUSARMGenerator returns a generator of PrivateEndpoint_STATUSARM instances for property testing.
func PrivateEndpointSTATUSARMGenerator() gopter.Gen {
	if privateEndpointSTATUSARMGenerator != nil {
		return privateEndpointSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointSTATUSARM(generators)
	privateEndpointSTATUSARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpoint_STATUSARM{}), generators)

	return privateEndpointSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointSTATUSARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_PrivateLinkServiceConnectionState_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateLinkServiceConnectionState_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateLinkServiceConnectionStateSTATUSARM, PrivateLinkServiceConnectionStateSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateLinkServiceConnectionStateSTATUSARM runs a test to see if a specific instance of PrivateLinkServiceConnectionState_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateLinkServiceConnectionStateSTATUSARM(subject PrivateLinkServiceConnectionState_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateLinkServiceConnectionState_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateLinkServiceConnectionState_STATUSARM instances for property testing - lazily instantiated by
// PrivateLinkServiceConnectionStateSTATUSARMGenerator()
var privateLinkServiceConnectionStateSTATUSARMGenerator gopter.Gen

// PrivateLinkServiceConnectionStateSTATUSARMGenerator returns a generator of PrivateLinkServiceConnectionState_STATUSARM instances for property testing.
func PrivateLinkServiceConnectionStateSTATUSARMGenerator() gopter.Gen {
	if privateLinkServiceConnectionStateSTATUSARMGenerator != nil {
		return privateLinkServiceConnectionStateSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkServiceConnectionStateSTATUSARM(generators)
	privateLinkServiceConnectionStateSTATUSARMGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServiceConnectionState_STATUSARM{}), generators)

	return privateLinkServiceConnectionStateSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateLinkServiceConnectionStateSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateLinkServiceConnectionStateSTATUSARM(gens map[string]gopter.Gen) {
	gens["ActionRequired"] = gen.PtrOf(gen.AlphaString())
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(
		PrivateLinkServiceConnectionStatus_STATUS_Approved,
		PrivateLinkServiceConnectionStatus_STATUS_Disconnected,
		PrivateLinkServiceConnectionStatus_STATUS_Pending,
		PrivateLinkServiceConnectionStatus_STATUS_Rejected))
}
