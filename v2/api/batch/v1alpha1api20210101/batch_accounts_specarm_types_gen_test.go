// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20210101

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_BatchAccounts_SPECARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BatchAccounts_SPECARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBatchAccountsSPECARM, BatchAccountsSPECARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBatchAccountsSPECARM runs a test to see if a specific instance of BatchAccounts_SPECARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBatchAccountsSPECARM(subject BatchAccounts_SPECARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BatchAccounts_SPECARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BatchAccounts_SPECARM instances for property testing - lazily instantiated by
//BatchAccountsSPECARMGenerator()
var batchAccountsSPECARMGenerator gopter.Gen

// BatchAccountsSPECARMGenerator returns a generator of BatchAccounts_SPECARM instances for property testing.
// We first initialize batchAccountsSPECARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BatchAccountsSPECARMGenerator() gopter.Gen {
	if batchAccountsSPECARMGenerator != nil {
		return batchAccountsSPECARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccountsSPECARM(generators)
	batchAccountsSPECARMGenerator = gen.Struct(reflect.TypeOf(BatchAccounts_SPECARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccountsSPECARM(generators)
	AddRelatedPropertyGeneratorsForBatchAccountsSPECARM(generators)
	batchAccountsSPECARMGenerator = gen.Struct(reflect.TypeOf(BatchAccounts_SPECARM{}), generators)

	return batchAccountsSPECARMGenerator
}

// AddIndependentPropertyGeneratorsForBatchAccountsSPECARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBatchAccountsSPECARM(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Location"] = gen.AlphaString()
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForBatchAccountsSPECARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBatchAccountsSPECARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(BatchAccountIdentitySpecARMGenerator())
	gens["Properties"] = gen.PtrOf(BatchAccountCreatePropertiesSpecARMGenerator())
}

func Test_BatchAccountCreateProperties_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BatchAccountCreateProperties_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBatchAccountCreatePropertiesSpecARM, BatchAccountCreatePropertiesSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBatchAccountCreatePropertiesSpecARM runs a test to see if a specific instance of BatchAccountCreateProperties_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBatchAccountCreatePropertiesSpecARM(subject BatchAccountCreateProperties_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BatchAccountCreateProperties_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BatchAccountCreateProperties_SpecARM instances for property testing - lazily instantiated by
//BatchAccountCreatePropertiesSpecARMGenerator()
var batchAccountCreatePropertiesSpecARMGenerator gopter.Gen

// BatchAccountCreatePropertiesSpecARMGenerator returns a generator of BatchAccountCreateProperties_SpecARM instances for property testing.
// We first initialize batchAccountCreatePropertiesSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BatchAccountCreatePropertiesSpecARMGenerator() gopter.Gen {
	if batchAccountCreatePropertiesSpecARMGenerator != nil {
		return batchAccountCreatePropertiesSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccountCreatePropertiesSpecARM(generators)
	batchAccountCreatePropertiesSpecARMGenerator = gen.Struct(reflect.TypeOf(BatchAccountCreateProperties_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccountCreatePropertiesSpecARM(generators)
	AddRelatedPropertyGeneratorsForBatchAccountCreatePropertiesSpecARM(generators)
	batchAccountCreatePropertiesSpecARMGenerator = gen.Struct(reflect.TypeOf(BatchAccountCreateProperties_SpecARM{}), generators)

	return batchAccountCreatePropertiesSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForBatchAccountCreatePropertiesSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBatchAccountCreatePropertiesSpecARM(gens map[string]gopter.Gen) {
	gens["PoolAllocationMode"] = gen.PtrOf(gen.OneConstOf(PoolAllocationMode_SpecBatchService, PoolAllocationMode_SpecUserSubscription))
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(PublicNetworkAccessType_SpecDisabled, PublicNetworkAccessType_SpecEnabled))
}

// AddRelatedPropertyGeneratorsForBatchAccountCreatePropertiesSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBatchAccountCreatePropertiesSpecARM(gens map[string]gopter.Gen) {
	gens["AutoStorage"] = gen.PtrOf(AutoStorageBasePropertiesSpecARMGenerator())
	gens["Encryption"] = gen.PtrOf(EncryptionPropertiesSpecARMGenerator())
	gens["KeyVaultReference"] = gen.PtrOf(KeyVaultReferenceSpecARMGenerator())
}

func Test_BatchAccountIdentity_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BatchAccountIdentity_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBatchAccountIdentitySpecARM, BatchAccountIdentitySpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBatchAccountIdentitySpecARM runs a test to see if a specific instance of BatchAccountIdentity_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBatchAccountIdentitySpecARM(subject BatchAccountIdentity_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BatchAccountIdentity_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BatchAccountIdentity_SpecARM instances for property testing - lazily instantiated by
//BatchAccountIdentitySpecARMGenerator()
var batchAccountIdentitySpecARMGenerator gopter.Gen

// BatchAccountIdentitySpecARMGenerator returns a generator of BatchAccountIdentity_SpecARM instances for property testing.
func BatchAccountIdentitySpecARMGenerator() gopter.Gen {
	if batchAccountIdentitySpecARMGenerator != nil {
		return batchAccountIdentitySpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccountIdentitySpecARM(generators)
	batchAccountIdentitySpecARMGenerator = gen.Struct(reflect.TypeOf(BatchAccountIdentity_SpecARM{}), generators)

	return batchAccountIdentitySpecARMGenerator
}

// AddIndependentPropertyGeneratorsForBatchAccountIdentitySpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBatchAccountIdentitySpecARM(gens map[string]gopter.Gen) {
	gens["Type"] = gen.OneConstOf(BatchAccountIdentitySpecTypeNone, BatchAccountIdentitySpecTypeSystemAssigned, BatchAccountIdentitySpecTypeUserAssigned)
}

func Test_AutoStorageBaseProperties_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoStorageBaseProperties_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoStorageBasePropertiesSpecARM, AutoStorageBasePropertiesSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoStorageBasePropertiesSpecARM runs a test to see if a specific instance of AutoStorageBaseProperties_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoStorageBasePropertiesSpecARM(subject AutoStorageBaseProperties_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoStorageBaseProperties_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoStorageBaseProperties_SpecARM instances for property testing - lazily instantiated by
//AutoStorageBasePropertiesSpecARMGenerator()
var autoStorageBasePropertiesSpecARMGenerator gopter.Gen

// AutoStorageBasePropertiesSpecARMGenerator returns a generator of AutoStorageBaseProperties_SpecARM instances for property testing.
func AutoStorageBasePropertiesSpecARMGenerator() gopter.Gen {
	if autoStorageBasePropertiesSpecARMGenerator != nil {
		return autoStorageBasePropertiesSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoStorageBasePropertiesSpecARM(generators)
	autoStorageBasePropertiesSpecARMGenerator = gen.Struct(reflect.TypeOf(AutoStorageBaseProperties_SpecARM{}), generators)

	return autoStorageBasePropertiesSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForAutoStorageBasePropertiesSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoStorageBasePropertiesSpecARM(gens map[string]gopter.Gen) {
	gens["StorageAccountId"] = gen.AlphaString()
}

func Test_EncryptionProperties_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionProperties_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionPropertiesSpecARM, EncryptionPropertiesSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionPropertiesSpecARM runs a test to see if a specific instance of EncryptionProperties_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionPropertiesSpecARM(subject EncryptionProperties_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionProperties_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionProperties_SpecARM instances for property testing - lazily instantiated by
//EncryptionPropertiesSpecARMGenerator()
var encryptionPropertiesSpecARMGenerator gopter.Gen

// EncryptionPropertiesSpecARMGenerator returns a generator of EncryptionProperties_SpecARM instances for property testing.
// We first initialize encryptionPropertiesSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EncryptionPropertiesSpecARMGenerator() gopter.Gen {
	if encryptionPropertiesSpecARMGenerator != nil {
		return encryptionPropertiesSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionPropertiesSpecARM(generators)
	encryptionPropertiesSpecARMGenerator = gen.Struct(reflect.TypeOf(EncryptionProperties_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionPropertiesSpecARM(generators)
	AddRelatedPropertyGeneratorsForEncryptionPropertiesSpecARM(generators)
	encryptionPropertiesSpecARMGenerator = gen.Struct(reflect.TypeOf(EncryptionProperties_SpecARM{}), generators)

	return encryptionPropertiesSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionPropertiesSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionPropertiesSpecARM(gens map[string]gopter.Gen) {
	gens["KeySource"] = gen.PtrOf(gen.OneConstOf(EncryptionPropertiesSpecKeySourceMicrosoftBatch, EncryptionPropertiesSpecKeySourceMicrosoftKeyVault))
}

// AddRelatedPropertyGeneratorsForEncryptionPropertiesSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionPropertiesSpecARM(gens map[string]gopter.Gen) {
	gens["KeyVaultProperties"] = gen.PtrOf(KeyVaultPropertiesSpecARMGenerator())
}

func Test_KeyVaultReference_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultReference_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultReferenceSpecARM, KeyVaultReferenceSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultReferenceSpecARM runs a test to see if a specific instance of KeyVaultReference_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultReferenceSpecARM(subject KeyVaultReference_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultReference_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultReference_SpecARM instances for property testing - lazily instantiated by
//KeyVaultReferenceSpecARMGenerator()
var keyVaultReferenceSpecARMGenerator gopter.Gen

// KeyVaultReferenceSpecARMGenerator returns a generator of KeyVaultReference_SpecARM instances for property testing.
func KeyVaultReferenceSpecARMGenerator() gopter.Gen {
	if keyVaultReferenceSpecARMGenerator != nil {
		return keyVaultReferenceSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultReferenceSpecARM(generators)
	keyVaultReferenceSpecARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultReference_SpecARM{}), generators)

	return keyVaultReferenceSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultReferenceSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultReferenceSpecARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.AlphaString()
	gens["Url"] = gen.AlphaString()
}

func Test_KeyVaultProperties_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultProperties_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultPropertiesSpecARM, KeyVaultPropertiesSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultPropertiesSpecARM runs a test to see if a specific instance of KeyVaultProperties_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultPropertiesSpecARM(subject KeyVaultProperties_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultProperties_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultProperties_SpecARM instances for property testing - lazily instantiated by
//KeyVaultPropertiesSpecARMGenerator()
var keyVaultPropertiesSpecARMGenerator gopter.Gen

// KeyVaultPropertiesSpecARMGenerator returns a generator of KeyVaultProperties_SpecARM instances for property testing.
func KeyVaultPropertiesSpecARMGenerator() gopter.Gen {
	if keyVaultPropertiesSpecARMGenerator != nil {
		return keyVaultPropertiesSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultPropertiesSpecARM(generators)
	keyVaultPropertiesSpecARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultProperties_SpecARM{}), generators)

	return keyVaultPropertiesSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultPropertiesSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultPropertiesSpecARM(gens map[string]gopter.Gen) {
	gens["KeyIdentifier"] = gen.PtrOf(gen.AlphaString())
}
