// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20210101

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_BatchAccounts_SPECARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BatchAccounts_SPECARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBatchAccounts_SPECARM, BatchAccounts_SPECARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBatchAccounts_SPECARM runs a test to see if a specific instance of BatchAccounts_SPECARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBatchAccounts_SPECARM(subject BatchAccounts_SPECARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BatchAccounts_SPECARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BatchAccounts_SPECARM instances for property testing - lazily instantiated by
//BatchAccounts_SPECARMGenerator()
var batchAccounts_specarmGenerator gopter.Gen

// BatchAccounts_SPECARMGenerator returns a generator of BatchAccounts_SPECARM instances for property testing.
// We first initialize batchAccounts_specarmGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BatchAccounts_SPECARMGenerator() gopter.Gen {
	if batchAccounts_specarmGenerator != nil {
		return batchAccounts_specarmGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccounts_SPECARM(generators)
	batchAccounts_specarmGenerator = gen.Struct(reflect.TypeOf(BatchAccounts_SPECARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccounts_SPECARM(generators)
	AddRelatedPropertyGeneratorsForBatchAccounts_SPECARM(generators)
	batchAccounts_specarmGenerator = gen.Struct(reflect.TypeOf(BatchAccounts_SPECARM{}), generators)

	return batchAccounts_specarmGenerator
}

// AddIndependentPropertyGeneratorsForBatchAccounts_SPECARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBatchAccounts_SPECARM(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Location"] = gen.AlphaString()
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForBatchAccounts_SPECARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBatchAccounts_SPECARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(BatchAccountIdentity_SpecARMGenerator())
	gens["Properties"] = gen.PtrOf(BatchAccountCreateProperties_SpecARMGenerator())
}

func Test_BatchAccountCreateProperties_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BatchAccountCreateProperties_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBatchAccountCreateProperties_SpecARM, BatchAccountCreateProperties_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBatchAccountCreateProperties_SpecARM runs a test to see if a specific instance of BatchAccountCreateProperties_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBatchAccountCreateProperties_SpecARM(subject BatchAccountCreateProperties_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BatchAccountCreateProperties_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BatchAccountCreateProperties_SpecARM instances for property testing - lazily instantiated by
//BatchAccountCreateProperties_SpecARMGenerator()
var batchAccountCreateProperties_specARMGenerator gopter.Gen

// BatchAccountCreateProperties_SpecARMGenerator returns a generator of BatchAccountCreateProperties_SpecARM instances for property testing.
// We first initialize batchAccountCreateProperties_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BatchAccountCreateProperties_SpecARMGenerator() gopter.Gen {
	if batchAccountCreateProperties_specARMGenerator != nil {
		return batchAccountCreateProperties_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccountCreateProperties_SpecARM(generators)
	batchAccountCreateProperties_specARMGenerator = gen.Struct(reflect.TypeOf(BatchAccountCreateProperties_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccountCreateProperties_SpecARM(generators)
	AddRelatedPropertyGeneratorsForBatchAccountCreateProperties_SpecARM(generators)
	batchAccountCreateProperties_specARMGenerator = gen.Struct(reflect.TypeOf(BatchAccountCreateProperties_SpecARM{}), generators)

	return batchAccountCreateProperties_specARMGenerator
}

// AddIndependentPropertyGeneratorsForBatchAccountCreateProperties_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBatchAccountCreateProperties_SpecARM(gens map[string]gopter.Gen) {
	gens["PoolAllocationMode"] = gen.PtrOf(gen.OneConstOf(PoolAllocationMode_SpecBatchService, PoolAllocationMode_SpecUserSubscription))
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(PublicNetworkAccessType_SpecDisabled, PublicNetworkAccessType_SpecEnabled))
}

// AddRelatedPropertyGeneratorsForBatchAccountCreateProperties_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBatchAccountCreateProperties_SpecARM(gens map[string]gopter.Gen) {
	gens["AutoStorage"] = gen.PtrOf(AutoStorageBaseProperties_SpecARMGenerator())
	gens["Encryption"] = gen.PtrOf(EncryptionProperties_SpecARMGenerator())
	gens["KeyVaultReference"] = gen.PtrOf(KeyVaultReference_SpecARMGenerator())
}

func Test_BatchAccountIdentity_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BatchAccountIdentity_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBatchAccountIdentity_SpecARM, BatchAccountIdentity_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBatchAccountIdentity_SpecARM runs a test to see if a specific instance of BatchAccountIdentity_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBatchAccountIdentity_SpecARM(subject BatchAccountIdentity_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BatchAccountIdentity_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BatchAccountIdentity_SpecARM instances for property testing - lazily instantiated by
//BatchAccountIdentity_SpecARMGenerator()
var batchAccountIdentity_specARMGenerator gopter.Gen

// BatchAccountIdentity_SpecARMGenerator returns a generator of BatchAccountIdentity_SpecARM instances for property testing.
func BatchAccountIdentity_SpecARMGenerator() gopter.Gen {
	if batchAccountIdentity_specARMGenerator != nil {
		return batchAccountIdentity_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccountIdentity_SpecARM(generators)
	batchAccountIdentity_specARMGenerator = gen.Struct(reflect.TypeOf(BatchAccountIdentity_SpecARM{}), generators)

	return batchAccountIdentity_specARMGenerator
}

// AddIndependentPropertyGeneratorsForBatchAccountIdentity_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBatchAccountIdentity_SpecARM(gens map[string]gopter.Gen) {
	gens["Type"] = gen.OneConstOf(BatchAccountIdentity_Type_SpecNone, BatchAccountIdentity_Type_SpecSystemAssigned, BatchAccountIdentity_Type_SpecUserAssigned)
}

func Test_AutoStorageBaseProperties_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoStorageBaseProperties_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoStorageBaseProperties_SpecARM, AutoStorageBaseProperties_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoStorageBaseProperties_SpecARM runs a test to see if a specific instance of AutoStorageBaseProperties_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoStorageBaseProperties_SpecARM(subject AutoStorageBaseProperties_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoStorageBaseProperties_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoStorageBaseProperties_SpecARM instances for property testing - lazily instantiated by
//AutoStorageBaseProperties_SpecARMGenerator()
var autoStorageBaseProperties_specARMGenerator gopter.Gen

// AutoStorageBaseProperties_SpecARMGenerator returns a generator of AutoStorageBaseProperties_SpecARM instances for property testing.
func AutoStorageBaseProperties_SpecARMGenerator() gopter.Gen {
	if autoStorageBaseProperties_specARMGenerator != nil {
		return autoStorageBaseProperties_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoStorageBaseProperties_SpecARM(generators)
	autoStorageBaseProperties_specARMGenerator = gen.Struct(reflect.TypeOf(AutoStorageBaseProperties_SpecARM{}), generators)

	return autoStorageBaseProperties_specARMGenerator
}

// AddIndependentPropertyGeneratorsForAutoStorageBaseProperties_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoStorageBaseProperties_SpecARM(gens map[string]gopter.Gen) {
	gens["StorageAccountId"] = gen.AlphaString()
}

func Test_EncryptionProperties_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionProperties_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionProperties_SpecARM, EncryptionProperties_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionProperties_SpecARM runs a test to see if a specific instance of EncryptionProperties_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionProperties_SpecARM(subject EncryptionProperties_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionProperties_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionProperties_SpecARM instances for property testing - lazily instantiated by
//EncryptionProperties_SpecARMGenerator()
var encryptionProperties_specARMGenerator gopter.Gen

// EncryptionProperties_SpecARMGenerator returns a generator of EncryptionProperties_SpecARM instances for property testing.
// We first initialize encryptionProperties_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EncryptionProperties_SpecARMGenerator() gopter.Gen {
	if encryptionProperties_specARMGenerator != nil {
		return encryptionProperties_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionProperties_SpecARM(generators)
	encryptionProperties_specARMGenerator = gen.Struct(reflect.TypeOf(EncryptionProperties_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionProperties_SpecARM(generators)
	AddRelatedPropertyGeneratorsForEncryptionProperties_SpecARM(generators)
	encryptionProperties_specARMGenerator = gen.Struct(reflect.TypeOf(EncryptionProperties_SpecARM{}), generators)

	return encryptionProperties_specARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionProperties_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionProperties_SpecARM(gens map[string]gopter.Gen) {
	gens["KeySource"] = gen.PtrOf(gen.OneConstOf(EncryptionProperties_KeySource_SpecMicrosoftBatch, EncryptionProperties_KeySource_SpecMicrosoftKeyVault))
}

// AddRelatedPropertyGeneratorsForEncryptionProperties_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionProperties_SpecARM(gens map[string]gopter.Gen) {
	gens["KeyVaultProperties"] = gen.PtrOf(KeyVaultProperties_SpecARMGenerator())
}

func Test_KeyVaultReference_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultReference_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultReference_SpecARM, KeyVaultReference_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultReference_SpecARM runs a test to see if a specific instance of KeyVaultReference_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultReference_SpecARM(subject KeyVaultReference_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultReference_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultReference_SpecARM instances for property testing - lazily instantiated by
//KeyVaultReference_SpecARMGenerator()
var keyVaultReference_specARMGenerator gopter.Gen

// KeyVaultReference_SpecARMGenerator returns a generator of KeyVaultReference_SpecARM instances for property testing.
func KeyVaultReference_SpecARMGenerator() gopter.Gen {
	if keyVaultReference_specARMGenerator != nil {
		return keyVaultReference_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultReference_SpecARM(generators)
	keyVaultReference_specARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultReference_SpecARM{}), generators)

	return keyVaultReference_specARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultReference_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultReference_SpecARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.AlphaString()
	gens["Url"] = gen.AlphaString()
}

func Test_KeyVaultProperties_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultProperties_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultProperties_SpecARM, KeyVaultProperties_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultProperties_SpecARM runs a test to see if a specific instance of KeyVaultProperties_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultProperties_SpecARM(subject KeyVaultProperties_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultProperties_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultProperties_SpecARM instances for property testing - lazily instantiated by
//KeyVaultProperties_SpecARMGenerator()
var keyVaultProperties_specARMGenerator gopter.Gen

// KeyVaultProperties_SpecARMGenerator returns a generator of KeyVaultProperties_SpecARM instances for property testing.
func KeyVaultProperties_SpecARMGenerator() gopter.Gen {
	if keyVaultProperties_specARMGenerator != nil {
		return keyVaultProperties_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultProperties_SpecARM(generators)
	keyVaultProperties_specARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultProperties_SpecARM{}), generators)

	return keyVaultProperties_specARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultProperties_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultProperties_SpecARM(gens map[string]gopter.Gen) {
	gens["KeyIdentifier"] = gen.PtrOf(gen.AlphaString())
}
