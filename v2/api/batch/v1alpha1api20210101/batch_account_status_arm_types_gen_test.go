// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20210101

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_BatchAccount_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BatchAccount_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBatchAccount_STATUSARM, BatchAccount_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBatchAccount_STATUSARM runs a test to see if a specific instance of BatchAccount_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBatchAccount_STATUSARM(subject BatchAccount_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BatchAccount_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BatchAccount_STATUSARM instances for property testing - lazily instantiated by
// BatchAccount_STATUSARMGenerator()
var batchAccount_STATUSARMGenerator gopter.Gen

// BatchAccount_STATUSARMGenerator returns a generator of BatchAccount_STATUSARM instances for property testing.
// We first initialize batchAccount_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BatchAccount_STATUSARMGenerator() gopter.Gen {
	if batchAccount_STATUSARMGenerator != nil {
		return batchAccount_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccount_STATUSARM(generators)
	batchAccount_STATUSARMGenerator = gen.Struct(reflect.TypeOf(BatchAccount_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccount_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForBatchAccount_STATUSARM(generators)
	batchAccount_STATUSARMGenerator = gen.Struct(reflect.TypeOf(BatchAccount_STATUSARM{}), generators)

	return batchAccount_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForBatchAccount_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBatchAccount_STATUSARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForBatchAccount_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBatchAccount_STATUSARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(BatchAccountIdentity_STATUSARMGenerator())
	gens["Properties"] = gen.PtrOf(BatchAccountProperties_STATUSARMGenerator())
}

func Test_BatchAccountIdentity_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BatchAccountIdentity_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBatchAccountIdentity_STATUSARM, BatchAccountIdentity_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBatchAccountIdentity_STATUSARM runs a test to see if a specific instance of BatchAccountIdentity_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBatchAccountIdentity_STATUSARM(subject BatchAccountIdentity_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BatchAccountIdentity_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BatchAccountIdentity_STATUSARM instances for property testing - lazily instantiated by
// BatchAccountIdentity_STATUSARMGenerator()
var batchAccountIdentity_STATUSARMGenerator gopter.Gen

// BatchAccountIdentity_STATUSARMGenerator returns a generator of BatchAccountIdentity_STATUSARM instances for property testing.
// We first initialize batchAccountIdentity_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BatchAccountIdentity_STATUSARMGenerator() gopter.Gen {
	if batchAccountIdentity_STATUSARMGenerator != nil {
		return batchAccountIdentity_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccountIdentity_STATUSARM(generators)
	batchAccountIdentity_STATUSARMGenerator = gen.Struct(reflect.TypeOf(BatchAccountIdentity_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccountIdentity_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForBatchAccountIdentity_STATUSARM(generators)
	batchAccountIdentity_STATUSARMGenerator = gen.Struct(reflect.TypeOf(BatchAccountIdentity_STATUSARM{}), generators)

	return batchAccountIdentity_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForBatchAccountIdentity_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBatchAccountIdentity_STATUSARM(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(BatchAccountIdentity_STATUS_Type_None, BatchAccountIdentity_STATUS_Type_SystemAssigned, BatchAccountIdentity_STATUS_Type_UserAssigned))
}

// AddRelatedPropertyGeneratorsForBatchAccountIdentity_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBatchAccountIdentity_STATUSARM(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), BatchAccountIdentity_STATUS_UserAssignedIdentitiesARMGenerator())
}

func Test_BatchAccountProperties_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BatchAccountProperties_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBatchAccountProperties_STATUSARM, BatchAccountProperties_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBatchAccountProperties_STATUSARM runs a test to see if a specific instance of BatchAccountProperties_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBatchAccountProperties_STATUSARM(subject BatchAccountProperties_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BatchAccountProperties_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BatchAccountProperties_STATUSARM instances for property testing - lazily instantiated by
// BatchAccountProperties_STATUSARMGenerator()
var batchAccountProperties_STATUSARMGenerator gopter.Gen

// BatchAccountProperties_STATUSARMGenerator returns a generator of BatchAccountProperties_STATUSARM instances for property testing.
// We first initialize batchAccountProperties_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BatchAccountProperties_STATUSARMGenerator() gopter.Gen {
	if batchAccountProperties_STATUSARMGenerator != nil {
		return batchAccountProperties_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccountProperties_STATUSARM(generators)
	batchAccountProperties_STATUSARMGenerator = gen.Struct(reflect.TypeOf(BatchAccountProperties_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccountProperties_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForBatchAccountProperties_STATUSARM(generators)
	batchAccountProperties_STATUSARMGenerator = gen.Struct(reflect.TypeOf(BatchAccountProperties_STATUSARM{}), generators)

	return batchAccountProperties_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForBatchAccountProperties_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBatchAccountProperties_STATUSARM(gens map[string]gopter.Gen) {
	gens["AccountEndpoint"] = gen.PtrOf(gen.AlphaString())
	gens["ActiveJobAndJobScheduleQuota"] = gen.PtrOf(gen.Int())
	gens["DedicatedCoreQuota"] = gen.PtrOf(gen.Int())
	gens["DedicatedCoreQuotaPerVMFamilyEnforced"] = gen.PtrOf(gen.Bool())
	gens["LowPriorityCoreQuota"] = gen.PtrOf(gen.Int())
	gens["PoolAllocationMode"] = gen.PtrOf(gen.OneConstOf(PoolAllocationMode_STATUS_BatchService, PoolAllocationMode_STATUS_UserSubscription))
	gens["PoolQuota"] = gen.PtrOf(gen.Int())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		BatchAccountProperties_STATUS_ProvisioningState_Cancelled,
		BatchAccountProperties_STATUS_ProvisioningState_Creating,
		BatchAccountProperties_STATUS_ProvisioningState_Deleting,
		BatchAccountProperties_STATUS_ProvisioningState_Failed,
		BatchAccountProperties_STATUS_ProvisioningState_Invalid,
		BatchAccountProperties_STATUS_ProvisioningState_Succeeded))
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(PublicNetworkAccessType_STATUS_Disabled, PublicNetworkAccessType_STATUS_Enabled))
}

// AddRelatedPropertyGeneratorsForBatchAccountProperties_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBatchAccountProperties_STATUSARM(gens map[string]gopter.Gen) {
	gens["AutoStorage"] = gen.PtrOf(AutoStorageProperties_STATUSARMGenerator())
	gens["DedicatedCoreQuotaPerVMFamily"] = gen.SliceOf(VirtualMachineFamilyCoreQuota_STATUSARMGenerator())
	gens["Encryption"] = gen.PtrOf(EncryptionProperties_STATUSARMGenerator())
	gens["KeyVaultReference"] = gen.PtrOf(KeyVaultReference_STATUSARMGenerator())
	gens["PrivateEndpointConnections"] = gen.SliceOf(PrivateEndpointConnection_STATUSARMGenerator())
}

func Test_AutoStorageProperties_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoStorageProperties_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoStorageProperties_STATUSARM, AutoStorageProperties_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoStorageProperties_STATUSARM runs a test to see if a specific instance of AutoStorageProperties_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoStorageProperties_STATUSARM(subject AutoStorageProperties_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoStorageProperties_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoStorageProperties_STATUSARM instances for property testing - lazily instantiated by
// AutoStorageProperties_STATUSARMGenerator()
var autoStorageProperties_STATUSARMGenerator gopter.Gen

// AutoStorageProperties_STATUSARMGenerator returns a generator of AutoStorageProperties_STATUSARM instances for property testing.
func AutoStorageProperties_STATUSARMGenerator() gopter.Gen {
	if autoStorageProperties_STATUSARMGenerator != nil {
		return autoStorageProperties_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoStorageProperties_STATUSARM(generators)
	autoStorageProperties_STATUSARMGenerator = gen.Struct(reflect.TypeOf(AutoStorageProperties_STATUSARM{}), generators)

	return autoStorageProperties_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForAutoStorageProperties_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoStorageProperties_STATUSARM(gens map[string]gopter.Gen) {
	gens["LastKeySync"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountId"] = gen.PtrOf(gen.AlphaString())
}

func Test_BatchAccountIdentity_STATUS_UserAssignedIdentitiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BatchAccountIdentity_STATUS_UserAssignedIdentitiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBatchAccountIdentity_STATUS_UserAssignedIdentitiesARM, BatchAccountIdentity_STATUS_UserAssignedIdentitiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBatchAccountIdentity_STATUS_UserAssignedIdentitiesARM runs a test to see if a specific instance of BatchAccountIdentity_STATUS_UserAssignedIdentitiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBatchAccountIdentity_STATUS_UserAssignedIdentitiesARM(subject BatchAccountIdentity_STATUS_UserAssignedIdentitiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BatchAccountIdentity_STATUS_UserAssignedIdentitiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BatchAccountIdentity_STATUS_UserAssignedIdentitiesARM instances for property testing - lazily
// instantiated by BatchAccountIdentity_STATUS_UserAssignedIdentitiesARMGenerator()
var batchAccountIdentity_STATUS_UserAssignedIdentitiesARMGenerator gopter.Gen

// BatchAccountIdentity_STATUS_UserAssignedIdentitiesARMGenerator returns a generator of BatchAccountIdentity_STATUS_UserAssignedIdentitiesARM instances for property testing.
func BatchAccountIdentity_STATUS_UserAssignedIdentitiesARMGenerator() gopter.Gen {
	if batchAccountIdentity_STATUS_UserAssignedIdentitiesARMGenerator != nil {
		return batchAccountIdentity_STATUS_UserAssignedIdentitiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccountIdentity_STATUS_UserAssignedIdentitiesARM(generators)
	batchAccountIdentity_STATUS_UserAssignedIdentitiesARMGenerator = gen.Struct(reflect.TypeOf(BatchAccountIdentity_STATUS_UserAssignedIdentitiesARM{}), generators)

	return batchAccountIdentity_STATUS_UserAssignedIdentitiesARMGenerator
}

// AddIndependentPropertyGeneratorsForBatchAccountIdentity_STATUS_UserAssignedIdentitiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBatchAccountIdentity_STATUS_UserAssignedIdentitiesARM(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionProperties_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionProperties_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionProperties_STATUSARM, EncryptionProperties_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionProperties_STATUSARM runs a test to see if a specific instance of EncryptionProperties_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionProperties_STATUSARM(subject EncryptionProperties_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionProperties_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionProperties_STATUSARM instances for property testing - lazily instantiated by
// EncryptionProperties_STATUSARMGenerator()
var encryptionProperties_STATUSARMGenerator gopter.Gen

// EncryptionProperties_STATUSARMGenerator returns a generator of EncryptionProperties_STATUSARM instances for property testing.
// We first initialize encryptionProperties_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EncryptionProperties_STATUSARMGenerator() gopter.Gen {
	if encryptionProperties_STATUSARMGenerator != nil {
		return encryptionProperties_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionProperties_STATUSARM(generators)
	encryptionProperties_STATUSARMGenerator = gen.Struct(reflect.TypeOf(EncryptionProperties_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionProperties_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForEncryptionProperties_STATUSARM(generators)
	encryptionProperties_STATUSARMGenerator = gen.Struct(reflect.TypeOf(EncryptionProperties_STATUSARM{}), generators)

	return encryptionProperties_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionProperties_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionProperties_STATUSARM(gens map[string]gopter.Gen) {
	gens["KeySource"] = gen.PtrOf(gen.OneConstOf(EncryptionProperties_STATUS_KeySource_MicrosoftBatch, EncryptionProperties_STATUS_KeySource_MicrosoftKeyVault))
}

// AddRelatedPropertyGeneratorsForEncryptionProperties_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionProperties_STATUSARM(gens map[string]gopter.Gen) {
	gens["KeyVaultProperties"] = gen.PtrOf(KeyVaultProperties_STATUSARMGenerator())
}

func Test_KeyVaultReference_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultReference_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultReference_STATUSARM, KeyVaultReference_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultReference_STATUSARM runs a test to see if a specific instance of KeyVaultReference_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultReference_STATUSARM(subject KeyVaultReference_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultReference_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultReference_STATUSARM instances for property testing - lazily instantiated by
// KeyVaultReference_STATUSARMGenerator()
var keyVaultReference_STATUSARMGenerator gopter.Gen

// KeyVaultReference_STATUSARMGenerator returns a generator of KeyVaultReference_STATUSARM instances for property testing.
func KeyVaultReference_STATUSARMGenerator() gopter.Gen {
	if keyVaultReference_STATUSARMGenerator != nil {
		return keyVaultReference_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultReference_STATUSARM(generators)
	keyVaultReference_STATUSARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultReference_STATUSARM{}), generators)

	return keyVaultReference_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultReference_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultReference_STATUSARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Url"] = gen.PtrOf(gen.AlphaString())
}

func Test_PrivateEndpointConnection_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointConnection_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointConnection_STATUSARM, PrivateEndpointConnection_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointConnection_STATUSARM runs a test to see if a specific instance of PrivateEndpointConnection_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointConnection_STATUSARM(subject PrivateEndpointConnection_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointConnection_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointConnection_STATUSARM instances for property testing - lazily instantiated by
// PrivateEndpointConnection_STATUSARMGenerator()
var privateEndpointConnection_STATUSARMGenerator gopter.Gen

// PrivateEndpointConnection_STATUSARMGenerator returns a generator of PrivateEndpointConnection_STATUSARM instances for property testing.
// We first initialize privateEndpointConnection_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateEndpointConnection_STATUSARMGenerator() gopter.Gen {
	if privateEndpointConnection_STATUSARMGenerator != nil {
		return privateEndpointConnection_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnection_STATUSARM(generators)
	privateEndpointConnection_STATUSARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnection_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnection_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForPrivateEndpointConnection_STATUSARM(generators)
	privateEndpointConnection_STATUSARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnection_STATUSARM{}), generators)

	return privateEndpointConnection_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointConnection_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointConnection_STATUSARM(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPrivateEndpointConnection_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateEndpointConnection_STATUSARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(PrivateEndpointConnectionProperties_STATUSARMGenerator())
}

func Test_VirtualMachineFamilyCoreQuota_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineFamilyCoreQuota_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineFamilyCoreQuota_STATUSARM, VirtualMachineFamilyCoreQuota_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineFamilyCoreQuota_STATUSARM runs a test to see if a specific instance of VirtualMachineFamilyCoreQuota_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineFamilyCoreQuota_STATUSARM(subject VirtualMachineFamilyCoreQuota_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineFamilyCoreQuota_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineFamilyCoreQuota_STATUSARM instances for property testing - lazily instantiated by
// VirtualMachineFamilyCoreQuota_STATUSARMGenerator()
var virtualMachineFamilyCoreQuota_STATUSARMGenerator gopter.Gen

// VirtualMachineFamilyCoreQuota_STATUSARMGenerator returns a generator of VirtualMachineFamilyCoreQuota_STATUSARM instances for property testing.
func VirtualMachineFamilyCoreQuota_STATUSARMGenerator() gopter.Gen {
	if virtualMachineFamilyCoreQuota_STATUSARMGenerator != nil {
		return virtualMachineFamilyCoreQuota_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineFamilyCoreQuota_STATUSARM(generators)
	virtualMachineFamilyCoreQuota_STATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineFamilyCoreQuota_STATUSARM{}), generators)

	return virtualMachineFamilyCoreQuota_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineFamilyCoreQuota_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineFamilyCoreQuota_STATUSARM(gens map[string]gopter.Gen) {
	gens["CoreQuota"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_KeyVaultProperties_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultProperties_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultProperties_STATUSARM, KeyVaultProperties_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultProperties_STATUSARM runs a test to see if a specific instance of KeyVaultProperties_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultProperties_STATUSARM(subject KeyVaultProperties_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultProperties_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultProperties_STATUSARM instances for property testing - lazily instantiated by
// KeyVaultProperties_STATUSARMGenerator()
var keyVaultProperties_STATUSARMGenerator gopter.Gen

// KeyVaultProperties_STATUSARMGenerator returns a generator of KeyVaultProperties_STATUSARM instances for property testing.
func KeyVaultProperties_STATUSARMGenerator() gopter.Gen {
	if keyVaultProperties_STATUSARMGenerator != nil {
		return keyVaultProperties_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultProperties_STATUSARM(generators)
	keyVaultProperties_STATUSARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultProperties_STATUSARM{}), generators)

	return keyVaultProperties_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultProperties_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultProperties_STATUSARM(gens map[string]gopter.Gen) {
	gens["KeyIdentifier"] = gen.PtrOf(gen.AlphaString())
}

func Test_PrivateEndpointConnectionProperties_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointConnectionProperties_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointConnectionProperties_STATUSARM, PrivateEndpointConnectionProperties_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointConnectionProperties_STATUSARM runs a test to see if a specific instance of PrivateEndpointConnectionProperties_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointConnectionProperties_STATUSARM(subject PrivateEndpointConnectionProperties_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointConnectionProperties_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointConnectionProperties_STATUSARM instances for property testing - lazily instantiated by
// PrivateEndpointConnectionProperties_STATUSARMGenerator()
var privateEndpointConnectionProperties_STATUSARMGenerator gopter.Gen

// PrivateEndpointConnectionProperties_STATUSARMGenerator returns a generator of PrivateEndpointConnectionProperties_STATUSARM instances for property testing.
// We first initialize privateEndpointConnectionProperties_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateEndpointConnectionProperties_STATUSARMGenerator() gopter.Gen {
	if privateEndpointConnectionProperties_STATUSARMGenerator != nil {
		return privateEndpointConnectionProperties_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnectionProperties_STATUSARM(generators)
	privateEndpointConnectionProperties_STATUSARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnectionProperties_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnectionProperties_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForPrivateEndpointConnectionProperties_STATUSARM(generators)
	privateEndpointConnectionProperties_STATUSARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnectionProperties_STATUSARM{}), generators)

	return privateEndpointConnectionProperties_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointConnectionProperties_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointConnectionProperties_STATUSARM(gens map[string]gopter.Gen) {
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(PrivateEndpointConnectionProperties_STATUS_ProvisioningState_Failed, PrivateEndpointConnectionProperties_STATUS_ProvisioningState_Succeeded, PrivateEndpointConnectionProperties_STATUS_ProvisioningState_Updating))
}

// AddRelatedPropertyGeneratorsForPrivateEndpointConnectionProperties_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateEndpointConnectionProperties_STATUSARM(gens map[string]gopter.Gen) {
	gens["PrivateEndpoint"] = gen.PtrOf(PrivateEndpoint_STATUSARMGenerator())
	gens["PrivateLinkServiceConnectionState"] = gen.PtrOf(PrivateLinkServiceConnectionState_STATUSARMGenerator())
}

func Test_PrivateEndpoint_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpoint_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpoint_STATUSARM, PrivateEndpoint_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpoint_STATUSARM runs a test to see if a specific instance of PrivateEndpoint_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpoint_STATUSARM(subject PrivateEndpoint_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpoint_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpoint_STATUSARM instances for property testing - lazily instantiated by
// PrivateEndpoint_STATUSARMGenerator()
var privateEndpoint_STATUSARMGenerator gopter.Gen

// PrivateEndpoint_STATUSARMGenerator returns a generator of PrivateEndpoint_STATUSARM instances for property testing.
func PrivateEndpoint_STATUSARMGenerator() gopter.Gen {
	if privateEndpoint_STATUSARMGenerator != nil {
		return privateEndpoint_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpoint_STATUSARM(generators)
	privateEndpoint_STATUSARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpoint_STATUSARM{}), generators)

	return privateEndpoint_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpoint_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpoint_STATUSARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_PrivateLinkServiceConnectionState_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateLinkServiceConnectionState_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateLinkServiceConnectionState_STATUSARM, PrivateLinkServiceConnectionState_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateLinkServiceConnectionState_STATUSARM runs a test to see if a specific instance of PrivateLinkServiceConnectionState_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateLinkServiceConnectionState_STATUSARM(subject PrivateLinkServiceConnectionState_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateLinkServiceConnectionState_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateLinkServiceConnectionState_STATUSARM instances for property testing - lazily instantiated by
// PrivateLinkServiceConnectionState_STATUSARMGenerator()
var privateLinkServiceConnectionState_STATUSARMGenerator gopter.Gen

// PrivateLinkServiceConnectionState_STATUSARMGenerator returns a generator of PrivateLinkServiceConnectionState_STATUSARM instances for property testing.
func PrivateLinkServiceConnectionState_STATUSARMGenerator() gopter.Gen {
	if privateLinkServiceConnectionState_STATUSARMGenerator != nil {
		return privateLinkServiceConnectionState_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkServiceConnectionState_STATUSARM(generators)
	privateLinkServiceConnectionState_STATUSARMGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServiceConnectionState_STATUSARM{}), generators)

	return privateLinkServiceConnectionState_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateLinkServiceConnectionState_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateLinkServiceConnectionState_STATUSARM(gens map[string]gopter.Gen) {
	gens["ActionRequired"] = gen.PtrOf(gen.AlphaString())
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(
		PrivateLinkServiceConnectionStatus_STATUS_Approved,
		PrivateLinkServiceConnectionStatus_STATUS_Disconnected,
		PrivateLinkServiceConnectionStatus_STATUS_Pending,
		PrivateLinkServiceConnectionStatus_STATUS_Rejected))
}
