// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20210101

import (
	"encoding/json"
	"github.com/Azure/azure-service-operator/v2/api/batch/v1alpha1api20210101storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_BatchAccount_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BatchAccount to hub returns original",
		prop.ForAll(RunResourceConversionTestForBatchAccount, BatchAccountGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForBatchAccount tests if a specific instance of BatchAccount round trips to the hub storage version and back losslessly
func RunResourceConversionTestForBatchAccount(subject BatchAccount) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v1alpha1api20210101storage.BatchAccount
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual BatchAccount
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BatchAccount_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BatchAccount to BatchAccount via AssignPropertiesToBatchAccount & AssignPropertiesFromBatchAccount returns original",
		prop.ForAll(RunPropertyAssignmentTestForBatchAccount, BatchAccountGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBatchAccount tests if a specific instance of BatchAccount can be assigned to v1alpha1api20210101storage and back losslessly
func RunPropertyAssignmentTestForBatchAccount(subject BatchAccount) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210101storage.BatchAccount
	err := copied.AssignPropertiesToBatchAccount(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BatchAccount
	err = actual.AssignPropertiesFromBatchAccount(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BatchAccount_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BatchAccount via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBatchAccount, BatchAccountGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBatchAccount runs a test to see if a specific instance of BatchAccount round trips to JSON and back losslessly
func RunJSONSerializationTestForBatchAccount(subject BatchAccount) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BatchAccount
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BatchAccount instances for property testing - lazily instantiated by BatchAccountGenerator()
var batchAccountGenerator gopter.Gen

// BatchAccountGenerator returns a generator of BatchAccount instances for property testing.
func BatchAccountGenerator() gopter.Gen {
	if batchAccountGenerator != nil {
		return batchAccountGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForBatchAccount(generators)
	batchAccountGenerator = gen.Struct(reflect.TypeOf(BatchAccount{}), generators)

	return batchAccountGenerator
}

// AddRelatedPropertyGeneratorsForBatchAccount is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBatchAccount(gens map[string]gopter.Gen) {
	gens["Spec"] = BatchAccounts_SPECGenerator()
	gens["Status"] = BatchAccount_StatusGenerator()
}

func Test_BatchAccount_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BatchAccount_Status to BatchAccount_Status via AssignPropertiesToBatchAccount_Status & AssignPropertiesFromBatchAccount_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForBatchAccount_Status, BatchAccount_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBatchAccount_Status tests if a specific instance of BatchAccount_Status can be assigned to v1alpha1api20210101storage and back losslessly
func RunPropertyAssignmentTestForBatchAccount_Status(subject BatchAccount_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210101storage.BatchAccount_Status
	err := copied.AssignPropertiesToBatchAccount_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BatchAccount_Status
	err = actual.AssignPropertiesFromBatchAccount_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BatchAccount_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BatchAccount_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBatchAccount_Status, BatchAccount_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBatchAccount_Status runs a test to see if a specific instance of BatchAccount_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForBatchAccount_Status(subject BatchAccount_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BatchAccount_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BatchAccount_Status instances for property testing - lazily instantiated by
//BatchAccount_StatusGenerator()
var batchAccount_statusGenerator gopter.Gen

// BatchAccount_StatusGenerator returns a generator of BatchAccount_Status instances for property testing.
// We first initialize batchAccount_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BatchAccount_StatusGenerator() gopter.Gen {
	if batchAccount_statusGenerator != nil {
		return batchAccount_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccount_Status(generators)
	batchAccount_statusGenerator = gen.Struct(reflect.TypeOf(BatchAccount_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccount_Status(generators)
	AddRelatedPropertyGeneratorsForBatchAccount_Status(generators)
	batchAccount_statusGenerator = gen.Struct(reflect.TypeOf(BatchAccount_Status{}), generators)

	return batchAccount_statusGenerator
}

// AddIndependentPropertyGeneratorsForBatchAccount_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBatchAccount_Status(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["PoolAllocationMode"] = gen.PtrOf(gen.OneConstOf(PoolAllocationMode_StatusBatchService, PoolAllocationMode_StatusUserSubscription))
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(PublicNetworkAccessType_StatusDisabled, PublicNetworkAccessType_StatusEnabled))
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForBatchAccount_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBatchAccount_Status(gens map[string]gopter.Gen) {
	gens["AutoStorage"] = gen.PtrOf(AutoStorageBaseProperties_StatusGenerator())
	gens["Encryption"] = gen.PtrOf(EncryptionProperties_StatusGenerator())
	gens["Identity"] = gen.PtrOf(BatchAccountIdentity_StatusGenerator())
	gens["KeyVaultReference"] = gen.PtrOf(KeyVaultReference_StatusGenerator())
}

func Test_BatchAccounts_SPEC_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BatchAccounts_SPEC to BatchAccounts_SPEC via AssignPropertiesToBatchAccounts_SPEC & AssignPropertiesFromBatchAccounts_SPEC returns original",
		prop.ForAll(RunPropertyAssignmentTestForBatchAccounts_SPEC, BatchAccounts_SPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBatchAccounts_SPEC tests if a specific instance of BatchAccounts_SPEC can be assigned to v1alpha1api20210101storage and back losslessly
func RunPropertyAssignmentTestForBatchAccounts_SPEC(subject BatchAccounts_SPEC) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210101storage.BatchAccounts_SPEC
	err := copied.AssignPropertiesToBatchAccounts_SPEC(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BatchAccounts_SPEC
	err = actual.AssignPropertiesFromBatchAccounts_SPEC(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BatchAccounts_SPEC_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BatchAccounts_SPEC via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBatchAccounts_SPEC, BatchAccounts_SPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBatchAccounts_SPEC runs a test to see if a specific instance of BatchAccounts_SPEC round trips to JSON and back losslessly
func RunJSONSerializationTestForBatchAccounts_SPEC(subject BatchAccounts_SPEC) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BatchAccounts_SPEC
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BatchAccounts_SPEC instances for property testing - lazily instantiated by BatchAccounts_SPECGenerator()
var batchAccounts_specGenerator gopter.Gen

// BatchAccounts_SPECGenerator returns a generator of BatchAccounts_SPEC instances for property testing.
// We first initialize batchAccounts_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BatchAccounts_SPECGenerator() gopter.Gen {
	if batchAccounts_specGenerator != nil {
		return batchAccounts_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccounts_SPEC(generators)
	batchAccounts_specGenerator = gen.Struct(reflect.TypeOf(BatchAccounts_SPEC{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccounts_SPEC(generators)
	AddRelatedPropertyGeneratorsForBatchAccounts_SPEC(generators)
	batchAccounts_specGenerator = gen.Struct(reflect.TypeOf(BatchAccounts_SPEC{}), generators)

	return batchAccounts_specGenerator
}

// AddIndependentPropertyGeneratorsForBatchAccounts_SPEC is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBatchAccounts_SPEC(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Location"] = gen.AlphaString()
	gens["PoolAllocationMode"] = gen.PtrOf(gen.OneConstOf(PoolAllocationMode_SpecBatchService, PoolAllocationMode_SpecUserSubscription))
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(PublicNetworkAccessType_SpecDisabled, PublicNetworkAccessType_SpecEnabled))
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForBatchAccounts_SPEC is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBatchAccounts_SPEC(gens map[string]gopter.Gen) {
	gens["AutoStorage"] = gen.PtrOf(AutoStorageBaseProperties_SpecGenerator())
	gens["Encryption"] = gen.PtrOf(EncryptionProperties_SpecGenerator())
	gens["Identity"] = gen.PtrOf(BatchAccountIdentity_SpecGenerator())
	gens["KeyVaultReference"] = gen.PtrOf(KeyVaultReference_SpecGenerator())
}

func Test_AutoStorageBaseProperties_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AutoStorageBaseProperties_Spec to AutoStorageBaseProperties_Spec via AssignPropertiesToAutoStorageBaseProperties_Spec & AssignPropertiesFromAutoStorageBaseProperties_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForAutoStorageBaseProperties_Spec, AutoStorageBaseProperties_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAutoStorageBaseProperties_Spec tests if a specific instance of AutoStorageBaseProperties_Spec can be assigned to v1alpha1api20210101storage and back losslessly
func RunPropertyAssignmentTestForAutoStorageBaseProperties_Spec(subject AutoStorageBaseProperties_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210101storage.AutoStorageBaseProperties_Spec
	err := copied.AssignPropertiesToAutoStorageBaseProperties_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AutoStorageBaseProperties_Spec
	err = actual.AssignPropertiesFromAutoStorageBaseProperties_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AutoStorageBaseProperties_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoStorageBaseProperties_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoStorageBaseProperties_Spec, AutoStorageBaseProperties_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoStorageBaseProperties_Spec runs a test to see if a specific instance of AutoStorageBaseProperties_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoStorageBaseProperties_Spec(subject AutoStorageBaseProperties_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoStorageBaseProperties_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoStorageBaseProperties_Spec instances for property testing - lazily instantiated by
//AutoStorageBaseProperties_SpecGenerator()
var autoStorageBaseProperties_specGenerator gopter.Gen

// AutoStorageBaseProperties_SpecGenerator returns a generator of AutoStorageBaseProperties_Spec instances for property testing.
func AutoStorageBaseProperties_SpecGenerator() gopter.Gen {
	if autoStorageBaseProperties_specGenerator != nil {
		return autoStorageBaseProperties_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	autoStorageBaseProperties_specGenerator = gen.Struct(reflect.TypeOf(AutoStorageBaseProperties_Spec{}), generators)

	return autoStorageBaseProperties_specGenerator
}

func Test_AutoStorageBaseProperties_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AutoStorageBaseProperties_Status to AutoStorageBaseProperties_Status via AssignPropertiesToAutoStorageBaseProperties_Status & AssignPropertiesFromAutoStorageBaseProperties_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForAutoStorageBaseProperties_Status, AutoStorageBaseProperties_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAutoStorageBaseProperties_Status tests if a specific instance of AutoStorageBaseProperties_Status can be assigned to v1alpha1api20210101storage and back losslessly
func RunPropertyAssignmentTestForAutoStorageBaseProperties_Status(subject AutoStorageBaseProperties_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210101storage.AutoStorageBaseProperties_Status
	err := copied.AssignPropertiesToAutoStorageBaseProperties_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AutoStorageBaseProperties_Status
	err = actual.AssignPropertiesFromAutoStorageBaseProperties_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AutoStorageBaseProperties_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoStorageBaseProperties_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoStorageBaseProperties_Status, AutoStorageBaseProperties_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoStorageBaseProperties_Status runs a test to see if a specific instance of AutoStorageBaseProperties_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoStorageBaseProperties_Status(subject AutoStorageBaseProperties_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoStorageBaseProperties_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoStorageBaseProperties_Status instances for property testing - lazily instantiated by
//AutoStorageBaseProperties_StatusGenerator()
var autoStorageBaseProperties_statusGenerator gopter.Gen

// AutoStorageBaseProperties_StatusGenerator returns a generator of AutoStorageBaseProperties_Status instances for property testing.
func AutoStorageBaseProperties_StatusGenerator() gopter.Gen {
	if autoStorageBaseProperties_statusGenerator != nil {
		return autoStorageBaseProperties_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoStorageBaseProperties_Status(generators)
	autoStorageBaseProperties_statusGenerator = gen.Struct(reflect.TypeOf(AutoStorageBaseProperties_Status{}), generators)

	return autoStorageBaseProperties_statusGenerator
}

// AddIndependentPropertyGeneratorsForAutoStorageBaseProperties_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoStorageBaseProperties_Status(gens map[string]gopter.Gen) {
	gens["StorageAccountId"] = gen.AlphaString()
}

func Test_BatchAccountIdentity_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BatchAccountIdentity_Spec to BatchAccountIdentity_Spec via AssignPropertiesToBatchAccountIdentity_Spec & AssignPropertiesFromBatchAccountIdentity_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForBatchAccountIdentity_Spec, BatchAccountIdentity_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBatchAccountIdentity_Spec tests if a specific instance of BatchAccountIdentity_Spec can be assigned to v1alpha1api20210101storage and back losslessly
func RunPropertyAssignmentTestForBatchAccountIdentity_Spec(subject BatchAccountIdentity_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210101storage.BatchAccountIdentity_Spec
	err := copied.AssignPropertiesToBatchAccountIdentity_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BatchAccountIdentity_Spec
	err = actual.AssignPropertiesFromBatchAccountIdentity_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BatchAccountIdentity_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BatchAccountIdentity_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBatchAccountIdentity_Spec, BatchAccountIdentity_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBatchAccountIdentity_Spec runs a test to see if a specific instance of BatchAccountIdentity_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForBatchAccountIdentity_Spec(subject BatchAccountIdentity_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BatchAccountIdentity_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BatchAccountIdentity_Spec instances for property testing - lazily instantiated by
//BatchAccountIdentity_SpecGenerator()
var batchAccountIdentity_specGenerator gopter.Gen

// BatchAccountIdentity_SpecGenerator returns a generator of BatchAccountIdentity_Spec instances for property testing.
func BatchAccountIdentity_SpecGenerator() gopter.Gen {
	if batchAccountIdentity_specGenerator != nil {
		return batchAccountIdentity_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccountIdentity_Spec(generators)
	batchAccountIdentity_specGenerator = gen.Struct(reflect.TypeOf(BatchAccountIdentity_Spec{}), generators)

	return batchAccountIdentity_specGenerator
}

// AddIndependentPropertyGeneratorsForBatchAccountIdentity_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBatchAccountIdentity_Spec(gens map[string]gopter.Gen) {
	gens["Type"] = gen.OneConstOf(BatchAccountIdentity_Type_SpecNone, BatchAccountIdentity_Type_SpecSystemAssigned, BatchAccountIdentity_Type_SpecUserAssigned)
}

func Test_BatchAccountIdentity_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BatchAccountIdentity_Status to BatchAccountIdentity_Status via AssignPropertiesToBatchAccountIdentity_Status & AssignPropertiesFromBatchAccountIdentity_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForBatchAccountIdentity_Status, BatchAccountIdentity_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBatchAccountIdentity_Status tests if a specific instance of BatchAccountIdentity_Status can be assigned to v1alpha1api20210101storage and back losslessly
func RunPropertyAssignmentTestForBatchAccountIdentity_Status(subject BatchAccountIdentity_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210101storage.BatchAccountIdentity_Status
	err := copied.AssignPropertiesToBatchAccountIdentity_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BatchAccountIdentity_Status
	err = actual.AssignPropertiesFromBatchAccountIdentity_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BatchAccountIdentity_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BatchAccountIdentity_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBatchAccountIdentity_Status, BatchAccountIdentity_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBatchAccountIdentity_Status runs a test to see if a specific instance of BatchAccountIdentity_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForBatchAccountIdentity_Status(subject BatchAccountIdentity_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BatchAccountIdentity_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BatchAccountIdentity_Status instances for property testing - lazily instantiated by
//BatchAccountIdentity_StatusGenerator()
var batchAccountIdentity_statusGenerator gopter.Gen

// BatchAccountIdentity_StatusGenerator returns a generator of BatchAccountIdentity_Status instances for property testing.
// We first initialize batchAccountIdentity_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BatchAccountIdentity_StatusGenerator() gopter.Gen {
	if batchAccountIdentity_statusGenerator != nil {
		return batchAccountIdentity_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccountIdentity_Status(generators)
	batchAccountIdentity_statusGenerator = gen.Struct(reflect.TypeOf(BatchAccountIdentity_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccountIdentity_Status(generators)
	AddRelatedPropertyGeneratorsForBatchAccountIdentity_Status(generators)
	batchAccountIdentity_statusGenerator = gen.Struct(reflect.TypeOf(BatchAccountIdentity_Status{}), generators)

	return batchAccountIdentity_statusGenerator
}

// AddIndependentPropertyGeneratorsForBatchAccountIdentity_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBatchAccountIdentity_Status(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.OneConstOf(BatchAccountIdentity_Type_StatusNone, BatchAccountIdentity_Type_StatusSystemAssigned, BatchAccountIdentity_Type_StatusUserAssigned)
}

// AddRelatedPropertyGeneratorsForBatchAccountIdentity_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBatchAccountIdentity_Status(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), BatchAccountIdentity_UserAssignedIdentities_StatusGenerator())
}

func Test_EncryptionProperties_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EncryptionProperties_Spec to EncryptionProperties_Spec via AssignPropertiesToEncryptionProperties_Spec & AssignPropertiesFromEncryptionProperties_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForEncryptionProperties_Spec, EncryptionProperties_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEncryptionProperties_Spec tests if a specific instance of EncryptionProperties_Spec can be assigned to v1alpha1api20210101storage and back losslessly
func RunPropertyAssignmentTestForEncryptionProperties_Spec(subject EncryptionProperties_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210101storage.EncryptionProperties_Spec
	err := copied.AssignPropertiesToEncryptionProperties_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EncryptionProperties_Spec
	err = actual.AssignPropertiesFromEncryptionProperties_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EncryptionProperties_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionProperties_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionProperties_Spec, EncryptionProperties_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionProperties_Spec runs a test to see if a specific instance of EncryptionProperties_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionProperties_Spec(subject EncryptionProperties_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionProperties_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionProperties_Spec instances for property testing - lazily instantiated by
//EncryptionProperties_SpecGenerator()
var encryptionProperties_specGenerator gopter.Gen

// EncryptionProperties_SpecGenerator returns a generator of EncryptionProperties_Spec instances for property testing.
// We first initialize encryptionProperties_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EncryptionProperties_SpecGenerator() gopter.Gen {
	if encryptionProperties_specGenerator != nil {
		return encryptionProperties_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionProperties_Spec(generators)
	encryptionProperties_specGenerator = gen.Struct(reflect.TypeOf(EncryptionProperties_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionProperties_Spec(generators)
	AddRelatedPropertyGeneratorsForEncryptionProperties_Spec(generators)
	encryptionProperties_specGenerator = gen.Struct(reflect.TypeOf(EncryptionProperties_Spec{}), generators)

	return encryptionProperties_specGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionProperties_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionProperties_Spec(gens map[string]gopter.Gen) {
	gens["KeySource"] = gen.PtrOf(gen.OneConstOf(EncryptionProperties_KeySource_SpecMicrosoftBatch, EncryptionProperties_KeySource_SpecMicrosoftKeyVault))
}

// AddRelatedPropertyGeneratorsForEncryptionProperties_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionProperties_Spec(gens map[string]gopter.Gen) {
	gens["KeyVaultProperties"] = gen.PtrOf(KeyVaultProperties_SpecGenerator())
}

func Test_EncryptionProperties_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EncryptionProperties_Status to EncryptionProperties_Status via AssignPropertiesToEncryptionProperties_Status & AssignPropertiesFromEncryptionProperties_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForEncryptionProperties_Status, EncryptionProperties_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEncryptionProperties_Status tests if a specific instance of EncryptionProperties_Status can be assigned to v1alpha1api20210101storage and back losslessly
func RunPropertyAssignmentTestForEncryptionProperties_Status(subject EncryptionProperties_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210101storage.EncryptionProperties_Status
	err := copied.AssignPropertiesToEncryptionProperties_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EncryptionProperties_Status
	err = actual.AssignPropertiesFromEncryptionProperties_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EncryptionProperties_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionProperties_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionProperties_Status, EncryptionProperties_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionProperties_Status runs a test to see if a specific instance of EncryptionProperties_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionProperties_Status(subject EncryptionProperties_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionProperties_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionProperties_Status instances for property testing - lazily instantiated by
//EncryptionProperties_StatusGenerator()
var encryptionProperties_statusGenerator gopter.Gen

// EncryptionProperties_StatusGenerator returns a generator of EncryptionProperties_Status instances for property testing.
// We first initialize encryptionProperties_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EncryptionProperties_StatusGenerator() gopter.Gen {
	if encryptionProperties_statusGenerator != nil {
		return encryptionProperties_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionProperties_Status(generators)
	encryptionProperties_statusGenerator = gen.Struct(reflect.TypeOf(EncryptionProperties_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionProperties_Status(generators)
	AddRelatedPropertyGeneratorsForEncryptionProperties_Status(generators)
	encryptionProperties_statusGenerator = gen.Struct(reflect.TypeOf(EncryptionProperties_Status{}), generators)

	return encryptionProperties_statusGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionProperties_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionProperties_Status(gens map[string]gopter.Gen) {
	gens["KeySource"] = gen.PtrOf(gen.OneConstOf(EncryptionProperties_KeySource_StatusMicrosoftBatch, EncryptionProperties_KeySource_StatusMicrosoftKeyVault))
}

// AddRelatedPropertyGeneratorsForEncryptionProperties_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionProperties_Status(gens map[string]gopter.Gen) {
	gens["KeyVaultProperties"] = gen.PtrOf(KeyVaultProperties_StatusGenerator())
}

func Test_KeyVaultReference_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KeyVaultReference_Spec to KeyVaultReference_Spec via AssignPropertiesToKeyVaultReference_Spec & AssignPropertiesFromKeyVaultReference_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForKeyVaultReference_Spec, KeyVaultReference_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKeyVaultReference_Spec tests if a specific instance of KeyVaultReference_Spec can be assigned to v1alpha1api20210101storage and back losslessly
func RunPropertyAssignmentTestForKeyVaultReference_Spec(subject KeyVaultReference_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210101storage.KeyVaultReference_Spec
	err := copied.AssignPropertiesToKeyVaultReference_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KeyVaultReference_Spec
	err = actual.AssignPropertiesFromKeyVaultReference_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KeyVaultReference_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultReference_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultReference_Spec, KeyVaultReference_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultReference_Spec runs a test to see if a specific instance of KeyVaultReference_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultReference_Spec(subject KeyVaultReference_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultReference_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultReference_Spec instances for property testing - lazily instantiated by
//KeyVaultReference_SpecGenerator()
var keyVaultReference_specGenerator gopter.Gen

// KeyVaultReference_SpecGenerator returns a generator of KeyVaultReference_Spec instances for property testing.
func KeyVaultReference_SpecGenerator() gopter.Gen {
	if keyVaultReference_specGenerator != nil {
		return keyVaultReference_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultReference_Spec(generators)
	keyVaultReference_specGenerator = gen.Struct(reflect.TypeOf(KeyVaultReference_Spec{}), generators)

	return keyVaultReference_specGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultReference_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultReference_Spec(gens map[string]gopter.Gen) {
	gens["Url"] = gen.AlphaString()
}

func Test_KeyVaultReference_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KeyVaultReference_Status to KeyVaultReference_Status via AssignPropertiesToKeyVaultReference_Status & AssignPropertiesFromKeyVaultReference_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForKeyVaultReference_Status, KeyVaultReference_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKeyVaultReference_Status tests if a specific instance of KeyVaultReference_Status can be assigned to v1alpha1api20210101storage and back losslessly
func RunPropertyAssignmentTestForKeyVaultReference_Status(subject KeyVaultReference_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210101storage.KeyVaultReference_Status
	err := copied.AssignPropertiesToKeyVaultReference_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KeyVaultReference_Status
	err = actual.AssignPropertiesFromKeyVaultReference_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KeyVaultReference_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultReference_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultReference_Status, KeyVaultReference_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultReference_Status runs a test to see if a specific instance of KeyVaultReference_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultReference_Status(subject KeyVaultReference_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultReference_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultReference_Status instances for property testing - lazily instantiated by
//KeyVaultReference_StatusGenerator()
var keyVaultReference_statusGenerator gopter.Gen

// KeyVaultReference_StatusGenerator returns a generator of KeyVaultReference_Status instances for property testing.
func KeyVaultReference_StatusGenerator() gopter.Gen {
	if keyVaultReference_statusGenerator != nil {
		return keyVaultReference_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultReference_Status(generators)
	keyVaultReference_statusGenerator = gen.Struct(reflect.TypeOf(KeyVaultReference_Status{}), generators)

	return keyVaultReference_statusGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultReference_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultReference_Status(gens map[string]gopter.Gen) {
	gens["Id"] = gen.AlphaString()
	gens["Url"] = gen.AlphaString()
}

func Test_BatchAccountIdentity_UserAssignedIdentities_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BatchAccountIdentity_UserAssignedIdentities_Status to BatchAccountIdentity_UserAssignedIdentities_Status via AssignPropertiesToBatchAccountIdentity_UserAssignedIdentities_Status & AssignPropertiesFromBatchAccountIdentity_UserAssignedIdentities_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForBatchAccountIdentity_UserAssignedIdentities_Status, BatchAccountIdentity_UserAssignedIdentities_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBatchAccountIdentity_UserAssignedIdentities_Status tests if a specific instance of BatchAccountIdentity_UserAssignedIdentities_Status can be assigned to v1alpha1api20210101storage and back losslessly
func RunPropertyAssignmentTestForBatchAccountIdentity_UserAssignedIdentities_Status(subject BatchAccountIdentity_UserAssignedIdentities_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210101storage.BatchAccountIdentity_UserAssignedIdentities_Status
	err := copied.AssignPropertiesToBatchAccountIdentity_UserAssignedIdentities_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BatchAccountIdentity_UserAssignedIdentities_Status
	err = actual.AssignPropertiesFromBatchAccountIdentity_UserAssignedIdentities_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BatchAccountIdentity_UserAssignedIdentities_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BatchAccountIdentity_UserAssignedIdentities_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBatchAccountIdentity_UserAssignedIdentities_Status, BatchAccountIdentity_UserAssignedIdentities_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBatchAccountIdentity_UserAssignedIdentities_Status runs a test to see if a specific instance of BatchAccountIdentity_UserAssignedIdentities_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForBatchAccountIdentity_UserAssignedIdentities_Status(subject BatchAccountIdentity_UserAssignedIdentities_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BatchAccountIdentity_UserAssignedIdentities_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BatchAccountIdentity_UserAssignedIdentities_Status instances for property testing - lazily instantiated
//by BatchAccountIdentity_UserAssignedIdentities_StatusGenerator()
var batchAccountIdentity_userAssignedIdentities_statusGenerator gopter.Gen

// BatchAccountIdentity_UserAssignedIdentities_StatusGenerator returns a generator of BatchAccountIdentity_UserAssignedIdentities_Status instances for property testing.
func BatchAccountIdentity_UserAssignedIdentities_StatusGenerator() gopter.Gen {
	if batchAccountIdentity_userAssignedIdentities_statusGenerator != nil {
		return batchAccountIdentity_userAssignedIdentities_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccountIdentity_UserAssignedIdentities_Status(generators)
	batchAccountIdentity_userAssignedIdentities_statusGenerator = gen.Struct(reflect.TypeOf(BatchAccountIdentity_UserAssignedIdentities_Status{}), generators)

	return batchAccountIdentity_userAssignedIdentities_statusGenerator
}

// AddIndependentPropertyGeneratorsForBatchAccountIdentity_UserAssignedIdentities_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBatchAccountIdentity_UserAssignedIdentities_Status(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_KeyVaultProperties_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KeyVaultProperties_Spec to KeyVaultProperties_Spec via AssignPropertiesToKeyVaultProperties_Spec & AssignPropertiesFromKeyVaultProperties_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForKeyVaultProperties_Spec, KeyVaultProperties_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKeyVaultProperties_Spec tests if a specific instance of KeyVaultProperties_Spec can be assigned to v1alpha1api20210101storage and back losslessly
func RunPropertyAssignmentTestForKeyVaultProperties_Spec(subject KeyVaultProperties_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210101storage.KeyVaultProperties_Spec
	err := copied.AssignPropertiesToKeyVaultProperties_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KeyVaultProperties_Spec
	err = actual.AssignPropertiesFromKeyVaultProperties_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KeyVaultProperties_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultProperties_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultProperties_Spec, KeyVaultProperties_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultProperties_Spec runs a test to see if a specific instance of KeyVaultProperties_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultProperties_Spec(subject KeyVaultProperties_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultProperties_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultProperties_Spec instances for property testing - lazily instantiated by
//KeyVaultProperties_SpecGenerator()
var keyVaultProperties_specGenerator gopter.Gen

// KeyVaultProperties_SpecGenerator returns a generator of KeyVaultProperties_Spec instances for property testing.
func KeyVaultProperties_SpecGenerator() gopter.Gen {
	if keyVaultProperties_specGenerator != nil {
		return keyVaultProperties_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultProperties_Spec(generators)
	keyVaultProperties_specGenerator = gen.Struct(reflect.TypeOf(KeyVaultProperties_Spec{}), generators)

	return keyVaultProperties_specGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultProperties_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultProperties_Spec(gens map[string]gopter.Gen) {
	gens["KeyIdentifier"] = gen.PtrOf(gen.AlphaString())
}

func Test_KeyVaultProperties_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KeyVaultProperties_Status to KeyVaultProperties_Status via AssignPropertiesToKeyVaultProperties_Status & AssignPropertiesFromKeyVaultProperties_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForKeyVaultProperties_Status, KeyVaultProperties_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKeyVaultProperties_Status tests if a specific instance of KeyVaultProperties_Status can be assigned to v1alpha1api20210101storage and back losslessly
func RunPropertyAssignmentTestForKeyVaultProperties_Status(subject KeyVaultProperties_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210101storage.KeyVaultProperties_Status
	err := copied.AssignPropertiesToKeyVaultProperties_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KeyVaultProperties_Status
	err = actual.AssignPropertiesFromKeyVaultProperties_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KeyVaultProperties_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultProperties_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultProperties_Status, KeyVaultProperties_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultProperties_Status runs a test to see if a specific instance of KeyVaultProperties_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultProperties_Status(subject KeyVaultProperties_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultProperties_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultProperties_Status instances for property testing - lazily instantiated by
//KeyVaultProperties_StatusGenerator()
var keyVaultProperties_statusGenerator gopter.Gen

// KeyVaultProperties_StatusGenerator returns a generator of KeyVaultProperties_Status instances for property testing.
func KeyVaultProperties_StatusGenerator() gopter.Gen {
	if keyVaultProperties_statusGenerator != nil {
		return keyVaultProperties_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultProperties_Status(generators)
	keyVaultProperties_statusGenerator = gen.Struct(reflect.TypeOf(KeyVaultProperties_Status{}), generators)

	return keyVaultProperties_statusGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultProperties_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultProperties_Status(gens map[string]gopter.Gen) {
	gens["KeyIdentifier"] = gen.PtrOf(gen.AlphaString())
}
