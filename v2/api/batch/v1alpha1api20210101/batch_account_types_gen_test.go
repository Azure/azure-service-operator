// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20210101

import (
	"encoding/json"
	"github.com/Azure/azure-service-operator/v2/api/batch/v1alpha1api20210101storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_BatchAccount_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BatchAccount to hub returns original",
		prop.ForAll(RunResourceConversionTestForBatchAccount, BatchAccountGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForBatchAccount tests if a specific instance of BatchAccount round trips to the hub storage version and back losslessly
func RunResourceConversionTestForBatchAccount(subject BatchAccount) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v1alpha1api20210101storage.BatchAccount
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual BatchAccount
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BatchAccount_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BatchAccount to BatchAccount via AssignPropertiesToBatchAccount & AssignPropertiesFromBatchAccount returns original",
		prop.ForAll(RunPropertyAssignmentTestForBatchAccount, BatchAccountGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBatchAccount tests if a specific instance of BatchAccount can be assigned to v1alpha1api20210101storage and back losslessly
func RunPropertyAssignmentTestForBatchAccount(subject BatchAccount) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210101storage.BatchAccount
	err := copied.AssignPropertiesToBatchAccount(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BatchAccount
	err = actual.AssignPropertiesFromBatchAccount(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BatchAccount_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BatchAccount via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBatchAccount, BatchAccountGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBatchAccount runs a test to see if a specific instance of BatchAccount round trips to JSON and back losslessly
func RunJSONSerializationTestForBatchAccount(subject BatchAccount) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BatchAccount
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BatchAccount instances for property testing - lazily instantiated by BatchAccountGenerator()
var batchAccountGenerator gopter.Gen

// BatchAccountGenerator returns a generator of BatchAccount instances for property testing.
func BatchAccountGenerator() gopter.Gen {
	if batchAccountGenerator != nil {
		return batchAccountGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForBatchAccount(generators)
	batchAccountGenerator = gen.Struct(reflect.TypeOf(BatchAccount{}), generators)

	return batchAccountGenerator
}

// AddRelatedPropertyGeneratorsForBatchAccount is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBatchAccount(gens map[string]gopter.Gen) {
	gens["Spec"] = BatchAccountsSPECGenerator()
	gens["Status"] = BatchAccountCreateParametersStatusGenerator()
}

func Test_BatchAccountCreateParameters_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BatchAccountCreateParameters_Status to BatchAccountCreateParameters_Status via AssignPropertiesToBatchAccountCreateParametersStatus & AssignPropertiesFromBatchAccountCreateParametersStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForBatchAccountCreateParametersStatus, BatchAccountCreateParametersStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBatchAccountCreateParametersStatus tests if a specific instance of BatchAccountCreateParameters_Status can be assigned to v1alpha1api20210101storage and back losslessly
func RunPropertyAssignmentTestForBatchAccountCreateParametersStatus(subject BatchAccountCreateParameters_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210101storage.BatchAccountCreateParameters_Status
	err := copied.AssignPropertiesToBatchAccountCreateParametersStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BatchAccountCreateParameters_Status
	err = actual.AssignPropertiesFromBatchAccountCreateParametersStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BatchAccountCreateParameters_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BatchAccountCreateParameters_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBatchAccountCreateParametersStatus, BatchAccountCreateParametersStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBatchAccountCreateParametersStatus runs a test to see if a specific instance of BatchAccountCreateParameters_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForBatchAccountCreateParametersStatus(subject BatchAccountCreateParameters_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BatchAccountCreateParameters_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BatchAccountCreateParameters_Status instances for property testing - lazily instantiated by
//BatchAccountCreateParametersStatusGenerator()
var batchAccountCreateParametersStatusGenerator gopter.Gen

// BatchAccountCreateParametersStatusGenerator returns a generator of BatchAccountCreateParameters_Status instances for property testing.
// We first initialize batchAccountCreateParametersStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BatchAccountCreateParametersStatusGenerator() gopter.Gen {
	if batchAccountCreateParametersStatusGenerator != nil {
		return batchAccountCreateParametersStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccountCreateParametersStatus(generators)
	batchAccountCreateParametersStatusGenerator = gen.Struct(reflect.TypeOf(BatchAccountCreateParameters_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccountCreateParametersStatus(generators)
	AddRelatedPropertyGeneratorsForBatchAccountCreateParametersStatus(generators)
	batchAccountCreateParametersStatusGenerator = gen.Struct(reflect.TypeOf(BatchAccountCreateParameters_Status{}), generators)

	return batchAccountCreateParametersStatusGenerator
}

// AddIndependentPropertyGeneratorsForBatchAccountCreateParametersStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBatchAccountCreateParametersStatus(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["PoolAllocationMode"] = gen.PtrOf(gen.OneConstOf(PoolAllocationMode_StatusBatchService, PoolAllocationMode_StatusUserSubscription))
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(PublicNetworkAccessType_StatusDisabled, PublicNetworkAccessType_StatusEnabled))
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForBatchAccountCreateParametersStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBatchAccountCreateParametersStatus(gens map[string]gopter.Gen) {
	gens["AutoStorage"] = gen.PtrOf(AutoStorageBasePropertiesStatusGenerator())
	gens["Encryption"] = gen.PtrOf(EncryptionPropertiesStatusGenerator())
	gens["Identity"] = gen.PtrOf(BatchAccountIdentityStatusGenerator())
	gens["KeyVaultReference"] = gen.PtrOf(KeyVaultReferenceStatusGenerator())
}

func Test_BatchAccounts_SPEC_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BatchAccounts_SPEC to BatchAccounts_SPEC via AssignPropertiesToBatchAccountsSPEC & AssignPropertiesFromBatchAccountsSPEC returns original",
		prop.ForAll(RunPropertyAssignmentTestForBatchAccountsSPEC, BatchAccountsSPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBatchAccountsSPEC tests if a specific instance of BatchAccounts_SPEC can be assigned to v1alpha1api20210101storage and back losslessly
func RunPropertyAssignmentTestForBatchAccountsSPEC(subject BatchAccounts_SPEC) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210101storage.BatchAccounts_SPEC
	err := copied.AssignPropertiesToBatchAccountsSPEC(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BatchAccounts_SPEC
	err = actual.AssignPropertiesFromBatchAccountsSPEC(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BatchAccounts_SPEC_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BatchAccounts_SPEC via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBatchAccountsSPEC, BatchAccountsSPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBatchAccountsSPEC runs a test to see if a specific instance of BatchAccounts_SPEC round trips to JSON and back losslessly
func RunJSONSerializationTestForBatchAccountsSPEC(subject BatchAccounts_SPEC) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BatchAccounts_SPEC
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BatchAccounts_SPEC instances for property testing - lazily instantiated by BatchAccountsSPECGenerator()
var batchAccountsSPECGenerator gopter.Gen

// BatchAccountsSPECGenerator returns a generator of BatchAccounts_SPEC instances for property testing.
// We first initialize batchAccountsSPECGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BatchAccountsSPECGenerator() gopter.Gen {
	if batchAccountsSPECGenerator != nil {
		return batchAccountsSPECGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccountsSPEC(generators)
	batchAccountsSPECGenerator = gen.Struct(reflect.TypeOf(BatchAccounts_SPEC{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccountsSPEC(generators)
	AddRelatedPropertyGeneratorsForBatchAccountsSPEC(generators)
	batchAccountsSPECGenerator = gen.Struct(reflect.TypeOf(BatchAccounts_SPEC{}), generators)

	return batchAccountsSPECGenerator
}

// AddIndependentPropertyGeneratorsForBatchAccountsSPEC is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBatchAccountsSPEC(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Location"] = gen.AlphaString()
	gens["PoolAllocationMode"] = gen.PtrOf(gen.OneConstOf(PoolAllocationMode_SpecBatchService, PoolAllocationMode_SpecUserSubscription))
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(PublicNetworkAccessType_SpecDisabled, PublicNetworkAccessType_SpecEnabled))
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForBatchAccountsSPEC is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBatchAccountsSPEC(gens map[string]gopter.Gen) {
	gens["AutoStorage"] = gen.PtrOf(AutoStorageBasePropertiesSpecGenerator())
	gens["Encryption"] = gen.PtrOf(EncryptionPropertiesSpecGenerator())
	gens["Identity"] = gen.PtrOf(BatchAccountIdentitySpecGenerator())
	gens["KeyVaultReference"] = gen.PtrOf(KeyVaultReferenceSpecGenerator())
}

func Test_AutoStorageBaseProperties_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AutoStorageBaseProperties_Spec to AutoStorageBaseProperties_Spec via AssignPropertiesToAutoStorageBasePropertiesSpec & AssignPropertiesFromAutoStorageBasePropertiesSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForAutoStorageBasePropertiesSpec, AutoStorageBasePropertiesSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAutoStorageBasePropertiesSpec tests if a specific instance of AutoStorageBaseProperties_Spec can be assigned to v1alpha1api20210101storage and back losslessly
func RunPropertyAssignmentTestForAutoStorageBasePropertiesSpec(subject AutoStorageBaseProperties_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210101storage.AutoStorageBaseProperties_Spec
	err := copied.AssignPropertiesToAutoStorageBasePropertiesSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AutoStorageBaseProperties_Spec
	err = actual.AssignPropertiesFromAutoStorageBasePropertiesSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AutoStorageBaseProperties_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoStorageBaseProperties_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoStorageBasePropertiesSpec, AutoStorageBasePropertiesSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoStorageBasePropertiesSpec runs a test to see if a specific instance of AutoStorageBaseProperties_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoStorageBasePropertiesSpec(subject AutoStorageBaseProperties_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoStorageBaseProperties_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoStorageBaseProperties_Spec instances for property testing - lazily instantiated by
//AutoStorageBasePropertiesSpecGenerator()
var autoStorageBasePropertiesSpecGenerator gopter.Gen

// AutoStorageBasePropertiesSpecGenerator returns a generator of AutoStorageBaseProperties_Spec instances for property testing.
func AutoStorageBasePropertiesSpecGenerator() gopter.Gen {
	if autoStorageBasePropertiesSpecGenerator != nil {
		return autoStorageBasePropertiesSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	autoStorageBasePropertiesSpecGenerator = gen.Struct(reflect.TypeOf(AutoStorageBaseProperties_Spec{}), generators)

	return autoStorageBasePropertiesSpecGenerator
}

func Test_AutoStorageBaseProperties_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AutoStorageBaseProperties_Status to AutoStorageBaseProperties_Status via AssignPropertiesToAutoStorageBasePropertiesStatus & AssignPropertiesFromAutoStorageBasePropertiesStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForAutoStorageBasePropertiesStatus, AutoStorageBasePropertiesStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAutoStorageBasePropertiesStatus tests if a specific instance of AutoStorageBaseProperties_Status can be assigned to v1alpha1api20210101storage and back losslessly
func RunPropertyAssignmentTestForAutoStorageBasePropertiesStatus(subject AutoStorageBaseProperties_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210101storage.AutoStorageBaseProperties_Status
	err := copied.AssignPropertiesToAutoStorageBasePropertiesStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AutoStorageBaseProperties_Status
	err = actual.AssignPropertiesFromAutoStorageBasePropertiesStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AutoStorageBaseProperties_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoStorageBaseProperties_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoStorageBasePropertiesStatus, AutoStorageBasePropertiesStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoStorageBasePropertiesStatus runs a test to see if a specific instance of AutoStorageBaseProperties_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoStorageBasePropertiesStatus(subject AutoStorageBaseProperties_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoStorageBaseProperties_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoStorageBaseProperties_Status instances for property testing - lazily instantiated by
//AutoStorageBasePropertiesStatusGenerator()
var autoStorageBasePropertiesStatusGenerator gopter.Gen

// AutoStorageBasePropertiesStatusGenerator returns a generator of AutoStorageBaseProperties_Status instances for property testing.
func AutoStorageBasePropertiesStatusGenerator() gopter.Gen {
	if autoStorageBasePropertiesStatusGenerator != nil {
		return autoStorageBasePropertiesStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoStorageBasePropertiesStatus(generators)
	autoStorageBasePropertiesStatusGenerator = gen.Struct(reflect.TypeOf(AutoStorageBaseProperties_Status{}), generators)

	return autoStorageBasePropertiesStatusGenerator
}

// AddIndependentPropertyGeneratorsForAutoStorageBasePropertiesStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoStorageBasePropertiesStatus(gens map[string]gopter.Gen) {
	gens["StorageAccountId"] = gen.AlphaString()
}

func Test_BatchAccountIdentity_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BatchAccountIdentity_Spec to BatchAccountIdentity_Spec via AssignPropertiesToBatchAccountIdentitySpec & AssignPropertiesFromBatchAccountIdentitySpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForBatchAccountIdentitySpec, BatchAccountIdentitySpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBatchAccountIdentitySpec tests if a specific instance of BatchAccountIdentity_Spec can be assigned to v1alpha1api20210101storage and back losslessly
func RunPropertyAssignmentTestForBatchAccountIdentitySpec(subject BatchAccountIdentity_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210101storage.BatchAccountIdentity_Spec
	err := copied.AssignPropertiesToBatchAccountIdentitySpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BatchAccountIdentity_Spec
	err = actual.AssignPropertiesFromBatchAccountIdentitySpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BatchAccountIdentity_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BatchAccountIdentity_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBatchAccountIdentitySpec, BatchAccountIdentitySpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBatchAccountIdentitySpec runs a test to see if a specific instance of BatchAccountIdentity_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForBatchAccountIdentitySpec(subject BatchAccountIdentity_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BatchAccountIdentity_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BatchAccountIdentity_Spec instances for property testing - lazily instantiated by
//BatchAccountIdentitySpecGenerator()
var batchAccountIdentitySpecGenerator gopter.Gen

// BatchAccountIdentitySpecGenerator returns a generator of BatchAccountIdentity_Spec instances for property testing.
func BatchAccountIdentitySpecGenerator() gopter.Gen {
	if batchAccountIdentitySpecGenerator != nil {
		return batchAccountIdentitySpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccountIdentitySpec(generators)
	batchAccountIdentitySpecGenerator = gen.Struct(reflect.TypeOf(BatchAccountIdentity_Spec{}), generators)

	return batchAccountIdentitySpecGenerator
}

// AddIndependentPropertyGeneratorsForBatchAccountIdentitySpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBatchAccountIdentitySpec(gens map[string]gopter.Gen) {
	gens["Type"] = gen.OneConstOf(BatchAccountIdentitySpecTypeNone, BatchAccountIdentitySpecTypeSystemAssigned, BatchAccountIdentitySpecTypeUserAssigned)
}

func Test_BatchAccountIdentity_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BatchAccountIdentity_Status to BatchAccountIdentity_Status via AssignPropertiesToBatchAccountIdentityStatus & AssignPropertiesFromBatchAccountIdentityStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForBatchAccountIdentityStatus, BatchAccountIdentityStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBatchAccountIdentityStatus tests if a specific instance of BatchAccountIdentity_Status can be assigned to v1alpha1api20210101storage and back losslessly
func RunPropertyAssignmentTestForBatchAccountIdentityStatus(subject BatchAccountIdentity_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210101storage.BatchAccountIdentity_Status
	err := copied.AssignPropertiesToBatchAccountIdentityStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BatchAccountIdentity_Status
	err = actual.AssignPropertiesFromBatchAccountIdentityStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BatchAccountIdentity_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BatchAccountIdentity_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBatchAccountIdentityStatus, BatchAccountIdentityStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBatchAccountIdentityStatus runs a test to see if a specific instance of BatchAccountIdentity_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForBatchAccountIdentityStatus(subject BatchAccountIdentity_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BatchAccountIdentity_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BatchAccountIdentity_Status instances for property testing - lazily instantiated by
//BatchAccountIdentityStatusGenerator()
var batchAccountIdentityStatusGenerator gopter.Gen

// BatchAccountIdentityStatusGenerator returns a generator of BatchAccountIdentity_Status instances for property testing.
// We first initialize batchAccountIdentityStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BatchAccountIdentityStatusGenerator() gopter.Gen {
	if batchAccountIdentityStatusGenerator != nil {
		return batchAccountIdentityStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccountIdentityStatus(generators)
	batchAccountIdentityStatusGenerator = gen.Struct(reflect.TypeOf(BatchAccountIdentity_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccountIdentityStatus(generators)
	AddRelatedPropertyGeneratorsForBatchAccountIdentityStatus(generators)
	batchAccountIdentityStatusGenerator = gen.Struct(reflect.TypeOf(BatchAccountIdentity_Status{}), generators)

	return batchAccountIdentityStatusGenerator
}

// AddIndependentPropertyGeneratorsForBatchAccountIdentityStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBatchAccountIdentityStatus(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.OneConstOf(BatchAccountIdentityStatusTypeNone, BatchAccountIdentityStatusTypeSystemAssigned, BatchAccountIdentityStatusTypeUserAssigned)
}

// AddRelatedPropertyGeneratorsForBatchAccountIdentityStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBatchAccountIdentityStatus(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), BatchAccountIdentityStatusUserAssignedIdentitiesGenerator())
}

func Test_EncryptionProperties_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EncryptionProperties_Spec to EncryptionProperties_Spec via AssignPropertiesToEncryptionPropertiesSpec & AssignPropertiesFromEncryptionPropertiesSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForEncryptionPropertiesSpec, EncryptionPropertiesSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEncryptionPropertiesSpec tests if a specific instance of EncryptionProperties_Spec can be assigned to v1alpha1api20210101storage and back losslessly
func RunPropertyAssignmentTestForEncryptionPropertiesSpec(subject EncryptionProperties_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210101storage.EncryptionProperties_Spec
	err := copied.AssignPropertiesToEncryptionPropertiesSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EncryptionProperties_Spec
	err = actual.AssignPropertiesFromEncryptionPropertiesSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EncryptionProperties_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionProperties_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionPropertiesSpec, EncryptionPropertiesSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionPropertiesSpec runs a test to see if a specific instance of EncryptionProperties_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionPropertiesSpec(subject EncryptionProperties_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionProperties_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionProperties_Spec instances for property testing - lazily instantiated by
//EncryptionPropertiesSpecGenerator()
var encryptionPropertiesSpecGenerator gopter.Gen

// EncryptionPropertiesSpecGenerator returns a generator of EncryptionProperties_Spec instances for property testing.
// We first initialize encryptionPropertiesSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EncryptionPropertiesSpecGenerator() gopter.Gen {
	if encryptionPropertiesSpecGenerator != nil {
		return encryptionPropertiesSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionPropertiesSpec(generators)
	encryptionPropertiesSpecGenerator = gen.Struct(reflect.TypeOf(EncryptionProperties_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionPropertiesSpec(generators)
	AddRelatedPropertyGeneratorsForEncryptionPropertiesSpec(generators)
	encryptionPropertiesSpecGenerator = gen.Struct(reflect.TypeOf(EncryptionProperties_Spec{}), generators)

	return encryptionPropertiesSpecGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionPropertiesSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionPropertiesSpec(gens map[string]gopter.Gen) {
	gens["KeySource"] = gen.PtrOf(gen.OneConstOf(EncryptionPropertiesSpecKeySourceMicrosoftBatch, EncryptionPropertiesSpecKeySourceMicrosoftKeyVault))
}

// AddRelatedPropertyGeneratorsForEncryptionPropertiesSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionPropertiesSpec(gens map[string]gopter.Gen) {
	gens["KeyVaultProperties"] = gen.PtrOf(KeyVaultPropertiesSpecGenerator())
}

func Test_EncryptionProperties_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EncryptionProperties_Status to EncryptionProperties_Status via AssignPropertiesToEncryptionPropertiesStatus & AssignPropertiesFromEncryptionPropertiesStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForEncryptionPropertiesStatus, EncryptionPropertiesStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEncryptionPropertiesStatus tests if a specific instance of EncryptionProperties_Status can be assigned to v1alpha1api20210101storage and back losslessly
func RunPropertyAssignmentTestForEncryptionPropertiesStatus(subject EncryptionProperties_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210101storage.EncryptionProperties_Status
	err := copied.AssignPropertiesToEncryptionPropertiesStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EncryptionProperties_Status
	err = actual.AssignPropertiesFromEncryptionPropertiesStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EncryptionProperties_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionProperties_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionPropertiesStatus, EncryptionPropertiesStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionPropertiesStatus runs a test to see if a specific instance of EncryptionProperties_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionPropertiesStatus(subject EncryptionProperties_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionProperties_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionProperties_Status instances for property testing - lazily instantiated by
//EncryptionPropertiesStatusGenerator()
var encryptionPropertiesStatusGenerator gopter.Gen

// EncryptionPropertiesStatusGenerator returns a generator of EncryptionProperties_Status instances for property testing.
// We first initialize encryptionPropertiesStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EncryptionPropertiesStatusGenerator() gopter.Gen {
	if encryptionPropertiesStatusGenerator != nil {
		return encryptionPropertiesStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionPropertiesStatus(generators)
	encryptionPropertiesStatusGenerator = gen.Struct(reflect.TypeOf(EncryptionProperties_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionPropertiesStatus(generators)
	AddRelatedPropertyGeneratorsForEncryptionPropertiesStatus(generators)
	encryptionPropertiesStatusGenerator = gen.Struct(reflect.TypeOf(EncryptionProperties_Status{}), generators)

	return encryptionPropertiesStatusGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionPropertiesStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionPropertiesStatus(gens map[string]gopter.Gen) {
	gens["KeySource"] = gen.PtrOf(gen.OneConstOf(EncryptionPropertiesStatusKeySourceMicrosoftBatch, EncryptionPropertiesStatusKeySourceMicrosoftKeyVault))
}

// AddRelatedPropertyGeneratorsForEncryptionPropertiesStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionPropertiesStatus(gens map[string]gopter.Gen) {
	gens["KeyVaultProperties"] = gen.PtrOf(KeyVaultPropertiesStatusGenerator())
}

func Test_KeyVaultReference_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KeyVaultReference_Spec to KeyVaultReference_Spec via AssignPropertiesToKeyVaultReferenceSpec & AssignPropertiesFromKeyVaultReferenceSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForKeyVaultReferenceSpec, KeyVaultReferenceSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKeyVaultReferenceSpec tests if a specific instance of KeyVaultReference_Spec can be assigned to v1alpha1api20210101storage and back losslessly
func RunPropertyAssignmentTestForKeyVaultReferenceSpec(subject KeyVaultReference_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210101storage.KeyVaultReference_Spec
	err := copied.AssignPropertiesToKeyVaultReferenceSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KeyVaultReference_Spec
	err = actual.AssignPropertiesFromKeyVaultReferenceSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KeyVaultReference_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultReference_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultReferenceSpec, KeyVaultReferenceSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultReferenceSpec runs a test to see if a specific instance of KeyVaultReference_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultReferenceSpec(subject KeyVaultReference_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultReference_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultReference_Spec instances for property testing - lazily instantiated by
//KeyVaultReferenceSpecGenerator()
var keyVaultReferenceSpecGenerator gopter.Gen

// KeyVaultReferenceSpecGenerator returns a generator of KeyVaultReference_Spec instances for property testing.
func KeyVaultReferenceSpecGenerator() gopter.Gen {
	if keyVaultReferenceSpecGenerator != nil {
		return keyVaultReferenceSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultReferenceSpec(generators)
	keyVaultReferenceSpecGenerator = gen.Struct(reflect.TypeOf(KeyVaultReference_Spec{}), generators)

	return keyVaultReferenceSpecGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultReferenceSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultReferenceSpec(gens map[string]gopter.Gen) {
	gens["Url"] = gen.AlphaString()
}

func Test_KeyVaultReference_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KeyVaultReference_Status to KeyVaultReference_Status via AssignPropertiesToKeyVaultReferenceStatus & AssignPropertiesFromKeyVaultReferenceStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForKeyVaultReferenceStatus, KeyVaultReferenceStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKeyVaultReferenceStatus tests if a specific instance of KeyVaultReference_Status can be assigned to v1alpha1api20210101storage and back losslessly
func RunPropertyAssignmentTestForKeyVaultReferenceStatus(subject KeyVaultReference_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210101storage.KeyVaultReference_Status
	err := copied.AssignPropertiesToKeyVaultReferenceStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KeyVaultReference_Status
	err = actual.AssignPropertiesFromKeyVaultReferenceStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KeyVaultReference_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultReference_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultReferenceStatus, KeyVaultReferenceStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultReferenceStatus runs a test to see if a specific instance of KeyVaultReference_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultReferenceStatus(subject KeyVaultReference_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultReference_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultReference_Status instances for property testing - lazily instantiated by
//KeyVaultReferenceStatusGenerator()
var keyVaultReferenceStatusGenerator gopter.Gen

// KeyVaultReferenceStatusGenerator returns a generator of KeyVaultReference_Status instances for property testing.
func KeyVaultReferenceStatusGenerator() gopter.Gen {
	if keyVaultReferenceStatusGenerator != nil {
		return keyVaultReferenceStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultReferenceStatus(generators)
	keyVaultReferenceStatusGenerator = gen.Struct(reflect.TypeOf(KeyVaultReference_Status{}), generators)

	return keyVaultReferenceStatusGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultReferenceStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultReferenceStatus(gens map[string]gopter.Gen) {
	gens["Id"] = gen.AlphaString()
	gens["Url"] = gen.AlphaString()
}

func Test_BatchAccountIdentity_Status_UserAssignedIdentities_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BatchAccountIdentity_Status_UserAssignedIdentities to BatchAccountIdentity_Status_UserAssignedIdentities via AssignPropertiesToBatchAccountIdentityStatusUserAssignedIdentities & AssignPropertiesFromBatchAccountIdentityStatusUserAssignedIdentities returns original",
		prop.ForAll(RunPropertyAssignmentTestForBatchAccountIdentityStatusUserAssignedIdentities, BatchAccountIdentityStatusUserAssignedIdentitiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBatchAccountIdentityStatusUserAssignedIdentities tests if a specific instance of BatchAccountIdentity_Status_UserAssignedIdentities can be assigned to v1alpha1api20210101storage and back losslessly
func RunPropertyAssignmentTestForBatchAccountIdentityStatusUserAssignedIdentities(subject BatchAccountIdentity_Status_UserAssignedIdentities) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210101storage.BatchAccountIdentity_Status_UserAssignedIdentities
	err := copied.AssignPropertiesToBatchAccountIdentityStatusUserAssignedIdentities(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BatchAccountIdentity_Status_UserAssignedIdentities
	err = actual.AssignPropertiesFromBatchAccountIdentityStatusUserAssignedIdentities(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BatchAccountIdentity_Status_UserAssignedIdentities_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BatchAccountIdentity_Status_UserAssignedIdentities via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBatchAccountIdentityStatusUserAssignedIdentities, BatchAccountIdentityStatusUserAssignedIdentitiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBatchAccountIdentityStatusUserAssignedIdentities runs a test to see if a specific instance of BatchAccountIdentity_Status_UserAssignedIdentities round trips to JSON and back losslessly
func RunJSONSerializationTestForBatchAccountIdentityStatusUserAssignedIdentities(subject BatchAccountIdentity_Status_UserAssignedIdentities) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BatchAccountIdentity_Status_UserAssignedIdentities
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BatchAccountIdentity_Status_UserAssignedIdentities instances for property testing - lazily instantiated
//by BatchAccountIdentityStatusUserAssignedIdentitiesGenerator()
var batchAccountIdentityStatusUserAssignedIdentitiesGenerator gopter.Gen

// BatchAccountIdentityStatusUserAssignedIdentitiesGenerator returns a generator of BatchAccountIdentity_Status_UserAssignedIdentities instances for property testing.
func BatchAccountIdentityStatusUserAssignedIdentitiesGenerator() gopter.Gen {
	if batchAccountIdentityStatusUserAssignedIdentitiesGenerator != nil {
		return batchAccountIdentityStatusUserAssignedIdentitiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBatchAccountIdentityStatusUserAssignedIdentities(generators)
	batchAccountIdentityStatusUserAssignedIdentitiesGenerator = gen.Struct(reflect.TypeOf(BatchAccountIdentity_Status_UserAssignedIdentities{}), generators)

	return batchAccountIdentityStatusUserAssignedIdentitiesGenerator
}

// AddIndependentPropertyGeneratorsForBatchAccountIdentityStatusUserAssignedIdentities is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBatchAccountIdentityStatusUserAssignedIdentities(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_KeyVaultProperties_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KeyVaultProperties_Spec to KeyVaultProperties_Spec via AssignPropertiesToKeyVaultPropertiesSpec & AssignPropertiesFromKeyVaultPropertiesSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForKeyVaultPropertiesSpec, KeyVaultPropertiesSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKeyVaultPropertiesSpec tests if a specific instance of KeyVaultProperties_Spec can be assigned to v1alpha1api20210101storage and back losslessly
func RunPropertyAssignmentTestForKeyVaultPropertiesSpec(subject KeyVaultProperties_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210101storage.KeyVaultProperties_Spec
	err := copied.AssignPropertiesToKeyVaultPropertiesSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KeyVaultProperties_Spec
	err = actual.AssignPropertiesFromKeyVaultPropertiesSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KeyVaultProperties_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultProperties_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultPropertiesSpec, KeyVaultPropertiesSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultPropertiesSpec runs a test to see if a specific instance of KeyVaultProperties_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultPropertiesSpec(subject KeyVaultProperties_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultProperties_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultProperties_Spec instances for property testing - lazily instantiated by
//KeyVaultPropertiesSpecGenerator()
var keyVaultPropertiesSpecGenerator gopter.Gen

// KeyVaultPropertiesSpecGenerator returns a generator of KeyVaultProperties_Spec instances for property testing.
func KeyVaultPropertiesSpecGenerator() gopter.Gen {
	if keyVaultPropertiesSpecGenerator != nil {
		return keyVaultPropertiesSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultPropertiesSpec(generators)
	keyVaultPropertiesSpecGenerator = gen.Struct(reflect.TypeOf(KeyVaultProperties_Spec{}), generators)

	return keyVaultPropertiesSpecGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultPropertiesSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultPropertiesSpec(gens map[string]gopter.Gen) {
	gens["KeyIdentifier"] = gen.PtrOf(gen.AlphaString())
}

func Test_KeyVaultProperties_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KeyVaultProperties_Status to KeyVaultProperties_Status via AssignPropertiesToKeyVaultPropertiesStatus & AssignPropertiesFromKeyVaultPropertiesStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForKeyVaultPropertiesStatus, KeyVaultPropertiesStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKeyVaultPropertiesStatus tests if a specific instance of KeyVaultProperties_Status can be assigned to v1alpha1api20210101storage and back losslessly
func RunPropertyAssignmentTestForKeyVaultPropertiesStatus(subject KeyVaultProperties_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210101storage.KeyVaultProperties_Status
	err := copied.AssignPropertiesToKeyVaultPropertiesStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KeyVaultProperties_Status
	err = actual.AssignPropertiesFromKeyVaultPropertiesStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KeyVaultProperties_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultProperties_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultPropertiesStatus, KeyVaultPropertiesStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultPropertiesStatus runs a test to see if a specific instance of KeyVaultProperties_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultPropertiesStatus(subject KeyVaultProperties_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultProperties_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultProperties_Status instances for property testing - lazily instantiated by
//KeyVaultPropertiesStatusGenerator()
var keyVaultPropertiesStatusGenerator gopter.Gen

// KeyVaultPropertiesStatusGenerator returns a generator of KeyVaultProperties_Status instances for property testing.
func KeyVaultPropertiesStatusGenerator() gopter.Gen {
	if keyVaultPropertiesStatusGenerator != nil {
		return keyVaultPropertiesStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultPropertiesStatus(generators)
	keyVaultPropertiesStatusGenerator = gen.Struct(reflect.TypeOf(KeyVaultProperties_Status{}), generators)

	return keyVaultPropertiesStatusGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultPropertiesStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultPropertiesStatus(gens map[string]gopter.Gen) {
	gens["KeyIdentifier"] = gen.PtrOf(gen.AlphaString())
}
