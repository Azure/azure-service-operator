// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20211101

import (
	"encoding/json"
	v1api20211101s "github.com/Azure/azure-service-operator/v2/api/sql/v1api20211101storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_Server_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	parameters.MinSuccessfulTests = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Server to hub returns original",
		prop.ForAll(RunResourceConversionTestForServer, ServerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForServer tests if a specific instance of Server round trips to the hub storage version and back losslessly
func RunResourceConversionTestForServer(subject Server) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v1api20211101s.Server
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual Server
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Server_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Server to Server via AssignProperties_To_Server & AssignProperties_From_Server returns original",
		prop.ForAll(RunPropertyAssignmentTestForServer, ServerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForServer tests if a specific instance of Server can be assigned to v1api20211101storage and back losslessly
func RunPropertyAssignmentTestForServer(subject Server) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20211101s.Server
	err := copied.AssignProperties_To_Server(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Server
	err = actual.AssignProperties_From_Server(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Server_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Server via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServer, ServerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServer runs a test to see if a specific instance of Server round trips to JSON and back losslessly
func RunJSONSerializationTestForServer(subject Server) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Server
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Server instances for property testing - lazily instantiated by ServerGenerator()
var serverGenerator gopter.Gen

// ServerGenerator returns a generator of Server instances for property testing.
func ServerGenerator() gopter.Gen {
	if serverGenerator != nil {
		return serverGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForServer(generators)
	serverGenerator = gen.Struct(reflect.TypeOf(Server{}), generators)

	return serverGenerator
}

// AddRelatedPropertyGeneratorsForServer is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForServer(gens map[string]gopter.Gen) {
	gens["Spec"] = Server_SpecGenerator()
	gens["Status"] = Server_STATUSGenerator()
}

func Test_Server_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Server_Spec to Server_Spec via AssignProperties_To_Server_Spec & AssignProperties_From_Server_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForServer_Spec, Server_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForServer_Spec tests if a specific instance of Server_Spec can be assigned to v1api20211101storage and back losslessly
func RunPropertyAssignmentTestForServer_Spec(subject Server_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20211101s.Server_Spec
	err := copied.AssignProperties_To_Server_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Server_Spec
	err = actual.AssignProperties_From_Server_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Server_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Server_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServer_Spec, Server_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServer_Spec runs a test to see if a specific instance of Server_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForServer_Spec(subject Server_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Server_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Server_Spec instances for property testing - lazily instantiated by Server_SpecGenerator()
var server_SpecGenerator gopter.Gen

// Server_SpecGenerator returns a generator of Server_Spec instances for property testing.
// We first initialize server_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Server_SpecGenerator() gopter.Gen {
	if server_SpecGenerator != nil {
		return server_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServer_Spec(generators)
	server_SpecGenerator = gen.Struct(reflect.TypeOf(Server_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServer_Spec(generators)
	AddRelatedPropertyGeneratorsForServer_Spec(generators)
	server_SpecGenerator = gen.Struct(reflect.TypeOf(Server_Spec{}), generators)

	return server_SpecGenerator
}

// AddIndependentPropertyGeneratorsForServer_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServer_Spec(gens map[string]gopter.Gen) {
	gens["AdministratorLogin"] = gen.PtrOf(gen.AlphaString())
	gens["AzureName"] = gen.AlphaString()
	gens["FederatedClientId"] = gen.PtrOf(gen.AlphaString())
	gens["KeyId"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["MinimalTlsVersion"] = gen.PtrOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(ServerProperties_PublicNetworkAccess_Disabled, ServerProperties_PublicNetworkAccess_Enabled))
	gens["RestrictOutboundNetworkAccess"] = gen.PtrOf(gen.OneConstOf(ServerProperties_RestrictOutboundNetworkAccess_Disabled, ServerProperties_RestrictOutboundNetworkAccess_Enabled))
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Version"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForServer_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForServer_Spec(gens map[string]gopter.Gen) {
	gens["Administrators"] = gen.PtrOf(ServerExternalAdministratorGenerator())
	gens["Identity"] = gen.PtrOf(ResourceIdentityGenerator())
	gens["OperatorSpec"] = gen.PtrOf(ServerOperatorSpecGenerator())
}

func Test_Server_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Server_STATUS to Server_STATUS via AssignProperties_To_Server_STATUS & AssignProperties_From_Server_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForServer_STATUS, Server_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForServer_STATUS tests if a specific instance of Server_STATUS can be assigned to v1api20211101storage and back losslessly
func RunPropertyAssignmentTestForServer_STATUS(subject Server_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20211101s.Server_STATUS
	err := copied.AssignProperties_To_Server_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Server_STATUS
	err = actual.AssignProperties_From_Server_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Server_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Server_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServer_STATUS, Server_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServer_STATUS runs a test to see if a specific instance of Server_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForServer_STATUS(subject Server_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Server_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Server_STATUS instances for property testing - lazily instantiated by Server_STATUSGenerator()
var server_STATUSGenerator gopter.Gen

// Server_STATUSGenerator returns a generator of Server_STATUS instances for property testing.
// We first initialize server_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Server_STATUSGenerator() gopter.Gen {
	if server_STATUSGenerator != nil {
		return server_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServer_STATUS(generators)
	server_STATUSGenerator = gen.Struct(reflect.TypeOf(Server_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServer_STATUS(generators)
	AddRelatedPropertyGeneratorsForServer_STATUS(generators)
	server_STATUSGenerator = gen.Struct(reflect.TypeOf(Server_STATUS{}), generators)

	return server_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForServer_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServer_STATUS(gens map[string]gopter.Gen) {
	gens["AdministratorLogin"] = gen.PtrOf(gen.AlphaString())
	gens["FederatedClientId"] = gen.PtrOf(gen.AlphaString())
	gens["FullyQualifiedDomainName"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["KeyId"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["MinimalTlsVersion"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["PrimaryUserAssignedIdentityId"] = gen.PtrOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(ServerProperties_PublicNetworkAccess_STATUS_Disabled, ServerProperties_PublicNetworkAccess_STATUS_Enabled))
	gens["RestrictOutboundNetworkAccess"] = gen.PtrOf(gen.OneConstOf(ServerProperties_RestrictOutboundNetworkAccess_STATUS_Disabled, ServerProperties_RestrictOutboundNetworkAccess_STATUS_Enabled))
	gens["State"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["Version"] = gen.PtrOf(gen.AlphaString())
	gens["WorkspaceFeature"] = gen.PtrOf(gen.OneConstOf(ServerProperties_WorkspaceFeature_STATUS_Connected, ServerProperties_WorkspaceFeature_STATUS_Disconnected))
}

// AddRelatedPropertyGeneratorsForServer_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForServer_STATUS(gens map[string]gopter.Gen) {
	gens["Administrators"] = gen.PtrOf(ServerExternalAdministrator_STATUSGenerator())
	gens["Identity"] = gen.PtrOf(ResourceIdentity_STATUSGenerator())
	gens["PrivateEndpointConnections"] = gen.SliceOf(ServerPrivateEndpointConnection_STATUSGenerator())
}

func Test_ResourceIdentity_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResourceIdentity to ResourceIdentity via AssignProperties_To_ResourceIdentity & AssignProperties_From_ResourceIdentity returns original",
		prop.ForAll(RunPropertyAssignmentTestForResourceIdentity, ResourceIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResourceIdentity tests if a specific instance of ResourceIdentity can be assigned to v1api20211101storage and back losslessly
func RunPropertyAssignmentTestForResourceIdentity(subject ResourceIdentity) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20211101s.ResourceIdentity
	err := copied.AssignProperties_To_ResourceIdentity(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResourceIdentity
	err = actual.AssignProperties_From_ResourceIdentity(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResourceIdentity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceIdentity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceIdentity, ResourceIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceIdentity runs a test to see if a specific instance of ResourceIdentity round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceIdentity(subject ResourceIdentity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceIdentity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceIdentity instances for property testing - lazily instantiated by ResourceIdentityGenerator()
var resourceIdentityGenerator gopter.Gen

// ResourceIdentityGenerator returns a generator of ResourceIdentity instances for property testing.
// We first initialize resourceIdentityGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ResourceIdentityGenerator() gopter.Gen {
	if resourceIdentityGenerator != nil {
		return resourceIdentityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceIdentity(generators)
	resourceIdentityGenerator = gen.Struct(reflect.TypeOf(ResourceIdentity{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceIdentity(generators)
	AddRelatedPropertyGeneratorsForResourceIdentity(generators)
	resourceIdentityGenerator = gen.Struct(reflect.TypeOf(ResourceIdentity{}), generators)

	return resourceIdentityGenerator
}

// AddIndependentPropertyGeneratorsForResourceIdentity is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceIdentity(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ResourceIdentity_Type_None,
		ResourceIdentity_Type_SystemAssigned,
		ResourceIdentity_Type_SystemAssignedUserAssigned,
		ResourceIdentity_Type_UserAssigned))
}

// AddRelatedPropertyGeneratorsForResourceIdentity is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResourceIdentity(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.SliceOf(UserAssignedIdentityDetailsGenerator())
}

func Test_ResourceIdentity_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResourceIdentity_STATUS to ResourceIdentity_STATUS via AssignProperties_To_ResourceIdentity_STATUS & AssignProperties_From_ResourceIdentity_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForResourceIdentity_STATUS, ResourceIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResourceIdentity_STATUS tests if a specific instance of ResourceIdentity_STATUS can be assigned to v1api20211101storage and back losslessly
func RunPropertyAssignmentTestForResourceIdentity_STATUS(subject ResourceIdentity_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20211101s.ResourceIdentity_STATUS
	err := copied.AssignProperties_To_ResourceIdentity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResourceIdentity_STATUS
	err = actual.AssignProperties_From_ResourceIdentity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResourceIdentity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceIdentity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceIdentity_STATUS, ResourceIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceIdentity_STATUS runs a test to see if a specific instance of ResourceIdentity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceIdentity_STATUS(subject ResourceIdentity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceIdentity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceIdentity_STATUS instances for property testing - lazily instantiated by
// ResourceIdentity_STATUSGenerator()
var resourceIdentity_STATUSGenerator gopter.Gen

// ResourceIdentity_STATUSGenerator returns a generator of ResourceIdentity_STATUS instances for property testing.
// We first initialize resourceIdentity_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ResourceIdentity_STATUSGenerator() gopter.Gen {
	if resourceIdentity_STATUSGenerator != nil {
		return resourceIdentity_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceIdentity_STATUS(generators)
	resourceIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(ResourceIdentity_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceIdentity_STATUS(generators)
	AddRelatedPropertyGeneratorsForResourceIdentity_STATUS(generators)
	resourceIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(ResourceIdentity_STATUS{}), generators)

	return resourceIdentity_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForResourceIdentity_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ResourceIdentity_Type_STATUS_None,
		ResourceIdentity_Type_STATUS_SystemAssigned,
		ResourceIdentity_Type_STATUS_SystemAssignedUserAssigned,
		ResourceIdentity_Type_STATUS_UserAssigned))
}

// AddRelatedPropertyGeneratorsForResourceIdentity_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResourceIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), UserIdentity_STATUSGenerator())
}

func Test_ServerExternalAdministrator_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ServerExternalAdministrator to ServerExternalAdministrator via AssignProperties_To_ServerExternalAdministrator & AssignProperties_From_ServerExternalAdministrator returns original",
		prop.ForAll(RunPropertyAssignmentTestForServerExternalAdministrator, ServerExternalAdministratorGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForServerExternalAdministrator tests if a specific instance of ServerExternalAdministrator can be assigned to v1api20211101storage and back losslessly
func RunPropertyAssignmentTestForServerExternalAdministrator(subject ServerExternalAdministrator) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20211101s.ServerExternalAdministrator
	err := copied.AssignProperties_To_ServerExternalAdministrator(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ServerExternalAdministrator
	err = actual.AssignProperties_From_ServerExternalAdministrator(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ServerExternalAdministrator_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServerExternalAdministrator via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServerExternalAdministrator, ServerExternalAdministratorGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServerExternalAdministrator runs a test to see if a specific instance of ServerExternalAdministrator round trips to JSON and back losslessly
func RunJSONSerializationTestForServerExternalAdministrator(subject ServerExternalAdministrator) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServerExternalAdministrator
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServerExternalAdministrator instances for property testing - lazily instantiated by
// ServerExternalAdministratorGenerator()
var serverExternalAdministratorGenerator gopter.Gen

// ServerExternalAdministratorGenerator returns a generator of ServerExternalAdministrator instances for property testing.
func ServerExternalAdministratorGenerator() gopter.Gen {
	if serverExternalAdministratorGenerator != nil {
		return serverExternalAdministratorGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServerExternalAdministrator(generators)
	serverExternalAdministratorGenerator = gen.Struct(reflect.TypeOf(ServerExternalAdministrator{}), generators)

	return serverExternalAdministratorGenerator
}

// AddIndependentPropertyGeneratorsForServerExternalAdministrator is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServerExternalAdministrator(gens map[string]gopter.Gen) {
	gens["AdministratorType"] = gen.PtrOf(gen.OneConstOf(ServerExternalAdministrator_AdministratorType_ActiveDirectory))
	gens["AzureADOnlyAuthentication"] = gen.PtrOf(gen.Bool())
	gens["Login"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalType"] = gen.PtrOf(gen.OneConstOf(ServerExternalAdministrator_PrincipalType_Application, ServerExternalAdministrator_PrincipalType_Group, ServerExternalAdministrator_PrincipalType_User))
	gens["Sid"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
}

func Test_ServerExternalAdministrator_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ServerExternalAdministrator_STATUS to ServerExternalAdministrator_STATUS via AssignProperties_To_ServerExternalAdministrator_STATUS & AssignProperties_From_ServerExternalAdministrator_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForServerExternalAdministrator_STATUS, ServerExternalAdministrator_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForServerExternalAdministrator_STATUS tests if a specific instance of ServerExternalAdministrator_STATUS can be assigned to v1api20211101storage and back losslessly
func RunPropertyAssignmentTestForServerExternalAdministrator_STATUS(subject ServerExternalAdministrator_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20211101s.ServerExternalAdministrator_STATUS
	err := copied.AssignProperties_To_ServerExternalAdministrator_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ServerExternalAdministrator_STATUS
	err = actual.AssignProperties_From_ServerExternalAdministrator_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ServerExternalAdministrator_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServerExternalAdministrator_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServerExternalAdministrator_STATUS, ServerExternalAdministrator_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServerExternalAdministrator_STATUS runs a test to see if a specific instance of ServerExternalAdministrator_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForServerExternalAdministrator_STATUS(subject ServerExternalAdministrator_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServerExternalAdministrator_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServerExternalAdministrator_STATUS instances for property testing - lazily instantiated by
// ServerExternalAdministrator_STATUSGenerator()
var serverExternalAdministrator_STATUSGenerator gopter.Gen

// ServerExternalAdministrator_STATUSGenerator returns a generator of ServerExternalAdministrator_STATUS instances for property testing.
func ServerExternalAdministrator_STATUSGenerator() gopter.Gen {
	if serverExternalAdministrator_STATUSGenerator != nil {
		return serverExternalAdministrator_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServerExternalAdministrator_STATUS(generators)
	serverExternalAdministrator_STATUSGenerator = gen.Struct(reflect.TypeOf(ServerExternalAdministrator_STATUS{}), generators)

	return serverExternalAdministrator_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForServerExternalAdministrator_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServerExternalAdministrator_STATUS(gens map[string]gopter.Gen) {
	gens["AdministratorType"] = gen.PtrOf(gen.OneConstOf(ServerExternalAdministrator_AdministratorType_STATUS_ActiveDirectory))
	gens["AzureADOnlyAuthentication"] = gen.PtrOf(gen.Bool())
	gens["Login"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalType"] = gen.PtrOf(gen.OneConstOf(ServerExternalAdministrator_PrincipalType_STATUS_Application, ServerExternalAdministrator_PrincipalType_STATUS_Group, ServerExternalAdministrator_PrincipalType_STATUS_User))
	gens["Sid"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
}

func Test_ServerOperatorSpec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ServerOperatorSpec to ServerOperatorSpec via AssignProperties_To_ServerOperatorSpec & AssignProperties_From_ServerOperatorSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForServerOperatorSpec, ServerOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForServerOperatorSpec tests if a specific instance of ServerOperatorSpec can be assigned to v1api20211101storage and back losslessly
func RunPropertyAssignmentTestForServerOperatorSpec(subject ServerOperatorSpec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20211101s.ServerOperatorSpec
	err := copied.AssignProperties_To_ServerOperatorSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ServerOperatorSpec
	err = actual.AssignProperties_From_ServerOperatorSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ServerOperatorSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServerOperatorSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServerOperatorSpec, ServerOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServerOperatorSpec runs a test to see if a specific instance of ServerOperatorSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForServerOperatorSpec(subject ServerOperatorSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServerOperatorSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServerOperatorSpec instances for property testing - lazily instantiated by ServerOperatorSpecGenerator()
var serverOperatorSpecGenerator gopter.Gen

// ServerOperatorSpecGenerator returns a generator of ServerOperatorSpec instances for property testing.
func ServerOperatorSpecGenerator() gopter.Gen {
	if serverOperatorSpecGenerator != nil {
		return serverOperatorSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForServerOperatorSpec(generators)
	serverOperatorSpecGenerator = gen.Struct(reflect.TypeOf(ServerOperatorSpec{}), generators)

	return serverOperatorSpecGenerator
}

// AddRelatedPropertyGeneratorsForServerOperatorSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForServerOperatorSpec(gens map[string]gopter.Gen) {
	gens["ConfigMaps"] = gen.PtrOf(ServerOperatorConfigMapsGenerator())
}

func Test_ServerPrivateEndpointConnection_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ServerPrivateEndpointConnection_STATUS to ServerPrivateEndpointConnection_STATUS via AssignProperties_To_ServerPrivateEndpointConnection_STATUS & AssignProperties_From_ServerPrivateEndpointConnection_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForServerPrivateEndpointConnection_STATUS, ServerPrivateEndpointConnection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForServerPrivateEndpointConnection_STATUS tests if a specific instance of ServerPrivateEndpointConnection_STATUS can be assigned to v1api20211101storage and back losslessly
func RunPropertyAssignmentTestForServerPrivateEndpointConnection_STATUS(subject ServerPrivateEndpointConnection_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20211101s.ServerPrivateEndpointConnection_STATUS
	err := copied.AssignProperties_To_ServerPrivateEndpointConnection_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ServerPrivateEndpointConnection_STATUS
	err = actual.AssignProperties_From_ServerPrivateEndpointConnection_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ServerPrivateEndpointConnection_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServerPrivateEndpointConnection_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServerPrivateEndpointConnection_STATUS, ServerPrivateEndpointConnection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServerPrivateEndpointConnection_STATUS runs a test to see if a specific instance of ServerPrivateEndpointConnection_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForServerPrivateEndpointConnection_STATUS(subject ServerPrivateEndpointConnection_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServerPrivateEndpointConnection_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServerPrivateEndpointConnection_STATUS instances for property testing - lazily instantiated by
// ServerPrivateEndpointConnection_STATUSGenerator()
var serverPrivateEndpointConnection_STATUSGenerator gopter.Gen

// ServerPrivateEndpointConnection_STATUSGenerator returns a generator of ServerPrivateEndpointConnection_STATUS instances for property testing.
// We first initialize serverPrivateEndpointConnection_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ServerPrivateEndpointConnection_STATUSGenerator() gopter.Gen {
	if serverPrivateEndpointConnection_STATUSGenerator != nil {
		return serverPrivateEndpointConnection_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServerPrivateEndpointConnection_STATUS(generators)
	serverPrivateEndpointConnection_STATUSGenerator = gen.Struct(reflect.TypeOf(ServerPrivateEndpointConnection_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServerPrivateEndpointConnection_STATUS(generators)
	AddRelatedPropertyGeneratorsForServerPrivateEndpointConnection_STATUS(generators)
	serverPrivateEndpointConnection_STATUSGenerator = gen.Struct(reflect.TypeOf(ServerPrivateEndpointConnection_STATUS{}), generators)

	return serverPrivateEndpointConnection_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForServerPrivateEndpointConnection_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServerPrivateEndpointConnection_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForServerPrivateEndpointConnection_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForServerPrivateEndpointConnection_STATUS(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(PrivateEndpointConnectionProperties_STATUSGenerator())
}

func Test_PrivateEndpointConnectionProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PrivateEndpointConnectionProperties_STATUS to PrivateEndpointConnectionProperties_STATUS via AssignProperties_To_PrivateEndpointConnectionProperties_STATUS & AssignProperties_From_PrivateEndpointConnectionProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForPrivateEndpointConnectionProperties_STATUS, PrivateEndpointConnectionProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPrivateEndpointConnectionProperties_STATUS tests if a specific instance of PrivateEndpointConnectionProperties_STATUS can be assigned to v1api20211101storage and back losslessly
func RunPropertyAssignmentTestForPrivateEndpointConnectionProperties_STATUS(subject PrivateEndpointConnectionProperties_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20211101s.PrivateEndpointConnectionProperties_STATUS
	err := copied.AssignProperties_To_PrivateEndpointConnectionProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PrivateEndpointConnectionProperties_STATUS
	err = actual.AssignProperties_From_PrivateEndpointConnectionProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PrivateEndpointConnectionProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointConnectionProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointConnectionProperties_STATUS, PrivateEndpointConnectionProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointConnectionProperties_STATUS runs a test to see if a specific instance of PrivateEndpointConnectionProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointConnectionProperties_STATUS(subject PrivateEndpointConnectionProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointConnectionProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointConnectionProperties_STATUS instances for property testing - lazily instantiated by
// PrivateEndpointConnectionProperties_STATUSGenerator()
var privateEndpointConnectionProperties_STATUSGenerator gopter.Gen

// PrivateEndpointConnectionProperties_STATUSGenerator returns a generator of PrivateEndpointConnectionProperties_STATUS instances for property testing.
// We first initialize privateEndpointConnectionProperties_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PrivateEndpointConnectionProperties_STATUSGenerator() gopter.Gen {
	if privateEndpointConnectionProperties_STATUSGenerator != nil {
		return privateEndpointConnectionProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnectionProperties_STATUS(generators)
	privateEndpointConnectionProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnectionProperties_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnectionProperties_STATUS(generators)
	AddRelatedPropertyGeneratorsForPrivateEndpointConnectionProperties_STATUS(generators)
	privateEndpointConnectionProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnectionProperties_STATUS{}), generators)

	return privateEndpointConnectionProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointConnectionProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointConnectionProperties_STATUS(gens map[string]gopter.Gen) {
	gens["GroupIds"] = gen.SliceOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		PrivateEndpointConnectionProperties_ProvisioningState_STATUS_Approving,
		PrivateEndpointConnectionProperties_ProvisioningState_STATUS_Dropping,
		PrivateEndpointConnectionProperties_ProvisioningState_STATUS_Failed,
		PrivateEndpointConnectionProperties_ProvisioningState_STATUS_Ready,
		PrivateEndpointConnectionProperties_ProvisioningState_STATUS_Rejecting))
}

// AddRelatedPropertyGeneratorsForPrivateEndpointConnectionProperties_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPrivateEndpointConnectionProperties_STATUS(gens map[string]gopter.Gen) {
	gens["PrivateEndpoint"] = gen.PtrOf(PrivateEndpointProperty_STATUSGenerator())
	gens["PrivateLinkServiceConnectionState"] = gen.PtrOf(PrivateLinkServiceConnectionStateProperty_STATUSGenerator())
}

func Test_ServerOperatorConfigMaps_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ServerOperatorConfigMaps to ServerOperatorConfigMaps via AssignProperties_To_ServerOperatorConfigMaps & AssignProperties_From_ServerOperatorConfigMaps returns original",
		prop.ForAll(RunPropertyAssignmentTestForServerOperatorConfigMaps, ServerOperatorConfigMapsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForServerOperatorConfigMaps tests if a specific instance of ServerOperatorConfigMaps can be assigned to v1api20211101storage and back losslessly
func RunPropertyAssignmentTestForServerOperatorConfigMaps(subject ServerOperatorConfigMaps) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20211101s.ServerOperatorConfigMaps
	err := copied.AssignProperties_To_ServerOperatorConfigMaps(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ServerOperatorConfigMaps
	err = actual.AssignProperties_From_ServerOperatorConfigMaps(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ServerOperatorConfigMaps_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServerOperatorConfigMaps via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServerOperatorConfigMaps, ServerOperatorConfigMapsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServerOperatorConfigMaps runs a test to see if a specific instance of ServerOperatorConfigMaps round trips to JSON and back losslessly
func RunJSONSerializationTestForServerOperatorConfigMaps(subject ServerOperatorConfigMaps) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServerOperatorConfigMaps
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServerOperatorConfigMaps instances for property testing - lazily instantiated by
// ServerOperatorConfigMapsGenerator()
var serverOperatorConfigMapsGenerator gopter.Gen

// ServerOperatorConfigMapsGenerator returns a generator of ServerOperatorConfigMaps instances for property testing.
func ServerOperatorConfigMapsGenerator() gopter.Gen {
	if serverOperatorConfigMapsGenerator != nil {
		return serverOperatorConfigMapsGenerator
	}

	generators := make(map[string]gopter.Gen)
	serverOperatorConfigMapsGenerator = gen.Struct(reflect.TypeOf(ServerOperatorConfigMaps{}), generators)

	return serverOperatorConfigMapsGenerator
}

func Test_UserAssignedIdentityDetails_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UserAssignedIdentityDetails to UserAssignedIdentityDetails via AssignProperties_To_UserAssignedIdentityDetails & AssignProperties_From_UserAssignedIdentityDetails returns original",
		prop.ForAll(RunPropertyAssignmentTestForUserAssignedIdentityDetails, UserAssignedIdentityDetailsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUserAssignedIdentityDetails tests if a specific instance of UserAssignedIdentityDetails can be assigned to v1api20211101storage and back losslessly
func RunPropertyAssignmentTestForUserAssignedIdentityDetails(subject UserAssignedIdentityDetails) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20211101s.UserAssignedIdentityDetails
	err := copied.AssignProperties_To_UserAssignedIdentityDetails(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UserAssignedIdentityDetails
	err = actual.AssignProperties_From_UserAssignedIdentityDetails(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UserAssignedIdentityDetails_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentityDetails via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentityDetails, UserAssignedIdentityDetailsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentityDetails runs a test to see if a specific instance of UserAssignedIdentityDetails round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentityDetails(subject UserAssignedIdentityDetails) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentityDetails
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentityDetails instances for property testing - lazily instantiated by
// UserAssignedIdentityDetailsGenerator()
var userAssignedIdentityDetailsGenerator gopter.Gen

// UserAssignedIdentityDetailsGenerator returns a generator of UserAssignedIdentityDetails instances for property testing.
func UserAssignedIdentityDetailsGenerator() gopter.Gen {
	if userAssignedIdentityDetailsGenerator != nil {
		return userAssignedIdentityDetailsGenerator
	}

	generators := make(map[string]gopter.Gen)
	userAssignedIdentityDetailsGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentityDetails{}), generators)

	return userAssignedIdentityDetailsGenerator
}

func Test_UserIdentity_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UserIdentity_STATUS to UserIdentity_STATUS via AssignProperties_To_UserIdentity_STATUS & AssignProperties_From_UserIdentity_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForUserIdentity_STATUS, UserIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUserIdentity_STATUS tests if a specific instance of UserIdentity_STATUS can be assigned to v1api20211101storage and back losslessly
func RunPropertyAssignmentTestForUserIdentity_STATUS(subject UserIdentity_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20211101s.UserIdentity_STATUS
	err := copied.AssignProperties_To_UserIdentity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UserIdentity_STATUS
	err = actual.AssignProperties_From_UserIdentity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UserIdentity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserIdentity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserIdentity_STATUS, UserIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserIdentity_STATUS runs a test to see if a specific instance of UserIdentity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUserIdentity_STATUS(subject UserIdentity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserIdentity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserIdentity_STATUS instances for property testing - lazily instantiated by
// UserIdentity_STATUSGenerator()
var userIdentity_STATUSGenerator gopter.Gen

// UserIdentity_STATUSGenerator returns a generator of UserIdentity_STATUS instances for property testing.
func UserIdentity_STATUSGenerator() gopter.Gen {
	if userIdentity_STATUSGenerator != nil {
		return userIdentity_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserIdentity_STATUS(generators)
	userIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(UserIdentity_STATUS{}), generators)

	return userIdentity_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForUserIdentity_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_PrivateEndpointProperty_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PrivateEndpointProperty_STATUS to PrivateEndpointProperty_STATUS via AssignProperties_To_PrivateEndpointProperty_STATUS & AssignProperties_From_PrivateEndpointProperty_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForPrivateEndpointProperty_STATUS, PrivateEndpointProperty_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPrivateEndpointProperty_STATUS tests if a specific instance of PrivateEndpointProperty_STATUS can be assigned to v1api20211101storage and back losslessly
func RunPropertyAssignmentTestForPrivateEndpointProperty_STATUS(subject PrivateEndpointProperty_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20211101s.PrivateEndpointProperty_STATUS
	err := copied.AssignProperties_To_PrivateEndpointProperty_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PrivateEndpointProperty_STATUS
	err = actual.AssignProperties_From_PrivateEndpointProperty_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PrivateEndpointProperty_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointProperty_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointProperty_STATUS, PrivateEndpointProperty_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointProperty_STATUS runs a test to see if a specific instance of PrivateEndpointProperty_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointProperty_STATUS(subject PrivateEndpointProperty_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointProperty_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointProperty_STATUS instances for property testing - lazily instantiated by
// PrivateEndpointProperty_STATUSGenerator()
var privateEndpointProperty_STATUSGenerator gopter.Gen

// PrivateEndpointProperty_STATUSGenerator returns a generator of PrivateEndpointProperty_STATUS instances for property testing.
func PrivateEndpointProperty_STATUSGenerator() gopter.Gen {
	if privateEndpointProperty_STATUSGenerator != nil {
		return privateEndpointProperty_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointProperty_STATUS(generators)
	privateEndpointProperty_STATUSGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointProperty_STATUS{}), generators)

	return privateEndpointProperty_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointProperty_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointProperty_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_PrivateLinkServiceConnectionStateProperty_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PrivateLinkServiceConnectionStateProperty_STATUS to PrivateLinkServiceConnectionStateProperty_STATUS via AssignProperties_To_PrivateLinkServiceConnectionStateProperty_STATUS & AssignProperties_From_PrivateLinkServiceConnectionStateProperty_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForPrivateLinkServiceConnectionStateProperty_STATUS, PrivateLinkServiceConnectionStateProperty_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPrivateLinkServiceConnectionStateProperty_STATUS tests if a specific instance of PrivateLinkServiceConnectionStateProperty_STATUS can be assigned to v1api20211101storage and back losslessly
func RunPropertyAssignmentTestForPrivateLinkServiceConnectionStateProperty_STATUS(subject PrivateLinkServiceConnectionStateProperty_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1api20211101s.PrivateLinkServiceConnectionStateProperty_STATUS
	err := copied.AssignProperties_To_PrivateLinkServiceConnectionStateProperty_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PrivateLinkServiceConnectionStateProperty_STATUS
	err = actual.AssignProperties_From_PrivateLinkServiceConnectionStateProperty_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PrivateLinkServiceConnectionStateProperty_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateLinkServiceConnectionStateProperty_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateLinkServiceConnectionStateProperty_STATUS, PrivateLinkServiceConnectionStateProperty_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateLinkServiceConnectionStateProperty_STATUS runs a test to see if a specific instance of PrivateLinkServiceConnectionStateProperty_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateLinkServiceConnectionStateProperty_STATUS(subject PrivateLinkServiceConnectionStateProperty_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateLinkServiceConnectionStateProperty_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateLinkServiceConnectionStateProperty_STATUS instances for property testing - lazily instantiated by
// PrivateLinkServiceConnectionStateProperty_STATUSGenerator()
var privateLinkServiceConnectionStateProperty_STATUSGenerator gopter.Gen

// PrivateLinkServiceConnectionStateProperty_STATUSGenerator returns a generator of PrivateLinkServiceConnectionStateProperty_STATUS instances for property testing.
func PrivateLinkServiceConnectionStateProperty_STATUSGenerator() gopter.Gen {
	if privateLinkServiceConnectionStateProperty_STATUSGenerator != nil {
		return privateLinkServiceConnectionStateProperty_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkServiceConnectionStateProperty_STATUS(generators)
	privateLinkServiceConnectionStateProperty_STATUSGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServiceConnectionStateProperty_STATUS{}), generators)

	return privateLinkServiceConnectionStateProperty_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForPrivateLinkServiceConnectionStateProperty_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateLinkServiceConnectionStateProperty_STATUS(gens map[string]gopter.Gen) {
	gens["ActionsRequired"] = gen.PtrOf(gen.OneConstOf(PrivateLinkServiceConnectionStateProperty_ActionsRequired_STATUS_None))
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(
		PrivateLinkServiceConnectionStateProperty_Status_STATUS_Approved,
		PrivateLinkServiceConnectionStateProperty_Status_STATUS_Disconnected,
		PrivateLinkServiceConnectionStateProperty_Status_STATUS_Pending,
		PrivateLinkServiceConnectionStateProperty_Status_STATUS_Rejected))
}
