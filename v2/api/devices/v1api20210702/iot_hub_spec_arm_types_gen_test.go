// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20210702

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_ArmIdentity_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ArmIdentity_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForArmIdentity_ARM, ArmIdentity_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForArmIdentity_ARM runs a test to see if a specific instance of ArmIdentity_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForArmIdentity_ARM(subject ArmIdentity_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ArmIdentity_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ArmIdentity_ARM instances for property testing - lazily instantiated by ArmIdentity_ARMGenerator()
var armIdentity_ARMGenerator gopter.Gen

// ArmIdentity_ARMGenerator returns a generator of ArmIdentity_ARM instances for property testing.
// We first initialize armIdentity_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ArmIdentity_ARMGenerator() gopter.Gen {
	if armIdentity_ARMGenerator != nil {
		return armIdentity_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForArmIdentity_ARM(generators)
	armIdentity_ARMGenerator = gen.Struct(reflect.TypeOf(ArmIdentity_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForArmIdentity_ARM(generators)
	AddRelatedPropertyGeneratorsForArmIdentity_ARM(generators)
	armIdentity_ARMGenerator = gen.Struct(reflect.TypeOf(ArmIdentity_ARM{}), generators)

	return armIdentity_ARMGenerator
}

// AddIndependentPropertyGeneratorsForArmIdentity_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForArmIdentity_ARM(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ArmIdentity_Type_ARM_None,
		ArmIdentity_Type_ARM_SystemAssigned,
		ArmIdentity_Type_ARM_SystemAssignedUserAssigned,
		ArmIdentity_Type_ARM_UserAssigned))
}

// AddRelatedPropertyGeneratorsForArmIdentity_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForArmIdentity_ARM(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(
		gen.AlphaString(),
		UserAssignedIdentityDetails_ARMGenerator())
}

func Test_CloudToDeviceProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CloudToDeviceProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCloudToDeviceProperties_ARM, CloudToDeviceProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCloudToDeviceProperties_ARM runs a test to see if a specific instance of CloudToDeviceProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCloudToDeviceProperties_ARM(subject CloudToDeviceProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CloudToDeviceProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CloudToDeviceProperties_ARM instances for property testing - lazily instantiated by
// CloudToDeviceProperties_ARMGenerator()
var cloudToDeviceProperties_ARMGenerator gopter.Gen

// CloudToDeviceProperties_ARMGenerator returns a generator of CloudToDeviceProperties_ARM instances for property testing.
// We first initialize cloudToDeviceProperties_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CloudToDeviceProperties_ARMGenerator() gopter.Gen {
	if cloudToDeviceProperties_ARMGenerator != nil {
		return cloudToDeviceProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCloudToDeviceProperties_ARM(generators)
	cloudToDeviceProperties_ARMGenerator = gen.Struct(reflect.TypeOf(CloudToDeviceProperties_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCloudToDeviceProperties_ARM(generators)
	AddRelatedPropertyGeneratorsForCloudToDeviceProperties_ARM(generators)
	cloudToDeviceProperties_ARMGenerator = gen.Struct(reflect.TypeOf(CloudToDeviceProperties_ARM{}), generators)

	return cloudToDeviceProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForCloudToDeviceProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCloudToDeviceProperties_ARM(gens map[string]gopter.Gen) {
	gens["DefaultTtlAsIso8601"] = gen.PtrOf(gen.AlphaString())
	gens["MaxDeliveryCount"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForCloudToDeviceProperties_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCloudToDeviceProperties_ARM(gens map[string]gopter.Gen) {
	gens["Feedback"] = gen.PtrOf(FeedbackProperties_ARMGenerator())
}

func Test_EnrichmentProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EnrichmentProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEnrichmentProperties_ARM, EnrichmentProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEnrichmentProperties_ARM runs a test to see if a specific instance of EnrichmentProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEnrichmentProperties_ARM(subject EnrichmentProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EnrichmentProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EnrichmentProperties_ARM instances for property testing - lazily instantiated by
// EnrichmentProperties_ARMGenerator()
var enrichmentProperties_ARMGenerator gopter.Gen

// EnrichmentProperties_ARMGenerator returns a generator of EnrichmentProperties_ARM instances for property testing.
func EnrichmentProperties_ARMGenerator() gopter.Gen {
	if enrichmentProperties_ARMGenerator != nil {
		return enrichmentProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEnrichmentProperties_ARM(generators)
	enrichmentProperties_ARMGenerator = gen.Struct(reflect.TypeOf(EnrichmentProperties_ARM{}), generators)

	return enrichmentProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForEnrichmentProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEnrichmentProperties_ARM(gens map[string]gopter.Gen) {
	gens["EndpointNames"] = gen.SliceOf(gen.AlphaString())
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_EventHubProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventHubProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventHubProperties_ARM, EventHubProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventHubProperties_ARM runs a test to see if a specific instance of EventHubProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEventHubProperties_ARM(subject EventHubProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventHubProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventHubProperties_ARM instances for property testing - lazily instantiated by
// EventHubProperties_ARMGenerator()
var eventHubProperties_ARMGenerator gopter.Gen

// EventHubProperties_ARMGenerator returns a generator of EventHubProperties_ARM instances for property testing.
func EventHubProperties_ARMGenerator() gopter.Gen {
	if eventHubProperties_ARMGenerator != nil {
		return eventHubProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventHubProperties_ARM(generators)
	eventHubProperties_ARMGenerator = gen.Struct(reflect.TypeOf(EventHubProperties_ARM{}), generators)

	return eventHubProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForEventHubProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventHubProperties_ARM(gens map[string]gopter.Gen) {
	gens["PartitionCount"] = gen.PtrOf(gen.Int())
	gens["RetentionTimeInDays"] = gen.PtrOf(gen.Int())
}

func Test_FallbackRouteProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FallbackRouteProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFallbackRouteProperties_ARM, FallbackRouteProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFallbackRouteProperties_ARM runs a test to see if a specific instance of FallbackRouteProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForFallbackRouteProperties_ARM(subject FallbackRouteProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FallbackRouteProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FallbackRouteProperties_ARM instances for property testing - lazily instantiated by
// FallbackRouteProperties_ARMGenerator()
var fallbackRouteProperties_ARMGenerator gopter.Gen

// FallbackRouteProperties_ARMGenerator returns a generator of FallbackRouteProperties_ARM instances for property testing.
func FallbackRouteProperties_ARMGenerator() gopter.Gen {
	if fallbackRouteProperties_ARMGenerator != nil {
		return fallbackRouteProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFallbackRouteProperties_ARM(generators)
	fallbackRouteProperties_ARMGenerator = gen.Struct(reflect.TypeOf(FallbackRouteProperties_ARM{}), generators)

	return fallbackRouteProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForFallbackRouteProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFallbackRouteProperties_ARM(gens map[string]gopter.Gen) {
	gens["Condition"] = gen.PtrOf(gen.AlphaString())
	gens["EndpointNames"] = gen.SliceOf(gen.AlphaString())
	gens["IsEnabled"] = gen.PtrOf(gen.Bool())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Source"] = gen.PtrOf(gen.OneConstOf(FallbackRouteProperties_Source_ARM_DeviceMessages))
}

func Test_FeedbackProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FeedbackProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFeedbackProperties_ARM, FeedbackProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFeedbackProperties_ARM runs a test to see if a specific instance of FeedbackProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForFeedbackProperties_ARM(subject FeedbackProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FeedbackProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FeedbackProperties_ARM instances for property testing - lazily instantiated by
// FeedbackProperties_ARMGenerator()
var feedbackProperties_ARMGenerator gopter.Gen

// FeedbackProperties_ARMGenerator returns a generator of FeedbackProperties_ARM instances for property testing.
func FeedbackProperties_ARMGenerator() gopter.Gen {
	if feedbackProperties_ARMGenerator != nil {
		return feedbackProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFeedbackProperties_ARM(generators)
	feedbackProperties_ARMGenerator = gen.Struct(reflect.TypeOf(FeedbackProperties_ARM{}), generators)

	return feedbackProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForFeedbackProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFeedbackProperties_ARM(gens map[string]gopter.Gen) {
	gens["LockDurationAsIso8601"] = gen.PtrOf(gen.AlphaString())
	gens["MaxDeliveryCount"] = gen.PtrOf(gen.Int())
	gens["TtlAsIso8601"] = gen.PtrOf(gen.AlphaString())
}

func Test_IotHubProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IotHubProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIotHubProperties_ARM, IotHubProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIotHubProperties_ARM runs a test to see if a specific instance of IotHubProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIotHubProperties_ARM(subject IotHubProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IotHubProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IotHubProperties_ARM instances for property testing - lazily instantiated by
// IotHubProperties_ARMGenerator()
var iotHubProperties_ARMGenerator gopter.Gen

// IotHubProperties_ARMGenerator returns a generator of IotHubProperties_ARM instances for property testing.
// We first initialize iotHubProperties_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IotHubProperties_ARMGenerator() gopter.Gen {
	if iotHubProperties_ARMGenerator != nil {
		return iotHubProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIotHubProperties_ARM(generators)
	iotHubProperties_ARMGenerator = gen.Struct(reflect.TypeOf(IotHubProperties_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIotHubProperties_ARM(generators)
	AddRelatedPropertyGeneratorsForIotHubProperties_ARM(generators)
	iotHubProperties_ARMGenerator = gen.Struct(reflect.TypeOf(IotHubProperties_ARM{}), generators)

	return iotHubProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForIotHubProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIotHubProperties_ARM(gens map[string]gopter.Gen) {
	gens["AllowedFqdnList"] = gen.SliceOf(gen.AlphaString())
	gens["Comments"] = gen.PtrOf(gen.AlphaString())
	gens["DisableDeviceSAS"] = gen.PtrOf(gen.Bool())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["DisableModuleSAS"] = gen.PtrOf(gen.Bool())
	gens["EnableDataResidency"] = gen.PtrOf(gen.Bool())
	gens["EnableFileUploadNotifications"] = gen.PtrOf(gen.Bool())
	gens["Features"] = gen.PtrOf(gen.OneConstOf(IotHubProperties_Features_ARM_DeviceManagement, IotHubProperties_Features_ARM_None))
	gens["MinTlsVersion"] = gen.PtrOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(IotHubProperties_PublicNetworkAccess_ARM_Disabled, IotHubProperties_PublicNetworkAccess_ARM_Enabled))
	gens["RestrictOutboundNetworkAccess"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForIotHubProperties_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIotHubProperties_ARM(gens map[string]gopter.Gen) {
	gens["AuthorizationPolicies"] = gen.SliceOf(SharedAccessSignatureAuthorizationRule_ARMGenerator())
	gens["CloudToDevice"] = gen.PtrOf(CloudToDeviceProperties_ARMGenerator())
	gens["EventHubEndpoints"] = gen.MapOf(
		gen.AlphaString(),
		EventHubProperties_ARMGenerator())
	gens["IpFilterRules"] = gen.SliceOf(IpFilterRule_ARMGenerator())
	gens["MessagingEndpoints"] = gen.MapOf(
		gen.AlphaString(),
		MessagingEndpointProperties_ARMGenerator())
	gens["NetworkRuleSets"] = gen.PtrOf(NetworkRuleSetProperties_ARMGenerator())
	gens["Routing"] = gen.PtrOf(RoutingProperties_ARMGenerator())
	gens["StorageEndpoints"] = gen.MapOf(
		gen.AlphaString(),
		StorageEndpointProperties_ARMGenerator())
}

func Test_IotHubSkuInfo_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IotHubSkuInfo_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIotHubSkuInfo_ARM, IotHubSkuInfo_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIotHubSkuInfo_ARM runs a test to see if a specific instance of IotHubSkuInfo_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIotHubSkuInfo_ARM(subject IotHubSkuInfo_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IotHubSkuInfo_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IotHubSkuInfo_ARM instances for property testing - lazily instantiated by IotHubSkuInfo_ARMGenerator()
var iotHubSkuInfo_ARMGenerator gopter.Gen

// IotHubSkuInfo_ARMGenerator returns a generator of IotHubSkuInfo_ARM instances for property testing.
func IotHubSkuInfo_ARMGenerator() gopter.Gen {
	if iotHubSkuInfo_ARMGenerator != nil {
		return iotHubSkuInfo_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIotHubSkuInfo_ARM(generators)
	iotHubSkuInfo_ARMGenerator = gen.Struct(reflect.TypeOf(IotHubSkuInfo_ARM{}), generators)

	return iotHubSkuInfo_ARMGenerator
}

// AddIndependentPropertyGeneratorsForIotHubSkuInfo_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIotHubSkuInfo_ARM(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.OneConstOf(
		IotHubSkuInfo_Name_ARM_B1,
		IotHubSkuInfo_Name_ARM_B2,
		IotHubSkuInfo_Name_ARM_B3,
		IotHubSkuInfo_Name_ARM_F1,
		IotHubSkuInfo_Name_ARM_S1,
		IotHubSkuInfo_Name_ARM_S2,
		IotHubSkuInfo_Name_ARM_S3))
}

func Test_IotHub_Spec_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IotHub_Spec_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIotHub_Spec_ARM, IotHub_Spec_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIotHub_Spec_ARM runs a test to see if a specific instance of IotHub_Spec_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIotHub_Spec_ARM(subject IotHub_Spec_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IotHub_Spec_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IotHub_Spec_ARM instances for property testing - lazily instantiated by IotHub_Spec_ARMGenerator()
var iotHub_Spec_ARMGenerator gopter.Gen

// IotHub_Spec_ARMGenerator returns a generator of IotHub_Spec_ARM instances for property testing.
// We first initialize iotHub_Spec_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IotHub_Spec_ARMGenerator() gopter.Gen {
	if iotHub_Spec_ARMGenerator != nil {
		return iotHub_Spec_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIotHub_Spec_ARM(generators)
	iotHub_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(IotHub_Spec_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIotHub_Spec_ARM(generators)
	AddRelatedPropertyGeneratorsForIotHub_Spec_ARM(generators)
	iotHub_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(IotHub_Spec_ARM{}), generators)

	return iotHub_Spec_ARMGenerator
}

// AddIndependentPropertyGeneratorsForIotHub_Spec_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIotHub_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForIotHub_Spec_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIotHub_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ArmIdentity_ARMGenerator())
	gens["Properties"] = gen.PtrOf(IotHubProperties_ARMGenerator())
	gens["Sku"] = gen.PtrOf(IotHubSkuInfo_ARMGenerator())
}

func Test_IpFilterRule_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpFilterRule_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpFilterRule_ARM, IpFilterRule_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpFilterRule_ARM runs a test to see if a specific instance of IpFilterRule_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIpFilterRule_ARM(subject IpFilterRule_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpFilterRule_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpFilterRule_ARM instances for property testing - lazily instantiated by IpFilterRule_ARMGenerator()
var ipFilterRule_ARMGenerator gopter.Gen

// IpFilterRule_ARMGenerator returns a generator of IpFilterRule_ARM instances for property testing.
func IpFilterRule_ARMGenerator() gopter.Gen {
	if ipFilterRule_ARMGenerator != nil {
		return ipFilterRule_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpFilterRule_ARM(generators)
	ipFilterRule_ARMGenerator = gen.Struct(reflect.TypeOf(IpFilterRule_ARM{}), generators)

	return ipFilterRule_ARMGenerator
}

// AddIndependentPropertyGeneratorsForIpFilterRule_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpFilterRule_ARM(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(IpFilterRule_Action_ARM_Accept, IpFilterRule_Action_ARM_Reject))
	gens["FilterName"] = gen.PtrOf(gen.AlphaString())
	gens["IpMask"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedIdentity_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedIdentity_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedIdentity_ARM, ManagedIdentity_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedIdentity_ARM runs a test to see if a specific instance of ManagedIdentity_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedIdentity_ARM(subject ManagedIdentity_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedIdentity_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedIdentity_ARM instances for property testing - lazily instantiated by
// ManagedIdentity_ARMGenerator()
var managedIdentity_ARMGenerator gopter.Gen

// ManagedIdentity_ARMGenerator returns a generator of ManagedIdentity_ARM instances for property testing.
func ManagedIdentity_ARMGenerator() gopter.Gen {
	if managedIdentity_ARMGenerator != nil {
		return managedIdentity_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedIdentity_ARM(generators)
	managedIdentity_ARMGenerator = gen.Struct(reflect.TypeOf(ManagedIdentity_ARM{}), generators)

	return managedIdentity_ARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedIdentity_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedIdentity_ARM(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentity"] = gen.PtrOf(gen.AlphaString())
}

func Test_MessagingEndpointProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MessagingEndpointProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMessagingEndpointProperties_ARM, MessagingEndpointProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMessagingEndpointProperties_ARM runs a test to see if a specific instance of MessagingEndpointProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForMessagingEndpointProperties_ARM(subject MessagingEndpointProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MessagingEndpointProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MessagingEndpointProperties_ARM instances for property testing - lazily instantiated by
// MessagingEndpointProperties_ARMGenerator()
var messagingEndpointProperties_ARMGenerator gopter.Gen

// MessagingEndpointProperties_ARMGenerator returns a generator of MessagingEndpointProperties_ARM instances for property testing.
func MessagingEndpointProperties_ARMGenerator() gopter.Gen {
	if messagingEndpointProperties_ARMGenerator != nil {
		return messagingEndpointProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMessagingEndpointProperties_ARM(generators)
	messagingEndpointProperties_ARMGenerator = gen.Struct(reflect.TypeOf(MessagingEndpointProperties_ARM{}), generators)

	return messagingEndpointProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForMessagingEndpointProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMessagingEndpointProperties_ARM(gens map[string]gopter.Gen) {
	gens["LockDurationAsIso8601"] = gen.PtrOf(gen.AlphaString())
	gens["MaxDeliveryCount"] = gen.PtrOf(gen.Int())
	gens["TtlAsIso8601"] = gen.PtrOf(gen.AlphaString())
}

func Test_NetworkRuleSetIpRule_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkRuleSetIpRule_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkRuleSetIpRule_ARM, NetworkRuleSetIpRule_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkRuleSetIpRule_ARM runs a test to see if a specific instance of NetworkRuleSetIpRule_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkRuleSetIpRule_ARM(subject NetworkRuleSetIpRule_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkRuleSetIpRule_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkRuleSetIpRule_ARM instances for property testing - lazily instantiated by
// NetworkRuleSetIpRule_ARMGenerator()
var networkRuleSetIpRule_ARMGenerator gopter.Gen

// NetworkRuleSetIpRule_ARMGenerator returns a generator of NetworkRuleSetIpRule_ARM instances for property testing.
func NetworkRuleSetIpRule_ARMGenerator() gopter.Gen {
	if networkRuleSetIpRule_ARMGenerator != nil {
		return networkRuleSetIpRule_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSetIpRule_ARM(generators)
	networkRuleSetIpRule_ARMGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSetIpRule_ARM{}), generators)

	return networkRuleSetIpRule_ARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkRuleSetIpRule_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkRuleSetIpRule_ARM(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(NetworkRuleSetIpRule_Action_ARM_Allow))
	gens["FilterName"] = gen.PtrOf(gen.AlphaString())
	gens["IpMask"] = gen.PtrOf(gen.AlphaString())
}

func Test_NetworkRuleSetProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkRuleSetProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkRuleSetProperties_ARM, NetworkRuleSetProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkRuleSetProperties_ARM runs a test to see if a specific instance of NetworkRuleSetProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkRuleSetProperties_ARM(subject NetworkRuleSetProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkRuleSetProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkRuleSetProperties_ARM instances for property testing - lazily instantiated by
// NetworkRuleSetProperties_ARMGenerator()
var networkRuleSetProperties_ARMGenerator gopter.Gen

// NetworkRuleSetProperties_ARMGenerator returns a generator of NetworkRuleSetProperties_ARM instances for property testing.
// We first initialize networkRuleSetProperties_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkRuleSetProperties_ARMGenerator() gopter.Gen {
	if networkRuleSetProperties_ARMGenerator != nil {
		return networkRuleSetProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSetProperties_ARM(generators)
	networkRuleSetProperties_ARMGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSetProperties_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSetProperties_ARM(generators)
	AddRelatedPropertyGeneratorsForNetworkRuleSetProperties_ARM(generators)
	networkRuleSetProperties_ARMGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSetProperties_ARM{}), generators)

	return networkRuleSetProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkRuleSetProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkRuleSetProperties_ARM(gens map[string]gopter.Gen) {
	gens["ApplyToBuiltInEventHubEndpoint"] = gen.PtrOf(gen.Bool())
	gens["DefaultAction"] = gen.PtrOf(gen.OneConstOf(NetworkRuleSetProperties_DefaultAction_ARM_Allow, NetworkRuleSetProperties_DefaultAction_ARM_Deny))
}

// AddRelatedPropertyGeneratorsForNetworkRuleSetProperties_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkRuleSetProperties_ARM(gens map[string]gopter.Gen) {
	gens["IpRules"] = gen.SliceOf(NetworkRuleSetIpRule_ARMGenerator())
}

func Test_RouteProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RouteProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRouteProperties_ARM, RouteProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRouteProperties_ARM runs a test to see if a specific instance of RouteProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRouteProperties_ARM(subject RouteProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RouteProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RouteProperties_ARM instances for property testing - lazily instantiated by
// RouteProperties_ARMGenerator()
var routeProperties_ARMGenerator gopter.Gen

// RouteProperties_ARMGenerator returns a generator of RouteProperties_ARM instances for property testing.
func RouteProperties_ARMGenerator() gopter.Gen {
	if routeProperties_ARMGenerator != nil {
		return routeProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRouteProperties_ARM(generators)
	routeProperties_ARMGenerator = gen.Struct(reflect.TypeOf(RouteProperties_ARM{}), generators)

	return routeProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForRouteProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRouteProperties_ARM(gens map[string]gopter.Gen) {
	gens["Condition"] = gen.PtrOf(gen.AlphaString())
	gens["EndpointNames"] = gen.SliceOf(gen.AlphaString())
	gens["IsEnabled"] = gen.PtrOf(gen.Bool())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Source"] = gen.PtrOf(gen.OneConstOf(
		RouteProperties_Source_ARM_DeviceConnectionStateEvents,
		RouteProperties_Source_ARM_DeviceJobLifecycleEvents,
		RouteProperties_Source_ARM_DeviceLifecycleEvents,
		RouteProperties_Source_ARM_DeviceMessages,
		RouteProperties_Source_ARM_Invalid,
		RouteProperties_Source_ARM_TwinChangeEvents))
}

func Test_RoutingEndpoints_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingEndpoints_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingEndpoints_ARM, RoutingEndpoints_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingEndpoints_ARM runs a test to see if a specific instance of RoutingEndpoints_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingEndpoints_ARM(subject RoutingEndpoints_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingEndpoints_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingEndpoints_ARM instances for property testing - lazily instantiated by
// RoutingEndpoints_ARMGenerator()
var routingEndpoints_ARMGenerator gopter.Gen

// RoutingEndpoints_ARMGenerator returns a generator of RoutingEndpoints_ARM instances for property testing.
func RoutingEndpoints_ARMGenerator() gopter.Gen {
	if routingEndpoints_ARMGenerator != nil {
		return routingEndpoints_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForRoutingEndpoints_ARM(generators)
	routingEndpoints_ARMGenerator = gen.Struct(reflect.TypeOf(RoutingEndpoints_ARM{}), generators)

	return routingEndpoints_ARMGenerator
}

// AddRelatedPropertyGeneratorsForRoutingEndpoints_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRoutingEndpoints_ARM(gens map[string]gopter.Gen) {
	gens["EventHubs"] = gen.SliceOf(RoutingEventHubProperties_ARMGenerator())
	gens["ServiceBusQueues"] = gen.SliceOf(RoutingServiceBusQueueEndpointProperties_ARMGenerator())
	gens["ServiceBusTopics"] = gen.SliceOf(RoutingServiceBusTopicEndpointProperties_ARMGenerator())
	gens["StorageContainers"] = gen.SliceOf(RoutingStorageContainerProperties_ARMGenerator())
}

func Test_RoutingEventHubProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingEventHubProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingEventHubProperties_ARM, RoutingEventHubProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingEventHubProperties_ARM runs a test to see if a specific instance of RoutingEventHubProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingEventHubProperties_ARM(subject RoutingEventHubProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingEventHubProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingEventHubProperties_ARM instances for property testing - lazily instantiated by
// RoutingEventHubProperties_ARMGenerator()
var routingEventHubProperties_ARMGenerator gopter.Gen

// RoutingEventHubProperties_ARMGenerator returns a generator of RoutingEventHubProperties_ARM instances for property testing.
// We first initialize routingEventHubProperties_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RoutingEventHubProperties_ARMGenerator() gopter.Gen {
	if routingEventHubProperties_ARMGenerator != nil {
		return routingEventHubProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingEventHubProperties_ARM(generators)
	routingEventHubProperties_ARMGenerator = gen.Struct(reflect.TypeOf(RoutingEventHubProperties_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingEventHubProperties_ARM(generators)
	AddRelatedPropertyGeneratorsForRoutingEventHubProperties_ARM(generators)
	routingEventHubProperties_ARMGenerator = gen.Struct(reflect.TypeOf(RoutingEventHubProperties_ARM{}), generators)

	return routingEventHubProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForRoutingEventHubProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRoutingEventHubProperties_ARM(gens map[string]gopter.Gen) {
	gens["AuthenticationType"] = gen.PtrOf(gen.OneConstOf(RoutingEventHubProperties_AuthenticationType_ARM_IdentityBased, RoutingEventHubProperties_AuthenticationType_ARM_KeyBased))
	gens["ConnectionString"] = gen.PtrOf(gen.AlphaString())
	gens["EndpointUri"] = gen.PtrOf(gen.AlphaString())
	gens["EntityPath"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceGroup"] = gen.PtrOf(gen.AlphaString())
	gens["SubscriptionId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForRoutingEventHubProperties_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRoutingEventHubProperties_ARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedIdentity_ARMGenerator())
}

func Test_RoutingProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingProperties_ARM, RoutingProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingProperties_ARM runs a test to see if a specific instance of RoutingProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingProperties_ARM(subject RoutingProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingProperties_ARM instances for property testing - lazily instantiated by
// RoutingProperties_ARMGenerator()
var routingProperties_ARMGenerator gopter.Gen

// RoutingProperties_ARMGenerator returns a generator of RoutingProperties_ARM instances for property testing.
func RoutingProperties_ARMGenerator() gopter.Gen {
	if routingProperties_ARMGenerator != nil {
		return routingProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForRoutingProperties_ARM(generators)
	routingProperties_ARMGenerator = gen.Struct(reflect.TypeOf(RoutingProperties_ARM{}), generators)

	return routingProperties_ARMGenerator
}

// AddRelatedPropertyGeneratorsForRoutingProperties_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRoutingProperties_ARM(gens map[string]gopter.Gen) {
	gens["Endpoints"] = gen.PtrOf(RoutingEndpoints_ARMGenerator())
	gens["Enrichments"] = gen.SliceOf(EnrichmentProperties_ARMGenerator())
	gens["FallbackRoute"] = gen.PtrOf(FallbackRouteProperties_ARMGenerator())
	gens["Routes"] = gen.SliceOf(RouteProperties_ARMGenerator())
}

func Test_RoutingServiceBusQueueEndpointProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingServiceBusQueueEndpointProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingServiceBusQueueEndpointProperties_ARM, RoutingServiceBusQueueEndpointProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingServiceBusQueueEndpointProperties_ARM runs a test to see if a specific instance of RoutingServiceBusQueueEndpointProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingServiceBusQueueEndpointProperties_ARM(subject RoutingServiceBusQueueEndpointProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingServiceBusQueueEndpointProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingServiceBusQueueEndpointProperties_ARM instances for property testing - lazily instantiated by
// RoutingServiceBusQueueEndpointProperties_ARMGenerator()
var routingServiceBusQueueEndpointProperties_ARMGenerator gopter.Gen

// RoutingServiceBusQueueEndpointProperties_ARMGenerator returns a generator of RoutingServiceBusQueueEndpointProperties_ARM instances for property testing.
// We first initialize routingServiceBusQueueEndpointProperties_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RoutingServiceBusQueueEndpointProperties_ARMGenerator() gopter.Gen {
	if routingServiceBusQueueEndpointProperties_ARMGenerator != nil {
		return routingServiceBusQueueEndpointProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingServiceBusQueueEndpointProperties_ARM(generators)
	routingServiceBusQueueEndpointProperties_ARMGenerator = gen.Struct(reflect.TypeOf(RoutingServiceBusQueueEndpointProperties_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingServiceBusQueueEndpointProperties_ARM(generators)
	AddRelatedPropertyGeneratorsForRoutingServiceBusQueueEndpointProperties_ARM(generators)
	routingServiceBusQueueEndpointProperties_ARMGenerator = gen.Struct(reflect.TypeOf(RoutingServiceBusQueueEndpointProperties_ARM{}), generators)

	return routingServiceBusQueueEndpointProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForRoutingServiceBusQueueEndpointProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRoutingServiceBusQueueEndpointProperties_ARM(gens map[string]gopter.Gen) {
	gens["AuthenticationType"] = gen.PtrOf(gen.OneConstOf(RoutingServiceBusQueueEndpointProperties_AuthenticationType_ARM_IdentityBased, RoutingServiceBusQueueEndpointProperties_AuthenticationType_ARM_KeyBased))
	gens["ConnectionString"] = gen.PtrOf(gen.AlphaString())
	gens["EndpointUri"] = gen.PtrOf(gen.AlphaString())
	gens["EntityPath"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceGroup"] = gen.PtrOf(gen.AlphaString())
	gens["SubscriptionId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForRoutingServiceBusQueueEndpointProperties_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRoutingServiceBusQueueEndpointProperties_ARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedIdentity_ARMGenerator())
}

func Test_RoutingServiceBusTopicEndpointProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingServiceBusTopicEndpointProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingServiceBusTopicEndpointProperties_ARM, RoutingServiceBusTopicEndpointProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingServiceBusTopicEndpointProperties_ARM runs a test to see if a specific instance of RoutingServiceBusTopicEndpointProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingServiceBusTopicEndpointProperties_ARM(subject RoutingServiceBusTopicEndpointProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingServiceBusTopicEndpointProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingServiceBusTopicEndpointProperties_ARM instances for property testing - lazily instantiated by
// RoutingServiceBusTopicEndpointProperties_ARMGenerator()
var routingServiceBusTopicEndpointProperties_ARMGenerator gopter.Gen

// RoutingServiceBusTopicEndpointProperties_ARMGenerator returns a generator of RoutingServiceBusTopicEndpointProperties_ARM instances for property testing.
// We first initialize routingServiceBusTopicEndpointProperties_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RoutingServiceBusTopicEndpointProperties_ARMGenerator() gopter.Gen {
	if routingServiceBusTopicEndpointProperties_ARMGenerator != nil {
		return routingServiceBusTopicEndpointProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingServiceBusTopicEndpointProperties_ARM(generators)
	routingServiceBusTopicEndpointProperties_ARMGenerator = gen.Struct(reflect.TypeOf(RoutingServiceBusTopicEndpointProperties_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingServiceBusTopicEndpointProperties_ARM(generators)
	AddRelatedPropertyGeneratorsForRoutingServiceBusTopicEndpointProperties_ARM(generators)
	routingServiceBusTopicEndpointProperties_ARMGenerator = gen.Struct(reflect.TypeOf(RoutingServiceBusTopicEndpointProperties_ARM{}), generators)

	return routingServiceBusTopicEndpointProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForRoutingServiceBusTopicEndpointProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRoutingServiceBusTopicEndpointProperties_ARM(gens map[string]gopter.Gen) {
	gens["AuthenticationType"] = gen.PtrOf(gen.OneConstOf(RoutingServiceBusTopicEndpointProperties_AuthenticationType_ARM_IdentityBased, RoutingServiceBusTopicEndpointProperties_AuthenticationType_ARM_KeyBased))
	gens["ConnectionString"] = gen.PtrOf(gen.AlphaString())
	gens["EndpointUri"] = gen.PtrOf(gen.AlphaString())
	gens["EntityPath"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceGroup"] = gen.PtrOf(gen.AlphaString())
	gens["SubscriptionId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForRoutingServiceBusTopicEndpointProperties_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRoutingServiceBusTopicEndpointProperties_ARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedIdentity_ARMGenerator())
}

func Test_RoutingStorageContainerProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingStorageContainerProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingStorageContainerProperties_ARM, RoutingStorageContainerProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingStorageContainerProperties_ARM runs a test to see if a specific instance of RoutingStorageContainerProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingStorageContainerProperties_ARM(subject RoutingStorageContainerProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingStorageContainerProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingStorageContainerProperties_ARM instances for property testing - lazily instantiated by
// RoutingStorageContainerProperties_ARMGenerator()
var routingStorageContainerProperties_ARMGenerator gopter.Gen

// RoutingStorageContainerProperties_ARMGenerator returns a generator of RoutingStorageContainerProperties_ARM instances for property testing.
// We first initialize routingStorageContainerProperties_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RoutingStorageContainerProperties_ARMGenerator() gopter.Gen {
	if routingStorageContainerProperties_ARMGenerator != nil {
		return routingStorageContainerProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingStorageContainerProperties_ARM(generators)
	routingStorageContainerProperties_ARMGenerator = gen.Struct(reflect.TypeOf(RoutingStorageContainerProperties_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingStorageContainerProperties_ARM(generators)
	AddRelatedPropertyGeneratorsForRoutingStorageContainerProperties_ARM(generators)
	routingStorageContainerProperties_ARMGenerator = gen.Struct(reflect.TypeOf(RoutingStorageContainerProperties_ARM{}), generators)

	return routingStorageContainerProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForRoutingStorageContainerProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRoutingStorageContainerProperties_ARM(gens map[string]gopter.Gen) {
	gens["AuthenticationType"] = gen.PtrOf(gen.OneConstOf(RoutingStorageContainerProperties_AuthenticationType_ARM_IdentityBased, RoutingStorageContainerProperties_AuthenticationType_ARM_KeyBased))
	gens["BatchFrequencyInSeconds"] = gen.PtrOf(gen.Int())
	gens["ConnectionString"] = gen.PtrOf(gen.AlphaString())
	gens["ContainerName"] = gen.PtrOf(gen.AlphaString())
	gens["Encoding"] = gen.PtrOf(gen.OneConstOf(RoutingStorageContainerProperties_Encoding_ARM_Avro, RoutingStorageContainerProperties_Encoding_ARM_AvroDeflate, RoutingStorageContainerProperties_Encoding_ARM_JSON))
	gens["EndpointUri"] = gen.PtrOf(gen.AlphaString())
	gens["FileNameFormat"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["MaxChunkSizeInBytes"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceGroup"] = gen.PtrOf(gen.AlphaString())
	gens["SubscriptionId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForRoutingStorageContainerProperties_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRoutingStorageContainerProperties_ARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedIdentity_ARMGenerator())
}

func Test_SharedAccessSignatureAuthorizationRule_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SharedAccessSignatureAuthorizationRule_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSharedAccessSignatureAuthorizationRule_ARM, SharedAccessSignatureAuthorizationRule_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSharedAccessSignatureAuthorizationRule_ARM runs a test to see if a specific instance of SharedAccessSignatureAuthorizationRule_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSharedAccessSignatureAuthorizationRule_ARM(subject SharedAccessSignatureAuthorizationRule_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SharedAccessSignatureAuthorizationRule_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SharedAccessSignatureAuthorizationRule_ARM instances for property testing - lazily instantiated by
// SharedAccessSignatureAuthorizationRule_ARMGenerator()
var sharedAccessSignatureAuthorizationRule_ARMGenerator gopter.Gen

// SharedAccessSignatureAuthorizationRule_ARMGenerator returns a generator of SharedAccessSignatureAuthorizationRule_ARM instances for property testing.
func SharedAccessSignatureAuthorizationRule_ARMGenerator() gopter.Gen {
	if sharedAccessSignatureAuthorizationRule_ARMGenerator != nil {
		return sharedAccessSignatureAuthorizationRule_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSharedAccessSignatureAuthorizationRule_ARM(generators)
	sharedAccessSignatureAuthorizationRule_ARMGenerator = gen.Struct(reflect.TypeOf(SharedAccessSignatureAuthorizationRule_ARM{}), generators)

	return sharedAccessSignatureAuthorizationRule_ARMGenerator
}

// AddIndependentPropertyGeneratorsForSharedAccessSignatureAuthorizationRule_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSharedAccessSignatureAuthorizationRule_ARM(gens map[string]gopter.Gen) {
	gens["KeyName"] = gen.PtrOf(gen.AlphaString())
	gens["Rights"] = gen.PtrOf(gen.OneConstOf(
		SharedAccessSignatureAuthorizationRule_Rights_ARM_DeviceConnect,
		SharedAccessSignatureAuthorizationRule_Rights_ARM_RegistryRead,
		SharedAccessSignatureAuthorizationRule_Rights_ARM_RegistryReadDeviceConnect,
		SharedAccessSignatureAuthorizationRule_Rights_ARM_RegistryReadRegistryWrite,
		SharedAccessSignatureAuthorizationRule_Rights_ARM_RegistryReadRegistryWriteDeviceConnect,
		SharedAccessSignatureAuthorizationRule_Rights_ARM_RegistryReadRegistryWriteServiceConnect,
		SharedAccessSignatureAuthorizationRule_Rights_ARM_RegistryReadRegistryWriteServiceConnectDeviceConnect,
		SharedAccessSignatureAuthorizationRule_Rights_ARM_RegistryReadServiceConnect,
		SharedAccessSignatureAuthorizationRule_Rights_ARM_RegistryReadServiceConnectDeviceConnect,
		SharedAccessSignatureAuthorizationRule_Rights_ARM_RegistryWrite,
		SharedAccessSignatureAuthorizationRule_Rights_ARM_RegistryWriteDeviceConnect,
		SharedAccessSignatureAuthorizationRule_Rights_ARM_RegistryWriteServiceConnect,
		SharedAccessSignatureAuthorizationRule_Rights_ARM_RegistryWriteServiceConnectDeviceConnect,
		SharedAccessSignatureAuthorizationRule_Rights_ARM_ServiceConnect,
		SharedAccessSignatureAuthorizationRule_Rights_ARM_ServiceConnectDeviceConnect))
}

func Test_StorageEndpointProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageEndpointProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageEndpointProperties_ARM, StorageEndpointProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageEndpointProperties_ARM runs a test to see if a specific instance of StorageEndpointProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageEndpointProperties_ARM(subject StorageEndpointProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageEndpointProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageEndpointProperties_ARM instances for property testing - lazily instantiated by
// StorageEndpointProperties_ARMGenerator()
var storageEndpointProperties_ARMGenerator gopter.Gen

// StorageEndpointProperties_ARMGenerator returns a generator of StorageEndpointProperties_ARM instances for property testing.
// We first initialize storageEndpointProperties_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func StorageEndpointProperties_ARMGenerator() gopter.Gen {
	if storageEndpointProperties_ARMGenerator != nil {
		return storageEndpointProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageEndpointProperties_ARM(generators)
	storageEndpointProperties_ARMGenerator = gen.Struct(reflect.TypeOf(StorageEndpointProperties_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageEndpointProperties_ARM(generators)
	AddRelatedPropertyGeneratorsForStorageEndpointProperties_ARM(generators)
	storageEndpointProperties_ARMGenerator = gen.Struct(reflect.TypeOf(StorageEndpointProperties_ARM{}), generators)

	return storageEndpointProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForStorageEndpointProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageEndpointProperties_ARM(gens map[string]gopter.Gen) {
	gens["AuthenticationType"] = gen.PtrOf(gen.OneConstOf(StorageEndpointProperties_AuthenticationType_ARM_IdentityBased, StorageEndpointProperties_AuthenticationType_ARM_KeyBased))
	gens["ConnectionString"] = gen.PtrOf(gen.AlphaString())
	gens["ContainerName"] = gen.PtrOf(gen.AlphaString())
	gens["SasTtlAsIso8601"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForStorageEndpointProperties_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageEndpointProperties_ARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedIdentity_ARMGenerator())
}

func Test_UserAssignedIdentityDetails_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentityDetails_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentityDetails_ARM, UserAssignedIdentityDetails_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentityDetails_ARM runs a test to see if a specific instance of UserAssignedIdentityDetails_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentityDetails_ARM(subject UserAssignedIdentityDetails_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentityDetails_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentityDetails_ARM instances for property testing - lazily instantiated by
// UserAssignedIdentityDetails_ARMGenerator()
var userAssignedIdentityDetails_ARMGenerator gopter.Gen

// UserAssignedIdentityDetails_ARMGenerator returns a generator of UserAssignedIdentityDetails_ARM instances for property testing.
func UserAssignedIdentityDetails_ARMGenerator() gopter.Gen {
	if userAssignedIdentityDetails_ARMGenerator != nil {
		return userAssignedIdentityDetails_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	userAssignedIdentityDetails_ARMGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentityDetails_ARM{}), generators)

	return userAssignedIdentityDetails_ARMGenerator
}
