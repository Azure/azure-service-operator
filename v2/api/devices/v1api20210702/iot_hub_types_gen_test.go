// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20210702

import (
	"encoding/json"
	storage "github.com/Azure/azure-service-operator/v2/api/devices/v1api20210702/storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_IotHub_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	parameters.MinSuccessfulTests = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IotHub to hub returns original",
		prop.ForAll(RunResourceConversionTestForIotHub, IotHubGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForIotHub tests if a specific instance of IotHub round trips to the hub storage version and back losslessly
func RunResourceConversionTestForIotHub(subject IotHub) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub storage.IotHub
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual IotHub
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IotHub_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IotHub to IotHub via AssignProperties_To_IotHub & AssignProperties_From_IotHub returns original",
		prop.ForAll(RunPropertyAssignmentTestForIotHub, IotHubGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIotHub tests if a specific instance of IotHub can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForIotHub(subject IotHub) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.IotHub
	err := copied.AssignProperties_To_IotHub(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IotHub
	err = actual.AssignProperties_From_IotHub(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IotHub_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IotHub via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIotHub, IotHubGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIotHub runs a test to see if a specific instance of IotHub round trips to JSON and back losslessly
func RunJSONSerializationTestForIotHub(subject IotHub) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IotHub
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IotHub instances for property testing - lazily instantiated by IotHubGenerator()
var iotHubGenerator gopter.Gen

// IotHubGenerator returns a generator of IotHub instances for property testing.
func IotHubGenerator() gopter.Gen {
	if iotHubGenerator != nil {
		return iotHubGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForIotHub(generators)
	iotHubGenerator = gen.Struct(reflect.TypeOf(IotHub{}), generators)

	return iotHubGenerator
}

// AddRelatedPropertyGeneratorsForIotHub is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIotHub(gens map[string]gopter.Gen) {
	gens["Spec"] = IotHub_SpecGenerator()
	gens["Status"] = IotHub_STATUSGenerator()
}

func Test_IotHub_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IotHub_Spec to IotHub_Spec via AssignProperties_To_IotHub_Spec & AssignProperties_From_IotHub_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForIotHub_Spec, IotHub_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIotHub_Spec tests if a specific instance of IotHub_Spec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForIotHub_Spec(subject IotHub_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.IotHub_Spec
	err := copied.AssignProperties_To_IotHub_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IotHub_Spec
	err = actual.AssignProperties_From_IotHub_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IotHub_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IotHub_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIotHub_Spec, IotHub_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIotHub_Spec runs a test to see if a specific instance of IotHub_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForIotHub_Spec(subject IotHub_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IotHub_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IotHub_Spec instances for property testing - lazily instantiated by IotHub_SpecGenerator()
var iotHub_SpecGenerator gopter.Gen

// IotHub_SpecGenerator returns a generator of IotHub_Spec instances for property testing.
// We first initialize iotHub_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IotHub_SpecGenerator() gopter.Gen {
	if iotHub_SpecGenerator != nil {
		return iotHub_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIotHub_Spec(generators)
	iotHub_SpecGenerator = gen.Struct(reflect.TypeOf(IotHub_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIotHub_Spec(generators)
	AddRelatedPropertyGeneratorsForIotHub_Spec(generators)
	iotHub_SpecGenerator = gen.Struct(reflect.TypeOf(IotHub_Spec{}), generators)

	return iotHub_SpecGenerator
}

// AddIndependentPropertyGeneratorsForIotHub_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIotHub_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForIotHub_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIotHub_Spec(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ArmIdentityGenerator())
	gens["OperatorSpec"] = gen.PtrOf(IotHubOperatorSpecGenerator())
	gens["Properties"] = gen.PtrOf(IotHubPropertiesGenerator())
	gens["Sku"] = gen.PtrOf(IotHubSkuInfoGenerator())
}

func Test_IotHub_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IotHub_STATUS to IotHub_STATUS via AssignProperties_To_IotHub_STATUS & AssignProperties_From_IotHub_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForIotHub_STATUS, IotHub_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIotHub_STATUS tests if a specific instance of IotHub_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForIotHub_STATUS(subject IotHub_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.IotHub_STATUS
	err := copied.AssignProperties_To_IotHub_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IotHub_STATUS
	err = actual.AssignProperties_From_IotHub_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IotHub_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IotHub_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIotHub_STATUS, IotHub_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIotHub_STATUS runs a test to see if a specific instance of IotHub_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForIotHub_STATUS(subject IotHub_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IotHub_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IotHub_STATUS instances for property testing - lazily instantiated by IotHub_STATUSGenerator()
var iotHub_STATUSGenerator gopter.Gen

// IotHub_STATUSGenerator returns a generator of IotHub_STATUS instances for property testing.
// We first initialize iotHub_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IotHub_STATUSGenerator() gopter.Gen {
	if iotHub_STATUSGenerator != nil {
		return iotHub_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIotHub_STATUS(generators)
	iotHub_STATUSGenerator = gen.Struct(reflect.TypeOf(IotHub_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIotHub_STATUS(generators)
	AddRelatedPropertyGeneratorsForIotHub_STATUS(generators)
	iotHub_STATUSGenerator = gen.Struct(reflect.TypeOf(IotHub_STATUS{}), generators)

	return iotHub_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForIotHub_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIotHub_STATUS(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForIotHub_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIotHub_STATUS(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ArmIdentity_STATUSGenerator())
	gens["Properties"] = gen.PtrOf(IotHubProperties_STATUSGenerator())
	gens["Sku"] = gen.PtrOf(IotHubSkuInfo_STATUSGenerator())
	gens["SystemData"] = gen.PtrOf(SystemData_STATUSGenerator())
}

func Test_ArmIdentity_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ArmIdentity to ArmIdentity via AssignProperties_To_ArmIdentity & AssignProperties_From_ArmIdentity returns original",
		prop.ForAll(RunPropertyAssignmentTestForArmIdentity, ArmIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForArmIdentity tests if a specific instance of ArmIdentity can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForArmIdentity(subject ArmIdentity) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ArmIdentity
	err := copied.AssignProperties_To_ArmIdentity(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ArmIdentity
	err = actual.AssignProperties_From_ArmIdentity(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ArmIdentity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ArmIdentity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForArmIdentity, ArmIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForArmIdentity runs a test to see if a specific instance of ArmIdentity round trips to JSON and back losslessly
func RunJSONSerializationTestForArmIdentity(subject ArmIdentity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ArmIdentity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ArmIdentity instances for property testing - lazily instantiated by ArmIdentityGenerator()
var armIdentityGenerator gopter.Gen

// ArmIdentityGenerator returns a generator of ArmIdentity instances for property testing.
// We first initialize armIdentityGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ArmIdentityGenerator() gopter.Gen {
	if armIdentityGenerator != nil {
		return armIdentityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForArmIdentity(generators)
	armIdentityGenerator = gen.Struct(reflect.TypeOf(ArmIdentity{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForArmIdentity(generators)
	AddRelatedPropertyGeneratorsForArmIdentity(generators)
	armIdentityGenerator = gen.Struct(reflect.TypeOf(ArmIdentity{}), generators)

	return armIdentityGenerator
}

// AddIndependentPropertyGeneratorsForArmIdentity is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForArmIdentity(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ArmIdentity_Type_None,
		ArmIdentity_Type_SystemAssigned,
		ArmIdentity_Type_SystemAssignedUserAssigned,
		ArmIdentity_Type_UserAssigned))
}

// AddRelatedPropertyGeneratorsForArmIdentity is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForArmIdentity(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.SliceOf(UserAssignedIdentityDetailsGenerator())
}

func Test_ArmIdentity_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ArmIdentity_STATUS to ArmIdentity_STATUS via AssignProperties_To_ArmIdentity_STATUS & AssignProperties_From_ArmIdentity_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForArmIdentity_STATUS, ArmIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForArmIdentity_STATUS tests if a specific instance of ArmIdentity_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForArmIdentity_STATUS(subject ArmIdentity_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ArmIdentity_STATUS
	err := copied.AssignProperties_To_ArmIdentity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ArmIdentity_STATUS
	err = actual.AssignProperties_From_ArmIdentity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ArmIdentity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ArmIdentity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForArmIdentity_STATUS, ArmIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForArmIdentity_STATUS runs a test to see if a specific instance of ArmIdentity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForArmIdentity_STATUS(subject ArmIdentity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ArmIdentity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ArmIdentity_STATUS instances for property testing - lazily instantiated by ArmIdentity_STATUSGenerator()
var armIdentity_STATUSGenerator gopter.Gen

// ArmIdentity_STATUSGenerator returns a generator of ArmIdentity_STATUS instances for property testing.
// We first initialize armIdentity_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ArmIdentity_STATUSGenerator() gopter.Gen {
	if armIdentity_STATUSGenerator != nil {
		return armIdentity_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForArmIdentity_STATUS(generators)
	armIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(ArmIdentity_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForArmIdentity_STATUS(generators)
	AddRelatedPropertyGeneratorsForArmIdentity_STATUS(generators)
	armIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(ArmIdentity_STATUS{}), generators)

	return armIdentity_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForArmIdentity_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForArmIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ArmIdentity_Type_STATUS_None,
		ArmIdentity_Type_STATUS_SystemAssigned,
		ArmIdentity_Type_STATUS_SystemAssignedUserAssigned,
		ArmIdentity_Type_STATUS_UserAssigned))
}

// AddRelatedPropertyGeneratorsForArmIdentity_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForArmIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(
		gen.AlphaString(),
		ArmUserIdentity_STATUSGenerator())
}

func Test_IotHubOperatorSpec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IotHubOperatorSpec to IotHubOperatorSpec via AssignProperties_To_IotHubOperatorSpec & AssignProperties_From_IotHubOperatorSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForIotHubOperatorSpec, IotHubOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIotHubOperatorSpec tests if a specific instance of IotHubOperatorSpec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForIotHubOperatorSpec(subject IotHubOperatorSpec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.IotHubOperatorSpec
	err := copied.AssignProperties_To_IotHubOperatorSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IotHubOperatorSpec
	err = actual.AssignProperties_From_IotHubOperatorSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IotHubOperatorSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IotHubOperatorSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIotHubOperatorSpec, IotHubOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIotHubOperatorSpec runs a test to see if a specific instance of IotHubOperatorSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForIotHubOperatorSpec(subject IotHubOperatorSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IotHubOperatorSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IotHubOperatorSpec instances for property testing - lazily instantiated by IotHubOperatorSpecGenerator()
var iotHubOperatorSpecGenerator gopter.Gen

// IotHubOperatorSpecGenerator returns a generator of IotHubOperatorSpec instances for property testing.
func IotHubOperatorSpecGenerator() gopter.Gen {
	if iotHubOperatorSpecGenerator != nil {
		return iotHubOperatorSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForIotHubOperatorSpec(generators)
	iotHubOperatorSpecGenerator = gen.Struct(reflect.TypeOf(IotHubOperatorSpec{}), generators)

	return iotHubOperatorSpecGenerator
}

// AddRelatedPropertyGeneratorsForIotHubOperatorSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIotHubOperatorSpec(gens map[string]gopter.Gen) {
	gens["Secrets"] = gen.PtrOf(IotHubOperatorSecretsGenerator())
}

func Test_IotHubProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IotHubProperties to IotHubProperties via AssignProperties_To_IotHubProperties & AssignProperties_From_IotHubProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForIotHubProperties, IotHubPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIotHubProperties tests if a specific instance of IotHubProperties can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForIotHubProperties(subject IotHubProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.IotHubProperties
	err := copied.AssignProperties_To_IotHubProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IotHubProperties
	err = actual.AssignProperties_From_IotHubProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IotHubProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IotHubProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIotHubProperties, IotHubPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIotHubProperties runs a test to see if a specific instance of IotHubProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForIotHubProperties(subject IotHubProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IotHubProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IotHubProperties instances for property testing - lazily instantiated by IotHubPropertiesGenerator()
var iotHubPropertiesGenerator gopter.Gen

// IotHubPropertiesGenerator returns a generator of IotHubProperties instances for property testing.
// We first initialize iotHubPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IotHubPropertiesGenerator() gopter.Gen {
	if iotHubPropertiesGenerator != nil {
		return iotHubPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIotHubProperties(generators)
	iotHubPropertiesGenerator = gen.Struct(reflect.TypeOf(IotHubProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIotHubProperties(generators)
	AddRelatedPropertyGeneratorsForIotHubProperties(generators)
	iotHubPropertiesGenerator = gen.Struct(reflect.TypeOf(IotHubProperties{}), generators)

	return iotHubPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForIotHubProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIotHubProperties(gens map[string]gopter.Gen) {
	gens["AllowedFqdnList"] = gen.SliceOf(gen.AlphaString())
	gens["Comments"] = gen.PtrOf(gen.AlphaString())
	gens["DisableDeviceSAS"] = gen.PtrOf(gen.Bool())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["DisableModuleSAS"] = gen.PtrOf(gen.Bool())
	gens["EnableDataResidency"] = gen.PtrOf(gen.Bool())
	gens["EnableFileUploadNotifications"] = gen.PtrOf(gen.Bool())
	gens["Features"] = gen.PtrOf(gen.OneConstOf(IotHubProperties_Features_DeviceManagement, IotHubProperties_Features_None))
	gens["MinTlsVersion"] = gen.PtrOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(IotHubProperties_PublicNetworkAccess_Disabled, IotHubProperties_PublicNetworkAccess_Enabled))
	gens["RestrictOutboundNetworkAccess"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForIotHubProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIotHubProperties(gens map[string]gopter.Gen) {
	gens["AuthorizationPolicies"] = gen.SliceOf(SharedAccessSignatureAuthorizationRuleGenerator())
	gens["CloudToDevice"] = gen.PtrOf(CloudToDevicePropertiesGenerator())
	gens["EventHubEndpoints"] = gen.MapOf(
		gen.AlphaString(),
		EventHubPropertiesGenerator())
	gens["IpFilterRules"] = gen.SliceOf(IpFilterRuleGenerator())
	gens["MessagingEndpoints"] = gen.MapOf(
		gen.AlphaString(),
		MessagingEndpointPropertiesGenerator())
	gens["NetworkRuleSets"] = gen.PtrOf(NetworkRuleSetPropertiesGenerator())
	gens["Routing"] = gen.PtrOf(RoutingPropertiesGenerator())
	gens["StorageEndpoints"] = gen.MapOf(
		gen.AlphaString(),
		StorageEndpointPropertiesGenerator())
}

func Test_IotHubProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IotHubProperties_STATUS to IotHubProperties_STATUS via AssignProperties_To_IotHubProperties_STATUS & AssignProperties_From_IotHubProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForIotHubProperties_STATUS, IotHubProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIotHubProperties_STATUS tests if a specific instance of IotHubProperties_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForIotHubProperties_STATUS(subject IotHubProperties_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.IotHubProperties_STATUS
	err := copied.AssignProperties_To_IotHubProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IotHubProperties_STATUS
	err = actual.AssignProperties_From_IotHubProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IotHubProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IotHubProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIotHubProperties_STATUS, IotHubProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIotHubProperties_STATUS runs a test to see if a specific instance of IotHubProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForIotHubProperties_STATUS(subject IotHubProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IotHubProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IotHubProperties_STATUS instances for property testing - lazily instantiated by
// IotHubProperties_STATUSGenerator()
var iotHubProperties_STATUSGenerator gopter.Gen

// IotHubProperties_STATUSGenerator returns a generator of IotHubProperties_STATUS instances for property testing.
// We first initialize iotHubProperties_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IotHubProperties_STATUSGenerator() gopter.Gen {
	if iotHubProperties_STATUSGenerator != nil {
		return iotHubProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIotHubProperties_STATUS(generators)
	iotHubProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(IotHubProperties_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIotHubProperties_STATUS(generators)
	AddRelatedPropertyGeneratorsForIotHubProperties_STATUS(generators)
	iotHubProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(IotHubProperties_STATUS{}), generators)

	return iotHubProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForIotHubProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIotHubProperties_STATUS(gens map[string]gopter.Gen) {
	gens["AllowedFqdnList"] = gen.SliceOf(gen.AlphaString())
	gens["Comments"] = gen.PtrOf(gen.AlphaString())
	gens["DisableDeviceSAS"] = gen.PtrOf(gen.Bool())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["DisableModuleSAS"] = gen.PtrOf(gen.Bool())
	gens["EnableDataResidency"] = gen.PtrOf(gen.Bool())
	gens["EnableFileUploadNotifications"] = gen.PtrOf(gen.Bool())
	gens["Features"] = gen.PtrOf(gen.OneConstOf(IotHubProperties_Features_STATUS_DeviceManagement, IotHubProperties_Features_STATUS_None))
	gens["HostName"] = gen.PtrOf(gen.AlphaString())
	gens["MinTlsVersion"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(IotHubProperties_PublicNetworkAccess_STATUS_Disabled, IotHubProperties_PublicNetworkAccess_STATUS_Enabled))
	gens["RestrictOutboundNetworkAccess"] = gen.PtrOf(gen.Bool())
	gens["State"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForIotHubProperties_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIotHubProperties_STATUS(gens map[string]gopter.Gen) {
	gens["AuthorizationPolicies"] = gen.SliceOf(SharedAccessSignatureAuthorizationRule_STATUSGenerator())
	gens["CloudToDevice"] = gen.PtrOf(CloudToDeviceProperties_STATUSGenerator())
	gens["EventHubEndpoints"] = gen.MapOf(
		gen.AlphaString(),
		EventHubProperties_STATUSGenerator())
	gens["IpFilterRules"] = gen.SliceOf(IpFilterRule_STATUSGenerator())
	gens["Locations"] = gen.SliceOf(IotHubLocationDescription_STATUSGenerator())
	gens["MessagingEndpoints"] = gen.MapOf(
		gen.AlphaString(),
		MessagingEndpointProperties_STATUSGenerator())
	gens["NetworkRuleSets"] = gen.PtrOf(NetworkRuleSetProperties_STATUSGenerator())
	gens["PrivateEndpointConnections"] = gen.SliceOf(PrivateEndpointConnection_STATUSGenerator())
	gens["Routing"] = gen.PtrOf(RoutingProperties_STATUSGenerator())
	gens["StorageEndpoints"] = gen.MapOf(
		gen.AlphaString(),
		StorageEndpointProperties_STATUSGenerator())
}

func Test_IotHubSkuInfo_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IotHubSkuInfo to IotHubSkuInfo via AssignProperties_To_IotHubSkuInfo & AssignProperties_From_IotHubSkuInfo returns original",
		prop.ForAll(RunPropertyAssignmentTestForIotHubSkuInfo, IotHubSkuInfoGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIotHubSkuInfo tests if a specific instance of IotHubSkuInfo can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForIotHubSkuInfo(subject IotHubSkuInfo) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.IotHubSkuInfo
	err := copied.AssignProperties_To_IotHubSkuInfo(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IotHubSkuInfo
	err = actual.AssignProperties_From_IotHubSkuInfo(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IotHubSkuInfo_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IotHubSkuInfo via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIotHubSkuInfo, IotHubSkuInfoGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIotHubSkuInfo runs a test to see if a specific instance of IotHubSkuInfo round trips to JSON and back losslessly
func RunJSONSerializationTestForIotHubSkuInfo(subject IotHubSkuInfo) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IotHubSkuInfo
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IotHubSkuInfo instances for property testing - lazily instantiated by IotHubSkuInfoGenerator()
var iotHubSkuInfoGenerator gopter.Gen

// IotHubSkuInfoGenerator returns a generator of IotHubSkuInfo instances for property testing.
func IotHubSkuInfoGenerator() gopter.Gen {
	if iotHubSkuInfoGenerator != nil {
		return iotHubSkuInfoGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIotHubSkuInfo(generators)
	iotHubSkuInfoGenerator = gen.Struct(reflect.TypeOf(IotHubSkuInfo{}), generators)

	return iotHubSkuInfoGenerator
}

// AddIndependentPropertyGeneratorsForIotHubSkuInfo is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIotHubSkuInfo(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.OneConstOf(
		IotHubSkuInfo_Name_B1,
		IotHubSkuInfo_Name_B2,
		IotHubSkuInfo_Name_B3,
		IotHubSkuInfo_Name_F1,
		IotHubSkuInfo_Name_S1,
		IotHubSkuInfo_Name_S2,
		IotHubSkuInfo_Name_S3))
}

func Test_IotHubSkuInfo_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IotHubSkuInfo_STATUS to IotHubSkuInfo_STATUS via AssignProperties_To_IotHubSkuInfo_STATUS & AssignProperties_From_IotHubSkuInfo_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForIotHubSkuInfo_STATUS, IotHubSkuInfo_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIotHubSkuInfo_STATUS tests if a specific instance of IotHubSkuInfo_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForIotHubSkuInfo_STATUS(subject IotHubSkuInfo_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.IotHubSkuInfo_STATUS
	err := copied.AssignProperties_To_IotHubSkuInfo_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IotHubSkuInfo_STATUS
	err = actual.AssignProperties_From_IotHubSkuInfo_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IotHubSkuInfo_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IotHubSkuInfo_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIotHubSkuInfo_STATUS, IotHubSkuInfo_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIotHubSkuInfo_STATUS runs a test to see if a specific instance of IotHubSkuInfo_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForIotHubSkuInfo_STATUS(subject IotHubSkuInfo_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IotHubSkuInfo_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IotHubSkuInfo_STATUS instances for property testing - lazily instantiated by
// IotHubSkuInfo_STATUSGenerator()
var iotHubSkuInfo_STATUSGenerator gopter.Gen

// IotHubSkuInfo_STATUSGenerator returns a generator of IotHubSkuInfo_STATUS instances for property testing.
func IotHubSkuInfo_STATUSGenerator() gopter.Gen {
	if iotHubSkuInfo_STATUSGenerator != nil {
		return iotHubSkuInfo_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIotHubSkuInfo_STATUS(generators)
	iotHubSkuInfo_STATUSGenerator = gen.Struct(reflect.TypeOf(IotHubSkuInfo_STATUS{}), generators)

	return iotHubSkuInfo_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForIotHubSkuInfo_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIotHubSkuInfo_STATUS(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.OneConstOf(
		IotHubSkuInfo_Name_STATUS_B1,
		IotHubSkuInfo_Name_STATUS_B2,
		IotHubSkuInfo_Name_STATUS_B3,
		IotHubSkuInfo_Name_STATUS_F1,
		IotHubSkuInfo_Name_STATUS_S1,
		IotHubSkuInfo_Name_STATUS_S2,
		IotHubSkuInfo_Name_STATUS_S3))
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(IotHubSkuInfo_Tier_STATUS_Basic, IotHubSkuInfo_Tier_STATUS_Free, IotHubSkuInfo_Tier_STATUS_Standard))
}

func Test_SystemData_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SystemData_STATUS to SystemData_STATUS via AssignProperties_To_SystemData_STATUS & AssignProperties_From_SystemData_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSystemData_STATUS, SystemData_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSystemData_STATUS tests if a specific instance of SystemData_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSystemData_STATUS(subject SystemData_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.SystemData_STATUS
	err := copied.AssignProperties_To_SystemData_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SystemData_STATUS
	err = actual.AssignProperties_From_SystemData_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SystemData_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SystemData_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSystemData_STATUS, SystemData_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSystemData_STATUS runs a test to see if a specific instance of SystemData_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSystemData_STATUS(subject SystemData_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SystemData_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SystemData_STATUS instances for property testing - lazily instantiated by SystemData_STATUSGenerator()
var systemData_STATUSGenerator gopter.Gen

// SystemData_STATUSGenerator returns a generator of SystemData_STATUS instances for property testing.
func SystemData_STATUSGenerator() gopter.Gen {
	if systemData_STATUSGenerator != nil {
		return systemData_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSystemData_STATUS(generators)
	systemData_STATUSGenerator = gen.Struct(reflect.TypeOf(SystemData_STATUS{}), generators)

	return systemData_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSystemData_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSystemData_STATUS(gens map[string]gopter.Gen) {
	gens["CreatedAt"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedBy"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemData_CreatedByType_STATUS_Application,
		SystemData_CreatedByType_STATUS_Key,
		SystemData_CreatedByType_STATUS_ManagedIdentity,
		SystemData_CreatedByType_STATUS_User))
	gens["LastModifiedAt"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedBy"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemData_LastModifiedByType_STATUS_Application,
		SystemData_LastModifiedByType_STATUS_Key,
		SystemData_LastModifiedByType_STATUS_ManagedIdentity,
		SystemData_LastModifiedByType_STATUS_User))
}

func Test_ArmUserIdentity_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ArmUserIdentity_STATUS to ArmUserIdentity_STATUS via AssignProperties_To_ArmUserIdentity_STATUS & AssignProperties_From_ArmUserIdentity_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForArmUserIdentity_STATUS, ArmUserIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForArmUserIdentity_STATUS tests if a specific instance of ArmUserIdentity_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForArmUserIdentity_STATUS(subject ArmUserIdentity_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ArmUserIdentity_STATUS
	err := copied.AssignProperties_To_ArmUserIdentity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ArmUserIdentity_STATUS
	err = actual.AssignProperties_From_ArmUserIdentity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ArmUserIdentity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ArmUserIdentity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForArmUserIdentity_STATUS, ArmUserIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForArmUserIdentity_STATUS runs a test to see if a specific instance of ArmUserIdentity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForArmUserIdentity_STATUS(subject ArmUserIdentity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ArmUserIdentity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ArmUserIdentity_STATUS instances for property testing - lazily instantiated by
// ArmUserIdentity_STATUSGenerator()
var armUserIdentity_STATUSGenerator gopter.Gen

// ArmUserIdentity_STATUSGenerator returns a generator of ArmUserIdentity_STATUS instances for property testing.
func ArmUserIdentity_STATUSGenerator() gopter.Gen {
	if armUserIdentity_STATUSGenerator != nil {
		return armUserIdentity_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForArmUserIdentity_STATUS(generators)
	armUserIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(ArmUserIdentity_STATUS{}), generators)

	return armUserIdentity_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForArmUserIdentity_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForArmUserIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_CloudToDeviceProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CloudToDeviceProperties to CloudToDeviceProperties via AssignProperties_To_CloudToDeviceProperties & AssignProperties_From_CloudToDeviceProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForCloudToDeviceProperties, CloudToDevicePropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCloudToDeviceProperties tests if a specific instance of CloudToDeviceProperties can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForCloudToDeviceProperties(subject CloudToDeviceProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.CloudToDeviceProperties
	err := copied.AssignProperties_To_CloudToDeviceProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CloudToDeviceProperties
	err = actual.AssignProperties_From_CloudToDeviceProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CloudToDeviceProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CloudToDeviceProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCloudToDeviceProperties, CloudToDevicePropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCloudToDeviceProperties runs a test to see if a specific instance of CloudToDeviceProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForCloudToDeviceProperties(subject CloudToDeviceProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CloudToDeviceProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CloudToDeviceProperties instances for property testing - lazily instantiated by
// CloudToDevicePropertiesGenerator()
var cloudToDevicePropertiesGenerator gopter.Gen

// CloudToDevicePropertiesGenerator returns a generator of CloudToDeviceProperties instances for property testing.
// We first initialize cloudToDevicePropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CloudToDevicePropertiesGenerator() gopter.Gen {
	if cloudToDevicePropertiesGenerator != nil {
		return cloudToDevicePropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCloudToDeviceProperties(generators)
	cloudToDevicePropertiesGenerator = gen.Struct(reflect.TypeOf(CloudToDeviceProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCloudToDeviceProperties(generators)
	AddRelatedPropertyGeneratorsForCloudToDeviceProperties(generators)
	cloudToDevicePropertiesGenerator = gen.Struct(reflect.TypeOf(CloudToDeviceProperties{}), generators)

	return cloudToDevicePropertiesGenerator
}

// AddIndependentPropertyGeneratorsForCloudToDeviceProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCloudToDeviceProperties(gens map[string]gopter.Gen) {
	gens["DefaultTtlAsIso8601"] = gen.PtrOf(gen.AlphaString())
	gens["MaxDeliveryCount"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForCloudToDeviceProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCloudToDeviceProperties(gens map[string]gopter.Gen) {
	gens["Feedback"] = gen.PtrOf(FeedbackPropertiesGenerator())
}

func Test_CloudToDeviceProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CloudToDeviceProperties_STATUS to CloudToDeviceProperties_STATUS via AssignProperties_To_CloudToDeviceProperties_STATUS & AssignProperties_From_CloudToDeviceProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForCloudToDeviceProperties_STATUS, CloudToDeviceProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCloudToDeviceProperties_STATUS tests if a specific instance of CloudToDeviceProperties_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForCloudToDeviceProperties_STATUS(subject CloudToDeviceProperties_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.CloudToDeviceProperties_STATUS
	err := copied.AssignProperties_To_CloudToDeviceProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CloudToDeviceProperties_STATUS
	err = actual.AssignProperties_From_CloudToDeviceProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CloudToDeviceProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CloudToDeviceProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCloudToDeviceProperties_STATUS, CloudToDeviceProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCloudToDeviceProperties_STATUS runs a test to see if a specific instance of CloudToDeviceProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForCloudToDeviceProperties_STATUS(subject CloudToDeviceProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CloudToDeviceProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CloudToDeviceProperties_STATUS instances for property testing - lazily instantiated by
// CloudToDeviceProperties_STATUSGenerator()
var cloudToDeviceProperties_STATUSGenerator gopter.Gen

// CloudToDeviceProperties_STATUSGenerator returns a generator of CloudToDeviceProperties_STATUS instances for property testing.
// We first initialize cloudToDeviceProperties_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CloudToDeviceProperties_STATUSGenerator() gopter.Gen {
	if cloudToDeviceProperties_STATUSGenerator != nil {
		return cloudToDeviceProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCloudToDeviceProperties_STATUS(generators)
	cloudToDeviceProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(CloudToDeviceProperties_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCloudToDeviceProperties_STATUS(generators)
	AddRelatedPropertyGeneratorsForCloudToDeviceProperties_STATUS(generators)
	cloudToDeviceProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(CloudToDeviceProperties_STATUS{}), generators)

	return cloudToDeviceProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForCloudToDeviceProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCloudToDeviceProperties_STATUS(gens map[string]gopter.Gen) {
	gens["DefaultTtlAsIso8601"] = gen.PtrOf(gen.AlphaString())
	gens["MaxDeliveryCount"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForCloudToDeviceProperties_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCloudToDeviceProperties_STATUS(gens map[string]gopter.Gen) {
	gens["Feedback"] = gen.PtrOf(FeedbackProperties_STATUSGenerator())
}

func Test_EventHubProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EventHubProperties to EventHubProperties via AssignProperties_To_EventHubProperties & AssignProperties_From_EventHubProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventHubProperties, EventHubPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventHubProperties tests if a specific instance of EventHubProperties can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForEventHubProperties(subject EventHubProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.EventHubProperties
	err := copied.AssignProperties_To_EventHubProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EventHubProperties
	err = actual.AssignProperties_From_EventHubProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventHubProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventHubProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventHubProperties, EventHubPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventHubProperties runs a test to see if a specific instance of EventHubProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForEventHubProperties(subject EventHubProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventHubProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventHubProperties instances for property testing - lazily instantiated by EventHubPropertiesGenerator()
var eventHubPropertiesGenerator gopter.Gen

// EventHubPropertiesGenerator returns a generator of EventHubProperties instances for property testing.
func EventHubPropertiesGenerator() gopter.Gen {
	if eventHubPropertiesGenerator != nil {
		return eventHubPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventHubProperties(generators)
	eventHubPropertiesGenerator = gen.Struct(reflect.TypeOf(EventHubProperties{}), generators)

	return eventHubPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForEventHubProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventHubProperties(gens map[string]gopter.Gen) {
	gens["PartitionCount"] = gen.PtrOf(gen.Int())
	gens["RetentionTimeInDays"] = gen.PtrOf(gen.Int())
}

func Test_EventHubProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EventHubProperties_STATUS to EventHubProperties_STATUS via AssignProperties_To_EventHubProperties_STATUS & AssignProperties_From_EventHubProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventHubProperties_STATUS, EventHubProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventHubProperties_STATUS tests if a specific instance of EventHubProperties_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForEventHubProperties_STATUS(subject EventHubProperties_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.EventHubProperties_STATUS
	err := copied.AssignProperties_To_EventHubProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EventHubProperties_STATUS
	err = actual.AssignProperties_From_EventHubProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventHubProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventHubProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventHubProperties_STATUS, EventHubProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventHubProperties_STATUS runs a test to see if a specific instance of EventHubProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEventHubProperties_STATUS(subject EventHubProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventHubProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventHubProperties_STATUS instances for property testing - lazily instantiated by
// EventHubProperties_STATUSGenerator()
var eventHubProperties_STATUSGenerator gopter.Gen

// EventHubProperties_STATUSGenerator returns a generator of EventHubProperties_STATUS instances for property testing.
func EventHubProperties_STATUSGenerator() gopter.Gen {
	if eventHubProperties_STATUSGenerator != nil {
		return eventHubProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventHubProperties_STATUS(generators)
	eventHubProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(EventHubProperties_STATUS{}), generators)

	return eventHubProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForEventHubProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventHubProperties_STATUS(gens map[string]gopter.Gen) {
	gens["Endpoint"] = gen.PtrOf(gen.AlphaString())
	gens["PartitionCount"] = gen.PtrOf(gen.Int())
	gens["PartitionIds"] = gen.SliceOf(gen.AlphaString())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["RetentionTimeInDays"] = gen.PtrOf(gen.Int())
}

func Test_IotHubLocationDescription_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IotHubLocationDescription_STATUS to IotHubLocationDescription_STATUS via AssignProperties_To_IotHubLocationDescription_STATUS & AssignProperties_From_IotHubLocationDescription_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForIotHubLocationDescription_STATUS, IotHubLocationDescription_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIotHubLocationDescription_STATUS tests if a specific instance of IotHubLocationDescription_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForIotHubLocationDescription_STATUS(subject IotHubLocationDescription_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.IotHubLocationDescription_STATUS
	err := copied.AssignProperties_To_IotHubLocationDescription_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IotHubLocationDescription_STATUS
	err = actual.AssignProperties_From_IotHubLocationDescription_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IotHubLocationDescription_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IotHubLocationDescription_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIotHubLocationDescription_STATUS, IotHubLocationDescription_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIotHubLocationDescription_STATUS runs a test to see if a specific instance of IotHubLocationDescription_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForIotHubLocationDescription_STATUS(subject IotHubLocationDescription_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IotHubLocationDescription_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IotHubLocationDescription_STATUS instances for property testing - lazily instantiated by
// IotHubLocationDescription_STATUSGenerator()
var iotHubLocationDescription_STATUSGenerator gopter.Gen

// IotHubLocationDescription_STATUSGenerator returns a generator of IotHubLocationDescription_STATUS instances for property testing.
func IotHubLocationDescription_STATUSGenerator() gopter.Gen {
	if iotHubLocationDescription_STATUSGenerator != nil {
		return iotHubLocationDescription_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIotHubLocationDescription_STATUS(generators)
	iotHubLocationDescription_STATUSGenerator = gen.Struct(reflect.TypeOf(IotHubLocationDescription_STATUS{}), generators)

	return iotHubLocationDescription_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForIotHubLocationDescription_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIotHubLocationDescription_STATUS(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Role"] = gen.PtrOf(gen.OneConstOf(IotHubLocationDescription_Role_STATUS_Primary, IotHubLocationDescription_Role_STATUS_Secondary))
}

func Test_IotHubOperatorSecrets_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IotHubOperatorSecrets to IotHubOperatorSecrets via AssignProperties_To_IotHubOperatorSecrets & AssignProperties_From_IotHubOperatorSecrets returns original",
		prop.ForAll(RunPropertyAssignmentTestForIotHubOperatorSecrets, IotHubOperatorSecretsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIotHubOperatorSecrets tests if a specific instance of IotHubOperatorSecrets can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForIotHubOperatorSecrets(subject IotHubOperatorSecrets) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.IotHubOperatorSecrets
	err := copied.AssignProperties_To_IotHubOperatorSecrets(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IotHubOperatorSecrets
	err = actual.AssignProperties_From_IotHubOperatorSecrets(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IotHubOperatorSecrets_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IotHubOperatorSecrets via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIotHubOperatorSecrets, IotHubOperatorSecretsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIotHubOperatorSecrets runs a test to see if a specific instance of IotHubOperatorSecrets round trips to JSON and back losslessly
func RunJSONSerializationTestForIotHubOperatorSecrets(subject IotHubOperatorSecrets) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IotHubOperatorSecrets
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IotHubOperatorSecrets instances for property testing - lazily instantiated by
// IotHubOperatorSecretsGenerator()
var iotHubOperatorSecretsGenerator gopter.Gen

// IotHubOperatorSecretsGenerator returns a generator of IotHubOperatorSecrets instances for property testing.
func IotHubOperatorSecretsGenerator() gopter.Gen {
	if iotHubOperatorSecretsGenerator != nil {
		return iotHubOperatorSecretsGenerator
	}

	generators := make(map[string]gopter.Gen)
	iotHubOperatorSecretsGenerator = gen.Struct(reflect.TypeOf(IotHubOperatorSecrets{}), generators)

	return iotHubOperatorSecretsGenerator
}

func Test_IpFilterRule_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IpFilterRule to IpFilterRule via AssignProperties_To_IpFilterRule & AssignProperties_From_IpFilterRule returns original",
		prop.ForAll(RunPropertyAssignmentTestForIpFilterRule, IpFilterRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIpFilterRule tests if a specific instance of IpFilterRule can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForIpFilterRule(subject IpFilterRule) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.IpFilterRule
	err := copied.AssignProperties_To_IpFilterRule(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IpFilterRule
	err = actual.AssignProperties_From_IpFilterRule(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IpFilterRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpFilterRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpFilterRule, IpFilterRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpFilterRule runs a test to see if a specific instance of IpFilterRule round trips to JSON and back losslessly
func RunJSONSerializationTestForIpFilterRule(subject IpFilterRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpFilterRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpFilterRule instances for property testing - lazily instantiated by IpFilterRuleGenerator()
var ipFilterRuleGenerator gopter.Gen

// IpFilterRuleGenerator returns a generator of IpFilterRule instances for property testing.
func IpFilterRuleGenerator() gopter.Gen {
	if ipFilterRuleGenerator != nil {
		return ipFilterRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpFilterRule(generators)
	ipFilterRuleGenerator = gen.Struct(reflect.TypeOf(IpFilterRule{}), generators)

	return ipFilterRuleGenerator
}

// AddIndependentPropertyGeneratorsForIpFilterRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpFilterRule(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(IpFilterRule_Action_Accept, IpFilterRule_Action_Reject))
	gens["FilterName"] = gen.PtrOf(gen.AlphaString())
	gens["IpMask"] = gen.PtrOf(gen.AlphaString())
}

func Test_IpFilterRule_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IpFilterRule_STATUS to IpFilterRule_STATUS via AssignProperties_To_IpFilterRule_STATUS & AssignProperties_From_IpFilterRule_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForIpFilterRule_STATUS, IpFilterRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIpFilterRule_STATUS tests if a specific instance of IpFilterRule_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForIpFilterRule_STATUS(subject IpFilterRule_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.IpFilterRule_STATUS
	err := copied.AssignProperties_To_IpFilterRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IpFilterRule_STATUS
	err = actual.AssignProperties_From_IpFilterRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IpFilterRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpFilterRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpFilterRule_STATUS, IpFilterRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpFilterRule_STATUS runs a test to see if a specific instance of IpFilterRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForIpFilterRule_STATUS(subject IpFilterRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpFilterRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpFilterRule_STATUS instances for property testing - lazily instantiated by
// IpFilterRule_STATUSGenerator()
var ipFilterRule_STATUSGenerator gopter.Gen

// IpFilterRule_STATUSGenerator returns a generator of IpFilterRule_STATUS instances for property testing.
func IpFilterRule_STATUSGenerator() gopter.Gen {
	if ipFilterRule_STATUSGenerator != nil {
		return ipFilterRule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpFilterRule_STATUS(generators)
	ipFilterRule_STATUSGenerator = gen.Struct(reflect.TypeOf(IpFilterRule_STATUS{}), generators)

	return ipFilterRule_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForIpFilterRule_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpFilterRule_STATUS(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(IpFilterRule_Action_STATUS_Accept, IpFilterRule_Action_STATUS_Reject))
	gens["FilterName"] = gen.PtrOf(gen.AlphaString())
	gens["IpMask"] = gen.PtrOf(gen.AlphaString())
}

func Test_MessagingEndpointProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MessagingEndpointProperties to MessagingEndpointProperties via AssignProperties_To_MessagingEndpointProperties & AssignProperties_From_MessagingEndpointProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForMessagingEndpointProperties, MessagingEndpointPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMessagingEndpointProperties tests if a specific instance of MessagingEndpointProperties can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForMessagingEndpointProperties(subject MessagingEndpointProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.MessagingEndpointProperties
	err := copied.AssignProperties_To_MessagingEndpointProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual MessagingEndpointProperties
	err = actual.AssignProperties_From_MessagingEndpointProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MessagingEndpointProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MessagingEndpointProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMessagingEndpointProperties, MessagingEndpointPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMessagingEndpointProperties runs a test to see if a specific instance of MessagingEndpointProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForMessagingEndpointProperties(subject MessagingEndpointProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MessagingEndpointProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MessagingEndpointProperties instances for property testing - lazily instantiated by
// MessagingEndpointPropertiesGenerator()
var messagingEndpointPropertiesGenerator gopter.Gen

// MessagingEndpointPropertiesGenerator returns a generator of MessagingEndpointProperties instances for property testing.
func MessagingEndpointPropertiesGenerator() gopter.Gen {
	if messagingEndpointPropertiesGenerator != nil {
		return messagingEndpointPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMessagingEndpointProperties(generators)
	messagingEndpointPropertiesGenerator = gen.Struct(reflect.TypeOf(MessagingEndpointProperties{}), generators)

	return messagingEndpointPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForMessagingEndpointProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMessagingEndpointProperties(gens map[string]gopter.Gen) {
	gens["LockDurationAsIso8601"] = gen.PtrOf(gen.AlphaString())
	gens["MaxDeliveryCount"] = gen.PtrOf(gen.Int())
	gens["TtlAsIso8601"] = gen.PtrOf(gen.AlphaString())
}

func Test_MessagingEndpointProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MessagingEndpointProperties_STATUS to MessagingEndpointProperties_STATUS via AssignProperties_To_MessagingEndpointProperties_STATUS & AssignProperties_From_MessagingEndpointProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForMessagingEndpointProperties_STATUS, MessagingEndpointProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMessagingEndpointProperties_STATUS tests if a specific instance of MessagingEndpointProperties_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForMessagingEndpointProperties_STATUS(subject MessagingEndpointProperties_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.MessagingEndpointProperties_STATUS
	err := copied.AssignProperties_To_MessagingEndpointProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual MessagingEndpointProperties_STATUS
	err = actual.AssignProperties_From_MessagingEndpointProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MessagingEndpointProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MessagingEndpointProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMessagingEndpointProperties_STATUS, MessagingEndpointProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMessagingEndpointProperties_STATUS runs a test to see if a specific instance of MessagingEndpointProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForMessagingEndpointProperties_STATUS(subject MessagingEndpointProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MessagingEndpointProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MessagingEndpointProperties_STATUS instances for property testing - lazily instantiated by
// MessagingEndpointProperties_STATUSGenerator()
var messagingEndpointProperties_STATUSGenerator gopter.Gen

// MessagingEndpointProperties_STATUSGenerator returns a generator of MessagingEndpointProperties_STATUS instances for property testing.
func MessagingEndpointProperties_STATUSGenerator() gopter.Gen {
	if messagingEndpointProperties_STATUSGenerator != nil {
		return messagingEndpointProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMessagingEndpointProperties_STATUS(generators)
	messagingEndpointProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(MessagingEndpointProperties_STATUS{}), generators)

	return messagingEndpointProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForMessagingEndpointProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMessagingEndpointProperties_STATUS(gens map[string]gopter.Gen) {
	gens["LockDurationAsIso8601"] = gen.PtrOf(gen.AlphaString())
	gens["MaxDeliveryCount"] = gen.PtrOf(gen.Int())
	gens["TtlAsIso8601"] = gen.PtrOf(gen.AlphaString())
}

func Test_NetworkRuleSetProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NetworkRuleSetProperties to NetworkRuleSetProperties via AssignProperties_To_NetworkRuleSetProperties & AssignProperties_From_NetworkRuleSetProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForNetworkRuleSetProperties, NetworkRuleSetPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNetworkRuleSetProperties tests if a specific instance of NetworkRuleSetProperties can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForNetworkRuleSetProperties(subject NetworkRuleSetProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.NetworkRuleSetProperties
	err := copied.AssignProperties_To_NetworkRuleSetProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NetworkRuleSetProperties
	err = actual.AssignProperties_From_NetworkRuleSetProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NetworkRuleSetProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkRuleSetProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkRuleSetProperties, NetworkRuleSetPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkRuleSetProperties runs a test to see if a specific instance of NetworkRuleSetProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkRuleSetProperties(subject NetworkRuleSetProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkRuleSetProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkRuleSetProperties instances for property testing - lazily instantiated by
// NetworkRuleSetPropertiesGenerator()
var networkRuleSetPropertiesGenerator gopter.Gen

// NetworkRuleSetPropertiesGenerator returns a generator of NetworkRuleSetProperties instances for property testing.
// We first initialize networkRuleSetPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkRuleSetPropertiesGenerator() gopter.Gen {
	if networkRuleSetPropertiesGenerator != nil {
		return networkRuleSetPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSetProperties(generators)
	networkRuleSetPropertiesGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSetProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSetProperties(generators)
	AddRelatedPropertyGeneratorsForNetworkRuleSetProperties(generators)
	networkRuleSetPropertiesGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSetProperties{}), generators)

	return networkRuleSetPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForNetworkRuleSetProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkRuleSetProperties(gens map[string]gopter.Gen) {
	gens["ApplyToBuiltInEventHubEndpoint"] = gen.PtrOf(gen.Bool())
	gens["DefaultAction"] = gen.PtrOf(gen.OneConstOf(NetworkRuleSetProperties_DefaultAction_Allow, NetworkRuleSetProperties_DefaultAction_Deny))
}

// AddRelatedPropertyGeneratorsForNetworkRuleSetProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkRuleSetProperties(gens map[string]gopter.Gen) {
	gens["IpRules"] = gen.SliceOf(NetworkRuleSetIpRuleGenerator())
}

func Test_NetworkRuleSetProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NetworkRuleSetProperties_STATUS to NetworkRuleSetProperties_STATUS via AssignProperties_To_NetworkRuleSetProperties_STATUS & AssignProperties_From_NetworkRuleSetProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForNetworkRuleSetProperties_STATUS, NetworkRuleSetProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNetworkRuleSetProperties_STATUS tests if a specific instance of NetworkRuleSetProperties_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForNetworkRuleSetProperties_STATUS(subject NetworkRuleSetProperties_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.NetworkRuleSetProperties_STATUS
	err := copied.AssignProperties_To_NetworkRuleSetProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NetworkRuleSetProperties_STATUS
	err = actual.AssignProperties_From_NetworkRuleSetProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NetworkRuleSetProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkRuleSetProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkRuleSetProperties_STATUS, NetworkRuleSetProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkRuleSetProperties_STATUS runs a test to see if a specific instance of NetworkRuleSetProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkRuleSetProperties_STATUS(subject NetworkRuleSetProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkRuleSetProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkRuleSetProperties_STATUS instances for property testing - lazily instantiated by
// NetworkRuleSetProperties_STATUSGenerator()
var networkRuleSetProperties_STATUSGenerator gopter.Gen

// NetworkRuleSetProperties_STATUSGenerator returns a generator of NetworkRuleSetProperties_STATUS instances for property testing.
// We first initialize networkRuleSetProperties_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkRuleSetProperties_STATUSGenerator() gopter.Gen {
	if networkRuleSetProperties_STATUSGenerator != nil {
		return networkRuleSetProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSetProperties_STATUS(generators)
	networkRuleSetProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSetProperties_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSetProperties_STATUS(generators)
	AddRelatedPropertyGeneratorsForNetworkRuleSetProperties_STATUS(generators)
	networkRuleSetProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSetProperties_STATUS{}), generators)

	return networkRuleSetProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForNetworkRuleSetProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkRuleSetProperties_STATUS(gens map[string]gopter.Gen) {
	gens["ApplyToBuiltInEventHubEndpoint"] = gen.PtrOf(gen.Bool())
	gens["DefaultAction"] = gen.PtrOf(gen.OneConstOf(NetworkRuleSetProperties_DefaultAction_STATUS_Allow, NetworkRuleSetProperties_DefaultAction_STATUS_Deny))
}

// AddRelatedPropertyGeneratorsForNetworkRuleSetProperties_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkRuleSetProperties_STATUS(gens map[string]gopter.Gen) {
	gens["IpRules"] = gen.SliceOf(NetworkRuleSetIpRule_STATUSGenerator())
}

func Test_PrivateEndpointConnection_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PrivateEndpointConnection_STATUS to PrivateEndpointConnection_STATUS via AssignProperties_To_PrivateEndpointConnection_STATUS & AssignProperties_From_PrivateEndpointConnection_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForPrivateEndpointConnection_STATUS, PrivateEndpointConnection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPrivateEndpointConnection_STATUS tests if a specific instance of PrivateEndpointConnection_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForPrivateEndpointConnection_STATUS(subject PrivateEndpointConnection_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.PrivateEndpointConnection_STATUS
	err := copied.AssignProperties_To_PrivateEndpointConnection_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PrivateEndpointConnection_STATUS
	err = actual.AssignProperties_From_PrivateEndpointConnection_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PrivateEndpointConnection_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointConnection_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointConnection_STATUS, PrivateEndpointConnection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointConnection_STATUS runs a test to see if a specific instance of PrivateEndpointConnection_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointConnection_STATUS(subject PrivateEndpointConnection_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointConnection_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointConnection_STATUS instances for property testing - lazily instantiated by
// PrivateEndpointConnection_STATUSGenerator()
var privateEndpointConnection_STATUSGenerator gopter.Gen

// PrivateEndpointConnection_STATUSGenerator returns a generator of PrivateEndpointConnection_STATUS instances for property testing.
func PrivateEndpointConnection_STATUSGenerator() gopter.Gen {
	if privateEndpointConnection_STATUSGenerator != nil {
		return privateEndpointConnection_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnection_STATUS(generators)
	privateEndpointConnection_STATUSGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnection_STATUS{}), generators)

	return privateEndpointConnection_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointConnection_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointConnection_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_RoutingProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RoutingProperties to RoutingProperties via AssignProperties_To_RoutingProperties & AssignProperties_From_RoutingProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForRoutingProperties, RoutingPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRoutingProperties tests if a specific instance of RoutingProperties can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForRoutingProperties(subject RoutingProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.RoutingProperties
	err := copied.AssignProperties_To_RoutingProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RoutingProperties
	err = actual.AssignProperties_From_RoutingProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RoutingProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingProperties, RoutingPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingProperties runs a test to see if a specific instance of RoutingProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingProperties(subject RoutingProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingProperties instances for property testing - lazily instantiated by RoutingPropertiesGenerator()
var routingPropertiesGenerator gopter.Gen

// RoutingPropertiesGenerator returns a generator of RoutingProperties instances for property testing.
func RoutingPropertiesGenerator() gopter.Gen {
	if routingPropertiesGenerator != nil {
		return routingPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForRoutingProperties(generators)
	routingPropertiesGenerator = gen.Struct(reflect.TypeOf(RoutingProperties{}), generators)

	return routingPropertiesGenerator
}

// AddRelatedPropertyGeneratorsForRoutingProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRoutingProperties(gens map[string]gopter.Gen) {
	gens["Endpoints"] = gen.PtrOf(RoutingEndpointsGenerator())
	gens["Enrichments"] = gen.SliceOf(EnrichmentPropertiesGenerator())
	gens["FallbackRoute"] = gen.PtrOf(FallbackRoutePropertiesGenerator())
	gens["Routes"] = gen.SliceOf(RoutePropertiesGenerator())
}

func Test_RoutingProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RoutingProperties_STATUS to RoutingProperties_STATUS via AssignProperties_To_RoutingProperties_STATUS & AssignProperties_From_RoutingProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForRoutingProperties_STATUS, RoutingProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRoutingProperties_STATUS tests if a specific instance of RoutingProperties_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForRoutingProperties_STATUS(subject RoutingProperties_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.RoutingProperties_STATUS
	err := copied.AssignProperties_To_RoutingProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RoutingProperties_STATUS
	err = actual.AssignProperties_From_RoutingProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RoutingProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingProperties_STATUS, RoutingProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingProperties_STATUS runs a test to see if a specific instance of RoutingProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingProperties_STATUS(subject RoutingProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingProperties_STATUS instances for property testing - lazily instantiated by
// RoutingProperties_STATUSGenerator()
var routingProperties_STATUSGenerator gopter.Gen

// RoutingProperties_STATUSGenerator returns a generator of RoutingProperties_STATUS instances for property testing.
func RoutingProperties_STATUSGenerator() gopter.Gen {
	if routingProperties_STATUSGenerator != nil {
		return routingProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForRoutingProperties_STATUS(generators)
	routingProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(RoutingProperties_STATUS{}), generators)

	return routingProperties_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForRoutingProperties_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRoutingProperties_STATUS(gens map[string]gopter.Gen) {
	gens["Endpoints"] = gen.PtrOf(RoutingEndpoints_STATUSGenerator())
	gens["Enrichments"] = gen.SliceOf(EnrichmentProperties_STATUSGenerator())
	gens["FallbackRoute"] = gen.PtrOf(FallbackRouteProperties_STATUSGenerator())
	gens["Routes"] = gen.SliceOf(RouteProperties_STATUSGenerator())
}

func Test_SharedAccessSignatureAuthorizationRule_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SharedAccessSignatureAuthorizationRule to SharedAccessSignatureAuthorizationRule via AssignProperties_To_SharedAccessSignatureAuthorizationRule & AssignProperties_From_SharedAccessSignatureAuthorizationRule returns original",
		prop.ForAll(RunPropertyAssignmentTestForSharedAccessSignatureAuthorizationRule, SharedAccessSignatureAuthorizationRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSharedAccessSignatureAuthorizationRule tests if a specific instance of SharedAccessSignatureAuthorizationRule can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSharedAccessSignatureAuthorizationRule(subject SharedAccessSignatureAuthorizationRule) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.SharedAccessSignatureAuthorizationRule
	err := copied.AssignProperties_To_SharedAccessSignatureAuthorizationRule(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SharedAccessSignatureAuthorizationRule
	err = actual.AssignProperties_From_SharedAccessSignatureAuthorizationRule(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SharedAccessSignatureAuthorizationRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SharedAccessSignatureAuthorizationRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSharedAccessSignatureAuthorizationRule, SharedAccessSignatureAuthorizationRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSharedAccessSignatureAuthorizationRule runs a test to see if a specific instance of SharedAccessSignatureAuthorizationRule round trips to JSON and back losslessly
func RunJSONSerializationTestForSharedAccessSignatureAuthorizationRule(subject SharedAccessSignatureAuthorizationRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SharedAccessSignatureAuthorizationRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SharedAccessSignatureAuthorizationRule instances for property testing - lazily instantiated by
// SharedAccessSignatureAuthorizationRuleGenerator()
var sharedAccessSignatureAuthorizationRuleGenerator gopter.Gen

// SharedAccessSignatureAuthorizationRuleGenerator returns a generator of SharedAccessSignatureAuthorizationRule instances for property testing.
func SharedAccessSignatureAuthorizationRuleGenerator() gopter.Gen {
	if sharedAccessSignatureAuthorizationRuleGenerator != nil {
		return sharedAccessSignatureAuthorizationRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSharedAccessSignatureAuthorizationRule(generators)
	sharedAccessSignatureAuthorizationRuleGenerator = gen.Struct(reflect.TypeOf(SharedAccessSignatureAuthorizationRule{}), generators)

	return sharedAccessSignatureAuthorizationRuleGenerator
}

// AddIndependentPropertyGeneratorsForSharedAccessSignatureAuthorizationRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSharedAccessSignatureAuthorizationRule(gens map[string]gopter.Gen) {
	gens["KeyName"] = gen.PtrOf(gen.AlphaString())
	gens["Rights"] = gen.PtrOf(gen.OneConstOf(
		SharedAccessSignatureAuthorizationRule_Rights_DeviceConnect,
		SharedAccessSignatureAuthorizationRule_Rights_RegistryRead,
		SharedAccessSignatureAuthorizationRule_Rights_RegistryReadDeviceConnect,
		SharedAccessSignatureAuthorizationRule_Rights_RegistryReadRegistryWrite,
		SharedAccessSignatureAuthorizationRule_Rights_RegistryReadRegistryWriteDeviceConnect,
		SharedAccessSignatureAuthorizationRule_Rights_RegistryReadRegistryWriteServiceConnect,
		SharedAccessSignatureAuthorizationRule_Rights_RegistryReadRegistryWriteServiceConnectDeviceConnect,
		SharedAccessSignatureAuthorizationRule_Rights_RegistryReadServiceConnect,
		SharedAccessSignatureAuthorizationRule_Rights_RegistryReadServiceConnectDeviceConnect,
		SharedAccessSignatureAuthorizationRule_Rights_RegistryWrite,
		SharedAccessSignatureAuthorizationRule_Rights_RegistryWriteDeviceConnect,
		SharedAccessSignatureAuthorizationRule_Rights_RegistryWriteServiceConnect,
		SharedAccessSignatureAuthorizationRule_Rights_RegistryWriteServiceConnectDeviceConnect,
		SharedAccessSignatureAuthorizationRule_Rights_ServiceConnect,
		SharedAccessSignatureAuthorizationRule_Rights_ServiceConnectDeviceConnect))
}

func Test_SharedAccessSignatureAuthorizationRule_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SharedAccessSignatureAuthorizationRule_STATUS to SharedAccessSignatureAuthorizationRule_STATUS via AssignProperties_To_SharedAccessSignatureAuthorizationRule_STATUS & AssignProperties_From_SharedAccessSignatureAuthorizationRule_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSharedAccessSignatureAuthorizationRule_STATUS, SharedAccessSignatureAuthorizationRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSharedAccessSignatureAuthorizationRule_STATUS tests if a specific instance of SharedAccessSignatureAuthorizationRule_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSharedAccessSignatureAuthorizationRule_STATUS(subject SharedAccessSignatureAuthorizationRule_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.SharedAccessSignatureAuthorizationRule_STATUS
	err := copied.AssignProperties_To_SharedAccessSignatureAuthorizationRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SharedAccessSignatureAuthorizationRule_STATUS
	err = actual.AssignProperties_From_SharedAccessSignatureAuthorizationRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SharedAccessSignatureAuthorizationRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SharedAccessSignatureAuthorizationRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSharedAccessSignatureAuthorizationRule_STATUS, SharedAccessSignatureAuthorizationRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSharedAccessSignatureAuthorizationRule_STATUS runs a test to see if a specific instance of SharedAccessSignatureAuthorizationRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSharedAccessSignatureAuthorizationRule_STATUS(subject SharedAccessSignatureAuthorizationRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SharedAccessSignatureAuthorizationRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SharedAccessSignatureAuthorizationRule_STATUS instances for property testing - lazily instantiated by
// SharedAccessSignatureAuthorizationRule_STATUSGenerator()
var sharedAccessSignatureAuthorizationRule_STATUSGenerator gopter.Gen

// SharedAccessSignatureAuthorizationRule_STATUSGenerator returns a generator of SharedAccessSignatureAuthorizationRule_STATUS instances for property testing.
func SharedAccessSignatureAuthorizationRule_STATUSGenerator() gopter.Gen {
	if sharedAccessSignatureAuthorizationRule_STATUSGenerator != nil {
		return sharedAccessSignatureAuthorizationRule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSharedAccessSignatureAuthorizationRule_STATUS(generators)
	sharedAccessSignatureAuthorizationRule_STATUSGenerator = gen.Struct(reflect.TypeOf(SharedAccessSignatureAuthorizationRule_STATUS{}), generators)

	return sharedAccessSignatureAuthorizationRule_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSharedAccessSignatureAuthorizationRule_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSharedAccessSignatureAuthorizationRule_STATUS(gens map[string]gopter.Gen) {
	gens["KeyName"] = gen.PtrOf(gen.AlphaString())
	gens["Rights"] = gen.PtrOf(gen.OneConstOf(
		SharedAccessSignatureAuthorizationRule_Rights_STATUS_DeviceConnect,
		SharedAccessSignatureAuthorizationRule_Rights_STATUS_RegistryRead,
		SharedAccessSignatureAuthorizationRule_Rights_STATUS_RegistryReadDeviceConnect,
		SharedAccessSignatureAuthorizationRule_Rights_STATUS_RegistryReadRegistryWrite,
		SharedAccessSignatureAuthorizationRule_Rights_STATUS_RegistryReadRegistryWriteDeviceConnect,
		SharedAccessSignatureAuthorizationRule_Rights_STATUS_RegistryReadRegistryWriteServiceConnect,
		SharedAccessSignatureAuthorizationRule_Rights_STATUS_RegistryReadRegistryWriteServiceConnectDeviceConnect,
		SharedAccessSignatureAuthorizationRule_Rights_STATUS_RegistryReadServiceConnect,
		SharedAccessSignatureAuthorizationRule_Rights_STATUS_RegistryReadServiceConnectDeviceConnect,
		SharedAccessSignatureAuthorizationRule_Rights_STATUS_RegistryWrite,
		SharedAccessSignatureAuthorizationRule_Rights_STATUS_RegistryWriteDeviceConnect,
		SharedAccessSignatureAuthorizationRule_Rights_STATUS_RegistryWriteServiceConnect,
		SharedAccessSignatureAuthorizationRule_Rights_STATUS_RegistryWriteServiceConnectDeviceConnect,
		SharedAccessSignatureAuthorizationRule_Rights_STATUS_ServiceConnect,
		SharedAccessSignatureAuthorizationRule_Rights_STATUS_ServiceConnectDeviceConnect))
}

func Test_StorageEndpointProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from StorageEndpointProperties to StorageEndpointProperties via AssignProperties_To_StorageEndpointProperties & AssignProperties_From_StorageEndpointProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForStorageEndpointProperties, StorageEndpointPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForStorageEndpointProperties tests if a specific instance of StorageEndpointProperties can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForStorageEndpointProperties(subject StorageEndpointProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.StorageEndpointProperties
	err := copied.AssignProperties_To_StorageEndpointProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual StorageEndpointProperties
	err = actual.AssignProperties_From_StorageEndpointProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_StorageEndpointProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageEndpointProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageEndpointProperties, StorageEndpointPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageEndpointProperties runs a test to see if a specific instance of StorageEndpointProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageEndpointProperties(subject StorageEndpointProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageEndpointProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageEndpointProperties instances for property testing - lazily instantiated by
// StorageEndpointPropertiesGenerator()
var storageEndpointPropertiesGenerator gopter.Gen

// StorageEndpointPropertiesGenerator returns a generator of StorageEndpointProperties instances for property testing.
// We first initialize storageEndpointPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func StorageEndpointPropertiesGenerator() gopter.Gen {
	if storageEndpointPropertiesGenerator != nil {
		return storageEndpointPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageEndpointProperties(generators)
	storageEndpointPropertiesGenerator = gen.Struct(reflect.TypeOf(StorageEndpointProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageEndpointProperties(generators)
	AddRelatedPropertyGeneratorsForStorageEndpointProperties(generators)
	storageEndpointPropertiesGenerator = gen.Struct(reflect.TypeOf(StorageEndpointProperties{}), generators)

	return storageEndpointPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForStorageEndpointProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageEndpointProperties(gens map[string]gopter.Gen) {
	gens["AuthenticationType"] = gen.PtrOf(gen.OneConstOf(StorageEndpointProperties_AuthenticationType_IdentityBased, StorageEndpointProperties_AuthenticationType_KeyBased))
	gens["ContainerName"] = gen.PtrOf(gen.AlphaString())
	gens["SasTtlAsIso8601"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForStorageEndpointProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageEndpointProperties(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedIdentityGenerator())
}

func Test_StorageEndpointProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from StorageEndpointProperties_STATUS to StorageEndpointProperties_STATUS via AssignProperties_To_StorageEndpointProperties_STATUS & AssignProperties_From_StorageEndpointProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForStorageEndpointProperties_STATUS, StorageEndpointProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForStorageEndpointProperties_STATUS tests if a specific instance of StorageEndpointProperties_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForStorageEndpointProperties_STATUS(subject StorageEndpointProperties_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.StorageEndpointProperties_STATUS
	err := copied.AssignProperties_To_StorageEndpointProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual StorageEndpointProperties_STATUS
	err = actual.AssignProperties_From_StorageEndpointProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_StorageEndpointProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageEndpointProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageEndpointProperties_STATUS, StorageEndpointProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageEndpointProperties_STATUS runs a test to see if a specific instance of StorageEndpointProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageEndpointProperties_STATUS(subject StorageEndpointProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageEndpointProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageEndpointProperties_STATUS instances for property testing - lazily instantiated by
// StorageEndpointProperties_STATUSGenerator()
var storageEndpointProperties_STATUSGenerator gopter.Gen

// StorageEndpointProperties_STATUSGenerator returns a generator of StorageEndpointProperties_STATUS instances for property testing.
// We first initialize storageEndpointProperties_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func StorageEndpointProperties_STATUSGenerator() gopter.Gen {
	if storageEndpointProperties_STATUSGenerator != nil {
		return storageEndpointProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageEndpointProperties_STATUS(generators)
	storageEndpointProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(StorageEndpointProperties_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageEndpointProperties_STATUS(generators)
	AddRelatedPropertyGeneratorsForStorageEndpointProperties_STATUS(generators)
	storageEndpointProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(StorageEndpointProperties_STATUS{}), generators)

	return storageEndpointProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForStorageEndpointProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageEndpointProperties_STATUS(gens map[string]gopter.Gen) {
	gens["AuthenticationType"] = gen.PtrOf(gen.OneConstOf(StorageEndpointProperties_AuthenticationType_STATUS_IdentityBased, StorageEndpointProperties_AuthenticationType_STATUS_KeyBased))
	gens["ContainerName"] = gen.PtrOf(gen.AlphaString())
	gens["SasTtlAsIso8601"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForStorageEndpointProperties_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageEndpointProperties_STATUS(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedIdentity_STATUSGenerator())
}

func Test_UserAssignedIdentityDetails_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UserAssignedIdentityDetails to UserAssignedIdentityDetails via AssignProperties_To_UserAssignedIdentityDetails & AssignProperties_From_UserAssignedIdentityDetails returns original",
		prop.ForAll(RunPropertyAssignmentTestForUserAssignedIdentityDetails, UserAssignedIdentityDetailsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUserAssignedIdentityDetails tests if a specific instance of UserAssignedIdentityDetails can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForUserAssignedIdentityDetails(subject UserAssignedIdentityDetails) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.UserAssignedIdentityDetails
	err := copied.AssignProperties_To_UserAssignedIdentityDetails(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UserAssignedIdentityDetails
	err = actual.AssignProperties_From_UserAssignedIdentityDetails(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UserAssignedIdentityDetails_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentityDetails via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentityDetails, UserAssignedIdentityDetailsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentityDetails runs a test to see if a specific instance of UserAssignedIdentityDetails round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentityDetails(subject UserAssignedIdentityDetails) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentityDetails
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentityDetails instances for property testing - lazily instantiated by
// UserAssignedIdentityDetailsGenerator()
var userAssignedIdentityDetailsGenerator gopter.Gen

// UserAssignedIdentityDetailsGenerator returns a generator of UserAssignedIdentityDetails instances for property testing.
func UserAssignedIdentityDetailsGenerator() gopter.Gen {
	if userAssignedIdentityDetailsGenerator != nil {
		return userAssignedIdentityDetailsGenerator
	}

	generators := make(map[string]gopter.Gen)
	userAssignedIdentityDetailsGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentityDetails{}), generators)

	return userAssignedIdentityDetailsGenerator
}

func Test_EnrichmentProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EnrichmentProperties to EnrichmentProperties via AssignProperties_To_EnrichmentProperties & AssignProperties_From_EnrichmentProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForEnrichmentProperties, EnrichmentPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEnrichmentProperties tests if a specific instance of EnrichmentProperties can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForEnrichmentProperties(subject EnrichmentProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.EnrichmentProperties
	err := copied.AssignProperties_To_EnrichmentProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EnrichmentProperties
	err = actual.AssignProperties_From_EnrichmentProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EnrichmentProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EnrichmentProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEnrichmentProperties, EnrichmentPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEnrichmentProperties runs a test to see if a specific instance of EnrichmentProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForEnrichmentProperties(subject EnrichmentProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EnrichmentProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EnrichmentProperties instances for property testing - lazily instantiated by
// EnrichmentPropertiesGenerator()
var enrichmentPropertiesGenerator gopter.Gen

// EnrichmentPropertiesGenerator returns a generator of EnrichmentProperties instances for property testing.
func EnrichmentPropertiesGenerator() gopter.Gen {
	if enrichmentPropertiesGenerator != nil {
		return enrichmentPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEnrichmentProperties(generators)
	enrichmentPropertiesGenerator = gen.Struct(reflect.TypeOf(EnrichmentProperties{}), generators)

	return enrichmentPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForEnrichmentProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEnrichmentProperties(gens map[string]gopter.Gen) {
	gens["EndpointNames"] = gen.SliceOf(gen.AlphaString())
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_EnrichmentProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EnrichmentProperties_STATUS to EnrichmentProperties_STATUS via AssignProperties_To_EnrichmentProperties_STATUS & AssignProperties_From_EnrichmentProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForEnrichmentProperties_STATUS, EnrichmentProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEnrichmentProperties_STATUS tests if a specific instance of EnrichmentProperties_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForEnrichmentProperties_STATUS(subject EnrichmentProperties_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.EnrichmentProperties_STATUS
	err := copied.AssignProperties_To_EnrichmentProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EnrichmentProperties_STATUS
	err = actual.AssignProperties_From_EnrichmentProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EnrichmentProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EnrichmentProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEnrichmentProperties_STATUS, EnrichmentProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEnrichmentProperties_STATUS runs a test to see if a specific instance of EnrichmentProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEnrichmentProperties_STATUS(subject EnrichmentProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EnrichmentProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EnrichmentProperties_STATUS instances for property testing - lazily instantiated by
// EnrichmentProperties_STATUSGenerator()
var enrichmentProperties_STATUSGenerator gopter.Gen

// EnrichmentProperties_STATUSGenerator returns a generator of EnrichmentProperties_STATUS instances for property testing.
func EnrichmentProperties_STATUSGenerator() gopter.Gen {
	if enrichmentProperties_STATUSGenerator != nil {
		return enrichmentProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEnrichmentProperties_STATUS(generators)
	enrichmentProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(EnrichmentProperties_STATUS{}), generators)

	return enrichmentProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForEnrichmentProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEnrichmentProperties_STATUS(gens map[string]gopter.Gen) {
	gens["EndpointNames"] = gen.SliceOf(gen.AlphaString())
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_FallbackRouteProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FallbackRouteProperties to FallbackRouteProperties via AssignProperties_To_FallbackRouteProperties & AssignProperties_From_FallbackRouteProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForFallbackRouteProperties, FallbackRoutePropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFallbackRouteProperties tests if a specific instance of FallbackRouteProperties can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFallbackRouteProperties(subject FallbackRouteProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FallbackRouteProperties
	err := copied.AssignProperties_To_FallbackRouteProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FallbackRouteProperties
	err = actual.AssignProperties_From_FallbackRouteProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FallbackRouteProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FallbackRouteProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFallbackRouteProperties, FallbackRoutePropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFallbackRouteProperties runs a test to see if a specific instance of FallbackRouteProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForFallbackRouteProperties(subject FallbackRouteProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FallbackRouteProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FallbackRouteProperties instances for property testing - lazily instantiated by
// FallbackRoutePropertiesGenerator()
var fallbackRoutePropertiesGenerator gopter.Gen

// FallbackRoutePropertiesGenerator returns a generator of FallbackRouteProperties instances for property testing.
func FallbackRoutePropertiesGenerator() gopter.Gen {
	if fallbackRoutePropertiesGenerator != nil {
		return fallbackRoutePropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFallbackRouteProperties(generators)
	fallbackRoutePropertiesGenerator = gen.Struct(reflect.TypeOf(FallbackRouteProperties{}), generators)

	return fallbackRoutePropertiesGenerator
}

// AddIndependentPropertyGeneratorsForFallbackRouteProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFallbackRouteProperties(gens map[string]gopter.Gen) {
	gens["Condition"] = gen.PtrOf(gen.AlphaString())
	gens["EndpointNames"] = gen.SliceOf(gen.AlphaString())
	gens["IsEnabled"] = gen.PtrOf(gen.Bool())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Source"] = gen.PtrOf(gen.OneConstOf(FallbackRouteProperties_Source_DeviceMessages))
}

func Test_FallbackRouteProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FallbackRouteProperties_STATUS to FallbackRouteProperties_STATUS via AssignProperties_To_FallbackRouteProperties_STATUS & AssignProperties_From_FallbackRouteProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForFallbackRouteProperties_STATUS, FallbackRouteProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFallbackRouteProperties_STATUS tests if a specific instance of FallbackRouteProperties_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFallbackRouteProperties_STATUS(subject FallbackRouteProperties_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FallbackRouteProperties_STATUS
	err := copied.AssignProperties_To_FallbackRouteProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FallbackRouteProperties_STATUS
	err = actual.AssignProperties_From_FallbackRouteProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FallbackRouteProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FallbackRouteProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFallbackRouteProperties_STATUS, FallbackRouteProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFallbackRouteProperties_STATUS runs a test to see if a specific instance of FallbackRouteProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFallbackRouteProperties_STATUS(subject FallbackRouteProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FallbackRouteProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FallbackRouteProperties_STATUS instances for property testing - lazily instantiated by
// FallbackRouteProperties_STATUSGenerator()
var fallbackRouteProperties_STATUSGenerator gopter.Gen

// FallbackRouteProperties_STATUSGenerator returns a generator of FallbackRouteProperties_STATUS instances for property testing.
func FallbackRouteProperties_STATUSGenerator() gopter.Gen {
	if fallbackRouteProperties_STATUSGenerator != nil {
		return fallbackRouteProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFallbackRouteProperties_STATUS(generators)
	fallbackRouteProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(FallbackRouteProperties_STATUS{}), generators)

	return fallbackRouteProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFallbackRouteProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFallbackRouteProperties_STATUS(gens map[string]gopter.Gen) {
	gens["Condition"] = gen.PtrOf(gen.AlphaString())
	gens["EndpointNames"] = gen.SliceOf(gen.AlphaString())
	gens["IsEnabled"] = gen.PtrOf(gen.Bool())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Source"] = gen.PtrOf(gen.OneConstOf(FallbackRouteProperties_Source_STATUS_DeviceMessages))
}

func Test_FeedbackProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FeedbackProperties to FeedbackProperties via AssignProperties_To_FeedbackProperties & AssignProperties_From_FeedbackProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForFeedbackProperties, FeedbackPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFeedbackProperties tests if a specific instance of FeedbackProperties can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFeedbackProperties(subject FeedbackProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FeedbackProperties
	err := copied.AssignProperties_To_FeedbackProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FeedbackProperties
	err = actual.AssignProperties_From_FeedbackProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FeedbackProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FeedbackProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFeedbackProperties, FeedbackPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFeedbackProperties runs a test to see if a specific instance of FeedbackProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForFeedbackProperties(subject FeedbackProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FeedbackProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FeedbackProperties instances for property testing - lazily instantiated by FeedbackPropertiesGenerator()
var feedbackPropertiesGenerator gopter.Gen

// FeedbackPropertiesGenerator returns a generator of FeedbackProperties instances for property testing.
func FeedbackPropertiesGenerator() gopter.Gen {
	if feedbackPropertiesGenerator != nil {
		return feedbackPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFeedbackProperties(generators)
	feedbackPropertiesGenerator = gen.Struct(reflect.TypeOf(FeedbackProperties{}), generators)

	return feedbackPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForFeedbackProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFeedbackProperties(gens map[string]gopter.Gen) {
	gens["LockDurationAsIso8601"] = gen.PtrOf(gen.AlphaString())
	gens["MaxDeliveryCount"] = gen.PtrOf(gen.Int())
	gens["TtlAsIso8601"] = gen.PtrOf(gen.AlphaString())
}

func Test_FeedbackProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FeedbackProperties_STATUS to FeedbackProperties_STATUS via AssignProperties_To_FeedbackProperties_STATUS & AssignProperties_From_FeedbackProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForFeedbackProperties_STATUS, FeedbackProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFeedbackProperties_STATUS tests if a specific instance of FeedbackProperties_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFeedbackProperties_STATUS(subject FeedbackProperties_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FeedbackProperties_STATUS
	err := copied.AssignProperties_To_FeedbackProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FeedbackProperties_STATUS
	err = actual.AssignProperties_From_FeedbackProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FeedbackProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FeedbackProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFeedbackProperties_STATUS, FeedbackProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFeedbackProperties_STATUS runs a test to see if a specific instance of FeedbackProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFeedbackProperties_STATUS(subject FeedbackProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FeedbackProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FeedbackProperties_STATUS instances for property testing - lazily instantiated by
// FeedbackProperties_STATUSGenerator()
var feedbackProperties_STATUSGenerator gopter.Gen

// FeedbackProperties_STATUSGenerator returns a generator of FeedbackProperties_STATUS instances for property testing.
func FeedbackProperties_STATUSGenerator() gopter.Gen {
	if feedbackProperties_STATUSGenerator != nil {
		return feedbackProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFeedbackProperties_STATUS(generators)
	feedbackProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(FeedbackProperties_STATUS{}), generators)

	return feedbackProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFeedbackProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFeedbackProperties_STATUS(gens map[string]gopter.Gen) {
	gens["LockDurationAsIso8601"] = gen.PtrOf(gen.AlphaString())
	gens["MaxDeliveryCount"] = gen.PtrOf(gen.Int())
	gens["TtlAsIso8601"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedIdentity_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedIdentity to ManagedIdentity via AssignProperties_To_ManagedIdentity & AssignProperties_From_ManagedIdentity returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedIdentity, ManagedIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedIdentity tests if a specific instance of ManagedIdentity can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedIdentity(subject ManagedIdentity) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ManagedIdentity
	err := copied.AssignProperties_To_ManagedIdentity(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedIdentity
	err = actual.AssignProperties_From_ManagedIdentity(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedIdentity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedIdentity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedIdentity, ManagedIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedIdentity runs a test to see if a specific instance of ManagedIdentity round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedIdentity(subject ManagedIdentity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedIdentity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedIdentity instances for property testing - lazily instantiated by ManagedIdentityGenerator()
var managedIdentityGenerator gopter.Gen

// ManagedIdentityGenerator returns a generator of ManagedIdentity instances for property testing.
func ManagedIdentityGenerator() gopter.Gen {
	if managedIdentityGenerator != nil {
		return managedIdentityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedIdentity(generators)
	managedIdentityGenerator = gen.Struct(reflect.TypeOf(ManagedIdentity{}), generators)

	return managedIdentityGenerator
}

// AddIndependentPropertyGeneratorsForManagedIdentity is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedIdentity(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentity"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedIdentity_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedIdentity_STATUS to ManagedIdentity_STATUS via AssignProperties_To_ManagedIdentity_STATUS & AssignProperties_From_ManagedIdentity_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedIdentity_STATUS, ManagedIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedIdentity_STATUS tests if a specific instance of ManagedIdentity_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedIdentity_STATUS(subject ManagedIdentity_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ManagedIdentity_STATUS
	err := copied.AssignProperties_To_ManagedIdentity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedIdentity_STATUS
	err = actual.AssignProperties_From_ManagedIdentity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedIdentity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedIdentity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedIdentity_STATUS, ManagedIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedIdentity_STATUS runs a test to see if a specific instance of ManagedIdentity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedIdentity_STATUS(subject ManagedIdentity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedIdentity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedIdentity_STATUS instances for property testing - lazily instantiated by
// ManagedIdentity_STATUSGenerator()
var managedIdentity_STATUSGenerator gopter.Gen

// ManagedIdentity_STATUSGenerator returns a generator of ManagedIdentity_STATUS instances for property testing.
func ManagedIdentity_STATUSGenerator() gopter.Gen {
	if managedIdentity_STATUSGenerator != nil {
		return managedIdentity_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedIdentity_STATUS(generators)
	managedIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedIdentity_STATUS{}), generators)

	return managedIdentity_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForManagedIdentity_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentity"] = gen.PtrOf(gen.AlphaString())
}

func Test_NetworkRuleSetIpRule_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NetworkRuleSetIpRule to NetworkRuleSetIpRule via AssignProperties_To_NetworkRuleSetIpRule & AssignProperties_From_NetworkRuleSetIpRule returns original",
		prop.ForAll(RunPropertyAssignmentTestForNetworkRuleSetIpRule, NetworkRuleSetIpRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNetworkRuleSetIpRule tests if a specific instance of NetworkRuleSetIpRule can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForNetworkRuleSetIpRule(subject NetworkRuleSetIpRule) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.NetworkRuleSetIpRule
	err := copied.AssignProperties_To_NetworkRuleSetIpRule(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NetworkRuleSetIpRule
	err = actual.AssignProperties_From_NetworkRuleSetIpRule(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NetworkRuleSetIpRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkRuleSetIpRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkRuleSetIpRule, NetworkRuleSetIpRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkRuleSetIpRule runs a test to see if a specific instance of NetworkRuleSetIpRule round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkRuleSetIpRule(subject NetworkRuleSetIpRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkRuleSetIpRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkRuleSetIpRule instances for property testing - lazily instantiated by
// NetworkRuleSetIpRuleGenerator()
var networkRuleSetIpRuleGenerator gopter.Gen

// NetworkRuleSetIpRuleGenerator returns a generator of NetworkRuleSetIpRule instances for property testing.
func NetworkRuleSetIpRuleGenerator() gopter.Gen {
	if networkRuleSetIpRuleGenerator != nil {
		return networkRuleSetIpRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSetIpRule(generators)
	networkRuleSetIpRuleGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSetIpRule{}), generators)

	return networkRuleSetIpRuleGenerator
}

// AddIndependentPropertyGeneratorsForNetworkRuleSetIpRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkRuleSetIpRule(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(NetworkRuleSetIpRule_Action_Allow))
	gens["FilterName"] = gen.PtrOf(gen.AlphaString())
	gens["IpMask"] = gen.PtrOf(gen.AlphaString())
}

func Test_NetworkRuleSetIpRule_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NetworkRuleSetIpRule_STATUS to NetworkRuleSetIpRule_STATUS via AssignProperties_To_NetworkRuleSetIpRule_STATUS & AssignProperties_From_NetworkRuleSetIpRule_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForNetworkRuleSetIpRule_STATUS, NetworkRuleSetIpRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNetworkRuleSetIpRule_STATUS tests if a specific instance of NetworkRuleSetIpRule_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForNetworkRuleSetIpRule_STATUS(subject NetworkRuleSetIpRule_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.NetworkRuleSetIpRule_STATUS
	err := copied.AssignProperties_To_NetworkRuleSetIpRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NetworkRuleSetIpRule_STATUS
	err = actual.AssignProperties_From_NetworkRuleSetIpRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NetworkRuleSetIpRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkRuleSetIpRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkRuleSetIpRule_STATUS, NetworkRuleSetIpRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkRuleSetIpRule_STATUS runs a test to see if a specific instance of NetworkRuleSetIpRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkRuleSetIpRule_STATUS(subject NetworkRuleSetIpRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkRuleSetIpRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkRuleSetIpRule_STATUS instances for property testing - lazily instantiated by
// NetworkRuleSetIpRule_STATUSGenerator()
var networkRuleSetIpRule_STATUSGenerator gopter.Gen

// NetworkRuleSetIpRule_STATUSGenerator returns a generator of NetworkRuleSetIpRule_STATUS instances for property testing.
func NetworkRuleSetIpRule_STATUSGenerator() gopter.Gen {
	if networkRuleSetIpRule_STATUSGenerator != nil {
		return networkRuleSetIpRule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSetIpRule_STATUS(generators)
	networkRuleSetIpRule_STATUSGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSetIpRule_STATUS{}), generators)

	return networkRuleSetIpRule_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForNetworkRuleSetIpRule_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkRuleSetIpRule_STATUS(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(NetworkRuleSetIpRule_Action_STATUS_Allow))
	gens["FilterName"] = gen.PtrOf(gen.AlphaString())
	gens["IpMask"] = gen.PtrOf(gen.AlphaString())
}

func Test_RouteProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RouteProperties to RouteProperties via AssignProperties_To_RouteProperties & AssignProperties_From_RouteProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForRouteProperties, RoutePropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRouteProperties tests if a specific instance of RouteProperties can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForRouteProperties(subject RouteProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.RouteProperties
	err := copied.AssignProperties_To_RouteProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RouteProperties
	err = actual.AssignProperties_From_RouteProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RouteProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RouteProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRouteProperties, RoutePropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRouteProperties runs a test to see if a specific instance of RouteProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForRouteProperties(subject RouteProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RouteProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RouteProperties instances for property testing - lazily instantiated by RoutePropertiesGenerator()
var routePropertiesGenerator gopter.Gen

// RoutePropertiesGenerator returns a generator of RouteProperties instances for property testing.
func RoutePropertiesGenerator() gopter.Gen {
	if routePropertiesGenerator != nil {
		return routePropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRouteProperties(generators)
	routePropertiesGenerator = gen.Struct(reflect.TypeOf(RouteProperties{}), generators)

	return routePropertiesGenerator
}

// AddIndependentPropertyGeneratorsForRouteProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRouteProperties(gens map[string]gopter.Gen) {
	gens["Condition"] = gen.PtrOf(gen.AlphaString())
	gens["EndpointNames"] = gen.SliceOf(gen.AlphaString())
	gens["IsEnabled"] = gen.PtrOf(gen.Bool())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Source"] = gen.PtrOf(gen.OneConstOf(
		RouteProperties_Source_DeviceConnectionStateEvents,
		RouteProperties_Source_DeviceJobLifecycleEvents,
		RouteProperties_Source_DeviceLifecycleEvents,
		RouteProperties_Source_DeviceMessages,
		RouteProperties_Source_Invalid,
		RouteProperties_Source_TwinChangeEvents))
}

func Test_RouteProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RouteProperties_STATUS to RouteProperties_STATUS via AssignProperties_To_RouteProperties_STATUS & AssignProperties_From_RouteProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForRouteProperties_STATUS, RouteProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRouteProperties_STATUS tests if a specific instance of RouteProperties_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForRouteProperties_STATUS(subject RouteProperties_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.RouteProperties_STATUS
	err := copied.AssignProperties_To_RouteProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RouteProperties_STATUS
	err = actual.AssignProperties_From_RouteProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RouteProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RouteProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRouteProperties_STATUS, RouteProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRouteProperties_STATUS runs a test to see if a specific instance of RouteProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRouteProperties_STATUS(subject RouteProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RouteProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RouteProperties_STATUS instances for property testing - lazily instantiated by
// RouteProperties_STATUSGenerator()
var routeProperties_STATUSGenerator gopter.Gen

// RouteProperties_STATUSGenerator returns a generator of RouteProperties_STATUS instances for property testing.
func RouteProperties_STATUSGenerator() gopter.Gen {
	if routeProperties_STATUSGenerator != nil {
		return routeProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRouteProperties_STATUS(generators)
	routeProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(RouteProperties_STATUS{}), generators)

	return routeProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForRouteProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRouteProperties_STATUS(gens map[string]gopter.Gen) {
	gens["Condition"] = gen.PtrOf(gen.AlphaString())
	gens["EndpointNames"] = gen.SliceOf(gen.AlphaString())
	gens["IsEnabled"] = gen.PtrOf(gen.Bool())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Source"] = gen.PtrOf(gen.OneConstOf(
		RouteProperties_Source_STATUS_DeviceConnectionStateEvents,
		RouteProperties_Source_STATUS_DeviceJobLifecycleEvents,
		RouteProperties_Source_STATUS_DeviceLifecycleEvents,
		RouteProperties_Source_STATUS_DeviceMessages,
		RouteProperties_Source_STATUS_Invalid,
		RouteProperties_Source_STATUS_TwinChangeEvents))
}

func Test_RoutingEndpoints_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RoutingEndpoints to RoutingEndpoints via AssignProperties_To_RoutingEndpoints & AssignProperties_From_RoutingEndpoints returns original",
		prop.ForAll(RunPropertyAssignmentTestForRoutingEndpoints, RoutingEndpointsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRoutingEndpoints tests if a specific instance of RoutingEndpoints can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForRoutingEndpoints(subject RoutingEndpoints) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.RoutingEndpoints
	err := copied.AssignProperties_To_RoutingEndpoints(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RoutingEndpoints
	err = actual.AssignProperties_From_RoutingEndpoints(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RoutingEndpoints_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingEndpoints via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingEndpoints, RoutingEndpointsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingEndpoints runs a test to see if a specific instance of RoutingEndpoints round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingEndpoints(subject RoutingEndpoints) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingEndpoints
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingEndpoints instances for property testing - lazily instantiated by RoutingEndpointsGenerator()
var routingEndpointsGenerator gopter.Gen

// RoutingEndpointsGenerator returns a generator of RoutingEndpoints instances for property testing.
func RoutingEndpointsGenerator() gopter.Gen {
	if routingEndpointsGenerator != nil {
		return routingEndpointsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForRoutingEndpoints(generators)
	routingEndpointsGenerator = gen.Struct(reflect.TypeOf(RoutingEndpoints{}), generators)

	return routingEndpointsGenerator
}

// AddRelatedPropertyGeneratorsForRoutingEndpoints is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRoutingEndpoints(gens map[string]gopter.Gen) {
	gens["EventHubs"] = gen.SliceOf(RoutingEventHubPropertiesGenerator())
	gens["ServiceBusQueues"] = gen.SliceOf(RoutingServiceBusQueueEndpointPropertiesGenerator())
	gens["ServiceBusTopics"] = gen.SliceOf(RoutingServiceBusTopicEndpointPropertiesGenerator())
	gens["StorageContainers"] = gen.SliceOf(RoutingStorageContainerPropertiesGenerator())
}

func Test_RoutingEndpoints_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RoutingEndpoints_STATUS to RoutingEndpoints_STATUS via AssignProperties_To_RoutingEndpoints_STATUS & AssignProperties_From_RoutingEndpoints_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForRoutingEndpoints_STATUS, RoutingEndpoints_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRoutingEndpoints_STATUS tests if a specific instance of RoutingEndpoints_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForRoutingEndpoints_STATUS(subject RoutingEndpoints_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.RoutingEndpoints_STATUS
	err := copied.AssignProperties_To_RoutingEndpoints_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RoutingEndpoints_STATUS
	err = actual.AssignProperties_From_RoutingEndpoints_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RoutingEndpoints_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingEndpoints_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingEndpoints_STATUS, RoutingEndpoints_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingEndpoints_STATUS runs a test to see if a specific instance of RoutingEndpoints_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingEndpoints_STATUS(subject RoutingEndpoints_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingEndpoints_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingEndpoints_STATUS instances for property testing - lazily instantiated by
// RoutingEndpoints_STATUSGenerator()
var routingEndpoints_STATUSGenerator gopter.Gen

// RoutingEndpoints_STATUSGenerator returns a generator of RoutingEndpoints_STATUS instances for property testing.
func RoutingEndpoints_STATUSGenerator() gopter.Gen {
	if routingEndpoints_STATUSGenerator != nil {
		return routingEndpoints_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForRoutingEndpoints_STATUS(generators)
	routingEndpoints_STATUSGenerator = gen.Struct(reflect.TypeOf(RoutingEndpoints_STATUS{}), generators)

	return routingEndpoints_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForRoutingEndpoints_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRoutingEndpoints_STATUS(gens map[string]gopter.Gen) {
	gens["EventHubs"] = gen.SliceOf(RoutingEventHubProperties_STATUSGenerator())
	gens["ServiceBusQueues"] = gen.SliceOf(RoutingServiceBusQueueEndpointProperties_STATUSGenerator())
	gens["ServiceBusTopics"] = gen.SliceOf(RoutingServiceBusTopicEndpointProperties_STATUSGenerator())
	gens["StorageContainers"] = gen.SliceOf(RoutingStorageContainerProperties_STATUSGenerator())
}

func Test_RoutingEventHubProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RoutingEventHubProperties to RoutingEventHubProperties via AssignProperties_To_RoutingEventHubProperties & AssignProperties_From_RoutingEventHubProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForRoutingEventHubProperties, RoutingEventHubPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRoutingEventHubProperties tests if a specific instance of RoutingEventHubProperties can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForRoutingEventHubProperties(subject RoutingEventHubProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.RoutingEventHubProperties
	err := copied.AssignProperties_To_RoutingEventHubProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RoutingEventHubProperties
	err = actual.AssignProperties_From_RoutingEventHubProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RoutingEventHubProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingEventHubProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingEventHubProperties, RoutingEventHubPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingEventHubProperties runs a test to see if a specific instance of RoutingEventHubProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingEventHubProperties(subject RoutingEventHubProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingEventHubProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingEventHubProperties instances for property testing - lazily instantiated by
// RoutingEventHubPropertiesGenerator()
var routingEventHubPropertiesGenerator gopter.Gen

// RoutingEventHubPropertiesGenerator returns a generator of RoutingEventHubProperties instances for property testing.
// We first initialize routingEventHubPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RoutingEventHubPropertiesGenerator() gopter.Gen {
	if routingEventHubPropertiesGenerator != nil {
		return routingEventHubPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingEventHubProperties(generators)
	routingEventHubPropertiesGenerator = gen.Struct(reflect.TypeOf(RoutingEventHubProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingEventHubProperties(generators)
	AddRelatedPropertyGeneratorsForRoutingEventHubProperties(generators)
	routingEventHubPropertiesGenerator = gen.Struct(reflect.TypeOf(RoutingEventHubProperties{}), generators)

	return routingEventHubPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForRoutingEventHubProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRoutingEventHubProperties(gens map[string]gopter.Gen) {
	gens["AuthenticationType"] = gen.PtrOf(gen.OneConstOf(RoutingEventHubProperties_AuthenticationType_IdentityBased, RoutingEventHubProperties_AuthenticationType_KeyBased))
	gens["EndpointUri"] = gen.PtrOf(gen.AlphaString())
	gens["EntityPath"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceGroup"] = gen.PtrOf(gen.AlphaString())
	gens["SubscriptionId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForRoutingEventHubProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRoutingEventHubProperties(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedIdentityGenerator())
}

func Test_RoutingEventHubProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RoutingEventHubProperties_STATUS to RoutingEventHubProperties_STATUS via AssignProperties_To_RoutingEventHubProperties_STATUS & AssignProperties_From_RoutingEventHubProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForRoutingEventHubProperties_STATUS, RoutingEventHubProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRoutingEventHubProperties_STATUS tests if a specific instance of RoutingEventHubProperties_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForRoutingEventHubProperties_STATUS(subject RoutingEventHubProperties_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.RoutingEventHubProperties_STATUS
	err := copied.AssignProperties_To_RoutingEventHubProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RoutingEventHubProperties_STATUS
	err = actual.AssignProperties_From_RoutingEventHubProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RoutingEventHubProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingEventHubProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingEventHubProperties_STATUS, RoutingEventHubProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingEventHubProperties_STATUS runs a test to see if a specific instance of RoutingEventHubProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingEventHubProperties_STATUS(subject RoutingEventHubProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingEventHubProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingEventHubProperties_STATUS instances for property testing - lazily instantiated by
// RoutingEventHubProperties_STATUSGenerator()
var routingEventHubProperties_STATUSGenerator gopter.Gen

// RoutingEventHubProperties_STATUSGenerator returns a generator of RoutingEventHubProperties_STATUS instances for property testing.
// We first initialize routingEventHubProperties_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RoutingEventHubProperties_STATUSGenerator() gopter.Gen {
	if routingEventHubProperties_STATUSGenerator != nil {
		return routingEventHubProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingEventHubProperties_STATUS(generators)
	routingEventHubProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(RoutingEventHubProperties_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingEventHubProperties_STATUS(generators)
	AddRelatedPropertyGeneratorsForRoutingEventHubProperties_STATUS(generators)
	routingEventHubProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(RoutingEventHubProperties_STATUS{}), generators)

	return routingEventHubProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForRoutingEventHubProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRoutingEventHubProperties_STATUS(gens map[string]gopter.Gen) {
	gens["AuthenticationType"] = gen.PtrOf(gen.OneConstOf(RoutingEventHubProperties_AuthenticationType_STATUS_IdentityBased, RoutingEventHubProperties_AuthenticationType_STATUS_KeyBased))
	gens["EndpointUri"] = gen.PtrOf(gen.AlphaString())
	gens["EntityPath"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceGroup"] = gen.PtrOf(gen.AlphaString())
	gens["SubscriptionId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForRoutingEventHubProperties_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRoutingEventHubProperties_STATUS(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedIdentity_STATUSGenerator())
}

func Test_RoutingServiceBusQueueEndpointProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RoutingServiceBusQueueEndpointProperties to RoutingServiceBusQueueEndpointProperties via AssignProperties_To_RoutingServiceBusQueueEndpointProperties & AssignProperties_From_RoutingServiceBusQueueEndpointProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForRoutingServiceBusQueueEndpointProperties, RoutingServiceBusQueueEndpointPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRoutingServiceBusQueueEndpointProperties tests if a specific instance of RoutingServiceBusQueueEndpointProperties can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForRoutingServiceBusQueueEndpointProperties(subject RoutingServiceBusQueueEndpointProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.RoutingServiceBusQueueEndpointProperties
	err := copied.AssignProperties_To_RoutingServiceBusQueueEndpointProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RoutingServiceBusQueueEndpointProperties
	err = actual.AssignProperties_From_RoutingServiceBusQueueEndpointProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RoutingServiceBusQueueEndpointProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingServiceBusQueueEndpointProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingServiceBusQueueEndpointProperties, RoutingServiceBusQueueEndpointPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingServiceBusQueueEndpointProperties runs a test to see if a specific instance of RoutingServiceBusQueueEndpointProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingServiceBusQueueEndpointProperties(subject RoutingServiceBusQueueEndpointProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingServiceBusQueueEndpointProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingServiceBusQueueEndpointProperties instances for property testing - lazily instantiated by
// RoutingServiceBusQueueEndpointPropertiesGenerator()
var routingServiceBusQueueEndpointPropertiesGenerator gopter.Gen

// RoutingServiceBusQueueEndpointPropertiesGenerator returns a generator of RoutingServiceBusQueueEndpointProperties instances for property testing.
// We first initialize routingServiceBusQueueEndpointPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RoutingServiceBusQueueEndpointPropertiesGenerator() gopter.Gen {
	if routingServiceBusQueueEndpointPropertiesGenerator != nil {
		return routingServiceBusQueueEndpointPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingServiceBusQueueEndpointProperties(generators)
	routingServiceBusQueueEndpointPropertiesGenerator = gen.Struct(reflect.TypeOf(RoutingServiceBusQueueEndpointProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingServiceBusQueueEndpointProperties(generators)
	AddRelatedPropertyGeneratorsForRoutingServiceBusQueueEndpointProperties(generators)
	routingServiceBusQueueEndpointPropertiesGenerator = gen.Struct(reflect.TypeOf(RoutingServiceBusQueueEndpointProperties{}), generators)

	return routingServiceBusQueueEndpointPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForRoutingServiceBusQueueEndpointProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRoutingServiceBusQueueEndpointProperties(gens map[string]gopter.Gen) {
	gens["AuthenticationType"] = gen.PtrOf(gen.OneConstOf(RoutingServiceBusQueueEndpointProperties_AuthenticationType_IdentityBased, RoutingServiceBusQueueEndpointProperties_AuthenticationType_KeyBased))
	gens["EndpointUri"] = gen.PtrOf(gen.AlphaString())
	gens["EntityPath"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceGroup"] = gen.PtrOf(gen.AlphaString())
	gens["SubscriptionId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForRoutingServiceBusQueueEndpointProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRoutingServiceBusQueueEndpointProperties(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedIdentityGenerator())
}

func Test_RoutingServiceBusQueueEndpointProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RoutingServiceBusQueueEndpointProperties_STATUS to RoutingServiceBusQueueEndpointProperties_STATUS via AssignProperties_To_RoutingServiceBusQueueEndpointProperties_STATUS & AssignProperties_From_RoutingServiceBusQueueEndpointProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForRoutingServiceBusQueueEndpointProperties_STATUS, RoutingServiceBusQueueEndpointProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRoutingServiceBusQueueEndpointProperties_STATUS tests if a specific instance of RoutingServiceBusQueueEndpointProperties_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForRoutingServiceBusQueueEndpointProperties_STATUS(subject RoutingServiceBusQueueEndpointProperties_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.RoutingServiceBusQueueEndpointProperties_STATUS
	err := copied.AssignProperties_To_RoutingServiceBusQueueEndpointProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RoutingServiceBusQueueEndpointProperties_STATUS
	err = actual.AssignProperties_From_RoutingServiceBusQueueEndpointProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RoutingServiceBusQueueEndpointProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingServiceBusQueueEndpointProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingServiceBusQueueEndpointProperties_STATUS, RoutingServiceBusQueueEndpointProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingServiceBusQueueEndpointProperties_STATUS runs a test to see if a specific instance of RoutingServiceBusQueueEndpointProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingServiceBusQueueEndpointProperties_STATUS(subject RoutingServiceBusQueueEndpointProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingServiceBusQueueEndpointProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingServiceBusQueueEndpointProperties_STATUS instances for property testing - lazily instantiated by
// RoutingServiceBusQueueEndpointProperties_STATUSGenerator()
var routingServiceBusQueueEndpointProperties_STATUSGenerator gopter.Gen

// RoutingServiceBusQueueEndpointProperties_STATUSGenerator returns a generator of RoutingServiceBusQueueEndpointProperties_STATUS instances for property testing.
// We first initialize routingServiceBusQueueEndpointProperties_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RoutingServiceBusQueueEndpointProperties_STATUSGenerator() gopter.Gen {
	if routingServiceBusQueueEndpointProperties_STATUSGenerator != nil {
		return routingServiceBusQueueEndpointProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingServiceBusQueueEndpointProperties_STATUS(generators)
	routingServiceBusQueueEndpointProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(RoutingServiceBusQueueEndpointProperties_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingServiceBusQueueEndpointProperties_STATUS(generators)
	AddRelatedPropertyGeneratorsForRoutingServiceBusQueueEndpointProperties_STATUS(generators)
	routingServiceBusQueueEndpointProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(RoutingServiceBusQueueEndpointProperties_STATUS{}), generators)

	return routingServiceBusQueueEndpointProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForRoutingServiceBusQueueEndpointProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRoutingServiceBusQueueEndpointProperties_STATUS(gens map[string]gopter.Gen) {
	gens["AuthenticationType"] = gen.PtrOf(gen.OneConstOf(RoutingServiceBusQueueEndpointProperties_AuthenticationType_STATUS_IdentityBased, RoutingServiceBusQueueEndpointProperties_AuthenticationType_STATUS_KeyBased))
	gens["EndpointUri"] = gen.PtrOf(gen.AlphaString())
	gens["EntityPath"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceGroup"] = gen.PtrOf(gen.AlphaString())
	gens["SubscriptionId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForRoutingServiceBusQueueEndpointProperties_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRoutingServiceBusQueueEndpointProperties_STATUS(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedIdentity_STATUSGenerator())
}

func Test_RoutingServiceBusTopicEndpointProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RoutingServiceBusTopicEndpointProperties to RoutingServiceBusTopicEndpointProperties via AssignProperties_To_RoutingServiceBusTopicEndpointProperties & AssignProperties_From_RoutingServiceBusTopicEndpointProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForRoutingServiceBusTopicEndpointProperties, RoutingServiceBusTopicEndpointPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRoutingServiceBusTopicEndpointProperties tests if a specific instance of RoutingServiceBusTopicEndpointProperties can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForRoutingServiceBusTopicEndpointProperties(subject RoutingServiceBusTopicEndpointProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.RoutingServiceBusTopicEndpointProperties
	err := copied.AssignProperties_To_RoutingServiceBusTopicEndpointProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RoutingServiceBusTopicEndpointProperties
	err = actual.AssignProperties_From_RoutingServiceBusTopicEndpointProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RoutingServiceBusTopicEndpointProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingServiceBusTopicEndpointProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingServiceBusTopicEndpointProperties, RoutingServiceBusTopicEndpointPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingServiceBusTopicEndpointProperties runs a test to see if a specific instance of RoutingServiceBusTopicEndpointProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingServiceBusTopicEndpointProperties(subject RoutingServiceBusTopicEndpointProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingServiceBusTopicEndpointProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingServiceBusTopicEndpointProperties instances for property testing - lazily instantiated by
// RoutingServiceBusTopicEndpointPropertiesGenerator()
var routingServiceBusTopicEndpointPropertiesGenerator gopter.Gen

// RoutingServiceBusTopicEndpointPropertiesGenerator returns a generator of RoutingServiceBusTopicEndpointProperties instances for property testing.
// We first initialize routingServiceBusTopicEndpointPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RoutingServiceBusTopicEndpointPropertiesGenerator() gopter.Gen {
	if routingServiceBusTopicEndpointPropertiesGenerator != nil {
		return routingServiceBusTopicEndpointPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingServiceBusTopicEndpointProperties(generators)
	routingServiceBusTopicEndpointPropertiesGenerator = gen.Struct(reflect.TypeOf(RoutingServiceBusTopicEndpointProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingServiceBusTopicEndpointProperties(generators)
	AddRelatedPropertyGeneratorsForRoutingServiceBusTopicEndpointProperties(generators)
	routingServiceBusTopicEndpointPropertiesGenerator = gen.Struct(reflect.TypeOf(RoutingServiceBusTopicEndpointProperties{}), generators)

	return routingServiceBusTopicEndpointPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForRoutingServiceBusTopicEndpointProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRoutingServiceBusTopicEndpointProperties(gens map[string]gopter.Gen) {
	gens["AuthenticationType"] = gen.PtrOf(gen.OneConstOf(RoutingServiceBusTopicEndpointProperties_AuthenticationType_IdentityBased, RoutingServiceBusTopicEndpointProperties_AuthenticationType_KeyBased))
	gens["EndpointUri"] = gen.PtrOf(gen.AlphaString())
	gens["EntityPath"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceGroup"] = gen.PtrOf(gen.AlphaString())
	gens["SubscriptionId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForRoutingServiceBusTopicEndpointProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRoutingServiceBusTopicEndpointProperties(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedIdentityGenerator())
}

func Test_RoutingServiceBusTopicEndpointProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RoutingServiceBusTopicEndpointProperties_STATUS to RoutingServiceBusTopicEndpointProperties_STATUS via AssignProperties_To_RoutingServiceBusTopicEndpointProperties_STATUS & AssignProperties_From_RoutingServiceBusTopicEndpointProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForRoutingServiceBusTopicEndpointProperties_STATUS, RoutingServiceBusTopicEndpointProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRoutingServiceBusTopicEndpointProperties_STATUS tests if a specific instance of RoutingServiceBusTopicEndpointProperties_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForRoutingServiceBusTopicEndpointProperties_STATUS(subject RoutingServiceBusTopicEndpointProperties_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.RoutingServiceBusTopicEndpointProperties_STATUS
	err := copied.AssignProperties_To_RoutingServiceBusTopicEndpointProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RoutingServiceBusTopicEndpointProperties_STATUS
	err = actual.AssignProperties_From_RoutingServiceBusTopicEndpointProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RoutingServiceBusTopicEndpointProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingServiceBusTopicEndpointProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingServiceBusTopicEndpointProperties_STATUS, RoutingServiceBusTopicEndpointProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingServiceBusTopicEndpointProperties_STATUS runs a test to see if a specific instance of RoutingServiceBusTopicEndpointProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingServiceBusTopicEndpointProperties_STATUS(subject RoutingServiceBusTopicEndpointProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingServiceBusTopicEndpointProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingServiceBusTopicEndpointProperties_STATUS instances for property testing - lazily instantiated by
// RoutingServiceBusTopicEndpointProperties_STATUSGenerator()
var routingServiceBusTopicEndpointProperties_STATUSGenerator gopter.Gen

// RoutingServiceBusTopicEndpointProperties_STATUSGenerator returns a generator of RoutingServiceBusTopicEndpointProperties_STATUS instances for property testing.
// We first initialize routingServiceBusTopicEndpointProperties_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RoutingServiceBusTopicEndpointProperties_STATUSGenerator() gopter.Gen {
	if routingServiceBusTopicEndpointProperties_STATUSGenerator != nil {
		return routingServiceBusTopicEndpointProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingServiceBusTopicEndpointProperties_STATUS(generators)
	routingServiceBusTopicEndpointProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(RoutingServiceBusTopicEndpointProperties_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingServiceBusTopicEndpointProperties_STATUS(generators)
	AddRelatedPropertyGeneratorsForRoutingServiceBusTopicEndpointProperties_STATUS(generators)
	routingServiceBusTopicEndpointProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(RoutingServiceBusTopicEndpointProperties_STATUS{}), generators)

	return routingServiceBusTopicEndpointProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForRoutingServiceBusTopicEndpointProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRoutingServiceBusTopicEndpointProperties_STATUS(gens map[string]gopter.Gen) {
	gens["AuthenticationType"] = gen.PtrOf(gen.OneConstOf(RoutingServiceBusTopicEndpointProperties_AuthenticationType_STATUS_IdentityBased, RoutingServiceBusTopicEndpointProperties_AuthenticationType_STATUS_KeyBased))
	gens["EndpointUri"] = gen.PtrOf(gen.AlphaString())
	gens["EntityPath"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceGroup"] = gen.PtrOf(gen.AlphaString())
	gens["SubscriptionId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForRoutingServiceBusTopicEndpointProperties_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRoutingServiceBusTopicEndpointProperties_STATUS(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedIdentity_STATUSGenerator())
}

func Test_RoutingStorageContainerProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RoutingStorageContainerProperties to RoutingStorageContainerProperties via AssignProperties_To_RoutingStorageContainerProperties & AssignProperties_From_RoutingStorageContainerProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForRoutingStorageContainerProperties, RoutingStorageContainerPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRoutingStorageContainerProperties tests if a specific instance of RoutingStorageContainerProperties can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForRoutingStorageContainerProperties(subject RoutingStorageContainerProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.RoutingStorageContainerProperties
	err := copied.AssignProperties_To_RoutingStorageContainerProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RoutingStorageContainerProperties
	err = actual.AssignProperties_From_RoutingStorageContainerProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RoutingStorageContainerProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingStorageContainerProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingStorageContainerProperties, RoutingStorageContainerPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingStorageContainerProperties runs a test to see if a specific instance of RoutingStorageContainerProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingStorageContainerProperties(subject RoutingStorageContainerProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingStorageContainerProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingStorageContainerProperties instances for property testing - lazily instantiated by
// RoutingStorageContainerPropertiesGenerator()
var routingStorageContainerPropertiesGenerator gopter.Gen

// RoutingStorageContainerPropertiesGenerator returns a generator of RoutingStorageContainerProperties instances for property testing.
// We first initialize routingStorageContainerPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RoutingStorageContainerPropertiesGenerator() gopter.Gen {
	if routingStorageContainerPropertiesGenerator != nil {
		return routingStorageContainerPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingStorageContainerProperties(generators)
	routingStorageContainerPropertiesGenerator = gen.Struct(reflect.TypeOf(RoutingStorageContainerProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingStorageContainerProperties(generators)
	AddRelatedPropertyGeneratorsForRoutingStorageContainerProperties(generators)
	routingStorageContainerPropertiesGenerator = gen.Struct(reflect.TypeOf(RoutingStorageContainerProperties{}), generators)

	return routingStorageContainerPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForRoutingStorageContainerProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRoutingStorageContainerProperties(gens map[string]gopter.Gen) {
	gens["AuthenticationType"] = gen.PtrOf(gen.OneConstOf(RoutingStorageContainerProperties_AuthenticationType_IdentityBased, RoutingStorageContainerProperties_AuthenticationType_KeyBased))
	gens["BatchFrequencyInSeconds"] = gen.PtrOf(gen.Int())
	gens["ContainerName"] = gen.PtrOf(gen.AlphaString())
	gens["Encoding"] = gen.PtrOf(gen.OneConstOf(RoutingStorageContainerProperties_Encoding_Avro, RoutingStorageContainerProperties_Encoding_AvroDeflate, RoutingStorageContainerProperties_Encoding_JSON))
	gens["EndpointUri"] = gen.PtrOf(gen.AlphaString())
	gens["FileNameFormat"] = gen.PtrOf(gen.AlphaString())
	gens["MaxChunkSizeInBytes"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceGroup"] = gen.PtrOf(gen.AlphaString())
	gens["SubscriptionId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForRoutingStorageContainerProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRoutingStorageContainerProperties(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedIdentityGenerator())
}

func Test_RoutingStorageContainerProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RoutingStorageContainerProperties_STATUS to RoutingStorageContainerProperties_STATUS via AssignProperties_To_RoutingStorageContainerProperties_STATUS & AssignProperties_From_RoutingStorageContainerProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForRoutingStorageContainerProperties_STATUS, RoutingStorageContainerProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRoutingStorageContainerProperties_STATUS tests if a specific instance of RoutingStorageContainerProperties_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForRoutingStorageContainerProperties_STATUS(subject RoutingStorageContainerProperties_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.RoutingStorageContainerProperties_STATUS
	err := copied.AssignProperties_To_RoutingStorageContainerProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RoutingStorageContainerProperties_STATUS
	err = actual.AssignProperties_From_RoutingStorageContainerProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RoutingStorageContainerProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingStorageContainerProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingStorageContainerProperties_STATUS, RoutingStorageContainerProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingStorageContainerProperties_STATUS runs a test to see if a specific instance of RoutingStorageContainerProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingStorageContainerProperties_STATUS(subject RoutingStorageContainerProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingStorageContainerProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingStorageContainerProperties_STATUS instances for property testing - lazily instantiated by
// RoutingStorageContainerProperties_STATUSGenerator()
var routingStorageContainerProperties_STATUSGenerator gopter.Gen

// RoutingStorageContainerProperties_STATUSGenerator returns a generator of RoutingStorageContainerProperties_STATUS instances for property testing.
// We first initialize routingStorageContainerProperties_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RoutingStorageContainerProperties_STATUSGenerator() gopter.Gen {
	if routingStorageContainerProperties_STATUSGenerator != nil {
		return routingStorageContainerProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingStorageContainerProperties_STATUS(generators)
	routingStorageContainerProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(RoutingStorageContainerProperties_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingStorageContainerProperties_STATUS(generators)
	AddRelatedPropertyGeneratorsForRoutingStorageContainerProperties_STATUS(generators)
	routingStorageContainerProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(RoutingStorageContainerProperties_STATUS{}), generators)

	return routingStorageContainerProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForRoutingStorageContainerProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRoutingStorageContainerProperties_STATUS(gens map[string]gopter.Gen) {
	gens["AuthenticationType"] = gen.PtrOf(gen.OneConstOf(RoutingStorageContainerProperties_AuthenticationType_STATUS_IdentityBased, RoutingStorageContainerProperties_AuthenticationType_STATUS_KeyBased))
	gens["BatchFrequencyInSeconds"] = gen.PtrOf(gen.Int())
	gens["ContainerName"] = gen.PtrOf(gen.AlphaString())
	gens["Encoding"] = gen.PtrOf(gen.OneConstOf(RoutingStorageContainerProperties_Encoding_STATUS_Avro, RoutingStorageContainerProperties_Encoding_STATUS_AvroDeflate, RoutingStorageContainerProperties_Encoding_STATUS_JSON))
	gens["EndpointUri"] = gen.PtrOf(gen.AlphaString())
	gens["FileNameFormat"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["MaxChunkSizeInBytes"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceGroup"] = gen.PtrOf(gen.AlphaString())
	gens["SubscriptionId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForRoutingStorageContainerProperties_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRoutingStorageContainerProperties_STATUS(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedIdentity_STATUSGenerator())
}
