// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package arm

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_ArmIdentity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ArmIdentity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForArmIdentity, ArmIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForArmIdentity runs a test to see if a specific instance of ArmIdentity round trips to JSON and back losslessly
func RunJSONSerializationTestForArmIdentity(subject ArmIdentity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ArmIdentity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ArmIdentity instances for property testing - lazily instantiated by ArmIdentityGenerator()
var armIdentityGenerator gopter.Gen

// ArmIdentityGenerator returns a generator of ArmIdentity instances for property testing.
// We first initialize armIdentityGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ArmIdentityGenerator() gopter.Gen {
	if armIdentityGenerator != nil {
		return armIdentityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForArmIdentity(generators)
	armIdentityGenerator = gen.Struct(reflect.TypeOf(ArmIdentity{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForArmIdentity(generators)
	AddRelatedPropertyGeneratorsForArmIdentity(generators)
	armIdentityGenerator = gen.Struct(reflect.TypeOf(ArmIdentity{}), generators)

	return armIdentityGenerator
}

// AddIndependentPropertyGeneratorsForArmIdentity is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForArmIdentity(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ArmIdentity_Type_None,
		ArmIdentity_Type_SystemAssigned,
		ArmIdentity_Type_SystemAssignedUserAssigned,
		ArmIdentity_Type_UserAssigned))
}

// AddRelatedPropertyGeneratorsForArmIdentity is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForArmIdentity(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(
		gen.AlphaString(),
		UserAssignedIdentityDetailsGenerator())
}

func Test_CloudToDeviceProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CloudToDeviceProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCloudToDeviceProperties, CloudToDevicePropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCloudToDeviceProperties runs a test to see if a specific instance of CloudToDeviceProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForCloudToDeviceProperties(subject CloudToDeviceProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CloudToDeviceProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CloudToDeviceProperties instances for property testing - lazily instantiated by
// CloudToDevicePropertiesGenerator()
var cloudToDevicePropertiesGenerator gopter.Gen

// CloudToDevicePropertiesGenerator returns a generator of CloudToDeviceProperties instances for property testing.
// We first initialize cloudToDevicePropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CloudToDevicePropertiesGenerator() gopter.Gen {
	if cloudToDevicePropertiesGenerator != nil {
		return cloudToDevicePropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCloudToDeviceProperties(generators)
	cloudToDevicePropertiesGenerator = gen.Struct(reflect.TypeOf(CloudToDeviceProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCloudToDeviceProperties(generators)
	AddRelatedPropertyGeneratorsForCloudToDeviceProperties(generators)
	cloudToDevicePropertiesGenerator = gen.Struct(reflect.TypeOf(CloudToDeviceProperties{}), generators)

	return cloudToDevicePropertiesGenerator
}

// AddIndependentPropertyGeneratorsForCloudToDeviceProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCloudToDeviceProperties(gens map[string]gopter.Gen) {
	gens["DefaultTtlAsIso8601"] = gen.PtrOf(gen.AlphaString())
	gens["MaxDeliveryCount"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForCloudToDeviceProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCloudToDeviceProperties(gens map[string]gopter.Gen) {
	gens["Feedback"] = gen.PtrOf(FeedbackPropertiesGenerator())
}

func Test_EnrichmentProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EnrichmentProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEnrichmentProperties, EnrichmentPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEnrichmentProperties runs a test to see if a specific instance of EnrichmentProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForEnrichmentProperties(subject EnrichmentProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EnrichmentProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EnrichmentProperties instances for property testing - lazily instantiated by
// EnrichmentPropertiesGenerator()
var enrichmentPropertiesGenerator gopter.Gen

// EnrichmentPropertiesGenerator returns a generator of EnrichmentProperties instances for property testing.
func EnrichmentPropertiesGenerator() gopter.Gen {
	if enrichmentPropertiesGenerator != nil {
		return enrichmentPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEnrichmentProperties(generators)
	enrichmentPropertiesGenerator = gen.Struct(reflect.TypeOf(EnrichmentProperties{}), generators)

	return enrichmentPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForEnrichmentProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEnrichmentProperties(gens map[string]gopter.Gen) {
	gens["EndpointNames"] = gen.SliceOf(gen.AlphaString())
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_EventHubProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventHubProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventHubProperties, EventHubPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventHubProperties runs a test to see if a specific instance of EventHubProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForEventHubProperties(subject EventHubProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventHubProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventHubProperties instances for property testing - lazily instantiated by EventHubPropertiesGenerator()
var eventHubPropertiesGenerator gopter.Gen

// EventHubPropertiesGenerator returns a generator of EventHubProperties instances for property testing.
func EventHubPropertiesGenerator() gopter.Gen {
	if eventHubPropertiesGenerator != nil {
		return eventHubPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventHubProperties(generators)
	eventHubPropertiesGenerator = gen.Struct(reflect.TypeOf(EventHubProperties{}), generators)

	return eventHubPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForEventHubProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventHubProperties(gens map[string]gopter.Gen) {
	gens["PartitionCount"] = gen.PtrOf(gen.Int())
	gens["RetentionTimeInDays"] = gen.PtrOf(gen.Int())
}

func Test_FallbackRouteProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FallbackRouteProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFallbackRouteProperties, FallbackRoutePropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFallbackRouteProperties runs a test to see if a specific instance of FallbackRouteProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForFallbackRouteProperties(subject FallbackRouteProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FallbackRouteProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FallbackRouteProperties instances for property testing - lazily instantiated by
// FallbackRoutePropertiesGenerator()
var fallbackRoutePropertiesGenerator gopter.Gen

// FallbackRoutePropertiesGenerator returns a generator of FallbackRouteProperties instances for property testing.
func FallbackRoutePropertiesGenerator() gopter.Gen {
	if fallbackRoutePropertiesGenerator != nil {
		return fallbackRoutePropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFallbackRouteProperties(generators)
	fallbackRoutePropertiesGenerator = gen.Struct(reflect.TypeOf(FallbackRouteProperties{}), generators)

	return fallbackRoutePropertiesGenerator
}

// AddIndependentPropertyGeneratorsForFallbackRouteProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFallbackRouteProperties(gens map[string]gopter.Gen) {
	gens["Condition"] = gen.PtrOf(gen.AlphaString())
	gens["EndpointNames"] = gen.SliceOf(gen.AlphaString())
	gens["IsEnabled"] = gen.PtrOf(gen.Bool())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Source"] = gen.PtrOf(gen.OneConstOf(FallbackRouteProperties_Source_DeviceMessages))
}

func Test_FeedbackProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FeedbackProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFeedbackProperties, FeedbackPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFeedbackProperties runs a test to see if a specific instance of FeedbackProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForFeedbackProperties(subject FeedbackProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FeedbackProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FeedbackProperties instances for property testing - lazily instantiated by FeedbackPropertiesGenerator()
var feedbackPropertiesGenerator gopter.Gen

// FeedbackPropertiesGenerator returns a generator of FeedbackProperties instances for property testing.
func FeedbackPropertiesGenerator() gopter.Gen {
	if feedbackPropertiesGenerator != nil {
		return feedbackPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFeedbackProperties(generators)
	feedbackPropertiesGenerator = gen.Struct(reflect.TypeOf(FeedbackProperties{}), generators)

	return feedbackPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForFeedbackProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFeedbackProperties(gens map[string]gopter.Gen) {
	gens["LockDurationAsIso8601"] = gen.PtrOf(gen.AlphaString())
	gens["MaxDeliveryCount"] = gen.PtrOf(gen.Int())
	gens["TtlAsIso8601"] = gen.PtrOf(gen.AlphaString())
}

func Test_IotHubProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IotHubProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIotHubProperties, IotHubPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIotHubProperties runs a test to see if a specific instance of IotHubProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForIotHubProperties(subject IotHubProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IotHubProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IotHubProperties instances for property testing - lazily instantiated by IotHubPropertiesGenerator()
var iotHubPropertiesGenerator gopter.Gen

// IotHubPropertiesGenerator returns a generator of IotHubProperties instances for property testing.
// We first initialize iotHubPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IotHubPropertiesGenerator() gopter.Gen {
	if iotHubPropertiesGenerator != nil {
		return iotHubPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIotHubProperties(generators)
	iotHubPropertiesGenerator = gen.Struct(reflect.TypeOf(IotHubProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIotHubProperties(generators)
	AddRelatedPropertyGeneratorsForIotHubProperties(generators)
	iotHubPropertiesGenerator = gen.Struct(reflect.TypeOf(IotHubProperties{}), generators)

	return iotHubPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForIotHubProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIotHubProperties(gens map[string]gopter.Gen) {
	gens["AllowedFqdnList"] = gen.SliceOf(gen.AlphaString())
	gens["Comments"] = gen.PtrOf(gen.AlphaString())
	gens["DisableDeviceSAS"] = gen.PtrOf(gen.Bool())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["DisableModuleSAS"] = gen.PtrOf(gen.Bool())
	gens["EnableDataResidency"] = gen.PtrOf(gen.Bool())
	gens["EnableFileUploadNotifications"] = gen.PtrOf(gen.Bool())
	gens["Features"] = gen.PtrOf(gen.OneConstOf(IotHubProperties_Features_DeviceManagement, IotHubProperties_Features_None))
	gens["MinTlsVersion"] = gen.PtrOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(IotHubProperties_PublicNetworkAccess_Disabled, IotHubProperties_PublicNetworkAccess_Enabled))
	gens["RestrictOutboundNetworkAccess"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForIotHubProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIotHubProperties(gens map[string]gopter.Gen) {
	gens["AuthorizationPolicies"] = gen.SliceOf(SharedAccessSignatureAuthorizationRuleGenerator())
	gens["CloudToDevice"] = gen.PtrOf(CloudToDevicePropertiesGenerator())
	gens["EventHubEndpoints"] = gen.MapOf(
		gen.AlphaString(),
		EventHubPropertiesGenerator())
	gens["IpFilterRules"] = gen.SliceOf(IpFilterRuleGenerator())
	gens["MessagingEndpoints"] = gen.MapOf(
		gen.AlphaString(),
		MessagingEndpointPropertiesGenerator())
	gens["NetworkRuleSets"] = gen.PtrOf(NetworkRuleSetPropertiesGenerator())
	gens["Routing"] = gen.PtrOf(RoutingPropertiesGenerator())
	gens["StorageEndpoints"] = gen.MapOf(
		gen.AlphaString(),
		StorageEndpointPropertiesGenerator())
}

func Test_IotHubSkuInfo_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IotHubSkuInfo via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIotHubSkuInfo, IotHubSkuInfoGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIotHubSkuInfo runs a test to see if a specific instance of IotHubSkuInfo round trips to JSON and back losslessly
func RunJSONSerializationTestForIotHubSkuInfo(subject IotHubSkuInfo) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IotHubSkuInfo
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IotHubSkuInfo instances for property testing - lazily instantiated by IotHubSkuInfoGenerator()
var iotHubSkuInfoGenerator gopter.Gen

// IotHubSkuInfoGenerator returns a generator of IotHubSkuInfo instances for property testing.
func IotHubSkuInfoGenerator() gopter.Gen {
	if iotHubSkuInfoGenerator != nil {
		return iotHubSkuInfoGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIotHubSkuInfo(generators)
	iotHubSkuInfoGenerator = gen.Struct(reflect.TypeOf(IotHubSkuInfo{}), generators)

	return iotHubSkuInfoGenerator
}

// AddIndependentPropertyGeneratorsForIotHubSkuInfo is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIotHubSkuInfo(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.OneConstOf(
		IotHubSkuInfo_Name_B1,
		IotHubSkuInfo_Name_B2,
		IotHubSkuInfo_Name_B3,
		IotHubSkuInfo_Name_F1,
		IotHubSkuInfo_Name_S1,
		IotHubSkuInfo_Name_S2,
		IotHubSkuInfo_Name_S3))
}

func Test_IotHub_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IotHub_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIotHub_Spec, IotHub_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIotHub_Spec runs a test to see if a specific instance of IotHub_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForIotHub_Spec(subject IotHub_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IotHub_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IotHub_Spec instances for property testing - lazily instantiated by IotHub_SpecGenerator()
var iotHub_SpecGenerator gopter.Gen

// IotHub_SpecGenerator returns a generator of IotHub_Spec instances for property testing.
// We first initialize iotHub_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IotHub_SpecGenerator() gopter.Gen {
	if iotHub_SpecGenerator != nil {
		return iotHub_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIotHub_Spec(generators)
	iotHub_SpecGenerator = gen.Struct(reflect.TypeOf(IotHub_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIotHub_Spec(generators)
	AddRelatedPropertyGeneratorsForIotHub_Spec(generators)
	iotHub_SpecGenerator = gen.Struct(reflect.TypeOf(IotHub_Spec{}), generators)

	return iotHub_SpecGenerator
}

// AddIndependentPropertyGeneratorsForIotHub_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIotHub_Spec(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForIotHub_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIotHub_Spec(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ArmIdentityGenerator())
	gens["Properties"] = gen.PtrOf(IotHubPropertiesGenerator())
	gens["Sku"] = gen.PtrOf(IotHubSkuInfoGenerator())
}

func Test_IpFilterRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpFilterRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpFilterRule, IpFilterRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpFilterRule runs a test to see if a specific instance of IpFilterRule round trips to JSON and back losslessly
func RunJSONSerializationTestForIpFilterRule(subject IpFilterRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpFilterRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpFilterRule instances for property testing - lazily instantiated by IpFilterRuleGenerator()
var ipFilterRuleGenerator gopter.Gen

// IpFilterRuleGenerator returns a generator of IpFilterRule instances for property testing.
func IpFilterRuleGenerator() gopter.Gen {
	if ipFilterRuleGenerator != nil {
		return ipFilterRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpFilterRule(generators)
	ipFilterRuleGenerator = gen.Struct(reflect.TypeOf(IpFilterRule{}), generators)

	return ipFilterRuleGenerator
}

// AddIndependentPropertyGeneratorsForIpFilterRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpFilterRule(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(IpFilterRule_Action_Accept, IpFilterRule_Action_Reject))
	gens["FilterName"] = gen.PtrOf(gen.AlphaString())
	gens["IpMask"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedIdentity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedIdentity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedIdentity, ManagedIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedIdentity runs a test to see if a specific instance of ManagedIdentity round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedIdentity(subject ManagedIdentity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedIdentity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedIdentity instances for property testing - lazily instantiated by ManagedIdentityGenerator()
var managedIdentityGenerator gopter.Gen

// ManagedIdentityGenerator returns a generator of ManagedIdentity instances for property testing.
func ManagedIdentityGenerator() gopter.Gen {
	if managedIdentityGenerator != nil {
		return managedIdentityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedIdentity(generators)
	managedIdentityGenerator = gen.Struct(reflect.TypeOf(ManagedIdentity{}), generators)

	return managedIdentityGenerator
}

// AddIndependentPropertyGeneratorsForManagedIdentity is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedIdentity(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentity"] = gen.PtrOf(gen.AlphaString())
}

func Test_MessagingEndpointProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MessagingEndpointProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMessagingEndpointProperties, MessagingEndpointPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMessagingEndpointProperties runs a test to see if a specific instance of MessagingEndpointProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForMessagingEndpointProperties(subject MessagingEndpointProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MessagingEndpointProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MessagingEndpointProperties instances for property testing - lazily instantiated by
// MessagingEndpointPropertiesGenerator()
var messagingEndpointPropertiesGenerator gopter.Gen

// MessagingEndpointPropertiesGenerator returns a generator of MessagingEndpointProperties instances for property testing.
func MessagingEndpointPropertiesGenerator() gopter.Gen {
	if messagingEndpointPropertiesGenerator != nil {
		return messagingEndpointPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMessagingEndpointProperties(generators)
	messagingEndpointPropertiesGenerator = gen.Struct(reflect.TypeOf(MessagingEndpointProperties{}), generators)

	return messagingEndpointPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForMessagingEndpointProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMessagingEndpointProperties(gens map[string]gopter.Gen) {
	gens["LockDurationAsIso8601"] = gen.PtrOf(gen.AlphaString())
	gens["MaxDeliveryCount"] = gen.PtrOf(gen.Int())
	gens["TtlAsIso8601"] = gen.PtrOf(gen.AlphaString())
}

func Test_NetworkRuleSetIpRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkRuleSetIpRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkRuleSetIpRule, NetworkRuleSetIpRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkRuleSetIpRule runs a test to see if a specific instance of NetworkRuleSetIpRule round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkRuleSetIpRule(subject NetworkRuleSetIpRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkRuleSetIpRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkRuleSetIpRule instances for property testing - lazily instantiated by
// NetworkRuleSetIpRuleGenerator()
var networkRuleSetIpRuleGenerator gopter.Gen

// NetworkRuleSetIpRuleGenerator returns a generator of NetworkRuleSetIpRule instances for property testing.
func NetworkRuleSetIpRuleGenerator() gopter.Gen {
	if networkRuleSetIpRuleGenerator != nil {
		return networkRuleSetIpRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSetIpRule(generators)
	networkRuleSetIpRuleGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSetIpRule{}), generators)

	return networkRuleSetIpRuleGenerator
}

// AddIndependentPropertyGeneratorsForNetworkRuleSetIpRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkRuleSetIpRule(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(NetworkRuleSetIpRule_Action_Allow))
	gens["FilterName"] = gen.PtrOf(gen.AlphaString())
	gens["IpMask"] = gen.PtrOf(gen.AlphaString())
}

func Test_NetworkRuleSetProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkRuleSetProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkRuleSetProperties, NetworkRuleSetPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkRuleSetProperties runs a test to see if a specific instance of NetworkRuleSetProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkRuleSetProperties(subject NetworkRuleSetProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkRuleSetProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkRuleSetProperties instances for property testing - lazily instantiated by
// NetworkRuleSetPropertiesGenerator()
var networkRuleSetPropertiesGenerator gopter.Gen

// NetworkRuleSetPropertiesGenerator returns a generator of NetworkRuleSetProperties instances for property testing.
// We first initialize networkRuleSetPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkRuleSetPropertiesGenerator() gopter.Gen {
	if networkRuleSetPropertiesGenerator != nil {
		return networkRuleSetPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSetProperties(generators)
	networkRuleSetPropertiesGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSetProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSetProperties(generators)
	AddRelatedPropertyGeneratorsForNetworkRuleSetProperties(generators)
	networkRuleSetPropertiesGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSetProperties{}), generators)

	return networkRuleSetPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForNetworkRuleSetProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkRuleSetProperties(gens map[string]gopter.Gen) {
	gens["ApplyToBuiltInEventHubEndpoint"] = gen.PtrOf(gen.Bool())
	gens["DefaultAction"] = gen.PtrOf(gen.OneConstOf(NetworkRuleSetProperties_DefaultAction_Allow, NetworkRuleSetProperties_DefaultAction_Deny))
}

// AddRelatedPropertyGeneratorsForNetworkRuleSetProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkRuleSetProperties(gens map[string]gopter.Gen) {
	gens["IpRules"] = gen.SliceOf(NetworkRuleSetIpRuleGenerator())
}

func Test_RouteProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RouteProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRouteProperties, RoutePropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRouteProperties runs a test to see if a specific instance of RouteProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForRouteProperties(subject RouteProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RouteProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RouteProperties instances for property testing - lazily instantiated by RoutePropertiesGenerator()
var routePropertiesGenerator gopter.Gen

// RoutePropertiesGenerator returns a generator of RouteProperties instances for property testing.
func RoutePropertiesGenerator() gopter.Gen {
	if routePropertiesGenerator != nil {
		return routePropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRouteProperties(generators)
	routePropertiesGenerator = gen.Struct(reflect.TypeOf(RouteProperties{}), generators)

	return routePropertiesGenerator
}

// AddIndependentPropertyGeneratorsForRouteProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRouteProperties(gens map[string]gopter.Gen) {
	gens["Condition"] = gen.PtrOf(gen.AlphaString())
	gens["EndpointNames"] = gen.SliceOf(gen.AlphaString())
	gens["IsEnabled"] = gen.PtrOf(gen.Bool())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Source"] = gen.PtrOf(gen.OneConstOf(
		RouteProperties_Source_DeviceConnectionStateEvents,
		RouteProperties_Source_DeviceJobLifecycleEvents,
		RouteProperties_Source_DeviceLifecycleEvents,
		RouteProperties_Source_DeviceMessages,
		RouteProperties_Source_Invalid,
		RouteProperties_Source_TwinChangeEvents))
}

func Test_RoutingEndpoints_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingEndpoints via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingEndpoints, RoutingEndpointsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingEndpoints runs a test to see if a specific instance of RoutingEndpoints round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingEndpoints(subject RoutingEndpoints) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingEndpoints
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingEndpoints instances for property testing - lazily instantiated by RoutingEndpointsGenerator()
var routingEndpointsGenerator gopter.Gen

// RoutingEndpointsGenerator returns a generator of RoutingEndpoints instances for property testing.
func RoutingEndpointsGenerator() gopter.Gen {
	if routingEndpointsGenerator != nil {
		return routingEndpointsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForRoutingEndpoints(generators)
	routingEndpointsGenerator = gen.Struct(reflect.TypeOf(RoutingEndpoints{}), generators)

	return routingEndpointsGenerator
}

// AddRelatedPropertyGeneratorsForRoutingEndpoints is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRoutingEndpoints(gens map[string]gopter.Gen) {
	gens["EventHubs"] = gen.SliceOf(RoutingEventHubPropertiesGenerator())
	gens["ServiceBusQueues"] = gen.SliceOf(RoutingServiceBusQueueEndpointPropertiesGenerator())
	gens["ServiceBusTopics"] = gen.SliceOf(RoutingServiceBusTopicEndpointPropertiesGenerator())
	gens["StorageContainers"] = gen.SliceOf(RoutingStorageContainerPropertiesGenerator())
}

func Test_RoutingEventHubProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingEventHubProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingEventHubProperties, RoutingEventHubPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingEventHubProperties runs a test to see if a specific instance of RoutingEventHubProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingEventHubProperties(subject RoutingEventHubProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingEventHubProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingEventHubProperties instances for property testing - lazily instantiated by
// RoutingEventHubPropertiesGenerator()
var routingEventHubPropertiesGenerator gopter.Gen

// RoutingEventHubPropertiesGenerator returns a generator of RoutingEventHubProperties instances for property testing.
// We first initialize routingEventHubPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RoutingEventHubPropertiesGenerator() gopter.Gen {
	if routingEventHubPropertiesGenerator != nil {
		return routingEventHubPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingEventHubProperties(generators)
	routingEventHubPropertiesGenerator = gen.Struct(reflect.TypeOf(RoutingEventHubProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingEventHubProperties(generators)
	AddRelatedPropertyGeneratorsForRoutingEventHubProperties(generators)
	routingEventHubPropertiesGenerator = gen.Struct(reflect.TypeOf(RoutingEventHubProperties{}), generators)

	return routingEventHubPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForRoutingEventHubProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRoutingEventHubProperties(gens map[string]gopter.Gen) {
	gens["AuthenticationType"] = gen.PtrOf(gen.OneConstOf(RoutingEventHubProperties_AuthenticationType_IdentityBased, RoutingEventHubProperties_AuthenticationType_KeyBased))
	gens["ConnectionString"] = gen.PtrOf(gen.AlphaString())
	gens["EndpointUri"] = gen.PtrOf(gen.AlphaString())
	gens["EntityPath"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceGroup"] = gen.PtrOf(gen.AlphaString())
	gens["SubscriptionId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForRoutingEventHubProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRoutingEventHubProperties(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedIdentityGenerator())
}

func Test_RoutingProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingProperties, RoutingPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingProperties runs a test to see if a specific instance of RoutingProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingProperties(subject RoutingProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingProperties instances for property testing - lazily instantiated by RoutingPropertiesGenerator()
var routingPropertiesGenerator gopter.Gen

// RoutingPropertiesGenerator returns a generator of RoutingProperties instances for property testing.
func RoutingPropertiesGenerator() gopter.Gen {
	if routingPropertiesGenerator != nil {
		return routingPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForRoutingProperties(generators)
	routingPropertiesGenerator = gen.Struct(reflect.TypeOf(RoutingProperties{}), generators)

	return routingPropertiesGenerator
}

// AddRelatedPropertyGeneratorsForRoutingProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRoutingProperties(gens map[string]gopter.Gen) {
	gens["Endpoints"] = gen.PtrOf(RoutingEndpointsGenerator())
	gens["Enrichments"] = gen.SliceOf(EnrichmentPropertiesGenerator())
	gens["FallbackRoute"] = gen.PtrOf(FallbackRoutePropertiesGenerator())
	gens["Routes"] = gen.SliceOf(RoutePropertiesGenerator())
}

func Test_RoutingServiceBusQueueEndpointProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingServiceBusQueueEndpointProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingServiceBusQueueEndpointProperties, RoutingServiceBusQueueEndpointPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingServiceBusQueueEndpointProperties runs a test to see if a specific instance of RoutingServiceBusQueueEndpointProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingServiceBusQueueEndpointProperties(subject RoutingServiceBusQueueEndpointProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingServiceBusQueueEndpointProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingServiceBusQueueEndpointProperties instances for property testing - lazily instantiated by
// RoutingServiceBusQueueEndpointPropertiesGenerator()
var routingServiceBusQueueEndpointPropertiesGenerator gopter.Gen

// RoutingServiceBusQueueEndpointPropertiesGenerator returns a generator of RoutingServiceBusQueueEndpointProperties instances for property testing.
// We first initialize routingServiceBusQueueEndpointPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RoutingServiceBusQueueEndpointPropertiesGenerator() gopter.Gen {
	if routingServiceBusQueueEndpointPropertiesGenerator != nil {
		return routingServiceBusQueueEndpointPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingServiceBusQueueEndpointProperties(generators)
	routingServiceBusQueueEndpointPropertiesGenerator = gen.Struct(reflect.TypeOf(RoutingServiceBusQueueEndpointProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingServiceBusQueueEndpointProperties(generators)
	AddRelatedPropertyGeneratorsForRoutingServiceBusQueueEndpointProperties(generators)
	routingServiceBusQueueEndpointPropertiesGenerator = gen.Struct(reflect.TypeOf(RoutingServiceBusQueueEndpointProperties{}), generators)

	return routingServiceBusQueueEndpointPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForRoutingServiceBusQueueEndpointProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRoutingServiceBusQueueEndpointProperties(gens map[string]gopter.Gen) {
	gens["AuthenticationType"] = gen.PtrOf(gen.OneConstOf(RoutingServiceBusQueueEndpointProperties_AuthenticationType_IdentityBased, RoutingServiceBusQueueEndpointProperties_AuthenticationType_KeyBased))
	gens["ConnectionString"] = gen.PtrOf(gen.AlphaString())
	gens["EndpointUri"] = gen.PtrOf(gen.AlphaString())
	gens["EntityPath"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceGroup"] = gen.PtrOf(gen.AlphaString())
	gens["SubscriptionId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForRoutingServiceBusQueueEndpointProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRoutingServiceBusQueueEndpointProperties(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedIdentityGenerator())
}

func Test_RoutingServiceBusTopicEndpointProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingServiceBusTopicEndpointProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingServiceBusTopicEndpointProperties, RoutingServiceBusTopicEndpointPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingServiceBusTopicEndpointProperties runs a test to see if a specific instance of RoutingServiceBusTopicEndpointProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingServiceBusTopicEndpointProperties(subject RoutingServiceBusTopicEndpointProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingServiceBusTopicEndpointProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingServiceBusTopicEndpointProperties instances for property testing - lazily instantiated by
// RoutingServiceBusTopicEndpointPropertiesGenerator()
var routingServiceBusTopicEndpointPropertiesGenerator gopter.Gen

// RoutingServiceBusTopicEndpointPropertiesGenerator returns a generator of RoutingServiceBusTopicEndpointProperties instances for property testing.
// We first initialize routingServiceBusTopicEndpointPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RoutingServiceBusTopicEndpointPropertiesGenerator() gopter.Gen {
	if routingServiceBusTopicEndpointPropertiesGenerator != nil {
		return routingServiceBusTopicEndpointPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingServiceBusTopicEndpointProperties(generators)
	routingServiceBusTopicEndpointPropertiesGenerator = gen.Struct(reflect.TypeOf(RoutingServiceBusTopicEndpointProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingServiceBusTopicEndpointProperties(generators)
	AddRelatedPropertyGeneratorsForRoutingServiceBusTopicEndpointProperties(generators)
	routingServiceBusTopicEndpointPropertiesGenerator = gen.Struct(reflect.TypeOf(RoutingServiceBusTopicEndpointProperties{}), generators)

	return routingServiceBusTopicEndpointPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForRoutingServiceBusTopicEndpointProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRoutingServiceBusTopicEndpointProperties(gens map[string]gopter.Gen) {
	gens["AuthenticationType"] = gen.PtrOf(gen.OneConstOf(RoutingServiceBusTopicEndpointProperties_AuthenticationType_IdentityBased, RoutingServiceBusTopicEndpointProperties_AuthenticationType_KeyBased))
	gens["ConnectionString"] = gen.PtrOf(gen.AlphaString())
	gens["EndpointUri"] = gen.PtrOf(gen.AlphaString())
	gens["EntityPath"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceGroup"] = gen.PtrOf(gen.AlphaString())
	gens["SubscriptionId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForRoutingServiceBusTopicEndpointProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRoutingServiceBusTopicEndpointProperties(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedIdentityGenerator())
}

func Test_RoutingStorageContainerProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingStorageContainerProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingStorageContainerProperties, RoutingStorageContainerPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingStorageContainerProperties runs a test to see if a specific instance of RoutingStorageContainerProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingStorageContainerProperties(subject RoutingStorageContainerProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingStorageContainerProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingStorageContainerProperties instances for property testing - lazily instantiated by
// RoutingStorageContainerPropertiesGenerator()
var routingStorageContainerPropertiesGenerator gopter.Gen

// RoutingStorageContainerPropertiesGenerator returns a generator of RoutingStorageContainerProperties instances for property testing.
// We first initialize routingStorageContainerPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RoutingStorageContainerPropertiesGenerator() gopter.Gen {
	if routingStorageContainerPropertiesGenerator != nil {
		return routingStorageContainerPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingStorageContainerProperties(generators)
	routingStorageContainerPropertiesGenerator = gen.Struct(reflect.TypeOf(RoutingStorageContainerProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingStorageContainerProperties(generators)
	AddRelatedPropertyGeneratorsForRoutingStorageContainerProperties(generators)
	routingStorageContainerPropertiesGenerator = gen.Struct(reflect.TypeOf(RoutingStorageContainerProperties{}), generators)

	return routingStorageContainerPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForRoutingStorageContainerProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRoutingStorageContainerProperties(gens map[string]gopter.Gen) {
	gens["AuthenticationType"] = gen.PtrOf(gen.OneConstOf(RoutingStorageContainerProperties_AuthenticationType_IdentityBased, RoutingStorageContainerProperties_AuthenticationType_KeyBased))
	gens["BatchFrequencyInSeconds"] = gen.PtrOf(gen.Int())
	gens["ConnectionString"] = gen.PtrOf(gen.AlphaString())
	gens["ContainerName"] = gen.PtrOf(gen.AlphaString())
	gens["Encoding"] = gen.PtrOf(gen.OneConstOf(RoutingStorageContainerProperties_Encoding_Avro, RoutingStorageContainerProperties_Encoding_AvroDeflate, RoutingStorageContainerProperties_Encoding_JSON))
	gens["EndpointUri"] = gen.PtrOf(gen.AlphaString())
	gens["FileNameFormat"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["MaxChunkSizeInBytes"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceGroup"] = gen.PtrOf(gen.AlphaString())
	gens["SubscriptionId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForRoutingStorageContainerProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRoutingStorageContainerProperties(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedIdentityGenerator())
}

func Test_SharedAccessSignatureAuthorizationRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SharedAccessSignatureAuthorizationRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSharedAccessSignatureAuthorizationRule, SharedAccessSignatureAuthorizationRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSharedAccessSignatureAuthorizationRule runs a test to see if a specific instance of SharedAccessSignatureAuthorizationRule round trips to JSON and back losslessly
func RunJSONSerializationTestForSharedAccessSignatureAuthorizationRule(subject SharedAccessSignatureAuthorizationRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SharedAccessSignatureAuthorizationRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SharedAccessSignatureAuthorizationRule instances for property testing - lazily instantiated by
// SharedAccessSignatureAuthorizationRuleGenerator()
var sharedAccessSignatureAuthorizationRuleGenerator gopter.Gen

// SharedAccessSignatureAuthorizationRuleGenerator returns a generator of SharedAccessSignatureAuthorizationRule instances for property testing.
func SharedAccessSignatureAuthorizationRuleGenerator() gopter.Gen {
	if sharedAccessSignatureAuthorizationRuleGenerator != nil {
		return sharedAccessSignatureAuthorizationRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSharedAccessSignatureAuthorizationRule(generators)
	sharedAccessSignatureAuthorizationRuleGenerator = gen.Struct(reflect.TypeOf(SharedAccessSignatureAuthorizationRule{}), generators)

	return sharedAccessSignatureAuthorizationRuleGenerator
}

// AddIndependentPropertyGeneratorsForSharedAccessSignatureAuthorizationRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSharedAccessSignatureAuthorizationRule(gens map[string]gopter.Gen) {
	gens["KeyName"] = gen.PtrOf(gen.AlphaString())
	gens["Rights"] = gen.PtrOf(gen.OneConstOf(
		SharedAccessSignatureAuthorizationRule_Rights_DeviceConnect,
		SharedAccessSignatureAuthorizationRule_Rights_RegistryRead,
		SharedAccessSignatureAuthorizationRule_Rights_RegistryReadDeviceConnect,
		SharedAccessSignatureAuthorizationRule_Rights_RegistryReadRegistryWrite,
		SharedAccessSignatureAuthorizationRule_Rights_RegistryReadRegistryWriteDeviceConnect,
		SharedAccessSignatureAuthorizationRule_Rights_RegistryReadRegistryWriteServiceConnect,
		SharedAccessSignatureAuthorizationRule_Rights_RegistryReadRegistryWriteServiceConnectDeviceConnect,
		SharedAccessSignatureAuthorizationRule_Rights_RegistryReadServiceConnect,
		SharedAccessSignatureAuthorizationRule_Rights_RegistryReadServiceConnectDeviceConnect,
		SharedAccessSignatureAuthorizationRule_Rights_RegistryWrite,
		SharedAccessSignatureAuthorizationRule_Rights_RegistryWriteDeviceConnect,
		SharedAccessSignatureAuthorizationRule_Rights_RegistryWriteServiceConnect,
		SharedAccessSignatureAuthorizationRule_Rights_RegistryWriteServiceConnectDeviceConnect,
		SharedAccessSignatureAuthorizationRule_Rights_ServiceConnect,
		SharedAccessSignatureAuthorizationRule_Rights_ServiceConnectDeviceConnect))
}

func Test_StorageEndpointProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageEndpointProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageEndpointProperties, StorageEndpointPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageEndpointProperties runs a test to see if a specific instance of StorageEndpointProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageEndpointProperties(subject StorageEndpointProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageEndpointProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageEndpointProperties instances for property testing - lazily instantiated by
// StorageEndpointPropertiesGenerator()
var storageEndpointPropertiesGenerator gopter.Gen

// StorageEndpointPropertiesGenerator returns a generator of StorageEndpointProperties instances for property testing.
// We first initialize storageEndpointPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func StorageEndpointPropertiesGenerator() gopter.Gen {
	if storageEndpointPropertiesGenerator != nil {
		return storageEndpointPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageEndpointProperties(generators)
	storageEndpointPropertiesGenerator = gen.Struct(reflect.TypeOf(StorageEndpointProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageEndpointProperties(generators)
	AddRelatedPropertyGeneratorsForStorageEndpointProperties(generators)
	storageEndpointPropertiesGenerator = gen.Struct(reflect.TypeOf(StorageEndpointProperties{}), generators)

	return storageEndpointPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForStorageEndpointProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageEndpointProperties(gens map[string]gopter.Gen) {
	gens["AuthenticationType"] = gen.PtrOf(gen.OneConstOf(StorageEndpointProperties_AuthenticationType_IdentityBased, StorageEndpointProperties_AuthenticationType_KeyBased))
	gens["ConnectionString"] = gen.PtrOf(gen.AlphaString())
	gens["ContainerName"] = gen.PtrOf(gen.AlphaString())
	gens["SasTtlAsIso8601"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForStorageEndpointProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageEndpointProperties(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedIdentityGenerator())
}

func Test_UserAssignedIdentityDetails_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentityDetails via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentityDetails, UserAssignedIdentityDetailsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentityDetails runs a test to see if a specific instance of UserAssignedIdentityDetails round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentityDetails(subject UserAssignedIdentityDetails) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentityDetails
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentityDetails instances for property testing - lazily instantiated by
// UserAssignedIdentityDetailsGenerator()
var userAssignedIdentityDetailsGenerator gopter.Gen

// UserAssignedIdentityDetailsGenerator returns a generator of UserAssignedIdentityDetails instances for property testing.
func UserAssignedIdentityDetailsGenerator() gopter.Gen {
	if userAssignedIdentityDetailsGenerator != nil {
		return userAssignedIdentityDetailsGenerator
	}

	generators := make(map[string]gopter.Gen)
	userAssignedIdentityDetailsGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentityDetails{}), generators)

	return userAssignedIdentityDetailsGenerator
}
