// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package storage

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_IotHub_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IotHub via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIotHub, IotHubGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIotHub runs a test to see if a specific instance of IotHub round trips to JSON and back losslessly
func RunJSONSerializationTestForIotHub(subject IotHub) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IotHub
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IotHub instances for property testing - lazily instantiated by IotHubGenerator()
var iotHubGenerator gopter.Gen

// IotHubGenerator returns a generator of IotHub instances for property testing.
func IotHubGenerator() gopter.Gen {
	if iotHubGenerator != nil {
		return iotHubGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForIotHub(generators)
	iotHubGenerator = gen.Struct(reflect.TypeOf(IotHub{}), generators)

	return iotHubGenerator
}

// AddRelatedPropertyGeneratorsForIotHub is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIotHub(gens map[string]gopter.Gen) {
	gens["Spec"] = IotHub_SpecGenerator()
	gens["Status"] = IotHub_STATUSGenerator()
}

func Test_IotHub_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IotHub_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIotHub_Spec, IotHub_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIotHub_Spec runs a test to see if a specific instance of IotHub_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForIotHub_Spec(subject IotHub_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IotHub_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IotHub_Spec instances for property testing - lazily instantiated by IotHub_SpecGenerator()
var iotHub_SpecGenerator gopter.Gen

// IotHub_SpecGenerator returns a generator of IotHub_Spec instances for property testing.
// We first initialize iotHub_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IotHub_SpecGenerator() gopter.Gen {
	if iotHub_SpecGenerator != nil {
		return iotHub_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIotHub_Spec(generators)
	iotHub_SpecGenerator = gen.Struct(reflect.TypeOf(IotHub_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIotHub_Spec(generators)
	AddRelatedPropertyGeneratorsForIotHub_Spec(generators)
	iotHub_SpecGenerator = gen.Struct(reflect.TypeOf(IotHub_Spec{}), generators)

	return iotHub_SpecGenerator
}

// AddIndependentPropertyGeneratorsForIotHub_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIotHub_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["OriginalVersion"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForIotHub_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIotHub_Spec(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ArmIdentityGenerator())
	gens["OperatorSpec"] = gen.PtrOf(IotHubOperatorSpecGenerator())
	gens["Properties"] = gen.PtrOf(IotHubPropertiesGenerator())
	gens["Sku"] = gen.PtrOf(IotHubSkuInfoGenerator())
}

func Test_IotHub_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IotHub_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIotHub_STATUS, IotHub_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIotHub_STATUS runs a test to see if a specific instance of IotHub_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForIotHub_STATUS(subject IotHub_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IotHub_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IotHub_STATUS instances for property testing - lazily instantiated by IotHub_STATUSGenerator()
var iotHub_STATUSGenerator gopter.Gen

// IotHub_STATUSGenerator returns a generator of IotHub_STATUS instances for property testing.
// We first initialize iotHub_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IotHub_STATUSGenerator() gopter.Gen {
	if iotHub_STATUSGenerator != nil {
		return iotHub_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIotHub_STATUS(generators)
	iotHub_STATUSGenerator = gen.Struct(reflect.TypeOf(IotHub_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIotHub_STATUS(generators)
	AddRelatedPropertyGeneratorsForIotHub_STATUS(generators)
	iotHub_STATUSGenerator = gen.Struct(reflect.TypeOf(IotHub_STATUS{}), generators)

	return iotHub_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForIotHub_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIotHub_STATUS(gens map[string]gopter.Gen) {
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForIotHub_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIotHub_STATUS(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ArmIdentity_STATUSGenerator())
	gens["Properties"] = gen.PtrOf(IotHubProperties_STATUSGenerator())
	gens["Sku"] = gen.PtrOf(IotHubSkuInfo_STATUSGenerator())
	gens["SystemData"] = gen.PtrOf(SystemData_STATUSGenerator())
}

func Test_ArmIdentity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ArmIdentity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForArmIdentity, ArmIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForArmIdentity runs a test to see if a specific instance of ArmIdentity round trips to JSON and back losslessly
func RunJSONSerializationTestForArmIdentity(subject ArmIdentity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ArmIdentity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ArmIdentity instances for property testing - lazily instantiated by ArmIdentityGenerator()
var armIdentityGenerator gopter.Gen

// ArmIdentityGenerator returns a generator of ArmIdentity instances for property testing.
// We first initialize armIdentityGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ArmIdentityGenerator() gopter.Gen {
	if armIdentityGenerator != nil {
		return armIdentityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForArmIdentity(generators)
	armIdentityGenerator = gen.Struct(reflect.TypeOf(ArmIdentity{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForArmIdentity(generators)
	AddRelatedPropertyGeneratorsForArmIdentity(generators)
	armIdentityGenerator = gen.Struct(reflect.TypeOf(ArmIdentity{}), generators)

	return armIdentityGenerator
}

// AddIndependentPropertyGeneratorsForArmIdentity is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForArmIdentity(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForArmIdentity is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForArmIdentity(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.SliceOf(UserAssignedIdentityDetailsGenerator())
}

func Test_ArmIdentity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ArmIdentity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForArmIdentity_STATUS, ArmIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForArmIdentity_STATUS runs a test to see if a specific instance of ArmIdentity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForArmIdentity_STATUS(subject ArmIdentity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ArmIdentity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ArmIdentity_STATUS instances for property testing - lazily instantiated by ArmIdentity_STATUSGenerator()
var armIdentity_STATUSGenerator gopter.Gen

// ArmIdentity_STATUSGenerator returns a generator of ArmIdentity_STATUS instances for property testing.
// We first initialize armIdentity_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ArmIdentity_STATUSGenerator() gopter.Gen {
	if armIdentity_STATUSGenerator != nil {
		return armIdentity_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForArmIdentity_STATUS(generators)
	armIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(ArmIdentity_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForArmIdentity_STATUS(generators)
	AddRelatedPropertyGeneratorsForArmIdentity_STATUS(generators)
	armIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(ArmIdentity_STATUS{}), generators)

	return armIdentity_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForArmIdentity_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForArmIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForArmIdentity_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForArmIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), ArmUserIdentity_STATUSGenerator())
}

func Test_IotHubOperatorSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IotHubOperatorSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIotHubOperatorSpec, IotHubOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIotHubOperatorSpec runs a test to see if a specific instance of IotHubOperatorSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForIotHubOperatorSpec(subject IotHubOperatorSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IotHubOperatorSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IotHubOperatorSpec instances for property testing - lazily instantiated by IotHubOperatorSpecGenerator()
var iotHubOperatorSpecGenerator gopter.Gen

// IotHubOperatorSpecGenerator returns a generator of IotHubOperatorSpec instances for property testing.
func IotHubOperatorSpecGenerator() gopter.Gen {
	if iotHubOperatorSpecGenerator != nil {
		return iotHubOperatorSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForIotHubOperatorSpec(generators)
	iotHubOperatorSpecGenerator = gen.Struct(reflect.TypeOf(IotHubOperatorSpec{}), generators)

	return iotHubOperatorSpecGenerator
}

// AddRelatedPropertyGeneratorsForIotHubOperatorSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIotHubOperatorSpec(gens map[string]gopter.Gen) {
	gens["Secrets"] = gen.PtrOf(IotHubOperatorSecretsGenerator())
}

func Test_IotHubProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IotHubProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIotHubProperties, IotHubPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIotHubProperties runs a test to see if a specific instance of IotHubProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForIotHubProperties(subject IotHubProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IotHubProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IotHubProperties instances for property testing - lazily instantiated by IotHubPropertiesGenerator()
var iotHubPropertiesGenerator gopter.Gen

// IotHubPropertiesGenerator returns a generator of IotHubProperties instances for property testing.
// We first initialize iotHubPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IotHubPropertiesGenerator() gopter.Gen {
	if iotHubPropertiesGenerator != nil {
		return iotHubPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIotHubProperties(generators)
	iotHubPropertiesGenerator = gen.Struct(reflect.TypeOf(IotHubProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIotHubProperties(generators)
	AddRelatedPropertyGeneratorsForIotHubProperties(generators)
	iotHubPropertiesGenerator = gen.Struct(reflect.TypeOf(IotHubProperties{}), generators)

	return iotHubPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForIotHubProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIotHubProperties(gens map[string]gopter.Gen) {
	gens["AllowedFqdnList"] = gen.SliceOf(gen.AlphaString())
	gens["Comments"] = gen.PtrOf(gen.AlphaString())
	gens["DisableDeviceSAS"] = gen.PtrOf(gen.Bool())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["DisableModuleSAS"] = gen.PtrOf(gen.Bool())
	gens["EnableDataResidency"] = gen.PtrOf(gen.Bool())
	gens["EnableFileUploadNotifications"] = gen.PtrOf(gen.Bool())
	gens["Features"] = gen.PtrOf(gen.AlphaString())
	gens["MinTlsVersion"] = gen.PtrOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.AlphaString())
	gens["RestrictOutboundNetworkAccess"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForIotHubProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIotHubProperties(gens map[string]gopter.Gen) {
	gens["AuthorizationPolicies"] = gen.SliceOf(SharedAccessSignatureAuthorizationRuleGenerator())
	gens["CloudToDevice"] = gen.PtrOf(CloudToDevicePropertiesGenerator())
	gens["EventHubEndpoints"] = gen.MapOf(gen.AlphaString(), EventHubPropertiesGenerator())
	gens["IpFilterRules"] = gen.SliceOf(IpFilterRuleGenerator())
	gens["MessagingEndpoints"] = gen.MapOf(gen.AlphaString(), MessagingEndpointPropertiesGenerator())
	gens["NetworkRuleSets"] = gen.PtrOf(NetworkRuleSetPropertiesGenerator())
	gens["Routing"] = gen.PtrOf(RoutingPropertiesGenerator())
	gens["StorageEndpoints"] = gen.MapOf(gen.AlphaString(), StorageEndpointPropertiesGenerator())
}

func Test_IotHubProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IotHubProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIotHubProperties_STATUS, IotHubProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIotHubProperties_STATUS runs a test to see if a specific instance of IotHubProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForIotHubProperties_STATUS(subject IotHubProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IotHubProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IotHubProperties_STATUS instances for property testing - lazily instantiated by
// IotHubProperties_STATUSGenerator()
var iotHubProperties_STATUSGenerator gopter.Gen

// IotHubProperties_STATUSGenerator returns a generator of IotHubProperties_STATUS instances for property testing.
// We first initialize iotHubProperties_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IotHubProperties_STATUSGenerator() gopter.Gen {
	if iotHubProperties_STATUSGenerator != nil {
		return iotHubProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIotHubProperties_STATUS(generators)
	iotHubProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(IotHubProperties_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIotHubProperties_STATUS(generators)
	AddRelatedPropertyGeneratorsForIotHubProperties_STATUS(generators)
	iotHubProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(IotHubProperties_STATUS{}), generators)

	return iotHubProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForIotHubProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIotHubProperties_STATUS(gens map[string]gopter.Gen) {
	gens["AllowedFqdnList"] = gen.SliceOf(gen.AlphaString())
	gens["Comments"] = gen.PtrOf(gen.AlphaString())
	gens["DisableDeviceSAS"] = gen.PtrOf(gen.Bool())
	gens["DisableLocalAuth"] = gen.PtrOf(gen.Bool())
	gens["DisableModuleSAS"] = gen.PtrOf(gen.Bool())
	gens["EnableDataResidency"] = gen.PtrOf(gen.Bool())
	gens["EnableFileUploadNotifications"] = gen.PtrOf(gen.Bool())
	gens["Features"] = gen.PtrOf(gen.AlphaString())
	gens["HostName"] = gen.PtrOf(gen.AlphaString())
	gens["MinTlsVersion"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.AlphaString())
	gens["RestrictOutboundNetworkAccess"] = gen.PtrOf(gen.Bool())
	gens["State"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForIotHubProperties_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIotHubProperties_STATUS(gens map[string]gopter.Gen) {
	gens["AuthorizationPolicies"] = gen.SliceOf(SharedAccessSignatureAuthorizationRule_STATUSGenerator())
	gens["CloudToDevice"] = gen.PtrOf(CloudToDeviceProperties_STATUSGenerator())
	gens["EventHubEndpoints"] = gen.MapOf(gen.AlphaString(), EventHubProperties_STATUSGenerator())
	gens["IpFilterRules"] = gen.SliceOf(IpFilterRule_STATUSGenerator())
	gens["Locations"] = gen.SliceOf(IotHubLocationDescription_STATUSGenerator())
	gens["MessagingEndpoints"] = gen.MapOf(gen.AlphaString(), MessagingEndpointProperties_STATUSGenerator())
	gens["NetworkRuleSets"] = gen.PtrOf(NetworkRuleSetProperties_STATUSGenerator())
	gens["PrivateEndpointConnections"] = gen.SliceOf(PrivateEndpointConnection_STATUSGenerator())
	gens["Routing"] = gen.PtrOf(RoutingProperties_STATUSGenerator())
	gens["StorageEndpoints"] = gen.MapOf(gen.AlphaString(), StorageEndpointProperties_STATUSGenerator())
}

func Test_IotHubSkuInfo_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IotHubSkuInfo via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIotHubSkuInfo, IotHubSkuInfoGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIotHubSkuInfo runs a test to see if a specific instance of IotHubSkuInfo round trips to JSON and back losslessly
func RunJSONSerializationTestForIotHubSkuInfo(subject IotHubSkuInfo) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IotHubSkuInfo
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IotHubSkuInfo instances for property testing - lazily instantiated by IotHubSkuInfoGenerator()
var iotHubSkuInfoGenerator gopter.Gen

// IotHubSkuInfoGenerator returns a generator of IotHubSkuInfo instances for property testing.
func IotHubSkuInfoGenerator() gopter.Gen {
	if iotHubSkuInfoGenerator != nil {
		return iotHubSkuInfoGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIotHubSkuInfo(generators)
	iotHubSkuInfoGenerator = gen.Struct(reflect.TypeOf(IotHubSkuInfo{}), generators)

	return iotHubSkuInfoGenerator
}

// AddIndependentPropertyGeneratorsForIotHubSkuInfo is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIotHubSkuInfo(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_IotHubSkuInfo_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IotHubSkuInfo_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIotHubSkuInfo_STATUS, IotHubSkuInfo_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIotHubSkuInfo_STATUS runs a test to see if a specific instance of IotHubSkuInfo_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForIotHubSkuInfo_STATUS(subject IotHubSkuInfo_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IotHubSkuInfo_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IotHubSkuInfo_STATUS instances for property testing - lazily instantiated by
// IotHubSkuInfo_STATUSGenerator()
var iotHubSkuInfo_STATUSGenerator gopter.Gen

// IotHubSkuInfo_STATUSGenerator returns a generator of IotHubSkuInfo_STATUS instances for property testing.
func IotHubSkuInfo_STATUSGenerator() gopter.Gen {
	if iotHubSkuInfo_STATUSGenerator != nil {
		return iotHubSkuInfo_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIotHubSkuInfo_STATUS(generators)
	iotHubSkuInfo_STATUSGenerator = gen.Struct(reflect.TypeOf(IotHubSkuInfo_STATUS{}), generators)

	return iotHubSkuInfo_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForIotHubSkuInfo_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIotHubSkuInfo_STATUS(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
}

func Test_SystemData_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SystemData_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSystemData_STATUS, SystemData_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSystemData_STATUS runs a test to see if a specific instance of SystemData_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSystemData_STATUS(subject SystemData_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SystemData_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SystemData_STATUS instances for property testing - lazily instantiated by SystemData_STATUSGenerator()
var systemData_STATUSGenerator gopter.Gen

// SystemData_STATUSGenerator returns a generator of SystemData_STATUS instances for property testing.
func SystemData_STATUSGenerator() gopter.Gen {
	if systemData_STATUSGenerator != nil {
		return systemData_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSystemData_STATUS(generators)
	systemData_STATUSGenerator = gen.Struct(reflect.TypeOf(SystemData_STATUS{}), generators)

	return systemData_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSystemData_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSystemData_STATUS(gens map[string]gopter.Gen) {
	gens["CreatedAt"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedBy"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedByType"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedAt"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedBy"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedByType"] = gen.PtrOf(gen.AlphaString())
}

func Test_ArmUserIdentity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ArmUserIdentity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForArmUserIdentity_STATUS, ArmUserIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForArmUserIdentity_STATUS runs a test to see if a specific instance of ArmUserIdentity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForArmUserIdentity_STATUS(subject ArmUserIdentity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ArmUserIdentity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ArmUserIdentity_STATUS instances for property testing - lazily instantiated by
// ArmUserIdentity_STATUSGenerator()
var armUserIdentity_STATUSGenerator gopter.Gen

// ArmUserIdentity_STATUSGenerator returns a generator of ArmUserIdentity_STATUS instances for property testing.
func ArmUserIdentity_STATUSGenerator() gopter.Gen {
	if armUserIdentity_STATUSGenerator != nil {
		return armUserIdentity_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForArmUserIdentity_STATUS(generators)
	armUserIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(ArmUserIdentity_STATUS{}), generators)

	return armUserIdentity_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForArmUserIdentity_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForArmUserIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_CloudToDeviceProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CloudToDeviceProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCloudToDeviceProperties, CloudToDevicePropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCloudToDeviceProperties runs a test to see if a specific instance of CloudToDeviceProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForCloudToDeviceProperties(subject CloudToDeviceProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CloudToDeviceProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CloudToDeviceProperties instances for property testing - lazily instantiated by
// CloudToDevicePropertiesGenerator()
var cloudToDevicePropertiesGenerator gopter.Gen

// CloudToDevicePropertiesGenerator returns a generator of CloudToDeviceProperties instances for property testing.
// We first initialize cloudToDevicePropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CloudToDevicePropertiesGenerator() gopter.Gen {
	if cloudToDevicePropertiesGenerator != nil {
		return cloudToDevicePropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCloudToDeviceProperties(generators)
	cloudToDevicePropertiesGenerator = gen.Struct(reflect.TypeOf(CloudToDeviceProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCloudToDeviceProperties(generators)
	AddRelatedPropertyGeneratorsForCloudToDeviceProperties(generators)
	cloudToDevicePropertiesGenerator = gen.Struct(reflect.TypeOf(CloudToDeviceProperties{}), generators)

	return cloudToDevicePropertiesGenerator
}

// AddIndependentPropertyGeneratorsForCloudToDeviceProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCloudToDeviceProperties(gens map[string]gopter.Gen) {
	gens["DefaultTtlAsIso8601"] = gen.PtrOf(gen.AlphaString())
	gens["MaxDeliveryCount"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForCloudToDeviceProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCloudToDeviceProperties(gens map[string]gopter.Gen) {
	gens["Feedback"] = gen.PtrOf(FeedbackPropertiesGenerator())
}

func Test_CloudToDeviceProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CloudToDeviceProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCloudToDeviceProperties_STATUS, CloudToDeviceProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCloudToDeviceProperties_STATUS runs a test to see if a specific instance of CloudToDeviceProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForCloudToDeviceProperties_STATUS(subject CloudToDeviceProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CloudToDeviceProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CloudToDeviceProperties_STATUS instances for property testing - lazily instantiated by
// CloudToDeviceProperties_STATUSGenerator()
var cloudToDeviceProperties_STATUSGenerator gopter.Gen

// CloudToDeviceProperties_STATUSGenerator returns a generator of CloudToDeviceProperties_STATUS instances for property testing.
// We first initialize cloudToDeviceProperties_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CloudToDeviceProperties_STATUSGenerator() gopter.Gen {
	if cloudToDeviceProperties_STATUSGenerator != nil {
		return cloudToDeviceProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCloudToDeviceProperties_STATUS(generators)
	cloudToDeviceProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(CloudToDeviceProperties_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCloudToDeviceProperties_STATUS(generators)
	AddRelatedPropertyGeneratorsForCloudToDeviceProperties_STATUS(generators)
	cloudToDeviceProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(CloudToDeviceProperties_STATUS{}), generators)

	return cloudToDeviceProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForCloudToDeviceProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCloudToDeviceProperties_STATUS(gens map[string]gopter.Gen) {
	gens["DefaultTtlAsIso8601"] = gen.PtrOf(gen.AlphaString())
	gens["MaxDeliveryCount"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForCloudToDeviceProperties_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCloudToDeviceProperties_STATUS(gens map[string]gopter.Gen) {
	gens["Feedback"] = gen.PtrOf(FeedbackProperties_STATUSGenerator())
}

func Test_EventHubProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventHubProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventHubProperties, EventHubPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventHubProperties runs a test to see if a specific instance of EventHubProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForEventHubProperties(subject EventHubProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventHubProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventHubProperties instances for property testing - lazily instantiated by EventHubPropertiesGenerator()
var eventHubPropertiesGenerator gopter.Gen

// EventHubPropertiesGenerator returns a generator of EventHubProperties instances for property testing.
func EventHubPropertiesGenerator() gopter.Gen {
	if eventHubPropertiesGenerator != nil {
		return eventHubPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventHubProperties(generators)
	eventHubPropertiesGenerator = gen.Struct(reflect.TypeOf(EventHubProperties{}), generators)

	return eventHubPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForEventHubProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventHubProperties(gens map[string]gopter.Gen) {
	gens["PartitionCount"] = gen.PtrOf(gen.Int())
	gens["RetentionTimeInDays"] = gen.PtrOf(gen.Int())
}

func Test_EventHubProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventHubProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventHubProperties_STATUS, EventHubProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventHubProperties_STATUS runs a test to see if a specific instance of EventHubProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEventHubProperties_STATUS(subject EventHubProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventHubProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventHubProperties_STATUS instances for property testing - lazily instantiated by
// EventHubProperties_STATUSGenerator()
var eventHubProperties_STATUSGenerator gopter.Gen

// EventHubProperties_STATUSGenerator returns a generator of EventHubProperties_STATUS instances for property testing.
func EventHubProperties_STATUSGenerator() gopter.Gen {
	if eventHubProperties_STATUSGenerator != nil {
		return eventHubProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventHubProperties_STATUS(generators)
	eventHubProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(EventHubProperties_STATUS{}), generators)

	return eventHubProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForEventHubProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventHubProperties_STATUS(gens map[string]gopter.Gen) {
	gens["Endpoint"] = gen.PtrOf(gen.AlphaString())
	gens["PartitionCount"] = gen.PtrOf(gen.Int())
	gens["PartitionIds"] = gen.SliceOf(gen.AlphaString())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["RetentionTimeInDays"] = gen.PtrOf(gen.Int())
}

func Test_IotHubLocationDescription_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IotHubLocationDescription_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIotHubLocationDescription_STATUS, IotHubLocationDescription_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIotHubLocationDescription_STATUS runs a test to see if a specific instance of IotHubLocationDescription_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForIotHubLocationDescription_STATUS(subject IotHubLocationDescription_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IotHubLocationDescription_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IotHubLocationDescription_STATUS instances for property testing - lazily instantiated by
// IotHubLocationDescription_STATUSGenerator()
var iotHubLocationDescription_STATUSGenerator gopter.Gen

// IotHubLocationDescription_STATUSGenerator returns a generator of IotHubLocationDescription_STATUS instances for property testing.
func IotHubLocationDescription_STATUSGenerator() gopter.Gen {
	if iotHubLocationDescription_STATUSGenerator != nil {
		return iotHubLocationDescription_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIotHubLocationDescription_STATUS(generators)
	iotHubLocationDescription_STATUSGenerator = gen.Struct(reflect.TypeOf(IotHubLocationDescription_STATUS{}), generators)

	return iotHubLocationDescription_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForIotHubLocationDescription_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIotHubLocationDescription_STATUS(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Role"] = gen.PtrOf(gen.AlphaString())
}

func Test_IotHubOperatorSecrets_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IotHubOperatorSecrets via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIotHubOperatorSecrets, IotHubOperatorSecretsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIotHubOperatorSecrets runs a test to see if a specific instance of IotHubOperatorSecrets round trips to JSON and back losslessly
func RunJSONSerializationTestForIotHubOperatorSecrets(subject IotHubOperatorSecrets) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IotHubOperatorSecrets
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IotHubOperatorSecrets instances for property testing - lazily instantiated by
// IotHubOperatorSecretsGenerator()
var iotHubOperatorSecretsGenerator gopter.Gen

// IotHubOperatorSecretsGenerator returns a generator of IotHubOperatorSecrets instances for property testing.
func IotHubOperatorSecretsGenerator() gopter.Gen {
	if iotHubOperatorSecretsGenerator != nil {
		return iotHubOperatorSecretsGenerator
	}

	generators := make(map[string]gopter.Gen)
	iotHubOperatorSecretsGenerator = gen.Struct(reflect.TypeOf(IotHubOperatorSecrets{}), generators)

	return iotHubOperatorSecretsGenerator
}

func Test_IpFilterRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpFilterRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpFilterRule, IpFilterRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpFilterRule runs a test to see if a specific instance of IpFilterRule round trips to JSON and back losslessly
func RunJSONSerializationTestForIpFilterRule(subject IpFilterRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpFilterRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpFilterRule instances for property testing - lazily instantiated by IpFilterRuleGenerator()
var ipFilterRuleGenerator gopter.Gen

// IpFilterRuleGenerator returns a generator of IpFilterRule instances for property testing.
func IpFilterRuleGenerator() gopter.Gen {
	if ipFilterRuleGenerator != nil {
		return ipFilterRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpFilterRule(generators)
	ipFilterRuleGenerator = gen.Struct(reflect.TypeOf(IpFilterRule{}), generators)

	return ipFilterRuleGenerator
}

// AddIndependentPropertyGeneratorsForIpFilterRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpFilterRule(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.AlphaString())
	gens["FilterName"] = gen.PtrOf(gen.AlphaString())
	gens["IpMask"] = gen.PtrOf(gen.AlphaString())
}

func Test_IpFilterRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpFilterRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpFilterRule_STATUS, IpFilterRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpFilterRule_STATUS runs a test to see if a specific instance of IpFilterRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForIpFilterRule_STATUS(subject IpFilterRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpFilterRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpFilterRule_STATUS instances for property testing - lazily instantiated by
// IpFilterRule_STATUSGenerator()
var ipFilterRule_STATUSGenerator gopter.Gen

// IpFilterRule_STATUSGenerator returns a generator of IpFilterRule_STATUS instances for property testing.
func IpFilterRule_STATUSGenerator() gopter.Gen {
	if ipFilterRule_STATUSGenerator != nil {
		return ipFilterRule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpFilterRule_STATUS(generators)
	ipFilterRule_STATUSGenerator = gen.Struct(reflect.TypeOf(IpFilterRule_STATUS{}), generators)

	return ipFilterRule_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForIpFilterRule_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpFilterRule_STATUS(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.AlphaString())
	gens["FilterName"] = gen.PtrOf(gen.AlphaString())
	gens["IpMask"] = gen.PtrOf(gen.AlphaString())
}

func Test_MessagingEndpointProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MessagingEndpointProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMessagingEndpointProperties, MessagingEndpointPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMessagingEndpointProperties runs a test to see if a specific instance of MessagingEndpointProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForMessagingEndpointProperties(subject MessagingEndpointProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MessagingEndpointProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MessagingEndpointProperties instances for property testing - lazily instantiated by
// MessagingEndpointPropertiesGenerator()
var messagingEndpointPropertiesGenerator gopter.Gen

// MessagingEndpointPropertiesGenerator returns a generator of MessagingEndpointProperties instances for property testing.
func MessagingEndpointPropertiesGenerator() gopter.Gen {
	if messagingEndpointPropertiesGenerator != nil {
		return messagingEndpointPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMessagingEndpointProperties(generators)
	messagingEndpointPropertiesGenerator = gen.Struct(reflect.TypeOf(MessagingEndpointProperties{}), generators)

	return messagingEndpointPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForMessagingEndpointProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMessagingEndpointProperties(gens map[string]gopter.Gen) {
	gens["LockDurationAsIso8601"] = gen.PtrOf(gen.AlphaString())
	gens["MaxDeliveryCount"] = gen.PtrOf(gen.Int())
	gens["TtlAsIso8601"] = gen.PtrOf(gen.AlphaString())
}

func Test_MessagingEndpointProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MessagingEndpointProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMessagingEndpointProperties_STATUS, MessagingEndpointProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMessagingEndpointProperties_STATUS runs a test to see if a specific instance of MessagingEndpointProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForMessagingEndpointProperties_STATUS(subject MessagingEndpointProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MessagingEndpointProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MessagingEndpointProperties_STATUS instances for property testing - lazily instantiated by
// MessagingEndpointProperties_STATUSGenerator()
var messagingEndpointProperties_STATUSGenerator gopter.Gen

// MessagingEndpointProperties_STATUSGenerator returns a generator of MessagingEndpointProperties_STATUS instances for property testing.
func MessagingEndpointProperties_STATUSGenerator() gopter.Gen {
	if messagingEndpointProperties_STATUSGenerator != nil {
		return messagingEndpointProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMessagingEndpointProperties_STATUS(generators)
	messagingEndpointProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(MessagingEndpointProperties_STATUS{}), generators)

	return messagingEndpointProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForMessagingEndpointProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMessagingEndpointProperties_STATUS(gens map[string]gopter.Gen) {
	gens["LockDurationAsIso8601"] = gen.PtrOf(gen.AlphaString())
	gens["MaxDeliveryCount"] = gen.PtrOf(gen.Int())
	gens["TtlAsIso8601"] = gen.PtrOf(gen.AlphaString())
}

func Test_NetworkRuleSetProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkRuleSetProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkRuleSetProperties, NetworkRuleSetPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkRuleSetProperties runs a test to see if a specific instance of NetworkRuleSetProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkRuleSetProperties(subject NetworkRuleSetProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkRuleSetProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkRuleSetProperties instances for property testing - lazily instantiated by
// NetworkRuleSetPropertiesGenerator()
var networkRuleSetPropertiesGenerator gopter.Gen

// NetworkRuleSetPropertiesGenerator returns a generator of NetworkRuleSetProperties instances for property testing.
// We first initialize networkRuleSetPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkRuleSetPropertiesGenerator() gopter.Gen {
	if networkRuleSetPropertiesGenerator != nil {
		return networkRuleSetPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSetProperties(generators)
	networkRuleSetPropertiesGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSetProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSetProperties(generators)
	AddRelatedPropertyGeneratorsForNetworkRuleSetProperties(generators)
	networkRuleSetPropertiesGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSetProperties{}), generators)

	return networkRuleSetPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForNetworkRuleSetProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkRuleSetProperties(gens map[string]gopter.Gen) {
	gens["ApplyToBuiltInEventHubEndpoint"] = gen.PtrOf(gen.Bool())
	gens["DefaultAction"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNetworkRuleSetProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkRuleSetProperties(gens map[string]gopter.Gen) {
	gens["IpRules"] = gen.SliceOf(NetworkRuleSetIpRuleGenerator())
}

func Test_NetworkRuleSetProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkRuleSetProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkRuleSetProperties_STATUS, NetworkRuleSetProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkRuleSetProperties_STATUS runs a test to see if a specific instance of NetworkRuleSetProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkRuleSetProperties_STATUS(subject NetworkRuleSetProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkRuleSetProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkRuleSetProperties_STATUS instances for property testing - lazily instantiated by
// NetworkRuleSetProperties_STATUSGenerator()
var networkRuleSetProperties_STATUSGenerator gopter.Gen

// NetworkRuleSetProperties_STATUSGenerator returns a generator of NetworkRuleSetProperties_STATUS instances for property testing.
// We first initialize networkRuleSetProperties_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkRuleSetProperties_STATUSGenerator() gopter.Gen {
	if networkRuleSetProperties_STATUSGenerator != nil {
		return networkRuleSetProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSetProperties_STATUS(generators)
	networkRuleSetProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSetProperties_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSetProperties_STATUS(generators)
	AddRelatedPropertyGeneratorsForNetworkRuleSetProperties_STATUS(generators)
	networkRuleSetProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSetProperties_STATUS{}), generators)

	return networkRuleSetProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForNetworkRuleSetProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkRuleSetProperties_STATUS(gens map[string]gopter.Gen) {
	gens["ApplyToBuiltInEventHubEndpoint"] = gen.PtrOf(gen.Bool())
	gens["DefaultAction"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNetworkRuleSetProperties_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkRuleSetProperties_STATUS(gens map[string]gopter.Gen) {
	gens["IpRules"] = gen.SliceOf(NetworkRuleSetIpRule_STATUSGenerator())
}

func Test_PrivateEndpointConnection_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointConnection_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointConnection_STATUS, PrivateEndpointConnection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointConnection_STATUS runs a test to see if a specific instance of PrivateEndpointConnection_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointConnection_STATUS(subject PrivateEndpointConnection_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointConnection_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointConnection_STATUS instances for property testing - lazily instantiated by
// PrivateEndpointConnection_STATUSGenerator()
var privateEndpointConnection_STATUSGenerator gopter.Gen

// PrivateEndpointConnection_STATUSGenerator returns a generator of PrivateEndpointConnection_STATUS instances for property testing.
func PrivateEndpointConnection_STATUSGenerator() gopter.Gen {
	if privateEndpointConnection_STATUSGenerator != nil {
		return privateEndpointConnection_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnection_STATUS(generators)
	privateEndpointConnection_STATUSGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnection_STATUS{}), generators)

	return privateEndpointConnection_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointConnection_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointConnection_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_RoutingProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingProperties, RoutingPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingProperties runs a test to see if a specific instance of RoutingProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingProperties(subject RoutingProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingProperties instances for property testing - lazily instantiated by RoutingPropertiesGenerator()
var routingPropertiesGenerator gopter.Gen

// RoutingPropertiesGenerator returns a generator of RoutingProperties instances for property testing.
func RoutingPropertiesGenerator() gopter.Gen {
	if routingPropertiesGenerator != nil {
		return routingPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForRoutingProperties(generators)
	routingPropertiesGenerator = gen.Struct(reflect.TypeOf(RoutingProperties{}), generators)

	return routingPropertiesGenerator
}

// AddRelatedPropertyGeneratorsForRoutingProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRoutingProperties(gens map[string]gopter.Gen) {
	gens["Endpoints"] = gen.PtrOf(RoutingEndpointsGenerator())
	gens["Enrichments"] = gen.SliceOf(EnrichmentPropertiesGenerator())
	gens["FallbackRoute"] = gen.PtrOf(FallbackRoutePropertiesGenerator())
	gens["Routes"] = gen.SliceOf(RoutePropertiesGenerator())
}

func Test_RoutingProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingProperties_STATUS, RoutingProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingProperties_STATUS runs a test to see if a specific instance of RoutingProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingProperties_STATUS(subject RoutingProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingProperties_STATUS instances for property testing - lazily instantiated by
// RoutingProperties_STATUSGenerator()
var routingProperties_STATUSGenerator gopter.Gen

// RoutingProperties_STATUSGenerator returns a generator of RoutingProperties_STATUS instances for property testing.
func RoutingProperties_STATUSGenerator() gopter.Gen {
	if routingProperties_STATUSGenerator != nil {
		return routingProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForRoutingProperties_STATUS(generators)
	routingProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(RoutingProperties_STATUS{}), generators)

	return routingProperties_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForRoutingProperties_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRoutingProperties_STATUS(gens map[string]gopter.Gen) {
	gens["Endpoints"] = gen.PtrOf(RoutingEndpoints_STATUSGenerator())
	gens["Enrichments"] = gen.SliceOf(EnrichmentProperties_STATUSGenerator())
	gens["FallbackRoute"] = gen.PtrOf(FallbackRouteProperties_STATUSGenerator())
	gens["Routes"] = gen.SliceOf(RouteProperties_STATUSGenerator())
}

func Test_SharedAccessSignatureAuthorizationRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SharedAccessSignatureAuthorizationRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSharedAccessSignatureAuthorizationRule, SharedAccessSignatureAuthorizationRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSharedAccessSignatureAuthorizationRule runs a test to see if a specific instance of SharedAccessSignatureAuthorizationRule round trips to JSON and back losslessly
func RunJSONSerializationTestForSharedAccessSignatureAuthorizationRule(subject SharedAccessSignatureAuthorizationRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SharedAccessSignatureAuthorizationRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SharedAccessSignatureAuthorizationRule instances for property testing - lazily instantiated by
// SharedAccessSignatureAuthorizationRuleGenerator()
var sharedAccessSignatureAuthorizationRuleGenerator gopter.Gen

// SharedAccessSignatureAuthorizationRuleGenerator returns a generator of SharedAccessSignatureAuthorizationRule instances for property testing.
func SharedAccessSignatureAuthorizationRuleGenerator() gopter.Gen {
	if sharedAccessSignatureAuthorizationRuleGenerator != nil {
		return sharedAccessSignatureAuthorizationRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSharedAccessSignatureAuthorizationRule(generators)
	sharedAccessSignatureAuthorizationRuleGenerator = gen.Struct(reflect.TypeOf(SharedAccessSignatureAuthorizationRule{}), generators)

	return sharedAccessSignatureAuthorizationRuleGenerator
}

// AddIndependentPropertyGeneratorsForSharedAccessSignatureAuthorizationRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSharedAccessSignatureAuthorizationRule(gens map[string]gopter.Gen) {
	gens["KeyName"] = gen.PtrOf(gen.AlphaString())
	gens["Rights"] = gen.PtrOf(gen.AlphaString())
}

func Test_SharedAccessSignatureAuthorizationRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SharedAccessSignatureAuthorizationRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSharedAccessSignatureAuthorizationRule_STATUS, SharedAccessSignatureAuthorizationRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSharedAccessSignatureAuthorizationRule_STATUS runs a test to see if a specific instance of SharedAccessSignatureAuthorizationRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSharedAccessSignatureAuthorizationRule_STATUS(subject SharedAccessSignatureAuthorizationRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SharedAccessSignatureAuthorizationRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SharedAccessSignatureAuthorizationRule_STATUS instances for property testing - lazily instantiated by
// SharedAccessSignatureAuthorizationRule_STATUSGenerator()
var sharedAccessSignatureAuthorizationRule_STATUSGenerator gopter.Gen

// SharedAccessSignatureAuthorizationRule_STATUSGenerator returns a generator of SharedAccessSignatureAuthorizationRule_STATUS instances for property testing.
func SharedAccessSignatureAuthorizationRule_STATUSGenerator() gopter.Gen {
	if sharedAccessSignatureAuthorizationRule_STATUSGenerator != nil {
		return sharedAccessSignatureAuthorizationRule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSharedAccessSignatureAuthorizationRule_STATUS(generators)
	sharedAccessSignatureAuthorizationRule_STATUSGenerator = gen.Struct(reflect.TypeOf(SharedAccessSignatureAuthorizationRule_STATUS{}), generators)

	return sharedAccessSignatureAuthorizationRule_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSharedAccessSignatureAuthorizationRule_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSharedAccessSignatureAuthorizationRule_STATUS(gens map[string]gopter.Gen) {
	gens["KeyName"] = gen.PtrOf(gen.AlphaString())
	gens["Rights"] = gen.PtrOf(gen.AlphaString())
}

func Test_StorageEndpointProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageEndpointProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageEndpointProperties, StorageEndpointPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageEndpointProperties runs a test to see if a specific instance of StorageEndpointProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageEndpointProperties(subject StorageEndpointProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageEndpointProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageEndpointProperties instances for property testing - lazily instantiated by
// StorageEndpointPropertiesGenerator()
var storageEndpointPropertiesGenerator gopter.Gen

// StorageEndpointPropertiesGenerator returns a generator of StorageEndpointProperties instances for property testing.
// We first initialize storageEndpointPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func StorageEndpointPropertiesGenerator() gopter.Gen {
	if storageEndpointPropertiesGenerator != nil {
		return storageEndpointPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageEndpointProperties(generators)
	storageEndpointPropertiesGenerator = gen.Struct(reflect.TypeOf(StorageEndpointProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageEndpointProperties(generators)
	AddRelatedPropertyGeneratorsForStorageEndpointProperties(generators)
	storageEndpointPropertiesGenerator = gen.Struct(reflect.TypeOf(StorageEndpointProperties{}), generators)

	return storageEndpointPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForStorageEndpointProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageEndpointProperties(gens map[string]gopter.Gen) {
	gens["AuthenticationType"] = gen.PtrOf(gen.AlphaString())
	gens["ContainerName"] = gen.PtrOf(gen.AlphaString())
	gens["SasTtlAsIso8601"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForStorageEndpointProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageEndpointProperties(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedIdentityGenerator())
}

func Test_StorageEndpointProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageEndpointProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageEndpointProperties_STATUS, StorageEndpointProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageEndpointProperties_STATUS runs a test to see if a specific instance of StorageEndpointProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageEndpointProperties_STATUS(subject StorageEndpointProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageEndpointProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageEndpointProperties_STATUS instances for property testing - lazily instantiated by
// StorageEndpointProperties_STATUSGenerator()
var storageEndpointProperties_STATUSGenerator gopter.Gen

// StorageEndpointProperties_STATUSGenerator returns a generator of StorageEndpointProperties_STATUS instances for property testing.
// We first initialize storageEndpointProperties_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func StorageEndpointProperties_STATUSGenerator() gopter.Gen {
	if storageEndpointProperties_STATUSGenerator != nil {
		return storageEndpointProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageEndpointProperties_STATUS(generators)
	storageEndpointProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(StorageEndpointProperties_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageEndpointProperties_STATUS(generators)
	AddRelatedPropertyGeneratorsForStorageEndpointProperties_STATUS(generators)
	storageEndpointProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(StorageEndpointProperties_STATUS{}), generators)

	return storageEndpointProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForStorageEndpointProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageEndpointProperties_STATUS(gens map[string]gopter.Gen) {
	gens["AuthenticationType"] = gen.PtrOf(gen.AlphaString())
	gens["ContainerName"] = gen.PtrOf(gen.AlphaString())
	gens["SasTtlAsIso8601"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForStorageEndpointProperties_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageEndpointProperties_STATUS(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedIdentity_STATUSGenerator())
}

func Test_UserAssignedIdentityDetails_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentityDetails via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentityDetails, UserAssignedIdentityDetailsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentityDetails runs a test to see if a specific instance of UserAssignedIdentityDetails round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentityDetails(subject UserAssignedIdentityDetails) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentityDetails
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentityDetails instances for property testing - lazily instantiated by
// UserAssignedIdentityDetailsGenerator()
var userAssignedIdentityDetailsGenerator gopter.Gen

// UserAssignedIdentityDetailsGenerator returns a generator of UserAssignedIdentityDetails instances for property testing.
func UserAssignedIdentityDetailsGenerator() gopter.Gen {
	if userAssignedIdentityDetailsGenerator != nil {
		return userAssignedIdentityDetailsGenerator
	}

	generators := make(map[string]gopter.Gen)
	userAssignedIdentityDetailsGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentityDetails{}), generators)

	return userAssignedIdentityDetailsGenerator
}

func Test_EnrichmentProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EnrichmentProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEnrichmentProperties, EnrichmentPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEnrichmentProperties runs a test to see if a specific instance of EnrichmentProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForEnrichmentProperties(subject EnrichmentProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EnrichmentProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EnrichmentProperties instances for property testing - lazily instantiated by
// EnrichmentPropertiesGenerator()
var enrichmentPropertiesGenerator gopter.Gen

// EnrichmentPropertiesGenerator returns a generator of EnrichmentProperties instances for property testing.
func EnrichmentPropertiesGenerator() gopter.Gen {
	if enrichmentPropertiesGenerator != nil {
		return enrichmentPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEnrichmentProperties(generators)
	enrichmentPropertiesGenerator = gen.Struct(reflect.TypeOf(EnrichmentProperties{}), generators)

	return enrichmentPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForEnrichmentProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEnrichmentProperties(gens map[string]gopter.Gen) {
	gens["EndpointNames"] = gen.SliceOf(gen.AlphaString())
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_EnrichmentProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EnrichmentProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEnrichmentProperties_STATUS, EnrichmentProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEnrichmentProperties_STATUS runs a test to see if a specific instance of EnrichmentProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEnrichmentProperties_STATUS(subject EnrichmentProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EnrichmentProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EnrichmentProperties_STATUS instances for property testing - lazily instantiated by
// EnrichmentProperties_STATUSGenerator()
var enrichmentProperties_STATUSGenerator gopter.Gen

// EnrichmentProperties_STATUSGenerator returns a generator of EnrichmentProperties_STATUS instances for property testing.
func EnrichmentProperties_STATUSGenerator() gopter.Gen {
	if enrichmentProperties_STATUSGenerator != nil {
		return enrichmentProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEnrichmentProperties_STATUS(generators)
	enrichmentProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(EnrichmentProperties_STATUS{}), generators)

	return enrichmentProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForEnrichmentProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEnrichmentProperties_STATUS(gens map[string]gopter.Gen) {
	gens["EndpointNames"] = gen.SliceOf(gen.AlphaString())
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_FallbackRouteProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FallbackRouteProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFallbackRouteProperties, FallbackRoutePropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFallbackRouteProperties runs a test to see if a specific instance of FallbackRouteProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForFallbackRouteProperties(subject FallbackRouteProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FallbackRouteProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FallbackRouteProperties instances for property testing - lazily instantiated by
// FallbackRoutePropertiesGenerator()
var fallbackRoutePropertiesGenerator gopter.Gen

// FallbackRoutePropertiesGenerator returns a generator of FallbackRouteProperties instances for property testing.
func FallbackRoutePropertiesGenerator() gopter.Gen {
	if fallbackRoutePropertiesGenerator != nil {
		return fallbackRoutePropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFallbackRouteProperties(generators)
	fallbackRoutePropertiesGenerator = gen.Struct(reflect.TypeOf(FallbackRouteProperties{}), generators)

	return fallbackRoutePropertiesGenerator
}

// AddIndependentPropertyGeneratorsForFallbackRouteProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFallbackRouteProperties(gens map[string]gopter.Gen) {
	gens["Condition"] = gen.PtrOf(gen.AlphaString())
	gens["EndpointNames"] = gen.SliceOf(gen.AlphaString())
	gens["IsEnabled"] = gen.PtrOf(gen.Bool())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Source"] = gen.PtrOf(gen.AlphaString())
}

func Test_FallbackRouteProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FallbackRouteProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFallbackRouteProperties_STATUS, FallbackRouteProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFallbackRouteProperties_STATUS runs a test to see if a specific instance of FallbackRouteProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFallbackRouteProperties_STATUS(subject FallbackRouteProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FallbackRouteProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FallbackRouteProperties_STATUS instances for property testing - lazily instantiated by
// FallbackRouteProperties_STATUSGenerator()
var fallbackRouteProperties_STATUSGenerator gopter.Gen

// FallbackRouteProperties_STATUSGenerator returns a generator of FallbackRouteProperties_STATUS instances for property testing.
func FallbackRouteProperties_STATUSGenerator() gopter.Gen {
	if fallbackRouteProperties_STATUSGenerator != nil {
		return fallbackRouteProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFallbackRouteProperties_STATUS(generators)
	fallbackRouteProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(FallbackRouteProperties_STATUS{}), generators)

	return fallbackRouteProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFallbackRouteProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFallbackRouteProperties_STATUS(gens map[string]gopter.Gen) {
	gens["Condition"] = gen.PtrOf(gen.AlphaString())
	gens["EndpointNames"] = gen.SliceOf(gen.AlphaString())
	gens["IsEnabled"] = gen.PtrOf(gen.Bool())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Source"] = gen.PtrOf(gen.AlphaString())
}

func Test_FeedbackProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FeedbackProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFeedbackProperties, FeedbackPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFeedbackProperties runs a test to see if a specific instance of FeedbackProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForFeedbackProperties(subject FeedbackProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FeedbackProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FeedbackProperties instances for property testing - lazily instantiated by FeedbackPropertiesGenerator()
var feedbackPropertiesGenerator gopter.Gen

// FeedbackPropertiesGenerator returns a generator of FeedbackProperties instances for property testing.
func FeedbackPropertiesGenerator() gopter.Gen {
	if feedbackPropertiesGenerator != nil {
		return feedbackPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFeedbackProperties(generators)
	feedbackPropertiesGenerator = gen.Struct(reflect.TypeOf(FeedbackProperties{}), generators)

	return feedbackPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForFeedbackProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFeedbackProperties(gens map[string]gopter.Gen) {
	gens["LockDurationAsIso8601"] = gen.PtrOf(gen.AlphaString())
	gens["MaxDeliveryCount"] = gen.PtrOf(gen.Int())
	gens["TtlAsIso8601"] = gen.PtrOf(gen.AlphaString())
}

func Test_FeedbackProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FeedbackProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFeedbackProperties_STATUS, FeedbackProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFeedbackProperties_STATUS runs a test to see if a specific instance of FeedbackProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFeedbackProperties_STATUS(subject FeedbackProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FeedbackProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FeedbackProperties_STATUS instances for property testing - lazily instantiated by
// FeedbackProperties_STATUSGenerator()
var feedbackProperties_STATUSGenerator gopter.Gen

// FeedbackProperties_STATUSGenerator returns a generator of FeedbackProperties_STATUS instances for property testing.
func FeedbackProperties_STATUSGenerator() gopter.Gen {
	if feedbackProperties_STATUSGenerator != nil {
		return feedbackProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFeedbackProperties_STATUS(generators)
	feedbackProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(FeedbackProperties_STATUS{}), generators)

	return feedbackProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFeedbackProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFeedbackProperties_STATUS(gens map[string]gopter.Gen) {
	gens["LockDurationAsIso8601"] = gen.PtrOf(gen.AlphaString())
	gens["MaxDeliveryCount"] = gen.PtrOf(gen.Int())
	gens["TtlAsIso8601"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedIdentity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedIdentity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedIdentity, ManagedIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedIdentity runs a test to see if a specific instance of ManagedIdentity round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedIdentity(subject ManagedIdentity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedIdentity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedIdentity instances for property testing - lazily instantiated by ManagedIdentityGenerator()
var managedIdentityGenerator gopter.Gen

// ManagedIdentityGenerator returns a generator of ManagedIdentity instances for property testing.
func ManagedIdentityGenerator() gopter.Gen {
	if managedIdentityGenerator != nil {
		return managedIdentityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedIdentity(generators)
	managedIdentityGenerator = gen.Struct(reflect.TypeOf(ManagedIdentity{}), generators)

	return managedIdentityGenerator
}

// AddIndependentPropertyGeneratorsForManagedIdentity is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedIdentity(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentity"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedIdentity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedIdentity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedIdentity_STATUS, ManagedIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedIdentity_STATUS runs a test to see if a specific instance of ManagedIdentity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedIdentity_STATUS(subject ManagedIdentity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedIdentity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedIdentity_STATUS instances for property testing - lazily instantiated by
// ManagedIdentity_STATUSGenerator()
var managedIdentity_STATUSGenerator gopter.Gen

// ManagedIdentity_STATUSGenerator returns a generator of ManagedIdentity_STATUS instances for property testing.
func ManagedIdentity_STATUSGenerator() gopter.Gen {
	if managedIdentity_STATUSGenerator != nil {
		return managedIdentity_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedIdentity_STATUS(generators)
	managedIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedIdentity_STATUS{}), generators)

	return managedIdentity_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForManagedIdentity_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentity"] = gen.PtrOf(gen.AlphaString())
}

func Test_NetworkRuleSetIpRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkRuleSetIpRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkRuleSetIpRule, NetworkRuleSetIpRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkRuleSetIpRule runs a test to see if a specific instance of NetworkRuleSetIpRule round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkRuleSetIpRule(subject NetworkRuleSetIpRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkRuleSetIpRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkRuleSetIpRule instances for property testing - lazily instantiated by
// NetworkRuleSetIpRuleGenerator()
var networkRuleSetIpRuleGenerator gopter.Gen

// NetworkRuleSetIpRuleGenerator returns a generator of NetworkRuleSetIpRule instances for property testing.
func NetworkRuleSetIpRuleGenerator() gopter.Gen {
	if networkRuleSetIpRuleGenerator != nil {
		return networkRuleSetIpRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSetIpRule(generators)
	networkRuleSetIpRuleGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSetIpRule{}), generators)

	return networkRuleSetIpRuleGenerator
}

// AddIndependentPropertyGeneratorsForNetworkRuleSetIpRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkRuleSetIpRule(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.AlphaString())
	gens["FilterName"] = gen.PtrOf(gen.AlphaString())
	gens["IpMask"] = gen.PtrOf(gen.AlphaString())
}

func Test_NetworkRuleSetIpRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkRuleSetIpRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkRuleSetIpRule_STATUS, NetworkRuleSetIpRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkRuleSetIpRule_STATUS runs a test to see if a specific instance of NetworkRuleSetIpRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkRuleSetIpRule_STATUS(subject NetworkRuleSetIpRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkRuleSetIpRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkRuleSetIpRule_STATUS instances for property testing - lazily instantiated by
// NetworkRuleSetIpRule_STATUSGenerator()
var networkRuleSetIpRule_STATUSGenerator gopter.Gen

// NetworkRuleSetIpRule_STATUSGenerator returns a generator of NetworkRuleSetIpRule_STATUS instances for property testing.
func NetworkRuleSetIpRule_STATUSGenerator() gopter.Gen {
	if networkRuleSetIpRule_STATUSGenerator != nil {
		return networkRuleSetIpRule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkRuleSetIpRule_STATUS(generators)
	networkRuleSetIpRule_STATUSGenerator = gen.Struct(reflect.TypeOf(NetworkRuleSetIpRule_STATUS{}), generators)

	return networkRuleSetIpRule_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForNetworkRuleSetIpRule_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkRuleSetIpRule_STATUS(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.AlphaString())
	gens["FilterName"] = gen.PtrOf(gen.AlphaString())
	gens["IpMask"] = gen.PtrOf(gen.AlphaString())
}

func Test_RouteProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RouteProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRouteProperties, RoutePropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRouteProperties runs a test to see if a specific instance of RouteProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForRouteProperties(subject RouteProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RouteProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RouteProperties instances for property testing - lazily instantiated by RoutePropertiesGenerator()
var routePropertiesGenerator gopter.Gen

// RoutePropertiesGenerator returns a generator of RouteProperties instances for property testing.
func RoutePropertiesGenerator() gopter.Gen {
	if routePropertiesGenerator != nil {
		return routePropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRouteProperties(generators)
	routePropertiesGenerator = gen.Struct(reflect.TypeOf(RouteProperties{}), generators)

	return routePropertiesGenerator
}

// AddIndependentPropertyGeneratorsForRouteProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRouteProperties(gens map[string]gopter.Gen) {
	gens["Condition"] = gen.PtrOf(gen.AlphaString())
	gens["EndpointNames"] = gen.SliceOf(gen.AlphaString())
	gens["IsEnabled"] = gen.PtrOf(gen.Bool())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Source"] = gen.PtrOf(gen.AlphaString())
}

func Test_RouteProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RouteProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRouteProperties_STATUS, RouteProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRouteProperties_STATUS runs a test to see if a specific instance of RouteProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRouteProperties_STATUS(subject RouteProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RouteProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RouteProperties_STATUS instances for property testing - lazily instantiated by
// RouteProperties_STATUSGenerator()
var routeProperties_STATUSGenerator gopter.Gen

// RouteProperties_STATUSGenerator returns a generator of RouteProperties_STATUS instances for property testing.
func RouteProperties_STATUSGenerator() gopter.Gen {
	if routeProperties_STATUSGenerator != nil {
		return routeProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRouteProperties_STATUS(generators)
	routeProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(RouteProperties_STATUS{}), generators)

	return routeProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForRouteProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRouteProperties_STATUS(gens map[string]gopter.Gen) {
	gens["Condition"] = gen.PtrOf(gen.AlphaString())
	gens["EndpointNames"] = gen.SliceOf(gen.AlphaString())
	gens["IsEnabled"] = gen.PtrOf(gen.Bool())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Source"] = gen.PtrOf(gen.AlphaString())
}

func Test_RoutingEndpoints_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingEndpoints via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingEndpoints, RoutingEndpointsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingEndpoints runs a test to see if a specific instance of RoutingEndpoints round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingEndpoints(subject RoutingEndpoints) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingEndpoints
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingEndpoints instances for property testing - lazily instantiated by RoutingEndpointsGenerator()
var routingEndpointsGenerator gopter.Gen

// RoutingEndpointsGenerator returns a generator of RoutingEndpoints instances for property testing.
func RoutingEndpointsGenerator() gopter.Gen {
	if routingEndpointsGenerator != nil {
		return routingEndpointsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForRoutingEndpoints(generators)
	routingEndpointsGenerator = gen.Struct(reflect.TypeOf(RoutingEndpoints{}), generators)

	return routingEndpointsGenerator
}

// AddRelatedPropertyGeneratorsForRoutingEndpoints is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRoutingEndpoints(gens map[string]gopter.Gen) {
	gens["EventHubs"] = gen.SliceOf(RoutingEventHubPropertiesGenerator())
	gens["ServiceBusQueues"] = gen.SliceOf(RoutingServiceBusQueueEndpointPropertiesGenerator())
	gens["ServiceBusTopics"] = gen.SliceOf(RoutingServiceBusTopicEndpointPropertiesGenerator())
	gens["StorageContainers"] = gen.SliceOf(RoutingStorageContainerPropertiesGenerator())
}

func Test_RoutingEndpoints_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingEndpoints_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingEndpoints_STATUS, RoutingEndpoints_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingEndpoints_STATUS runs a test to see if a specific instance of RoutingEndpoints_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingEndpoints_STATUS(subject RoutingEndpoints_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingEndpoints_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingEndpoints_STATUS instances for property testing - lazily instantiated by
// RoutingEndpoints_STATUSGenerator()
var routingEndpoints_STATUSGenerator gopter.Gen

// RoutingEndpoints_STATUSGenerator returns a generator of RoutingEndpoints_STATUS instances for property testing.
func RoutingEndpoints_STATUSGenerator() gopter.Gen {
	if routingEndpoints_STATUSGenerator != nil {
		return routingEndpoints_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForRoutingEndpoints_STATUS(generators)
	routingEndpoints_STATUSGenerator = gen.Struct(reflect.TypeOf(RoutingEndpoints_STATUS{}), generators)

	return routingEndpoints_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForRoutingEndpoints_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRoutingEndpoints_STATUS(gens map[string]gopter.Gen) {
	gens["EventHubs"] = gen.SliceOf(RoutingEventHubProperties_STATUSGenerator())
	gens["ServiceBusQueues"] = gen.SliceOf(RoutingServiceBusQueueEndpointProperties_STATUSGenerator())
	gens["ServiceBusTopics"] = gen.SliceOf(RoutingServiceBusTopicEndpointProperties_STATUSGenerator())
	gens["StorageContainers"] = gen.SliceOf(RoutingStorageContainerProperties_STATUSGenerator())
}

func Test_RoutingEventHubProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingEventHubProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingEventHubProperties, RoutingEventHubPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingEventHubProperties runs a test to see if a specific instance of RoutingEventHubProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingEventHubProperties(subject RoutingEventHubProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingEventHubProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingEventHubProperties instances for property testing - lazily instantiated by
// RoutingEventHubPropertiesGenerator()
var routingEventHubPropertiesGenerator gopter.Gen

// RoutingEventHubPropertiesGenerator returns a generator of RoutingEventHubProperties instances for property testing.
// We first initialize routingEventHubPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RoutingEventHubPropertiesGenerator() gopter.Gen {
	if routingEventHubPropertiesGenerator != nil {
		return routingEventHubPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingEventHubProperties(generators)
	routingEventHubPropertiesGenerator = gen.Struct(reflect.TypeOf(RoutingEventHubProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingEventHubProperties(generators)
	AddRelatedPropertyGeneratorsForRoutingEventHubProperties(generators)
	routingEventHubPropertiesGenerator = gen.Struct(reflect.TypeOf(RoutingEventHubProperties{}), generators)

	return routingEventHubPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForRoutingEventHubProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRoutingEventHubProperties(gens map[string]gopter.Gen) {
	gens["AuthenticationType"] = gen.PtrOf(gen.AlphaString())
	gens["EndpointUri"] = gen.PtrOf(gen.AlphaString())
	gens["EntityPath"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceGroup"] = gen.PtrOf(gen.AlphaString())
	gens["SubscriptionId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForRoutingEventHubProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRoutingEventHubProperties(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedIdentityGenerator())
}

func Test_RoutingEventHubProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingEventHubProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingEventHubProperties_STATUS, RoutingEventHubProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingEventHubProperties_STATUS runs a test to see if a specific instance of RoutingEventHubProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingEventHubProperties_STATUS(subject RoutingEventHubProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingEventHubProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingEventHubProperties_STATUS instances for property testing - lazily instantiated by
// RoutingEventHubProperties_STATUSGenerator()
var routingEventHubProperties_STATUSGenerator gopter.Gen

// RoutingEventHubProperties_STATUSGenerator returns a generator of RoutingEventHubProperties_STATUS instances for property testing.
// We first initialize routingEventHubProperties_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RoutingEventHubProperties_STATUSGenerator() gopter.Gen {
	if routingEventHubProperties_STATUSGenerator != nil {
		return routingEventHubProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingEventHubProperties_STATUS(generators)
	routingEventHubProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(RoutingEventHubProperties_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingEventHubProperties_STATUS(generators)
	AddRelatedPropertyGeneratorsForRoutingEventHubProperties_STATUS(generators)
	routingEventHubProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(RoutingEventHubProperties_STATUS{}), generators)

	return routingEventHubProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForRoutingEventHubProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRoutingEventHubProperties_STATUS(gens map[string]gopter.Gen) {
	gens["AuthenticationType"] = gen.PtrOf(gen.AlphaString())
	gens["EndpointUri"] = gen.PtrOf(gen.AlphaString())
	gens["EntityPath"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceGroup"] = gen.PtrOf(gen.AlphaString())
	gens["SubscriptionId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForRoutingEventHubProperties_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRoutingEventHubProperties_STATUS(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedIdentity_STATUSGenerator())
}

func Test_RoutingServiceBusQueueEndpointProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingServiceBusQueueEndpointProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingServiceBusQueueEndpointProperties, RoutingServiceBusQueueEndpointPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingServiceBusQueueEndpointProperties runs a test to see if a specific instance of RoutingServiceBusQueueEndpointProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingServiceBusQueueEndpointProperties(subject RoutingServiceBusQueueEndpointProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingServiceBusQueueEndpointProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingServiceBusQueueEndpointProperties instances for property testing - lazily instantiated by
// RoutingServiceBusQueueEndpointPropertiesGenerator()
var routingServiceBusQueueEndpointPropertiesGenerator gopter.Gen

// RoutingServiceBusQueueEndpointPropertiesGenerator returns a generator of RoutingServiceBusQueueEndpointProperties instances for property testing.
// We first initialize routingServiceBusQueueEndpointPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RoutingServiceBusQueueEndpointPropertiesGenerator() gopter.Gen {
	if routingServiceBusQueueEndpointPropertiesGenerator != nil {
		return routingServiceBusQueueEndpointPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingServiceBusQueueEndpointProperties(generators)
	routingServiceBusQueueEndpointPropertiesGenerator = gen.Struct(reflect.TypeOf(RoutingServiceBusQueueEndpointProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingServiceBusQueueEndpointProperties(generators)
	AddRelatedPropertyGeneratorsForRoutingServiceBusQueueEndpointProperties(generators)
	routingServiceBusQueueEndpointPropertiesGenerator = gen.Struct(reflect.TypeOf(RoutingServiceBusQueueEndpointProperties{}), generators)

	return routingServiceBusQueueEndpointPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForRoutingServiceBusQueueEndpointProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRoutingServiceBusQueueEndpointProperties(gens map[string]gopter.Gen) {
	gens["AuthenticationType"] = gen.PtrOf(gen.AlphaString())
	gens["EndpointUri"] = gen.PtrOf(gen.AlphaString())
	gens["EntityPath"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceGroup"] = gen.PtrOf(gen.AlphaString())
	gens["SubscriptionId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForRoutingServiceBusQueueEndpointProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRoutingServiceBusQueueEndpointProperties(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedIdentityGenerator())
}

func Test_RoutingServiceBusQueueEndpointProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingServiceBusQueueEndpointProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingServiceBusQueueEndpointProperties_STATUS, RoutingServiceBusQueueEndpointProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingServiceBusQueueEndpointProperties_STATUS runs a test to see if a specific instance of RoutingServiceBusQueueEndpointProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingServiceBusQueueEndpointProperties_STATUS(subject RoutingServiceBusQueueEndpointProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingServiceBusQueueEndpointProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingServiceBusQueueEndpointProperties_STATUS instances for property testing - lazily instantiated by
// RoutingServiceBusQueueEndpointProperties_STATUSGenerator()
var routingServiceBusQueueEndpointProperties_STATUSGenerator gopter.Gen

// RoutingServiceBusQueueEndpointProperties_STATUSGenerator returns a generator of RoutingServiceBusQueueEndpointProperties_STATUS instances for property testing.
// We first initialize routingServiceBusQueueEndpointProperties_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RoutingServiceBusQueueEndpointProperties_STATUSGenerator() gopter.Gen {
	if routingServiceBusQueueEndpointProperties_STATUSGenerator != nil {
		return routingServiceBusQueueEndpointProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingServiceBusQueueEndpointProperties_STATUS(generators)
	routingServiceBusQueueEndpointProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(RoutingServiceBusQueueEndpointProperties_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingServiceBusQueueEndpointProperties_STATUS(generators)
	AddRelatedPropertyGeneratorsForRoutingServiceBusQueueEndpointProperties_STATUS(generators)
	routingServiceBusQueueEndpointProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(RoutingServiceBusQueueEndpointProperties_STATUS{}), generators)

	return routingServiceBusQueueEndpointProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForRoutingServiceBusQueueEndpointProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRoutingServiceBusQueueEndpointProperties_STATUS(gens map[string]gopter.Gen) {
	gens["AuthenticationType"] = gen.PtrOf(gen.AlphaString())
	gens["EndpointUri"] = gen.PtrOf(gen.AlphaString())
	gens["EntityPath"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceGroup"] = gen.PtrOf(gen.AlphaString())
	gens["SubscriptionId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForRoutingServiceBusQueueEndpointProperties_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRoutingServiceBusQueueEndpointProperties_STATUS(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedIdentity_STATUSGenerator())
}

func Test_RoutingServiceBusTopicEndpointProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingServiceBusTopicEndpointProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingServiceBusTopicEndpointProperties, RoutingServiceBusTopicEndpointPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingServiceBusTopicEndpointProperties runs a test to see if a specific instance of RoutingServiceBusTopicEndpointProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingServiceBusTopicEndpointProperties(subject RoutingServiceBusTopicEndpointProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingServiceBusTopicEndpointProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingServiceBusTopicEndpointProperties instances for property testing - lazily instantiated by
// RoutingServiceBusTopicEndpointPropertiesGenerator()
var routingServiceBusTopicEndpointPropertiesGenerator gopter.Gen

// RoutingServiceBusTopicEndpointPropertiesGenerator returns a generator of RoutingServiceBusTopicEndpointProperties instances for property testing.
// We first initialize routingServiceBusTopicEndpointPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RoutingServiceBusTopicEndpointPropertiesGenerator() gopter.Gen {
	if routingServiceBusTopicEndpointPropertiesGenerator != nil {
		return routingServiceBusTopicEndpointPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingServiceBusTopicEndpointProperties(generators)
	routingServiceBusTopicEndpointPropertiesGenerator = gen.Struct(reflect.TypeOf(RoutingServiceBusTopicEndpointProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingServiceBusTopicEndpointProperties(generators)
	AddRelatedPropertyGeneratorsForRoutingServiceBusTopicEndpointProperties(generators)
	routingServiceBusTopicEndpointPropertiesGenerator = gen.Struct(reflect.TypeOf(RoutingServiceBusTopicEndpointProperties{}), generators)

	return routingServiceBusTopicEndpointPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForRoutingServiceBusTopicEndpointProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRoutingServiceBusTopicEndpointProperties(gens map[string]gopter.Gen) {
	gens["AuthenticationType"] = gen.PtrOf(gen.AlphaString())
	gens["EndpointUri"] = gen.PtrOf(gen.AlphaString())
	gens["EntityPath"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceGroup"] = gen.PtrOf(gen.AlphaString())
	gens["SubscriptionId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForRoutingServiceBusTopicEndpointProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRoutingServiceBusTopicEndpointProperties(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedIdentityGenerator())
}

func Test_RoutingServiceBusTopicEndpointProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingServiceBusTopicEndpointProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingServiceBusTopicEndpointProperties_STATUS, RoutingServiceBusTopicEndpointProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingServiceBusTopicEndpointProperties_STATUS runs a test to see if a specific instance of RoutingServiceBusTopicEndpointProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingServiceBusTopicEndpointProperties_STATUS(subject RoutingServiceBusTopicEndpointProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingServiceBusTopicEndpointProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingServiceBusTopicEndpointProperties_STATUS instances for property testing - lazily instantiated by
// RoutingServiceBusTopicEndpointProperties_STATUSGenerator()
var routingServiceBusTopicEndpointProperties_STATUSGenerator gopter.Gen

// RoutingServiceBusTopicEndpointProperties_STATUSGenerator returns a generator of RoutingServiceBusTopicEndpointProperties_STATUS instances for property testing.
// We first initialize routingServiceBusTopicEndpointProperties_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RoutingServiceBusTopicEndpointProperties_STATUSGenerator() gopter.Gen {
	if routingServiceBusTopicEndpointProperties_STATUSGenerator != nil {
		return routingServiceBusTopicEndpointProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingServiceBusTopicEndpointProperties_STATUS(generators)
	routingServiceBusTopicEndpointProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(RoutingServiceBusTopicEndpointProperties_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingServiceBusTopicEndpointProperties_STATUS(generators)
	AddRelatedPropertyGeneratorsForRoutingServiceBusTopicEndpointProperties_STATUS(generators)
	routingServiceBusTopicEndpointProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(RoutingServiceBusTopicEndpointProperties_STATUS{}), generators)

	return routingServiceBusTopicEndpointProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForRoutingServiceBusTopicEndpointProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRoutingServiceBusTopicEndpointProperties_STATUS(gens map[string]gopter.Gen) {
	gens["AuthenticationType"] = gen.PtrOf(gen.AlphaString())
	gens["EndpointUri"] = gen.PtrOf(gen.AlphaString())
	gens["EntityPath"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceGroup"] = gen.PtrOf(gen.AlphaString())
	gens["SubscriptionId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForRoutingServiceBusTopicEndpointProperties_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRoutingServiceBusTopicEndpointProperties_STATUS(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedIdentity_STATUSGenerator())
}

func Test_RoutingStorageContainerProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingStorageContainerProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingStorageContainerProperties, RoutingStorageContainerPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingStorageContainerProperties runs a test to see if a specific instance of RoutingStorageContainerProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingStorageContainerProperties(subject RoutingStorageContainerProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingStorageContainerProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingStorageContainerProperties instances for property testing - lazily instantiated by
// RoutingStorageContainerPropertiesGenerator()
var routingStorageContainerPropertiesGenerator gopter.Gen

// RoutingStorageContainerPropertiesGenerator returns a generator of RoutingStorageContainerProperties instances for property testing.
// We first initialize routingStorageContainerPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RoutingStorageContainerPropertiesGenerator() gopter.Gen {
	if routingStorageContainerPropertiesGenerator != nil {
		return routingStorageContainerPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingStorageContainerProperties(generators)
	routingStorageContainerPropertiesGenerator = gen.Struct(reflect.TypeOf(RoutingStorageContainerProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingStorageContainerProperties(generators)
	AddRelatedPropertyGeneratorsForRoutingStorageContainerProperties(generators)
	routingStorageContainerPropertiesGenerator = gen.Struct(reflect.TypeOf(RoutingStorageContainerProperties{}), generators)

	return routingStorageContainerPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForRoutingStorageContainerProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRoutingStorageContainerProperties(gens map[string]gopter.Gen) {
	gens["AuthenticationType"] = gen.PtrOf(gen.AlphaString())
	gens["BatchFrequencyInSeconds"] = gen.PtrOf(gen.Int())
	gens["ContainerName"] = gen.PtrOf(gen.AlphaString())
	gens["Encoding"] = gen.PtrOf(gen.AlphaString())
	gens["EndpointUri"] = gen.PtrOf(gen.AlphaString())
	gens["FileNameFormat"] = gen.PtrOf(gen.AlphaString())
	gens["MaxChunkSizeInBytes"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceGroup"] = gen.PtrOf(gen.AlphaString())
	gens["SubscriptionId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForRoutingStorageContainerProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRoutingStorageContainerProperties(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedIdentityGenerator())
}

func Test_RoutingStorageContainerProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RoutingStorageContainerProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRoutingStorageContainerProperties_STATUS, RoutingStorageContainerProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRoutingStorageContainerProperties_STATUS runs a test to see if a specific instance of RoutingStorageContainerProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRoutingStorageContainerProperties_STATUS(subject RoutingStorageContainerProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RoutingStorageContainerProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RoutingStorageContainerProperties_STATUS instances for property testing - lazily instantiated by
// RoutingStorageContainerProperties_STATUSGenerator()
var routingStorageContainerProperties_STATUSGenerator gopter.Gen

// RoutingStorageContainerProperties_STATUSGenerator returns a generator of RoutingStorageContainerProperties_STATUS instances for property testing.
// We first initialize routingStorageContainerProperties_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RoutingStorageContainerProperties_STATUSGenerator() gopter.Gen {
	if routingStorageContainerProperties_STATUSGenerator != nil {
		return routingStorageContainerProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingStorageContainerProperties_STATUS(generators)
	routingStorageContainerProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(RoutingStorageContainerProperties_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRoutingStorageContainerProperties_STATUS(generators)
	AddRelatedPropertyGeneratorsForRoutingStorageContainerProperties_STATUS(generators)
	routingStorageContainerProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(RoutingStorageContainerProperties_STATUS{}), generators)

	return routingStorageContainerProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForRoutingStorageContainerProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRoutingStorageContainerProperties_STATUS(gens map[string]gopter.Gen) {
	gens["AuthenticationType"] = gen.PtrOf(gen.AlphaString())
	gens["BatchFrequencyInSeconds"] = gen.PtrOf(gen.Int())
	gens["ContainerName"] = gen.PtrOf(gen.AlphaString())
	gens["Encoding"] = gen.PtrOf(gen.AlphaString())
	gens["EndpointUri"] = gen.PtrOf(gen.AlphaString())
	gens["FileNameFormat"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["MaxChunkSizeInBytes"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceGroup"] = gen.PtrOf(gen.AlphaString())
	gens["SubscriptionId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForRoutingStorageContainerProperties_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRoutingStorageContainerProperties_STATUS(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedIdentity_STATUSGenerator())
}
