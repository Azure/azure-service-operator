// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package storage

import (
	v20200930s "github.com/Azure/azure-service-operator/v2/api/compute/v1api20200930/storage"
	v20201201s "github.com/Azure/azure-service-operator/v2/api/compute/v1api20201201/storage"
	v20210701s "github.com/Azure/azure-service-operator/v2/api/compute/v1api20210701/storage"
	v20220301s "github.com/Azure/azure-service-operator/v2/api/compute/v1api20220301/storage"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/pkg/errors"
	"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Storage version of v1beta20220301.VirtualMachine
// Deprecated version of VirtualMachine. Use v1api20220301.VirtualMachine instead
type VirtualMachine struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              VirtualMachine_Spec   `json:"spec,omitempty"`
	Status            VirtualMachine_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &VirtualMachine{}

// GetConditions returns the conditions of the resource
func (machine *VirtualMachine) GetConditions() conditions.Conditions {
	return machine.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (machine *VirtualMachine) SetConditions(conditions conditions.Conditions) {
	machine.Status.Conditions = conditions
}

var _ conversion.Convertible = &VirtualMachine{}

// ConvertFrom populates our VirtualMachine from the provided hub VirtualMachine
func (machine *VirtualMachine) ConvertFrom(hub conversion.Hub) error {
	// intermediate variable for conversion
	var source v20201201s.VirtualMachine

	err := source.ConvertFrom(hub)
	if err != nil {
		return errors.Wrap(err, "converting from hub to source")
	}

	err = machine.AssignProperties_From_VirtualMachine(&source)
	if err != nil {
		return errors.Wrap(err, "converting from source to machine")
	}

	return nil
}

// ConvertTo populates the provided hub VirtualMachine from our VirtualMachine
func (machine *VirtualMachine) ConvertTo(hub conversion.Hub) error {
	// intermediate variable for conversion
	var destination v20201201s.VirtualMachine
	err := machine.AssignProperties_To_VirtualMachine(&destination)
	if err != nil {
		return errors.Wrap(err, "converting to destination from machine")
	}
	err = destination.ConvertTo(hub)
	if err != nil {
		return errors.Wrap(err, "converting from destination to hub")
	}

	return nil
}

var _ genruntime.KubernetesResource = &VirtualMachine{}

// AzureName returns the Azure name of the resource
func (machine *VirtualMachine) AzureName() string {
	return machine.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2022-03-01"
func (machine VirtualMachine) GetAPIVersion() string {
	return string(APIVersion_Value)
}

// GetResourceScope returns the scope of the resource
func (machine *VirtualMachine) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (machine *VirtualMachine) GetSpec() genruntime.ConvertibleSpec {
	return &machine.Spec
}

// GetStatus returns the status of this resource
func (machine *VirtualMachine) GetStatus() genruntime.ConvertibleStatus {
	return &machine.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (machine *VirtualMachine) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Compute/virtualMachines"
func (machine *VirtualMachine) GetType() string {
	return "Microsoft.Compute/virtualMachines"
}

// NewEmptyStatus returns a new empty (blank) status
func (machine *VirtualMachine) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &VirtualMachine_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (machine *VirtualMachine) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(machine.Spec)
	return machine.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (machine *VirtualMachine) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*VirtualMachine_STATUS); ok {
		machine.Status = *st
		return nil
	}

	// Convert status to required version
	var st VirtualMachine_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	machine.Status = st
	return nil
}

// AssignProperties_From_VirtualMachine populates our VirtualMachine from the provided source VirtualMachine
func (machine *VirtualMachine) AssignProperties_From_VirtualMachine(source *v20201201s.VirtualMachine) error {

	// ObjectMeta
	machine.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec VirtualMachine_Spec
	err := spec.AssignProperties_From_VirtualMachine_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_VirtualMachine_Spec() to populate field Spec")
	}
	machine.Spec = spec

	// Status
	var status VirtualMachine_STATUS
	err = status.AssignProperties_From_VirtualMachine_STATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_VirtualMachine_STATUS() to populate field Status")
	}
	machine.Status = status

	// Invoke the augmentConversionForVirtualMachine interface (if implemented) to customize the conversion
	var machineAsAny any = machine
	if augmentedMachine, ok := machineAsAny.(augmentConversionForVirtualMachine); ok {
		err := augmentedMachine.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachine populates the provided destination VirtualMachine from our VirtualMachine
func (machine *VirtualMachine) AssignProperties_To_VirtualMachine(destination *v20201201s.VirtualMachine) error {

	// ObjectMeta
	destination.ObjectMeta = *machine.ObjectMeta.DeepCopy()

	// Spec
	var spec v20201201s.VirtualMachine_Spec
	err := machine.Spec.AssignProperties_To_VirtualMachine_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_VirtualMachine_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status v20201201s.VirtualMachine_STATUS
	err = machine.Status.AssignProperties_To_VirtualMachine_STATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_VirtualMachine_STATUS() to populate field Status")
	}
	destination.Status = status

	// Invoke the augmentConversionForVirtualMachine interface (if implemented) to customize the conversion
	var machineAsAny any = machine
	if augmentedMachine, ok := machineAsAny.(augmentConversionForVirtualMachine); ok {
		err := augmentedMachine.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (machine *VirtualMachine) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: machine.Spec.OriginalVersion,
		Kind:    "VirtualMachine",
	}
}

// +kubebuilder:object:root=true
// Storage version of v1beta20220301.VirtualMachine
// Deprecated version of VirtualMachine. Use v1api20220301.VirtualMachine instead
type VirtualMachineList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []VirtualMachine `json:"items"`
}

type augmentConversionForVirtualMachine interface {
	AssignPropertiesFrom(src *v20201201s.VirtualMachine) error
	AssignPropertiesTo(dst *v20201201s.VirtualMachine) error
}

// Storage version of v1beta20220301.VirtualMachine_Spec
type VirtualMachine_Spec struct {
	AdditionalCapabilities *AdditionalCapabilities `json:"additionalCapabilities,omitempty"`
	ApplicationProfile     *ApplicationProfile     `json:"applicationProfile,omitempty"`
	AvailabilitySet        *SubResource            `json:"availabilitySet,omitempty"`

	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName            string                      `json:"azureName,omitempty"`
	BillingProfile       *BillingProfile             `json:"billingProfile,omitempty"`
	CapacityReservation  *CapacityReservationProfile `json:"capacityReservation,omitempty"`
	DiagnosticsProfile   *DiagnosticsProfile         `json:"diagnosticsProfile,omitempty"`
	EvictionPolicy       *string                     `json:"evictionPolicy,omitempty"`
	ExtendedLocation     *ExtendedLocation           `json:"extendedLocation,omitempty"`
	ExtensionsTimeBudget *string                     `json:"extensionsTimeBudget,omitempty"`
	HardwareProfile      *HardwareProfile            `json:"hardwareProfile,omitempty"`
	Host                 *SubResource                `json:"host,omitempty"`
	HostGroup            *SubResource                `json:"hostGroup,omitempty"`
	Identity             *VirtualMachineIdentity     `json:"identity,omitempty"`
	LicenseType          *string                     `json:"licenseType,omitempty"`
	Location             *string                     `json:"location,omitempty"`
	NetworkProfile       *NetworkProfile             `json:"networkProfile,omitempty"`
	OriginalVersion      string                      `json:"originalVersion,omitempty"`
	OsProfile            *OSProfile                  `json:"osProfile,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner                   *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`
	Plan                    *Plan                              `json:"plan,omitempty"`
	PlatformFaultDomain     *int                               `json:"platformFaultDomain,omitempty"`
	Priority                *string                            `json:"priority,omitempty"`
	PropertyBag             genruntime.PropertyBag             `json:"$propertyBag,omitempty"`
	ProximityPlacementGroup *SubResource                       `json:"proximityPlacementGroup,omitempty"`
	ScheduledEventsProfile  *ScheduledEventsProfile            `json:"scheduledEventsProfile,omitempty"`
	SecurityProfile         *SecurityProfile                   `json:"securityProfile,omitempty"`
	StorageProfile          *StorageProfile                    `json:"storageProfile,omitempty"`
	Tags                    map[string]string                  `json:"tags,omitempty"`
	UserData                *string                            `json:"userData,omitempty"`
	VirtualMachineScaleSet  *SubResource                       `json:"virtualMachineScaleSet,omitempty"`
	Zones                   []string                           `json:"zones,omitempty"`
}

var _ genruntime.ConvertibleSpec = &VirtualMachine_Spec{}

// ConvertSpecFrom populates our VirtualMachine_Spec from the provided source
func (machine *VirtualMachine_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v20201201s.VirtualMachine_Spec)
	if ok {
		// Populate our instance from source
		return machine.AssignProperties_From_VirtualMachine_Spec(src)
	}

	// Convert to an intermediate form
	src = &v20201201s.VirtualMachine_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = machine.AssignProperties_From_VirtualMachine_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our VirtualMachine_Spec
func (machine *VirtualMachine_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v20201201s.VirtualMachine_Spec)
	if ok {
		// Populate destination from our instance
		return machine.AssignProperties_To_VirtualMachine_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &v20201201s.VirtualMachine_Spec{}
	err := machine.AssignProperties_To_VirtualMachine_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_VirtualMachine_Spec populates our VirtualMachine_Spec from the provided source VirtualMachine_Spec
func (machine *VirtualMachine_Spec) AssignProperties_From_VirtualMachine_Spec(source *v20201201s.VirtualMachine_Spec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AdditionalCapabilities
	if source.AdditionalCapabilities != nil {
		var additionalCapability AdditionalCapabilities
		err := additionalCapability.AssignProperties_From_AdditionalCapabilities(source.AdditionalCapabilities)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AdditionalCapabilities() to populate field AdditionalCapabilities")
		}
		machine.AdditionalCapabilities = &additionalCapability
	} else {
		machine.AdditionalCapabilities = nil
	}

	// ApplicationProfile
	if propertyBag.Contains("ApplicationProfile") {
		var applicationProfile ApplicationProfile
		err := propertyBag.Pull("ApplicationProfile", &applicationProfile)
		if err != nil {
			return errors.Wrap(err, "pulling 'ApplicationProfile' from propertyBag")
		}

		machine.ApplicationProfile = &applicationProfile
	} else {
		machine.ApplicationProfile = nil
	}

	// AvailabilitySet
	if source.AvailabilitySet != nil {
		var availabilitySet SubResource
		err := availabilitySet.AssignProperties_From_SubResource(source.AvailabilitySet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field AvailabilitySet")
		}
		machine.AvailabilitySet = &availabilitySet
	} else {
		machine.AvailabilitySet = nil
	}

	// AzureName
	machine.AzureName = source.AzureName

	// BillingProfile
	if source.BillingProfile != nil {
		var billingProfile BillingProfile
		err := billingProfile.AssignProperties_From_BillingProfile(source.BillingProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BillingProfile() to populate field BillingProfile")
		}
		machine.BillingProfile = &billingProfile
	} else {
		machine.BillingProfile = nil
	}

	// CapacityReservation
	if propertyBag.Contains("CapacityReservation") {
		var capacityReservation CapacityReservationProfile
		err := propertyBag.Pull("CapacityReservation", &capacityReservation)
		if err != nil {
			return errors.Wrap(err, "pulling 'CapacityReservation' from propertyBag")
		}

		machine.CapacityReservation = &capacityReservation
	} else {
		machine.CapacityReservation = nil
	}

	// DiagnosticsProfile
	if source.DiagnosticsProfile != nil {
		var diagnosticsProfile DiagnosticsProfile
		err := diagnosticsProfile.AssignProperties_From_DiagnosticsProfile(source.DiagnosticsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DiagnosticsProfile() to populate field DiagnosticsProfile")
		}
		machine.DiagnosticsProfile = &diagnosticsProfile
	} else {
		machine.DiagnosticsProfile = nil
	}

	// EvictionPolicy
	machine.EvictionPolicy = genruntime.ClonePointerToString(source.EvictionPolicy)

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocationStash v20200930s.ExtendedLocation
		err := extendedLocationStash.AssignProperties_From_ExtendedLocation(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ExtendedLocation() to populate field ExtendedLocationStash from ExtendedLocation")
		}
		var extendedLocation ExtendedLocation
		err = extendedLocation.AssignProperties_From_ExtendedLocation(&extendedLocationStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ExtendedLocation() to populate field ExtendedLocation from ExtendedLocationStash")
		}
		machine.ExtendedLocation = &extendedLocation
	} else {
		machine.ExtendedLocation = nil
	}

	// ExtensionsTimeBudget
	machine.ExtensionsTimeBudget = genruntime.ClonePointerToString(source.ExtensionsTimeBudget)

	// HardwareProfile
	if source.HardwareProfile != nil {
		var hardwareProfile HardwareProfile
		err := hardwareProfile.AssignProperties_From_HardwareProfile(source.HardwareProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HardwareProfile() to populate field HardwareProfile")
		}
		machine.HardwareProfile = &hardwareProfile
	} else {
		machine.HardwareProfile = nil
	}

	// Host
	if source.Host != nil {
		var host SubResource
		err := host.AssignProperties_From_SubResource(source.Host)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field Host")
		}
		machine.Host = &host
	} else {
		machine.Host = nil
	}

	// HostGroup
	if source.HostGroup != nil {
		var hostGroup SubResource
		err := hostGroup.AssignProperties_From_SubResource(source.HostGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field HostGroup")
		}
		machine.HostGroup = &hostGroup
	} else {
		machine.HostGroup = nil
	}

	// Identity
	if source.Identity != nil {
		var identity VirtualMachineIdentity
		err := identity.AssignProperties_From_VirtualMachineIdentity(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineIdentity() to populate field Identity")
		}
		machine.Identity = &identity
	} else {
		machine.Identity = nil
	}

	// LicenseType
	machine.LicenseType = genruntime.ClonePointerToString(source.LicenseType)

	// Location
	machine.Location = genruntime.ClonePointerToString(source.Location)

	// NetworkProfile
	if source.NetworkProfile != nil {
		var networkProfile NetworkProfile
		err := networkProfile.AssignProperties_From_NetworkProfile(source.NetworkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_NetworkProfile() to populate field NetworkProfile")
		}
		machine.NetworkProfile = &networkProfile
	} else {
		machine.NetworkProfile = nil
	}

	// OriginalVersion
	machine.OriginalVersion = source.OriginalVersion

	// OsProfile
	if source.OsProfile != nil {
		var osProfile OSProfile
		err := osProfile.AssignProperties_From_OSProfile(source.OsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_OSProfile() to populate field OsProfile")
		}
		machine.OsProfile = &osProfile
	} else {
		machine.OsProfile = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		machine.Owner = &owner
	} else {
		machine.Owner = nil
	}

	// Plan
	if source.Plan != nil {
		var plan Plan
		err := plan.AssignProperties_From_Plan(source.Plan)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Plan() to populate field Plan")
		}
		machine.Plan = &plan
	} else {
		machine.Plan = nil
	}

	// PlatformFaultDomain
	machine.PlatformFaultDomain = genruntime.ClonePointerToInt(source.PlatformFaultDomain)

	// Priority
	machine.Priority = genruntime.ClonePointerToString(source.Priority)

	// ProximityPlacementGroup
	if source.ProximityPlacementGroup != nil {
		var proximityPlacementGroup SubResource
		err := proximityPlacementGroup.AssignProperties_From_SubResource(source.ProximityPlacementGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field ProximityPlacementGroup")
		}
		machine.ProximityPlacementGroup = &proximityPlacementGroup
	} else {
		machine.ProximityPlacementGroup = nil
	}

	// ScheduledEventsProfile
	if propertyBag.Contains("ScheduledEventsProfile") {
		var scheduledEventsProfile ScheduledEventsProfile
		err := propertyBag.Pull("ScheduledEventsProfile", &scheduledEventsProfile)
		if err != nil {
			return errors.Wrap(err, "pulling 'ScheduledEventsProfile' from propertyBag")
		}

		machine.ScheduledEventsProfile = &scheduledEventsProfile
	} else {
		machine.ScheduledEventsProfile = nil
	}

	// SecurityProfile
	if source.SecurityProfile != nil {
		var securityProfile SecurityProfile
		err := securityProfile.AssignProperties_From_SecurityProfile(source.SecurityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SecurityProfile() to populate field SecurityProfile")
		}
		machine.SecurityProfile = &securityProfile
	} else {
		machine.SecurityProfile = nil
	}

	// StorageProfile
	if source.StorageProfile != nil {
		var storageProfile StorageProfile
		err := storageProfile.AssignProperties_From_StorageProfile(source.StorageProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_StorageProfile() to populate field StorageProfile")
		}
		machine.StorageProfile = &storageProfile
	} else {
		machine.StorageProfile = nil
	}

	// Tags
	machine.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// UserData
	if propertyBag.Contains("UserData") {
		var userDatum string
		err := propertyBag.Pull("UserData", &userDatum)
		if err != nil {
			return errors.Wrap(err, "pulling 'UserData' from propertyBag")
		}

		machine.UserData = &userDatum
	} else {
		machine.UserData = nil
	}

	// VirtualMachineScaleSet
	if source.VirtualMachineScaleSet != nil {
		var virtualMachineScaleSet SubResource
		err := virtualMachineScaleSet.AssignProperties_From_SubResource(source.VirtualMachineScaleSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field VirtualMachineScaleSet")
		}
		machine.VirtualMachineScaleSet = &virtualMachineScaleSet
	} else {
		machine.VirtualMachineScaleSet = nil
	}

	// Zones
	machine.Zones = genruntime.CloneSliceOfString(source.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		machine.PropertyBag = propertyBag
	} else {
		machine.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachine_Spec interface (if implemented) to customize the conversion
	var machineAsAny any = machine
	if augmentedMachine, ok := machineAsAny.(augmentConversionForVirtualMachine_Spec); ok {
		err := augmentedMachine.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachine_Spec populates the provided destination VirtualMachine_Spec from our VirtualMachine_Spec
func (machine *VirtualMachine_Spec) AssignProperties_To_VirtualMachine_Spec(destination *v20201201s.VirtualMachine_Spec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(machine.PropertyBag)

	// AdditionalCapabilities
	if machine.AdditionalCapabilities != nil {
		var additionalCapability v20201201s.AdditionalCapabilities
		err := machine.AdditionalCapabilities.AssignProperties_To_AdditionalCapabilities(&additionalCapability)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AdditionalCapabilities() to populate field AdditionalCapabilities")
		}
		destination.AdditionalCapabilities = &additionalCapability
	} else {
		destination.AdditionalCapabilities = nil
	}

	// ApplicationProfile
	if machine.ApplicationProfile != nil {
		propertyBag.Add("ApplicationProfile", *machine.ApplicationProfile)
	} else {
		propertyBag.Remove("ApplicationProfile")
	}

	// AvailabilitySet
	if machine.AvailabilitySet != nil {
		var availabilitySet v20201201s.SubResource
		err := machine.AvailabilitySet.AssignProperties_To_SubResource(&availabilitySet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field AvailabilitySet")
		}
		destination.AvailabilitySet = &availabilitySet
	} else {
		destination.AvailabilitySet = nil
	}

	// AzureName
	destination.AzureName = machine.AzureName

	// BillingProfile
	if machine.BillingProfile != nil {
		var billingProfile v20201201s.BillingProfile
		err := machine.BillingProfile.AssignProperties_To_BillingProfile(&billingProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BillingProfile() to populate field BillingProfile")
		}
		destination.BillingProfile = &billingProfile
	} else {
		destination.BillingProfile = nil
	}

	// CapacityReservation
	if machine.CapacityReservation != nil {
		propertyBag.Add("CapacityReservation", *machine.CapacityReservation)
	} else {
		propertyBag.Remove("CapacityReservation")
	}

	// DiagnosticsProfile
	if machine.DiagnosticsProfile != nil {
		var diagnosticsProfile v20201201s.DiagnosticsProfile
		err := machine.DiagnosticsProfile.AssignProperties_To_DiagnosticsProfile(&diagnosticsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DiagnosticsProfile() to populate field DiagnosticsProfile")
		}
		destination.DiagnosticsProfile = &diagnosticsProfile
	} else {
		destination.DiagnosticsProfile = nil
	}

	// EvictionPolicy
	destination.EvictionPolicy = genruntime.ClonePointerToString(machine.EvictionPolicy)

	// ExtendedLocation
	if machine.ExtendedLocation != nil {
		var extendedLocationStash v20200930s.ExtendedLocation
		err := machine.ExtendedLocation.AssignProperties_To_ExtendedLocation(&extendedLocationStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ExtendedLocation() to populate field ExtendedLocationStash from ExtendedLocation")
		}
		var extendedLocation v20201201s.ExtendedLocation
		err = extendedLocationStash.AssignProperties_To_ExtendedLocation(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ExtendedLocation() to populate field ExtendedLocation from ExtendedLocationStash")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// ExtensionsTimeBudget
	destination.ExtensionsTimeBudget = genruntime.ClonePointerToString(machine.ExtensionsTimeBudget)

	// HardwareProfile
	if machine.HardwareProfile != nil {
		var hardwareProfile v20201201s.HardwareProfile
		err := machine.HardwareProfile.AssignProperties_To_HardwareProfile(&hardwareProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HardwareProfile() to populate field HardwareProfile")
		}
		destination.HardwareProfile = &hardwareProfile
	} else {
		destination.HardwareProfile = nil
	}

	// Host
	if machine.Host != nil {
		var host v20201201s.SubResource
		err := machine.Host.AssignProperties_To_SubResource(&host)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field Host")
		}
		destination.Host = &host
	} else {
		destination.Host = nil
	}

	// HostGroup
	if machine.HostGroup != nil {
		var hostGroup v20201201s.SubResource
		err := machine.HostGroup.AssignProperties_To_SubResource(&hostGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field HostGroup")
		}
		destination.HostGroup = &hostGroup
	} else {
		destination.HostGroup = nil
	}

	// Identity
	if machine.Identity != nil {
		var identity v20201201s.VirtualMachineIdentity
		err := machine.Identity.AssignProperties_To_VirtualMachineIdentity(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineIdentity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// LicenseType
	destination.LicenseType = genruntime.ClonePointerToString(machine.LicenseType)

	// Location
	destination.Location = genruntime.ClonePointerToString(machine.Location)

	// NetworkProfile
	if machine.NetworkProfile != nil {
		var networkProfile v20201201s.NetworkProfile
		err := machine.NetworkProfile.AssignProperties_To_NetworkProfile(&networkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_NetworkProfile() to populate field NetworkProfile")
		}
		destination.NetworkProfile = &networkProfile
	} else {
		destination.NetworkProfile = nil
	}

	// OriginalVersion
	destination.OriginalVersion = machine.OriginalVersion

	// OsProfile
	if machine.OsProfile != nil {
		var osProfile v20201201s.OSProfile
		err := machine.OsProfile.AssignProperties_To_OSProfile(&osProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_OSProfile() to populate field OsProfile")
		}
		destination.OsProfile = &osProfile
	} else {
		destination.OsProfile = nil
	}

	// Owner
	if machine.Owner != nil {
		owner := machine.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// Plan
	if machine.Plan != nil {
		var plan v20201201s.Plan
		err := machine.Plan.AssignProperties_To_Plan(&plan)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Plan() to populate field Plan")
		}
		destination.Plan = &plan
	} else {
		destination.Plan = nil
	}

	// PlatformFaultDomain
	destination.PlatformFaultDomain = genruntime.ClonePointerToInt(machine.PlatformFaultDomain)

	// Priority
	destination.Priority = genruntime.ClonePointerToString(machine.Priority)

	// ProximityPlacementGroup
	if machine.ProximityPlacementGroup != nil {
		var proximityPlacementGroup v20201201s.SubResource
		err := machine.ProximityPlacementGroup.AssignProperties_To_SubResource(&proximityPlacementGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field ProximityPlacementGroup")
		}
		destination.ProximityPlacementGroup = &proximityPlacementGroup
	} else {
		destination.ProximityPlacementGroup = nil
	}

	// ScheduledEventsProfile
	if machine.ScheduledEventsProfile != nil {
		propertyBag.Add("ScheduledEventsProfile", *machine.ScheduledEventsProfile)
	} else {
		propertyBag.Remove("ScheduledEventsProfile")
	}

	// SecurityProfile
	if machine.SecurityProfile != nil {
		var securityProfile v20201201s.SecurityProfile
		err := machine.SecurityProfile.AssignProperties_To_SecurityProfile(&securityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SecurityProfile() to populate field SecurityProfile")
		}
		destination.SecurityProfile = &securityProfile
	} else {
		destination.SecurityProfile = nil
	}

	// StorageProfile
	if machine.StorageProfile != nil {
		var storageProfile v20201201s.StorageProfile
		err := machine.StorageProfile.AssignProperties_To_StorageProfile(&storageProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_StorageProfile() to populate field StorageProfile")
		}
		destination.StorageProfile = &storageProfile
	} else {
		destination.StorageProfile = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(machine.Tags)

	// UserData
	if machine.UserData != nil {
		propertyBag.Add("UserData", *machine.UserData)
	} else {
		propertyBag.Remove("UserData")
	}

	// VirtualMachineScaleSet
	if machine.VirtualMachineScaleSet != nil {
		var virtualMachineScaleSet v20201201s.SubResource
		err := machine.VirtualMachineScaleSet.AssignProperties_To_SubResource(&virtualMachineScaleSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field VirtualMachineScaleSet")
		}
		destination.VirtualMachineScaleSet = &virtualMachineScaleSet
	} else {
		destination.VirtualMachineScaleSet = nil
	}

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(machine.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachine_Spec interface (if implemented) to customize the conversion
	var machineAsAny any = machine
	if augmentedMachine, ok := machineAsAny.(augmentConversionForVirtualMachine_Spec); ok {
		err := augmentedMachine.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.VirtualMachine_STATUS
// Deprecated version of VirtualMachine_STATUS. Use v1api20220301.VirtualMachine_STATUS instead
type VirtualMachine_STATUS struct {
	AdditionalCapabilities  *AdditionalCapabilities_STATUS     `json:"additionalCapabilities,omitempty"`
	ApplicationProfile      *ApplicationProfile_STATUS         `json:"applicationProfile,omitempty"`
	AvailabilitySet         *SubResource_STATUS                `json:"availabilitySet,omitempty"`
	BillingProfile          *BillingProfile_STATUS             `json:"billingProfile,omitempty"`
	CapacityReservation     *CapacityReservationProfile_STATUS `json:"capacityReservation,omitempty"`
	Conditions              []conditions.Condition             `json:"conditions,omitempty"`
	DiagnosticsProfile      *DiagnosticsProfile_STATUS         `json:"diagnosticsProfile,omitempty"`
	EvictionPolicy          *string                            `json:"evictionPolicy,omitempty"`
	ExtendedLocation        *ExtendedLocation_STATUS           `json:"extendedLocation,omitempty"`
	ExtensionsTimeBudget    *string                            `json:"extensionsTimeBudget,omitempty"`
	HardwareProfile         *HardwareProfile_STATUS            `json:"hardwareProfile,omitempty"`
	Host                    *SubResource_STATUS                `json:"host,omitempty"`
	HostGroup               *SubResource_STATUS                `json:"hostGroup,omitempty"`
	Id                      *string                            `json:"id,omitempty"`
	Identity                *VirtualMachineIdentity_STATUS     `json:"identity,omitempty"`
	InstanceView            *VirtualMachineInstanceView_STATUS `json:"instanceView,omitempty"`
	LicenseType             *string                            `json:"licenseType,omitempty"`
	Location                *string                            `json:"location,omitempty"`
	Name                    *string                            `json:"name,omitempty"`
	NetworkProfile          *NetworkProfile_STATUS             `json:"networkProfile,omitempty"`
	OsProfile               *OSProfile_STATUS                  `json:"osProfile,omitempty"`
	Plan                    *Plan_STATUS                       `json:"plan,omitempty"`
	PlatformFaultDomain     *int                               `json:"platformFaultDomain,omitempty"`
	Priority                *string                            `json:"priority,omitempty"`
	PropertyBag             genruntime.PropertyBag             `json:"$propertyBag,omitempty"`
	ProvisioningState       *string                            `json:"provisioningState,omitempty"`
	ProximityPlacementGroup *SubResource_STATUS                `json:"proximityPlacementGroup,omitempty"`
	Resources               []VirtualMachineExtension_STATUS   `json:"resources,omitempty"`
	ScheduledEventsProfile  *ScheduledEventsProfile_STATUS     `json:"scheduledEventsProfile,omitempty"`
	SecurityProfile         *SecurityProfile_STATUS            `json:"securityProfile,omitempty"`
	StorageProfile          *StorageProfile_STATUS             `json:"storageProfile,omitempty"`
	Tags                    map[string]string                  `json:"tags,omitempty"`
	TimeCreated             *string                            `json:"timeCreated,omitempty"`
	Type                    *string                            `json:"type,omitempty"`
	UserData                *string                            `json:"userData,omitempty"`
	VirtualMachineScaleSet  *SubResource_STATUS                `json:"virtualMachineScaleSet,omitempty"`
	VmId                    *string                            `json:"vmId,omitempty"`
	Zones                   []string                           `json:"zones,omitempty"`
}

var _ genruntime.ConvertibleStatus = &VirtualMachine_STATUS{}

// ConvertStatusFrom populates our VirtualMachine_STATUS from the provided source
func (machine *VirtualMachine_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v20201201s.VirtualMachine_STATUS)
	if ok {
		// Populate our instance from source
		return machine.AssignProperties_From_VirtualMachine_STATUS(src)
	}

	// Convert to an intermediate form
	src = &v20201201s.VirtualMachine_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = machine.AssignProperties_From_VirtualMachine_STATUS(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our VirtualMachine_STATUS
func (machine *VirtualMachine_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v20201201s.VirtualMachine_STATUS)
	if ok {
		// Populate destination from our instance
		return machine.AssignProperties_To_VirtualMachine_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &v20201201s.VirtualMachine_STATUS{}
	err := machine.AssignProperties_To_VirtualMachine_STATUS(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

// AssignProperties_From_VirtualMachine_STATUS populates our VirtualMachine_STATUS from the provided source VirtualMachine_STATUS
func (machine *VirtualMachine_STATUS) AssignProperties_From_VirtualMachine_STATUS(source *v20201201s.VirtualMachine_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AdditionalCapabilities
	if source.AdditionalCapabilities != nil {
		var additionalCapability AdditionalCapabilities_STATUS
		err := additionalCapability.AssignProperties_From_AdditionalCapabilities_STATUS(source.AdditionalCapabilities)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AdditionalCapabilities_STATUS() to populate field AdditionalCapabilities")
		}
		machine.AdditionalCapabilities = &additionalCapability
	} else {
		machine.AdditionalCapabilities = nil
	}

	// ApplicationProfile
	if propertyBag.Contains("ApplicationProfile") {
		var applicationProfile ApplicationProfile_STATUS
		err := propertyBag.Pull("ApplicationProfile", &applicationProfile)
		if err != nil {
			return errors.Wrap(err, "pulling 'ApplicationProfile' from propertyBag")
		}

		machine.ApplicationProfile = &applicationProfile
	} else {
		machine.ApplicationProfile = nil
	}

	// AvailabilitySet
	if source.AvailabilitySet != nil {
		var availabilitySet SubResource_STATUS
		err := availabilitySet.AssignProperties_From_SubResource_STATUS(source.AvailabilitySet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field AvailabilitySet")
		}
		machine.AvailabilitySet = &availabilitySet
	} else {
		machine.AvailabilitySet = nil
	}

	// BillingProfile
	if source.BillingProfile != nil {
		var billingProfile BillingProfile_STATUS
		err := billingProfile.AssignProperties_From_BillingProfile_STATUS(source.BillingProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BillingProfile_STATUS() to populate field BillingProfile")
		}
		machine.BillingProfile = &billingProfile
	} else {
		machine.BillingProfile = nil
	}

	// CapacityReservation
	if propertyBag.Contains("CapacityReservation") {
		var capacityReservation CapacityReservationProfile_STATUS
		err := propertyBag.Pull("CapacityReservation", &capacityReservation)
		if err != nil {
			return errors.Wrap(err, "pulling 'CapacityReservation' from propertyBag")
		}

		machine.CapacityReservation = &capacityReservation
	} else {
		machine.CapacityReservation = nil
	}

	// Conditions
	machine.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// DiagnosticsProfile
	if source.DiagnosticsProfile != nil {
		var diagnosticsProfile DiagnosticsProfile_STATUS
		err := diagnosticsProfile.AssignProperties_From_DiagnosticsProfile_STATUS(source.DiagnosticsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DiagnosticsProfile_STATUS() to populate field DiagnosticsProfile")
		}
		machine.DiagnosticsProfile = &diagnosticsProfile
	} else {
		machine.DiagnosticsProfile = nil
	}

	// EvictionPolicy
	machine.EvictionPolicy = genruntime.ClonePointerToString(source.EvictionPolicy)

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocationSTATUSStash v20200930s.ExtendedLocation_STATUS
		err := extendedLocationSTATUSStash.AssignProperties_From_ExtendedLocation_STATUS(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ExtendedLocation_STATUS() to populate field ExtendedLocation_STATUSStash from ExtendedLocation")
		}
		var extendedLocation ExtendedLocation_STATUS
		err = extendedLocation.AssignProperties_From_ExtendedLocation_STATUS(&extendedLocationSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ExtendedLocation_STATUS() to populate field ExtendedLocation from ExtendedLocation_STATUSStash")
		}
		machine.ExtendedLocation = &extendedLocation
	} else {
		machine.ExtendedLocation = nil
	}

	// ExtensionsTimeBudget
	machine.ExtensionsTimeBudget = genruntime.ClonePointerToString(source.ExtensionsTimeBudget)

	// HardwareProfile
	if source.HardwareProfile != nil {
		var hardwareProfile HardwareProfile_STATUS
		err := hardwareProfile.AssignProperties_From_HardwareProfile_STATUS(source.HardwareProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HardwareProfile_STATUS() to populate field HardwareProfile")
		}
		machine.HardwareProfile = &hardwareProfile
	} else {
		machine.HardwareProfile = nil
	}

	// Host
	if source.Host != nil {
		var host SubResource_STATUS
		err := host.AssignProperties_From_SubResource_STATUS(source.Host)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field Host")
		}
		machine.Host = &host
	} else {
		machine.Host = nil
	}

	// HostGroup
	if source.HostGroup != nil {
		var hostGroup SubResource_STATUS
		err := hostGroup.AssignProperties_From_SubResource_STATUS(source.HostGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field HostGroup")
		}
		machine.HostGroup = &hostGroup
	} else {
		machine.HostGroup = nil
	}

	// Id
	machine.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity VirtualMachineIdentity_STATUS
		err := identity.AssignProperties_From_VirtualMachineIdentity_STATUS(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineIdentity_STATUS() to populate field Identity")
		}
		machine.Identity = &identity
	} else {
		machine.Identity = nil
	}

	// InstanceView
	if source.InstanceView != nil {
		var instanceView VirtualMachineInstanceView_STATUS
		err := instanceView.AssignProperties_From_VirtualMachineInstanceView_STATUS(source.InstanceView)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineInstanceView_STATUS() to populate field InstanceView")
		}
		machine.InstanceView = &instanceView
	} else {
		machine.InstanceView = nil
	}

	// LicenseType
	machine.LicenseType = genruntime.ClonePointerToString(source.LicenseType)

	// Location
	machine.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	machine.Name = genruntime.ClonePointerToString(source.Name)

	// NetworkProfile
	if source.NetworkProfile != nil {
		var networkProfile NetworkProfile_STATUS
		err := networkProfile.AssignProperties_From_NetworkProfile_STATUS(source.NetworkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_NetworkProfile_STATUS() to populate field NetworkProfile")
		}
		machine.NetworkProfile = &networkProfile
	} else {
		machine.NetworkProfile = nil
	}

	// OsProfile
	if source.OsProfile != nil {
		var osProfile OSProfile_STATUS
		err := osProfile.AssignProperties_From_OSProfile_STATUS(source.OsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_OSProfile_STATUS() to populate field OsProfile")
		}
		machine.OsProfile = &osProfile
	} else {
		machine.OsProfile = nil
	}

	// Plan
	if source.Plan != nil {
		var plan Plan_STATUS
		err := plan.AssignProperties_From_Plan_STATUS(source.Plan)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Plan_STATUS() to populate field Plan")
		}
		machine.Plan = &plan
	} else {
		machine.Plan = nil
	}

	// PlatformFaultDomain
	machine.PlatformFaultDomain = genruntime.ClonePointerToInt(source.PlatformFaultDomain)

	// Priority
	machine.Priority = genruntime.ClonePointerToString(source.Priority)

	// ProvisioningState
	machine.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// ProximityPlacementGroup
	if source.ProximityPlacementGroup != nil {
		var proximityPlacementGroup SubResource_STATUS
		err := proximityPlacementGroup.AssignProperties_From_SubResource_STATUS(source.ProximityPlacementGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field ProximityPlacementGroup")
		}
		machine.ProximityPlacementGroup = &proximityPlacementGroup
	} else {
		machine.ProximityPlacementGroup = nil
	}

	// Resources
	if source.Resources != nil {
		resourceList := make([]VirtualMachineExtension_STATUS, len(source.Resources))
		for resourceIndex, resourceItem := range source.Resources {
			// Shadow the loop variable to avoid aliasing
			resourceItem := resourceItem
			var resource VirtualMachineExtension_STATUS
			err := resource.AssignProperties_From_VirtualMachineExtension_STATUS(&resourceItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineExtension_STATUS() to populate field Resources")
			}
			resourceList[resourceIndex] = resource
		}
		machine.Resources = resourceList
	} else {
		machine.Resources = nil
	}

	// ScheduledEventsProfile
	if propertyBag.Contains("ScheduledEventsProfile") {
		var scheduledEventsProfile ScheduledEventsProfile_STATUS
		err := propertyBag.Pull("ScheduledEventsProfile", &scheduledEventsProfile)
		if err != nil {
			return errors.Wrap(err, "pulling 'ScheduledEventsProfile' from propertyBag")
		}

		machine.ScheduledEventsProfile = &scheduledEventsProfile
	} else {
		machine.ScheduledEventsProfile = nil
	}

	// SecurityProfile
	if source.SecurityProfile != nil {
		var securityProfile SecurityProfile_STATUS
		err := securityProfile.AssignProperties_From_SecurityProfile_STATUS(source.SecurityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SecurityProfile_STATUS() to populate field SecurityProfile")
		}
		machine.SecurityProfile = &securityProfile
	} else {
		machine.SecurityProfile = nil
	}

	// StorageProfile
	if source.StorageProfile != nil {
		var storageProfile StorageProfile_STATUS
		err := storageProfile.AssignProperties_From_StorageProfile_STATUS(source.StorageProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_StorageProfile_STATUS() to populate field StorageProfile")
		}
		machine.StorageProfile = &storageProfile
	} else {
		machine.StorageProfile = nil
	}

	// Tags
	machine.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// TimeCreated
	if propertyBag.Contains("TimeCreated") {
		var timeCreated string
		err := propertyBag.Pull("TimeCreated", &timeCreated)
		if err != nil {
			return errors.Wrap(err, "pulling 'TimeCreated' from propertyBag")
		}

		machine.TimeCreated = &timeCreated
	} else {
		machine.TimeCreated = nil
	}

	// Type
	machine.Type = genruntime.ClonePointerToString(source.Type)

	// UserData
	if propertyBag.Contains("UserData") {
		var userDatum string
		err := propertyBag.Pull("UserData", &userDatum)
		if err != nil {
			return errors.Wrap(err, "pulling 'UserData' from propertyBag")
		}

		machine.UserData = &userDatum
	} else {
		machine.UserData = nil
	}

	// VirtualMachineScaleSet
	if source.VirtualMachineScaleSet != nil {
		var virtualMachineScaleSet SubResource_STATUS
		err := virtualMachineScaleSet.AssignProperties_From_SubResource_STATUS(source.VirtualMachineScaleSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field VirtualMachineScaleSet")
		}
		machine.VirtualMachineScaleSet = &virtualMachineScaleSet
	} else {
		machine.VirtualMachineScaleSet = nil
	}

	// VmId
	machine.VmId = genruntime.ClonePointerToString(source.VmId)

	// Zones
	machine.Zones = genruntime.CloneSliceOfString(source.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		machine.PropertyBag = propertyBag
	} else {
		machine.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachine_STATUS interface (if implemented) to customize the conversion
	var machineAsAny any = machine
	if augmentedMachine, ok := machineAsAny.(augmentConversionForVirtualMachine_STATUS); ok {
		err := augmentedMachine.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachine_STATUS populates the provided destination VirtualMachine_STATUS from our VirtualMachine_STATUS
func (machine *VirtualMachine_STATUS) AssignProperties_To_VirtualMachine_STATUS(destination *v20201201s.VirtualMachine_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(machine.PropertyBag)

	// AdditionalCapabilities
	if machine.AdditionalCapabilities != nil {
		var additionalCapability v20201201s.AdditionalCapabilities_STATUS
		err := machine.AdditionalCapabilities.AssignProperties_To_AdditionalCapabilities_STATUS(&additionalCapability)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AdditionalCapabilities_STATUS() to populate field AdditionalCapabilities")
		}
		destination.AdditionalCapabilities = &additionalCapability
	} else {
		destination.AdditionalCapabilities = nil
	}

	// ApplicationProfile
	if machine.ApplicationProfile != nil {
		propertyBag.Add("ApplicationProfile", *machine.ApplicationProfile)
	} else {
		propertyBag.Remove("ApplicationProfile")
	}

	// AvailabilitySet
	if machine.AvailabilitySet != nil {
		var availabilitySet v20201201s.SubResource_STATUS
		err := machine.AvailabilitySet.AssignProperties_To_SubResource_STATUS(&availabilitySet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field AvailabilitySet")
		}
		destination.AvailabilitySet = &availabilitySet
	} else {
		destination.AvailabilitySet = nil
	}

	// BillingProfile
	if machine.BillingProfile != nil {
		var billingProfile v20201201s.BillingProfile_STATUS
		err := machine.BillingProfile.AssignProperties_To_BillingProfile_STATUS(&billingProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BillingProfile_STATUS() to populate field BillingProfile")
		}
		destination.BillingProfile = &billingProfile
	} else {
		destination.BillingProfile = nil
	}

	// CapacityReservation
	if machine.CapacityReservation != nil {
		propertyBag.Add("CapacityReservation", *machine.CapacityReservation)
	} else {
		propertyBag.Remove("CapacityReservation")
	}

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(machine.Conditions)

	// DiagnosticsProfile
	if machine.DiagnosticsProfile != nil {
		var diagnosticsProfile v20201201s.DiagnosticsProfile_STATUS
		err := machine.DiagnosticsProfile.AssignProperties_To_DiagnosticsProfile_STATUS(&diagnosticsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DiagnosticsProfile_STATUS() to populate field DiagnosticsProfile")
		}
		destination.DiagnosticsProfile = &diagnosticsProfile
	} else {
		destination.DiagnosticsProfile = nil
	}

	// EvictionPolicy
	destination.EvictionPolicy = genruntime.ClonePointerToString(machine.EvictionPolicy)

	// ExtendedLocation
	if machine.ExtendedLocation != nil {
		var extendedLocationSTATUSStash v20200930s.ExtendedLocation_STATUS
		err := machine.ExtendedLocation.AssignProperties_To_ExtendedLocation_STATUS(&extendedLocationSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ExtendedLocation_STATUS() to populate field ExtendedLocation_STATUSStash from ExtendedLocation")
		}
		var extendedLocation v20201201s.ExtendedLocation_STATUS
		err = extendedLocationSTATUSStash.AssignProperties_To_ExtendedLocation_STATUS(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ExtendedLocation_STATUS() to populate field ExtendedLocation from ExtendedLocation_STATUSStash")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// ExtensionsTimeBudget
	destination.ExtensionsTimeBudget = genruntime.ClonePointerToString(machine.ExtensionsTimeBudget)

	// HardwareProfile
	if machine.HardwareProfile != nil {
		var hardwareProfile v20201201s.HardwareProfile_STATUS
		err := machine.HardwareProfile.AssignProperties_To_HardwareProfile_STATUS(&hardwareProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HardwareProfile_STATUS() to populate field HardwareProfile")
		}
		destination.HardwareProfile = &hardwareProfile
	} else {
		destination.HardwareProfile = nil
	}

	// Host
	if machine.Host != nil {
		var host v20201201s.SubResource_STATUS
		err := machine.Host.AssignProperties_To_SubResource_STATUS(&host)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field Host")
		}
		destination.Host = &host
	} else {
		destination.Host = nil
	}

	// HostGroup
	if machine.HostGroup != nil {
		var hostGroup v20201201s.SubResource_STATUS
		err := machine.HostGroup.AssignProperties_To_SubResource_STATUS(&hostGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field HostGroup")
		}
		destination.HostGroup = &hostGroup
	} else {
		destination.HostGroup = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(machine.Id)

	// Identity
	if machine.Identity != nil {
		var identity v20201201s.VirtualMachineIdentity_STATUS
		err := machine.Identity.AssignProperties_To_VirtualMachineIdentity_STATUS(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineIdentity_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// InstanceView
	if machine.InstanceView != nil {
		var instanceView v20201201s.VirtualMachineInstanceView_STATUS
		err := machine.InstanceView.AssignProperties_To_VirtualMachineInstanceView_STATUS(&instanceView)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineInstanceView_STATUS() to populate field InstanceView")
		}
		destination.InstanceView = &instanceView
	} else {
		destination.InstanceView = nil
	}

	// LicenseType
	destination.LicenseType = genruntime.ClonePointerToString(machine.LicenseType)

	// Location
	destination.Location = genruntime.ClonePointerToString(machine.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(machine.Name)

	// NetworkProfile
	if machine.NetworkProfile != nil {
		var networkProfile v20201201s.NetworkProfile_STATUS
		err := machine.NetworkProfile.AssignProperties_To_NetworkProfile_STATUS(&networkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_NetworkProfile_STATUS() to populate field NetworkProfile")
		}
		destination.NetworkProfile = &networkProfile
	} else {
		destination.NetworkProfile = nil
	}

	// OsProfile
	if machine.OsProfile != nil {
		var osProfile v20201201s.OSProfile_STATUS
		err := machine.OsProfile.AssignProperties_To_OSProfile_STATUS(&osProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_OSProfile_STATUS() to populate field OsProfile")
		}
		destination.OsProfile = &osProfile
	} else {
		destination.OsProfile = nil
	}

	// Plan
	if machine.Plan != nil {
		var plan v20201201s.Plan_STATUS
		err := machine.Plan.AssignProperties_To_Plan_STATUS(&plan)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Plan_STATUS() to populate field Plan")
		}
		destination.Plan = &plan
	} else {
		destination.Plan = nil
	}

	// PlatformFaultDomain
	destination.PlatformFaultDomain = genruntime.ClonePointerToInt(machine.PlatformFaultDomain)

	// Priority
	destination.Priority = genruntime.ClonePointerToString(machine.Priority)

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(machine.ProvisioningState)

	// ProximityPlacementGroup
	if machine.ProximityPlacementGroup != nil {
		var proximityPlacementGroup v20201201s.SubResource_STATUS
		err := machine.ProximityPlacementGroup.AssignProperties_To_SubResource_STATUS(&proximityPlacementGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field ProximityPlacementGroup")
		}
		destination.ProximityPlacementGroup = &proximityPlacementGroup
	} else {
		destination.ProximityPlacementGroup = nil
	}

	// Resources
	if machine.Resources != nil {
		resourceList := make([]v20201201s.VirtualMachineExtension_STATUS, len(machine.Resources))
		for resourceIndex, resourceItem := range machine.Resources {
			// Shadow the loop variable to avoid aliasing
			resourceItem := resourceItem
			var resource v20201201s.VirtualMachineExtension_STATUS
			err := resourceItem.AssignProperties_To_VirtualMachineExtension_STATUS(&resource)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineExtension_STATUS() to populate field Resources")
			}
			resourceList[resourceIndex] = resource
		}
		destination.Resources = resourceList
	} else {
		destination.Resources = nil
	}

	// ScheduledEventsProfile
	if machine.ScheduledEventsProfile != nil {
		propertyBag.Add("ScheduledEventsProfile", *machine.ScheduledEventsProfile)
	} else {
		propertyBag.Remove("ScheduledEventsProfile")
	}

	// SecurityProfile
	if machine.SecurityProfile != nil {
		var securityProfile v20201201s.SecurityProfile_STATUS
		err := machine.SecurityProfile.AssignProperties_To_SecurityProfile_STATUS(&securityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SecurityProfile_STATUS() to populate field SecurityProfile")
		}
		destination.SecurityProfile = &securityProfile
	} else {
		destination.SecurityProfile = nil
	}

	// StorageProfile
	if machine.StorageProfile != nil {
		var storageProfile v20201201s.StorageProfile_STATUS
		err := machine.StorageProfile.AssignProperties_To_StorageProfile_STATUS(&storageProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_StorageProfile_STATUS() to populate field StorageProfile")
		}
		destination.StorageProfile = &storageProfile
	} else {
		destination.StorageProfile = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(machine.Tags)

	// TimeCreated
	if machine.TimeCreated != nil {
		propertyBag.Add("TimeCreated", *machine.TimeCreated)
	} else {
		propertyBag.Remove("TimeCreated")
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(machine.Type)

	// UserData
	if machine.UserData != nil {
		propertyBag.Add("UserData", *machine.UserData)
	} else {
		propertyBag.Remove("UserData")
	}

	// VirtualMachineScaleSet
	if machine.VirtualMachineScaleSet != nil {
		var virtualMachineScaleSet v20201201s.SubResource_STATUS
		err := machine.VirtualMachineScaleSet.AssignProperties_To_SubResource_STATUS(&virtualMachineScaleSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field VirtualMachineScaleSet")
		}
		destination.VirtualMachineScaleSet = &virtualMachineScaleSet
	} else {
		destination.VirtualMachineScaleSet = nil
	}

	// VmId
	destination.VmId = genruntime.ClonePointerToString(machine.VmId)

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(machine.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachine_STATUS interface (if implemented) to customize the conversion
	var machineAsAny any = machine
	if augmentedMachine, ok := machineAsAny.(augmentConversionForVirtualMachine_STATUS); ok {
		err := augmentedMachine.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.AdditionalCapabilities
// Deprecated version of AdditionalCapabilities. Use v1api20220301.AdditionalCapabilities instead
type AdditionalCapabilities struct {
	HibernationEnabled *bool                  `json:"hibernationEnabled,omitempty"`
	PropertyBag        genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	UltraSSDEnabled    *bool                  `json:"ultraSSDEnabled,omitempty"`
}

// AssignProperties_From_AdditionalCapabilities populates our AdditionalCapabilities from the provided source AdditionalCapabilities
func (capabilities *AdditionalCapabilities) AssignProperties_From_AdditionalCapabilities(source *v20201201s.AdditionalCapabilities) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// HibernationEnabled
	if propertyBag.Contains("HibernationEnabled") {
		var hibernationEnabled bool
		err := propertyBag.Pull("HibernationEnabled", &hibernationEnabled)
		if err != nil {
			return errors.Wrap(err, "pulling 'HibernationEnabled' from propertyBag")
		}

		capabilities.HibernationEnabled = &hibernationEnabled
	} else {
		capabilities.HibernationEnabled = nil
	}

	// UltraSSDEnabled
	if source.UltraSSDEnabled != nil {
		ultraSSDEnabled := *source.UltraSSDEnabled
		capabilities.UltraSSDEnabled = &ultraSSDEnabled
	} else {
		capabilities.UltraSSDEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		capabilities.PropertyBag = propertyBag
	} else {
		capabilities.PropertyBag = nil
	}

	// Invoke the augmentConversionForAdditionalCapabilities interface (if implemented) to customize the conversion
	var capabilitiesAsAny any = capabilities
	if augmentedCapabilities, ok := capabilitiesAsAny.(augmentConversionForAdditionalCapabilities); ok {
		err := augmentedCapabilities.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AdditionalCapabilities populates the provided destination AdditionalCapabilities from our AdditionalCapabilities
func (capabilities *AdditionalCapabilities) AssignProperties_To_AdditionalCapabilities(destination *v20201201s.AdditionalCapabilities) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(capabilities.PropertyBag)

	// HibernationEnabled
	if capabilities.HibernationEnabled != nil {
		propertyBag.Add("HibernationEnabled", *capabilities.HibernationEnabled)
	} else {
		propertyBag.Remove("HibernationEnabled")
	}

	// UltraSSDEnabled
	if capabilities.UltraSSDEnabled != nil {
		ultraSSDEnabled := *capabilities.UltraSSDEnabled
		destination.UltraSSDEnabled = &ultraSSDEnabled
	} else {
		destination.UltraSSDEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAdditionalCapabilities interface (if implemented) to customize the conversion
	var capabilitiesAsAny any = capabilities
	if augmentedCapabilities, ok := capabilitiesAsAny.(augmentConversionForAdditionalCapabilities); ok {
		err := augmentedCapabilities.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.AdditionalCapabilities_STATUS
// Deprecated version of AdditionalCapabilities_STATUS. Use v1api20220301.AdditionalCapabilities_STATUS instead
type AdditionalCapabilities_STATUS struct {
	HibernationEnabled *bool                  `json:"hibernationEnabled,omitempty"`
	PropertyBag        genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	UltraSSDEnabled    *bool                  `json:"ultraSSDEnabled,omitempty"`
}

// AssignProperties_From_AdditionalCapabilities_STATUS populates our AdditionalCapabilities_STATUS from the provided source AdditionalCapabilities_STATUS
func (capabilities *AdditionalCapabilities_STATUS) AssignProperties_From_AdditionalCapabilities_STATUS(source *v20201201s.AdditionalCapabilities_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// HibernationEnabled
	if propertyBag.Contains("HibernationEnabled") {
		var hibernationEnabled bool
		err := propertyBag.Pull("HibernationEnabled", &hibernationEnabled)
		if err != nil {
			return errors.Wrap(err, "pulling 'HibernationEnabled' from propertyBag")
		}

		capabilities.HibernationEnabled = &hibernationEnabled
	} else {
		capabilities.HibernationEnabled = nil
	}

	// UltraSSDEnabled
	if source.UltraSSDEnabled != nil {
		ultraSSDEnabled := *source.UltraSSDEnabled
		capabilities.UltraSSDEnabled = &ultraSSDEnabled
	} else {
		capabilities.UltraSSDEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		capabilities.PropertyBag = propertyBag
	} else {
		capabilities.PropertyBag = nil
	}

	// Invoke the augmentConversionForAdditionalCapabilities_STATUS interface (if implemented) to customize the conversion
	var capabilitiesAsAny any = capabilities
	if augmentedCapabilities, ok := capabilitiesAsAny.(augmentConversionForAdditionalCapabilities_STATUS); ok {
		err := augmentedCapabilities.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AdditionalCapabilities_STATUS populates the provided destination AdditionalCapabilities_STATUS from our AdditionalCapabilities_STATUS
func (capabilities *AdditionalCapabilities_STATUS) AssignProperties_To_AdditionalCapabilities_STATUS(destination *v20201201s.AdditionalCapabilities_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(capabilities.PropertyBag)

	// HibernationEnabled
	if capabilities.HibernationEnabled != nil {
		propertyBag.Add("HibernationEnabled", *capabilities.HibernationEnabled)
	} else {
		propertyBag.Remove("HibernationEnabled")
	}

	// UltraSSDEnabled
	if capabilities.UltraSSDEnabled != nil {
		ultraSSDEnabled := *capabilities.UltraSSDEnabled
		destination.UltraSSDEnabled = &ultraSSDEnabled
	} else {
		destination.UltraSSDEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAdditionalCapabilities_STATUS interface (if implemented) to customize the conversion
	var capabilitiesAsAny any = capabilities
	if augmentedCapabilities, ok := capabilitiesAsAny.(augmentConversionForAdditionalCapabilities_STATUS); ok {
		err := augmentedCapabilities.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.ApplicationProfile
// Deprecated version of ApplicationProfile. Use v1api20220301.ApplicationProfile instead
type ApplicationProfile struct {
	GalleryApplications []VMGalleryApplication `json:"galleryApplications,omitempty"`
	PropertyBag         genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_ApplicationProfile populates our ApplicationProfile from the provided source ApplicationProfile
func (profile *ApplicationProfile) AssignProperties_From_ApplicationProfile(source *v20220301s.ApplicationProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// GalleryApplications
	if source.GalleryApplications != nil {
		galleryApplicationList := make([]VMGalleryApplication, len(source.GalleryApplications))
		for galleryApplicationIndex, galleryApplicationItem := range source.GalleryApplications {
			// Shadow the loop variable to avoid aliasing
			galleryApplicationItem := galleryApplicationItem
			var galleryApplication VMGalleryApplication
			err := galleryApplication.AssignProperties_From_VMGalleryApplication(&galleryApplicationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VMGalleryApplication() to populate field GalleryApplications")
			}
			galleryApplicationList[galleryApplicationIndex] = galleryApplication
		}
		profile.GalleryApplications = galleryApplicationList
	} else {
		profile.GalleryApplications = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForApplicationProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForApplicationProfile); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ApplicationProfile populates the provided destination ApplicationProfile from our ApplicationProfile
func (profile *ApplicationProfile) AssignProperties_To_ApplicationProfile(destination *v20220301s.ApplicationProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// GalleryApplications
	if profile.GalleryApplications != nil {
		galleryApplicationList := make([]v20220301s.VMGalleryApplication, len(profile.GalleryApplications))
		for galleryApplicationIndex, galleryApplicationItem := range profile.GalleryApplications {
			// Shadow the loop variable to avoid aliasing
			galleryApplicationItem := galleryApplicationItem
			var galleryApplication v20220301s.VMGalleryApplication
			err := galleryApplicationItem.AssignProperties_To_VMGalleryApplication(&galleryApplication)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VMGalleryApplication() to populate field GalleryApplications")
			}
			galleryApplicationList[galleryApplicationIndex] = galleryApplication
		}
		destination.GalleryApplications = galleryApplicationList
	} else {
		destination.GalleryApplications = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForApplicationProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForApplicationProfile); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.ApplicationProfile_STATUS
// Deprecated version of ApplicationProfile_STATUS. Use v1api20220301.ApplicationProfile_STATUS instead
type ApplicationProfile_STATUS struct {
	GalleryApplications []VMGalleryApplication_STATUS `json:"galleryApplications,omitempty"`
	PropertyBag         genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_ApplicationProfile_STATUS populates our ApplicationProfile_STATUS from the provided source ApplicationProfile_STATUS
func (profile *ApplicationProfile_STATUS) AssignProperties_From_ApplicationProfile_STATUS(source *v20220301s.ApplicationProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// GalleryApplications
	if source.GalleryApplications != nil {
		galleryApplicationList := make([]VMGalleryApplication_STATUS, len(source.GalleryApplications))
		for galleryApplicationIndex, galleryApplicationItem := range source.GalleryApplications {
			// Shadow the loop variable to avoid aliasing
			galleryApplicationItem := galleryApplicationItem
			var galleryApplication VMGalleryApplication_STATUS
			err := galleryApplication.AssignProperties_From_VMGalleryApplication_STATUS(&galleryApplicationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VMGalleryApplication_STATUS() to populate field GalleryApplications")
			}
			galleryApplicationList[galleryApplicationIndex] = galleryApplication
		}
		profile.GalleryApplications = galleryApplicationList
	} else {
		profile.GalleryApplications = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForApplicationProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForApplicationProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ApplicationProfile_STATUS populates the provided destination ApplicationProfile_STATUS from our ApplicationProfile_STATUS
func (profile *ApplicationProfile_STATUS) AssignProperties_To_ApplicationProfile_STATUS(destination *v20220301s.ApplicationProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// GalleryApplications
	if profile.GalleryApplications != nil {
		galleryApplicationList := make([]v20220301s.VMGalleryApplication_STATUS, len(profile.GalleryApplications))
		for galleryApplicationIndex, galleryApplicationItem := range profile.GalleryApplications {
			// Shadow the loop variable to avoid aliasing
			galleryApplicationItem := galleryApplicationItem
			var galleryApplication v20220301s.VMGalleryApplication_STATUS
			err := galleryApplicationItem.AssignProperties_To_VMGalleryApplication_STATUS(&galleryApplication)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VMGalleryApplication_STATUS() to populate field GalleryApplications")
			}
			galleryApplicationList[galleryApplicationIndex] = galleryApplication
		}
		destination.GalleryApplications = galleryApplicationList
	} else {
		destination.GalleryApplications = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForApplicationProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForApplicationProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForVirtualMachine_Spec interface {
	AssignPropertiesFrom(src *v20201201s.VirtualMachine_Spec) error
	AssignPropertiesTo(dst *v20201201s.VirtualMachine_Spec) error
}

type augmentConversionForVirtualMachine_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.VirtualMachine_STATUS) error
	AssignPropertiesTo(dst *v20201201s.VirtualMachine_STATUS) error
}

// Storage version of v1beta20220301.BillingProfile
// Deprecated version of BillingProfile. Use v1api20220301.BillingProfile instead
type BillingProfile struct {
	MaxPrice    *float64               `json:"maxPrice,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_BillingProfile populates our BillingProfile from the provided source BillingProfile
func (profile *BillingProfile) AssignProperties_From_BillingProfile(source *v20201201s.BillingProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MaxPrice
	if source.MaxPrice != nil {
		maxPrice := *source.MaxPrice
		profile.MaxPrice = &maxPrice
	} else {
		profile.MaxPrice = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForBillingProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForBillingProfile); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_BillingProfile populates the provided destination BillingProfile from our BillingProfile
func (profile *BillingProfile) AssignProperties_To_BillingProfile(destination *v20201201s.BillingProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// MaxPrice
	if profile.MaxPrice != nil {
		maxPrice := *profile.MaxPrice
		destination.MaxPrice = &maxPrice
	} else {
		destination.MaxPrice = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForBillingProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForBillingProfile); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.BillingProfile_STATUS
// Deprecated version of BillingProfile_STATUS. Use v1api20220301.BillingProfile_STATUS instead
type BillingProfile_STATUS struct {
	MaxPrice    *float64               `json:"maxPrice,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_BillingProfile_STATUS populates our BillingProfile_STATUS from the provided source BillingProfile_STATUS
func (profile *BillingProfile_STATUS) AssignProperties_From_BillingProfile_STATUS(source *v20201201s.BillingProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MaxPrice
	if source.MaxPrice != nil {
		maxPrice := *source.MaxPrice
		profile.MaxPrice = &maxPrice
	} else {
		profile.MaxPrice = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForBillingProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForBillingProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_BillingProfile_STATUS populates the provided destination BillingProfile_STATUS from our BillingProfile_STATUS
func (profile *BillingProfile_STATUS) AssignProperties_To_BillingProfile_STATUS(destination *v20201201s.BillingProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// MaxPrice
	if profile.MaxPrice != nil {
		maxPrice := *profile.MaxPrice
		destination.MaxPrice = &maxPrice
	} else {
		destination.MaxPrice = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForBillingProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForBillingProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.CapacityReservationProfile
// Deprecated version of CapacityReservationProfile. Use v1api20220301.CapacityReservationProfile instead
type CapacityReservationProfile struct {
	CapacityReservationGroup *SubResource           `json:"capacityReservationGroup,omitempty"`
	PropertyBag              genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_CapacityReservationProfile populates our CapacityReservationProfile from the provided source CapacityReservationProfile
func (profile *CapacityReservationProfile) AssignProperties_From_CapacityReservationProfile(source *v20220301s.CapacityReservationProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CapacityReservationGroup
	if source.CapacityReservationGroup != nil {
		var subResourceStash v20210701s.SubResource
		err := subResourceStash.AssignProperties_From_SubResource(source.CapacityReservationGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SubResourceStash from CapacityReservationGroup")
		}
		var subResourceStashLocal v20201201s.SubResource
		err = subResourceStashLocal.AssignProperties_From_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SubResourceStash")
		}
		var capacityReservationGroup SubResource
		err = capacityReservationGroup.AssignProperties_From_SubResource(&subResourceStashLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field CapacityReservationGroup from SubResourceStash")
		}
		profile.CapacityReservationGroup = &capacityReservationGroup
	} else {
		profile.CapacityReservationGroup = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForCapacityReservationProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForCapacityReservationProfile); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_CapacityReservationProfile populates the provided destination CapacityReservationProfile from our CapacityReservationProfile
func (profile *CapacityReservationProfile) AssignProperties_To_CapacityReservationProfile(destination *v20220301s.CapacityReservationProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// CapacityReservationGroup
	if profile.CapacityReservationGroup != nil {
		var subResourceStash v20201201s.SubResource
		err := profile.CapacityReservationGroup.AssignProperties_To_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SubResourceStash from CapacityReservationGroup")
		}
		var subResourceStashLocal v20210701s.SubResource
		err = subResourceStash.AssignProperties_To_SubResource(&subResourceStashLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SubResourceStash")
		}
		var capacityReservationGroup v20220301s.SubResource
		err = subResourceStashLocal.AssignProperties_To_SubResource(&capacityReservationGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field CapacityReservationGroup from SubResourceStash")
		}
		destination.CapacityReservationGroup = &capacityReservationGroup
	} else {
		destination.CapacityReservationGroup = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForCapacityReservationProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForCapacityReservationProfile); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.CapacityReservationProfile_STATUS
// Deprecated version of CapacityReservationProfile_STATUS. Use v1api20220301.CapacityReservationProfile_STATUS instead
type CapacityReservationProfile_STATUS struct {
	CapacityReservationGroup *SubResource_STATUS    `json:"capacityReservationGroup,omitempty"`
	PropertyBag              genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_CapacityReservationProfile_STATUS populates our CapacityReservationProfile_STATUS from the provided source CapacityReservationProfile_STATUS
func (profile *CapacityReservationProfile_STATUS) AssignProperties_From_CapacityReservationProfile_STATUS(source *v20220301s.CapacityReservationProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CapacityReservationGroup
	if source.CapacityReservationGroup != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := subResourceSTATUSStash.AssignProperties_From_SubResource_STATUS(source.CapacityReservationGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash from CapacityReservationGroup")
		}
		var subResourceSTATUSStashLocal v20201201s.SubResource_STATUS
		err = subResourceSTATUSStashLocal.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash")
		}
		var capacityReservationGroup SubResource_STATUS
		err = capacityReservationGroup.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStashLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field CapacityReservationGroup from SubResource_STATUSStash")
		}
		profile.CapacityReservationGroup = &capacityReservationGroup
	} else {
		profile.CapacityReservationGroup = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForCapacityReservationProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForCapacityReservationProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_CapacityReservationProfile_STATUS populates the provided destination CapacityReservationProfile_STATUS from our CapacityReservationProfile_STATUS
func (profile *CapacityReservationProfile_STATUS) AssignProperties_To_CapacityReservationProfile_STATUS(destination *v20220301s.CapacityReservationProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// CapacityReservationGroup
	if profile.CapacityReservationGroup != nil {
		var subResourceSTATUSStash v20201201s.SubResource_STATUS
		err := profile.CapacityReservationGroup.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash from CapacityReservationGroup")
		}
		var subResourceSTATUSStashLocal v20210701s.SubResource_STATUS
		err = subResourceSTATUSStash.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStashLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash")
		}
		var capacityReservationGroup v20220301s.SubResource_STATUS
		err = subResourceSTATUSStashLocal.AssignProperties_To_SubResource_STATUS(&capacityReservationGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field CapacityReservationGroup from SubResource_STATUSStash")
		}
		destination.CapacityReservationGroup = &capacityReservationGroup
	} else {
		destination.CapacityReservationGroup = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForCapacityReservationProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForCapacityReservationProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.DiagnosticsProfile
// Deprecated version of DiagnosticsProfile. Use v1api20220301.DiagnosticsProfile instead
type DiagnosticsProfile struct {
	BootDiagnostics *BootDiagnostics       `json:"bootDiagnostics,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DiagnosticsProfile populates our DiagnosticsProfile from the provided source DiagnosticsProfile
func (profile *DiagnosticsProfile) AssignProperties_From_DiagnosticsProfile(source *v20201201s.DiagnosticsProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// BootDiagnostics
	if source.BootDiagnostics != nil {
		var bootDiagnostic BootDiagnostics
		err := bootDiagnostic.AssignProperties_From_BootDiagnostics(source.BootDiagnostics)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BootDiagnostics() to populate field BootDiagnostics")
		}
		profile.BootDiagnostics = &bootDiagnostic
	} else {
		profile.BootDiagnostics = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForDiagnosticsProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForDiagnosticsProfile); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DiagnosticsProfile populates the provided destination DiagnosticsProfile from our DiagnosticsProfile
func (profile *DiagnosticsProfile) AssignProperties_To_DiagnosticsProfile(destination *v20201201s.DiagnosticsProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// BootDiagnostics
	if profile.BootDiagnostics != nil {
		var bootDiagnostic v20201201s.BootDiagnostics
		err := profile.BootDiagnostics.AssignProperties_To_BootDiagnostics(&bootDiagnostic)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BootDiagnostics() to populate field BootDiagnostics")
		}
		destination.BootDiagnostics = &bootDiagnostic
	} else {
		destination.BootDiagnostics = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDiagnosticsProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForDiagnosticsProfile); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.DiagnosticsProfile_STATUS
// Deprecated version of DiagnosticsProfile_STATUS. Use v1api20220301.DiagnosticsProfile_STATUS instead
type DiagnosticsProfile_STATUS struct {
	BootDiagnostics *BootDiagnostics_STATUS `json:"bootDiagnostics,omitempty"`
	PropertyBag     genruntime.PropertyBag  `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DiagnosticsProfile_STATUS populates our DiagnosticsProfile_STATUS from the provided source DiagnosticsProfile_STATUS
func (profile *DiagnosticsProfile_STATUS) AssignProperties_From_DiagnosticsProfile_STATUS(source *v20201201s.DiagnosticsProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// BootDiagnostics
	if source.BootDiagnostics != nil {
		var bootDiagnostic BootDiagnostics_STATUS
		err := bootDiagnostic.AssignProperties_From_BootDiagnostics_STATUS(source.BootDiagnostics)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BootDiagnostics_STATUS() to populate field BootDiagnostics")
		}
		profile.BootDiagnostics = &bootDiagnostic
	} else {
		profile.BootDiagnostics = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForDiagnosticsProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForDiagnosticsProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DiagnosticsProfile_STATUS populates the provided destination DiagnosticsProfile_STATUS from our DiagnosticsProfile_STATUS
func (profile *DiagnosticsProfile_STATUS) AssignProperties_To_DiagnosticsProfile_STATUS(destination *v20201201s.DiagnosticsProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// BootDiagnostics
	if profile.BootDiagnostics != nil {
		var bootDiagnostic v20201201s.BootDiagnostics_STATUS
		err := profile.BootDiagnostics.AssignProperties_To_BootDiagnostics_STATUS(&bootDiagnostic)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BootDiagnostics_STATUS() to populate field BootDiagnostics")
		}
		destination.BootDiagnostics = &bootDiagnostic
	} else {
		destination.BootDiagnostics = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDiagnosticsProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForDiagnosticsProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.HardwareProfile
// Deprecated version of HardwareProfile. Use v1api20220301.HardwareProfile instead
type HardwareProfile struct {
	PropertyBag      genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	VmSize           *string                `json:"vmSize,omitempty"`
	VmSizeProperties *VMSizeProperties      `json:"vmSizeProperties,omitempty"`
}

// AssignProperties_From_HardwareProfile populates our HardwareProfile from the provided source HardwareProfile
func (profile *HardwareProfile) AssignProperties_From_HardwareProfile(source *v20201201s.HardwareProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// VmSize
	profile.VmSize = genruntime.ClonePointerToString(source.VmSize)

	// VmSizeProperties
	if propertyBag.Contains("VmSizeProperties") {
		var vmSizeProperty VMSizeProperties
		err := propertyBag.Pull("VmSizeProperties", &vmSizeProperty)
		if err != nil {
			return errors.Wrap(err, "pulling 'VmSizeProperties' from propertyBag")
		}

		profile.VmSizeProperties = &vmSizeProperty
	} else {
		profile.VmSizeProperties = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForHardwareProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForHardwareProfile); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_HardwareProfile populates the provided destination HardwareProfile from our HardwareProfile
func (profile *HardwareProfile) AssignProperties_To_HardwareProfile(destination *v20201201s.HardwareProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// VmSize
	destination.VmSize = genruntime.ClonePointerToString(profile.VmSize)

	// VmSizeProperties
	if profile.VmSizeProperties != nil {
		propertyBag.Add("VmSizeProperties", *profile.VmSizeProperties)
	} else {
		propertyBag.Remove("VmSizeProperties")
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForHardwareProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForHardwareProfile); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.HardwareProfile_STATUS
// Deprecated version of HardwareProfile_STATUS. Use v1api20220301.HardwareProfile_STATUS instead
type HardwareProfile_STATUS struct {
	PropertyBag      genruntime.PropertyBag   `json:"$propertyBag,omitempty"`
	VmSize           *string                  `json:"vmSize,omitempty"`
	VmSizeProperties *VMSizeProperties_STATUS `json:"vmSizeProperties,omitempty"`
}

// AssignProperties_From_HardwareProfile_STATUS populates our HardwareProfile_STATUS from the provided source HardwareProfile_STATUS
func (profile *HardwareProfile_STATUS) AssignProperties_From_HardwareProfile_STATUS(source *v20201201s.HardwareProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// VmSize
	profile.VmSize = genruntime.ClonePointerToString(source.VmSize)

	// VmSizeProperties
	if propertyBag.Contains("VmSizeProperties") {
		var vmSizeProperty VMSizeProperties_STATUS
		err := propertyBag.Pull("VmSizeProperties", &vmSizeProperty)
		if err != nil {
			return errors.Wrap(err, "pulling 'VmSizeProperties' from propertyBag")
		}

		profile.VmSizeProperties = &vmSizeProperty
	} else {
		profile.VmSizeProperties = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForHardwareProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForHardwareProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_HardwareProfile_STATUS populates the provided destination HardwareProfile_STATUS from our HardwareProfile_STATUS
func (profile *HardwareProfile_STATUS) AssignProperties_To_HardwareProfile_STATUS(destination *v20201201s.HardwareProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// VmSize
	destination.VmSize = genruntime.ClonePointerToString(profile.VmSize)

	// VmSizeProperties
	if profile.VmSizeProperties != nil {
		propertyBag.Add("VmSizeProperties", *profile.VmSizeProperties)
	} else {
		propertyBag.Remove("VmSizeProperties")
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForHardwareProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForHardwareProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.NetworkProfile
// Deprecated version of NetworkProfile. Use v1api20220301.NetworkProfile instead
type NetworkProfile struct {
	NetworkApiVersion              *string                                       `json:"networkApiVersion,omitempty"`
	NetworkInterfaceConfigurations []VirtualMachineNetworkInterfaceConfiguration `json:"networkInterfaceConfigurations,omitempty"`
	NetworkInterfaces              []NetworkInterfaceReference                   `json:"networkInterfaces,omitempty"`
	PropertyBag                    genruntime.PropertyBag                        `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_NetworkProfile populates our NetworkProfile from the provided source NetworkProfile
func (profile *NetworkProfile) AssignProperties_From_NetworkProfile(source *v20201201s.NetworkProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// NetworkApiVersion
	if propertyBag.Contains("NetworkApiVersion") {
		var networkApiVersion string
		err := propertyBag.Pull("NetworkApiVersion", &networkApiVersion)
		if err != nil {
			return errors.Wrap(err, "pulling 'NetworkApiVersion' from propertyBag")
		}

		profile.NetworkApiVersion = &networkApiVersion
	} else {
		profile.NetworkApiVersion = nil
	}

	// NetworkInterfaceConfigurations
	if propertyBag.Contains("NetworkInterfaceConfigurations") {
		var networkInterfaceConfiguration []VirtualMachineNetworkInterfaceConfiguration
		err := propertyBag.Pull("NetworkInterfaceConfigurations", &networkInterfaceConfiguration)
		if err != nil {
			return errors.Wrap(err, "pulling 'NetworkInterfaceConfigurations' from propertyBag")
		}

		profile.NetworkInterfaceConfigurations = networkInterfaceConfiguration
	} else {
		profile.NetworkInterfaceConfigurations = nil
	}

	// NetworkInterfaces
	if source.NetworkInterfaces != nil {
		networkInterfaceList := make([]NetworkInterfaceReference, len(source.NetworkInterfaces))
		for networkInterfaceIndex, networkInterfaceItem := range source.NetworkInterfaces {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceItem := networkInterfaceItem
			var networkInterface NetworkInterfaceReference
			err := networkInterface.AssignProperties_From_NetworkInterfaceReference(&networkInterfaceItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_NetworkInterfaceReference() to populate field NetworkInterfaces")
			}
			networkInterfaceList[networkInterfaceIndex] = networkInterface
		}
		profile.NetworkInterfaces = networkInterfaceList
	} else {
		profile.NetworkInterfaces = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForNetworkProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForNetworkProfile); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_NetworkProfile populates the provided destination NetworkProfile from our NetworkProfile
func (profile *NetworkProfile) AssignProperties_To_NetworkProfile(destination *v20201201s.NetworkProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// NetworkApiVersion
	if profile.NetworkApiVersion != nil {
		propertyBag.Add("NetworkApiVersion", *profile.NetworkApiVersion)
	} else {
		propertyBag.Remove("NetworkApiVersion")
	}

	// NetworkInterfaceConfigurations
	if len(profile.NetworkInterfaceConfigurations) > 0 {
		propertyBag.Add("NetworkInterfaceConfigurations", profile.NetworkInterfaceConfigurations)
	} else {
		propertyBag.Remove("NetworkInterfaceConfigurations")
	}

	// NetworkInterfaces
	if profile.NetworkInterfaces != nil {
		networkInterfaceList := make([]v20201201s.NetworkInterfaceReference, len(profile.NetworkInterfaces))
		for networkInterfaceIndex, networkInterfaceItem := range profile.NetworkInterfaces {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceItem := networkInterfaceItem
			var networkInterface v20201201s.NetworkInterfaceReference
			err := networkInterfaceItem.AssignProperties_To_NetworkInterfaceReference(&networkInterface)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_NetworkInterfaceReference() to populate field NetworkInterfaces")
			}
			networkInterfaceList[networkInterfaceIndex] = networkInterface
		}
		destination.NetworkInterfaces = networkInterfaceList
	} else {
		destination.NetworkInterfaces = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForNetworkProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForNetworkProfile); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.NetworkProfile_STATUS
// Deprecated version of NetworkProfile_STATUS. Use v1api20220301.NetworkProfile_STATUS instead
type NetworkProfile_STATUS struct {
	NetworkApiVersion              *string                                              `json:"networkApiVersion,omitempty"`
	NetworkInterfaceConfigurations []VirtualMachineNetworkInterfaceConfiguration_STATUS `json:"networkInterfaceConfigurations,omitempty"`
	NetworkInterfaces              []NetworkInterfaceReference_STATUS                   `json:"networkInterfaces,omitempty"`
	PropertyBag                    genruntime.PropertyBag                               `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_NetworkProfile_STATUS populates our NetworkProfile_STATUS from the provided source NetworkProfile_STATUS
func (profile *NetworkProfile_STATUS) AssignProperties_From_NetworkProfile_STATUS(source *v20201201s.NetworkProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// NetworkApiVersion
	if propertyBag.Contains("NetworkApiVersion") {
		var networkApiVersion string
		err := propertyBag.Pull("NetworkApiVersion", &networkApiVersion)
		if err != nil {
			return errors.Wrap(err, "pulling 'NetworkApiVersion' from propertyBag")
		}

		profile.NetworkApiVersion = &networkApiVersion
	} else {
		profile.NetworkApiVersion = nil
	}

	// NetworkInterfaceConfigurations
	if propertyBag.Contains("NetworkInterfaceConfigurations") {
		var networkInterfaceConfiguration []VirtualMachineNetworkInterfaceConfiguration_STATUS
		err := propertyBag.Pull("NetworkInterfaceConfigurations", &networkInterfaceConfiguration)
		if err != nil {
			return errors.Wrap(err, "pulling 'NetworkInterfaceConfigurations' from propertyBag")
		}

		profile.NetworkInterfaceConfigurations = networkInterfaceConfiguration
	} else {
		profile.NetworkInterfaceConfigurations = nil
	}

	// NetworkInterfaces
	if source.NetworkInterfaces != nil {
		networkInterfaceList := make([]NetworkInterfaceReference_STATUS, len(source.NetworkInterfaces))
		for networkInterfaceIndex, networkInterfaceItem := range source.NetworkInterfaces {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceItem := networkInterfaceItem
			var networkInterface NetworkInterfaceReference_STATUS
			err := networkInterface.AssignProperties_From_NetworkInterfaceReference_STATUS(&networkInterfaceItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_NetworkInterfaceReference_STATUS() to populate field NetworkInterfaces")
			}
			networkInterfaceList[networkInterfaceIndex] = networkInterface
		}
		profile.NetworkInterfaces = networkInterfaceList
	} else {
		profile.NetworkInterfaces = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForNetworkProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForNetworkProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_NetworkProfile_STATUS populates the provided destination NetworkProfile_STATUS from our NetworkProfile_STATUS
func (profile *NetworkProfile_STATUS) AssignProperties_To_NetworkProfile_STATUS(destination *v20201201s.NetworkProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// NetworkApiVersion
	if profile.NetworkApiVersion != nil {
		propertyBag.Add("NetworkApiVersion", *profile.NetworkApiVersion)
	} else {
		propertyBag.Remove("NetworkApiVersion")
	}

	// NetworkInterfaceConfigurations
	if len(profile.NetworkInterfaceConfigurations) > 0 {
		propertyBag.Add("NetworkInterfaceConfigurations", profile.NetworkInterfaceConfigurations)
	} else {
		propertyBag.Remove("NetworkInterfaceConfigurations")
	}

	// NetworkInterfaces
	if profile.NetworkInterfaces != nil {
		networkInterfaceList := make([]v20201201s.NetworkInterfaceReference_STATUS, len(profile.NetworkInterfaces))
		for networkInterfaceIndex, networkInterfaceItem := range profile.NetworkInterfaces {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceItem := networkInterfaceItem
			var networkInterface v20201201s.NetworkInterfaceReference_STATUS
			err := networkInterfaceItem.AssignProperties_To_NetworkInterfaceReference_STATUS(&networkInterface)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_NetworkInterfaceReference_STATUS() to populate field NetworkInterfaces")
			}
			networkInterfaceList[networkInterfaceIndex] = networkInterface
		}
		destination.NetworkInterfaces = networkInterfaceList
	} else {
		destination.NetworkInterfaces = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForNetworkProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForNetworkProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.OSProfile
// Deprecated version of OSProfile. Use v1api20220301.OSProfile instead
type OSProfile struct {
	AdminPassword               *genruntime.SecretReference `json:"adminPassword,omitempty"`
	AdminUsername               *string                     `json:"adminUsername,omitempty"`
	AllowExtensionOperations    *bool                       `json:"allowExtensionOperations,omitempty"`
	ComputerName                *string                     `json:"computerName,omitempty"`
	CustomData                  *string                     `json:"customData,omitempty"`
	LinuxConfiguration          *LinuxConfiguration         `json:"linuxConfiguration,omitempty"`
	PropertyBag                 genruntime.PropertyBag      `json:"$propertyBag,omitempty"`
	RequireGuestProvisionSignal *bool                       `json:"requireGuestProvisionSignal,omitempty"`
	Secrets                     []VaultSecretGroup          `json:"secrets,omitempty"`
	WindowsConfiguration        *WindowsConfiguration       `json:"windowsConfiguration,omitempty"`
}

// AssignProperties_From_OSProfile populates our OSProfile from the provided source OSProfile
func (profile *OSProfile) AssignProperties_From_OSProfile(source *v20201201s.OSProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AdminPassword
	if source.AdminPassword != nil {
		adminPassword := source.AdminPassword.Copy()
		profile.AdminPassword = &adminPassword
	} else {
		profile.AdminPassword = nil
	}

	// AdminUsername
	profile.AdminUsername = genruntime.ClonePointerToString(source.AdminUsername)

	// AllowExtensionOperations
	if source.AllowExtensionOperations != nil {
		allowExtensionOperation := *source.AllowExtensionOperations
		profile.AllowExtensionOperations = &allowExtensionOperation
	} else {
		profile.AllowExtensionOperations = nil
	}

	// ComputerName
	profile.ComputerName = genruntime.ClonePointerToString(source.ComputerName)

	// CustomData
	profile.CustomData = genruntime.ClonePointerToString(source.CustomData)

	// LinuxConfiguration
	if source.LinuxConfiguration != nil {
		var linuxConfiguration LinuxConfiguration
		err := linuxConfiguration.AssignProperties_From_LinuxConfiguration(source.LinuxConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_LinuxConfiguration() to populate field LinuxConfiguration")
		}
		profile.LinuxConfiguration = &linuxConfiguration
	} else {
		profile.LinuxConfiguration = nil
	}

	// RequireGuestProvisionSignal
	if source.RequireGuestProvisionSignal != nil {
		requireGuestProvisionSignal := *source.RequireGuestProvisionSignal
		profile.RequireGuestProvisionSignal = &requireGuestProvisionSignal
	} else {
		profile.RequireGuestProvisionSignal = nil
	}

	// Secrets
	if source.Secrets != nil {
		secretList := make([]VaultSecretGroup, len(source.Secrets))
		for secretIndex, secretItem := range source.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret VaultSecretGroup
			err := secret.AssignProperties_From_VaultSecretGroup(&secretItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VaultSecretGroup() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		profile.Secrets = secretList
	} else {
		profile.Secrets = nil
	}

	// WindowsConfiguration
	if source.WindowsConfiguration != nil {
		var windowsConfiguration WindowsConfiguration
		err := windowsConfiguration.AssignProperties_From_WindowsConfiguration(source.WindowsConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_WindowsConfiguration() to populate field WindowsConfiguration")
		}
		profile.WindowsConfiguration = &windowsConfiguration
	} else {
		profile.WindowsConfiguration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForOSProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForOSProfile); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_OSProfile populates the provided destination OSProfile from our OSProfile
func (profile *OSProfile) AssignProperties_To_OSProfile(destination *v20201201s.OSProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// AdminPassword
	if profile.AdminPassword != nil {
		adminPassword := profile.AdminPassword.Copy()
		destination.AdminPassword = &adminPassword
	} else {
		destination.AdminPassword = nil
	}

	// AdminUsername
	destination.AdminUsername = genruntime.ClonePointerToString(profile.AdminUsername)

	// AllowExtensionOperations
	if profile.AllowExtensionOperations != nil {
		allowExtensionOperation := *profile.AllowExtensionOperations
		destination.AllowExtensionOperations = &allowExtensionOperation
	} else {
		destination.AllowExtensionOperations = nil
	}

	// ComputerName
	destination.ComputerName = genruntime.ClonePointerToString(profile.ComputerName)

	// CustomData
	destination.CustomData = genruntime.ClonePointerToString(profile.CustomData)

	// LinuxConfiguration
	if profile.LinuxConfiguration != nil {
		var linuxConfiguration v20201201s.LinuxConfiguration
		err := profile.LinuxConfiguration.AssignProperties_To_LinuxConfiguration(&linuxConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_LinuxConfiguration() to populate field LinuxConfiguration")
		}
		destination.LinuxConfiguration = &linuxConfiguration
	} else {
		destination.LinuxConfiguration = nil
	}

	// RequireGuestProvisionSignal
	if profile.RequireGuestProvisionSignal != nil {
		requireGuestProvisionSignal := *profile.RequireGuestProvisionSignal
		destination.RequireGuestProvisionSignal = &requireGuestProvisionSignal
	} else {
		destination.RequireGuestProvisionSignal = nil
	}

	// Secrets
	if profile.Secrets != nil {
		secretList := make([]v20201201s.VaultSecretGroup, len(profile.Secrets))
		for secretIndex, secretItem := range profile.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret v20201201s.VaultSecretGroup
			err := secretItem.AssignProperties_To_VaultSecretGroup(&secret)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VaultSecretGroup() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		destination.Secrets = secretList
	} else {
		destination.Secrets = nil
	}

	// WindowsConfiguration
	if profile.WindowsConfiguration != nil {
		var windowsConfiguration v20201201s.WindowsConfiguration
		err := profile.WindowsConfiguration.AssignProperties_To_WindowsConfiguration(&windowsConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_WindowsConfiguration() to populate field WindowsConfiguration")
		}
		destination.WindowsConfiguration = &windowsConfiguration
	} else {
		destination.WindowsConfiguration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForOSProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForOSProfile); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.OSProfile_STATUS
// Deprecated version of OSProfile_STATUS. Use v1api20220301.OSProfile_STATUS instead
type OSProfile_STATUS struct {
	AdminUsername               *string                      `json:"adminUsername,omitempty"`
	AllowExtensionOperations    *bool                        `json:"allowExtensionOperations,omitempty"`
	ComputerName                *string                      `json:"computerName,omitempty"`
	CustomData                  *string                      `json:"customData,omitempty"`
	LinuxConfiguration          *LinuxConfiguration_STATUS   `json:"linuxConfiguration,omitempty"`
	PropertyBag                 genruntime.PropertyBag       `json:"$propertyBag,omitempty"`
	RequireGuestProvisionSignal *bool                        `json:"requireGuestProvisionSignal,omitempty"`
	Secrets                     []VaultSecretGroup_STATUS    `json:"secrets,omitempty"`
	WindowsConfiguration        *WindowsConfiguration_STATUS `json:"windowsConfiguration,omitempty"`
}

// AssignProperties_From_OSProfile_STATUS populates our OSProfile_STATUS from the provided source OSProfile_STATUS
func (profile *OSProfile_STATUS) AssignProperties_From_OSProfile_STATUS(source *v20201201s.OSProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AdminUsername
	profile.AdminUsername = genruntime.ClonePointerToString(source.AdminUsername)

	// AllowExtensionOperations
	if source.AllowExtensionOperations != nil {
		allowExtensionOperation := *source.AllowExtensionOperations
		profile.AllowExtensionOperations = &allowExtensionOperation
	} else {
		profile.AllowExtensionOperations = nil
	}

	// ComputerName
	profile.ComputerName = genruntime.ClonePointerToString(source.ComputerName)

	// CustomData
	profile.CustomData = genruntime.ClonePointerToString(source.CustomData)

	// LinuxConfiguration
	if source.LinuxConfiguration != nil {
		var linuxConfiguration LinuxConfiguration_STATUS
		err := linuxConfiguration.AssignProperties_From_LinuxConfiguration_STATUS(source.LinuxConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_LinuxConfiguration_STATUS() to populate field LinuxConfiguration")
		}
		profile.LinuxConfiguration = &linuxConfiguration
	} else {
		profile.LinuxConfiguration = nil
	}

	// RequireGuestProvisionSignal
	if source.RequireGuestProvisionSignal != nil {
		requireGuestProvisionSignal := *source.RequireGuestProvisionSignal
		profile.RequireGuestProvisionSignal = &requireGuestProvisionSignal
	} else {
		profile.RequireGuestProvisionSignal = nil
	}

	// Secrets
	if source.Secrets != nil {
		secretList := make([]VaultSecretGroup_STATUS, len(source.Secrets))
		for secretIndex, secretItem := range source.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret VaultSecretGroup_STATUS
			err := secret.AssignProperties_From_VaultSecretGroup_STATUS(&secretItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VaultSecretGroup_STATUS() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		profile.Secrets = secretList
	} else {
		profile.Secrets = nil
	}

	// WindowsConfiguration
	if source.WindowsConfiguration != nil {
		var windowsConfiguration WindowsConfiguration_STATUS
		err := windowsConfiguration.AssignProperties_From_WindowsConfiguration_STATUS(source.WindowsConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_WindowsConfiguration_STATUS() to populate field WindowsConfiguration")
		}
		profile.WindowsConfiguration = &windowsConfiguration
	} else {
		profile.WindowsConfiguration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForOSProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForOSProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_OSProfile_STATUS populates the provided destination OSProfile_STATUS from our OSProfile_STATUS
func (profile *OSProfile_STATUS) AssignProperties_To_OSProfile_STATUS(destination *v20201201s.OSProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// AdminUsername
	destination.AdminUsername = genruntime.ClonePointerToString(profile.AdminUsername)

	// AllowExtensionOperations
	if profile.AllowExtensionOperations != nil {
		allowExtensionOperation := *profile.AllowExtensionOperations
		destination.AllowExtensionOperations = &allowExtensionOperation
	} else {
		destination.AllowExtensionOperations = nil
	}

	// ComputerName
	destination.ComputerName = genruntime.ClonePointerToString(profile.ComputerName)

	// CustomData
	destination.CustomData = genruntime.ClonePointerToString(profile.CustomData)

	// LinuxConfiguration
	if profile.LinuxConfiguration != nil {
		var linuxConfiguration v20201201s.LinuxConfiguration_STATUS
		err := profile.LinuxConfiguration.AssignProperties_To_LinuxConfiguration_STATUS(&linuxConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_LinuxConfiguration_STATUS() to populate field LinuxConfiguration")
		}
		destination.LinuxConfiguration = &linuxConfiguration
	} else {
		destination.LinuxConfiguration = nil
	}

	// RequireGuestProvisionSignal
	if profile.RequireGuestProvisionSignal != nil {
		requireGuestProvisionSignal := *profile.RequireGuestProvisionSignal
		destination.RequireGuestProvisionSignal = &requireGuestProvisionSignal
	} else {
		destination.RequireGuestProvisionSignal = nil
	}

	// Secrets
	if profile.Secrets != nil {
		secretList := make([]v20201201s.VaultSecretGroup_STATUS, len(profile.Secrets))
		for secretIndex, secretItem := range profile.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret v20201201s.VaultSecretGroup_STATUS
			err := secretItem.AssignProperties_To_VaultSecretGroup_STATUS(&secret)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VaultSecretGroup_STATUS() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		destination.Secrets = secretList
	} else {
		destination.Secrets = nil
	}

	// WindowsConfiguration
	if profile.WindowsConfiguration != nil {
		var windowsConfiguration v20201201s.WindowsConfiguration_STATUS
		err := profile.WindowsConfiguration.AssignProperties_To_WindowsConfiguration_STATUS(&windowsConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_WindowsConfiguration_STATUS() to populate field WindowsConfiguration")
		}
		destination.WindowsConfiguration = &windowsConfiguration
	} else {
		destination.WindowsConfiguration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForOSProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForOSProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.Plan
// Deprecated version of Plan. Use v1api20220301.Plan instead
type Plan struct {
	Name          *string                `json:"name,omitempty"`
	Product       *string                `json:"product,omitempty"`
	PromotionCode *string                `json:"promotionCode,omitempty"`
	PropertyBag   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Publisher     *string                `json:"publisher,omitempty"`
}

// AssignProperties_From_Plan populates our Plan from the provided source Plan
func (plan *Plan) AssignProperties_From_Plan(source *v20201201s.Plan) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	plan.Name = genruntime.ClonePointerToString(source.Name)

	// Product
	plan.Product = genruntime.ClonePointerToString(source.Product)

	// PromotionCode
	plan.PromotionCode = genruntime.ClonePointerToString(source.PromotionCode)

	// Publisher
	plan.Publisher = genruntime.ClonePointerToString(source.Publisher)

	// Update the property bag
	if len(propertyBag) > 0 {
		plan.PropertyBag = propertyBag
	} else {
		plan.PropertyBag = nil
	}

	// Invoke the augmentConversionForPlan interface (if implemented) to customize the conversion
	var planAsAny any = plan
	if augmentedPlan, ok := planAsAny.(augmentConversionForPlan); ok {
		err := augmentedPlan.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_Plan populates the provided destination Plan from our Plan
func (plan *Plan) AssignProperties_To_Plan(destination *v20201201s.Plan) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(plan.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(plan.Name)

	// Product
	destination.Product = genruntime.ClonePointerToString(plan.Product)

	// PromotionCode
	destination.PromotionCode = genruntime.ClonePointerToString(plan.PromotionCode)

	// Publisher
	destination.Publisher = genruntime.ClonePointerToString(plan.Publisher)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForPlan interface (if implemented) to customize the conversion
	var planAsAny any = plan
	if augmentedPlan, ok := planAsAny.(augmentConversionForPlan); ok {
		err := augmentedPlan.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.Plan_STATUS
// Deprecated version of Plan_STATUS. Use v1api20220301.Plan_STATUS instead
type Plan_STATUS struct {
	Name          *string                `json:"name,omitempty"`
	Product       *string                `json:"product,omitempty"`
	PromotionCode *string                `json:"promotionCode,omitempty"`
	PropertyBag   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Publisher     *string                `json:"publisher,omitempty"`
}

// AssignProperties_From_Plan_STATUS populates our Plan_STATUS from the provided source Plan_STATUS
func (plan *Plan_STATUS) AssignProperties_From_Plan_STATUS(source *v20201201s.Plan_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	plan.Name = genruntime.ClonePointerToString(source.Name)

	// Product
	plan.Product = genruntime.ClonePointerToString(source.Product)

	// PromotionCode
	plan.PromotionCode = genruntime.ClonePointerToString(source.PromotionCode)

	// Publisher
	plan.Publisher = genruntime.ClonePointerToString(source.Publisher)

	// Update the property bag
	if len(propertyBag) > 0 {
		plan.PropertyBag = propertyBag
	} else {
		plan.PropertyBag = nil
	}

	// Invoke the augmentConversionForPlan_STATUS interface (if implemented) to customize the conversion
	var planAsAny any = plan
	if augmentedPlan, ok := planAsAny.(augmentConversionForPlan_STATUS); ok {
		err := augmentedPlan.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_Plan_STATUS populates the provided destination Plan_STATUS from our Plan_STATUS
func (plan *Plan_STATUS) AssignProperties_To_Plan_STATUS(destination *v20201201s.Plan_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(plan.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(plan.Name)

	// Product
	destination.Product = genruntime.ClonePointerToString(plan.Product)

	// PromotionCode
	destination.PromotionCode = genruntime.ClonePointerToString(plan.PromotionCode)

	// Publisher
	destination.Publisher = genruntime.ClonePointerToString(plan.Publisher)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForPlan_STATUS interface (if implemented) to customize the conversion
	var planAsAny any = plan
	if augmentedPlan, ok := planAsAny.(augmentConversionForPlan_STATUS); ok {
		err := augmentedPlan.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.ScheduledEventsProfile
// Deprecated version of ScheduledEventsProfile. Use v1api20220301.ScheduledEventsProfile instead
type ScheduledEventsProfile struct {
	PropertyBag                  genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
	TerminateNotificationProfile *TerminateNotificationProfile `json:"terminateNotificationProfile,omitempty"`
}

// AssignProperties_From_ScheduledEventsProfile populates our ScheduledEventsProfile from the provided source ScheduledEventsProfile
func (profile *ScheduledEventsProfile) AssignProperties_From_ScheduledEventsProfile(source *v20201201s.ScheduledEventsProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// TerminateNotificationProfile
	if source.TerminateNotificationProfile != nil {
		var terminateNotificationProfile TerminateNotificationProfile
		err := terminateNotificationProfile.AssignProperties_From_TerminateNotificationProfile(source.TerminateNotificationProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_TerminateNotificationProfile() to populate field TerminateNotificationProfile")
		}
		profile.TerminateNotificationProfile = &terminateNotificationProfile
	} else {
		profile.TerminateNotificationProfile = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForScheduledEventsProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForScheduledEventsProfile); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ScheduledEventsProfile populates the provided destination ScheduledEventsProfile from our ScheduledEventsProfile
func (profile *ScheduledEventsProfile) AssignProperties_To_ScheduledEventsProfile(destination *v20201201s.ScheduledEventsProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// TerminateNotificationProfile
	if profile.TerminateNotificationProfile != nil {
		var terminateNotificationProfile v20201201s.TerminateNotificationProfile
		err := profile.TerminateNotificationProfile.AssignProperties_To_TerminateNotificationProfile(&terminateNotificationProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_TerminateNotificationProfile() to populate field TerminateNotificationProfile")
		}
		destination.TerminateNotificationProfile = &terminateNotificationProfile
	} else {
		destination.TerminateNotificationProfile = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForScheduledEventsProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForScheduledEventsProfile); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.ScheduledEventsProfile_STATUS
// Deprecated version of ScheduledEventsProfile_STATUS. Use v1api20220301.ScheduledEventsProfile_STATUS instead
type ScheduledEventsProfile_STATUS struct {
	PropertyBag                  genruntime.PropertyBag               `json:"$propertyBag,omitempty"`
	TerminateNotificationProfile *TerminateNotificationProfile_STATUS `json:"terminateNotificationProfile,omitempty"`
}

// AssignProperties_From_ScheduledEventsProfile_STATUS populates our ScheduledEventsProfile_STATUS from the provided source ScheduledEventsProfile_STATUS
func (profile *ScheduledEventsProfile_STATUS) AssignProperties_From_ScheduledEventsProfile_STATUS(source *v20201201s.ScheduledEventsProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// TerminateNotificationProfile
	if source.TerminateNotificationProfile != nil {
		var terminateNotificationProfile TerminateNotificationProfile_STATUS
		err := terminateNotificationProfile.AssignProperties_From_TerminateNotificationProfile_STATUS(source.TerminateNotificationProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_TerminateNotificationProfile_STATUS() to populate field TerminateNotificationProfile")
		}
		profile.TerminateNotificationProfile = &terminateNotificationProfile
	} else {
		profile.TerminateNotificationProfile = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForScheduledEventsProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForScheduledEventsProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ScheduledEventsProfile_STATUS populates the provided destination ScheduledEventsProfile_STATUS from our ScheduledEventsProfile_STATUS
func (profile *ScheduledEventsProfile_STATUS) AssignProperties_To_ScheduledEventsProfile_STATUS(destination *v20201201s.ScheduledEventsProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// TerminateNotificationProfile
	if profile.TerminateNotificationProfile != nil {
		var terminateNotificationProfile v20201201s.TerminateNotificationProfile_STATUS
		err := profile.TerminateNotificationProfile.AssignProperties_To_TerminateNotificationProfile_STATUS(&terminateNotificationProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_TerminateNotificationProfile_STATUS() to populate field TerminateNotificationProfile")
		}
		destination.TerminateNotificationProfile = &terminateNotificationProfile
	} else {
		destination.TerminateNotificationProfile = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForScheduledEventsProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForScheduledEventsProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.SecurityProfile
// Deprecated version of SecurityProfile. Use v1api20220301.SecurityProfile instead
type SecurityProfile struct {
	EncryptionAtHost *bool                  `json:"encryptionAtHost,omitempty"`
	PropertyBag      genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SecurityType     *string                `json:"securityType,omitempty"`
	UefiSettings     *UefiSettings          `json:"uefiSettings,omitempty"`
}

// AssignProperties_From_SecurityProfile populates our SecurityProfile from the provided source SecurityProfile
func (profile *SecurityProfile) AssignProperties_From_SecurityProfile(source *v20201201s.SecurityProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// EncryptionAtHost
	if source.EncryptionAtHost != nil {
		encryptionAtHost := *source.EncryptionAtHost
		profile.EncryptionAtHost = &encryptionAtHost
	} else {
		profile.EncryptionAtHost = nil
	}

	// SecurityType
	profile.SecurityType = genruntime.ClonePointerToString(source.SecurityType)

	// UefiSettings
	if source.UefiSettings != nil {
		var uefiSetting UefiSettings
		err := uefiSetting.AssignProperties_From_UefiSettings(source.UefiSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UefiSettings() to populate field UefiSettings")
		}
		profile.UefiSettings = &uefiSetting
	} else {
		profile.UefiSettings = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForSecurityProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForSecurityProfile); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_SecurityProfile populates the provided destination SecurityProfile from our SecurityProfile
func (profile *SecurityProfile) AssignProperties_To_SecurityProfile(destination *v20201201s.SecurityProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// EncryptionAtHost
	if profile.EncryptionAtHost != nil {
		encryptionAtHost := *profile.EncryptionAtHost
		destination.EncryptionAtHost = &encryptionAtHost
	} else {
		destination.EncryptionAtHost = nil
	}

	// SecurityType
	destination.SecurityType = genruntime.ClonePointerToString(profile.SecurityType)

	// UefiSettings
	if profile.UefiSettings != nil {
		var uefiSetting v20201201s.UefiSettings
		err := profile.UefiSettings.AssignProperties_To_UefiSettings(&uefiSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UefiSettings() to populate field UefiSettings")
		}
		destination.UefiSettings = &uefiSetting
	} else {
		destination.UefiSettings = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForSecurityProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForSecurityProfile); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.SecurityProfile_STATUS
// Deprecated version of SecurityProfile_STATUS. Use v1api20220301.SecurityProfile_STATUS instead
type SecurityProfile_STATUS struct {
	EncryptionAtHost *bool                  `json:"encryptionAtHost,omitempty"`
	PropertyBag      genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SecurityType     *string                `json:"securityType,omitempty"`
	UefiSettings     *UefiSettings_STATUS   `json:"uefiSettings,omitempty"`
}

// AssignProperties_From_SecurityProfile_STATUS populates our SecurityProfile_STATUS from the provided source SecurityProfile_STATUS
func (profile *SecurityProfile_STATUS) AssignProperties_From_SecurityProfile_STATUS(source *v20201201s.SecurityProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// EncryptionAtHost
	if source.EncryptionAtHost != nil {
		encryptionAtHost := *source.EncryptionAtHost
		profile.EncryptionAtHost = &encryptionAtHost
	} else {
		profile.EncryptionAtHost = nil
	}

	// SecurityType
	profile.SecurityType = genruntime.ClonePointerToString(source.SecurityType)

	// UefiSettings
	if source.UefiSettings != nil {
		var uefiSetting UefiSettings_STATUS
		err := uefiSetting.AssignProperties_From_UefiSettings_STATUS(source.UefiSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UefiSettings_STATUS() to populate field UefiSettings")
		}
		profile.UefiSettings = &uefiSetting
	} else {
		profile.UefiSettings = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForSecurityProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForSecurityProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_SecurityProfile_STATUS populates the provided destination SecurityProfile_STATUS from our SecurityProfile_STATUS
func (profile *SecurityProfile_STATUS) AssignProperties_To_SecurityProfile_STATUS(destination *v20201201s.SecurityProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// EncryptionAtHost
	if profile.EncryptionAtHost != nil {
		encryptionAtHost := *profile.EncryptionAtHost
		destination.EncryptionAtHost = &encryptionAtHost
	} else {
		destination.EncryptionAtHost = nil
	}

	// SecurityType
	destination.SecurityType = genruntime.ClonePointerToString(profile.SecurityType)

	// UefiSettings
	if profile.UefiSettings != nil {
		var uefiSetting v20201201s.UefiSettings_STATUS
		err := profile.UefiSettings.AssignProperties_To_UefiSettings_STATUS(&uefiSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UefiSettings_STATUS() to populate field UefiSettings")
		}
		destination.UefiSettings = &uefiSetting
	} else {
		destination.UefiSettings = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForSecurityProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForSecurityProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.StorageProfile
// Deprecated version of StorageProfile. Use v1api20220301.StorageProfile instead
type StorageProfile struct {
	DataDisks      []DataDisk             `json:"dataDisks,omitempty"`
	ImageReference *ImageReference        `json:"imageReference,omitempty"`
	OsDisk         *OSDisk                `json:"osDisk,omitempty"`
	PropertyBag    genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_StorageProfile populates our StorageProfile from the provided source StorageProfile
func (profile *StorageProfile) AssignProperties_From_StorageProfile(source *v20201201s.StorageProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DataDisks
	if source.DataDisks != nil {
		dataDiskList := make([]DataDisk, len(source.DataDisks))
		for dataDiskIndex, dataDiskItem := range source.DataDisks {
			// Shadow the loop variable to avoid aliasing
			dataDiskItem := dataDiskItem
			var dataDisk DataDisk
			err := dataDisk.AssignProperties_From_DataDisk(&dataDiskItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_DataDisk() to populate field DataDisks")
			}
			dataDiskList[dataDiskIndex] = dataDisk
		}
		profile.DataDisks = dataDiskList
	} else {
		profile.DataDisks = nil
	}

	// ImageReference
	if source.ImageReference != nil {
		var imageReference ImageReference
		err := imageReference.AssignProperties_From_ImageReference(source.ImageReference)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ImageReference() to populate field ImageReference")
		}
		profile.ImageReference = &imageReference
	} else {
		profile.ImageReference = nil
	}

	// OsDisk
	if source.OsDisk != nil {
		var osDisk OSDisk
		err := osDisk.AssignProperties_From_OSDisk(source.OsDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_OSDisk() to populate field OsDisk")
		}
		profile.OsDisk = &osDisk
	} else {
		profile.OsDisk = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForStorageProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForStorageProfile); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_StorageProfile populates the provided destination StorageProfile from our StorageProfile
func (profile *StorageProfile) AssignProperties_To_StorageProfile(destination *v20201201s.StorageProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// DataDisks
	if profile.DataDisks != nil {
		dataDiskList := make([]v20201201s.DataDisk, len(profile.DataDisks))
		for dataDiskIndex, dataDiskItem := range profile.DataDisks {
			// Shadow the loop variable to avoid aliasing
			dataDiskItem := dataDiskItem
			var dataDisk v20201201s.DataDisk
			err := dataDiskItem.AssignProperties_To_DataDisk(&dataDisk)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_DataDisk() to populate field DataDisks")
			}
			dataDiskList[dataDiskIndex] = dataDisk
		}
		destination.DataDisks = dataDiskList
	} else {
		destination.DataDisks = nil
	}

	// ImageReference
	if profile.ImageReference != nil {
		var imageReference v20201201s.ImageReference
		err := profile.ImageReference.AssignProperties_To_ImageReference(&imageReference)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ImageReference() to populate field ImageReference")
		}
		destination.ImageReference = &imageReference
	} else {
		destination.ImageReference = nil
	}

	// OsDisk
	if profile.OsDisk != nil {
		var osDisk v20201201s.OSDisk
		err := profile.OsDisk.AssignProperties_To_OSDisk(&osDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_OSDisk() to populate field OsDisk")
		}
		destination.OsDisk = &osDisk
	} else {
		destination.OsDisk = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForStorageProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForStorageProfile); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.StorageProfile_STATUS
// Deprecated version of StorageProfile_STATUS. Use v1api20220301.StorageProfile_STATUS instead
type StorageProfile_STATUS struct {
	DataDisks      []DataDisk_STATUS      `json:"dataDisks,omitempty"`
	ImageReference *ImageReference_STATUS `json:"imageReference,omitempty"`
	OsDisk         *OSDisk_STATUS         `json:"osDisk,omitempty"`
	PropertyBag    genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_StorageProfile_STATUS populates our StorageProfile_STATUS from the provided source StorageProfile_STATUS
func (profile *StorageProfile_STATUS) AssignProperties_From_StorageProfile_STATUS(source *v20201201s.StorageProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DataDisks
	if source.DataDisks != nil {
		dataDiskList := make([]DataDisk_STATUS, len(source.DataDisks))
		for dataDiskIndex, dataDiskItem := range source.DataDisks {
			// Shadow the loop variable to avoid aliasing
			dataDiskItem := dataDiskItem
			var dataDisk DataDisk_STATUS
			err := dataDisk.AssignProperties_From_DataDisk_STATUS(&dataDiskItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_DataDisk_STATUS() to populate field DataDisks")
			}
			dataDiskList[dataDiskIndex] = dataDisk
		}
		profile.DataDisks = dataDiskList
	} else {
		profile.DataDisks = nil
	}

	// ImageReference
	if source.ImageReference != nil {
		var imageReference ImageReference_STATUS
		err := imageReference.AssignProperties_From_ImageReference_STATUS(source.ImageReference)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ImageReference_STATUS() to populate field ImageReference")
		}
		profile.ImageReference = &imageReference
	} else {
		profile.ImageReference = nil
	}

	// OsDisk
	if source.OsDisk != nil {
		var osDisk OSDisk_STATUS
		err := osDisk.AssignProperties_From_OSDisk_STATUS(source.OsDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_OSDisk_STATUS() to populate field OsDisk")
		}
		profile.OsDisk = &osDisk
	} else {
		profile.OsDisk = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForStorageProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForStorageProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_StorageProfile_STATUS populates the provided destination StorageProfile_STATUS from our StorageProfile_STATUS
func (profile *StorageProfile_STATUS) AssignProperties_To_StorageProfile_STATUS(destination *v20201201s.StorageProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// DataDisks
	if profile.DataDisks != nil {
		dataDiskList := make([]v20201201s.DataDisk_STATUS, len(profile.DataDisks))
		for dataDiskIndex, dataDiskItem := range profile.DataDisks {
			// Shadow the loop variable to avoid aliasing
			dataDiskItem := dataDiskItem
			var dataDisk v20201201s.DataDisk_STATUS
			err := dataDiskItem.AssignProperties_To_DataDisk_STATUS(&dataDisk)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_DataDisk_STATUS() to populate field DataDisks")
			}
			dataDiskList[dataDiskIndex] = dataDisk
		}
		destination.DataDisks = dataDiskList
	} else {
		destination.DataDisks = nil
	}

	// ImageReference
	if profile.ImageReference != nil {
		var imageReference v20201201s.ImageReference_STATUS
		err := profile.ImageReference.AssignProperties_To_ImageReference_STATUS(&imageReference)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ImageReference_STATUS() to populate field ImageReference")
		}
		destination.ImageReference = &imageReference
	} else {
		destination.ImageReference = nil
	}

	// OsDisk
	if profile.OsDisk != nil {
		var osDisk v20201201s.OSDisk_STATUS
		err := profile.OsDisk.AssignProperties_To_OSDisk_STATUS(&osDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_OSDisk_STATUS() to populate field OsDisk")
		}
		destination.OsDisk = &osDisk
	} else {
		destination.OsDisk = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForStorageProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForStorageProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.VirtualMachineExtension_STATUS
// Deprecated version of VirtualMachineExtension_STATUS. Use v1api20220301.VirtualMachineExtension_STATUS instead
type VirtualMachineExtension_STATUS struct {
	AutoUpgradeMinorVersion       *bool                                       `json:"autoUpgradeMinorVersion,omitempty"`
	EnableAutomaticUpgrade        *bool                                       `json:"enableAutomaticUpgrade,omitempty"`
	ForceUpdateTag                *string                                     `json:"forceUpdateTag,omitempty"`
	Id                            *string                                     `json:"id,omitempty"`
	InstanceView                  *VirtualMachineExtensionInstanceView_STATUS `json:"instanceView,omitempty"`
	Location                      *string                                     `json:"location,omitempty"`
	Name                          *string                                     `json:"name,omitempty"`
	PropertiesType                *string                                     `json:"properties_type,omitempty"`
	PropertyBag                   genruntime.PropertyBag                      `json:"$propertyBag,omitempty"`
	ProtectedSettings             map[string]v1.JSON                          `json:"protectedSettings,omitempty"`
	ProtectedSettingsFromKeyVault *KeyVaultSecretReference_STATUS             `json:"protectedSettingsFromKeyVault,omitempty"`
	ProvisioningState             *string                                     `json:"provisioningState,omitempty"`
	Publisher                     *string                                     `json:"publisher,omitempty"`
	Settings                      map[string]v1.JSON                          `json:"settings,omitempty"`
	SuppressFailures              *bool                                       `json:"suppressFailures,omitempty"`
	Tags                          map[string]string                           `json:"tags,omitempty"`
	Type                          *string                                     `json:"type,omitempty"`
	TypeHandlerVersion            *string                                     `json:"typeHandlerVersion,omitempty"`
}

// AssignProperties_From_VirtualMachineExtension_STATUS populates our VirtualMachineExtension_STATUS from the provided source VirtualMachineExtension_STATUS
func (extension *VirtualMachineExtension_STATUS) AssignProperties_From_VirtualMachineExtension_STATUS(source *v20201201s.VirtualMachineExtension_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AutoUpgradeMinorVersion
	if source.AutoUpgradeMinorVersion != nil {
		autoUpgradeMinorVersion := *source.AutoUpgradeMinorVersion
		extension.AutoUpgradeMinorVersion = &autoUpgradeMinorVersion
	} else {
		extension.AutoUpgradeMinorVersion = nil
	}

	// EnableAutomaticUpgrade
	if source.EnableAutomaticUpgrade != nil {
		enableAutomaticUpgrade := *source.EnableAutomaticUpgrade
		extension.EnableAutomaticUpgrade = &enableAutomaticUpgrade
	} else {
		extension.EnableAutomaticUpgrade = nil
	}

	// ForceUpdateTag
	extension.ForceUpdateTag = genruntime.ClonePointerToString(source.ForceUpdateTag)

	// Id
	extension.Id = genruntime.ClonePointerToString(source.Id)

	// InstanceView
	if source.InstanceView != nil {
		var instanceView VirtualMachineExtensionInstanceView_STATUS
		err := instanceView.AssignProperties_From_VirtualMachineExtensionInstanceView_STATUS(source.InstanceView)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineExtensionInstanceView_STATUS() to populate field InstanceView")
		}
		extension.InstanceView = &instanceView
	} else {
		extension.InstanceView = nil
	}

	// Location
	extension.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	extension.Name = genruntime.ClonePointerToString(source.Name)

	// PropertiesType
	extension.PropertiesType = genruntime.ClonePointerToString(source.PropertiesType)

	// ProtectedSettings
	if source.ProtectedSettings != nil {
		protectedSettingMap := make(map[string]v1.JSON, len(source.ProtectedSettings))
		for protectedSettingKey, protectedSettingValue := range source.ProtectedSettings {
			// Shadow the loop variable to avoid aliasing
			protectedSettingValue := protectedSettingValue
			protectedSettingMap[protectedSettingKey] = *protectedSettingValue.DeepCopy()
		}
		extension.ProtectedSettings = protectedSettingMap
	} else {
		extension.ProtectedSettings = nil
	}

	// ProtectedSettingsFromKeyVault
	if propertyBag.Contains("ProtectedSettingsFromKeyVault") {
		var protectedSettingsFromKeyVault KeyVaultSecretReference_STATUS
		err := propertyBag.Pull("ProtectedSettingsFromKeyVault", &protectedSettingsFromKeyVault)
		if err != nil {
			return errors.Wrap(err, "pulling 'ProtectedSettingsFromKeyVault' from propertyBag")
		}

		extension.ProtectedSettingsFromKeyVault = &protectedSettingsFromKeyVault
	} else {
		extension.ProtectedSettingsFromKeyVault = nil
	}

	// ProvisioningState
	extension.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// Publisher
	extension.Publisher = genruntime.ClonePointerToString(source.Publisher)

	// Settings
	if source.Settings != nil {
		settingMap := make(map[string]v1.JSON, len(source.Settings))
		for settingKey, settingValue := range source.Settings {
			// Shadow the loop variable to avoid aliasing
			settingValue := settingValue
			settingMap[settingKey] = *settingValue.DeepCopy()
		}
		extension.Settings = settingMap
	} else {
		extension.Settings = nil
	}

	// SuppressFailures
	if propertyBag.Contains("SuppressFailures") {
		var suppressFailure bool
		err := propertyBag.Pull("SuppressFailures", &suppressFailure)
		if err != nil {
			return errors.Wrap(err, "pulling 'SuppressFailures' from propertyBag")
		}

		extension.SuppressFailures = &suppressFailure
	} else {
		extension.SuppressFailures = nil
	}

	// Tags
	extension.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	extension.Type = genruntime.ClonePointerToString(source.Type)

	// TypeHandlerVersion
	extension.TypeHandlerVersion = genruntime.ClonePointerToString(source.TypeHandlerVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		extension.PropertyBag = propertyBag
	} else {
		extension.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineExtension_STATUS interface (if implemented) to customize the conversion
	var extensionAsAny any = extension
	if augmentedExtension, ok := extensionAsAny.(augmentConversionForVirtualMachineExtension_STATUS); ok {
		err := augmentedExtension.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineExtension_STATUS populates the provided destination VirtualMachineExtension_STATUS from our VirtualMachineExtension_STATUS
func (extension *VirtualMachineExtension_STATUS) AssignProperties_To_VirtualMachineExtension_STATUS(destination *v20201201s.VirtualMachineExtension_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(extension.PropertyBag)

	// AutoUpgradeMinorVersion
	if extension.AutoUpgradeMinorVersion != nil {
		autoUpgradeMinorVersion := *extension.AutoUpgradeMinorVersion
		destination.AutoUpgradeMinorVersion = &autoUpgradeMinorVersion
	} else {
		destination.AutoUpgradeMinorVersion = nil
	}

	// EnableAutomaticUpgrade
	if extension.EnableAutomaticUpgrade != nil {
		enableAutomaticUpgrade := *extension.EnableAutomaticUpgrade
		destination.EnableAutomaticUpgrade = &enableAutomaticUpgrade
	} else {
		destination.EnableAutomaticUpgrade = nil
	}

	// ForceUpdateTag
	destination.ForceUpdateTag = genruntime.ClonePointerToString(extension.ForceUpdateTag)

	// Id
	destination.Id = genruntime.ClonePointerToString(extension.Id)

	// InstanceView
	if extension.InstanceView != nil {
		var instanceView v20201201s.VirtualMachineExtensionInstanceView_STATUS
		err := extension.InstanceView.AssignProperties_To_VirtualMachineExtensionInstanceView_STATUS(&instanceView)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineExtensionInstanceView_STATUS() to populate field InstanceView")
		}
		destination.InstanceView = &instanceView
	} else {
		destination.InstanceView = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(extension.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(extension.Name)

	// PropertiesType
	destination.PropertiesType = genruntime.ClonePointerToString(extension.PropertiesType)

	// ProtectedSettings
	if extension.ProtectedSettings != nil {
		protectedSettingMap := make(map[string]v1.JSON, len(extension.ProtectedSettings))
		for protectedSettingKey, protectedSettingValue := range extension.ProtectedSettings {
			// Shadow the loop variable to avoid aliasing
			protectedSettingValue := protectedSettingValue
			protectedSettingMap[protectedSettingKey] = *protectedSettingValue.DeepCopy()
		}
		destination.ProtectedSettings = protectedSettingMap
	} else {
		destination.ProtectedSettings = nil
	}

	// ProtectedSettingsFromKeyVault
	if extension.ProtectedSettingsFromKeyVault != nil {
		propertyBag.Add("ProtectedSettingsFromKeyVault", *extension.ProtectedSettingsFromKeyVault)
	} else {
		propertyBag.Remove("ProtectedSettingsFromKeyVault")
	}

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(extension.ProvisioningState)

	// Publisher
	destination.Publisher = genruntime.ClonePointerToString(extension.Publisher)

	// Settings
	if extension.Settings != nil {
		settingMap := make(map[string]v1.JSON, len(extension.Settings))
		for settingKey, settingValue := range extension.Settings {
			// Shadow the loop variable to avoid aliasing
			settingValue := settingValue
			settingMap[settingKey] = *settingValue.DeepCopy()
		}
		destination.Settings = settingMap
	} else {
		destination.Settings = nil
	}

	// SuppressFailures
	if extension.SuppressFailures != nil {
		propertyBag.Add("SuppressFailures", *extension.SuppressFailures)
	} else {
		propertyBag.Remove("SuppressFailures")
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(extension.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(extension.Type)

	// TypeHandlerVersion
	destination.TypeHandlerVersion = genruntime.ClonePointerToString(extension.TypeHandlerVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineExtension_STATUS interface (if implemented) to customize the conversion
	var extensionAsAny any = extension
	if augmentedExtension, ok := extensionAsAny.(augmentConversionForVirtualMachineExtension_STATUS); ok {
		err := augmentedExtension.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.VirtualMachineIdentity
// Deprecated version of VirtualMachineIdentity. Use v1api20220301.VirtualMachineIdentity instead
type VirtualMachineIdentity struct {
	PropertyBag            genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
	Type                   *string                       `json:"type,omitempty"`
	UserAssignedIdentities []UserAssignedIdentityDetails `json:"userAssignedIdentities,omitempty"`
}

// AssignProperties_From_VirtualMachineIdentity populates our VirtualMachineIdentity from the provided source VirtualMachineIdentity
func (identity *VirtualMachineIdentity) AssignProperties_From_VirtualMachineIdentity(source *v20201201s.VirtualMachineIdentity) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Type
	identity.Type = genruntime.ClonePointerToString(source.Type)

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]UserAssignedIdentityDetails, len(source.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity UserAssignedIdentityDetails
			err := userAssignedIdentity.AssignProperties_From_UserAssignedIdentityDetails(&userAssignedIdentityItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityList
	} else {
		identity.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		identity.PropertyBag = propertyBag
	} else {
		identity.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineIdentity interface (if implemented) to customize the conversion
	var identityAsAny any = identity
	if augmentedIdentity, ok := identityAsAny.(augmentConversionForVirtualMachineIdentity); ok {
		err := augmentedIdentity.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineIdentity populates the provided destination VirtualMachineIdentity from our VirtualMachineIdentity
func (identity *VirtualMachineIdentity) AssignProperties_To_VirtualMachineIdentity(destination *v20201201s.VirtualMachineIdentity) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(identity.PropertyBag)

	// Type
	destination.Type = genruntime.ClonePointerToString(identity.Type)

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]v20201201s.UserAssignedIdentityDetails, len(identity.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity v20201201s.UserAssignedIdentityDetails
			err := userAssignedIdentityItem.AssignProperties_To_UserAssignedIdentityDetails(&userAssignedIdentity)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityList
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineIdentity interface (if implemented) to customize the conversion
	var identityAsAny any = identity
	if augmentedIdentity, ok := identityAsAny.(augmentConversionForVirtualMachineIdentity); ok {
		err := augmentedIdentity.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.VirtualMachineIdentity_STATUS
// Deprecated version of VirtualMachineIdentity_STATUS. Use v1api20220301.VirtualMachineIdentity_STATUS instead
type VirtualMachineIdentity_STATUS struct {
	PrincipalId            *string                                                         `json:"principalId,omitempty"`
	PropertyBag            genruntime.PropertyBag                                          `json:"$propertyBag,omitempty"`
	TenantId               *string                                                         `json:"tenantId,omitempty"`
	Type                   *string                                                         `json:"type,omitempty"`
	UserAssignedIdentities map[string]VirtualMachineIdentity_UserAssignedIdentities_STATUS `json:"userAssignedIdentities,omitempty"`
}

// AssignProperties_From_VirtualMachineIdentity_STATUS populates our VirtualMachineIdentity_STATUS from the provided source VirtualMachineIdentity_STATUS
func (identity *VirtualMachineIdentity_STATUS) AssignProperties_From_VirtualMachineIdentity_STATUS(source *v20201201s.VirtualMachineIdentity_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// TenantId
	identity.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	identity.Type = genruntime.ClonePointerToString(source.Type)

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]VirtualMachineIdentity_UserAssignedIdentities_STATUS, len(source.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity VirtualMachineIdentity_UserAssignedIdentities_STATUS
			err := userAssignedIdentity.AssignProperties_From_VirtualMachineIdentity_UserAssignedIdentities_STATUS(&userAssignedIdentityValue)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineIdentity_UserAssignedIdentities_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		identity.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		identity.PropertyBag = propertyBag
	} else {
		identity.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineIdentity_STATUS interface (if implemented) to customize the conversion
	var identityAsAny any = identity
	if augmentedIdentity, ok := identityAsAny.(augmentConversionForVirtualMachineIdentity_STATUS); ok {
		err := augmentedIdentity.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineIdentity_STATUS populates the provided destination VirtualMachineIdentity_STATUS from our VirtualMachineIdentity_STATUS
func (identity *VirtualMachineIdentity_STATUS) AssignProperties_To_VirtualMachineIdentity_STATUS(destination *v20201201s.VirtualMachineIdentity_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(identity.PropertyBag)

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(identity.TenantId)

	// Type
	destination.Type = genruntime.ClonePointerToString(identity.Type)

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]v20201201s.VirtualMachineIdentity_UserAssignedIdentities_STATUS, len(identity.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity v20201201s.VirtualMachineIdentity_UserAssignedIdentities_STATUS
			err := userAssignedIdentityValue.AssignProperties_To_VirtualMachineIdentity_UserAssignedIdentities_STATUS(&userAssignedIdentity)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineIdentity_UserAssignedIdentities_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineIdentity_STATUS interface (if implemented) to customize the conversion
	var identityAsAny any = identity
	if augmentedIdentity, ok := identityAsAny.(augmentConversionForVirtualMachineIdentity_STATUS); ok {
		err := augmentedIdentity.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.VirtualMachineInstanceView_STATUS
// Deprecated version of VirtualMachineInstanceView_STATUS. Use v1api20220301.VirtualMachineInstanceView_STATUS instead
type VirtualMachineInstanceView_STATUS struct {
	AssignedHost              *string                                      `json:"assignedHost,omitempty"`
	BootDiagnostics           *BootDiagnosticsInstanceView_STATUS          `json:"bootDiagnostics,omitempty"`
	ComputerName              *string                                      `json:"computerName,omitempty"`
	Disks                     []DiskInstanceView_STATUS                    `json:"disks,omitempty"`
	Extensions                []VirtualMachineExtensionInstanceView_STATUS `json:"extensions,omitempty"`
	HyperVGeneration          *string                                      `json:"hyperVGeneration,omitempty"`
	MaintenanceRedeployStatus *MaintenanceRedeployStatus_STATUS            `json:"maintenanceRedeployStatus,omitempty"`
	OsName                    *string                                      `json:"osName,omitempty"`
	OsVersion                 *string                                      `json:"osVersion,omitempty"`
	PatchStatus               *VirtualMachinePatchStatus_STATUS            `json:"patchStatus,omitempty"`
	PlatformFaultDomain       *int                                         `json:"platformFaultDomain,omitempty"`
	PlatformUpdateDomain      *int                                         `json:"platformUpdateDomain,omitempty"`
	PropertyBag               genruntime.PropertyBag                       `json:"$propertyBag,omitempty"`
	RdpThumbPrint             *string                                      `json:"rdpThumbPrint,omitempty"`
	Statuses                  []InstanceViewStatus_STATUS                  `json:"statuses,omitempty"`
	VmAgent                   *VirtualMachineAgentInstanceView_STATUS      `json:"vmAgent,omitempty"`
	VmHealth                  *VirtualMachineHealthStatus_STATUS           `json:"vmHealth,omitempty"`
}

// AssignProperties_From_VirtualMachineInstanceView_STATUS populates our VirtualMachineInstanceView_STATUS from the provided source VirtualMachineInstanceView_STATUS
func (view *VirtualMachineInstanceView_STATUS) AssignProperties_From_VirtualMachineInstanceView_STATUS(source *v20201201s.VirtualMachineInstanceView_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AssignedHost
	view.AssignedHost = genruntime.ClonePointerToString(source.AssignedHost)

	// BootDiagnostics
	if source.BootDiagnostics != nil {
		var bootDiagnostic BootDiagnosticsInstanceView_STATUS
		err := bootDiagnostic.AssignProperties_From_BootDiagnosticsInstanceView_STATUS(source.BootDiagnostics)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BootDiagnosticsInstanceView_STATUS() to populate field BootDiagnostics")
		}
		view.BootDiagnostics = &bootDiagnostic
	} else {
		view.BootDiagnostics = nil
	}

	// ComputerName
	view.ComputerName = genruntime.ClonePointerToString(source.ComputerName)

	// Disks
	if source.Disks != nil {
		diskList := make([]DiskInstanceView_STATUS, len(source.Disks))
		for diskIndex, diskItem := range source.Disks {
			// Shadow the loop variable to avoid aliasing
			diskItem := diskItem
			var disk DiskInstanceView_STATUS
			err := disk.AssignProperties_From_DiskInstanceView_STATUS(&diskItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_DiskInstanceView_STATUS() to populate field Disks")
			}
			diskList[diskIndex] = disk
		}
		view.Disks = diskList
	} else {
		view.Disks = nil
	}

	// Extensions
	if source.Extensions != nil {
		extensionList := make([]VirtualMachineExtensionInstanceView_STATUS, len(source.Extensions))
		for extensionIndex, extensionItem := range source.Extensions {
			// Shadow the loop variable to avoid aliasing
			extensionItem := extensionItem
			var extension VirtualMachineExtensionInstanceView_STATUS
			err := extension.AssignProperties_From_VirtualMachineExtensionInstanceView_STATUS(&extensionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineExtensionInstanceView_STATUS() to populate field Extensions")
			}
			extensionList[extensionIndex] = extension
		}
		view.Extensions = extensionList
	} else {
		view.Extensions = nil
	}

	// HyperVGeneration
	view.HyperVGeneration = genruntime.ClonePointerToString(source.HyperVGeneration)

	// MaintenanceRedeployStatus
	if source.MaintenanceRedeployStatus != nil {
		var maintenanceRedeployStatus MaintenanceRedeployStatus_STATUS
		err := maintenanceRedeployStatus.AssignProperties_From_MaintenanceRedeployStatus_STATUS(source.MaintenanceRedeployStatus)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_MaintenanceRedeployStatus_STATUS() to populate field MaintenanceRedeployStatus")
		}
		view.MaintenanceRedeployStatus = &maintenanceRedeployStatus
	} else {
		view.MaintenanceRedeployStatus = nil
	}

	// OsName
	view.OsName = genruntime.ClonePointerToString(source.OsName)

	// OsVersion
	view.OsVersion = genruntime.ClonePointerToString(source.OsVersion)

	// PatchStatus
	if source.PatchStatus != nil {
		var patchStatus VirtualMachinePatchStatus_STATUS
		err := patchStatus.AssignProperties_From_VirtualMachinePatchStatus_STATUS(source.PatchStatus)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachinePatchStatus_STATUS() to populate field PatchStatus")
		}
		view.PatchStatus = &patchStatus
	} else {
		view.PatchStatus = nil
	}

	// PlatformFaultDomain
	view.PlatformFaultDomain = genruntime.ClonePointerToInt(source.PlatformFaultDomain)

	// PlatformUpdateDomain
	view.PlatformUpdateDomain = genruntime.ClonePointerToInt(source.PlatformUpdateDomain)

	// RdpThumbPrint
	view.RdpThumbPrint = genruntime.ClonePointerToString(source.RdpThumbPrint)

	// Statuses
	if source.Statuses != nil {
		statusList := make([]InstanceViewStatus_STATUS, len(source.Statuses))
		for statusIndex, statusItem := range source.Statuses {
			// Shadow the loop variable to avoid aliasing
			statusItem := statusItem
			var status InstanceViewStatus_STATUS
			err := status.AssignProperties_From_InstanceViewStatus_STATUS(&statusItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_InstanceViewStatus_STATUS() to populate field Statuses")
			}
			statusList[statusIndex] = status
		}
		view.Statuses = statusList
	} else {
		view.Statuses = nil
	}

	// VmAgent
	if source.VmAgent != nil {
		var vmAgent VirtualMachineAgentInstanceView_STATUS
		err := vmAgent.AssignProperties_From_VirtualMachineAgentInstanceView_STATUS(source.VmAgent)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineAgentInstanceView_STATUS() to populate field VmAgent")
		}
		view.VmAgent = &vmAgent
	} else {
		view.VmAgent = nil
	}

	// VmHealth
	if source.VmHealth != nil {
		var vmHealth VirtualMachineHealthStatus_STATUS
		err := vmHealth.AssignProperties_From_VirtualMachineHealthStatus_STATUS(source.VmHealth)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineHealthStatus_STATUS() to populate field VmHealth")
		}
		view.VmHealth = &vmHealth
	} else {
		view.VmHealth = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		view.PropertyBag = propertyBag
	} else {
		view.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineInstanceView_STATUS interface (if implemented) to customize the conversion
	var viewAsAny any = view
	if augmentedView, ok := viewAsAny.(augmentConversionForVirtualMachineInstanceView_STATUS); ok {
		err := augmentedView.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineInstanceView_STATUS populates the provided destination VirtualMachineInstanceView_STATUS from our VirtualMachineInstanceView_STATUS
func (view *VirtualMachineInstanceView_STATUS) AssignProperties_To_VirtualMachineInstanceView_STATUS(destination *v20201201s.VirtualMachineInstanceView_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(view.PropertyBag)

	// AssignedHost
	destination.AssignedHost = genruntime.ClonePointerToString(view.AssignedHost)

	// BootDiagnostics
	if view.BootDiagnostics != nil {
		var bootDiagnostic v20201201s.BootDiagnosticsInstanceView_STATUS
		err := view.BootDiagnostics.AssignProperties_To_BootDiagnosticsInstanceView_STATUS(&bootDiagnostic)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BootDiagnosticsInstanceView_STATUS() to populate field BootDiagnostics")
		}
		destination.BootDiagnostics = &bootDiagnostic
	} else {
		destination.BootDiagnostics = nil
	}

	// ComputerName
	destination.ComputerName = genruntime.ClonePointerToString(view.ComputerName)

	// Disks
	if view.Disks != nil {
		diskList := make([]v20201201s.DiskInstanceView_STATUS, len(view.Disks))
		for diskIndex, diskItem := range view.Disks {
			// Shadow the loop variable to avoid aliasing
			diskItem := diskItem
			var disk v20201201s.DiskInstanceView_STATUS
			err := diskItem.AssignProperties_To_DiskInstanceView_STATUS(&disk)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_DiskInstanceView_STATUS() to populate field Disks")
			}
			diskList[diskIndex] = disk
		}
		destination.Disks = diskList
	} else {
		destination.Disks = nil
	}

	// Extensions
	if view.Extensions != nil {
		extensionList := make([]v20201201s.VirtualMachineExtensionInstanceView_STATUS, len(view.Extensions))
		for extensionIndex, extensionItem := range view.Extensions {
			// Shadow the loop variable to avoid aliasing
			extensionItem := extensionItem
			var extension v20201201s.VirtualMachineExtensionInstanceView_STATUS
			err := extensionItem.AssignProperties_To_VirtualMachineExtensionInstanceView_STATUS(&extension)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineExtensionInstanceView_STATUS() to populate field Extensions")
			}
			extensionList[extensionIndex] = extension
		}
		destination.Extensions = extensionList
	} else {
		destination.Extensions = nil
	}

	// HyperVGeneration
	destination.HyperVGeneration = genruntime.ClonePointerToString(view.HyperVGeneration)

	// MaintenanceRedeployStatus
	if view.MaintenanceRedeployStatus != nil {
		var maintenanceRedeployStatus v20201201s.MaintenanceRedeployStatus_STATUS
		err := view.MaintenanceRedeployStatus.AssignProperties_To_MaintenanceRedeployStatus_STATUS(&maintenanceRedeployStatus)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_MaintenanceRedeployStatus_STATUS() to populate field MaintenanceRedeployStatus")
		}
		destination.MaintenanceRedeployStatus = &maintenanceRedeployStatus
	} else {
		destination.MaintenanceRedeployStatus = nil
	}

	// OsName
	destination.OsName = genruntime.ClonePointerToString(view.OsName)

	// OsVersion
	destination.OsVersion = genruntime.ClonePointerToString(view.OsVersion)

	// PatchStatus
	if view.PatchStatus != nil {
		var patchStatus v20201201s.VirtualMachinePatchStatus_STATUS
		err := view.PatchStatus.AssignProperties_To_VirtualMachinePatchStatus_STATUS(&patchStatus)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachinePatchStatus_STATUS() to populate field PatchStatus")
		}
		destination.PatchStatus = &patchStatus
	} else {
		destination.PatchStatus = nil
	}

	// PlatformFaultDomain
	destination.PlatformFaultDomain = genruntime.ClonePointerToInt(view.PlatformFaultDomain)

	// PlatformUpdateDomain
	destination.PlatformUpdateDomain = genruntime.ClonePointerToInt(view.PlatformUpdateDomain)

	// RdpThumbPrint
	destination.RdpThumbPrint = genruntime.ClonePointerToString(view.RdpThumbPrint)

	// Statuses
	if view.Statuses != nil {
		statusList := make([]v20201201s.InstanceViewStatus_STATUS, len(view.Statuses))
		for statusIndex, statusItem := range view.Statuses {
			// Shadow the loop variable to avoid aliasing
			statusItem := statusItem
			var status v20201201s.InstanceViewStatus_STATUS
			err := statusItem.AssignProperties_To_InstanceViewStatus_STATUS(&status)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_InstanceViewStatus_STATUS() to populate field Statuses")
			}
			statusList[statusIndex] = status
		}
		destination.Statuses = statusList
	} else {
		destination.Statuses = nil
	}

	// VmAgent
	if view.VmAgent != nil {
		var vmAgent v20201201s.VirtualMachineAgentInstanceView_STATUS
		err := view.VmAgent.AssignProperties_To_VirtualMachineAgentInstanceView_STATUS(&vmAgent)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineAgentInstanceView_STATUS() to populate field VmAgent")
		}
		destination.VmAgent = &vmAgent
	} else {
		destination.VmAgent = nil
	}

	// VmHealth
	if view.VmHealth != nil {
		var vmHealth v20201201s.VirtualMachineHealthStatus_STATUS
		err := view.VmHealth.AssignProperties_To_VirtualMachineHealthStatus_STATUS(&vmHealth)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineHealthStatus_STATUS() to populate field VmHealth")
		}
		destination.VmHealth = &vmHealth
	} else {
		destination.VmHealth = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineInstanceView_STATUS interface (if implemented) to customize the conversion
	var viewAsAny any = view
	if augmentedView, ok := viewAsAny.(augmentConversionForVirtualMachineInstanceView_STATUS); ok {
		err := augmentedView.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForAdditionalCapabilities interface {
	AssignPropertiesFrom(src *v20201201s.AdditionalCapabilities) error
	AssignPropertiesTo(dst *v20201201s.AdditionalCapabilities) error
}

type augmentConversionForAdditionalCapabilities_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.AdditionalCapabilities_STATUS) error
	AssignPropertiesTo(dst *v20201201s.AdditionalCapabilities_STATUS) error
}

type augmentConversionForApplicationProfile interface {
	AssignPropertiesFrom(src *v20220301s.ApplicationProfile) error
	AssignPropertiesTo(dst *v20220301s.ApplicationProfile) error
}

type augmentConversionForApplicationProfile_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.ApplicationProfile_STATUS) error
	AssignPropertiesTo(dst *v20220301s.ApplicationProfile_STATUS) error
}

type augmentConversionForBillingProfile interface {
	AssignPropertiesFrom(src *v20201201s.BillingProfile) error
	AssignPropertiesTo(dst *v20201201s.BillingProfile) error
}

type augmentConversionForBillingProfile_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.BillingProfile_STATUS) error
	AssignPropertiesTo(dst *v20201201s.BillingProfile_STATUS) error
}

type augmentConversionForCapacityReservationProfile interface {
	AssignPropertiesFrom(src *v20220301s.CapacityReservationProfile) error
	AssignPropertiesTo(dst *v20220301s.CapacityReservationProfile) error
}

type augmentConversionForCapacityReservationProfile_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.CapacityReservationProfile_STATUS) error
	AssignPropertiesTo(dst *v20220301s.CapacityReservationProfile_STATUS) error
}

type augmentConversionForDiagnosticsProfile interface {
	AssignPropertiesFrom(src *v20201201s.DiagnosticsProfile) error
	AssignPropertiesTo(dst *v20201201s.DiagnosticsProfile) error
}

type augmentConversionForDiagnosticsProfile_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.DiagnosticsProfile_STATUS) error
	AssignPropertiesTo(dst *v20201201s.DiagnosticsProfile_STATUS) error
}

type augmentConversionForHardwareProfile interface {
	AssignPropertiesFrom(src *v20201201s.HardwareProfile) error
	AssignPropertiesTo(dst *v20201201s.HardwareProfile) error
}

type augmentConversionForHardwareProfile_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.HardwareProfile_STATUS) error
	AssignPropertiesTo(dst *v20201201s.HardwareProfile_STATUS) error
}

type augmentConversionForNetworkProfile interface {
	AssignPropertiesFrom(src *v20201201s.NetworkProfile) error
	AssignPropertiesTo(dst *v20201201s.NetworkProfile) error
}

type augmentConversionForNetworkProfile_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.NetworkProfile_STATUS) error
	AssignPropertiesTo(dst *v20201201s.NetworkProfile_STATUS) error
}

type augmentConversionForOSProfile interface {
	AssignPropertiesFrom(src *v20201201s.OSProfile) error
	AssignPropertiesTo(dst *v20201201s.OSProfile) error
}

type augmentConversionForOSProfile_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.OSProfile_STATUS) error
	AssignPropertiesTo(dst *v20201201s.OSProfile_STATUS) error
}

type augmentConversionForPlan interface {
	AssignPropertiesFrom(src *v20201201s.Plan) error
	AssignPropertiesTo(dst *v20201201s.Plan) error
}

type augmentConversionForPlan_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.Plan_STATUS) error
	AssignPropertiesTo(dst *v20201201s.Plan_STATUS) error
}

type augmentConversionForScheduledEventsProfile interface {
	AssignPropertiesFrom(src *v20201201s.ScheduledEventsProfile) error
	AssignPropertiesTo(dst *v20201201s.ScheduledEventsProfile) error
}

type augmentConversionForScheduledEventsProfile_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.ScheduledEventsProfile_STATUS) error
	AssignPropertiesTo(dst *v20201201s.ScheduledEventsProfile_STATUS) error
}

type augmentConversionForSecurityProfile interface {
	AssignPropertiesFrom(src *v20201201s.SecurityProfile) error
	AssignPropertiesTo(dst *v20201201s.SecurityProfile) error
}

type augmentConversionForSecurityProfile_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.SecurityProfile_STATUS) error
	AssignPropertiesTo(dst *v20201201s.SecurityProfile_STATUS) error
}

type augmentConversionForStorageProfile interface {
	AssignPropertiesFrom(src *v20201201s.StorageProfile) error
	AssignPropertiesTo(dst *v20201201s.StorageProfile) error
}

type augmentConversionForStorageProfile_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.StorageProfile_STATUS) error
	AssignPropertiesTo(dst *v20201201s.StorageProfile_STATUS) error
}

type augmentConversionForVirtualMachineExtension_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.VirtualMachineExtension_STATUS) error
	AssignPropertiesTo(dst *v20201201s.VirtualMachineExtension_STATUS) error
}

type augmentConversionForVirtualMachineIdentity interface {
	AssignPropertiesFrom(src *v20201201s.VirtualMachineIdentity) error
	AssignPropertiesTo(dst *v20201201s.VirtualMachineIdentity) error
}

type augmentConversionForVirtualMachineIdentity_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.VirtualMachineIdentity_STATUS) error
	AssignPropertiesTo(dst *v20201201s.VirtualMachineIdentity_STATUS) error
}

type augmentConversionForVirtualMachineInstanceView_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.VirtualMachineInstanceView_STATUS) error
	AssignPropertiesTo(dst *v20201201s.VirtualMachineInstanceView_STATUS) error
}

// Storage version of v1beta20220301.BootDiagnostics
// Deprecated version of BootDiagnostics. Use v1api20220301.BootDiagnostics instead
type BootDiagnostics struct {
	Enabled     *bool                  `json:"enabled,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	StorageUri  *string                `json:"storageUri,omitempty"`
}

// AssignProperties_From_BootDiagnostics populates our BootDiagnostics from the provided source BootDiagnostics
func (diagnostics *BootDiagnostics) AssignProperties_From_BootDiagnostics(source *v20201201s.BootDiagnostics) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		diagnostics.Enabled = &enabled
	} else {
		diagnostics.Enabled = nil
	}

	// StorageUri
	diagnostics.StorageUri = genruntime.ClonePointerToString(source.StorageUri)

	// Update the property bag
	if len(propertyBag) > 0 {
		diagnostics.PropertyBag = propertyBag
	} else {
		diagnostics.PropertyBag = nil
	}

	// Invoke the augmentConversionForBootDiagnostics interface (if implemented) to customize the conversion
	var diagnosticsAsAny any = diagnostics
	if augmentedDiagnostics, ok := diagnosticsAsAny.(augmentConversionForBootDiagnostics); ok {
		err := augmentedDiagnostics.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_BootDiagnostics populates the provided destination BootDiagnostics from our BootDiagnostics
func (diagnostics *BootDiagnostics) AssignProperties_To_BootDiagnostics(destination *v20201201s.BootDiagnostics) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(diagnostics.PropertyBag)

	// Enabled
	if diagnostics.Enabled != nil {
		enabled := *diagnostics.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// StorageUri
	destination.StorageUri = genruntime.ClonePointerToString(diagnostics.StorageUri)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForBootDiagnostics interface (if implemented) to customize the conversion
	var diagnosticsAsAny any = diagnostics
	if augmentedDiagnostics, ok := diagnosticsAsAny.(augmentConversionForBootDiagnostics); ok {
		err := augmentedDiagnostics.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.BootDiagnostics_STATUS
// Deprecated version of BootDiagnostics_STATUS. Use v1api20220301.BootDiagnostics_STATUS instead
type BootDiagnostics_STATUS struct {
	Enabled     *bool                  `json:"enabled,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	StorageUri  *string                `json:"storageUri,omitempty"`
}

// AssignProperties_From_BootDiagnostics_STATUS populates our BootDiagnostics_STATUS from the provided source BootDiagnostics_STATUS
func (diagnostics *BootDiagnostics_STATUS) AssignProperties_From_BootDiagnostics_STATUS(source *v20201201s.BootDiagnostics_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		diagnostics.Enabled = &enabled
	} else {
		diagnostics.Enabled = nil
	}

	// StorageUri
	diagnostics.StorageUri = genruntime.ClonePointerToString(source.StorageUri)

	// Update the property bag
	if len(propertyBag) > 0 {
		diagnostics.PropertyBag = propertyBag
	} else {
		diagnostics.PropertyBag = nil
	}

	// Invoke the augmentConversionForBootDiagnostics_STATUS interface (if implemented) to customize the conversion
	var diagnosticsAsAny any = diagnostics
	if augmentedDiagnostics, ok := diagnosticsAsAny.(augmentConversionForBootDiagnostics_STATUS); ok {
		err := augmentedDiagnostics.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_BootDiagnostics_STATUS populates the provided destination BootDiagnostics_STATUS from our BootDiagnostics_STATUS
func (diagnostics *BootDiagnostics_STATUS) AssignProperties_To_BootDiagnostics_STATUS(destination *v20201201s.BootDiagnostics_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(diagnostics.PropertyBag)

	// Enabled
	if diagnostics.Enabled != nil {
		enabled := *diagnostics.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// StorageUri
	destination.StorageUri = genruntime.ClonePointerToString(diagnostics.StorageUri)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForBootDiagnostics_STATUS interface (if implemented) to customize the conversion
	var diagnosticsAsAny any = diagnostics
	if augmentedDiagnostics, ok := diagnosticsAsAny.(augmentConversionForBootDiagnostics_STATUS); ok {
		err := augmentedDiagnostics.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.BootDiagnosticsInstanceView_STATUS
// Deprecated version of BootDiagnosticsInstanceView_STATUS. Use v1api20220301.BootDiagnosticsInstanceView_STATUS instead
type BootDiagnosticsInstanceView_STATUS struct {
	ConsoleScreenshotBlobUri *string                    `json:"consoleScreenshotBlobUri,omitempty"`
	PropertyBag              genruntime.PropertyBag     `json:"$propertyBag,omitempty"`
	SerialConsoleLogBlobUri  *string                    `json:"serialConsoleLogBlobUri,omitempty"`
	Status                   *InstanceViewStatus_STATUS `json:"status,omitempty"`
}

// AssignProperties_From_BootDiagnosticsInstanceView_STATUS populates our BootDiagnosticsInstanceView_STATUS from the provided source BootDiagnosticsInstanceView_STATUS
func (view *BootDiagnosticsInstanceView_STATUS) AssignProperties_From_BootDiagnosticsInstanceView_STATUS(source *v20201201s.BootDiagnosticsInstanceView_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ConsoleScreenshotBlobUri
	view.ConsoleScreenshotBlobUri = genruntime.ClonePointerToString(source.ConsoleScreenshotBlobUri)

	// SerialConsoleLogBlobUri
	view.SerialConsoleLogBlobUri = genruntime.ClonePointerToString(source.SerialConsoleLogBlobUri)

	// Status
	if source.Status != nil {
		var status InstanceViewStatus_STATUS
		err := status.AssignProperties_From_InstanceViewStatus_STATUS(source.Status)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_InstanceViewStatus_STATUS() to populate field Status")
		}
		view.Status = &status
	} else {
		view.Status = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		view.PropertyBag = propertyBag
	} else {
		view.PropertyBag = nil
	}

	// Invoke the augmentConversionForBootDiagnosticsInstanceView_STATUS interface (if implemented) to customize the conversion
	var viewAsAny any = view
	if augmentedView, ok := viewAsAny.(augmentConversionForBootDiagnosticsInstanceView_STATUS); ok {
		err := augmentedView.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_BootDiagnosticsInstanceView_STATUS populates the provided destination BootDiagnosticsInstanceView_STATUS from our BootDiagnosticsInstanceView_STATUS
func (view *BootDiagnosticsInstanceView_STATUS) AssignProperties_To_BootDiagnosticsInstanceView_STATUS(destination *v20201201s.BootDiagnosticsInstanceView_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(view.PropertyBag)

	// ConsoleScreenshotBlobUri
	destination.ConsoleScreenshotBlobUri = genruntime.ClonePointerToString(view.ConsoleScreenshotBlobUri)

	// SerialConsoleLogBlobUri
	destination.SerialConsoleLogBlobUri = genruntime.ClonePointerToString(view.SerialConsoleLogBlobUri)

	// Status
	if view.Status != nil {
		var status v20201201s.InstanceViewStatus_STATUS
		err := view.Status.AssignProperties_To_InstanceViewStatus_STATUS(&status)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_InstanceViewStatus_STATUS() to populate field Status")
		}
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForBootDiagnosticsInstanceView_STATUS interface (if implemented) to customize the conversion
	var viewAsAny any = view
	if augmentedView, ok := viewAsAny.(augmentConversionForBootDiagnosticsInstanceView_STATUS); ok {
		err := augmentedView.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.DataDisk
// Deprecated version of DataDisk. Use v1api20220301.DataDisk instead
type DataDisk struct {
	Caching                 *string                `json:"caching,omitempty"`
	CreateOption            *string                `json:"createOption,omitempty"`
	DeleteOption            *string                `json:"deleteOption,omitempty"`
	DetachOption            *string                `json:"detachOption,omitempty"`
	DiskSizeGB              *int                   `json:"diskSizeGB,omitempty"`
	Image                   *VirtualHardDisk       `json:"image,omitempty"`
	Lun                     *int                   `json:"lun,omitempty"`
	ManagedDisk             *ManagedDiskParameters `json:"managedDisk,omitempty"`
	Name                    *string                `json:"name,omitempty"`
	PropertyBag             genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	ToBeDetached            *bool                  `json:"toBeDetached,omitempty"`
	Vhd                     *VirtualHardDisk       `json:"vhd,omitempty"`
	WriteAcceleratorEnabled *bool                  `json:"writeAcceleratorEnabled,omitempty"`
}

// AssignProperties_From_DataDisk populates our DataDisk from the provided source DataDisk
func (disk *DataDisk) AssignProperties_From_DataDisk(source *v20201201s.DataDisk) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Caching
	disk.Caching = genruntime.ClonePointerToString(source.Caching)

	// CreateOption
	disk.CreateOption = genruntime.ClonePointerToString(source.CreateOption)

	// DeleteOption
	if propertyBag.Contains("DeleteOption") {
		var deleteOption string
		err := propertyBag.Pull("DeleteOption", &deleteOption)
		if err != nil {
			return errors.Wrap(err, "pulling 'DeleteOption' from propertyBag")
		}

		disk.DeleteOption = &deleteOption
	} else {
		disk.DeleteOption = nil
	}

	// DetachOption
	disk.DetachOption = genruntime.ClonePointerToString(source.DetachOption)

	// DiskSizeGB
	disk.DiskSizeGB = genruntime.ClonePointerToInt(source.DiskSizeGB)

	// Image
	if source.Image != nil {
		var image VirtualHardDisk
		err := image.AssignProperties_From_VirtualHardDisk(source.Image)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualHardDisk() to populate field Image")
		}
		disk.Image = &image
	} else {
		disk.Image = nil
	}

	// Lun
	disk.Lun = genruntime.ClonePointerToInt(source.Lun)

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk ManagedDiskParameters
		err := managedDisk.AssignProperties_From_ManagedDiskParameters(source.ManagedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedDiskParameters() to populate field ManagedDisk")
		}
		disk.ManagedDisk = &managedDisk
	} else {
		disk.ManagedDisk = nil
	}

	// Name
	disk.Name = genruntime.ClonePointerToString(source.Name)

	// ToBeDetached
	if source.ToBeDetached != nil {
		toBeDetached := *source.ToBeDetached
		disk.ToBeDetached = &toBeDetached
	} else {
		disk.ToBeDetached = nil
	}

	// Vhd
	if source.Vhd != nil {
		var vhd VirtualHardDisk
		err := vhd.AssignProperties_From_VirtualHardDisk(source.Vhd)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualHardDisk() to populate field Vhd")
		}
		disk.Vhd = &vhd
	} else {
		disk.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if source.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *source.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		disk.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		disk.PropertyBag = propertyBag
	} else {
		disk.PropertyBag = nil
	}

	// Invoke the augmentConversionForDataDisk interface (if implemented) to customize the conversion
	var diskAsAny any = disk
	if augmentedDisk, ok := diskAsAny.(augmentConversionForDataDisk); ok {
		err := augmentedDisk.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DataDisk populates the provided destination DataDisk from our DataDisk
func (disk *DataDisk) AssignProperties_To_DataDisk(destination *v20201201s.DataDisk) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(disk.PropertyBag)

	// Caching
	destination.Caching = genruntime.ClonePointerToString(disk.Caching)

	// CreateOption
	destination.CreateOption = genruntime.ClonePointerToString(disk.CreateOption)

	// DeleteOption
	if disk.DeleteOption != nil {
		propertyBag.Add("DeleteOption", *disk.DeleteOption)
	} else {
		propertyBag.Remove("DeleteOption")
	}

	// DetachOption
	destination.DetachOption = genruntime.ClonePointerToString(disk.DetachOption)

	// DiskSizeGB
	destination.DiskSizeGB = genruntime.ClonePointerToInt(disk.DiskSizeGB)

	// Image
	if disk.Image != nil {
		var image v20201201s.VirtualHardDisk
		err := disk.Image.AssignProperties_To_VirtualHardDisk(&image)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualHardDisk() to populate field Image")
		}
		destination.Image = &image
	} else {
		destination.Image = nil
	}

	// Lun
	destination.Lun = genruntime.ClonePointerToInt(disk.Lun)

	// ManagedDisk
	if disk.ManagedDisk != nil {
		var managedDisk v20201201s.ManagedDiskParameters
		err := disk.ManagedDisk.AssignProperties_To_ManagedDiskParameters(&managedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedDiskParameters() to populate field ManagedDisk")
		}
		destination.ManagedDisk = &managedDisk
	} else {
		destination.ManagedDisk = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(disk.Name)

	// ToBeDetached
	if disk.ToBeDetached != nil {
		toBeDetached := *disk.ToBeDetached
		destination.ToBeDetached = &toBeDetached
	} else {
		destination.ToBeDetached = nil
	}

	// Vhd
	if disk.Vhd != nil {
		var vhd v20201201s.VirtualHardDisk
		err := disk.Vhd.AssignProperties_To_VirtualHardDisk(&vhd)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualHardDisk() to populate field Vhd")
		}
		destination.Vhd = &vhd
	} else {
		destination.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if disk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *disk.WriteAcceleratorEnabled
		destination.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		destination.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDataDisk interface (if implemented) to customize the conversion
	var diskAsAny any = disk
	if augmentedDisk, ok := diskAsAny.(augmentConversionForDataDisk); ok {
		err := augmentedDisk.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.DataDisk_STATUS
// Deprecated version of DataDisk_STATUS. Use v1api20220301.DataDisk_STATUS instead
type DataDisk_STATUS struct {
	Caching                 *string                       `json:"caching,omitempty"`
	CreateOption            *string                       `json:"createOption,omitempty"`
	DeleteOption            *string                       `json:"deleteOption,omitempty"`
	DetachOption            *string                       `json:"detachOption,omitempty"`
	DiskIOPSReadWrite       *int                          `json:"diskIOPSReadWrite,omitempty"`
	DiskMBpsReadWrite       *int                          `json:"diskMBpsReadWrite,omitempty"`
	DiskSizeGB              *int                          `json:"diskSizeGB,omitempty"`
	Image                   *VirtualHardDisk_STATUS       `json:"image,omitempty"`
	Lun                     *int                          `json:"lun,omitempty"`
	ManagedDisk             *ManagedDiskParameters_STATUS `json:"managedDisk,omitempty"`
	Name                    *string                       `json:"name,omitempty"`
	PropertyBag             genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
	ToBeDetached            *bool                         `json:"toBeDetached,omitempty"`
	Vhd                     *VirtualHardDisk_STATUS       `json:"vhd,omitempty"`
	WriteAcceleratorEnabled *bool                         `json:"writeAcceleratorEnabled,omitempty"`
}

// AssignProperties_From_DataDisk_STATUS populates our DataDisk_STATUS from the provided source DataDisk_STATUS
func (disk *DataDisk_STATUS) AssignProperties_From_DataDisk_STATUS(source *v20201201s.DataDisk_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Caching
	disk.Caching = genruntime.ClonePointerToString(source.Caching)

	// CreateOption
	disk.CreateOption = genruntime.ClonePointerToString(source.CreateOption)

	// DeleteOption
	if propertyBag.Contains("DeleteOption") {
		var deleteOption string
		err := propertyBag.Pull("DeleteOption", &deleteOption)
		if err != nil {
			return errors.Wrap(err, "pulling 'DeleteOption' from propertyBag")
		}

		disk.DeleteOption = &deleteOption
	} else {
		disk.DeleteOption = nil
	}

	// DetachOption
	disk.DetachOption = genruntime.ClonePointerToString(source.DetachOption)

	// DiskIOPSReadWrite
	disk.DiskIOPSReadWrite = genruntime.ClonePointerToInt(source.DiskIOPSReadWrite)

	// DiskMBpsReadWrite
	disk.DiskMBpsReadWrite = genruntime.ClonePointerToInt(source.DiskMBpsReadWrite)

	// DiskSizeGB
	disk.DiskSizeGB = genruntime.ClonePointerToInt(source.DiskSizeGB)

	// Image
	if source.Image != nil {
		var image VirtualHardDisk_STATUS
		err := image.AssignProperties_From_VirtualHardDisk_STATUS(source.Image)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualHardDisk_STATUS() to populate field Image")
		}
		disk.Image = &image
	} else {
		disk.Image = nil
	}

	// Lun
	disk.Lun = genruntime.ClonePointerToInt(source.Lun)

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk ManagedDiskParameters_STATUS
		err := managedDisk.AssignProperties_From_ManagedDiskParameters_STATUS(source.ManagedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedDiskParameters_STATUS() to populate field ManagedDisk")
		}
		disk.ManagedDisk = &managedDisk
	} else {
		disk.ManagedDisk = nil
	}

	// Name
	disk.Name = genruntime.ClonePointerToString(source.Name)

	// ToBeDetached
	if source.ToBeDetached != nil {
		toBeDetached := *source.ToBeDetached
		disk.ToBeDetached = &toBeDetached
	} else {
		disk.ToBeDetached = nil
	}

	// Vhd
	if source.Vhd != nil {
		var vhd VirtualHardDisk_STATUS
		err := vhd.AssignProperties_From_VirtualHardDisk_STATUS(source.Vhd)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualHardDisk_STATUS() to populate field Vhd")
		}
		disk.Vhd = &vhd
	} else {
		disk.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if source.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *source.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		disk.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		disk.PropertyBag = propertyBag
	} else {
		disk.PropertyBag = nil
	}

	// Invoke the augmentConversionForDataDisk_STATUS interface (if implemented) to customize the conversion
	var diskAsAny any = disk
	if augmentedDisk, ok := diskAsAny.(augmentConversionForDataDisk_STATUS); ok {
		err := augmentedDisk.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DataDisk_STATUS populates the provided destination DataDisk_STATUS from our DataDisk_STATUS
func (disk *DataDisk_STATUS) AssignProperties_To_DataDisk_STATUS(destination *v20201201s.DataDisk_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(disk.PropertyBag)

	// Caching
	destination.Caching = genruntime.ClonePointerToString(disk.Caching)

	// CreateOption
	destination.CreateOption = genruntime.ClonePointerToString(disk.CreateOption)

	// DeleteOption
	if disk.DeleteOption != nil {
		propertyBag.Add("DeleteOption", *disk.DeleteOption)
	} else {
		propertyBag.Remove("DeleteOption")
	}

	// DetachOption
	destination.DetachOption = genruntime.ClonePointerToString(disk.DetachOption)

	// DiskIOPSReadWrite
	destination.DiskIOPSReadWrite = genruntime.ClonePointerToInt(disk.DiskIOPSReadWrite)

	// DiskMBpsReadWrite
	destination.DiskMBpsReadWrite = genruntime.ClonePointerToInt(disk.DiskMBpsReadWrite)

	// DiskSizeGB
	destination.DiskSizeGB = genruntime.ClonePointerToInt(disk.DiskSizeGB)

	// Image
	if disk.Image != nil {
		var image v20201201s.VirtualHardDisk_STATUS
		err := disk.Image.AssignProperties_To_VirtualHardDisk_STATUS(&image)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualHardDisk_STATUS() to populate field Image")
		}
		destination.Image = &image
	} else {
		destination.Image = nil
	}

	// Lun
	destination.Lun = genruntime.ClonePointerToInt(disk.Lun)

	// ManagedDisk
	if disk.ManagedDisk != nil {
		var managedDisk v20201201s.ManagedDiskParameters_STATUS
		err := disk.ManagedDisk.AssignProperties_To_ManagedDiskParameters_STATUS(&managedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedDiskParameters_STATUS() to populate field ManagedDisk")
		}
		destination.ManagedDisk = &managedDisk
	} else {
		destination.ManagedDisk = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(disk.Name)

	// ToBeDetached
	if disk.ToBeDetached != nil {
		toBeDetached := *disk.ToBeDetached
		destination.ToBeDetached = &toBeDetached
	} else {
		destination.ToBeDetached = nil
	}

	// Vhd
	if disk.Vhd != nil {
		var vhd v20201201s.VirtualHardDisk_STATUS
		err := disk.Vhd.AssignProperties_To_VirtualHardDisk_STATUS(&vhd)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualHardDisk_STATUS() to populate field Vhd")
		}
		destination.Vhd = &vhd
	} else {
		destination.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if disk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *disk.WriteAcceleratorEnabled
		destination.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		destination.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDataDisk_STATUS interface (if implemented) to customize the conversion
	var diskAsAny any = disk
	if augmentedDisk, ok := diskAsAny.(augmentConversionForDataDisk_STATUS); ok {
		err := augmentedDisk.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.DiskInstanceView_STATUS
// Deprecated version of DiskInstanceView_STATUS. Use v1api20220301.DiskInstanceView_STATUS instead
type DiskInstanceView_STATUS struct {
	EncryptionSettings []DiskEncryptionSettings_STATUS `json:"encryptionSettings,omitempty"`
	Name               *string                         `json:"name,omitempty"`
	PropertyBag        genruntime.PropertyBag          `json:"$propertyBag,omitempty"`
	Statuses           []InstanceViewStatus_STATUS     `json:"statuses,omitempty"`
}

// AssignProperties_From_DiskInstanceView_STATUS populates our DiskInstanceView_STATUS from the provided source DiskInstanceView_STATUS
func (view *DiskInstanceView_STATUS) AssignProperties_From_DiskInstanceView_STATUS(source *v20201201s.DiskInstanceView_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// EncryptionSettings
	if source.EncryptionSettings != nil {
		encryptionSettingList := make([]DiskEncryptionSettings_STATUS, len(source.EncryptionSettings))
		for encryptionSettingIndex, encryptionSettingItem := range source.EncryptionSettings {
			// Shadow the loop variable to avoid aliasing
			encryptionSettingItem := encryptionSettingItem
			var encryptionSetting DiskEncryptionSettings_STATUS
			err := encryptionSetting.AssignProperties_From_DiskEncryptionSettings_STATUS(&encryptionSettingItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_DiskEncryptionSettings_STATUS() to populate field EncryptionSettings")
			}
			encryptionSettingList[encryptionSettingIndex] = encryptionSetting
		}
		view.EncryptionSettings = encryptionSettingList
	} else {
		view.EncryptionSettings = nil
	}

	// Name
	view.Name = genruntime.ClonePointerToString(source.Name)

	// Statuses
	if source.Statuses != nil {
		statusList := make([]InstanceViewStatus_STATUS, len(source.Statuses))
		for statusIndex, statusItem := range source.Statuses {
			// Shadow the loop variable to avoid aliasing
			statusItem := statusItem
			var status InstanceViewStatus_STATUS
			err := status.AssignProperties_From_InstanceViewStatus_STATUS(&statusItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_InstanceViewStatus_STATUS() to populate field Statuses")
			}
			statusList[statusIndex] = status
		}
		view.Statuses = statusList
	} else {
		view.Statuses = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		view.PropertyBag = propertyBag
	} else {
		view.PropertyBag = nil
	}

	// Invoke the augmentConversionForDiskInstanceView_STATUS interface (if implemented) to customize the conversion
	var viewAsAny any = view
	if augmentedView, ok := viewAsAny.(augmentConversionForDiskInstanceView_STATUS); ok {
		err := augmentedView.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DiskInstanceView_STATUS populates the provided destination DiskInstanceView_STATUS from our DiskInstanceView_STATUS
func (view *DiskInstanceView_STATUS) AssignProperties_To_DiskInstanceView_STATUS(destination *v20201201s.DiskInstanceView_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(view.PropertyBag)

	// EncryptionSettings
	if view.EncryptionSettings != nil {
		encryptionSettingList := make([]v20201201s.DiskEncryptionSettings_STATUS, len(view.EncryptionSettings))
		for encryptionSettingIndex, encryptionSettingItem := range view.EncryptionSettings {
			// Shadow the loop variable to avoid aliasing
			encryptionSettingItem := encryptionSettingItem
			var encryptionSetting v20201201s.DiskEncryptionSettings_STATUS
			err := encryptionSettingItem.AssignProperties_To_DiskEncryptionSettings_STATUS(&encryptionSetting)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_DiskEncryptionSettings_STATUS() to populate field EncryptionSettings")
			}
			encryptionSettingList[encryptionSettingIndex] = encryptionSetting
		}
		destination.EncryptionSettings = encryptionSettingList
	} else {
		destination.EncryptionSettings = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(view.Name)

	// Statuses
	if view.Statuses != nil {
		statusList := make([]v20201201s.InstanceViewStatus_STATUS, len(view.Statuses))
		for statusIndex, statusItem := range view.Statuses {
			// Shadow the loop variable to avoid aliasing
			statusItem := statusItem
			var status v20201201s.InstanceViewStatus_STATUS
			err := statusItem.AssignProperties_To_InstanceViewStatus_STATUS(&status)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_InstanceViewStatus_STATUS() to populate field Statuses")
			}
			statusList[statusIndex] = status
		}
		destination.Statuses = statusList
	} else {
		destination.Statuses = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDiskInstanceView_STATUS interface (if implemented) to customize the conversion
	var viewAsAny any = view
	if augmentedView, ok := viewAsAny.(augmentConversionForDiskInstanceView_STATUS); ok {
		err := augmentedView.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.ImageReference
// Deprecated version of ImageReference. Use v1api20220301.ImageReference instead
type ImageReference struct {
	CommunityGalleryImageId *string                       `json:"communityGalleryImageId,omitempty"`
	Offer                   *string                       `json:"offer,omitempty"`
	PropertyBag             genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
	Publisher               *string                       `json:"publisher,omitempty"`
	Reference               *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
	SharedGalleryImageId    *string                       `json:"sharedGalleryImageId,omitempty"`
	Sku                     *string                       `json:"sku,omitempty"`
	Version                 *string                       `json:"version,omitempty"`
}

// AssignProperties_From_ImageReference populates our ImageReference from the provided source ImageReference
func (reference *ImageReference) AssignProperties_From_ImageReference(source *v20201201s.ImageReference) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CommunityGalleryImageId
	if propertyBag.Contains("CommunityGalleryImageId") {
		var communityGalleryImageId string
		err := propertyBag.Pull("CommunityGalleryImageId", &communityGalleryImageId)
		if err != nil {
			return errors.Wrap(err, "pulling 'CommunityGalleryImageId' from propertyBag")
		}

		reference.CommunityGalleryImageId = &communityGalleryImageId
	} else {
		reference.CommunityGalleryImageId = nil
	}

	// Offer
	reference.Offer = genruntime.ClonePointerToString(source.Offer)

	// Publisher
	reference.Publisher = genruntime.ClonePointerToString(source.Publisher)

	// Reference
	if source.Reference != nil {
		referenceTemp := source.Reference.Copy()
		reference.Reference = &referenceTemp
	} else {
		reference.Reference = nil
	}

	// SharedGalleryImageId
	if propertyBag.Contains("SharedGalleryImageId") {
		var sharedGalleryImageId string
		err := propertyBag.Pull("SharedGalleryImageId", &sharedGalleryImageId)
		if err != nil {
			return errors.Wrap(err, "pulling 'SharedGalleryImageId' from propertyBag")
		}

		reference.SharedGalleryImageId = &sharedGalleryImageId
	} else {
		reference.SharedGalleryImageId = nil
	}

	// Sku
	reference.Sku = genruntime.ClonePointerToString(source.Sku)

	// Version
	reference.Version = genruntime.ClonePointerToString(source.Version)

	// Update the property bag
	if len(propertyBag) > 0 {
		reference.PropertyBag = propertyBag
	} else {
		reference.PropertyBag = nil
	}

	// Invoke the augmentConversionForImageReference interface (if implemented) to customize the conversion
	var referenceAsAny any = reference
	if augmentedReference, ok := referenceAsAny.(augmentConversionForImageReference); ok {
		err := augmentedReference.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ImageReference populates the provided destination ImageReference from our ImageReference
func (reference *ImageReference) AssignProperties_To_ImageReference(destination *v20201201s.ImageReference) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(reference.PropertyBag)

	// CommunityGalleryImageId
	if reference.CommunityGalleryImageId != nil {
		propertyBag.Add("CommunityGalleryImageId", *reference.CommunityGalleryImageId)
	} else {
		propertyBag.Remove("CommunityGalleryImageId")
	}

	// Offer
	destination.Offer = genruntime.ClonePointerToString(reference.Offer)

	// Publisher
	destination.Publisher = genruntime.ClonePointerToString(reference.Publisher)

	// Reference
	if reference.Reference != nil {
		referenceTemp := reference.Reference.Copy()
		destination.Reference = &referenceTemp
	} else {
		destination.Reference = nil
	}

	// SharedGalleryImageId
	if reference.SharedGalleryImageId != nil {
		propertyBag.Add("SharedGalleryImageId", *reference.SharedGalleryImageId)
	} else {
		propertyBag.Remove("SharedGalleryImageId")
	}

	// Sku
	destination.Sku = genruntime.ClonePointerToString(reference.Sku)

	// Version
	destination.Version = genruntime.ClonePointerToString(reference.Version)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForImageReference interface (if implemented) to customize the conversion
	var referenceAsAny any = reference
	if augmentedReference, ok := referenceAsAny.(augmentConversionForImageReference); ok {
		err := augmentedReference.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.ImageReference_STATUS
// Deprecated version of ImageReference_STATUS. Use v1api20220301.ImageReference_STATUS instead
type ImageReference_STATUS struct {
	CommunityGalleryImageId *string                `json:"communityGalleryImageId,omitempty"`
	ExactVersion            *string                `json:"exactVersion,omitempty"`
	Id                      *string                `json:"id,omitempty"`
	Offer                   *string                `json:"offer,omitempty"`
	PropertyBag             genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Publisher               *string                `json:"publisher,omitempty"`
	SharedGalleryImageId    *string                `json:"sharedGalleryImageId,omitempty"`
	Sku                     *string                `json:"sku,omitempty"`
	Version                 *string                `json:"version,omitempty"`
}

// AssignProperties_From_ImageReference_STATUS populates our ImageReference_STATUS from the provided source ImageReference_STATUS
func (reference *ImageReference_STATUS) AssignProperties_From_ImageReference_STATUS(source *v20201201s.ImageReference_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CommunityGalleryImageId
	if propertyBag.Contains("CommunityGalleryImageId") {
		var communityGalleryImageId string
		err := propertyBag.Pull("CommunityGalleryImageId", &communityGalleryImageId)
		if err != nil {
			return errors.Wrap(err, "pulling 'CommunityGalleryImageId' from propertyBag")
		}

		reference.CommunityGalleryImageId = &communityGalleryImageId
	} else {
		reference.CommunityGalleryImageId = nil
	}

	// ExactVersion
	reference.ExactVersion = genruntime.ClonePointerToString(source.ExactVersion)

	// Id
	reference.Id = genruntime.ClonePointerToString(source.Id)

	// Offer
	reference.Offer = genruntime.ClonePointerToString(source.Offer)

	// Publisher
	reference.Publisher = genruntime.ClonePointerToString(source.Publisher)

	// SharedGalleryImageId
	if propertyBag.Contains("SharedGalleryImageId") {
		var sharedGalleryImageId string
		err := propertyBag.Pull("SharedGalleryImageId", &sharedGalleryImageId)
		if err != nil {
			return errors.Wrap(err, "pulling 'SharedGalleryImageId' from propertyBag")
		}

		reference.SharedGalleryImageId = &sharedGalleryImageId
	} else {
		reference.SharedGalleryImageId = nil
	}

	// Sku
	reference.Sku = genruntime.ClonePointerToString(source.Sku)

	// Version
	reference.Version = genruntime.ClonePointerToString(source.Version)

	// Update the property bag
	if len(propertyBag) > 0 {
		reference.PropertyBag = propertyBag
	} else {
		reference.PropertyBag = nil
	}

	// Invoke the augmentConversionForImageReference_STATUS interface (if implemented) to customize the conversion
	var referenceAsAny any = reference
	if augmentedReference, ok := referenceAsAny.(augmentConversionForImageReference_STATUS); ok {
		err := augmentedReference.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ImageReference_STATUS populates the provided destination ImageReference_STATUS from our ImageReference_STATUS
func (reference *ImageReference_STATUS) AssignProperties_To_ImageReference_STATUS(destination *v20201201s.ImageReference_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(reference.PropertyBag)

	// CommunityGalleryImageId
	if reference.CommunityGalleryImageId != nil {
		propertyBag.Add("CommunityGalleryImageId", *reference.CommunityGalleryImageId)
	} else {
		propertyBag.Remove("CommunityGalleryImageId")
	}

	// ExactVersion
	destination.ExactVersion = genruntime.ClonePointerToString(reference.ExactVersion)

	// Id
	destination.Id = genruntime.ClonePointerToString(reference.Id)

	// Offer
	destination.Offer = genruntime.ClonePointerToString(reference.Offer)

	// Publisher
	destination.Publisher = genruntime.ClonePointerToString(reference.Publisher)

	// SharedGalleryImageId
	if reference.SharedGalleryImageId != nil {
		propertyBag.Add("SharedGalleryImageId", *reference.SharedGalleryImageId)
	} else {
		propertyBag.Remove("SharedGalleryImageId")
	}

	// Sku
	destination.Sku = genruntime.ClonePointerToString(reference.Sku)

	// Version
	destination.Version = genruntime.ClonePointerToString(reference.Version)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForImageReference_STATUS interface (if implemented) to customize the conversion
	var referenceAsAny any = reference
	if augmentedReference, ok := referenceAsAny.(augmentConversionForImageReference_STATUS); ok {
		err := augmentedReference.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.InstanceViewStatus_STATUS
// Deprecated version of InstanceViewStatus_STATUS. Use v1api20220301.InstanceViewStatus_STATUS instead
type InstanceViewStatus_STATUS struct {
	Code          *string                `json:"code,omitempty"`
	DisplayStatus *string                `json:"displayStatus,omitempty"`
	Level         *string                `json:"level,omitempty"`
	Message       *string                `json:"message,omitempty"`
	PropertyBag   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Time          *string                `json:"time,omitempty"`
}

// AssignProperties_From_InstanceViewStatus_STATUS populates our InstanceViewStatus_STATUS from the provided source InstanceViewStatus_STATUS
func (status *InstanceViewStatus_STATUS) AssignProperties_From_InstanceViewStatus_STATUS(source *v20201201s.InstanceViewStatus_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Code
	status.Code = genruntime.ClonePointerToString(source.Code)

	// DisplayStatus
	status.DisplayStatus = genruntime.ClonePointerToString(source.DisplayStatus)

	// Level
	status.Level = genruntime.ClonePointerToString(source.Level)

	// Message
	status.Message = genruntime.ClonePointerToString(source.Message)

	// Time
	status.Time = genruntime.ClonePointerToString(source.Time)

	// Update the property bag
	if len(propertyBag) > 0 {
		status.PropertyBag = propertyBag
	} else {
		status.PropertyBag = nil
	}

	// Invoke the augmentConversionForInstanceViewStatus_STATUS interface (if implemented) to customize the conversion
	var statusAsAny any = status
	if augmentedStatus, ok := statusAsAny.(augmentConversionForInstanceViewStatus_STATUS); ok {
		err := augmentedStatus.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_InstanceViewStatus_STATUS populates the provided destination InstanceViewStatus_STATUS from our InstanceViewStatus_STATUS
func (status *InstanceViewStatus_STATUS) AssignProperties_To_InstanceViewStatus_STATUS(destination *v20201201s.InstanceViewStatus_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(status.PropertyBag)

	// Code
	destination.Code = genruntime.ClonePointerToString(status.Code)

	// DisplayStatus
	destination.DisplayStatus = genruntime.ClonePointerToString(status.DisplayStatus)

	// Level
	destination.Level = genruntime.ClonePointerToString(status.Level)

	// Message
	destination.Message = genruntime.ClonePointerToString(status.Message)

	// Time
	destination.Time = genruntime.ClonePointerToString(status.Time)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForInstanceViewStatus_STATUS interface (if implemented) to customize the conversion
	var statusAsAny any = status
	if augmentedStatus, ok := statusAsAny.(augmentConversionForInstanceViewStatus_STATUS); ok {
		err := augmentedStatus.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.KeyVaultSecretReference_STATUS
// Deprecated version of KeyVaultSecretReference_STATUS. Use v1api20220301.KeyVaultSecretReference_STATUS instead
type KeyVaultSecretReference_STATUS struct {
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SecretUrl   *string                `json:"secretUrl,omitempty"`
	SourceVault *SubResource_STATUS    `json:"sourceVault,omitempty"`
}

// AssignProperties_From_KeyVaultSecretReference_STATUS populates our KeyVaultSecretReference_STATUS from the provided source KeyVaultSecretReference_STATUS
func (reference *KeyVaultSecretReference_STATUS) AssignProperties_From_KeyVaultSecretReference_STATUS(source *v20201201s.KeyVaultSecretReference_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// SecretUrl
	reference.SecretUrl = genruntime.ClonePointerToString(source.SecretUrl)

	// SourceVault
	if source.SourceVault != nil {
		var sourceVault SubResource_STATUS
		err := sourceVault.AssignProperties_From_SubResource_STATUS(source.SourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SourceVault")
		}
		reference.SourceVault = &sourceVault
	} else {
		reference.SourceVault = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		reference.PropertyBag = propertyBag
	} else {
		reference.PropertyBag = nil
	}

	// Invoke the augmentConversionForKeyVaultSecretReference_STATUS interface (if implemented) to customize the conversion
	var referenceAsAny any = reference
	if augmentedReference, ok := referenceAsAny.(augmentConversionForKeyVaultSecretReference_STATUS); ok {
		err := augmentedReference.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_KeyVaultSecretReference_STATUS populates the provided destination KeyVaultSecretReference_STATUS from our KeyVaultSecretReference_STATUS
func (reference *KeyVaultSecretReference_STATUS) AssignProperties_To_KeyVaultSecretReference_STATUS(destination *v20201201s.KeyVaultSecretReference_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(reference.PropertyBag)

	// SecretUrl
	destination.SecretUrl = genruntime.ClonePointerToString(reference.SecretUrl)

	// SourceVault
	if reference.SourceVault != nil {
		var sourceVault v20201201s.SubResource_STATUS
		err := reference.SourceVault.AssignProperties_To_SubResource_STATUS(&sourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SourceVault")
		}
		destination.SourceVault = &sourceVault
	} else {
		destination.SourceVault = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForKeyVaultSecretReference_STATUS interface (if implemented) to customize the conversion
	var referenceAsAny any = reference
	if augmentedReference, ok := referenceAsAny.(augmentConversionForKeyVaultSecretReference_STATUS); ok {
		err := augmentedReference.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.LinuxConfiguration
// Deprecated version of LinuxConfiguration. Use v1api20220301.LinuxConfiguration instead
type LinuxConfiguration struct {
	DisablePasswordAuthentication *bool                  `json:"disablePasswordAuthentication,omitempty"`
	PatchSettings                 *LinuxPatchSettings    `json:"patchSettings,omitempty"`
	PropertyBag                   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	ProvisionVMAgent              *bool                  `json:"provisionVMAgent,omitempty"`
	Ssh                           *SshConfiguration      `json:"ssh,omitempty"`
}

// AssignProperties_From_LinuxConfiguration populates our LinuxConfiguration from the provided source LinuxConfiguration
func (configuration *LinuxConfiguration) AssignProperties_From_LinuxConfiguration(source *v20201201s.LinuxConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DisablePasswordAuthentication
	if source.DisablePasswordAuthentication != nil {
		disablePasswordAuthentication := *source.DisablePasswordAuthentication
		configuration.DisablePasswordAuthentication = &disablePasswordAuthentication
	} else {
		configuration.DisablePasswordAuthentication = nil
	}

	// PatchSettings
	if source.PatchSettings != nil {
		var patchSetting LinuxPatchSettings
		err := patchSetting.AssignProperties_From_LinuxPatchSettings(source.PatchSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_LinuxPatchSettings() to populate field PatchSettings")
		}
		configuration.PatchSettings = &patchSetting
	} else {
		configuration.PatchSettings = nil
	}

	// ProvisionVMAgent
	if source.ProvisionVMAgent != nil {
		provisionVMAgent := *source.ProvisionVMAgent
		configuration.ProvisionVMAgent = &provisionVMAgent
	} else {
		configuration.ProvisionVMAgent = nil
	}

	// Ssh
	if source.Ssh != nil {
		var ssh SshConfiguration
		err := ssh.AssignProperties_From_SshConfiguration(source.Ssh)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SshConfiguration() to populate field Ssh")
		}
		configuration.Ssh = &ssh
	} else {
		configuration.Ssh = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// Invoke the augmentConversionForLinuxConfiguration interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForLinuxConfiguration); ok {
		err := augmentedConfiguration.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_LinuxConfiguration populates the provided destination LinuxConfiguration from our LinuxConfiguration
func (configuration *LinuxConfiguration) AssignProperties_To_LinuxConfiguration(destination *v20201201s.LinuxConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// DisablePasswordAuthentication
	if configuration.DisablePasswordAuthentication != nil {
		disablePasswordAuthentication := *configuration.DisablePasswordAuthentication
		destination.DisablePasswordAuthentication = &disablePasswordAuthentication
	} else {
		destination.DisablePasswordAuthentication = nil
	}

	// PatchSettings
	if configuration.PatchSettings != nil {
		var patchSetting v20201201s.LinuxPatchSettings
		err := configuration.PatchSettings.AssignProperties_To_LinuxPatchSettings(&patchSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_LinuxPatchSettings() to populate field PatchSettings")
		}
		destination.PatchSettings = &patchSetting
	} else {
		destination.PatchSettings = nil
	}

	// ProvisionVMAgent
	if configuration.ProvisionVMAgent != nil {
		provisionVMAgent := *configuration.ProvisionVMAgent
		destination.ProvisionVMAgent = &provisionVMAgent
	} else {
		destination.ProvisionVMAgent = nil
	}

	// Ssh
	if configuration.Ssh != nil {
		var ssh v20201201s.SshConfiguration
		err := configuration.Ssh.AssignProperties_To_SshConfiguration(&ssh)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SshConfiguration() to populate field Ssh")
		}
		destination.Ssh = &ssh
	} else {
		destination.Ssh = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForLinuxConfiguration interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForLinuxConfiguration); ok {
		err := augmentedConfiguration.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.LinuxConfiguration_STATUS
// Deprecated version of LinuxConfiguration_STATUS. Use v1api20220301.LinuxConfiguration_STATUS instead
type LinuxConfiguration_STATUS struct {
	DisablePasswordAuthentication *bool                      `json:"disablePasswordAuthentication,omitempty"`
	PatchSettings                 *LinuxPatchSettings_STATUS `json:"patchSettings,omitempty"`
	PropertyBag                   genruntime.PropertyBag     `json:"$propertyBag,omitempty"`
	ProvisionVMAgent              *bool                      `json:"provisionVMAgent,omitempty"`
	Ssh                           *SshConfiguration_STATUS   `json:"ssh,omitempty"`
}

// AssignProperties_From_LinuxConfiguration_STATUS populates our LinuxConfiguration_STATUS from the provided source LinuxConfiguration_STATUS
func (configuration *LinuxConfiguration_STATUS) AssignProperties_From_LinuxConfiguration_STATUS(source *v20201201s.LinuxConfiguration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DisablePasswordAuthentication
	if source.DisablePasswordAuthentication != nil {
		disablePasswordAuthentication := *source.DisablePasswordAuthentication
		configuration.DisablePasswordAuthentication = &disablePasswordAuthentication
	} else {
		configuration.DisablePasswordAuthentication = nil
	}

	// PatchSettings
	if source.PatchSettings != nil {
		var patchSetting LinuxPatchSettings_STATUS
		err := patchSetting.AssignProperties_From_LinuxPatchSettings_STATUS(source.PatchSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_LinuxPatchSettings_STATUS() to populate field PatchSettings")
		}
		configuration.PatchSettings = &patchSetting
	} else {
		configuration.PatchSettings = nil
	}

	// ProvisionVMAgent
	if source.ProvisionVMAgent != nil {
		provisionVMAgent := *source.ProvisionVMAgent
		configuration.ProvisionVMAgent = &provisionVMAgent
	} else {
		configuration.ProvisionVMAgent = nil
	}

	// Ssh
	if source.Ssh != nil {
		var ssh SshConfiguration_STATUS
		err := ssh.AssignProperties_From_SshConfiguration_STATUS(source.Ssh)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SshConfiguration_STATUS() to populate field Ssh")
		}
		configuration.Ssh = &ssh
	} else {
		configuration.Ssh = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// Invoke the augmentConversionForLinuxConfiguration_STATUS interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForLinuxConfiguration_STATUS); ok {
		err := augmentedConfiguration.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_LinuxConfiguration_STATUS populates the provided destination LinuxConfiguration_STATUS from our LinuxConfiguration_STATUS
func (configuration *LinuxConfiguration_STATUS) AssignProperties_To_LinuxConfiguration_STATUS(destination *v20201201s.LinuxConfiguration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// DisablePasswordAuthentication
	if configuration.DisablePasswordAuthentication != nil {
		disablePasswordAuthentication := *configuration.DisablePasswordAuthentication
		destination.DisablePasswordAuthentication = &disablePasswordAuthentication
	} else {
		destination.DisablePasswordAuthentication = nil
	}

	// PatchSettings
	if configuration.PatchSettings != nil {
		var patchSetting v20201201s.LinuxPatchSettings_STATUS
		err := configuration.PatchSettings.AssignProperties_To_LinuxPatchSettings_STATUS(&patchSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_LinuxPatchSettings_STATUS() to populate field PatchSettings")
		}
		destination.PatchSettings = &patchSetting
	} else {
		destination.PatchSettings = nil
	}

	// ProvisionVMAgent
	if configuration.ProvisionVMAgent != nil {
		provisionVMAgent := *configuration.ProvisionVMAgent
		destination.ProvisionVMAgent = &provisionVMAgent
	} else {
		destination.ProvisionVMAgent = nil
	}

	// Ssh
	if configuration.Ssh != nil {
		var ssh v20201201s.SshConfiguration_STATUS
		err := configuration.Ssh.AssignProperties_To_SshConfiguration_STATUS(&ssh)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SshConfiguration_STATUS() to populate field Ssh")
		}
		destination.Ssh = &ssh
	} else {
		destination.Ssh = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForLinuxConfiguration_STATUS interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForLinuxConfiguration_STATUS); ok {
		err := augmentedConfiguration.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.MaintenanceRedeployStatus_STATUS
// Deprecated version of MaintenanceRedeployStatus_STATUS. Use v1api20220301.MaintenanceRedeployStatus_STATUS instead
type MaintenanceRedeployStatus_STATUS struct {
	IsCustomerInitiatedMaintenanceAllowed *bool                  `json:"isCustomerInitiatedMaintenanceAllowed,omitempty"`
	LastOperationMessage                  *string                `json:"lastOperationMessage,omitempty"`
	LastOperationResultCode               *string                `json:"lastOperationResultCode,omitempty"`
	MaintenanceWindowEndTime              *string                `json:"maintenanceWindowEndTime,omitempty"`
	MaintenanceWindowStartTime            *string                `json:"maintenanceWindowStartTime,omitempty"`
	PreMaintenanceWindowEndTime           *string                `json:"preMaintenanceWindowEndTime,omitempty"`
	PreMaintenanceWindowStartTime         *string                `json:"preMaintenanceWindowStartTime,omitempty"`
	PropertyBag                           genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_MaintenanceRedeployStatus_STATUS populates our MaintenanceRedeployStatus_STATUS from the provided source MaintenanceRedeployStatus_STATUS
func (status *MaintenanceRedeployStatus_STATUS) AssignProperties_From_MaintenanceRedeployStatus_STATUS(source *v20201201s.MaintenanceRedeployStatus_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// IsCustomerInitiatedMaintenanceAllowed
	if source.IsCustomerInitiatedMaintenanceAllowed != nil {
		isCustomerInitiatedMaintenanceAllowed := *source.IsCustomerInitiatedMaintenanceAllowed
		status.IsCustomerInitiatedMaintenanceAllowed = &isCustomerInitiatedMaintenanceAllowed
	} else {
		status.IsCustomerInitiatedMaintenanceAllowed = nil
	}

	// LastOperationMessage
	status.LastOperationMessage = genruntime.ClonePointerToString(source.LastOperationMessage)

	// LastOperationResultCode
	status.LastOperationResultCode = genruntime.ClonePointerToString(source.LastOperationResultCode)

	// MaintenanceWindowEndTime
	status.MaintenanceWindowEndTime = genruntime.ClonePointerToString(source.MaintenanceWindowEndTime)

	// MaintenanceWindowStartTime
	status.MaintenanceWindowStartTime = genruntime.ClonePointerToString(source.MaintenanceWindowStartTime)

	// PreMaintenanceWindowEndTime
	status.PreMaintenanceWindowEndTime = genruntime.ClonePointerToString(source.PreMaintenanceWindowEndTime)

	// PreMaintenanceWindowStartTime
	status.PreMaintenanceWindowStartTime = genruntime.ClonePointerToString(source.PreMaintenanceWindowStartTime)

	// Update the property bag
	if len(propertyBag) > 0 {
		status.PropertyBag = propertyBag
	} else {
		status.PropertyBag = nil
	}

	// Invoke the augmentConversionForMaintenanceRedeployStatus_STATUS interface (if implemented) to customize the conversion
	var statusAsAny any = status
	if augmentedStatus, ok := statusAsAny.(augmentConversionForMaintenanceRedeployStatus_STATUS); ok {
		err := augmentedStatus.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_MaintenanceRedeployStatus_STATUS populates the provided destination MaintenanceRedeployStatus_STATUS from our MaintenanceRedeployStatus_STATUS
func (status *MaintenanceRedeployStatus_STATUS) AssignProperties_To_MaintenanceRedeployStatus_STATUS(destination *v20201201s.MaintenanceRedeployStatus_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(status.PropertyBag)

	// IsCustomerInitiatedMaintenanceAllowed
	if status.IsCustomerInitiatedMaintenanceAllowed != nil {
		isCustomerInitiatedMaintenanceAllowed := *status.IsCustomerInitiatedMaintenanceAllowed
		destination.IsCustomerInitiatedMaintenanceAllowed = &isCustomerInitiatedMaintenanceAllowed
	} else {
		destination.IsCustomerInitiatedMaintenanceAllowed = nil
	}

	// LastOperationMessage
	destination.LastOperationMessage = genruntime.ClonePointerToString(status.LastOperationMessage)

	// LastOperationResultCode
	destination.LastOperationResultCode = genruntime.ClonePointerToString(status.LastOperationResultCode)

	// MaintenanceWindowEndTime
	destination.MaintenanceWindowEndTime = genruntime.ClonePointerToString(status.MaintenanceWindowEndTime)

	// MaintenanceWindowStartTime
	destination.MaintenanceWindowStartTime = genruntime.ClonePointerToString(status.MaintenanceWindowStartTime)

	// PreMaintenanceWindowEndTime
	destination.PreMaintenanceWindowEndTime = genruntime.ClonePointerToString(status.PreMaintenanceWindowEndTime)

	// PreMaintenanceWindowStartTime
	destination.PreMaintenanceWindowStartTime = genruntime.ClonePointerToString(status.PreMaintenanceWindowStartTime)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForMaintenanceRedeployStatus_STATUS interface (if implemented) to customize the conversion
	var statusAsAny any = status
	if augmentedStatus, ok := statusAsAny.(augmentConversionForMaintenanceRedeployStatus_STATUS); ok {
		err := augmentedStatus.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.NetworkInterfaceReference
// Deprecated version of NetworkInterfaceReference. Use v1api20220301.NetworkInterfaceReference instead
type NetworkInterfaceReference struct {
	DeleteOption *string                       `json:"deleteOption,omitempty"`
	Primary      *bool                         `json:"primary,omitempty"`
	PropertyBag  genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
	Reference    *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

// AssignProperties_From_NetworkInterfaceReference populates our NetworkInterfaceReference from the provided source NetworkInterfaceReference
func (reference *NetworkInterfaceReference) AssignProperties_From_NetworkInterfaceReference(source *v20201201s.NetworkInterfaceReference) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DeleteOption
	if propertyBag.Contains("DeleteOption") {
		var deleteOption string
		err := propertyBag.Pull("DeleteOption", &deleteOption)
		if err != nil {
			return errors.Wrap(err, "pulling 'DeleteOption' from propertyBag")
		}

		reference.DeleteOption = &deleteOption
	} else {
		reference.DeleteOption = nil
	}

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		reference.Primary = &primary
	} else {
		reference.Primary = nil
	}

	// Reference
	if source.Reference != nil {
		referenceTemp := source.Reference.Copy()
		reference.Reference = &referenceTemp
	} else {
		reference.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		reference.PropertyBag = propertyBag
	} else {
		reference.PropertyBag = nil
	}

	// Invoke the augmentConversionForNetworkInterfaceReference interface (if implemented) to customize the conversion
	var referenceAsAny any = reference
	if augmentedReference, ok := referenceAsAny.(augmentConversionForNetworkInterfaceReference); ok {
		err := augmentedReference.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_NetworkInterfaceReference populates the provided destination NetworkInterfaceReference from our NetworkInterfaceReference
func (reference *NetworkInterfaceReference) AssignProperties_To_NetworkInterfaceReference(destination *v20201201s.NetworkInterfaceReference) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(reference.PropertyBag)

	// DeleteOption
	if reference.DeleteOption != nil {
		propertyBag.Add("DeleteOption", *reference.DeleteOption)
	} else {
		propertyBag.Remove("DeleteOption")
	}

	// Primary
	if reference.Primary != nil {
		primary := *reference.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// Reference
	if reference.Reference != nil {
		referenceTemp := reference.Reference.Copy()
		destination.Reference = &referenceTemp
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForNetworkInterfaceReference interface (if implemented) to customize the conversion
	var referenceAsAny any = reference
	if augmentedReference, ok := referenceAsAny.(augmentConversionForNetworkInterfaceReference); ok {
		err := augmentedReference.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.NetworkInterfaceReference_STATUS
// Deprecated version of NetworkInterfaceReference_STATUS. Use v1api20220301.NetworkInterfaceReference_STATUS instead
type NetworkInterfaceReference_STATUS struct {
	DeleteOption *string                `json:"deleteOption,omitempty"`
	Id           *string                `json:"id,omitempty"`
	Primary      *bool                  `json:"primary,omitempty"`
	PropertyBag  genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_NetworkInterfaceReference_STATUS populates our NetworkInterfaceReference_STATUS from the provided source NetworkInterfaceReference_STATUS
func (reference *NetworkInterfaceReference_STATUS) AssignProperties_From_NetworkInterfaceReference_STATUS(source *v20201201s.NetworkInterfaceReference_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DeleteOption
	if propertyBag.Contains("DeleteOption") {
		var deleteOption string
		err := propertyBag.Pull("DeleteOption", &deleteOption)
		if err != nil {
			return errors.Wrap(err, "pulling 'DeleteOption' from propertyBag")
		}

		reference.DeleteOption = &deleteOption
	} else {
		reference.DeleteOption = nil
	}

	// Id
	reference.Id = genruntime.ClonePointerToString(source.Id)

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		reference.Primary = &primary
	} else {
		reference.Primary = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		reference.PropertyBag = propertyBag
	} else {
		reference.PropertyBag = nil
	}

	// Invoke the augmentConversionForNetworkInterfaceReference_STATUS interface (if implemented) to customize the conversion
	var referenceAsAny any = reference
	if augmentedReference, ok := referenceAsAny.(augmentConversionForNetworkInterfaceReference_STATUS); ok {
		err := augmentedReference.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_NetworkInterfaceReference_STATUS populates the provided destination NetworkInterfaceReference_STATUS from our NetworkInterfaceReference_STATUS
func (reference *NetworkInterfaceReference_STATUS) AssignProperties_To_NetworkInterfaceReference_STATUS(destination *v20201201s.NetworkInterfaceReference_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(reference.PropertyBag)

	// DeleteOption
	if reference.DeleteOption != nil {
		propertyBag.Add("DeleteOption", *reference.DeleteOption)
	} else {
		propertyBag.Remove("DeleteOption")
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(reference.Id)

	// Primary
	if reference.Primary != nil {
		primary := *reference.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForNetworkInterfaceReference_STATUS interface (if implemented) to customize the conversion
	var referenceAsAny any = reference
	if augmentedReference, ok := referenceAsAny.(augmentConversionForNetworkInterfaceReference_STATUS); ok {
		err := augmentedReference.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.OSDisk
// Deprecated version of OSDisk. Use v1api20220301.OSDisk instead
type OSDisk struct {
	Caching                 *string                 `json:"caching,omitempty"`
	CreateOption            *string                 `json:"createOption,omitempty"`
	DeleteOption            *string                 `json:"deleteOption,omitempty"`
	DiffDiskSettings        *DiffDiskSettings       `json:"diffDiskSettings,omitempty"`
	DiskSizeGB              *int                    `json:"diskSizeGB,omitempty"`
	EncryptionSettings      *DiskEncryptionSettings `json:"encryptionSettings,omitempty"`
	Image                   *VirtualHardDisk        `json:"image,omitempty"`
	ManagedDisk             *ManagedDiskParameters  `json:"managedDisk,omitempty"`
	Name                    *string                 `json:"name,omitempty"`
	OsType                  *string                 `json:"osType,omitempty"`
	PropertyBag             genruntime.PropertyBag  `json:"$propertyBag,omitempty"`
	Vhd                     *VirtualHardDisk        `json:"vhd,omitempty"`
	WriteAcceleratorEnabled *bool                   `json:"writeAcceleratorEnabled,omitempty"`
}

// AssignProperties_From_OSDisk populates our OSDisk from the provided source OSDisk
func (disk *OSDisk) AssignProperties_From_OSDisk(source *v20201201s.OSDisk) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Caching
	disk.Caching = genruntime.ClonePointerToString(source.Caching)

	// CreateOption
	disk.CreateOption = genruntime.ClonePointerToString(source.CreateOption)

	// DeleteOption
	if propertyBag.Contains("DeleteOption") {
		var deleteOption string
		err := propertyBag.Pull("DeleteOption", &deleteOption)
		if err != nil {
			return errors.Wrap(err, "pulling 'DeleteOption' from propertyBag")
		}

		disk.DeleteOption = &deleteOption
	} else {
		disk.DeleteOption = nil
	}

	// DiffDiskSettings
	if source.DiffDiskSettings != nil {
		var diffDiskSetting DiffDiskSettings
		err := diffDiskSetting.AssignProperties_From_DiffDiskSettings(source.DiffDiskSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DiffDiskSettings() to populate field DiffDiskSettings")
		}
		disk.DiffDiskSettings = &diffDiskSetting
	} else {
		disk.DiffDiskSettings = nil
	}

	// DiskSizeGB
	disk.DiskSizeGB = genruntime.ClonePointerToInt(source.DiskSizeGB)

	// EncryptionSettings
	if source.EncryptionSettings != nil {
		var encryptionSetting DiskEncryptionSettings
		err := encryptionSetting.AssignProperties_From_DiskEncryptionSettings(source.EncryptionSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DiskEncryptionSettings() to populate field EncryptionSettings")
		}
		disk.EncryptionSettings = &encryptionSetting
	} else {
		disk.EncryptionSettings = nil
	}

	// Image
	if source.Image != nil {
		var image VirtualHardDisk
		err := image.AssignProperties_From_VirtualHardDisk(source.Image)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualHardDisk() to populate field Image")
		}
		disk.Image = &image
	} else {
		disk.Image = nil
	}

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk ManagedDiskParameters
		err := managedDisk.AssignProperties_From_ManagedDiskParameters(source.ManagedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedDiskParameters() to populate field ManagedDisk")
		}
		disk.ManagedDisk = &managedDisk
	} else {
		disk.ManagedDisk = nil
	}

	// Name
	disk.Name = genruntime.ClonePointerToString(source.Name)

	// OsType
	disk.OsType = genruntime.ClonePointerToString(source.OsType)

	// Vhd
	if source.Vhd != nil {
		var vhd VirtualHardDisk
		err := vhd.AssignProperties_From_VirtualHardDisk(source.Vhd)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualHardDisk() to populate field Vhd")
		}
		disk.Vhd = &vhd
	} else {
		disk.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if source.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *source.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		disk.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		disk.PropertyBag = propertyBag
	} else {
		disk.PropertyBag = nil
	}

	// Invoke the augmentConversionForOSDisk interface (if implemented) to customize the conversion
	var diskAsAny any = disk
	if augmentedDisk, ok := diskAsAny.(augmentConversionForOSDisk); ok {
		err := augmentedDisk.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_OSDisk populates the provided destination OSDisk from our OSDisk
func (disk *OSDisk) AssignProperties_To_OSDisk(destination *v20201201s.OSDisk) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(disk.PropertyBag)

	// Caching
	destination.Caching = genruntime.ClonePointerToString(disk.Caching)

	// CreateOption
	destination.CreateOption = genruntime.ClonePointerToString(disk.CreateOption)

	// DeleteOption
	if disk.DeleteOption != nil {
		propertyBag.Add("DeleteOption", *disk.DeleteOption)
	} else {
		propertyBag.Remove("DeleteOption")
	}

	// DiffDiskSettings
	if disk.DiffDiskSettings != nil {
		var diffDiskSetting v20201201s.DiffDiskSettings
		err := disk.DiffDiskSettings.AssignProperties_To_DiffDiskSettings(&diffDiskSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DiffDiskSettings() to populate field DiffDiskSettings")
		}
		destination.DiffDiskSettings = &diffDiskSetting
	} else {
		destination.DiffDiskSettings = nil
	}

	// DiskSizeGB
	destination.DiskSizeGB = genruntime.ClonePointerToInt(disk.DiskSizeGB)

	// EncryptionSettings
	if disk.EncryptionSettings != nil {
		var encryptionSetting v20201201s.DiskEncryptionSettings
		err := disk.EncryptionSettings.AssignProperties_To_DiskEncryptionSettings(&encryptionSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DiskEncryptionSettings() to populate field EncryptionSettings")
		}
		destination.EncryptionSettings = &encryptionSetting
	} else {
		destination.EncryptionSettings = nil
	}

	// Image
	if disk.Image != nil {
		var image v20201201s.VirtualHardDisk
		err := disk.Image.AssignProperties_To_VirtualHardDisk(&image)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualHardDisk() to populate field Image")
		}
		destination.Image = &image
	} else {
		destination.Image = nil
	}

	// ManagedDisk
	if disk.ManagedDisk != nil {
		var managedDisk v20201201s.ManagedDiskParameters
		err := disk.ManagedDisk.AssignProperties_To_ManagedDiskParameters(&managedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedDiskParameters() to populate field ManagedDisk")
		}
		destination.ManagedDisk = &managedDisk
	} else {
		destination.ManagedDisk = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(disk.Name)

	// OsType
	destination.OsType = genruntime.ClonePointerToString(disk.OsType)

	// Vhd
	if disk.Vhd != nil {
		var vhd v20201201s.VirtualHardDisk
		err := disk.Vhd.AssignProperties_To_VirtualHardDisk(&vhd)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualHardDisk() to populate field Vhd")
		}
		destination.Vhd = &vhd
	} else {
		destination.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if disk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *disk.WriteAcceleratorEnabled
		destination.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		destination.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForOSDisk interface (if implemented) to customize the conversion
	var diskAsAny any = disk
	if augmentedDisk, ok := diskAsAny.(augmentConversionForOSDisk); ok {
		err := augmentedDisk.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.OSDisk_STATUS
// Deprecated version of OSDisk_STATUS. Use v1api20220301.OSDisk_STATUS instead
type OSDisk_STATUS struct {
	Caching                 *string                        `json:"caching,omitempty"`
	CreateOption            *string                        `json:"createOption,omitempty"`
	DeleteOption            *string                        `json:"deleteOption,omitempty"`
	DiffDiskSettings        *DiffDiskSettings_STATUS       `json:"diffDiskSettings,omitempty"`
	DiskSizeGB              *int                           `json:"diskSizeGB,omitempty"`
	EncryptionSettings      *DiskEncryptionSettings_STATUS `json:"encryptionSettings,omitempty"`
	Image                   *VirtualHardDisk_STATUS        `json:"image,omitempty"`
	ManagedDisk             *ManagedDiskParameters_STATUS  `json:"managedDisk,omitempty"`
	Name                    *string                        `json:"name,omitempty"`
	OsType                  *string                        `json:"osType,omitempty"`
	PropertyBag             genruntime.PropertyBag         `json:"$propertyBag,omitempty"`
	Vhd                     *VirtualHardDisk_STATUS        `json:"vhd,omitempty"`
	WriteAcceleratorEnabled *bool                          `json:"writeAcceleratorEnabled,omitempty"`
}

// AssignProperties_From_OSDisk_STATUS populates our OSDisk_STATUS from the provided source OSDisk_STATUS
func (disk *OSDisk_STATUS) AssignProperties_From_OSDisk_STATUS(source *v20201201s.OSDisk_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Caching
	disk.Caching = genruntime.ClonePointerToString(source.Caching)

	// CreateOption
	disk.CreateOption = genruntime.ClonePointerToString(source.CreateOption)

	// DeleteOption
	if propertyBag.Contains("DeleteOption") {
		var deleteOption string
		err := propertyBag.Pull("DeleteOption", &deleteOption)
		if err != nil {
			return errors.Wrap(err, "pulling 'DeleteOption' from propertyBag")
		}

		disk.DeleteOption = &deleteOption
	} else {
		disk.DeleteOption = nil
	}

	// DiffDiskSettings
	if source.DiffDiskSettings != nil {
		var diffDiskSetting DiffDiskSettings_STATUS
		err := diffDiskSetting.AssignProperties_From_DiffDiskSettings_STATUS(source.DiffDiskSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DiffDiskSettings_STATUS() to populate field DiffDiskSettings")
		}
		disk.DiffDiskSettings = &diffDiskSetting
	} else {
		disk.DiffDiskSettings = nil
	}

	// DiskSizeGB
	disk.DiskSizeGB = genruntime.ClonePointerToInt(source.DiskSizeGB)

	// EncryptionSettings
	if source.EncryptionSettings != nil {
		var encryptionSetting DiskEncryptionSettings_STATUS
		err := encryptionSetting.AssignProperties_From_DiskEncryptionSettings_STATUS(source.EncryptionSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DiskEncryptionSettings_STATUS() to populate field EncryptionSettings")
		}
		disk.EncryptionSettings = &encryptionSetting
	} else {
		disk.EncryptionSettings = nil
	}

	// Image
	if source.Image != nil {
		var image VirtualHardDisk_STATUS
		err := image.AssignProperties_From_VirtualHardDisk_STATUS(source.Image)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualHardDisk_STATUS() to populate field Image")
		}
		disk.Image = &image
	} else {
		disk.Image = nil
	}

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk ManagedDiskParameters_STATUS
		err := managedDisk.AssignProperties_From_ManagedDiskParameters_STATUS(source.ManagedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedDiskParameters_STATUS() to populate field ManagedDisk")
		}
		disk.ManagedDisk = &managedDisk
	} else {
		disk.ManagedDisk = nil
	}

	// Name
	disk.Name = genruntime.ClonePointerToString(source.Name)

	// OsType
	disk.OsType = genruntime.ClonePointerToString(source.OsType)

	// Vhd
	if source.Vhd != nil {
		var vhd VirtualHardDisk_STATUS
		err := vhd.AssignProperties_From_VirtualHardDisk_STATUS(source.Vhd)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualHardDisk_STATUS() to populate field Vhd")
		}
		disk.Vhd = &vhd
	} else {
		disk.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if source.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *source.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		disk.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		disk.PropertyBag = propertyBag
	} else {
		disk.PropertyBag = nil
	}

	// Invoke the augmentConversionForOSDisk_STATUS interface (if implemented) to customize the conversion
	var diskAsAny any = disk
	if augmentedDisk, ok := diskAsAny.(augmentConversionForOSDisk_STATUS); ok {
		err := augmentedDisk.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_OSDisk_STATUS populates the provided destination OSDisk_STATUS from our OSDisk_STATUS
func (disk *OSDisk_STATUS) AssignProperties_To_OSDisk_STATUS(destination *v20201201s.OSDisk_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(disk.PropertyBag)

	// Caching
	destination.Caching = genruntime.ClonePointerToString(disk.Caching)

	// CreateOption
	destination.CreateOption = genruntime.ClonePointerToString(disk.CreateOption)

	// DeleteOption
	if disk.DeleteOption != nil {
		propertyBag.Add("DeleteOption", *disk.DeleteOption)
	} else {
		propertyBag.Remove("DeleteOption")
	}

	// DiffDiskSettings
	if disk.DiffDiskSettings != nil {
		var diffDiskSetting v20201201s.DiffDiskSettings_STATUS
		err := disk.DiffDiskSettings.AssignProperties_To_DiffDiskSettings_STATUS(&diffDiskSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DiffDiskSettings_STATUS() to populate field DiffDiskSettings")
		}
		destination.DiffDiskSettings = &diffDiskSetting
	} else {
		destination.DiffDiskSettings = nil
	}

	// DiskSizeGB
	destination.DiskSizeGB = genruntime.ClonePointerToInt(disk.DiskSizeGB)

	// EncryptionSettings
	if disk.EncryptionSettings != nil {
		var encryptionSetting v20201201s.DiskEncryptionSettings_STATUS
		err := disk.EncryptionSettings.AssignProperties_To_DiskEncryptionSettings_STATUS(&encryptionSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DiskEncryptionSettings_STATUS() to populate field EncryptionSettings")
		}
		destination.EncryptionSettings = &encryptionSetting
	} else {
		destination.EncryptionSettings = nil
	}

	// Image
	if disk.Image != nil {
		var image v20201201s.VirtualHardDisk_STATUS
		err := disk.Image.AssignProperties_To_VirtualHardDisk_STATUS(&image)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualHardDisk_STATUS() to populate field Image")
		}
		destination.Image = &image
	} else {
		destination.Image = nil
	}

	// ManagedDisk
	if disk.ManagedDisk != nil {
		var managedDisk v20201201s.ManagedDiskParameters_STATUS
		err := disk.ManagedDisk.AssignProperties_To_ManagedDiskParameters_STATUS(&managedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedDiskParameters_STATUS() to populate field ManagedDisk")
		}
		destination.ManagedDisk = &managedDisk
	} else {
		destination.ManagedDisk = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(disk.Name)

	// OsType
	destination.OsType = genruntime.ClonePointerToString(disk.OsType)

	// Vhd
	if disk.Vhd != nil {
		var vhd v20201201s.VirtualHardDisk_STATUS
		err := disk.Vhd.AssignProperties_To_VirtualHardDisk_STATUS(&vhd)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualHardDisk_STATUS() to populate field Vhd")
		}
		destination.Vhd = &vhd
	} else {
		destination.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if disk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *disk.WriteAcceleratorEnabled
		destination.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		destination.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForOSDisk_STATUS interface (if implemented) to customize the conversion
	var diskAsAny any = disk
	if augmentedDisk, ok := diskAsAny.(augmentConversionForOSDisk_STATUS); ok {
		err := augmentedDisk.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.TerminateNotificationProfile
// Deprecated version of TerminateNotificationProfile. Use v1api20220301.TerminateNotificationProfile instead
type TerminateNotificationProfile struct {
	Enable           *bool                  `json:"enable,omitempty"`
	NotBeforeTimeout *string                `json:"notBeforeTimeout,omitempty"`
	PropertyBag      genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_TerminateNotificationProfile populates our TerminateNotificationProfile from the provided source TerminateNotificationProfile
func (profile *TerminateNotificationProfile) AssignProperties_From_TerminateNotificationProfile(source *v20201201s.TerminateNotificationProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Enable
	if source.Enable != nil {
		enable := *source.Enable
		profile.Enable = &enable
	} else {
		profile.Enable = nil
	}

	// NotBeforeTimeout
	profile.NotBeforeTimeout = genruntime.ClonePointerToString(source.NotBeforeTimeout)

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForTerminateNotificationProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForTerminateNotificationProfile); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_TerminateNotificationProfile populates the provided destination TerminateNotificationProfile from our TerminateNotificationProfile
func (profile *TerminateNotificationProfile) AssignProperties_To_TerminateNotificationProfile(destination *v20201201s.TerminateNotificationProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// Enable
	if profile.Enable != nil {
		enable := *profile.Enable
		destination.Enable = &enable
	} else {
		destination.Enable = nil
	}

	// NotBeforeTimeout
	destination.NotBeforeTimeout = genruntime.ClonePointerToString(profile.NotBeforeTimeout)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForTerminateNotificationProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForTerminateNotificationProfile); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.TerminateNotificationProfile_STATUS
// Deprecated version of TerminateNotificationProfile_STATUS. Use v1api20220301.TerminateNotificationProfile_STATUS instead
type TerminateNotificationProfile_STATUS struct {
	Enable           *bool                  `json:"enable,omitempty"`
	NotBeforeTimeout *string                `json:"notBeforeTimeout,omitempty"`
	PropertyBag      genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_TerminateNotificationProfile_STATUS populates our TerminateNotificationProfile_STATUS from the provided source TerminateNotificationProfile_STATUS
func (profile *TerminateNotificationProfile_STATUS) AssignProperties_From_TerminateNotificationProfile_STATUS(source *v20201201s.TerminateNotificationProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Enable
	if source.Enable != nil {
		enable := *source.Enable
		profile.Enable = &enable
	} else {
		profile.Enable = nil
	}

	// NotBeforeTimeout
	profile.NotBeforeTimeout = genruntime.ClonePointerToString(source.NotBeforeTimeout)

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForTerminateNotificationProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForTerminateNotificationProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_TerminateNotificationProfile_STATUS populates the provided destination TerminateNotificationProfile_STATUS from our TerminateNotificationProfile_STATUS
func (profile *TerminateNotificationProfile_STATUS) AssignProperties_To_TerminateNotificationProfile_STATUS(destination *v20201201s.TerminateNotificationProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// Enable
	if profile.Enable != nil {
		enable := *profile.Enable
		destination.Enable = &enable
	} else {
		destination.Enable = nil
	}

	// NotBeforeTimeout
	destination.NotBeforeTimeout = genruntime.ClonePointerToString(profile.NotBeforeTimeout)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForTerminateNotificationProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForTerminateNotificationProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.UefiSettings
// Deprecated version of UefiSettings. Use v1api20220301.UefiSettings instead
type UefiSettings struct {
	PropertyBag       genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SecureBootEnabled *bool                  `json:"secureBootEnabled,omitempty"`
	VTpmEnabled       *bool                  `json:"vTpmEnabled,omitempty"`
}

// AssignProperties_From_UefiSettings populates our UefiSettings from the provided source UefiSettings
func (settings *UefiSettings) AssignProperties_From_UefiSettings(source *v20201201s.UefiSettings) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// SecureBootEnabled
	if source.SecureBootEnabled != nil {
		secureBootEnabled := *source.SecureBootEnabled
		settings.SecureBootEnabled = &secureBootEnabled
	} else {
		settings.SecureBootEnabled = nil
	}

	// VTpmEnabled
	if source.VTpmEnabled != nil {
		vTpmEnabled := *source.VTpmEnabled
		settings.VTpmEnabled = &vTpmEnabled
	} else {
		settings.VTpmEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// Invoke the augmentConversionForUefiSettings interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForUefiSettings); ok {
		err := augmentedSettings.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UefiSettings populates the provided destination UefiSettings from our UefiSettings
func (settings *UefiSettings) AssignProperties_To_UefiSettings(destination *v20201201s.UefiSettings) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// SecureBootEnabled
	if settings.SecureBootEnabled != nil {
		secureBootEnabled := *settings.SecureBootEnabled
		destination.SecureBootEnabled = &secureBootEnabled
	} else {
		destination.SecureBootEnabled = nil
	}

	// VTpmEnabled
	if settings.VTpmEnabled != nil {
		vTpmEnabled := *settings.VTpmEnabled
		destination.VTpmEnabled = &vTpmEnabled
	} else {
		destination.VTpmEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUefiSettings interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForUefiSettings); ok {
		err := augmentedSettings.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.UefiSettings_STATUS
// Deprecated version of UefiSettings_STATUS. Use v1api20220301.UefiSettings_STATUS instead
type UefiSettings_STATUS struct {
	PropertyBag       genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SecureBootEnabled *bool                  `json:"secureBootEnabled,omitempty"`
	VTpmEnabled       *bool                  `json:"vTpmEnabled,omitempty"`
}

// AssignProperties_From_UefiSettings_STATUS populates our UefiSettings_STATUS from the provided source UefiSettings_STATUS
func (settings *UefiSettings_STATUS) AssignProperties_From_UefiSettings_STATUS(source *v20201201s.UefiSettings_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// SecureBootEnabled
	if source.SecureBootEnabled != nil {
		secureBootEnabled := *source.SecureBootEnabled
		settings.SecureBootEnabled = &secureBootEnabled
	} else {
		settings.SecureBootEnabled = nil
	}

	// VTpmEnabled
	if source.VTpmEnabled != nil {
		vTpmEnabled := *source.VTpmEnabled
		settings.VTpmEnabled = &vTpmEnabled
	} else {
		settings.VTpmEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// Invoke the augmentConversionForUefiSettings_STATUS interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForUefiSettings_STATUS); ok {
		err := augmentedSettings.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UefiSettings_STATUS populates the provided destination UefiSettings_STATUS from our UefiSettings_STATUS
func (settings *UefiSettings_STATUS) AssignProperties_To_UefiSettings_STATUS(destination *v20201201s.UefiSettings_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// SecureBootEnabled
	if settings.SecureBootEnabled != nil {
		secureBootEnabled := *settings.SecureBootEnabled
		destination.SecureBootEnabled = &secureBootEnabled
	} else {
		destination.SecureBootEnabled = nil
	}

	// VTpmEnabled
	if settings.VTpmEnabled != nil {
		vTpmEnabled := *settings.VTpmEnabled
		destination.VTpmEnabled = &vTpmEnabled
	} else {
		destination.VTpmEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUefiSettings_STATUS interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForUefiSettings_STATUS); ok {
		err := augmentedSettings.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.UserAssignedIdentityDetails
// Deprecated version of UserAssignedIdentityDetails. Use v1api20220301.UserAssignedIdentityDetails instead
type UserAssignedIdentityDetails struct {
	PropertyBag genruntime.PropertyBag       `json:"$propertyBag,omitempty"`
	Reference   genruntime.ResourceReference `armReference:"Reference" json:"reference,omitempty"`
}

// AssignProperties_From_UserAssignedIdentityDetails populates our UserAssignedIdentityDetails from the provided source UserAssignedIdentityDetails
func (details *UserAssignedIdentityDetails) AssignProperties_From_UserAssignedIdentityDetails(source *v20201201s.UserAssignedIdentityDetails) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Reference
	details.Reference = source.Reference.Copy()

	// Update the property bag
	if len(propertyBag) > 0 {
		details.PropertyBag = propertyBag
	} else {
		details.PropertyBag = nil
	}

	// Invoke the augmentConversionForUserAssignedIdentityDetails interface (if implemented) to customize the conversion
	var detailsAsAny any = details
	if augmentedDetails, ok := detailsAsAny.(augmentConversionForUserAssignedIdentityDetails); ok {
		err := augmentedDetails.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UserAssignedIdentityDetails populates the provided destination UserAssignedIdentityDetails from our UserAssignedIdentityDetails
func (details *UserAssignedIdentityDetails) AssignProperties_To_UserAssignedIdentityDetails(destination *v20201201s.UserAssignedIdentityDetails) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(details.PropertyBag)

	// Reference
	destination.Reference = details.Reference.Copy()

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUserAssignedIdentityDetails interface (if implemented) to customize the conversion
	var detailsAsAny any = details
	if augmentedDetails, ok := detailsAsAny.(augmentConversionForUserAssignedIdentityDetails); ok {
		err := augmentedDetails.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.VaultSecretGroup
// Deprecated version of VaultSecretGroup. Use v1api20220301.VaultSecretGroup instead
type VaultSecretGroup struct {
	PropertyBag       genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SourceVault       *SubResource           `json:"sourceVault,omitempty"`
	VaultCertificates []VaultCertificate     `json:"vaultCertificates,omitempty"`
}

// AssignProperties_From_VaultSecretGroup populates our VaultSecretGroup from the provided source VaultSecretGroup
func (group *VaultSecretGroup) AssignProperties_From_VaultSecretGroup(source *v20201201s.VaultSecretGroup) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// SourceVault
	if source.SourceVault != nil {
		var sourceVault SubResource
		err := sourceVault.AssignProperties_From_SubResource(source.SourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SourceVault")
		}
		group.SourceVault = &sourceVault
	} else {
		group.SourceVault = nil
	}

	// VaultCertificates
	if source.VaultCertificates != nil {
		vaultCertificateList := make([]VaultCertificate, len(source.VaultCertificates))
		for vaultCertificateIndex, vaultCertificateItem := range source.VaultCertificates {
			// Shadow the loop variable to avoid aliasing
			vaultCertificateItem := vaultCertificateItem
			var vaultCertificate VaultCertificate
			err := vaultCertificate.AssignProperties_From_VaultCertificate(&vaultCertificateItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VaultCertificate() to populate field VaultCertificates")
			}
			vaultCertificateList[vaultCertificateIndex] = vaultCertificate
		}
		group.VaultCertificates = vaultCertificateList
	} else {
		group.VaultCertificates = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		group.PropertyBag = propertyBag
	} else {
		group.PropertyBag = nil
	}

	// Invoke the augmentConversionForVaultSecretGroup interface (if implemented) to customize the conversion
	var groupAsAny any = group
	if augmentedGroup, ok := groupAsAny.(augmentConversionForVaultSecretGroup); ok {
		err := augmentedGroup.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VaultSecretGroup populates the provided destination VaultSecretGroup from our VaultSecretGroup
func (group *VaultSecretGroup) AssignProperties_To_VaultSecretGroup(destination *v20201201s.VaultSecretGroup) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(group.PropertyBag)

	// SourceVault
	if group.SourceVault != nil {
		var sourceVault v20201201s.SubResource
		err := group.SourceVault.AssignProperties_To_SubResource(&sourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SourceVault")
		}
		destination.SourceVault = &sourceVault
	} else {
		destination.SourceVault = nil
	}

	// VaultCertificates
	if group.VaultCertificates != nil {
		vaultCertificateList := make([]v20201201s.VaultCertificate, len(group.VaultCertificates))
		for vaultCertificateIndex, vaultCertificateItem := range group.VaultCertificates {
			// Shadow the loop variable to avoid aliasing
			vaultCertificateItem := vaultCertificateItem
			var vaultCertificate v20201201s.VaultCertificate
			err := vaultCertificateItem.AssignProperties_To_VaultCertificate(&vaultCertificate)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VaultCertificate() to populate field VaultCertificates")
			}
			vaultCertificateList[vaultCertificateIndex] = vaultCertificate
		}
		destination.VaultCertificates = vaultCertificateList
	} else {
		destination.VaultCertificates = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVaultSecretGroup interface (if implemented) to customize the conversion
	var groupAsAny any = group
	if augmentedGroup, ok := groupAsAny.(augmentConversionForVaultSecretGroup); ok {
		err := augmentedGroup.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.VaultSecretGroup_STATUS
// Deprecated version of VaultSecretGroup_STATUS. Use v1api20220301.VaultSecretGroup_STATUS instead
type VaultSecretGroup_STATUS struct {
	PropertyBag       genruntime.PropertyBag    `json:"$propertyBag,omitempty"`
	SourceVault       *SubResource_STATUS       `json:"sourceVault,omitempty"`
	VaultCertificates []VaultCertificate_STATUS `json:"vaultCertificates,omitempty"`
}

// AssignProperties_From_VaultSecretGroup_STATUS populates our VaultSecretGroup_STATUS from the provided source VaultSecretGroup_STATUS
func (group *VaultSecretGroup_STATUS) AssignProperties_From_VaultSecretGroup_STATUS(source *v20201201s.VaultSecretGroup_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// SourceVault
	if source.SourceVault != nil {
		var sourceVault SubResource_STATUS
		err := sourceVault.AssignProperties_From_SubResource_STATUS(source.SourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SourceVault")
		}
		group.SourceVault = &sourceVault
	} else {
		group.SourceVault = nil
	}

	// VaultCertificates
	if source.VaultCertificates != nil {
		vaultCertificateList := make([]VaultCertificate_STATUS, len(source.VaultCertificates))
		for vaultCertificateIndex, vaultCertificateItem := range source.VaultCertificates {
			// Shadow the loop variable to avoid aliasing
			vaultCertificateItem := vaultCertificateItem
			var vaultCertificate VaultCertificate_STATUS
			err := vaultCertificate.AssignProperties_From_VaultCertificate_STATUS(&vaultCertificateItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VaultCertificate_STATUS() to populate field VaultCertificates")
			}
			vaultCertificateList[vaultCertificateIndex] = vaultCertificate
		}
		group.VaultCertificates = vaultCertificateList
	} else {
		group.VaultCertificates = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		group.PropertyBag = propertyBag
	} else {
		group.PropertyBag = nil
	}

	// Invoke the augmentConversionForVaultSecretGroup_STATUS interface (if implemented) to customize the conversion
	var groupAsAny any = group
	if augmentedGroup, ok := groupAsAny.(augmentConversionForVaultSecretGroup_STATUS); ok {
		err := augmentedGroup.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VaultSecretGroup_STATUS populates the provided destination VaultSecretGroup_STATUS from our VaultSecretGroup_STATUS
func (group *VaultSecretGroup_STATUS) AssignProperties_To_VaultSecretGroup_STATUS(destination *v20201201s.VaultSecretGroup_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(group.PropertyBag)

	// SourceVault
	if group.SourceVault != nil {
		var sourceVault v20201201s.SubResource_STATUS
		err := group.SourceVault.AssignProperties_To_SubResource_STATUS(&sourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SourceVault")
		}
		destination.SourceVault = &sourceVault
	} else {
		destination.SourceVault = nil
	}

	// VaultCertificates
	if group.VaultCertificates != nil {
		vaultCertificateList := make([]v20201201s.VaultCertificate_STATUS, len(group.VaultCertificates))
		for vaultCertificateIndex, vaultCertificateItem := range group.VaultCertificates {
			// Shadow the loop variable to avoid aliasing
			vaultCertificateItem := vaultCertificateItem
			var vaultCertificate v20201201s.VaultCertificate_STATUS
			err := vaultCertificateItem.AssignProperties_To_VaultCertificate_STATUS(&vaultCertificate)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VaultCertificate_STATUS() to populate field VaultCertificates")
			}
			vaultCertificateList[vaultCertificateIndex] = vaultCertificate
		}
		destination.VaultCertificates = vaultCertificateList
	} else {
		destination.VaultCertificates = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVaultSecretGroup_STATUS interface (if implemented) to customize the conversion
	var groupAsAny any = group
	if augmentedGroup, ok := groupAsAny.(augmentConversionForVaultSecretGroup_STATUS); ok {
		err := augmentedGroup.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.VirtualMachineAgentInstanceView_STATUS
// Deprecated version of VirtualMachineAgentInstanceView_STATUS. Use v1api20220301.VirtualMachineAgentInstanceView_STATUS instead
type VirtualMachineAgentInstanceView_STATUS struct {
	ExtensionHandlers []VirtualMachineExtensionHandlerInstanceView_STATUS `json:"extensionHandlers,omitempty"`
	PropertyBag       genruntime.PropertyBag                              `json:"$propertyBag,omitempty"`
	Statuses          []InstanceViewStatus_STATUS                         `json:"statuses,omitempty"`
	VmAgentVersion    *string                                             `json:"vmAgentVersion,omitempty"`
}

// AssignProperties_From_VirtualMachineAgentInstanceView_STATUS populates our VirtualMachineAgentInstanceView_STATUS from the provided source VirtualMachineAgentInstanceView_STATUS
func (view *VirtualMachineAgentInstanceView_STATUS) AssignProperties_From_VirtualMachineAgentInstanceView_STATUS(source *v20201201s.VirtualMachineAgentInstanceView_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ExtensionHandlers
	if source.ExtensionHandlers != nil {
		extensionHandlerList := make([]VirtualMachineExtensionHandlerInstanceView_STATUS, len(source.ExtensionHandlers))
		for extensionHandlerIndex, extensionHandlerItem := range source.ExtensionHandlers {
			// Shadow the loop variable to avoid aliasing
			extensionHandlerItem := extensionHandlerItem
			var extensionHandler VirtualMachineExtensionHandlerInstanceView_STATUS
			err := extensionHandler.AssignProperties_From_VirtualMachineExtensionHandlerInstanceView_STATUS(&extensionHandlerItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineExtensionHandlerInstanceView_STATUS() to populate field ExtensionHandlers")
			}
			extensionHandlerList[extensionHandlerIndex] = extensionHandler
		}
		view.ExtensionHandlers = extensionHandlerList
	} else {
		view.ExtensionHandlers = nil
	}

	// Statuses
	if source.Statuses != nil {
		statusList := make([]InstanceViewStatus_STATUS, len(source.Statuses))
		for statusIndex, statusItem := range source.Statuses {
			// Shadow the loop variable to avoid aliasing
			statusItem := statusItem
			var status InstanceViewStatus_STATUS
			err := status.AssignProperties_From_InstanceViewStatus_STATUS(&statusItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_InstanceViewStatus_STATUS() to populate field Statuses")
			}
			statusList[statusIndex] = status
		}
		view.Statuses = statusList
	} else {
		view.Statuses = nil
	}

	// VmAgentVersion
	view.VmAgentVersion = genruntime.ClonePointerToString(source.VmAgentVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		view.PropertyBag = propertyBag
	} else {
		view.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineAgentInstanceView_STATUS interface (if implemented) to customize the conversion
	var viewAsAny any = view
	if augmentedView, ok := viewAsAny.(augmentConversionForVirtualMachineAgentInstanceView_STATUS); ok {
		err := augmentedView.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineAgentInstanceView_STATUS populates the provided destination VirtualMachineAgentInstanceView_STATUS from our VirtualMachineAgentInstanceView_STATUS
func (view *VirtualMachineAgentInstanceView_STATUS) AssignProperties_To_VirtualMachineAgentInstanceView_STATUS(destination *v20201201s.VirtualMachineAgentInstanceView_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(view.PropertyBag)

	// ExtensionHandlers
	if view.ExtensionHandlers != nil {
		extensionHandlerList := make([]v20201201s.VirtualMachineExtensionHandlerInstanceView_STATUS, len(view.ExtensionHandlers))
		for extensionHandlerIndex, extensionHandlerItem := range view.ExtensionHandlers {
			// Shadow the loop variable to avoid aliasing
			extensionHandlerItem := extensionHandlerItem
			var extensionHandler v20201201s.VirtualMachineExtensionHandlerInstanceView_STATUS
			err := extensionHandlerItem.AssignProperties_To_VirtualMachineExtensionHandlerInstanceView_STATUS(&extensionHandler)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineExtensionHandlerInstanceView_STATUS() to populate field ExtensionHandlers")
			}
			extensionHandlerList[extensionHandlerIndex] = extensionHandler
		}
		destination.ExtensionHandlers = extensionHandlerList
	} else {
		destination.ExtensionHandlers = nil
	}

	// Statuses
	if view.Statuses != nil {
		statusList := make([]v20201201s.InstanceViewStatus_STATUS, len(view.Statuses))
		for statusIndex, statusItem := range view.Statuses {
			// Shadow the loop variable to avoid aliasing
			statusItem := statusItem
			var status v20201201s.InstanceViewStatus_STATUS
			err := statusItem.AssignProperties_To_InstanceViewStatus_STATUS(&status)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_InstanceViewStatus_STATUS() to populate field Statuses")
			}
			statusList[statusIndex] = status
		}
		destination.Statuses = statusList
	} else {
		destination.Statuses = nil
	}

	// VmAgentVersion
	destination.VmAgentVersion = genruntime.ClonePointerToString(view.VmAgentVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineAgentInstanceView_STATUS interface (if implemented) to customize the conversion
	var viewAsAny any = view
	if augmentedView, ok := viewAsAny.(augmentConversionForVirtualMachineAgentInstanceView_STATUS); ok {
		err := augmentedView.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.VirtualMachineExtensionInstanceView_STATUS
// Deprecated version of VirtualMachineExtensionInstanceView_STATUS. Use v1api20220301.VirtualMachineExtensionInstanceView_STATUS instead
type VirtualMachineExtensionInstanceView_STATUS struct {
	Name               *string                     `json:"name,omitempty"`
	PropertyBag        genruntime.PropertyBag      `json:"$propertyBag,omitempty"`
	Statuses           []InstanceViewStatus_STATUS `json:"statuses,omitempty"`
	Substatuses        []InstanceViewStatus_STATUS `json:"substatuses,omitempty"`
	Type               *string                     `json:"type,omitempty"`
	TypeHandlerVersion *string                     `json:"typeHandlerVersion,omitempty"`
}

// AssignProperties_From_VirtualMachineExtensionInstanceView_STATUS populates our VirtualMachineExtensionInstanceView_STATUS from the provided source VirtualMachineExtensionInstanceView_STATUS
func (view *VirtualMachineExtensionInstanceView_STATUS) AssignProperties_From_VirtualMachineExtensionInstanceView_STATUS(source *v20201201s.VirtualMachineExtensionInstanceView_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	view.Name = genruntime.ClonePointerToString(source.Name)

	// Statuses
	if source.Statuses != nil {
		statusList := make([]InstanceViewStatus_STATUS, len(source.Statuses))
		for statusIndex, statusItem := range source.Statuses {
			// Shadow the loop variable to avoid aliasing
			statusItem := statusItem
			var status InstanceViewStatus_STATUS
			err := status.AssignProperties_From_InstanceViewStatus_STATUS(&statusItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_InstanceViewStatus_STATUS() to populate field Statuses")
			}
			statusList[statusIndex] = status
		}
		view.Statuses = statusList
	} else {
		view.Statuses = nil
	}

	// Substatuses
	if source.Substatuses != nil {
		substatusList := make([]InstanceViewStatus_STATUS, len(source.Substatuses))
		for substatusIndex, substatusItem := range source.Substatuses {
			// Shadow the loop variable to avoid aliasing
			substatusItem := substatusItem
			var substatus InstanceViewStatus_STATUS
			err := substatus.AssignProperties_From_InstanceViewStatus_STATUS(&substatusItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_InstanceViewStatus_STATUS() to populate field Substatuses")
			}
			substatusList[substatusIndex] = substatus
		}
		view.Substatuses = substatusList
	} else {
		view.Substatuses = nil
	}

	// Type
	view.Type = genruntime.ClonePointerToString(source.Type)

	// TypeHandlerVersion
	view.TypeHandlerVersion = genruntime.ClonePointerToString(source.TypeHandlerVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		view.PropertyBag = propertyBag
	} else {
		view.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineExtensionInstanceView_STATUS interface (if implemented) to customize the conversion
	var viewAsAny any = view
	if augmentedView, ok := viewAsAny.(augmentConversionForVirtualMachineExtensionInstanceView_STATUS); ok {
		err := augmentedView.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineExtensionInstanceView_STATUS populates the provided destination VirtualMachineExtensionInstanceView_STATUS from our VirtualMachineExtensionInstanceView_STATUS
func (view *VirtualMachineExtensionInstanceView_STATUS) AssignProperties_To_VirtualMachineExtensionInstanceView_STATUS(destination *v20201201s.VirtualMachineExtensionInstanceView_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(view.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(view.Name)

	// Statuses
	if view.Statuses != nil {
		statusList := make([]v20201201s.InstanceViewStatus_STATUS, len(view.Statuses))
		for statusIndex, statusItem := range view.Statuses {
			// Shadow the loop variable to avoid aliasing
			statusItem := statusItem
			var status v20201201s.InstanceViewStatus_STATUS
			err := statusItem.AssignProperties_To_InstanceViewStatus_STATUS(&status)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_InstanceViewStatus_STATUS() to populate field Statuses")
			}
			statusList[statusIndex] = status
		}
		destination.Statuses = statusList
	} else {
		destination.Statuses = nil
	}

	// Substatuses
	if view.Substatuses != nil {
		substatusList := make([]v20201201s.InstanceViewStatus_STATUS, len(view.Substatuses))
		for substatusIndex, substatusItem := range view.Substatuses {
			// Shadow the loop variable to avoid aliasing
			substatusItem := substatusItem
			var substatus v20201201s.InstanceViewStatus_STATUS
			err := substatusItem.AssignProperties_To_InstanceViewStatus_STATUS(&substatus)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_InstanceViewStatus_STATUS() to populate field Substatuses")
			}
			substatusList[substatusIndex] = substatus
		}
		destination.Substatuses = substatusList
	} else {
		destination.Substatuses = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(view.Type)

	// TypeHandlerVersion
	destination.TypeHandlerVersion = genruntime.ClonePointerToString(view.TypeHandlerVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineExtensionInstanceView_STATUS interface (if implemented) to customize the conversion
	var viewAsAny any = view
	if augmentedView, ok := viewAsAny.(augmentConversionForVirtualMachineExtensionInstanceView_STATUS); ok {
		err := augmentedView.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.VirtualMachineHealthStatus_STATUS
// Deprecated version of VirtualMachineHealthStatus_STATUS. Use v1api20220301.VirtualMachineHealthStatus_STATUS instead
type VirtualMachineHealthStatus_STATUS struct {
	PropertyBag genruntime.PropertyBag     `json:"$propertyBag,omitempty"`
	Status      *InstanceViewStatus_STATUS `json:"status,omitempty"`
}

// AssignProperties_From_VirtualMachineHealthStatus_STATUS populates our VirtualMachineHealthStatus_STATUS from the provided source VirtualMachineHealthStatus_STATUS
func (status *VirtualMachineHealthStatus_STATUS) AssignProperties_From_VirtualMachineHealthStatus_STATUS(source *v20201201s.VirtualMachineHealthStatus_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Status
	if source.Status != nil {
		var statusLocal InstanceViewStatus_STATUS
		err := statusLocal.AssignProperties_From_InstanceViewStatus_STATUS(source.Status)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_InstanceViewStatus_STATUS() to populate field Status")
		}
		status.Status = &statusLocal
	} else {
		status.Status = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		status.PropertyBag = propertyBag
	} else {
		status.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineHealthStatus_STATUS interface (if implemented) to customize the conversion
	var statusAsAny any = status
	if augmentedStatus, ok := statusAsAny.(augmentConversionForVirtualMachineHealthStatus_STATUS); ok {
		err := augmentedStatus.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineHealthStatus_STATUS populates the provided destination VirtualMachineHealthStatus_STATUS from our VirtualMachineHealthStatus_STATUS
func (status *VirtualMachineHealthStatus_STATUS) AssignProperties_To_VirtualMachineHealthStatus_STATUS(destination *v20201201s.VirtualMachineHealthStatus_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(status.PropertyBag)

	// Status
	if status.Status != nil {
		var statusLocal v20201201s.InstanceViewStatus_STATUS
		err := status.Status.AssignProperties_To_InstanceViewStatus_STATUS(&statusLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_InstanceViewStatus_STATUS() to populate field Status")
		}
		destination.Status = &statusLocal
	} else {
		destination.Status = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineHealthStatus_STATUS interface (if implemented) to customize the conversion
	var statusAsAny any = status
	if augmentedStatus, ok := statusAsAny.(augmentConversionForVirtualMachineHealthStatus_STATUS); ok {
		err := augmentedStatus.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.VirtualMachineIdentity_UserAssignedIdentities_STATUS
// Deprecated version of VirtualMachineIdentity_UserAssignedIdentities_STATUS. Use v1api20220301.VirtualMachineIdentity_UserAssignedIdentities_STATUS instead
type VirtualMachineIdentity_UserAssignedIdentities_STATUS struct {
	ClientId    *string                `json:"clientId,omitempty"`
	PrincipalId *string                `json:"principalId,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_VirtualMachineIdentity_UserAssignedIdentities_STATUS populates our VirtualMachineIdentity_UserAssignedIdentities_STATUS from the provided source VirtualMachineIdentity_UserAssignedIdentities_STATUS
func (identities *VirtualMachineIdentity_UserAssignedIdentities_STATUS) AssignProperties_From_VirtualMachineIdentity_UserAssignedIdentities_STATUS(source *v20201201s.VirtualMachineIdentity_UserAssignedIdentities_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ClientId
	identities.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// PrincipalId
	identities.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// Update the property bag
	if len(propertyBag) > 0 {
		identities.PropertyBag = propertyBag
	} else {
		identities.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineIdentity_UserAssignedIdentities_STATUS interface (if implemented) to customize the conversion
	var identitiesAsAny any = identities
	if augmentedIdentities, ok := identitiesAsAny.(augmentConversionForVirtualMachineIdentity_UserAssignedIdentities_STATUS); ok {
		err := augmentedIdentities.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineIdentity_UserAssignedIdentities_STATUS populates the provided destination VirtualMachineIdentity_UserAssignedIdentities_STATUS from our VirtualMachineIdentity_UserAssignedIdentities_STATUS
func (identities *VirtualMachineIdentity_UserAssignedIdentities_STATUS) AssignProperties_To_VirtualMachineIdentity_UserAssignedIdentities_STATUS(destination *v20201201s.VirtualMachineIdentity_UserAssignedIdentities_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(identities.PropertyBag)

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(identities.ClientId)

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identities.PrincipalId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineIdentity_UserAssignedIdentities_STATUS interface (if implemented) to customize the conversion
	var identitiesAsAny any = identities
	if augmentedIdentities, ok := identitiesAsAny.(augmentConversionForVirtualMachineIdentity_UserAssignedIdentities_STATUS); ok {
		err := augmentedIdentities.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.VirtualMachineNetworkInterfaceConfiguration
// Deprecated version of VirtualMachineNetworkInterfaceConfiguration. Use v1api20220301.VirtualMachineNetworkInterfaceConfiguration instead
type VirtualMachineNetworkInterfaceConfiguration struct {
	DeleteOption                *string                                                 `json:"deleteOption,omitempty"`
	DnsSettings                 *VirtualMachineNetworkInterfaceDnsSettingsConfiguration `json:"dnsSettings,omitempty"`
	DscpConfiguration           *SubResource                                            `json:"dscpConfiguration,omitempty"`
	EnableAcceleratedNetworking *bool                                                   `json:"enableAcceleratedNetworking,omitempty"`
	EnableFpga                  *bool                                                   `json:"enableFpga,omitempty"`
	EnableIPForwarding          *bool                                                   `json:"enableIPForwarding,omitempty"`
	IpConfigurations            []VirtualMachineNetworkInterfaceIPConfiguration         `json:"ipConfigurations,omitempty"`
	Name                        *string                                                 `json:"name,omitempty"`
	NetworkSecurityGroup        *SubResource                                            `json:"networkSecurityGroup,omitempty"`
	Primary                     *bool                                                   `json:"primary,omitempty"`
	PropertyBag                 genruntime.PropertyBag                                  `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_VirtualMachineNetworkInterfaceConfiguration populates our VirtualMachineNetworkInterfaceConfiguration from the provided source VirtualMachineNetworkInterfaceConfiguration
func (configuration *VirtualMachineNetworkInterfaceConfiguration) AssignProperties_From_VirtualMachineNetworkInterfaceConfiguration(source *v20220301s.VirtualMachineNetworkInterfaceConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DeleteOption
	configuration.DeleteOption = genruntime.ClonePointerToString(source.DeleteOption)

	// DnsSettings
	if source.DnsSettings != nil {
		var dnsSetting VirtualMachineNetworkInterfaceDnsSettingsConfiguration
		err := dnsSetting.AssignProperties_From_VirtualMachineNetworkInterfaceDnsSettingsConfiguration(source.DnsSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineNetworkInterfaceDnsSettingsConfiguration() to populate field DnsSettings")
		}
		configuration.DnsSettings = &dnsSetting
	} else {
		configuration.DnsSettings = nil
	}

	// DscpConfiguration
	if source.DscpConfiguration != nil {
		var subResourceStash v20210701s.SubResource
		err := subResourceStash.AssignProperties_From_SubResource(source.DscpConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SubResourceStash from DscpConfiguration")
		}
		var subResourceStashLocal v20201201s.SubResource
		err = subResourceStashLocal.AssignProperties_From_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SubResourceStash")
		}
		var dscpConfiguration SubResource
		err = dscpConfiguration.AssignProperties_From_SubResource(&subResourceStashLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field DscpConfiguration from SubResourceStash")
		}
		configuration.DscpConfiguration = &dscpConfiguration
	} else {
		configuration.DscpConfiguration = nil
	}

	// EnableAcceleratedNetworking
	if source.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *source.EnableAcceleratedNetworking
		configuration.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	} else {
		configuration.EnableAcceleratedNetworking = nil
	}

	// EnableFpga
	if source.EnableFpga != nil {
		enableFpga := *source.EnableFpga
		configuration.EnableFpga = &enableFpga
	} else {
		configuration.EnableFpga = nil
	}

	// EnableIPForwarding
	if source.EnableIPForwarding != nil {
		enableIPForwarding := *source.EnableIPForwarding
		configuration.EnableIPForwarding = &enableIPForwarding
	} else {
		configuration.EnableIPForwarding = nil
	}

	// IpConfigurations
	if source.IpConfigurations != nil {
		ipConfigurationList := make([]VirtualMachineNetworkInterfaceIPConfiguration, len(source.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range source.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration VirtualMachineNetworkInterfaceIPConfiguration
			err := ipConfiguration.AssignProperties_From_VirtualMachineNetworkInterfaceIPConfiguration(&ipConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineNetworkInterfaceIPConfiguration() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		configuration.IpConfigurations = ipConfigurationList
	} else {
		configuration.IpConfigurations = nil
	}

	// Name
	configuration.Name = genruntime.ClonePointerToString(source.Name)

	// NetworkSecurityGroup
	if source.NetworkSecurityGroup != nil {
		var subResourceStash v20210701s.SubResource
		err := subResourceStash.AssignProperties_From_SubResource(source.NetworkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SubResourceStash from NetworkSecurityGroup")
		}
		var subResourceStashLocal v20201201s.SubResource
		err = subResourceStashLocal.AssignProperties_From_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SubResourceStash")
		}
		var networkSecurityGroup SubResource
		err = networkSecurityGroup.AssignProperties_From_SubResource(&subResourceStashLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field NetworkSecurityGroup from SubResourceStash")
		}
		configuration.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		configuration.NetworkSecurityGroup = nil
	}

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		configuration.Primary = &primary
	} else {
		configuration.Primary = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineNetworkInterfaceConfiguration interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForVirtualMachineNetworkInterfaceConfiguration); ok {
		err := augmentedConfiguration.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineNetworkInterfaceConfiguration populates the provided destination VirtualMachineNetworkInterfaceConfiguration from our VirtualMachineNetworkInterfaceConfiguration
func (configuration *VirtualMachineNetworkInterfaceConfiguration) AssignProperties_To_VirtualMachineNetworkInterfaceConfiguration(destination *v20220301s.VirtualMachineNetworkInterfaceConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// DeleteOption
	destination.DeleteOption = genruntime.ClonePointerToString(configuration.DeleteOption)

	// DnsSettings
	if configuration.DnsSettings != nil {
		var dnsSetting v20220301s.VirtualMachineNetworkInterfaceDnsSettingsConfiguration
		err := configuration.DnsSettings.AssignProperties_To_VirtualMachineNetworkInterfaceDnsSettingsConfiguration(&dnsSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineNetworkInterfaceDnsSettingsConfiguration() to populate field DnsSettings")
		}
		destination.DnsSettings = &dnsSetting
	} else {
		destination.DnsSettings = nil
	}

	// DscpConfiguration
	if configuration.DscpConfiguration != nil {
		var subResourceStash v20201201s.SubResource
		err := configuration.DscpConfiguration.AssignProperties_To_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SubResourceStash from DscpConfiguration")
		}
		var subResourceStashLocal v20210701s.SubResource
		err = subResourceStash.AssignProperties_To_SubResource(&subResourceStashLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SubResourceStash")
		}
		var dscpConfiguration v20220301s.SubResource
		err = subResourceStashLocal.AssignProperties_To_SubResource(&dscpConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field DscpConfiguration from SubResourceStash")
		}
		destination.DscpConfiguration = &dscpConfiguration
	} else {
		destination.DscpConfiguration = nil
	}

	// EnableAcceleratedNetworking
	if configuration.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *configuration.EnableAcceleratedNetworking
		destination.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	} else {
		destination.EnableAcceleratedNetworking = nil
	}

	// EnableFpga
	if configuration.EnableFpga != nil {
		enableFpga := *configuration.EnableFpga
		destination.EnableFpga = &enableFpga
	} else {
		destination.EnableFpga = nil
	}

	// EnableIPForwarding
	if configuration.EnableIPForwarding != nil {
		enableIPForwarding := *configuration.EnableIPForwarding
		destination.EnableIPForwarding = &enableIPForwarding
	} else {
		destination.EnableIPForwarding = nil
	}

	// IpConfigurations
	if configuration.IpConfigurations != nil {
		ipConfigurationList := make([]v20220301s.VirtualMachineNetworkInterfaceIPConfiguration, len(configuration.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range configuration.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration v20220301s.VirtualMachineNetworkInterfaceIPConfiguration
			err := ipConfigurationItem.AssignProperties_To_VirtualMachineNetworkInterfaceIPConfiguration(&ipConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineNetworkInterfaceIPConfiguration() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		destination.IpConfigurations = ipConfigurationList
	} else {
		destination.IpConfigurations = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(configuration.Name)

	// NetworkSecurityGroup
	if configuration.NetworkSecurityGroup != nil {
		var subResourceStash v20201201s.SubResource
		err := configuration.NetworkSecurityGroup.AssignProperties_To_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SubResourceStash from NetworkSecurityGroup")
		}
		var subResourceStashLocal v20210701s.SubResource
		err = subResourceStash.AssignProperties_To_SubResource(&subResourceStashLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SubResourceStash")
		}
		var networkSecurityGroup v20220301s.SubResource
		err = subResourceStashLocal.AssignProperties_To_SubResource(&networkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field NetworkSecurityGroup from SubResourceStash")
		}
		destination.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		destination.NetworkSecurityGroup = nil
	}

	// Primary
	if configuration.Primary != nil {
		primary := *configuration.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineNetworkInterfaceConfiguration interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForVirtualMachineNetworkInterfaceConfiguration); ok {
		err := augmentedConfiguration.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.VirtualMachineNetworkInterfaceConfiguration_STATUS
// Deprecated version of VirtualMachineNetworkInterfaceConfiguration_STATUS. Use v1api20220301.VirtualMachineNetworkInterfaceConfiguration_STATUS instead
type VirtualMachineNetworkInterfaceConfiguration_STATUS struct {
	DeleteOption                *string                                                        `json:"deleteOption,omitempty"`
	DnsSettings                 *VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS `json:"dnsSettings,omitempty"`
	DscpConfiguration           *SubResource_STATUS                                            `json:"dscpConfiguration,omitempty"`
	EnableAcceleratedNetworking *bool                                                          `json:"enableAcceleratedNetworking,omitempty"`
	EnableFpga                  *bool                                                          `json:"enableFpga,omitempty"`
	EnableIPForwarding          *bool                                                          `json:"enableIPForwarding,omitempty"`
	IpConfigurations            []VirtualMachineNetworkInterfaceIPConfiguration_STATUS         `json:"ipConfigurations,omitempty"`
	Name                        *string                                                        `json:"name,omitempty"`
	NetworkSecurityGroup        *SubResource_STATUS                                            `json:"networkSecurityGroup,omitempty"`
	Primary                     *bool                                                          `json:"primary,omitempty"`
	PropertyBag                 genruntime.PropertyBag                                         `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_VirtualMachineNetworkInterfaceConfiguration_STATUS populates our VirtualMachineNetworkInterfaceConfiguration_STATUS from the provided source VirtualMachineNetworkInterfaceConfiguration_STATUS
func (configuration *VirtualMachineNetworkInterfaceConfiguration_STATUS) AssignProperties_From_VirtualMachineNetworkInterfaceConfiguration_STATUS(source *v20220301s.VirtualMachineNetworkInterfaceConfiguration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DeleteOption
	configuration.DeleteOption = genruntime.ClonePointerToString(source.DeleteOption)

	// DnsSettings
	if source.DnsSettings != nil {
		var dnsSetting VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS
		err := dnsSetting.AssignProperties_From_VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS(source.DnsSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS() to populate field DnsSettings")
		}
		configuration.DnsSettings = &dnsSetting
	} else {
		configuration.DnsSettings = nil
	}

	// DscpConfiguration
	if source.DscpConfiguration != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := subResourceSTATUSStash.AssignProperties_From_SubResource_STATUS(source.DscpConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash from DscpConfiguration")
		}
		var subResourceSTATUSStashLocal v20201201s.SubResource_STATUS
		err = subResourceSTATUSStashLocal.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash")
		}
		var dscpConfiguration SubResource_STATUS
		err = dscpConfiguration.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStashLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field DscpConfiguration from SubResource_STATUSStash")
		}
		configuration.DscpConfiguration = &dscpConfiguration
	} else {
		configuration.DscpConfiguration = nil
	}

	// EnableAcceleratedNetworking
	if source.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *source.EnableAcceleratedNetworking
		configuration.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	} else {
		configuration.EnableAcceleratedNetworking = nil
	}

	// EnableFpga
	if source.EnableFpga != nil {
		enableFpga := *source.EnableFpga
		configuration.EnableFpga = &enableFpga
	} else {
		configuration.EnableFpga = nil
	}

	// EnableIPForwarding
	if source.EnableIPForwarding != nil {
		enableIPForwarding := *source.EnableIPForwarding
		configuration.EnableIPForwarding = &enableIPForwarding
	} else {
		configuration.EnableIPForwarding = nil
	}

	// IpConfigurations
	if source.IpConfigurations != nil {
		ipConfigurationList := make([]VirtualMachineNetworkInterfaceIPConfiguration_STATUS, len(source.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range source.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration VirtualMachineNetworkInterfaceIPConfiguration_STATUS
			err := ipConfiguration.AssignProperties_From_VirtualMachineNetworkInterfaceIPConfiguration_STATUS(&ipConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineNetworkInterfaceIPConfiguration_STATUS() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		configuration.IpConfigurations = ipConfigurationList
	} else {
		configuration.IpConfigurations = nil
	}

	// Name
	configuration.Name = genruntime.ClonePointerToString(source.Name)

	// NetworkSecurityGroup
	if source.NetworkSecurityGroup != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := subResourceSTATUSStash.AssignProperties_From_SubResource_STATUS(source.NetworkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash from NetworkSecurityGroup")
		}
		var subResourceSTATUSStashLocal v20201201s.SubResource_STATUS
		err = subResourceSTATUSStashLocal.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash")
		}
		var networkSecurityGroup SubResource_STATUS
		err = networkSecurityGroup.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStashLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field NetworkSecurityGroup from SubResource_STATUSStash")
		}
		configuration.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		configuration.NetworkSecurityGroup = nil
	}

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		configuration.Primary = &primary
	} else {
		configuration.Primary = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineNetworkInterfaceConfiguration_STATUS interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForVirtualMachineNetworkInterfaceConfiguration_STATUS); ok {
		err := augmentedConfiguration.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineNetworkInterfaceConfiguration_STATUS populates the provided destination VirtualMachineNetworkInterfaceConfiguration_STATUS from our VirtualMachineNetworkInterfaceConfiguration_STATUS
func (configuration *VirtualMachineNetworkInterfaceConfiguration_STATUS) AssignProperties_To_VirtualMachineNetworkInterfaceConfiguration_STATUS(destination *v20220301s.VirtualMachineNetworkInterfaceConfiguration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// DeleteOption
	destination.DeleteOption = genruntime.ClonePointerToString(configuration.DeleteOption)

	// DnsSettings
	if configuration.DnsSettings != nil {
		var dnsSetting v20220301s.VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS
		err := configuration.DnsSettings.AssignProperties_To_VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS(&dnsSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS() to populate field DnsSettings")
		}
		destination.DnsSettings = &dnsSetting
	} else {
		destination.DnsSettings = nil
	}

	// DscpConfiguration
	if configuration.DscpConfiguration != nil {
		var subResourceSTATUSStash v20201201s.SubResource_STATUS
		err := configuration.DscpConfiguration.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash from DscpConfiguration")
		}
		var subResourceSTATUSStashLocal v20210701s.SubResource_STATUS
		err = subResourceSTATUSStash.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStashLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash")
		}
		var dscpConfiguration v20220301s.SubResource_STATUS
		err = subResourceSTATUSStashLocal.AssignProperties_To_SubResource_STATUS(&dscpConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field DscpConfiguration from SubResource_STATUSStash")
		}
		destination.DscpConfiguration = &dscpConfiguration
	} else {
		destination.DscpConfiguration = nil
	}

	// EnableAcceleratedNetworking
	if configuration.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *configuration.EnableAcceleratedNetworking
		destination.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	} else {
		destination.EnableAcceleratedNetworking = nil
	}

	// EnableFpga
	if configuration.EnableFpga != nil {
		enableFpga := *configuration.EnableFpga
		destination.EnableFpga = &enableFpga
	} else {
		destination.EnableFpga = nil
	}

	// EnableIPForwarding
	if configuration.EnableIPForwarding != nil {
		enableIPForwarding := *configuration.EnableIPForwarding
		destination.EnableIPForwarding = &enableIPForwarding
	} else {
		destination.EnableIPForwarding = nil
	}

	// IpConfigurations
	if configuration.IpConfigurations != nil {
		ipConfigurationList := make([]v20220301s.VirtualMachineNetworkInterfaceIPConfiguration_STATUS, len(configuration.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range configuration.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration v20220301s.VirtualMachineNetworkInterfaceIPConfiguration_STATUS
			err := ipConfigurationItem.AssignProperties_To_VirtualMachineNetworkInterfaceIPConfiguration_STATUS(&ipConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineNetworkInterfaceIPConfiguration_STATUS() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		destination.IpConfigurations = ipConfigurationList
	} else {
		destination.IpConfigurations = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(configuration.Name)

	// NetworkSecurityGroup
	if configuration.NetworkSecurityGroup != nil {
		var subResourceSTATUSStash v20201201s.SubResource_STATUS
		err := configuration.NetworkSecurityGroup.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash from NetworkSecurityGroup")
		}
		var subResourceSTATUSStashLocal v20210701s.SubResource_STATUS
		err = subResourceSTATUSStash.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStashLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash")
		}
		var networkSecurityGroup v20220301s.SubResource_STATUS
		err = subResourceSTATUSStashLocal.AssignProperties_To_SubResource_STATUS(&networkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field NetworkSecurityGroup from SubResource_STATUSStash")
		}
		destination.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		destination.NetworkSecurityGroup = nil
	}

	// Primary
	if configuration.Primary != nil {
		primary := *configuration.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineNetworkInterfaceConfiguration_STATUS interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForVirtualMachineNetworkInterfaceConfiguration_STATUS); ok {
		err := augmentedConfiguration.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.VirtualMachinePatchStatus_STATUS
// Deprecated version of VirtualMachinePatchStatus_STATUS. Use v1api20220301.VirtualMachinePatchStatus_STATUS instead
type VirtualMachinePatchStatus_STATUS struct {
	AvailablePatchSummary        *AvailablePatchSummary_STATUS        `json:"availablePatchSummary,omitempty"`
	ConfigurationStatuses        []InstanceViewStatus_STATUS          `json:"configurationStatuses,omitempty"`
	LastPatchInstallationSummary *LastPatchInstallationSummary_STATUS `json:"lastPatchInstallationSummary,omitempty"`
	PropertyBag                  genruntime.PropertyBag               `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_VirtualMachinePatchStatus_STATUS populates our VirtualMachinePatchStatus_STATUS from the provided source VirtualMachinePatchStatus_STATUS
func (status *VirtualMachinePatchStatus_STATUS) AssignProperties_From_VirtualMachinePatchStatus_STATUS(source *v20201201s.VirtualMachinePatchStatus_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AvailablePatchSummary
	if source.AvailablePatchSummary != nil {
		var availablePatchSummary AvailablePatchSummary_STATUS
		err := availablePatchSummary.AssignProperties_From_AvailablePatchSummary_STATUS(source.AvailablePatchSummary)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AvailablePatchSummary_STATUS() to populate field AvailablePatchSummary")
		}
		status.AvailablePatchSummary = &availablePatchSummary
	} else {
		status.AvailablePatchSummary = nil
	}

	// ConfigurationStatuses
	if source.ConfigurationStatuses != nil {
		configurationStatusList := make([]InstanceViewStatus_STATUS, len(source.ConfigurationStatuses))
		for configurationStatusIndex, configurationStatusItem := range source.ConfigurationStatuses {
			// Shadow the loop variable to avoid aliasing
			configurationStatusItem := configurationStatusItem
			var configurationStatus InstanceViewStatus_STATUS
			err := configurationStatus.AssignProperties_From_InstanceViewStatus_STATUS(&configurationStatusItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_InstanceViewStatus_STATUS() to populate field ConfigurationStatuses")
			}
			configurationStatusList[configurationStatusIndex] = configurationStatus
		}
		status.ConfigurationStatuses = configurationStatusList
	} else {
		status.ConfigurationStatuses = nil
	}

	// LastPatchInstallationSummary
	if source.LastPatchInstallationSummary != nil {
		var lastPatchInstallationSummary LastPatchInstallationSummary_STATUS
		err := lastPatchInstallationSummary.AssignProperties_From_LastPatchInstallationSummary_STATUS(source.LastPatchInstallationSummary)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_LastPatchInstallationSummary_STATUS() to populate field LastPatchInstallationSummary")
		}
		status.LastPatchInstallationSummary = &lastPatchInstallationSummary
	} else {
		status.LastPatchInstallationSummary = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		status.PropertyBag = propertyBag
	} else {
		status.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachinePatchStatus_STATUS interface (if implemented) to customize the conversion
	var statusAsAny any = status
	if augmentedStatus, ok := statusAsAny.(augmentConversionForVirtualMachinePatchStatus_STATUS); ok {
		err := augmentedStatus.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachinePatchStatus_STATUS populates the provided destination VirtualMachinePatchStatus_STATUS from our VirtualMachinePatchStatus_STATUS
func (status *VirtualMachinePatchStatus_STATUS) AssignProperties_To_VirtualMachinePatchStatus_STATUS(destination *v20201201s.VirtualMachinePatchStatus_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(status.PropertyBag)

	// AvailablePatchSummary
	if status.AvailablePatchSummary != nil {
		var availablePatchSummary v20201201s.AvailablePatchSummary_STATUS
		err := status.AvailablePatchSummary.AssignProperties_To_AvailablePatchSummary_STATUS(&availablePatchSummary)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AvailablePatchSummary_STATUS() to populate field AvailablePatchSummary")
		}
		destination.AvailablePatchSummary = &availablePatchSummary
	} else {
		destination.AvailablePatchSummary = nil
	}

	// ConfigurationStatuses
	if status.ConfigurationStatuses != nil {
		configurationStatusList := make([]v20201201s.InstanceViewStatus_STATUS, len(status.ConfigurationStatuses))
		for configurationStatusIndex, configurationStatusItem := range status.ConfigurationStatuses {
			// Shadow the loop variable to avoid aliasing
			configurationStatusItem := configurationStatusItem
			var configurationStatus v20201201s.InstanceViewStatus_STATUS
			err := configurationStatusItem.AssignProperties_To_InstanceViewStatus_STATUS(&configurationStatus)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_InstanceViewStatus_STATUS() to populate field ConfigurationStatuses")
			}
			configurationStatusList[configurationStatusIndex] = configurationStatus
		}
		destination.ConfigurationStatuses = configurationStatusList
	} else {
		destination.ConfigurationStatuses = nil
	}

	// LastPatchInstallationSummary
	if status.LastPatchInstallationSummary != nil {
		var lastPatchInstallationSummary v20201201s.LastPatchInstallationSummary_STATUS
		err := status.LastPatchInstallationSummary.AssignProperties_To_LastPatchInstallationSummary_STATUS(&lastPatchInstallationSummary)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_LastPatchInstallationSummary_STATUS() to populate field LastPatchInstallationSummary")
		}
		destination.LastPatchInstallationSummary = &lastPatchInstallationSummary
	} else {
		destination.LastPatchInstallationSummary = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachinePatchStatus_STATUS interface (if implemented) to customize the conversion
	var statusAsAny any = status
	if augmentedStatus, ok := statusAsAny.(augmentConversionForVirtualMachinePatchStatus_STATUS); ok {
		err := augmentedStatus.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.VMGalleryApplication
// Deprecated version of VMGalleryApplication. Use v1api20220301.VMGalleryApplication instead
type VMGalleryApplication struct {
	ConfigurationReference *string `json:"configurationReference,omitempty"`
	EnableAutomaticUpgrade *bool   `json:"enableAutomaticUpgrade,omitempty"`
	Order                  *int    `json:"order,omitempty"`

	// +kubebuilder:validation:Required
	PackageReferenceReference       *genruntime.ResourceReference `armReference:"PackageReferenceId" json:"packageReferenceReference,omitempty"`
	PropertyBag                     genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
	Tags                            *string                       `json:"tags,omitempty"`
	TreatFailureAsDeploymentFailure *bool                         `json:"treatFailureAsDeploymentFailure,omitempty"`
}

// AssignProperties_From_VMGalleryApplication populates our VMGalleryApplication from the provided source VMGalleryApplication
func (application *VMGalleryApplication) AssignProperties_From_VMGalleryApplication(source *v20220301s.VMGalleryApplication) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ConfigurationReference
	application.ConfigurationReference = genruntime.ClonePointerToString(source.ConfigurationReference)

	// EnableAutomaticUpgrade
	if source.EnableAutomaticUpgrade != nil {
		enableAutomaticUpgrade := *source.EnableAutomaticUpgrade
		application.EnableAutomaticUpgrade = &enableAutomaticUpgrade
	} else {
		application.EnableAutomaticUpgrade = nil
	}

	// Order
	application.Order = genruntime.ClonePointerToInt(source.Order)

	// PackageReferenceReference
	if source.PackageReferenceReference != nil {
		packageReferenceReference := source.PackageReferenceReference.Copy()
		application.PackageReferenceReference = &packageReferenceReference
	} else {
		application.PackageReferenceReference = nil
	}

	// Tags
	application.Tags = genruntime.ClonePointerToString(source.Tags)

	// TreatFailureAsDeploymentFailure
	if source.TreatFailureAsDeploymentFailure != nil {
		treatFailureAsDeploymentFailure := *source.TreatFailureAsDeploymentFailure
		application.TreatFailureAsDeploymentFailure = &treatFailureAsDeploymentFailure
	} else {
		application.TreatFailureAsDeploymentFailure = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		application.PropertyBag = propertyBag
	} else {
		application.PropertyBag = nil
	}

	// Invoke the augmentConversionForVMGalleryApplication interface (if implemented) to customize the conversion
	var applicationAsAny any = application
	if augmentedApplication, ok := applicationAsAny.(augmentConversionForVMGalleryApplication); ok {
		err := augmentedApplication.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VMGalleryApplication populates the provided destination VMGalleryApplication from our VMGalleryApplication
func (application *VMGalleryApplication) AssignProperties_To_VMGalleryApplication(destination *v20220301s.VMGalleryApplication) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(application.PropertyBag)

	// ConfigurationReference
	destination.ConfigurationReference = genruntime.ClonePointerToString(application.ConfigurationReference)

	// EnableAutomaticUpgrade
	if application.EnableAutomaticUpgrade != nil {
		enableAutomaticUpgrade := *application.EnableAutomaticUpgrade
		destination.EnableAutomaticUpgrade = &enableAutomaticUpgrade
	} else {
		destination.EnableAutomaticUpgrade = nil
	}

	// Order
	destination.Order = genruntime.ClonePointerToInt(application.Order)

	// PackageReferenceReference
	if application.PackageReferenceReference != nil {
		packageReferenceReference := application.PackageReferenceReference.Copy()
		destination.PackageReferenceReference = &packageReferenceReference
	} else {
		destination.PackageReferenceReference = nil
	}

	// Tags
	destination.Tags = genruntime.ClonePointerToString(application.Tags)

	// TreatFailureAsDeploymentFailure
	if application.TreatFailureAsDeploymentFailure != nil {
		treatFailureAsDeploymentFailure := *application.TreatFailureAsDeploymentFailure
		destination.TreatFailureAsDeploymentFailure = &treatFailureAsDeploymentFailure
	} else {
		destination.TreatFailureAsDeploymentFailure = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVMGalleryApplication interface (if implemented) to customize the conversion
	var applicationAsAny any = application
	if augmentedApplication, ok := applicationAsAny.(augmentConversionForVMGalleryApplication); ok {
		err := augmentedApplication.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.VMGalleryApplication_STATUS
// Deprecated version of VMGalleryApplication_STATUS. Use v1api20220301.VMGalleryApplication_STATUS instead
type VMGalleryApplication_STATUS struct {
	ConfigurationReference          *string                `json:"configurationReference,omitempty"`
	EnableAutomaticUpgrade          *bool                  `json:"enableAutomaticUpgrade,omitempty"`
	Order                           *int                   `json:"order,omitempty"`
	PackageReferenceId              *string                `json:"packageReferenceId,omitempty"`
	PropertyBag                     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Tags                            *string                `json:"tags,omitempty"`
	TreatFailureAsDeploymentFailure *bool                  `json:"treatFailureAsDeploymentFailure,omitempty"`
}

// AssignProperties_From_VMGalleryApplication_STATUS populates our VMGalleryApplication_STATUS from the provided source VMGalleryApplication_STATUS
func (application *VMGalleryApplication_STATUS) AssignProperties_From_VMGalleryApplication_STATUS(source *v20220301s.VMGalleryApplication_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ConfigurationReference
	application.ConfigurationReference = genruntime.ClonePointerToString(source.ConfigurationReference)

	// EnableAutomaticUpgrade
	if source.EnableAutomaticUpgrade != nil {
		enableAutomaticUpgrade := *source.EnableAutomaticUpgrade
		application.EnableAutomaticUpgrade = &enableAutomaticUpgrade
	} else {
		application.EnableAutomaticUpgrade = nil
	}

	// Order
	application.Order = genruntime.ClonePointerToInt(source.Order)

	// PackageReferenceId
	application.PackageReferenceId = genruntime.ClonePointerToString(source.PackageReferenceId)

	// Tags
	application.Tags = genruntime.ClonePointerToString(source.Tags)

	// TreatFailureAsDeploymentFailure
	if source.TreatFailureAsDeploymentFailure != nil {
		treatFailureAsDeploymentFailure := *source.TreatFailureAsDeploymentFailure
		application.TreatFailureAsDeploymentFailure = &treatFailureAsDeploymentFailure
	} else {
		application.TreatFailureAsDeploymentFailure = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		application.PropertyBag = propertyBag
	} else {
		application.PropertyBag = nil
	}

	// Invoke the augmentConversionForVMGalleryApplication_STATUS interface (if implemented) to customize the conversion
	var applicationAsAny any = application
	if augmentedApplication, ok := applicationAsAny.(augmentConversionForVMGalleryApplication_STATUS); ok {
		err := augmentedApplication.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VMGalleryApplication_STATUS populates the provided destination VMGalleryApplication_STATUS from our VMGalleryApplication_STATUS
func (application *VMGalleryApplication_STATUS) AssignProperties_To_VMGalleryApplication_STATUS(destination *v20220301s.VMGalleryApplication_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(application.PropertyBag)

	// ConfigurationReference
	destination.ConfigurationReference = genruntime.ClonePointerToString(application.ConfigurationReference)

	// EnableAutomaticUpgrade
	if application.EnableAutomaticUpgrade != nil {
		enableAutomaticUpgrade := *application.EnableAutomaticUpgrade
		destination.EnableAutomaticUpgrade = &enableAutomaticUpgrade
	} else {
		destination.EnableAutomaticUpgrade = nil
	}

	// Order
	destination.Order = genruntime.ClonePointerToInt(application.Order)

	// PackageReferenceId
	destination.PackageReferenceId = genruntime.ClonePointerToString(application.PackageReferenceId)

	// Tags
	destination.Tags = genruntime.ClonePointerToString(application.Tags)

	// TreatFailureAsDeploymentFailure
	if application.TreatFailureAsDeploymentFailure != nil {
		treatFailureAsDeploymentFailure := *application.TreatFailureAsDeploymentFailure
		destination.TreatFailureAsDeploymentFailure = &treatFailureAsDeploymentFailure
	} else {
		destination.TreatFailureAsDeploymentFailure = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVMGalleryApplication_STATUS interface (if implemented) to customize the conversion
	var applicationAsAny any = application
	if augmentedApplication, ok := applicationAsAny.(augmentConversionForVMGalleryApplication_STATUS); ok {
		err := augmentedApplication.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.VMSizeProperties
// Deprecated version of VMSizeProperties. Use v1api20220301.VMSizeProperties instead
type VMSizeProperties struct {
	PropertyBag    genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	VCPUsAvailable *int                   `json:"vCPUsAvailable,omitempty"`
	VCPUsPerCore   *int                   `json:"vCPUsPerCore,omitempty"`
}

// AssignProperties_From_VMSizeProperties populates our VMSizeProperties from the provided source VMSizeProperties
func (properties *VMSizeProperties) AssignProperties_From_VMSizeProperties(source *v20220301s.VMSizeProperties) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// VCPUsAvailable
	properties.VCPUsAvailable = genruntime.ClonePointerToInt(source.VCPUsAvailable)

	// VCPUsPerCore
	properties.VCPUsPerCore = genruntime.ClonePointerToInt(source.VCPUsPerCore)

	// Update the property bag
	if len(propertyBag) > 0 {
		properties.PropertyBag = propertyBag
	} else {
		properties.PropertyBag = nil
	}

	// Invoke the augmentConversionForVMSizeProperties interface (if implemented) to customize the conversion
	var propertiesAsAny any = properties
	if augmentedProperties, ok := propertiesAsAny.(augmentConversionForVMSizeProperties); ok {
		err := augmentedProperties.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VMSizeProperties populates the provided destination VMSizeProperties from our VMSizeProperties
func (properties *VMSizeProperties) AssignProperties_To_VMSizeProperties(destination *v20220301s.VMSizeProperties) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(properties.PropertyBag)

	// VCPUsAvailable
	destination.VCPUsAvailable = genruntime.ClonePointerToInt(properties.VCPUsAvailable)

	// VCPUsPerCore
	destination.VCPUsPerCore = genruntime.ClonePointerToInt(properties.VCPUsPerCore)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVMSizeProperties interface (if implemented) to customize the conversion
	var propertiesAsAny any = properties
	if augmentedProperties, ok := propertiesAsAny.(augmentConversionForVMSizeProperties); ok {
		err := augmentedProperties.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.VMSizeProperties_STATUS
// Deprecated version of VMSizeProperties_STATUS. Use v1api20220301.VMSizeProperties_STATUS instead
type VMSizeProperties_STATUS struct {
	PropertyBag    genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	VCPUsAvailable *int                   `json:"vCPUsAvailable,omitempty"`
	VCPUsPerCore   *int                   `json:"vCPUsPerCore,omitempty"`
}

// AssignProperties_From_VMSizeProperties_STATUS populates our VMSizeProperties_STATUS from the provided source VMSizeProperties_STATUS
func (properties *VMSizeProperties_STATUS) AssignProperties_From_VMSizeProperties_STATUS(source *v20220301s.VMSizeProperties_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// VCPUsAvailable
	properties.VCPUsAvailable = genruntime.ClonePointerToInt(source.VCPUsAvailable)

	// VCPUsPerCore
	properties.VCPUsPerCore = genruntime.ClonePointerToInt(source.VCPUsPerCore)

	// Update the property bag
	if len(propertyBag) > 0 {
		properties.PropertyBag = propertyBag
	} else {
		properties.PropertyBag = nil
	}

	// Invoke the augmentConversionForVMSizeProperties_STATUS interface (if implemented) to customize the conversion
	var propertiesAsAny any = properties
	if augmentedProperties, ok := propertiesAsAny.(augmentConversionForVMSizeProperties_STATUS); ok {
		err := augmentedProperties.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VMSizeProperties_STATUS populates the provided destination VMSizeProperties_STATUS from our VMSizeProperties_STATUS
func (properties *VMSizeProperties_STATUS) AssignProperties_To_VMSizeProperties_STATUS(destination *v20220301s.VMSizeProperties_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(properties.PropertyBag)

	// VCPUsAvailable
	destination.VCPUsAvailable = genruntime.ClonePointerToInt(properties.VCPUsAvailable)

	// VCPUsPerCore
	destination.VCPUsPerCore = genruntime.ClonePointerToInt(properties.VCPUsPerCore)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVMSizeProperties_STATUS interface (if implemented) to customize the conversion
	var propertiesAsAny any = properties
	if augmentedProperties, ok := propertiesAsAny.(augmentConversionForVMSizeProperties_STATUS); ok {
		err := augmentedProperties.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.WindowsConfiguration
// Deprecated version of WindowsConfiguration. Use v1api20220301.WindowsConfiguration instead
type WindowsConfiguration struct {
	AdditionalUnattendContent []AdditionalUnattendContent `json:"additionalUnattendContent,omitempty"`
	EnableAutomaticUpdates    *bool                       `json:"enableAutomaticUpdates,omitempty"`
	PatchSettings             *PatchSettings              `json:"patchSettings,omitempty"`
	PropertyBag               genruntime.PropertyBag      `json:"$propertyBag,omitempty"`
	ProvisionVMAgent          *bool                       `json:"provisionVMAgent,omitempty"`
	TimeZone                  *string                     `json:"timeZone,omitempty"`
	WinRM                     *WinRMConfiguration         `json:"winRM,omitempty"`
}

// AssignProperties_From_WindowsConfiguration populates our WindowsConfiguration from the provided source WindowsConfiguration
func (configuration *WindowsConfiguration) AssignProperties_From_WindowsConfiguration(source *v20201201s.WindowsConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AdditionalUnattendContent
	if source.AdditionalUnattendContent != nil {
		additionalUnattendContentList := make([]AdditionalUnattendContent, len(source.AdditionalUnattendContent))
		for additionalUnattendContentIndex, additionalUnattendContentItem := range source.AdditionalUnattendContent {
			// Shadow the loop variable to avoid aliasing
			additionalUnattendContentItem := additionalUnattendContentItem
			var additionalUnattendContent AdditionalUnattendContent
			err := additionalUnattendContent.AssignProperties_From_AdditionalUnattendContent(&additionalUnattendContentItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_AdditionalUnattendContent() to populate field AdditionalUnattendContent")
			}
			additionalUnattendContentList[additionalUnattendContentIndex] = additionalUnattendContent
		}
		configuration.AdditionalUnattendContent = additionalUnattendContentList
	} else {
		configuration.AdditionalUnattendContent = nil
	}

	// EnableAutomaticUpdates
	if source.EnableAutomaticUpdates != nil {
		enableAutomaticUpdate := *source.EnableAutomaticUpdates
		configuration.EnableAutomaticUpdates = &enableAutomaticUpdate
	} else {
		configuration.EnableAutomaticUpdates = nil
	}

	// PatchSettings
	if source.PatchSettings != nil {
		var patchSetting PatchSettings
		err := patchSetting.AssignProperties_From_PatchSettings(source.PatchSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PatchSettings() to populate field PatchSettings")
		}
		configuration.PatchSettings = &patchSetting
	} else {
		configuration.PatchSettings = nil
	}

	// ProvisionVMAgent
	if source.ProvisionVMAgent != nil {
		provisionVMAgent := *source.ProvisionVMAgent
		configuration.ProvisionVMAgent = &provisionVMAgent
	} else {
		configuration.ProvisionVMAgent = nil
	}

	// TimeZone
	configuration.TimeZone = genruntime.ClonePointerToString(source.TimeZone)

	// WinRM
	if source.WinRM != nil {
		var winRM WinRMConfiguration
		err := winRM.AssignProperties_From_WinRMConfiguration(source.WinRM)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_WinRMConfiguration() to populate field WinRM")
		}
		configuration.WinRM = &winRM
	} else {
		configuration.WinRM = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// Invoke the augmentConversionForWindowsConfiguration interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForWindowsConfiguration); ok {
		err := augmentedConfiguration.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_WindowsConfiguration populates the provided destination WindowsConfiguration from our WindowsConfiguration
func (configuration *WindowsConfiguration) AssignProperties_To_WindowsConfiguration(destination *v20201201s.WindowsConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// AdditionalUnattendContent
	if configuration.AdditionalUnattendContent != nil {
		additionalUnattendContentList := make([]v20201201s.AdditionalUnattendContent, len(configuration.AdditionalUnattendContent))
		for additionalUnattendContentIndex, additionalUnattendContentItem := range configuration.AdditionalUnattendContent {
			// Shadow the loop variable to avoid aliasing
			additionalUnattendContentItem := additionalUnattendContentItem
			var additionalUnattendContent v20201201s.AdditionalUnattendContent
			err := additionalUnattendContentItem.AssignProperties_To_AdditionalUnattendContent(&additionalUnattendContent)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_AdditionalUnattendContent() to populate field AdditionalUnattendContent")
			}
			additionalUnattendContentList[additionalUnattendContentIndex] = additionalUnattendContent
		}
		destination.AdditionalUnattendContent = additionalUnattendContentList
	} else {
		destination.AdditionalUnattendContent = nil
	}

	// EnableAutomaticUpdates
	if configuration.EnableAutomaticUpdates != nil {
		enableAutomaticUpdate := *configuration.EnableAutomaticUpdates
		destination.EnableAutomaticUpdates = &enableAutomaticUpdate
	} else {
		destination.EnableAutomaticUpdates = nil
	}

	// PatchSettings
	if configuration.PatchSettings != nil {
		var patchSetting v20201201s.PatchSettings
		err := configuration.PatchSettings.AssignProperties_To_PatchSettings(&patchSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PatchSettings() to populate field PatchSettings")
		}
		destination.PatchSettings = &patchSetting
	} else {
		destination.PatchSettings = nil
	}

	// ProvisionVMAgent
	if configuration.ProvisionVMAgent != nil {
		provisionVMAgent := *configuration.ProvisionVMAgent
		destination.ProvisionVMAgent = &provisionVMAgent
	} else {
		destination.ProvisionVMAgent = nil
	}

	// TimeZone
	destination.TimeZone = genruntime.ClonePointerToString(configuration.TimeZone)

	// WinRM
	if configuration.WinRM != nil {
		var winRM v20201201s.WinRMConfiguration
		err := configuration.WinRM.AssignProperties_To_WinRMConfiguration(&winRM)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_WinRMConfiguration() to populate field WinRM")
		}
		destination.WinRM = &winRM
	} else {
		destination.WinRM = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForWindowsConfiguration interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForWindowsConfiguration); ok {
		err := augmentedConfiguration.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.WindowsConfiguration_STATUS
// Deprecated version of WindowsConfiguration_STATUS. Use v1api20220301.WindowsConfiguration_STATUS instead
type WindowsConfiguration_STATUS struct {
	AdditionalUnattendContent []AdditionalUnattendContent_STATUS `json:"additionalUnattendContent,omitempty"`
	EnableAutomaticUpdates    *bool                              `json:"enableAutomaticUpdates,omitempty"`
	PatchSettings             *PatchSettings_STATUS              `json:"patchSettings,omitempty"`
	PropertyBag               genruntime.PropertyBag             `json:"$propertyBag,omitempty"`
	ProvisionVMAgent          *bool                              `json:"provisionVMAgent,omitempty"`
	TimeZone                  *string                            `json:"timeZone,omitempty"`
	WinRM                     *WinRMConfiguration_STATUS         `json:"winRM,omitempty"`
}

// AssignProperties_From_WindowsConfiguration_STATUS populates our WindowsConfiguration_STATUS from the provided source WindowsConfiguration_STATUS
func (configuration *WindowsConfiguration_STATUS) AssignProperties_From_WindowsConfiguration_STATUS(source *v20201201s.WindowsConfiguration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AdditionalUnattendContent
	if source.AdditionalUnattendContent != nil {
		additionalUnattendContentList := make([]AdditionalUnattendContent_STATUS, len(source.AdditionalUnattendContent))
		for additionalUnattendContentIndex, additionalUnattendContentItem := range source.AdditionalUnattendContent {
			// Shadow the loop variable to avoid aliasing
			additionalUnattendContentItem := additionalUnattendContentItem
			var additionalUnattendContent AdditionalUnattendContent_STATUS
			err := additionalUnattendContent.AssignProperties_From_AdditionalUnattendContent_STATUS(&additionalUnattendContentItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_AdditionalUnattendContent_STATUS() to populate field AdditionalUnattendContent")
			}
			additionalUnattendContentList[additionalUnattendContentIndex] = additionalUnattendContent
		}
		configuration.AdditionalUnattendContent = additionalUnattendContentList
	} else {
		configuration.AdditionalUnattendContent = nil
	}

	// EnableAutomaticUpdates
	if source.EnableAutomaticUpdates != nil {
		enableAutomaticUpdate := *source.EnableAutomaticUpdates
		configuration.EnableAutomaticUpdates = &enableAutomaticUpdate
	} else {
		configuration.EnableAutomaticUpdates = nil
	}

	// PatchSettings
	if source.PatchSettings != nil {
		var patchSetting PatchSettings_STATUS
		err := patchSetting.AssignProperties_From_PatchSettings_STATUS(source.PatchSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PatchSettings_STATUS() to populate field PatchSettings")
		}
		configuration.PatchSettings = &patchSetting
	} else {
		configuration.PatchSettings = nil
	}

	// ProvisionVMAgent
	if source.ProvisionVMAgent != nil {
		provisionVMAgent := *source.ProvisionVMAgent
		configuration.ProvisionVMAgent = &provisionVMAgent
	} else {
		configuration.ProvisionVMAgent = nil
	}

	// TimeZone
	configuration.TimeZone = genruntime.ClonePointerToString(source.TimeZone)

	// WinRM
	if source.WinRM != nil {
		var winRM WinRMConfiguration_STATUS
		err := winRM.AssignProperties_From_WinRMConfiguration_STATUS(source.WinRM)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_WinRMConfiguration_STATUS() to populate field WinRM")
		}
		configuration.WinRM = &winRM
	} else {
		configuration.WinRM = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// Invoke the augmentConversionForWindowsConfiguration_STATUS interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForWindowsConfiguration_STATUS); ok {
		err := augmentedConfiguration.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_WindowsConfiguration_STATUS populates the provided destination WindowsConfiguration_STATUS from our WindowsConfiguration_STATUS
func (configuration *WindowsConfiguration_STATUS) AssignProperties_To_WindowsConfiguration_STATUS(destination *v20201201s.WindowsConfiguration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// AdditionalUnattendContent
	if configuration.AdditionalUnattendContent != nil {
		additionalUnattendContentList := make([]v20201201s.AdditionalUnattendContent_STATUS, len(configuration.AdditionalUnattendContent))
		for additionalUnattendContentIndex, additionalUnattendContentItem := range configuration.AdditionalUnattendContent {
			// Shadow the loop variable to avoid aliasing
			additionalUnattendContentItem := additionalUnattendContentItem
			var additionalUnattendContent v20201201s.AdditionalUnattendContent_STATUS
			err := additionalUnattendContentItem.AssignProperties_To_AdditionalUnattendContent_STATUS(&additionalUnattendContent)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_AdditionalUnattendContent_STATUS() to populate field AdditionalUnattendContent")
			}
			additionalUnattendContentList[additionalUnattendContentIndex] = additionalUnattendContent
		}
		destination.AdditionalUnattendContent = additionalUnattendContentList
	} else {
		destination.AdditionalUnattendContent = nil
	}

	// EnableAutomaticUpdates
	if configuration.EnableAutomaticUpdates != nil {
		enableAutomaticUpdate := *configuration.EnableAutomaticUpdates
		destination.EnableAutomaticUpdates = &enableAutomaticUpdate
	} else {
		destination.EnableAutomaticUpdates = nil
	}

	// PatchSettings
	if configuration.PatchSettings != nil {
		var patchSetting v20201201s.PatchSettings_STATUS
		err := configuration.PatchSettings.AssignProperties_To_PatchSettings_STATUS(&patchSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PatchSettings_STATUS() to populate field PatchSettings")
		}
		destination.PatchSettings = &patchSetting
	} else {
		destination.PatchSettings = nil
	}

	// ProvisionVMAgent
	if configuration.ProvisionVMAgent != nil {
		provisionVMAgent := *configuration.ProvisionVMAgent
		destination.ProvisionVMAgent = &provisionVMAgent
	} else {
		destination.ProvisionVMAgent = nil
	}

	// TimeZone
	destination.TimeZone = genruntime.ClonePointerToString(configuration.TimeZone)

	// WinRM
	if configuration.WinRM != nil {
		var winRM v20201201s.WinRMConfiguration_STATUS
		err := configuration.WinRM.AssignProperties_To_WinRMConfiguration_STATUS(&winRM)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_WinRMConfiguration_STATUS() to populate field WinRM")
		}
		destination.WinRM = &winRM
	} else {
		destination.WinRM = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForWindowsConfiguration_STATUS interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForWindowsConfiguration_STATUS); ok {
		err := augmentedConfiguration.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.AdditionalUnattendContent
// Deprecated version of AdditionalUnattendContent. Use v1api20220301.AdditionalUnattendContent instead
type AdditionalUnattendContent struct {
	ComponentName *string                `json:"componentName,omitempty"`
	Content       *string                `json:"content,omitempty"`
	PassName      *string                `json:"passName,omitempty"`
	PropertyBag   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SettingName   *string                `json:"settingName,omitempty"`
}

// AssignProperties_From_AdditionalUnattendContent populates our AdditionalUnattendContent from the provided source AdditionalUnattendContent
func (content *AdditionalUnattendContent) AssignProperties_From_AdditionalUnattendContent(source *v20201201s.AdditionalUnattendContent) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ComponentName
	content.ComponentName = genruntime.ClonePointerToString(source.ComponentName)

	// Content
	content.Content = genruntime.ClonePointerToString(source.Content)

	// PassName
	content.PassName = genruntime.ClonePointerToString(source.PassName)

	// SettingName
	content.SettingName = genruntime.ClonePointerToString(source.SettingName)

	// Update the property bag
	if len(propertyBag) > 0 {
		content.PropertyBag = propertyBag
	} else {
		content.PropertyBag = nil
	}

	// Invoke the augmentConversionForAdditionalUnattendContent interface (if implemented) to customize the conversion
	var contentAsAny any = content
	if augmentedContent, ok := contentAsAny.(augmentConversionForAdditionalUnattendContent); ok {
		err := augmentedContent.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AdditionalUnattendContent populates the provided destination AdditionalUnattendContent from our AdditionalUnattendContent
func (content *AdditionalUnattendContent) AssignProperties_To_AdditionalUnattendContent(destination *v20201201s.AdditionalUnattendContent) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(content.PropertyBag)

	// ComponentName
	destination.ComponentName = genruntime.ClonePointerToString(content.ComponentName)

	// Content
	destination.Content = genruntime.ClonePointerToString(content.Content)

	// PassName
	destination.PassName = genruntime.ClonePointerToString(content.PassName)

	// SettingName
	destination.SettingName = genruntime.ClonePointerToString(content.SettingName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAdditionalUnattendContent interface (if implemented) to customize the conversion
	var contentAsAny any = content
	if augmentedContent, ok := contentAsAny.(augmentConversionForAdditionalUnattendContent); ok {
		err := augmentedContent.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.AdditionalUnattendContent_STATUS
// Deprecated version of AdditionalUnattendContent_STATUS. Use v1api20220301.AdditionalUnattendContent_STATUS instead
type AdditionalUnattendContent_STATUS struct {
	ComponentName *string                `json:"componentName,omitempty"`
	Content       *string                `json:"content,omitempty"`
	PassName      *string                `json:"passName,omitempty"`
	PropertyBag   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SettingName   *string                `json:"settingName,omitempty"`
}

// AssignProperties_From_AdditionalUnattendContent_STATUS populates our AdditionalUnattendContent_STATUS from the provided source AdditionalUnattendContent_STATUS
func (content *AdditionalUnattendContent_STATUS) AssignProperties_From_AdditionalUnattendContent_STATUS(source *v20201201s.AdditionalUnattendContent_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ComponentName
	content.ComponentName = genruntime.ClonePointerToString(source.ComponentName)

	// Content
	content.Content = genruntime.ClonePointerToString(source.Content)

	// PassName
	content.PassName = genruntime.ClonePointerToString(source.PassName)

	// SettingName
	content.SettingName = genruntime.ClonePointerToString(source.SettingName)

	// Update the property bag
	if len(propertyBag) > 0 {
		content.PropertyBag = propertyBag
	} else {
		content.PropertyBag = nil
	}

	// Invoke the augmentConversionForAdditionalUnattendContent_STATUS interface (if implemented) to customize the conversion
	var contentAsAny any = content
	if augmentedContent, ok := contentAsAny.(augmentConversionForAdditionalUnattendContent_STATUS); ok {
		err := augmentedContent.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AdditionalUnattendContent_STATUS populates the provided destination AdditionalUnattendContent_STATUS from our AdditionalUnattendContent_STATUS
func (content *AdditionalUnattendContent_STATUS) AssignProperties_To_AdditionalUnattendContent_STATUS(destination *v20201201s.AdditionalUnattendContent_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(content.PropertyBag)

	// ComponentName
	destination.ComponentName = genruntime.ClonePointerToString(content.ComponentName)

	// Content
	destination.Content = genruntime.ClonePointerToString(content.Content)

	// PassName
	destination.PassName = genruntime.ClonePointerToString(content.PassName)

	// SettingName
	destination.SettingName = genruntime.ClonePointerToString(content.SettingName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAdditionalUnattendContent_STATUS interface (if implemented) to customize the conversion
	var contentAsAny any = content
	if augmentedContent, ok := contentAsAny.(augmentConversionForAdditionalUnattendContent_STATUS); ok {
		err := augmentedContent.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForBootDiagnostics interface {
	AssignPropertiesFrom(src *v20201201s.BootDiagnostics) error
	AssignPropertiesTo(dst *v20201201s.BootDiagnostics) error
}

type augmentConversionForBootDiagnostics_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.BootDiagnostics_STATUS) error
	AssignPropertiesTo(dst *v20201201s.BootDiagnostics_STATUS) error
}

type augmentConversionForBootDiagnosticsInstanceView_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.BootDiagnosticsInstanceView_STATUS) error
	AssignPropertiesTo(dst *v20201201s.BootDiagnosticsInstanceView_STATUS) error
}

type augmentConversionForDataDisk interface {
	AssignPropertiesFrom(src *v20201201s.DataDisk) error
	AssignPropertiesTo(dst *v20201201s.DataDisk) error
}

type augmentConversionForDataDisk_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.DataDisk_STATUS) error
	AssignPropertiesTo(dst *v20201201s.DataDisk_STATUS) error
}

type augmentConversionForDiskInstanceView_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.DiskInstanceView_STATUS) error
	AssignPropertiesTo(dst *v20201201s.DiskInstanceView_STATUS) error
}

type augmentConversionForImageReference interface {
	AssignPropertiesFrom(src *v20201201s.ImageReference) error
	AssignPropertiesTo(dst *v20201201s.ImageReference) error
}

type augmentConversionForImageReference_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.ImageReference_STATUS) error
	AssignPropertiesTo(dst *v20201201s.ImageReference_STATUS) error
}

type augmentConversionForInstanceViewStatus_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.InstanceViewStatus_STATUS) error
	AssignPropertiesTo(dst *v20201201s.InstanceViewStatus_STATUS) error
}

type augmentConversionForKeyVaultSecretReference_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.KeyVaultSecretReference_STATUS) error
	AssignPropertiesTo(dst *v20201201s.KeyVaultSecretReference_STATUS) error
}

type augmentConversionForLinuxConfiguration interface {
	AssignPropertiesFrom(src *v20201201s.LinuxConfiguration) error
	AssignPropertiesTo(dst *v20201201s.LinuxConfiguration) error
}

type augmentConversionForLinuxConfiguration_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.LinuxConfiguration_STATUS) error
	AssignPropertiesTo(dst *v20201201s.LinuxConfiguration_STATUS) error
}

type augmentConversionForMaintenanceRedeployStatus_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.MaintenanceRedeployStatus_STATUS) error
	AssignPropertiesTo(dst *v20201201s.MaintenanceRedeployStatus_STATUS) error
}

type augmentConversionForNetworkInterfaceReference interface {
	AssignPropertiesFrom(src *v20201201s.NetworkInterfaceReference) error
	AssignPropertiesTo(dst *v20201201s.NetworkInterfaceReference) error
}

type augmentConversionForNetworkInterfaceReference_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.NetworkInterfaceReference_STATUS) error
	AssignPropertiesTo(dst *v20201201s.NetworkInterfaceReference_STATUS) error
}

type augmentConversionForOSDisk interface {
	AssignPropertiesFrom(src *v20201201s.OSDisk) error
	AssignPropertiesTo(dst *v20201201s.OSDisk) error
}

type augmentConversionForOSDisk_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.OSDisk_STATUS) error
	AssignPropertiesTo(dst *v20201201s.OSDisk_STATUS) error
}

type augmentConversionForTerminateNotificationProfile interface {
	AssignPropertiesFrom(src *v20201201s.TerminateNotificationProfile) error
	AssignPropertiesTo(dst *v20201201s.TerminateNotificationProfile) error
}

type augmentConversionForTerminateNotificationProfile_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.TerminateNotificationProfile_STATUS) error
	AssignPropertiesTo(dst *v20201201s.TerminateNotificationProfile_STATUS) error
}

type augmentConversionForUefiSettings interface {
	AssignPropertiesFrom(src *v20201201s.UefiSettings) error
	AssignPropertiesTo(dst *v20201201s.UefiSettings) error
}

type augmentConversionForUefiSettings_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.UefiSettings_STATUS) error
	AssignPropertiesTo(dst *v20201201s.UefiSettings_STATUS) error
}

type augmentConversionForUserAssignedIdentityDetails interface {
	AssignPropertiesFrom(src *v20201201s.UserAssignedIdentityDetails) error
	AssignPropertiesTo(dst *v20201201s.UserAssignedIdentityDetails) error
}

type augmentConversionForVaultSecretGroup interface {
	AssignPropertiesFrom(src *v20201201s.VaultSecretGroup) error
	AssignPropertiesTo(dst *v20201201s.VaultSecretGroup) error
}

type augmentConversionForVaultSecretGroup_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.VaultSecretGroup_STATUS) error
	AssignPropertiesTo(dst *v20201201s.VaultSecretGroup_STATUS) error
}

type augmentConversionForVirtualMachineAgentInstanceView_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.VirtualMachineAgentInstanceView_STATUS) error
	AssignPropertiesTo(dst *v20201201s.VirtualMachineAgentInstanceView_STATUS) error
}

type augmentConversionForVirtualMachineExtensionInstanceView_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.VirtualMachineExtensionInstanceView_STATUS) error
	AssignPropertiesTo(dst *v20201201s.VirtualMachineExtensionInstanceView_STATUS) error
}

type augmentConversionForVirtualMachineHealthStatus_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.VirtualMachineHealthStatus_STATUS) error
	AssignPropertiesTo(dst *v20201201s.VirtualMachineHealthStatus_STATUS) error
}

type augmentConversionForVirtualMachineIdentity_UserAssignedIdentities_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.VirtualMachineIdentity_UserAssignedIdentities_STATUS) error
	AssignPropertiesTo(dst *v20201201s.VirtualMachineIdentity_UserAssignedIdentities_STATUS) error
}

type augmentConversionForVirtualMachineNetworkInterfaceConfiguration interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineNetworkInterfaceConfiguration) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineNetworkInterfaceConfiguration) error
}

type augmentConversionForVirtualMachineNetworkInterfaceConfiguration_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineNetworkInterfaceConfiguration_STATUS) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineNetworkInterfaceConfiguration_STATUS) error
}

type augmentConversionForVirtualMachinePatchStatus_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.VirtualMachinePatchStatus_STATUS) error
	AssignPropertiesTo(dst *v20201201s.VirtualMachinePatchStatus_STATUS) error
}

type augmentConversionForVMGalleryApplication interface {
	AssignPropertiesFrom(src *v20220301s.VMGalleryApplication) error
	AssignPropertiesTo(dst *v20220301s.VMGalleryApplication) error
}

type augmentConversionForVMGalleryApplication_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.VMGalleryApplication_STATUS) error
	AssignPropertiesTo(dst *v20220301s.VMGalleryApplication_STATUS) error
}

type augmentConversionForVMSizeProperties interface {
	AssignPropertiesFrom(src *v20220301s.VMSizeProperties) error
	AssignPropertiesTo(dst *v20220301s.VMSizeProperties) error
}

type augmentConversionForVMSizeProperties_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.VMSizeProperties_STATUS) error
	AssignPropertiesTo(dst *v20220301s.VMSizeProperties_STATUS) error
}

type augmentConversionForWindowsConfiguration interface {
	AssignPropertiesFrom(src *v20201201s.WindowsConfiguration) error
	AssignPropertiesTo(dst *v20201201s.WindowsConfiguration) error
}

type augmentConversionForWindowsConfiguration_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.WindowsConfiguration_STATUS) error
	AssignPropertiesTo(dst *v20201201s.WindowsConfiguration_STATUS) error
}

// Storage version of v1beta20220301.AvailablePatchSummary_STATUS
// Deprecated version of AvailablePatchSummary_STATUS. Use v1api20220301.AvailablePatchSummary_STATUS instead
type AvailablePatchSummary_STATUS struct {
	AssessmentActivityId          *string                `json:"assessmentActivityId,omitempty"`
	CriticalAndSecurityPatchCount *int                   `json:"criticalAndSecurityPatchCount,omitempty"`
	Error                         *ApiError_STATUS       `json:"error,omitempty"`
	LastModifiedTime              *string                `json:"lastModifiedTime,omitempty"`
	OtherPatchCount               *int                   `json:"otherPatchCount,omitempty"`
	PropertyBag                   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	RebootPending                 *bool                  `json:"rebootPending,omitempty"`
	StartTime                     *string                `json:"startTime,omitempty"`
	Status                        *string                `json:"status,omitempty"`
}

// AssignProperties_From_AvailablePatchSummary_STATUS populates our AvailablePatchSummary_STATUS from the provided source AvailablePatchSummary_STATUS
func (summary *AvailablePatchSummary_STATUS) AssignProperties_From_AvailablePatchSummary_STATUS(source *v20201201s.AvailablePatchSummary_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AssessmentActivityId
	summary.AssessmentActivityId = genruntime.ClonePointerToString(source.AssessmentActivityId)

	// CriticalAndSecurityPatchCount
	summary.CriticalAndSecurityPatchCount = genruntime.ClonePointerToInt(source.CriticalAndSecurityPatchCount)

	// Error
	if source.Error != nil {
		var error ApiError_STATUS
		err := error.AssignProperties_From_ApiError_STATUS(source.Error)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ApiError_STATUS() to populate field Error")
		}
		summary.Error = &error
	} else {
		summary.Error = nil
	}

	// LastModifiedTime
	summary.LastModifiedTime = genruntime.ClonePointerToString(source.LastModifiedTime)

	// OtherPatchCount
	summary.OtherPatchCount = genruntime.ClonePointerToInt(source.OtherPatchCount)

	// RebootPending
	if source.RebootPending != nil {
		rebootPending := *source.RebootPending
		summary.RebootPending = &rebootPending
	} else {
		summary.RebootPending = nil
	}

	// StartTime
	summary.StartTime = genruntime.ClonePointerToString(source.StartTime)

	// Status
	summary.Status = genruntime.ClonePointerToString(source.Status)

	// Update the property bag
	if len(propertyBag) > 0 {
		summary.PropertyBag = propertyBag
	} else {
		summary.PropertyBag = nil
	}

	// Invoke the augmentConversionForAvailablePatchSummary_STATUS interface (if implemented) to customize the conversion
	var summaryAsAny any = summary
	if augmentedSummary, ok := summaryAsAny.(augmentConversionForAvailablePatchSummary_STATUS); ok {
		err := augmentedSummary.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AvailablePatchSummary_STATUS populates the provided destination AvailablePatchSummary_STATUS from our AvailablePatchSummary_STATUS
func (summary *AvailablePatchSummary_STATUS) AssignProperties_To_AvailablePatchSummary_STATUS(destination *v20201201s.AvailablePatchSummary_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(summary.PropertyBag)

	// AssessmentActivityId
	destination.AssessmentActivityId = genruntime.ClonePointerToString(summary.AssessmentActivityId)

	// CriticalAndSecurityPatchCount
	destination.CriticalAndSecurityPatchCount = genruntime.ClonePointerToInt(summary.CriticalAndSecurityPatchCount)

	// Error
	if summary.Error != nil {
		var error v20201201s.ApiError_STATUS
		err := summary.Error.AssignProperties_To_ApiError_STATUS(&error)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ApiError_STATUS() to populate field Error")
		}
		destination.Error = &error
	} else {
		destination.Error = nil
	}

	// LastModifiedTime
	destination.LastModifiedTime = genruntime.ClonePointerToString(summary.LastModifiedTime)

	// OtherPatchCount
	destination.OtherPatchCount = genruntime.ClonePointerToInt(summary.OtherPatchCount)

	// RebootPending
	if summary.RebootPending != nil {
		rebootPending := *summary.RebootPending
		destination.RebootPending = &rebootPending
	} else {
		destination.RebootPending = nil
	}

	// StartTime
	destination.StartTime = genruntime.ClonePointerToString(summary.StartTime)

	// Status
	destination.Status = genruntime.ClonePointerToString(summary.Status)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAvailablePatchSummary_STATUS interface (if implemented) to customize the conversion
	var summaryAsAny any = summary
	if augmentedSummary, ok := summaryAsAny.(augmentConversionForAvailablePatchSummary_STATUS); ok {
		err := augmentedSummary.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.DiffDiskSettings
// Deprecated version of DiffDiskSettings. Use v1api20220301.DiffDiskSettings instead
type DiffDiskSettings struct {
	Option      *string                `json:"option,omitempty"`
	Placement   *string                `json:"placement,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DiffDiskSettings populates our DiffDiskSettings from the provided source DiffDiskSettings
func (settings *DiffDiskSettings) AssignProperties_From_DiffDiskSettings(source *v20201201s.DiffDiskSettings) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Option
	settings.Option = genruntime.ClonePointerToString(source.Option)

	// Placement
	settings.Placement = genruntime.ClonePointerToString(source.Placement)

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// Invoke the augmentConversionForDiffDiskSettings interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForDiffDiskSettings); ok {
		err := augmentedSettings.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DiffDiskSettings populates the provided destination DiffDiskSettings from our DiffDiskSettings
func (settings *DiffDiskSettings) AssignProperties_To_DiffDiskSettings(destination *v20201201s.DiffDiskSettings) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// Option
	destination.Option = genruntime.ClonePointerToString(settings.Option)

	// Placement
	destination.Placement = genruntime.ClonePointerToString(settings.Placement)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDiffDiskSettings interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForDiffDiskSettings); ok {
		err := augmentedSettings.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.DiffDiskSettings_STATUS
// Deprecated version of DiffDiskSettings_STATUS. Use v1api20220301.DiffDiskSettings_STATUS instead
type DiffDiskSettings_STATUS struct {
	Option      *string                `json:"option,omitempty"`
	Placement   *string                `json:"placement,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DiffDiskSettings_STATUS populates our DiffDiskSettings_STATUS from the provided source DiffDiskSettings_STATUS
func (settings *DiffDiskSettings_STATUS) AssignProperties_From_DiffDiskSettings_STATUS(source *v20201201s.DiffDiskSettings_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Option
	settings.Option = genruntime.ClonePointerToString(source.Option)

	// Placement
	settings.Placement = genruntime.ClonePointerToString(source.Placement)

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// Invoke the augmentConversionForDiffDiskSettings_STATUS interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForDiffDiskSettings_STATUS); ok {
		err := augmentedSettings.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DiffDiskSettings_STATUS populates the provided destination DiffDiskSettings_STATUS from our DiffDiskSettings_STATUS
func (settings *DiffDiskSettings_STATUS) AssignProperties_To_DiffDiskSettings_STATUS(destination *v20201201s.DiffDiskSettings_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// Option
	destination.Option = genruntime.ClonePointerToString(settings.Option)

	// Placement
	destination.Placement = genruntime.ClonePointerToString(settings.Placement)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDiffDiskSettings_STATUS interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForDiffDiskSettings_STATUS); ok {
		err := augmentedSettings.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.DiskEncryptionSettings
// Deprecated version of DiskEncryptionSettings. Use v1api20220301.DiskEncryptionSettings instead
type DiskEncryptionSettings struct {
	DiskEncryptionKey *KeyVaultSecretReference `json:"diskEncryptionKey,omitempty"`
	Enabled           *bool                    `json:"enabled,omitempty"`
	KeyEncryptionKey  *KeyVaultKeyReference    `json:"keyEncryptionKey,omitempty"`
	PropertyBag       genruntime.PropertyBag   `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DiskEncryptionSettings populates our DiskEncryptionSettings from the provided source DiskEncryptionSettings
func (settings *DiskEncryptionSettings) AssignProperties_From_DiskEncryptionSettings(source *v20201201s.DiskEncryptionSettings) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DiskEncryptionKey
	if source.DiskEncryptionKey != nil {
		var diskEncryptionKey KeyVaultSecretReference
		err := diskEncryptionKey.AssignProperties_From_KeyVaultSecretReference(source.DiskEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_KeyVaultSecretReference() to populate field DiskEncryptionKey")
		}
		settings.DiskEncryptionKey = &diskEncryptionKey
	} else {
		settings.DiskEncryptionKey = nil
	}

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		settings.Enabled = &enabled
	} else {
		settings.Enabled = nil
	}

	// KeyEncryptionKey
	if source.KeyEncryptionKey != nil {
		var keyEncryptionKey KeyVaultKeyReference
		err := keyEncryptionKey.AssignProperties_From_KeyVaultKeyReference(source.KeyEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_KeyVaultKeyReference() to populate field KeyEncryptionKey")
		}
		settings.KeyEncryptionKey = &keyEncryptionKey
	} else {
		settings.KeyEncryptionKey = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// Invoke the augmentConversionForDiskEncryptionSettings interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForDiskEncryptionSettings); ok {
		err := augmentedSettings.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DiskEncryptionSettings populates the provided destination DiskEncryptionSettings from our DiskEncryptionSettings
func (settings *DiskEncryptionSettings) AssignProperties_To_DiskEncryptionSettings(destination *v20201201s.DiskEncryptionSettings) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// DiskEncryptionKey
	if settings.DiskEncryptionKey != nil {
		var diskEncryptionKey v20201201s.KeyVaultSecretReference
		err := settings.DiskEncryptionKey.AssignProperties_To_KeyVaultSecretReference(&diskEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_KeyVaultSecretReference() to populate field DiskEncryptionKey")
		}
		destination.DiskEncryptionKey = &diskEncryptionKey
	} else {
		destination.DiskEncryptionKey = nil
	}

	// Enabled
	if settings.Enabled != nil {
		enabled := *settings.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// KeyEncryptionKey
	if settings.KeyEncryptionKey != nil {
		var keyEncryptionKey v20201201s.KeyVaultKeyReference
		err := settings.KeyEncryptionKey.AssignProperties_To_KeyVaultKeyReference(&keyEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_KeyVaultKeyReference() to populate field KeyEncryptionKey")
		}
		destination.KeyEncryptionKey = &keyEncryptionKey
	} else {
		destination.KeyEncryptionKey = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDiskEncryptionSettings interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForDiskEncryptionSettings); ok {
		err := augmentedSettings.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.DiskEncryptionSettings_STATUS
// Deprecated version of DiskEncryptionSettings_STATUS. Use v1api20220301.DiskEncryptionSettings_STATUS instead
type DiskEncryptionSettings_STATUS struct {
	DiskEncryptionKey *KeyVaultSecretReference_STATUS `json:"diskEncryptionKey,omitempty"`
	Enabled           *bool                           `json:"enabled,omitempty"`
	KeyEncryptionKey  *KeyVaultKeyReference_STATUS    `json:"keyEncryptionKey,omitempty"`
	PropertyBag       genruntime.PropertyBag          `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DiskEncryptionSettings_STATUS populates our DiskEncryptionSettings_STATUS from the provided source DiskEncryptionSettings_STATUS
func (settings *DiskEncryptionSettings_STATUS) AssignProperties_From_DiskEncryptionSettings_STATUS(source *v20201201s.DiskEncryptionSettings_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DiskEncryptionKey
	if source.DiskEncryptionKey != nil {
		var diskEncryptionKey KeyVaultSecretReference_STATUS
		err := diskEncryptionKey.AssignProperties_From_KeyVaultSecretReference_STATUS(source.DiskEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_KeyVaultSecretReference_STATUS() to populate field DiskEncryptionKey")
		}
		settings.DiskEncryptionKey = &diskEncryptionKey
	} else {
		settings.DiskEncryptionKey = nil
	}

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		settings.Enabled = &enabled
	} else {
		settings.Enabled = nil
	}

	// KeyEncryptionKey
	if source.KeyEncryptionKey != nil {
		var keyEncryptionKey KeyVaultKeyReference_STATUS
		err := keyEncryptionKey.AssignProperties_From_KeyVaultKeyReference_STATUS(source.KeyEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_KeyVaultKeyReference_STATUS() to populate field KeyEncryptionKey")
		}
		settings.KeyEncryptionKey = &keyEncryptionKey
	} else {
		settings.KeyEncryptionKey = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// Invoke the augmentConversionForDiskEncryptionSettings_STATUS interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForDiskEncryptionSettings_STATUS); ok {
		err := augmentedSettings.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DiskEncryptionSettings_STATUS populates the provided destination DiskEncryptionSettings_STATUS from our DiskEncryptionSettings_STATUS
func (settings *DiskEncryptionSettings_STATUS) AssignProperties_To_DiskEncryptionSettings_STATUS(destination *v20201201s.DiskEncryptionSettings_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// DiskEncryptionKey
	if settings.DiskEncryptionKey != nil {
		var diskEncryptionKey v20201201s.KeyVaultSecretReference_STATUS
		err := settings.DiskEncryptionKey.AssignProperties_To_KeyVaultSecretReference_STATUS(&diskEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_KeyVaultSecretReference_STATUS() to populate field DiskEncryptionKey")
		}
		destination.DiskEncryptionKey = &diskEncryptionKey
	} else {
		destination.DiskEncryptionKey = nil
	}

	// Enabled
	if settings.Enabled != nil {
		enabled := *settings.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// KeyEncryptionKey
	if settings.KeyEncryptionKey != nil {
		var keyEncryptionKey v20201201s.KeyVaultKeyReference_STATUS
		err := settings.KeyEncryptionKey.AssignProperties_To_KeyVaultKeyReference_STATUS(&keyEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_KeyVaultKeyReference_STATUS() to populate field KeyEncryptionKey")
		}
		destination.KeyEncryptionKey = &keyEncryptionKey
	} else {
		destination.KeyEncryptionKey = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDiskEncryptionSettings_STATUS interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForDiskEncryptionSettings_STATUS); ok {
		err := augmentedSettings.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.LastPatchInstallationSummary_STATUS
// Deprecated version of LastPatchInstallationSummary_STATUS. Use v1api20220301.LastPatchInstallationSummary_STATUS instead
type LastPatchInstallationSummary_STATUS struct {
	Error                     *ApiError_STATUS       `json:"error,omitempty"`
	ExcludedPatchCount        *int                   `json:"excludedPatchCount,omitempty"`
	FailedPatchCount          *int                   `json:"failedPatchCount,omitempty"`
	InstallationActivityId    *string                `json:"installationActivityId,omitempty"`
	InstalledPatchCount       *int                   `json:"installedPatchCount,omitempty"`
	LastModifiedTime          *string                `json:"lastModifiedTime,omitempty"`
	MaintenanceWindowExceeded *bool                  `json:"maintenanceWindowExceeded,omitempty"`
	NotSelectedPatchCount     *int                   `json:"notSelectedPatchCount,omitempty"`
	PendingPatchCount         *int                   `json:"pendingPatchCount,omitempty"`
	PropertyBag               genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	StartTime                 *string                `json:"startTime,omitempty"`
	Status                    *string                `json:"status,omitempty"`
}

// AssignProperties_From_LastPatchInstallationSummary_STATUS populates our LastPatchInstallationSummary_STATUS from the provided source LastPatchInstallationSummary_STATUS
func (summary *LastPatchInstallationSummary_STATUS) AssignProperties_From_LastPatchInstallationSummary_STATUS(source *v20201201s.LastPatchInstallationSummary_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Error
	if source.Error != nil {
		var error ApiError_STATUS
		err := error.AssignProperties_From_ApiError_STATUS(source.Error)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ApiError_STATUS() to populate field Error")
		}
		summary.Error = &error
	} else {
		summary.Error = nil
	}

	// ExcludedPatchCount
	summary.ExcludedPatchCount = genruntime.ClonePointerToInt(source.ExcludedPatchCount)

	// FailedPatchCount
	summary.FailedPatchCount = genruntime.ClonePointerToInt(source.FailedPatchCount)

	// InstallationActivityId
	summary.InstallationActivityId = genruntime.ClonePointerToString(source.InstallationActivityId)

	// InstalledPatchCount
	summary.InstalledPatchCount = genruntime.ClonePointerToInt(source.InstalledPatchCount)

	// LastModifiedTime
	summary.LastModifiedTime = genruntime.ClonePointerToString(source.LastModifiedTime)

	// MaintenanceWindowExceeded
	if source.MaintenanceWindowExceeded != nil {
		maintenanceWindowExceeded := *source.MaintenanceWindowExceeded
		summary.MaintenanceWindowExceeded = &maintenanceWindowExceeded
	} else {
		summary.MaintenanceWindowExceeded = nil
	}

	// NotSelectedPatchCount
	summary.NotSelectedPatchCount = genruntime.ClonePointerToInt(source.NotSelectedPatchCount)

	// PendingPatchCount
	summary.PendingPatchCount = genruntime.ClonePointerToInt(source.PendingPatchCount)

	// StartTime
	summary.StartTime = genruntime.ClonePointerToString(source.StartTime)

	// Status
	summary.Status = genruntime.ClonePointerToString(source.Status)

	// Update the property bag
	if len(propertyBag) > 0 {
		summary.PropertyBag = propertyBag
	} else {
		summary.PropertyBag = nil
	}

	// Invoke the augmentConversionForLastPatchInstallationSummary_STATUS interface (if implemented) to customize the conversion
	var summaryAsAny any = summary
	if augmentedSummary, ok := summaryAsAny.(augmentConversionForLastPatchInstallationSummary_STATUS); ok {
		err := augmentedSummary.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_LastPatchInstallationSummary_STATUS populates the provided destination LastPatchInstallationSummary_STATUS from our LastPatchInstallationSummary_STATUS
func (summary *LastPatchInstallationSummary_STATUS) AssignProperties_To_LastPatchInstallationSummary_STATUS(destination *v20201201s.LastPatchInstallationSummary_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(summary.PropertyBag)

	// Error
	if summary.Error != nil {
		var error v20201201s.ApiError_STATUS
		err := summary.Error.AssignProperties_To_ApiError_STATUS(&error)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ApiError_STATUS() to populate field Error")
		}
		destination.Error = &error
	} else {
		destination.Error = nil
	}

	// ExcludedPatchCount
	destination.ExcludedPatchCount = genruntime.ClonePointerToInt(summary.ExcludedPatchCount)

	// FailedPatchCount
	destination.FailedPatchCount = genruntime.ClonePointerToInt(summary.FailedPatchCount)

	// InstallationActivityId
	destination.InstallationActivityId = genruntime.ClonePointerToString(summary.InstallationActivityId)

	// InstalledPatchCount
	destination.InstalledPatchCount = genruntime.ClonePointerToInt(summary.InstalledPatchCount)

	// LastModifiedTime
	destination.LastModifiedTime = genruntime.ClonePointerToString(summary.LastModifiedTime)

	// MaintenanceWindowExceeded
	if summary.MaintenanceWindowExceeded != nil {
		maintenanceWindowExceeded := *summary.MaintenanceWindowExceeded
		destination.MaintenanceWindowExceeded = &maintenanceWindowExceeded
	} else {
		destination.MaintenanceWindowExceeded = nil
	}

	// NotSelectedPatchCount
	destination.NotSelectedPatchCount = genruntime.ClonePointerToInt(summary.NotSelectedPatchCount)

	// PendingPatchCount
	destination.PendingPatchCount = genruntime.ClonePointerToInt(summary.PendingPatchCount)

	// StartTime
	destination.StartTime = genruntime.ClonePointerToString(summary.StartTime)

	// Status
	destination.Status = genruntime.ClonePointerToString(summary.Status)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForLastPatchInstallationSummary_STATUS interface (if implemented) to customize the conversion
	var summaryAsAny any = summary
	if augmentedSummary, ok := summaryAsAny.(augmentConversionForLastPatchInstallationSummary_STATUS); ok {
		err := augmentedSummary.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.LinuxPatchSettings
// Deprecated version of LinuxPatchSettings. Use v1api20220301.LinuxPatchSettings instead
type LinuxPatchSettings struct {
	AssessmentMode              *string                                       `json:"assessmentMode,omitempty"`
	AutomaticByPlatformSettings *LinuxVMGuestPatchAutomaticByPlatformSettings `json:"automaticByPlatformSettings,omitempty"`
	PatchMode                   *string                                       `json:"patchMode,omitempty"`
	PropertyBag                 genruntime.PropertyBag                        `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_LinuxPatchSettings populates our LinuxPatchSettings from the provided source LinuxPatchSettings
func (settings *LinuxPatchSettings) AssignProperties_From_LinuxPatchSettings(source *v20201201s.LinuxPatchSettings) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AssessmentMode
	if propertyBag.Contains("AssessmentMode") {
		var assessmentMode string
		err := propertyBag.Pull("AssessmentMode", &assessmentMode)
		if err != nil {
			return errors.Wrap(err, "pulling 'AssessmentMode' from propertyBag")
		}

		settings.AssessmentMode = &assessmentMode
	} else {
		settings.AssessmentMode = nil
	}

	// AutomaticByPlatformSettings
	if propertyBag.Contains("AutomaticByPlatformSettings") {
		var automaticByPlatformSetting LinuxVMGuestPatchAutomaticByPlatformSettings
		err := propertyBag.Pull("AutomaticByPlatformSettings", &automaticByPlatformSetting)
		if err != nil {
			return errors.Wrap(err, "pulling 'AutomaticByPlatformSettings' from propertyBag")
		}

		settings.AutomaticByPlatformSettings = &automaticByPlatformSetting
	} else {
		settings.AutomaticByPlatformSettings = nil
	}

	// PatchMode
	settings.PatchMode = genruntime.ClonePointerToString(source.PatchMode)

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// Invoke the augmentConversionForLinuxPatchSettings interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForLinuxPatchSettings); ok {
		err := augmentedSettings.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_LinuxPatchSettings populates the provided destination LinuxPatchSettings from our LinuxPatchSettings
func (settings *LinuxPatchSettings) AssignProperties_To_LinuxPatchSettings(destination *v20201201s.LinuxPatchSettings) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// AssessmentMode
	if settings.AssessmentMode != nil {
		propertyBag.Add("AssessmentMode", *settings.AssessmentMode)
	} else {
		propertyBag.Remove("AssessmentMode")
	}

	// AutomaticByPlatformSettings
	if settings.AutomaticByPlatformSettings != nil {
		propertyBag.Add("AutomaticByPlatformSettings", *settings.AutomaticByPlatformSettings)
	} else {
		propertyBag.Remove("AutomaticByPlatformSettings")
	}

	// PatchMode
	destination.PatchMode = genruntime.ClonePointerToString(settings.PatchMode)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForLinuxPatchSettings interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForLinuxPatchSettings); ok {
		err := augmentedSettings.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.LinuxPatchSettings_STATUS
// Deprecated version of LinuxPatchSettings_STATUS. Use v1api20220301.LinuxPatchSettings_STATUS instead
type LinuxPatchSettings_STATUS struct {
	AssessmentMode              *string                                              `json:"assessmentMode,omitempty"`
	AutomaticByPlatformSettings *LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS `json:"automaticByPlatformSettings,omitempty"`
	PatchMode                   *string                                              `json:"patchMode,omitempty"`
	PropertyBag                 genruntime.PropertyBag                               `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_LinuxPatchSettings_STATUS populates our LinuxPatchSettings_STATUS from the provided source LinuxPatchSettings_STATUS
func (settings *LinuxPatchSettings_STATUS) AssignProperties_From_LinuxPatchSettings_STATUS(source *v20201201s.LinuxPatchSettings_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AssessmentMode
	if propertyBag.Contains("AssessmentMode") {
		var assessmentMode string
		err := propertyBag.Pull("AssessmentMode", &assessmentMode)
		if err != nil {
			return errors.Wrap(err, "pulling 'AssessmentMode' from propertyBag")
		}

		settings.AssessmentMode = &assessmentMode
	} else {
		settings.AssessmentMode = nil
	}

	// AutomaticByPlatformSettings
	if propertyBag.Contains("AutomaticByPlatformSettings") {
		var automaticByPlatformSetting LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS
		err := propertyBag.Pull("AutomaticByPlatformSettings", &automaticByPlatformSetting)
		if err != nil {
			return errors.Wrap(err, "pulling 'AutomaticByPlatformSettings' from propertyBag")
		}

		settings.AutomaticByPlatformSettings = &automaticByPlatformSetting
	} else {
		settings.AutomaticByPlatformSettings = nil
	}

	// PatchMode
	settings.PatchMode = genruntime.ClonePointerToString(source.PatchMode)

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// Invoke the augmentConversionForLinuxPatchSettings_STATUS interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForLinuxPatchSettings_STATUS); ok {
		err := augmentedSettings.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_LinuxPatchSettings_STATUS populates the provided destination LinuxPatchSettings_STATUS from our LinuxPatchSettings_STATUS
func (settings *LinuxPatchSettings_STATUS) AssignProperties_To_LinuxPatchSettings_STATUS(destination *v20201201s.LinuxPatchSettings_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// AssessmentMode
	if settings.AssessmentMode != nil {
		propertyBag.Add("AssessmentMode", *settings.AssessmentMode)
	} else {
		propertyBag.Remove("AssessmentMode")
	}

	// AutomaticByPlatformSettings
	if settings.AutomaticByPlatformSettings != nil {
		propertyBag.Add("AutomaticByPlatformSettings", *settings.AutomaticByPlatformSettings)
	} else {
		propertyBag.Remove("AutomaticByPlatformSettings")
	}

	// PatchMode
	destination.PatchMode = genruntime.ClonePointerToString(settings.PatchMode)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForLinuxPatchSettings_STATUS interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForLinuxPatchSettings_STATUS); ok {
		err := augmentedSettings.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.ManagedDiskParameters
// Deprecated version of ManagedDiskParameters. Use v1api20220301.ManagedDiskParameters instead
type ManagedDiskParameters struct {
	DiskEncryptionSet  *SubResource                  `json:"diskEncryptionSet,omitempty"`
	PropertyBag        genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
	Reference          *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
	SecurityProfile    *VMDiskSecurityProfile        `json:"securityProfile,omitempty"`
	StorageAccountType *string                       `json:"storageAccountType,omitempty"`
}

// AssignProperties_From_ManagedDiskParameters populates our ManagedDiskParameters from the provided source ManagedDiskParameters
func (parameters *ManagedDiskParameters) AssignProperties_From_ManagedDiskParameters(source *v20201201s.ManagedDiskParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DiskEncryptionSet
	if source.DiskEncryptionSet != nil {
		var diskEncryptionSet SubResource
		err := diskEncryptionSet.AssignProperties_From_SubResource(source.DiskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field DiskEncryptionSet")
		}
		parameters.DiskEncryptionSet = &diskEncryptionSet
	} else {
		parameters.DiskEncryptionSet = nil
	}

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		parameters.Reference = &reference
	} else {
		parameters.Reference = nil
	}

	// SecurityProfile
	if propertyBag.Contains("SecurityProfile") {
		var securityProfile VMDiskSecurityProfile
		err := propertyBag.Pull("SecurityProfile", &securityProfile)
		if err != nil {
			return errors.Wrap(err, "pulling 'SecurityProfile' from propertyBag")
		}

		parameters.SecurityProfile = &securityProfile
	} else {
		parameters.SecurityProfile = nil
	}

	// StorageAccountType
	parameters.StorageAccountType = genruntime.ClonePointerToString(source.StorageAccountType)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForManagedDiskParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForManagedDiskParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedDiskParameters populates the provided destination ManagedDiskParameters from our ManagedDiskParameters
func (parameters *ManagedDiskParameters) AssignProperties_To_ManagedDiskParameters(destination *v20201201s.ManagedDiskParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// DiskEncryptionSet
	if parameters.DiskEncryptionSet != nil {
		var diskEncryptionSet v20201201s.SubResource
		err := parameters.DiskEncryptionSet.AssignProperties_To_SubResource(&diskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field DiskEncryptionSet")
		}
		destination.DiskEncryptionSet = &diskEncryptionSet
	} else {
		destination.DiskEncryptionSet = nil
	}

	// Reference
	if parameters.Reference != nil {
		reference := parameters.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// SecurityProfile
	if parameters.SecurityProfile != nil {
		propertyBag.Add("SecurityProfile", *parameters.SecurityProfile)
	} else {
		propertyBag.Remove("SecurityProfile")
	}

	// StorageAccountType
	destination.StorageAccountType = genruntime.ClonePointerToString(parameters.StorageAccountType)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForManagedDiskParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForManagedDiskParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.ManagedDiskParameters_STATUS
// Deprecated version of ManagedDiskParameters_STATUS. Use v1api20220301.ManagedDiskParameters_STATUS instead
type ManagedDiskParameters_STATUS struct {
	DiskEncryptionSet  *SubResource_STATUS           `json:"diskEncryptionSet,omitempty"`
	Id                 *string                       `json:"id,omitempty"`
	PropertyBag        genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
	SecurityProfile    *VMDiskSecurityProfile_STATUS `json:"securityProfile,omitempty"`
	StorageAccountType *string                       `json:"storageAccountType,omitempty"`
}

// AssignProperties_From_ManagedDiskParameters_STATUS populates our ManagedDiskParameters_STATUS from the provided source ManagedDiskParameters_STATUS
func (parameters *ManagedDiskParameters_STATUS) AssignProperties_From_ManagedDiskParameters_STATUS(source *v20201201s.ManagedDiskParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DiskEncryptionSet
	if source.DiskEncryptionSet != nil {
		var diskEncryptionSet SubResource_STATUS
		err := diskEncryptionSet.AssignProperties_From_SubResource_STATUS(source.DiskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field DiskEncryptionSet")
		}
		parameters.DiskEncryptionSet = &diskEncryptionSet
	} else {
		parameters.DiskEncryptionSet = nil
	}

	// Id
	parameters.Id = genruntime.ClonePointerToString(source.Id)

	// SecurityProfile
	if propertyBag.Contains("SecurityProfile") {
		var securityProfile VMDiskSecurityProfile_STATUS
		err := propertyBag.Pull("SecurityProfile", &securityProfile)
		if err != nil {
			return errors.Wrap(err, "pulling 'SecurityProfile' from propertyBag")
		}

		parameters.SecurityProfile = &securityProfile
	} else {
		parameters.SecurityProfile = nil
	}

	// StorageAccountType
	parameters.StorageAccountType = genruntime.ClonePointerToString(source.StorageAccountType)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForManagedDiskParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForManagedDiskParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedDiskParameters_STATUS populates the provided destination ManagedDiskParameters_STATUS from our ManagedDiskParameters_STATUS
func (parameters *ManagedDiskParameters_STATUS) AssignProperties_To_ManagedDiskParameters_STATUS(destination *v20201201s.ManagedDiskParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// DiskEncryptionSet
	if parameters.DiskEncryptionSet != nil {
		var diskEncryptionSet v20201201s.SubResource_STATUS
		err := parameters.DiskEncryptionSet.AssignProperties_To_SubResource_STATUS(&diskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field DiskEncryptionSet")
		}
		destination.DiskEncryptionSet = &diskEncryptionSet
	} else {
		destination.DiskEncryptionSet = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(parameters.Id)

	// SecurityProfile
	if parameters.SecurityProfile != nil {
		propertyBag.Add("SecurityProfile", *parameters.SecurityProfile)
	} else {
		propertyBag.Remove("SecurityProfile")
	}

	// StorageAccountType
	destination.StorageAccountType = genruntime.ClonePointerToString(parameters.StorageAccountType)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForManagedDiskParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForManagedDiskParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.PatchSettings
// Deprecated version of PatchSettings. Use v1api20220301.PatchSettings instead
type PatchSettings struct {
	AssessmentMode              *string                                         `json:"assessmentMode,omitempty"`
	AutomaticByPlatformSettings *WindowsVMGuestPatchAutomaticByPlatformSettings `json:"automaticByPlatformSettings,omitempty"`
	EnableHotpatching           *bool                                           `json:"enableHotpatching,omitempty"`
	PatchMode                   *string                                         `json:"patchMode,omitempty"`
	PropertyBag                 genruntime.PropertyBag                          `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_PatchSettings populates our PatchSettings from the provided source PatchSettings
func (settings *PatchSettings) AssignProperties_From_PatchSettings(source *v20201201s.PatchSettings) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AssessmentMode
	if propertyBag.Contains("AssessmentMode") {
		var assessmentMode string
		err := propertyBag.Pull("AssessmentMode", &assessmentMode)
		if err != nil {
			return errors.Wrap(err, "pulling 'AssessmentMode' from propertyBag")
		}

		settings.AssessmentMode = &assessmentMode
	} else {
		settings.AssessmentMode = nil
	}

	// AutomaticByPlatformSettings
	if propertyBag.Contains("AutomaticByPlatformSettings") {
		var automaticByPlatformSetting WindowsVMGuestPatchAutomaticByPlatformSettings
		err := propertyBag.Pull("AutomaticByPlatformSettings", &automaticByPlatformSetting)
		if err != nil {
			return errors.Wrap(err, "pulling 'AutomaticByPlatformSettings' from propertyBag")
		}

		settings.AutomaticByPlatformSettings = &automaticByPlatformSetting
	} else {
		settings.AutomaticByPlatformSettings = nil
	}

	// EnableHotpatching
	if source.EnableHotpatching != nil {
		enableHotpatching := *source.EnableHotpatching
		settings.EnableHotpatching = &enableHotpatching
	} else {
		settings.EnableHotpatching = nil
	}

	// PatchMode
	settings.PatchMode = genruntime.ClonePointerToString(source.PatchMode)

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// Invoke the augmentConversionForPatchSettings interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForPatchSettings); ok {
		err := augmentedSettings.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_PatchSettings populates the provided destination PatchSettings from our PatchSettings
func (settings *PatchSettings) AssignProperties_To_PatchSettings(destination *v20201201s.PatchSettings) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// AssessmentMode
	if settings.AssessmentMode != nil {
		propertyBag.Add("AssessmentMode", *settings.AssessmentMode)
	} else {
		propertyBag.Remove("AssessmentMode")
	}

	// AutomaticByPlatformSettings
	if settings.AutomaticByPlatformSettings != nil {
		propertyBag.Add("AutomaticByPlatformSettings", *settings.AutomaticByPlatformSettings)
	} else {
		propertyBag.Remove("AutomaticByPlatformSettings")
	}

	// EnableHotpatching
	if settings.EnableHotpatching != nil {
		enableHotpatching := *settings.EnableHotpatching
		destination.EnableHotpatching = &enableHotpatching
	} else {
		destination.EnableHotpatching = nil
	}

	// PatchMode
	destination.PatchMode = genruntime.ClonePointerToString(settings.PatchMode)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForPatchSettings interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForPatchSettings); ok {
		err := augmentedSettings.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.PatchSettings_STATUS
// Deprecated version of PatchSettings_STATUS. Use v1api20220301.PatchSettings_STATUS instead
type PatchSettings_STATUS struct {
	AssessmentMode              *string                                                `json:"assessmentMode,omitempty"`
	AutomaticByPlatformSettings *WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS `json:"automaticByPlatformSettings,omitempty"`
	EnableHotpatching           *bool                                                  `json:"enableHotpatching,omitempty"`
	PatchMode                   *string                                                `json:"patchMode,omitempty"`
	PropertyBag                 genruntime.PropertyBag                                 `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_PatchSettings_STATUS populates our PatchSettings_STATUS from the provided source PatchSettings_STATUS
func (settings *PatchSettings_STATUS) AssignProperties_From_PatchSettings_STATUS(source *v20201201s.PatchSettings_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AssessmentMode
	if propertyBag.Contains("AssessmentMode") {
		var assessmentMode string
		err := propertyBag.Pull("AssessmentMode", &assessmentMode)
		if err != nil {
			return errors.Wrap(err, "pulling 'AssessmentMode' from propertyBag")
		}

		settings.AssessmentMode = &assessmentMode
	} else {
		settings.AssessmentMode = nil
	}

	// AutomaticByPlatformSettings
	if propertyBag.Contains("AutomaticByPlatformSettings") {
		var automaticByPlatformSetting WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS
		err := propertyBag.Pull("AutomaticByPlatformSettings", &automaticByPlatformSetting)
		if err != nil {
			return errors.Wrap(err, "pulling 'AutomaticByPlatformSettings' from propertyBag")
		}

		settings.AutomaticByPlatformSettings = &automaticByPlatformSetting
	} else {
		settings.AutomaticByPlatformSettings = nil
	}

	// EnableHotpatching
	if source.EnableHotpatching != nil {
		enableHotpatching := *source.EnableHotpatching
		settings.EnableHotpatching = &enableHotpatching
	} else {
		settings.EnableHotpatching = nil
	}

	// PatchMode
	settings.PatchMode = genruntime.ClonePointerToString(source.PatchMode)

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// Invoke the augmentConversionForPatchSettings_STATUS interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForPatchSettings_STATUS); ok {
		err := augmentedSettings.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_PatchSettings_STATUS populates the provided destination PatchSettings_STATUS from our PatchSettings_STATUS
func (settings *PatchSettings_STATUS) AssignProperties_To_PatchSettings_STATUS(destination *v20201201s.PatchSettings_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// AssessmentMode
	if settings.AssessmentMode != nil {
		propertyBag.Add("AssessmentMode", *settings.AssessmentMode)
	} else {
		propertyBag.Remove("AssessmentMode")
	}

	// AutomaticByPlatformSettings
	if settings.AutomaticByPlatformSettings != nil {
		propertyBag.Add("AutomaticByPlatformSettings", *settings.AutomaticByPlatformSettings)
	} else {
		propertyBag.Remove("AutomaticByPlatformSettings")
	}

	// EnableHotpatching
	if settings.EnableHotpatching != nil {
		enableHotpatching := *settings.EnableHotpatching
		destination.EnableHotpatching = &enableHotpatching
	} else {
		destination.EnableHotpatching = nil
	}

	// PatchMode
	destination.PatchMode = genruntime.ClonePointerToString(settings.PatchMode)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForPatchSettings_STATUS interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForPatchSettings_STATUS); ok {
		err := augmentedSettings.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.SshConfiguration
// Deprecated version of SshConfiguration. Use v1api20220301.SshConfiguration instead
type SshConfiguration struct {
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	PublicKeys  []SshPublicKeySpec     `json:"publicKeys,omitempty"`
}

// AssignProperties_From_SshConfiguration populates our SshConfiguration from the provided source SshConfiguration
func (configuration *SshConfiguration) AssignProperties_From_SshConfiguration(source *v20201201s.SshConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// PublicKeys
	if source.PublicKeys != nil {
		publicKeyList := make([]SshPublicKeySpec, len(source.PublicKeys))
		for publicKeyIndex, publicKeyItem := range source.PublicKeys {
			// Shadow the loop variable to avoid aliasing
			publicKeyItem := publicKeyItem
			var publicKey SshPublicKeySpec
			err := publicKey.AssignProperties_From_SshPublicKeySpec(&publicKeyItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SshPublicKeySpec() to populate field PublicKeys")
			}
			publicKeyList[publicKeyIndex] = publicKey
		}
		configuration.PublicKeys = publicKeyList
	} else {
		configuration.PublicKeys = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// Invoke the augmentConversionForSshConfiguration interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForSshConfiguration); ok {
		err := augmentedConfiguration.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_SshConfiguration populates the provided destination SshConfiguration from our SshConfiguration
func (configuration *SshConfiguration) AssignProperties_To_SshConfiguration(destination *v20201201s.SshConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// PublicKeys
	if configuration.PublicKeys != nil {
		publicKeyList := make([]v20201201s.SshPublicKeySpec, len(configuration.PublicKeys))
		for publicKeyIndex, publicKeyItem := range configuration.PublicKeys {
			// Shadow the loop variable to avoid aliasing
			publicKeyItem := publicKeyItem
			var publicKey v20201201s.SshPublicKeySpec
			err := publicKeyItem.AssignProperties_To_SshPublicKeySpec(&publicKey)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SshPublicKeySpec() to populate field PublicKeys")
			}
			publicKeyList[publicKeyIndex] = publicKey
		}
		destination.PublicKeys = publicKeyList
	} else {
		destination.PublicKeys = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForSshConfiguration interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForSshConfiguration); ok {
		err := augmentedConfiguration.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.SshConfiguration_STATUS
// Deprecated version of SshConfiguration_STATUS. Use v1api20220301.SshConfiguration_STATUS instead
type SshConfiguration_STATUS struct {
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	PublicKeys  []SshPublicKey_STATUS  `json:"publicKeys,omitempty"`
}

// AssignProperties_From_SshConfiguration_STATUS populates our SshConfiguration_STATUS from the provided source SshConfiguration_STATUS
func (configuration *SshConfiguration_STATUS) AssignProperties_From_SshConfiguration_STATUS(source *v20201201s.SshConfiguration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// PublicKeys
	if source.PublicKeys != nil {
		publicKeyList := make([]SshPublicKey_STATUS, len(source.PublicKeys))
		for publicKeyIndex, publicKeyItem := range source.PublicKeys {
			// Shadow the loop variable to avoid aliasing
			publicKeyItem := publicKeyItem
			var publicKey SshPublicKey_STATUS
			err := publicKey.AssignProperties_From_SshPublicKey_STATUS(&publicKeyItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SshPublicKey_STATUS() to populate field PublicKeys")
			}
			publicKeyList[publicKeyIndex] = publicKey
		}
		configuration.PublicKeys = publicKeyList
	} else {
		configuration.PublicKeys = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// Invoke the augmentConversionForSshConfiguration_STATUS interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForSshConfiguration_STATUS); ok {
		err := augmentedConfiguration.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_SshConfiguration_STATUS populates the provided destination SshConfiguration_STATUS from our SshConfiguration_STATUS
func (configuration *SshConfiguration_STATUS) AssignProperties_To_SshConfiguration_STATUS(destination *v20201201s.SshConfiguration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// PublicKeys
	if configuration.PublicKeys != nil {
		publicKeyList := make([]v20201201s.SshPublicKey_STATUS, len(configuration.PublicKeys))
		for publicKeyIndex, publicKeyItem := range configuration.PublicKeys {
			// Shadow the loop variable to avoid aliasing
			publicKeyItem := publicKeyItem
			var publicKey v20201201s.SshPublicKey_STATUS
			err := publicKeyItem.AssignProperties_To_SshPublicKey_STATUS(&publicKey)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SshPublicKey_STATUS() to populate field PublicKeys")
			}
			publicKeyList[publicKeyIndex] = publicKey
		}
		destination.PublicKeys = publicKeyList
	} else {
		destination.PublicKeys = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForSshConfiguration_STATUS interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForSshConfiguration_STATUS); ok {
		err := augmentedConfiguration.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.VaultCertificate
// Deprecated version of VaultCertificate. Use v1api20220301.VaultCertificate instead
type VaultCertificate struct {
	CertificateStore *string                `json:"certificateStore,omitempty"`
	CertificateUrl   *string                `json:"certificateUrl,omitempty"`
	PropertyBag      genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_VaultCertificate populates our VaultCertificate from the provided source VaultCertificate
func (certificate *VaultCertificate) AssignProperties_From_VaultCertificate(source *v20201201s.VaultCertificate) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CertificateStore
	certificate.CertificateStore = genruntime.ClonePointerToString(source.CertificateStore)

	// CertificateUrl
	certificate.CertificateUrl = genruntime.ClonePointerToString(source.CertificateUrl)

	// Update the property bag
	if len(propertyBag) > 0 {
		certificate.PropertyBag = propertyBag
	} else {
		certificate.PropertyBag = nil
	}

	// Invoke the augmentConversionForVaultCertificate interface (if implemented) to customize the conversion
	var certificateAsAny any = certificate
	if augmentedCertificate, ok := certificateAsAny.(augmentConversionForVaultCertificate); ok {
		err := augmentedCertificate.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VaultCertificate populates the provided destination VaultCertificate from our VaultCertificate
func (certificate *VaultCertificate) AssignProperties_To_VaultCertificate(destination *v20201201s.VaultCertificate) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(certificate.PropertyBag)

	// CertificateStore
	destination.CertificateStore = genruntime.ClonePointerToString(certificate.CertificateStore)

	// CertificateUrl
	destination.CertificateUrl = genruntime.ClonePointerToString(certificate.CertificateUrl)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVaultCertificate interface (if implemented) to customize the conversion
	var certificateAsAny any = certificate
	if augmentedCertificate, ok := certificateAsAny.(augmentConversionForVaultCertificate); ok {
		err := augmentedCertificate.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.VaultCertificate_STATUS
// Deprecated version of VaultCertificate_STATUS. Use v1api20220301.VaultCertificate_STATUS instead
type VaultCertificate_STATUS struct {
	CertificateStore *string                `json:"certificateStore,omitempty"`
	CertificateUrl   *string                `json:"certificateUrl,omitempty"`
	PropertyBag      genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_VaultCertificate_STATUS populates our VaultCertificate_STATUS from the provided source VaultCertificate_STATUS
func (certificate *VaultCertificate_STATUS) AssignProperties_From_VaultCertificate_STATUS(source *v20201201s.VaultCertificate_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CertificateStore
	certificate.CertificateStore = genruntime.ClonePointerToString(source.CertificateStore)

	// CertificateUrl
	certificate.CertificateUrl = genruntime.ClonePointerToString(source.CertificateUrl)

	// Update the property bag
	if len(propertyBag) > 0 {
		certificate.PropertyBag = propertyBag
	} else {
		certificate.PropertyBag = nil
	}

	// Invoke the augmentConversionForVaultCertificate_STATUS interface (if implemented) to customize the conversion
	var certificateAsAny any = certificate
	if augmentedCertificate, ok := certificateAsAny.(augmentConversionForVaultCertificate_STATUS); ok {
		err := augmentedCertificate.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VaultCertificate_STATUS populates the provided destination VaultCertificate_STATUS from our VaultCertificate_STATUS
func (certificate *VaultCertificate_STATUS) AssignProperties_To_VaultCertificate_STATUS(destination *v20201201s.VaultCertificate_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(certificate.PropertyBag)

	// CertificateStore
	destination.CertificateStore = genruntime.ClonePointerToString(certificate.CertificateStore)

	// CertificateUrl
	destination.CertificateUrl = genruntime.ClonePointerToString(certificate.CertificateUrl)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVaultCertificate_STATUS interface (if implemented) to customize the conversion
	var certificateAsAny any = certificate
	if augmentedCertificate, ok := certificateAsAny.(augmentConversionForVaultCertificate_STATUS); ok {
		err := augmentedCertificate.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.VirtualHardDisk
// Deprecated version of VirtualHardDisk. Use v1api20220301.VirtualHardDisk instead
type VirtualHardDisk struct {
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Uri         *string                `json:"uri,omitempty"`
}

// AssignProperties_From_VirtualHardDisk populates our VirtualHardDisk from the provided source VirtualHardDisk
func (disk *VirtualHardDisk) AssignProperties_From_VirtualHardDisk(source *v20201201s.VirtualHardDisk) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Uri
	disk.Uri = genruntime.ClonePointerToString(source.Uri)

	// Update the property bag
	if len(propertyBag) > 0 {
		disk.PropertyBag = propertyBag
	} else {
		disk.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualHardDisk interface (if implemented) to customize the conversion
	var diskAsAny any = disk
	if augmentedDisk, ok := diskAsAny.(augmentConversionForVirtualHardDisk); ok {
		err := augmentedDisk.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualHardDisk populates the provided destination VirtualHardDisk from our VirtualHardDisk
func (disk *VirtualHardDisk) AssignProperties_To_VirtualHardDisk(destination *v20201201s.VirtualHardDisk) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(disk.PropertyBag)

	// Uri
	destination.Uri = genruntime.ClonePointerToString(disk.Uri)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualHardDisk interface (if implemented) to customize the conversion
	var diskAsAny any = disk
	if augmentedDisk, ok := diskAsAny.(augmentConversionForVirtualHardDisk); ok {
		err := augmentedDisk.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.VirtualHardDisk_STATUS
// Deprecated version of VirtualHardDisk_STATUS. Use v1api20220301.VirtualHardDisk_STATUS instead
type VirtualHardDisk_STATUS struct {
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Uri         *string                `json:"uri,omitempty"`
}

// AssignProperties_From_VirtualHardDisk_STATUS populates our VirtualHardDisk_STATUS from the provided source VirtualHardDisk_STATUS
func (disk *VirtualHardDisk_STATUS) AssignProperties_From_VirtualHardDisk_STATUS(source *v20201201s.VirtualHardDisk_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Uri
	disk.Uri = genruntime.ClonePointerToString(source.Uri)

	// Update the property bag
	if len(propertyBag) > 0 {
		disk.PropertyBag = propertyBag
	} else {
		disk.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualHardDisk_STATUS interface (if implemented) to customize the conversion
	var diskAsAny any = disk
	if augmentedDisk, ok := diskAsAny.(augmentConversionForVirtualHardDisk_STATUS); ok {
		err := augmentedDisk.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualHardDisk_STATUS populates the provided destination VirtualHardDisk_STATUS from our VirtualHardDisk_STATUS
func (disk *VirtualHardDisk_STATUS) AssignProperties_To_VirtualHardDisk_STATUS(destination *v20201201s.VirtualHardDisk_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(disk.PropertyBag)

	// Uri
	destination.Uri = genruntime.ClonePointerToString(disk.Uri)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualHardDisk_STATUS interface (if implemented) to customize the conversion
	var diskAsAny any = disk
	if augmentedDisk, ok := diskAsAny.(augmentConversionForVirtualHardDisk_STATUS); ok {
		err := augmentedDisk.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.VirtualMachineExtensionHandlerInstanceView_STATUS
// Deprecated version of VirtualMachineExtensionHandlerInstanceView_STATUS. Use v1api20220301.VirtualMachineExtensionHandlerInstanceView_STATUS instead
type VirtualMachineExtensionHandlerInstanceView_STATUS struct {
	PropertyBag        genruntime.PropertyBag     `json:"$propertyBag,omitempty"`
	Status             *InstanceViewStatus_STATUS `json:"status,omitempty"`
	Type               *string                    `json:"type,omitempty"`
	TypeHandlerVersion *string                    `json:"typeHandlerVersion,omitempty"`
}

// AssignProperties_From_VirtualMachineExtensionHandlerInstanceView_STATUS populates our VirtualMachineExtensionHandlerInstanceView_STATUS from the provided source VirtualMachineExtensionHandlerInstanceView_STATUS
func (view *VirtualMachineExtensionHandlerInstanceView_STATUS) AssignProperties_From_VirtualMachineExtensionHandlerInstanceView_STATUS(source *v20201201s.VirtualMachineExtensionHandlerInstanceView_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Status
	if source.Status != nil {
		var status InstanceViewStatus_STATUS
		err := status.AssignProperties_From_InstanceViewStatus_STATUS(source.Status)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_InstanceViewStatus_STATUS() to populate field Status")
		}
		view.Status = &status
	} else {
		view.Status = nil
	}

	// Type
	view.Type = genruntime.ClonePointerToString(source.Type)

	// TypeHandlerVersion
	view.TypeHandlerVersion = genruntime.ClonePointerToString(source.TypeHandlerVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		view.PropertyBag = propertyBag
	} else {
		view.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineExtensionHandlerInstanceView_STATUS interface (if implemented) to customize the conversion
	var viewAsAny any = view
	if augmentedView, ok := viewAsAny.(augmentConversionForVirtualMachineExtensionHandlerInstanceView_STATUS); ok {
		err := augmentedView.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineExtensionHandlerInstanceView_STATUS populates the provided destination VirtualMachineExtensionHandlerInstanceView_STATUS from our VirtualMachineExtensionHandlerInstanceView_STATUS
func (view *VirtualMachineExtensionHandlerInstanceView_STATUS) AssignProperties_To_VirtualMachineExtensionHandlerInstanceView_STATUS(destination *v20201201s.VirtualMachineExtensionHandlerInstanceView_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(view.PropertyBag)

	// Status
	if view.Status != nil {
		var status v20201201s.InstanceViewStatus_STATUS
		err := view.Status.AssignProperties_To_InstanceViewStatus_STATUS(&status)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_InstanceViewStatus_STATUS() to populate field Status")
		}
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(view.Type)

	// TypeHandlerVersion
	destination.TypeHandlerVersion = genruntime.ClonePointerToString(view.TypeHandlerVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineExtensionHandlerInstanceView_STATUS interface (if implemented) to customize the conversion
	var viewAsAny any = view
	if augmentedView, ok := viewAsAny.(augmentConversionForVirtualMachineExtensionHandlerInstanceView_STATUS); ok {
		err := augmentedView.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.VirtualMachineNetworkInterfaceDnsSettingsConfiguration
// Deprecated version of VirtualMachineNetworkInterfaceDnsSettingsConfiguration. Use v1api20220301.VirtualMachineNetworkInterfaceDnsSettingsConfiguration instead
type VirtualMachineNetworkInterfaceDnsSettingsConfiguration struct {
	DnsServers  []string               `json:"dnsServers,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_VirtualMachineNetworkInterfaceDnsSettingsConfiguration populates our VirtualMachineNetworkInterfaceDnsSettingsConfiguration from the provided source VirtualMachineNetworkInterfaceDnsSettingsConfiguration
func (configuration *VirtualMachineNetworkInterfaceDnsSettingsConfiguration) AssignProperties_From_VirtualMachineNetworkInterfaceDnsSettingsConfiguration(source *v20220301s.VirtualMachineNetworkInterfaceDnsSettingsConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DnsServers
	configuration.DnsServers = genruntime.CloneSliceOfString(source.DnsServers)

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineNetworkInterfaceDnsSettingsConfiguration interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForVirtualMachineNetworkInterfaceDnsSettingsConfiguration); ok {
		err := augmentedConfiguration.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineNetworkInterfaceDnsSettingsConfiguration populates the provided destination VirtualMachineNetworkInterfaceDnsSettingsConfiguration from our VirtualMachineNetworkInterfaceDnsSettingsConfiguration
func (configuration *VirtualMachineNetworkInterfaceDnsSettingsConfiguration) AssignProperties_To_VirtualMachineNetworkInterfaceDnsSettingsConfiguration(destination *v20220301s.VirtualMachineNetworkInterfaceDnsSettingsConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// DnsServers
	destination.DnsServers = genruntime.CloneSliceOfString(configuration.DnsServers)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineNetworkInterfaceDnsSettingsConfiguration interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForVirtualMachineNetworkInterfaceDnsSettingsConfiguration); ok {
		err := augmentedConfiguration.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS
// Deprecated version of VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS. Use v1api20220301.VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS instead
type VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS struct {
	DnsServers  []string               `json:"dnsServers,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS populates our VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS from the provided source VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS
func (configuration *VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS) AssignProperties_From_VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS(source *v20220301s.VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DnsServers
	configuration.DnsServers = genruntime.CloneSliceOfString(source.DnsServers)

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForVirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS); ok {
		err := augmentedConfiguration.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS populates the provided destination VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS from our VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS
func (configuration *VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS) AssignProperties_To_VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS(destination *v20220301s.VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// DnsServers
	destination.DnsServers = genruntime.CloneSliceOfString(configuration.DnsServers)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForVirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS); ok {
		err := augmentedConfiguration.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.VirtualMachineNetworkInterfaceIPConfiguration
// Deprecated version of VirtualMachineNetworkInterfaceIPConfiguration. Use v1api20220301.VirtualMachineNetworkInterfaceIPConfiguration instead
type VirtualMachineNetworkInterfaceIPConfiguration struct {
	ApplicationGatewayBackendAddressPools []SubResource                               `json:"applicationGatewayBackendAddressPools,omitempty"`
	ApplicationSecurityGroups             []SubResource                               `json:"applicationSecurityGroups,omitempty"`
	LoadBalancerBackendAddressPools       []SubResource                               `json:"loadBalancerBackendAddressPools,omitempty"`
	Name                                  *string                                     `json:"name,omitempty"`
	Primary                               *bool                                       `json:"primary,omitempty"`
	PrivateIPAddressVersion               *string                                     `json:"privateIPAddressVersion,omitempty"`
	PropertyBag                           genruntime.PropertyBag                      `json:"$propertyBag,omitempty"`
	PublicIPAddressConfiguration          *VirtualMachinePublicIPAddressConfiguration `json:"publicIPAddressConfiguration,omitempty"`
	Subnet                                *SubResource                                `json:"subnet,omitempty"`
}

// AssignProperties_From_VirtualMachineNetworkInterfaceIPConfiguration populates our VirtualMachineNetworkInterfaceIPConfiguration from the provided source VirtualMachineNetworkInterfaceIPConfiguration
func (configuration *VirtualMachineNetworkInterfaceIPConfiguration) AssignProperties_From_VirtualMachineNetworkInterfaceIPConfiguration(source *v20220301s.VirtualMachineNetworkInterfaceIPConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ApplicationGatewayBackendAddressPools
	if source.ApplicationGatewayBackendAddressPools != nil {
		applicationGatewayBackendAddressPoolList := make([]SubResource, len(source.ApplicationGatewayBackendAddressPools))
		for applicationGatewayBackendAddressPoolIndex, applicationGatewayBackendAddressPoolItem := range source.ApplicationGatewayBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			applicationGatewayBackendAddressPoolItem := applicationGatewayBackendAddressPoolItem
			var subResourceStash v20210701s.SubResource
			err := subResourceStash.AssignProperties_From_SubResource(&applicationGatewayBackendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SubResourceStash from ApplicationGatewayBackendAddressPools")
			}
			var subResourceStashLocal v20201201s.SubResource
			err = subResourceStashLocal.AssignProperties_From_SubResource(&subResourceStash)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SubResourceStash")
			}
			var applicationGatewayBackendAddressPool SubResource
			err = applicationGatewayBackendAddressPool.AssignProperties_From_SubResource(&subResourceStashLocal)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field ApplicationGatewayBackendAddressPools from SubResourceStash")
			}
			applicationGatewayBackendAddressPoolList[applicationGatewayBackendAddressPoolIndex] = applicationGatewayBackendAddressPool
		}
		configuration.ApplicationGatewayBackendAddressPools = applicationGatewayBackendAddressPoolList
	} else {
		configuration.ApplicationGatewayBackendAddressPools = nil
	}

	// ApplicationSecurityGroups
	if source.ApplicationSecurityGroups != nil {
		applicationSecurityGroupList := make([]SubResource, len(source.ApplicationSecurityGroups))
		for applicationSecurityGroupIndex, applicationSecurityGroupItem := range source.ApplicationSecurityGroups {
			// Shadow the loop variable to avoid aliasing
			applicationSecurityGroupItem := applicationSecurityGroupItem
			var subResourceStash v20210701s.SubResource
			err := subResourceStash.AssignProperties_From_SubResource(&applicationSecurityGroupItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SubResourceStash from ApplicationSecurityGroups")
			}
			var subResourceStashLocal v20201201s.SubResource
			err = subResourceStashLocal.AssignProperties_From_SubResource(&subResourceStash)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SubResourceStash")
			}
			var applicationSecurityGroup SubResource
			err = applicationSecurityGroup.AssignProperties_From_SubResource(&subResourceStashLocal)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field ApplicationSecurityGroups from SubResourceStash")
			}
			applicationSecurityGroupList[applicationSecurityGroupIndex] = applicationSecurityGroup
		}
		configuration.ApplicationSecurityGroups = applicationSecurityGroupList
	} else {
		configuration.ApplicationSecurityGroups = nil
	}

	// LoadBalancerBackendAddressPools
	if source.LoadBalancerBackendAddressPools != nil {
		loadBalancerBackendAddressPoolList := make([]SubResource, len(source.LoadBalancerBackendAddressPools))
		for loadBalancerBackendAddressPoolIndex, loadBalancerBackendAddressPoolItem := range source.LoadBalancerBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressPoolItem := loadBalancerBackendAddressPoolItem
			var subResourceStash v20210701s.SubResource
			err := subResourceStash.AssignProperties_From_SubResource(&loadBalancerBackendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SubResourceStash from LoadBalancerBackendAddressPools")
			}
			var subResourceStashLocal v20201201s.SubResource
			err = subResourceStashLocal.AssignProperties_From_SubResource(&subResourceStash)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SubResourceStash")
			}
			var loadBalancerBackendAddressPool SubResource
			err = loadBalancerBackendAddressPool.AssignProperties_From_SubResource(&subResourceStashLocal)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field LoadBalancerBackendAddressPools from SubResourceStash")
			}
			loadBalancerBackendAddressPoolList[loadBalancerBackendAddressPoolIndex] = loadBalancerBackendAddressPool
		}
		configuration.LoadBalancerBackendAddressPools = loadBalancerBackendAddressPoolList
	} else {
		configuration.LoadBalancerBackendAddressPools = nil
	}

	// Name
	configuration.Name = genruntime.ClonePointerToString(source.Name)

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		configuration.Primary = &primary
	} else {
		configuration.Primary = nil
	}

	// PrivateIPAddressVersion
	configuration.PrivateIPAddressVersion = genruntime.ClonePointerToString(source.PrivateIPAddressVersion)

	// PublicIPAddressConfiguration
	if source.PublicIPAddressConfiguration != nil {
		var publicIPAddressConfiguration VirtualMachinePublicIPAddressConfiguration
		err := publicIPAddressConfiguration.AssignProperties_From_VirtualMachinePublicIPAddressConfiguration(source.PublicIPAddressConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachinePublicIPAddressConfiguration() to populate field PublicIPAddressConfiguration")
		}
		configuration.PublicIPAddressConfiguration = &publicIPAddressConfiguration
	} else {
		configuration.PublicIPAddressConfiguration = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subResourceStash v20210701s.SubResource
		err := subResourceStash.AssignProperties_From_SubResource(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SubResourceStash from Subnet")
		}
		var subResourceStashLocal v20201201s.SubResource
		err = subResourceStashLocal.AssignProperties_From_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SubResourceStash")
		}
		var subnet SubResource
		err = subnet.AssignProperties_From_SubResource(&subResourceStashLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field Subnet from SubResourceStash")
		}
		configuration.Subnet = &subnet
	} else {
		configuration.Subnet = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineNetworkInterfaceIPConfiguration interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForVirtualMachineNetworkInterfaceIPConfiguration); ok {
		err := augmentedConfiguration.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineNetworkInterfaceIPConfiguration populates the provided destination VirtualMachineNetworkInterfaceIPConfiguration from our VirtualMachineNetworkInterfaceIPConfiguration
func (configuration *VirtualMachineNetworkInterfaceIPConfiguration) AssignProperties_To_VirtualMachineNetworkInterfaceIPConfiguration(destination *v20220301s.VirtualMachineNetworkInterfaceIPConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// ApplicationGatewayBackendAddressPools
	if configuration.ApplicationGatewayBackendAddressPools != nil {
		applicationGatewayBackendAddressPoolList := make([]v20220301s.SubResource, len(configuration.ApplicationGatewayBackendAddressPools))
		for applicationGatewayBackendAddressPoolIndex, applicationGatewayBackendAddressPoolItem := range configuration.ApplicationGatewayBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			applicationGatewayBackendAddressPoolItem := applicationGatewayBackendAddressPoolItem
			var subResourceStash v20201201s.SubResource
			err := applicationGatewayBackendAddressPoolItem.AssignProperties_To_SubResource(&subResourceStash)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SubResourceStash from ApplicationGatewayBackendAddressPools")
			}
			var subResourceStashLocal v20210701s.SubResource
			err = subResourceStash.AssignProperties_To_SubResource(&subResourceStashLocal)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SubResourceStash")
			}
			var applicationGatewayBackendAddressPool v20220301s.SubResource
			err = subResourceStashLocal.AssignProperties_To_SubResource(&applicationGatewayBackendAddressPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field ApplicationGatewayBackendAddressPools from SubResourceStash")
			}
			applicationGatewayBackendAddressPoolList[applicationGatewayBackendAddressPoolIndex] = applicationGatewayBackendAddressPool
		}
		destination.ApplicationGatewayBackendAddressPools = applicationGatewayBackendAddressPoolList
	} else {
		destination.ApplicationGatewayBackendAddressPools = nil
	}

	// ApplicationSecurityGroups
	if configuration.ApplicationSecurityGroups != nil {
		applicationSecurityGroupList := make([]v20220301s.SubResource, len(configuration.ApplicationSecurityGroups))
		for applicationSecurityGroupIndex, applicationSecurityGroupItem := range configuration.ApplicationSecurityGroups {
			// Shadow the loop variable to avoid aliasing
			applicationSecurityGroupItem := applicationSecurityGroupItem
			var subResourceStash v20201201s.SubResource
			err := applicationSecurityGroupItem.AssignProperties_To_SubResource(&subResourceStash)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SubResourceStash from ApplicationSecurityGroups")
			}
			var subResourceStashLocal v20210701s.SubResource
			err = subResourceStash.AssignProperties_To_SubResource(&subResourceStashLocal)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SubResourceStash")
			}
			var applicationSecurityGroup v20220301s.SubResource
			err = subResourceStashLocal.AssignProperties_To_SubResource(&applicationSecurityGroup)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field ApplicationSecurityGroups from SubResourceStash")
			}
			applicationSecurityGroupList[applicationSecurityGroupIndex] = applicationSecurityGroup
		}
		destination.ApplicationSecurityGroups = applicationSecurityGroupList
	} else {
		destination.ApplicationSecurityGroups = nil
	}

	// LoadBalancerBackendAddressPools
	if configuration.LoadBalancerBackendAddressPools != nil {
		loadBalancerBackendAddressPoolList := make([]v20220301s.SubResource, len(configuration.LoadBalancerBackendAddressPools))
		for loadBalancerBackendAddressPoolIndex, loadBalancerBackendAddressPoolItem := range configuration.LoadBalancerBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressPoolItem := loadBalancerBackendAddressPoolItem
			var subResourceStash v20201201s.SubResource
			err := loadBalancerBackendAddressPoolItem.AssignProperties_To_SubResource(&subResourceStash)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SubResourceStash from LoadBalancerBackendAddressPools")
			}
			var subResourceStashLocal v20210701s.SubResource
			err = subResourceStash.AssignProperties_To_SubResource(&subResourceStashLocal)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SubResourceStash")
			}
			var loadBalancerBackendAddressPool v20220301s.SubResource
			err = subResourceStashLocal.AssignProperties_To_SubResource(&loadBalancerBackendAddressPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field LoadBalancerBackendAddressPools from SubResourceStash")
			}
			loadBalancerBackendAddressPoolList[loadBalancerBackendAddressPoolIndex] = loadBalancerBackendAddressPool
		}
		destination.LoadBalancerBackendAddressPools = loadBalancerBackendAddressPoolList
	} else {
		destination.LoadBalancerBackendAddressPools = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(configuration.Name)

	// Primary
	if configuration.Primary != nil {
		primary := *configuration.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// PrivateIPAddressVersion
	destination.PrivateIPAddressVersion = genruntime.ClonePointerToString(configuration.PrivateIPAddressVersion)

	// PublicIPAddressConfiguration
	if configuration.PublicIPAddressConfiguration != nil {
		var publicIPAddressConfiguration v20220301s.VirtualMachinePublicIPAddressConfiguration
		err := configuration.PublicIPAddressConfiguration.AssignProperties_To_VirtualMachinePublicIPAddressConfiguration(&publicIPAddressConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachinePublicIPAddressConfiguration() to populate field PublicIPAddressConfiguration")
		}
		destination.PublicIPAddressConfiguration = &publicIPAddressConfiguration
	} else {
		destination.PublicIPAddressConfiguration = nil
	}

	// Subnet
	if configuration.Subnet != nil {
		var subResourceStash v20201201s.SubResource
		err := configuration.Subnet.AssignProperties_To_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SubResourceStash from Subnet")
		}
		var subResourceStashLocal v20210701s.SubResource
		err = subResourceStash.AssignProperties_To_SubResource(&subResourceStashLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SubResourceStash")
		}
		var subnet v20220301s.SubResource
		err = subResourceStashLocal.AssignProperties_To_SubResource(&subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field Subnet from SubResourceStash")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineNetworkInterfaceIPConfiguration interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForVirtualMachineNetworkInterfaceIPConfiguration); ok {
		err := augmentedConfiguration.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.VirtualMachineNetworkInterfaceIPConfiguration_STATUS
// Deprecated version of VirtualMachineNetworkInterfaceIPConfiguration_STATUS. Use v1api20220301.VirtualMachineNetworkInterfaceIPConfiguration_STATUS instead
type VirtualMachineNetworkInterfaceIPConfiguration_STATUS struct {
	ApplicationGatewayBackendAddressPools []SubResource_STATUS                               `json:"applicationGatewayBackendAddressPools,omitempty"`
	ApplicationSecurityGroups             []SubResource_STATUS                               `json:"applicationSecurityGroups,omitempty"`
	LoadBalancerBackendAddressPools       []SubResource_STATUS                               `json:"loadBalancerBackendAddressPools,omitempty"`
	Name                                  *string                                            `json:"name,omitempty"`
	Primary                               *bool                                              `json:"primary,omitempty"`
	PrivateIPAddressVersion               *string                                            `json:"privateIPAddressVersion,omitempty"`
	PropertyBag                           genruntime.PropertyBag                             `json:"$propertyBag,omitempty"`
	PublicIPAddressConfiguration          *VirtualMachinePublicIPAddressConfiguration_STATUS `json:"publicIPAddressConfiguration,omitempty"`
	Subnet                                *SubResource_STATUS                                `json:"subnet,omitempty"`
}

// AssignProperties_From_VirtualMachineNetworkInterfaceIPConfiguration_STATUS populates our VirtualMachineNetworkInterfaceIPConfiguration_STATUS from the provided source VirtualMachineNetworkInterfaceIPConfiguration_STATUS
func (configuration *VirtualMachineNetworkInterfaceIPConfiguration_STATUS) AssignProperties_From_VirtualMachineNetworkInterfaceIPConfiguration_STATUS(source *v20220301s.VirtualMachineNetworkInterfaceIPConfiguration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ApplicationGatewayBackendAddressPools
	if source.ApplicationGatewayBackendAddressPools != nil {
		applicationGatewayBackendAddressPoolList := make([]SubResource_STATUS, len(source.ApplicationGatewayBackendAddressPools))
		for applicationGatewayBackendAddressPoolIndex, applicationGatewayBackendAddressPoolItem := range source.ApplicationGatewayBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			applicationGatewayBackendAddressPoolItem := applicationGatewayBackendAddressPoolItem
			var subResourceSTATUSStash v20210701s.SubResource_STATUS
			err := subResourceSTATUSStash.AssignProperties_From_SubResource_STATUS(&applicationGatewayBackendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash from ApplicationGatewayBackendAddressPools")
			}
			var subResourceSTATUSStashLocal v20201201s.SubResource_STATUS
			err = subResourceSTATUSStashLocal.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStash)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash")
			}
			var applicationGatewayBackendAddressPool SubResource_STATUS
			err = applicationGatewayBackendAddressPool.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStashLocal)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field ApplicationGatewayBackendAddressPools from SubResource_STATUSStash")
			}
			applicationGatewayBackendAddressPoolList[applicationGatewayBackendAddressPoolIndex] = applicationGatewayBackendAddressPool
		}
		configuration.ApplicationGatewayBackendAddressPools = applicationGatewayBackendAddressPoolList
	} else {
		configuration.ApplicationGatewayBackendAddressPools = nil
	}

	// ApplicationSecurityGroups
	if source.ApplicationSecurityGroups != nil {
		applicationSecurityGroupList := make([]SubResource_STATUS, len(source.ApplicationSecurityGroups))
		for applicationSecurityGroupIndex, applicationSecurityGroupItem := range source.ApplicationSecurityGroups {
			// Shadow the loop variable to avoid aliasing
			applicationSecurityGroupItem := applicationSecurityGroupItem
			var subResourceSTATUSStash v20210701s.SubResource_STATUS
			err := subResourceSTATUSStash.AssignProperties_From_SubResource_STATUS(&applicationSecurityGroupItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash from ApplicationSecurityGroups")
			}
			var subResourceSTATUSStashLocal v20201201s.SubResource_STATUS
			err = subResourceSTATUSStashLocal.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStash)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash")
			}
			var applicationSecurityGroup SubResource_STATUS
			err = applicationSecurityGroup.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStashLocal)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field ApplicationSecurityGroups from SubResource_STATUSStash")
			}
			applicationSecurityGroupList[applicationSecurityGroupIndex] = applicationSecurityGroup
		}
		configuration.ApplicationSecurityGroups = applicationSecurityGroupList
	} else {
		configuration.ApplicationSecurityGroups = nil
	}

	// LoadBalancerBackendAddressPools
	if source.LoadBalancerBackendAddressPools != nil {
		loadBalancerBackendAddressPoolList := make([]SubResource_STATUS, len(source.LoadBalancerBackendAddressPools))
		for loadBalancerBackendAddressPoolIndex, loadBalancerBackendAddressPoolItem := range source.LoadBalancerBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressPoolItem := loadBalancerBackendAddressPoolItem
			var subResourceSTATUSStash v20210701s.SubResource_STATUS
			err := subResourceSTATUSStash.AssignProperties_From_SubResource_STATUS(&loadBalancerBackendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash from LoadBalancerBackendAddressPools")
			}
			var subResourceSTATUSStashLocal v20201201s.SubResource_STATUS
			err = subResourceSTATUSStashLocal.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStash)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash")
			}
			var loadBalancerBackendAddressPool SubResource_STATUS
			err = loadBalancerBackendAddressPool.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStashLocal)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field LoadBalancerBackendAddressPools from SubResource_STATUSStash")
			}
			loadBalancerBackendAddressPoolList[loadBalancerBackendAddressPoolIndex] = loadBalancerBackendAddressPool
		}
		configuration.LoadBalancerBackendAddressPools = loadBalancerBackendAddressPoolList
	} else {
		configuration.LoadBalancerBackendAddressPools = nil
	}

	// Name
	configuration.Name = genruntime.ClonePointerToString(source.Name)

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		configuration.Primary = &primary
	} else {
		configuration.Primary = nil
	}

	// PrivateIPAddressVersion
	configuration.PrivateIPAddressVersion = genruntime.ClonePointerToString(source.PrivateIPAddressVersion)

	// PublicIPAddressConfiguration
	if source.PublicIPAddressConfiguration != nil {
		var publicIPAddressConfiguration VirtualMachinePublicIPAddressConfiguration_STATUS
		err := publicIPAddressConfiguration.AssignProperties_From_VirtualMachinePublicIPAddressConfiguration_STATUS(source.PublicIPAddressConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachinePublicIPAddressConfiguration_STATUS() to populate field PublicIPAddressConfiguration")
		}
		configuration.PublicIPAddressConfiguration = &publicIPAddressConfiguration
	} else {
		configuration.PublicIPAddressConfiguration = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := subResourceSTATUSStash.AssignProperties_From_SubResource_STATUS(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash from Subnet")
		}
		var subResourceSTATUSStashLocal v20201201s.SubResource_STATUS
		err = subResourceSTATUSStashLocal.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash")
		}
		var subnet SubResource_STATUS
		err = subnet.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStashLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field Subnet from SubResource_STATUSStash")
		}
		configuration.Subnet = &subnet
	} else {
		configuration.Subnet = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineNetworkInterfaceIPConfiguration_STATUS interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForVirtualMachineNetworkInterfaceIPConfiguration_STATUS); ok {
		err := augmentedConfiguration.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineNetworkInterfaceIPConfiguration_STATUS populates the provided destination VirtualMachineNetworkInterfaceIPConfiguration_STATUS from our VirtualMachineNetworkInterfaceIPConfiguration_STATUS
func (configuration *VirtualMachineNetworkInterfaceIPConfiguration_STATUS) AssignProperties_To_VirtualMachineNetworkInterfaceIPConfiguration_STATUS(destination *v20220301s.VirtualMachineNetworkInterfaceIPConfiguration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// ApplicationGatewayBackendAddressPools
	if configuration.ApplicationGatewayBackendAddressPools != nil {
		applicationGatewayBackendAddressPoolList := make([]v20220301s.SubResource_STATUS, len(configuration.ApplicationGatewayBackendAddressPools))
		for applicationGatewayBackendAddressPoolIndex, applicationGatewayBackendAddressPoolItem := range configuration.ApplicationGatewayBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			applicationGatewayBackendAddressPoolItem := applicationGatewayBackendAddressPoolItem
			var subResourceSTATUSStash v20201201s.SubResource_STATUS
			err := applicationGatewayBackendAddressPoolItem.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStash)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash from ApplicationGatewayBackendAddressPools")
			}
			var subResourceSTATUSStashLocal v20210701s.SubResource_STATUS
			err = subResourceSTATUSStash.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStashLocal)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash")
			}
			var applicationGatewayBackendAddressPool v20220301s.SubResource_STATUS
			err = subResourceSTATUSStashLocal.AssignProperties_To_SubResource_STATUS(&applicationGatewayBackendAddressPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field ApplicationGatewayBackendAddressPools from SubResource_STATUSStash")
			}
			applicationGatewayBackendAddressPoolList[applicationGatewayBackendAddressPoolIndex] = applicationGatewayBackendAddressPool
		}
		destination.ApplicationGatewayBackendAddressPools = applicationGatewayBackendAddressPoolList
	} else {
		destination.ApplicationGatewayBackendAddressPools = nil
	}

	// ApplicationSecurityGroups
	if configuration.ApplicationSecurityGroups != nil {
		applicationSecurityGroupList := make([]v20220301s.SubResource_STATUS, len(configuration.ApplicationSecurityGroups))
		for applicationSecurityGroupIndex, applicationSecurityGroupItem := range configuration.ApplicationSecurityGroups {
			// Shadow the loop variable to avoid aliasing
			applicationSecurityGroupItem := applicationSecurityGroupItem
			var subResourceSTATUSStash v20201201s.SubResource_STATUS
			err := applicationSecurityGroupItem.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStash)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash from ApplicationSecurityGroups")
			}
			var subResourceSTATUSStashLocal v20210701s.SubResource_STATUS
			err = subResourceSTATUSStash.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStashLocal)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash")
			}
			var applicationSecurityGroup v20220301s.SubResource_STATUS
			err = subResourceSTATUSStashLocal.AssignProperties_To_SubResource_STATUS(&applicationSecurityGroup)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field ApplicationSecurityGroups from SubResource_STATUSStash")
			}
			applicationSecurityGroupList[applicationSecurityGroupIndex] = applicationSecurityGroup
		}
		destination.ApplicationSecurityGroups = applicationSecurityGroupList
	} else {
		destination.ApplicationSecurityGroups = nil
	}

	// LoadBalancerBackendAddressPools
	if configuration.LoadBalancerBackendAddressPools != nil {
		loadBalancerBackendAddressPoolList := make([]v20220301s.SubResource_STATUS, len(configuration.LoadBalancerBackendAddressPools))
		for loadBalancerBackendAddressPoolIndex, loadBalancerBackendAddressPoolItem := range configuration.LoadBalancerBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressPoolItem := loadBalancerBackendAddressPoolItem
			var subResourceSTATUSStash v20201201s.SubResource_STATUS
			err := loadBalancerBackendAddressPoolItem.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStash)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash from LoadBalancerBackendAddressPools")
			}
			var subResourceSTATUSStashLocal v20210701s.SubResource_STATUS
			err = subResourceSTATUSStash.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStashLocal)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash")
			}
			var loadBalancerBackendAddressPool v20220301s.SubResource_STATUS
			err = subResourceSTATUSStashLocal.AssignProperties_To_SubResource_STATUS(&loadBalancerBackendAddressPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field LoadBalancerBackendAddressPools from SubResource_STATUSStash")
			}
			loadBalancerBackendAddressPoolList[loadBalancerBackendAddressPoolIndex] = loadBalancerBackendAddressPool
		}
		destination.LoadBalancerBackendAddressPools = loadBalancerBackendAddressPoolList
	} else {
		destination.LoadBalancerBackendAddressPools = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(configuration.Name)

	// Primary
	if configuration.Primary != nil {
		primary := *configuration.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// PrivateIPAddressVersion
	destination.PrivateIPAddressVersion = genruntime.ClonePointerToString(configuration.PrivateIPAddressVersion)

	// PublicIPAddressConfiguration
	if configuration.PublicIPAddressConfiguration != nil {
		var publicIPAddressConfiguration v20220301s.VirtualMachinePublicIPAddressConfiguration_STATUS
		err := configuration.PublicIPAddressConfiguration.AssignProperties_To_VirtualMachinePublicIPAddressConfiguration_STATUS(&publicIPAddressConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachinePublicIPAddressConfiguration_STATUS() to populate field PublicIPAddressConfiguration")
		}
		destination.PublicIPAddressConfiguration = &publicIPAddressConfiguration
	} else {
		destination.PublicIPAddressConfiguration = nil
	}

	// Subnet
	if configuration.Subnet != nil {
		var subResourceSTATUSStash v20201201s.SubResource_STATUS
		err := configuration.Subnet.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash from Subnet")
		}
		var subResourceSTATUSStashLocal v20210701s.SubResource_STATUS
		err = subResourceSTATUSStash.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStashLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash")
		}
		var subnet v20220301s.SubResource_STATUS
		err = subResourceSTATUSStashLocal.AssignProperties_To_SubResource_STATUS(&subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field Subnet from SubResource_STATUSStash")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineNetworkInterfaceIPConfiguration_STATUS interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForVirtualMachineNetworkInterfaceIPConfiguration_STATUS); ok {
		err := augmentedConfiguration.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.WinRMConfiguration
// Deprecated version of WinRMConfiguration. Use v1api20220301.WinRMConfiguration instead
type WinRMConfiguration struct {
	Listeners   []WinRMListener        `json:"listeners,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_WinRMConfiguration populates our WinRMConfiguration from the provided source WinRMConfiguration
func (configuration *WinRMConfiguration) AssignProperties_From_WinRMConfiguration(source *v20201201s.WinRMConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Listeners
	if source.Listeners != nil {
		listenerList := make([]WinRMListener, len(source.Listeners))
		for listenerIndex, listenerItem := range source.Listeners {
			// Shadow the loop variable to avoid aliasing
			listenerItem := listenerItem
			var listener WinRMListener
			err := listener.AssignProperties_From_WinRMListener(&listenerItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_WinRMListener() to populate field Listeners")
			}
			listenerList[listenerIndex] = listener
		}
		configuration.Listeners = listenerList
	} else {
		configuration.Listeners = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// Invoke the augmentConversionForWinRMConfiguration interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForWinRMConfiguration); ok {
		err := augmentedConfiguration.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_WinRMConfiguration populates the provided destination WinRMConfiguration from our WinRMConfiguration
func (configuration *WinRMConfiguration) AssignProperties_To_WinRMConfiguration(destination *v20201201s.WinRMConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// Listeners
	if configuration.Listeners != nil {
		listenerList := make([]v20201201s.WinRMListener, len(configuration.Listeners))
		for listenerIndex, listenerItem := range configuration.Listeners {
			// Shadow the loop variable to avoid aliasing
			listenerItem := listenerItem
			var listener v20201201s.WinRMListener
			err := listenerItem.AssignProperties_To_WinRMListener(&listener)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_WinRMListener() to populate field Listeners")
			}
			listenerList[listenerIndex] = listener
		}
		destination.Listeners = listenerList
	} else {
		destination.Listeners = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForWinRMConfiguration interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForWinRMConfiguration); ok {
		err := augmentedConfiguration.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.WinRMConfiguration_STATUS
// Deprecated version of WinRMConfiguration_STATUS. Use v1api20220301.WinRMConfiguration_STATUS instead
type WinRMConfiguration_STATUS struct {
	Listeners   []WinRMListener_STATUS `json:"listeners,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_WinRMConfiguration_STATUS populates our WinRMConfiguration_STATUS from the provided source WinRMConfiguration_STATUS
func (configuration *WinRMConfiguration_STATUS) AssignProperties_From_WinRMConfiguration_STATUS(source *v20201201s.WinRMConfiguration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Listeners
	if source.Listeners != nil {
		listenerList := make([]WinRMListener_STATUS, len(source.Listeners))
		for listenerIndex, listenerItem := range source.Listeners {
			// Shadow the loop variable to avoid aliasing
			listenerItem := listenerItem
			var listener WinRMListener_STATUS
			err := listener.AssignProperties_From_WinRMListener_STATUS(&listenerItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_WinRMListener_STATUS() to populate field Listeners")
			}
			listenerList[listenerIndex] = listener
		}
		configuration.Listeners = listenerList
	} else {
		configuration.Listeners = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// Invoke the augmentConversionForWinRMConfiguration_STATUS interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForWinRMConfiguration_STATUS); ok {
		err := augmentedConfiguration.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_WinRMConfiguration_STATUS populates the provided destination WinRMConfiguration_STATUS from our WinRMConfiguration_STATUS
func (configuration *WinRMConfiguration_STATUS) AssignProperties_To_WinRMConfiguration_STATUS(destination *v20201201s.WinRMConfiguration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// Listeners
	if configuration.Listeners != nil {
		listenerList := make([]v20201201s.WinRMListener_STATUS, len(configuration.Listeners))
		for listenerIndex, listenerItem := range configuration.Listeners {
			// Shadow the loop variable to avoid aliasing
			listenerItem := listenerItem
			var listener v20201201s.WinRMListener_STATUS
			err := listenerItem.AssignProperties_To_WinRMListener_STATUS(&listener)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_WinRMListener_STATUS() to populate field Listeners")
			}
			listenerList[listenerIndex] = listener
		}
		destination.Listeners = listenerList
	} else {
		destination.Listeners = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForWinRMConfiguration_STATUS interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForWinRMConfiguration_STATUS); ok {
		err := augmentedConfiguration.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.ApiError_STATUS
// Deprecated version of ApiError_STATUS. Use v1api20220301.ApiError_STATUS instead
type ApiError_STATUS struct {
	Code        *string                `json:"code,omitempty"`
	Details     []ApiErrorBase_STATUS  `json:"details,omitempty"`
	Innererror  *InnerError_STATUS     `json:"innererror,omitempty"`
	Message     *string                `json:"message,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Target      *string                `json:"target,omitempty"`
}

// AssignProperties_From_ApiError_STATUS populates our ApiError_STATUS from the provided source ApiError_STATUS
func (error *ApiError_STATUS) AssignProperties_From_ApiError_STATUS(source *v20201201s.ApiError_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Code
	error.Code = genruntime.ClonePointerToString(source.Code)

	// Details
	if source.Details != nil {
		detailList := make([]ApiErrorBase_STATUS, len(source.Details))
		for detailIndex, detailItem := range source.Details {
			// Shadow the loop variable to avoid aliasing
			detailItem := detailItem
			var detail ApiErrorBase_STATUS
			err := detail.AssignProperties_From_ApiErrorBase_STATUS(&detailItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApiErrorBase_STATUS() to populate field Details")
			}
			detailList[detailIndex] = detail
		}
		error.Details = detailList
	} else {
		error.Details = nil
	}

	// Innererror
	if source.Innererror != nil {
		var innererror InnerError_STATUS
		err := innererror.AssignProperties_From_InnerError_STATUS(source.Innererror)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_InnerError_STATUS() to populate field Innererror")
		}
		error.Innererror = &innererror
	} else {
		error.Innererror = nil
	}

	// Message
	error.Message = genruntime.ClonePointerToString(source.Message)

	// Target
	error.Target = genruntime.ClonePointerToString(source.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		error.PropertyBag = propertyBag
	} else {
		error.PropertyBag = nil
	}

	// Invoke the augmentConversionForApiError_STATUS interface (if implemented) to customize the conversion
	var errorAsAny any = error
	if augmentedError, ok := errorAsAny.(augmentConversionForApiError_STATUS); ok {
		err := augmentedError.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ApiError_STATUS populates the provided destination ApiError_STATUS from our ApiError_STATUS
func (error *ApiError_STATUS) AssignProperties_To_ApiError_STATUS(destination *v20201201s.ApiError_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(error.PropertyBag)

	// Code
	destination.Code = genruntime.ClonePointerToString(error.Code)

	// Details
	if error.Details != nil {
		detailList := make([]v20201201s.ApiErrorBase_STATUS, len(error.Details))
		for detailIndex, detailItem := range error.Details {
			// Shadow the loop variable to avoid aliasing
			detailItem := detailItem
			var detail v20201201s.ApiErrorBase_STATUS
			err := detailItem.AssignProperties_To_ApiErrorBase_STATUS(&detail)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApiErrorBase_STATUS() to populate field Details")
			}
			detailList[detailIndex] = detail
		}
		destination.Details = detailList
	} else {
		destination.Details = nil
	}

	// Innererror
	if error.Innererror != nil {
		var innererror v20201201s.InnerError_STATUS
		err := error.Innererror.AssignProperties_To_InnerError_STATUS(&innererror)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_InnerError_STATUS() to populate field Innererror")
		}
		destination.Innererror = &innererror
	} else {
		destination.Innererror = nil
	}

	// Message
	destination.Message = genruntime.ClonePointerToString(error.Message)

	// Target
	destination.Target = genruntime.ClonePointerToString(error.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForApiError_STATUS interface (if implemented) to customize the conversion
	var errorAsAny any = error
	if augmentedError, ok := errorAsAny.(augmentConversionForApiError_STATUS); ok {
		err := augmentedError.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForAdditionalUnattendContent interface {
	AssignPropertiesFrom(src *v20201201s.AdditionalUnattendContent) error
	AssignPropertiesTo(dst *v20201201s.AdditionalUnattendContent) error
}

type augmentConversionForAdditionalUnattendContent_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.AdditionalUnattendContent_STATUS) error
	AssignPropertiesTo(dst *v20201201s.AdditionalUnattendContent_STATUS) error
}

type augmentConversionForAvailablePatchSummary_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.AvailablePatchSummary_STATUS) error
	AssignPropertiesTo(dst *v20201201s.AvailablePatchSummary_STATUS) error
}

type augmentConversionForDiffDiskSettings interface {
	AssignPropertiesFrom(src *v20201201s.DiffDiskSettings) error
	AssignPropertiesTo(dst *v20201201s.DiffDiskSettings) error
}

type augmentConversionForDiffDiskSettings_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.DiffDiskSettings_STATUS) error
	AssignPropertiesTo(dst *v20201201s.DiffDiskSettings_STATUS) error
}

type augmentConversionForDiskEncryptionSettings interface {
	AssignPropertiesFrom(src *v20201201s.DiskEncryptionSettings) error
	AssignPropertiesTo(dst *v20201201s.DiskEncryptionSettings) error
}

type augmentConversionForDiskEncryptionSettings_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.DiskEncryptionSettings_STATUS) error
	AssignPropertiesTo(dst *v20201201s.DiskEncryptionSettings_STATUS) error
}

type augmentConversionForLastPatchInstallationSummary_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.LastPatchInstallationSummary_STATUS) error
	AssignPropertiesTo(dst *v20201201s.LastPatchInstallationSummary_STATUS) error
}

type augmentConversionForLinuxPatchSettings interface {
	AssignPropertiesFrom(src *v20201201s.LinuxPatchSettings) error
	AssignPropertiesTo(dst *v20201201s.LinuxPatchSettings) error
}

type augmentConversionForLinuxPatchSettings_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.LinuxPatchSettings_STATUS) error
	AssignPropertiesTo(dst *v20201201s.LinuxPatchSettings_STATUS) error
}

type augmentConversionForManagedDiskParameters interface {
	AssignPropertiesFrom(src *v20201201s.ManagedDiskParameters) error
	AssignPropertiesTo(dst *v20201201s.ManagedDiskParameters) error
}

type augmentConversionForManagedDiskParameters_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.ManagedDiskParameters_STATUS) error
	AssignPropertiesTo(dst *v20201201s.ManagedDiskParameters_STATUS) error
}

type augmentConversionForPatchSettings interface {
	AssignPropertiesFrom(src *v20201201s.PatchSettings) error
	AssignPropertiesTo(dst *v20201201s.PatchSettings) error
}

type augmentConversionForPatchSettings_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.PatchSettings_STATUS) error
	AssignPropertiesTo(dst *v20201201s.PatchSettings_STATUS) error
}

type augmentConversionForSshConfiguration interface {
	AssignPropertiesFrom(src *v20201201s.SshConfiguration) error
	AssignPropertiesTo(dst *v20201201s.SshConfiguration) error
}

type augmentConversionForSshConfiguration_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.SshConfiguration_STATUS) error
	AssignPropertiesTo(dst *v20201201s.SshConfiguration_STATUS) error
}

type augmentConversionForVaultCertificate interface {
	AssignPropertiesFrom(src *v20201201s.VaultCertificate) error
	AssignPropertiesTo(dst *v20201201s.VaultCertificate) error
}

type augmentConversionForVaultCertificate_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.VaultCertificate_STATUS) error
	AssignPropertiesTo(dst *v20201201s.VaultCertificate_STATUS) error
}

type augmentConversionForVirtualHardDisk interface {
	AssignPropertiesFrom(src *v20201201s.VirtualHardDisk) error
	AssignPropertiesTo(dst *v20201201s.VirtualHardDisk) error
}

type augmentConversionForVirtualHardDisk_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.VirtualHardDisk_STATUS) error
	AssignPropertiesTo(dst *v20201201s.VirtualHardDisk_STATUS) error
}

type augmentConversionForVirtualMachineExtensionHandlerInstanceView_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.VirtualMachineExtensionHandlerInstanceView_STATUS) error
	AssignPropertiesTo(dst *v20201201s.VirtualMachineExtensionHandlerInstanceView_STATUS) error
}

type augmentConversionForVirtualMachineNetworkInterfaceDnsSettingsConfiguration interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineNetworkInterfaceDnsSettingsConfiguration) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineNetworkInterfaceDnsSettingsConfiguration) error
}

type augmentConversionForVirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS) error
}

type augmentConversionForVirtualMachineNetworkInterfaceIPConfiguration interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineNetworkInterfaceIPConfiguration) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineNetworkInterfaceIPConfiguration) error
}

type augmentConversionForVirtualMachineNetworkInterfaceIPConfiguration_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineNetworkInterfaceIPConfiguration_STATUS) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineNetworkInterfaceIPConfiguration_STATUS) error
}

type augmentConversionForWinRMConfiguration interface {
	AssignPropertiesFrom(src *v20201201s.WinRMConfiguration) error
	AssignPropertiesTo(dst *v20201201s.WinRMConfiguration) error
}

type augmentConversionForWinRMConfiguration_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.WinRMConfiguration_STATUS) error
	AssignPropertiesTo(dst *v20201201s.WinRMConfiguration_STATUS) error
}

// Storage version of v1beta20220301.KeyVaultKeyReference
// Deprecated version of KeyVaultKeyReference. Use v1api20220301.KeyVaultKeyReference instead
type KeyVaultKeyReference struct {
	KeyUrl      *string                `json:"keyUrl,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SourceVault *SubResource           `json:"sourceVault,omitempty"`
}

// AssignProperties_From_KeyVaultKeyReference populates our KeyVaultKeyReference from the provided source KeyVaultKeyReference
func (reference *KeyVaultKeyReference) AssignProperties_From_KeyVaultKeyReference(source *v20201201s.KeyVaultKeyReference) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// KeyUrl
	reference.KeyUrl = genruntime.ClonePointerToString(source.KeyUrl)

	// SourceVault
	if source.SourceVault != nil {
		var sourceVault SubResource
		err := sourceVault.AssignProperties_From_SubResource(source.SourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SourceVault")
		}
		reference.SourceVault = &sourceVault
	} else {
		reference.SourceVault = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		reference.PropertyBag = propertyBag
	} else {
		reference.PropertyBag = nil
	}

	// Invoke the augmentConversionForKeyVaultKeyReference interface (if implemented) to customize the conversion
	var referenceAsAny any = reference
	if augmentedReference, ok := referenceAsAny.(augmentConversionForKeyVaultKeyReference); ok {
		err := augmentedReference.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_KeyVaultKeyReference populates the provided destination KeyVaultKeyReference from our KeyVaultKeyReference
func (reference *KeyVaultKeyReference) AssignProperties_To_KeyVaultKeyReference(destination *v20201201s.KeyVaultKeyReference) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(reference.PropertyBag)

	// KeyUrl
	destination.KeyUrl = genruntime.ClonePointerToString(reference.KeyUrl)

	// SourceVault
	if reference.SourceVault != nil {
		var sourceVault v20201201s.SubResource
		err := reference.SourceVault.AssignProperties_To_SubResource(&sourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SourceVault")
		}
		destination.SourceVault = &sourceVault
	} else {
		destination.SourceVault = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForKeyVaultKeyReference interface (if implemented) to customize the conversion
	var referenceAsAny any = reference
	if augmentedReference, ok := referenceAsAny.(augmentConversionForKeyVaultKeyReference); ok {
		err := augmentedReference.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.KeyVaultKeyReference_STATUS
// Deprecated version of KeyVaultKeyReference_STATUS. Use v1api20220301.KeyVaultKeyReference_STATUS instead
type KeyVaultKeyReference_STATUS struct {
	KeyUrl      *string                `json:"keyUrl,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SourceVault *SubResource_STATUS    `json:"sourceVault,omitempty"`
}

// AssignProperties_From_KeyVaultKeyReference_STATUS populates our KeyVaultKeyReference_STATUS from the provided source KeyVaultKeyReference_STATUS
func (reference *KeyVaultKeyReference_STATUS) AssignProperties_From_KeyVaultKeyReference_STATUS(source *v20201201s.KeyVaultKeyReference_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// KeyUrl
	reference.KeyUrl = genruntime.ClonePointerToString(source.KeyUrl)

	// SourceVault
	if source.SourceVault != nil {
		var sourceVault SubResource_STATUS
		err := sourceVault.AssignProperties_From_SubResource_STATUS(source.SourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SourceVault")
		}
		reference.SourceVault = &sourceVault
	} else {
		reference.SourceVault = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		reference.PropertyBag = propertyBag
	} else {
		reference.PropertyBag = nil
	}

	// Invoke the augmentConversionForKeyVaultKeyReference_STATUS interface (if implemented) to customize the conversion
	var referenceAsAny any = reference
	if augmentedReference, ok := referenceAsAny.(augmentConversionForKeyVaultKeyReference_STATUS); ok {
		err := augmentedReference.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_KeyVaultKeyReference_STATUS populates the provided destination KeyVaultKeyReference_STATUS from our KeyVaultKeyReference_STATUS
func (reference *KeyVaultKeyReference_STATUS) AssignProperties_To_KeyVaultKeyReference_STATUS(destination *v20201201s.KeyVaultKeyReference_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(reference.PropertyBag)

	// KeyUrl
	destination.KeyUrl = genruntime.ClonePointerToString(reference.KeyUrl)

	// SourceVault
	if reference.SourceVault != nil {
		var sourceVault v20201201s.SubResource_STATUS
		err := reference.SourceVault.AssignProperties_To_SubResource_STATUS(&sourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SourceVault")
		}
		destination.SourceVault = &sourceVault
	} else {
		destination.SourceVault = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForKeyVaultKeyReference_STATUS interface (if implemented) to customize the conversion
	var referenceAsAny any = reference
	if augmentedReference, ok := referenceAsAny.(augmentConversionForKeyVaultKeyReference_STATUS); ok {
		err := augmentedReference.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.KeyVaultSecretReference
// Deprecated version of KeyVaultSecretReference. Use v1api20220301.KeyVaultSecretReference instead
type KeyVaultSecretReference struct {
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SecretUrl   *string                `json:"secretUrl,omitempty"`
	SourceVault *SubResource           `json:"sourceVault,omitempty"`
}

// AssignProperties_From_KeyVaultSecretReference populates our KeyVaultSecretReference from the provided source KeyVaultSecretReference
func (reference *KeyVaultSecretReference) AssignProperties_From_KeyVaultSecretReference(source *v20201201s.KeyVaultSecretReference) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// SecretUrl
	reference.SecretUrl = genruntime.ClonePointerToString(source.SecretUrl)

	// SourceVault
	if source.SourceVault != nil {
		var sourceVault SubResource
		err := sourceVault.AssignProperties_From_SubResource(source.SourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SourceVault")
		}
		reference.SourceVault = &sourceVault
	} else {
		reference.SourceVault = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		reference.PropertyBag = propertyBag
	} else {
		reference.PropertyBag = nil
	}

	// Invoke the augmentConversionForKeyVaultSecretReference interface (if implemented) to customize the conversion
	var referenceAsAny any = reference
	if augmentedReference, ok := referenceAsAny.(augmentConversionForKeyVaultSecretReference); ok {
		err := augmentedReference.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_KeyVaultSecretReference populates the provided destination KeyVaultSecretReference from our KeyVaultSecretReference
func (reference *KeyVaultSecretReference) AssignProperties_To_KeyVaultSecretReference(destination *v20201201s.KeyVaultSecretReference) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(reference.PropertyBag)

	// SecretUrl
	destination.SecretUrl = genruntime.ClonePointerToString(reference.SecretUrl)

	// SourceVault
	if reference.SourceVault != nil {
		var sourceVault v20201201s.SubResource
		err := reference.SourceVault.AssignProperties_To_SubResource(&sourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SourceVault")
		}
		destination.SourceVault = &sourceVault
	} else {
		destination.SourceVault = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForKeyVaultSecretReference interface (if implemented) to customize the conversion
	var referenceAsAny any = reference
	if augmentedReference, ok := referenceAsAny.(augmentConversionForKeyVaultSecretReference); ok {
		err := augmentedReference.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.LinuxVMGuestPatchAutomaticByPlatformSettings
// Deprecated version of LinuxVMGuestPatchAutomaticByPlatformSettings. Use v1api20220301.LinuxVMGuestPatchAutomaticByPlatformSettings instead
type LinuxVMGuestPatchAutomaticByPlatformSettings struct {
	PropertyBag   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	RebootSetting *string                `json:"rebootSetting,omitempty"`
}

// AssignProperties_From_LinuxVMGuestPatchAutomaticByPlatformSettings populates our LinuxVMGuestPatchAutomaticByPlatformSettings from the provided source LinuxVMGuestPatchAutomaticByPlatformSettings
func (settings *LinuxVMGuestPatchAutomaticByPlatformSettings) AssignProperties_From_LinuxVMGuestPatchAutomaticByPlatformSettings(source *v20220301s.LinuxVMGuestPatchAutomaticByPlatformSettings) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// RebootSetting
	settings.RebootSetting = genruntime.ClonePointerToString(source.RebootSetting)

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// Invoke the augmentConversionForLinuxVMGuestPatchAutomaticByPlatformSettings interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForLinuxVMGuestPatchAutomaticByPlatformSettings); ok {
		err := augmentedSettings.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_LinuxVMGuestPatchAutomaticByPlatformSettings populates the provided destination LinuxVMGuestPatchAutomaticByPlatformSettings from our LinuxVMGuestPatchAutomaticByPlatformSettings
func (settings *LinuxVMGuestPatchAutomaticByPlatformSettings) AssignProperties_To_LinuxVMGuestPatchAutomaticByPlatformSettings(destination *v20220301s.LinuxVMGuestPatchAutomaticByPlatformSettings) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// RebootSetting
	destination.RebootSetting = genruntime.ClonePointerToString(settings.RebootSetting)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForLinuxVMGuestPatchAutomaticByPlatformSettings interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForLinuxVMGuestPatchAutomaticByPlatformSettings); ok {
		err := augmentedSettings.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS
// Deprecated version of LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS. Use v1api20220301.LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS instead
type LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS struct {
	PropertyBag   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	RebootSetting *string                `json:"rebootSetting,omitempty"`
}

// AssignProperties_From_LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS populates our LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS from the provided source LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS
func (settings *LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS) AssignProperties_From_LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS(source *v20220301s.LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// RebootSetting
	settings.RebootSetting = genruntime.ClonePointerToString(source.RebootSetting)

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// Invoke the augmentConversionForLinuxVMGuestPatchAutomaticByPlatformSettings_STATUS interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForLinuxVMGuestPatchAutomaticByPlatformSettings_STATUS); ok {
		err := augmentedSettings.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS populates the provided destination LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS from our LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS
func (settings *LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS) AssignProperties_To_LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS(destination *v20220301s.LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// RebootSetting
	destination.RebootSetting = genruntime.ClonePointerToString(settings.RebootSetting)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForLinuxVMGuestPatchAutomaticByPlatformSettings_STATUS interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForLinuxVMGuestPatchAutomaticByPlatformSettings_STATUS); ok {
		err := augmentedSettings.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.SshPublicKey_STATUS
// Deprecated version of SshPublicKey_STATUS. Use v1api20220301.SshPublicKey_STATUS instead
type SshPublicKey_STATUS struct {
	KeyData     *string                `json:"keyData,omitempty"`
	Path        *string                `json:"path,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_SshPublicKey_STATUS populates our SshPublicKey_STATUS from the provided source SshPublicKey_STATUS
func (publicKey *SshPublicKey_STATUS) AssignProperties_From_SshPublicKey_STATUS(source *v20201201s.SshPublicKey_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// KeyData
	publicKey.KeyData = genruntime.ClonePointerToString(source.KeyData)

	// Path
	publicKey.Path = genruntime.ClonePointerToString(source.Path)

	// Update the property bag
	if len(propertyBag) > 0 {
		publicKey.PropertyBag = propertyBag
	} else {
		publicKey.PropertyBag = nil
	}

	// Invoke the augmentConversionForSshPublicKey_STATUS interface (if implemented) to customize the conversion
	var publicKeyAsAny any = publicKey
	if augmentedPublicKey, ok := publicKeyAsAny.(augmentConversionForSshPublicKey_STATUS); ok {
		err := augmentedPublicKey.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_SshPublicKey_STATUS populates the provided destination SshPublicKey_STATUS from our SshPublicKey_STATUS
func (publicKey *SshPublicKey_STATUS) AssignProperties_To_SshPublicKey_STATUS(destination *v20201201s.SshPublicKey_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(publicKey.PropertyBag)

	// KeyData
	destination.KeyData = genruntime.ClonePointerToString(publicKey.KeyData)

	// Path
	destination.Path = genruntime.ClonePointerToString(publicKey.Path)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForSshPublicKey_STATUS interface (if implemented) to customize the conversion
	var publicKeyAsAny any = publicKey
	if augmentedPublicKey, ok := publicKeyAsAny.(augmentConversionForSshPublicKey_STATUS); ok {
		err := augmentedPublicKey.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.SshPublicKeySpec
// Deprecated version of SshPublicKeySpec. Use v1api20220301.SshPublicKeySpec instead
type SshPublicKeySpec struct {
	KeyData     *string                `json:"keyData,omitempty"`
	Path        *string                `json:"path,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_SshPublicKeySpec populates our SshPublicKeySpec from the provided source SshPublicKeySpec
func (publicKey *SshPublicKeySpec) AssignProperties_From_SshPublicKeySpec(source *v20201201s.SshPublicKeySpec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// KeyData
	publicKey.KeyData = genruntime.ClonePointerToString(source.KeyData)

	// Path
	publicKey.Path = genruntime.ClonePointerToString(source.Path)

	// Update the property bag
	if len(propertyBag) > 0 {
		publicKey.PropertyBag = propertyBag
	} else {
		publicKey.PropertyBag = nil
	}

	// Invoke the augmentConversionForSshPublicKeySpec interface (if implemented) to customize the conversion
	var publicKeyAsAny any = publicKey
	if augmentedPublicKey, ok := publicKeyAsAny.(augmentConversionForSshPublicKeySpec); ok {
		err := augmentedPublicKey.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_SshPublicKeySpec populates the provided destination SshPublicKeySpec from our SshPublicKeySpec
func (publicKey *SshPublicKeySpec) AssignProperties_To_SshPublicKeySpec(destination *v20201201s.SshPublicKeySpec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(publicKey.PropertyBag)

	// KeyData
	destination.KeyData = genruntime.ClonePointerToString(publicKey.KeyData)

	// Path
	destination.Path = genruntime.ClonePointerToString(publicKey.Path)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForSshPublicKeySpec interface (if implemented) to customize the conversion
	var publicKeyAsAny any = publicKey
	if augmentedPublicKey, ok := publicKeyAsAny.(augmentConversionForSshPublicKeySpec); ok {
		err := augmentedPublicKey.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.VirtualMachinePublicIPAddressConfiguration
// Deprecated version of VirtualMachinePublicIPAddressConfiguration. Use v1api20220301.VirtualMachinePublicIPAddressConfiguration instead
type VirtualMachinePublicIPAddressConfiguration struct {
	DeleteOption             *string                                                `json:"deleteOption,omitempty"`
	DnsSettings              *VirtualMachinePublicIPAddressDnsSettingsConfiguration `json:"dnsSettings,omitempty"`
	IdleTimeoutInMinutes     *int                                                   `json:"idleTimeoutInMinutes,omitempty"`
	IpTags                   []VirtualMachineIpTag                                  `json:"ipTags,omitempty"`
	Name                     *string                                                `json:"name,omitempty"`
	PropertyBag              genruntime.PropertyBag                                 `json:"$propertyBag,omitempty"`
	PublicIPAddressVersion   *string                                                `json:"publicIPAddressVersion,omitempty"`
	PublicIPAllocationMethod *string                                                `json:"publicIPAllocationMethod,omitempty"`
	PublicIPPrefix           *SubResource                                           `json:"publicIPPrefix,omitempty"`
	Sku                      *PublicIPAddressSku                                    `json:"sku,omitempty"`
}

// AssignProperties_From_VirtualMachinePublicIPAddressConfiguration populates our VirtualMachinePublicIPAddressConfiguration from the provided source VirtualMachinePublicIPAddressConfiguration
func (configuration *VirtualMachinePublicIPAddressConfiguration) AssignProperties_From_VirtualMachinePublicIPAddressConfiguration(source *v20220301s.VirtualMachinePublicIPAddressConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DeleteOption
	configuration.DeleteOption = genruntime.ClonePointerToString(source.DeleteOption)

	// DnsSettings
	if source.DnsSettings != nil {
		var dnsSetting VirtualMachinePublicIPAddressDnsSettingsConfiguration
		err := dnsSetting.AssignProperties_From_VirtualMachinePublicIPAddressDnsSettingsConfiguration(source.DnsSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachinePublicIPAddressDnsSettingsConfiguration() to populate field DnsSettings")
		}
		configuration.DnsSettings = &dnsSetting
	} else {
		configuration.DnsSettings = nil
	}

	// IdleTimeoutInMinutes
	configuration.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// IpTags
	if source.IpTags != nil {
		ipTagList := make([]VirtualMachineIpTag, len(source.IpTags))
		for ipTagIndex, ipTagItem := range source.IpTags {
			// Shadow the loop variable to avoid aliasing
			ipTagItem := ipTagItem
			var ipTag VirtualMachineIpTag
			err := ipTag.AssignProperties_From_VirtualMachineIpTag(&ipTagItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineIpTag() to populate field IpTags")
			}
			ipTagList[ipTagIndex] = ipTag
		}
		configuration.IpTags = ipTagList
	} else {
		configuration.IpTags = nil
	}

	// Name
	configuration.Name = genruntime.ClonePointerToString(source.Name)

	// PublicIPAddressVersion
	configuration.PublicIPAddressVersion = genruntime.ClonePointerToString(source.PublicIPAddressVersion)

	// PublicIPAllocationMethod
	configuration.PublicIPAllocationMethod = genruntime.ClonePointerToString(source.PublicIPAllocationMethod)

	// PublicIPPrefix
	if source.PublicIPPrefix != nil {
		var subResourceStash v20210701s.SubResource
		err := subResourceStash.AssignProperties_From_SubResource(source.PublicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SubResourceStash from PublicIPPrefix")
		}
		var subResourceStashLocal v20201201s.SubResource
		err = subResourceStashLocal.AssignProperties_From_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SubResourceStash")
		}
		var publicIPPrefix SubResource
		err = publicIPPrefix.AssignProperties_From_SubResource(&subResourceStashLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field PublicIPPrefix from SubResourceStash")
		}
		configuration.PublicIPPrefix = &publicIPPrefix
	} else {
		configuration.PublicIPPrefix = nil
	}

	// Sku
	if source.Sku != nil {
		var sku PublicIPAddressSku
		err := sku.AssignProperties_From_PublicIPAddressSku(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PublicIPAddressSku() to populate field Sku")
		}
		configuration.Sku = &sku
	} else {
		configuration.Sku = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachinePublicIPAddressConfiguration interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForVirtualMachinePublicIPAddressConfiguration); ok {
		err := augmentedConfiguration.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachinePublicIPAddressConfiguration populates the provided destination VirtualMachinePublicIPAddressConfiguration from our VirtualMachinePublicIPAddressConfiguration
func (configuration *VirtualMachinePublicIPAddressConfiguration) AssignProperties_To_VirtualMachinePublicIPAddressConfiguration(destination *v20220301s.VirtualMachinePublicIPAddressConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// DeleteOption
	destination.DeleteOption = genruntime.ClonePointerToString(configuration.DeleteOption)

	// DnsSettings
	if configuration.DnsSettings != nil {
		var dnsSetting v20220301s.VirtualMachinePublicIPAddressDnsSettingsConfiguration
		err := configuration.DnsSettings.AssignProperties_To_VirtualMachinePublicIPAddressDnsSettingsConfiguration(&dnsSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachinePublicIPAddressDnsSettingsConfiguration() to populate field DnsSettings")
		}
		destination.DnsSettings = &dnsSetting
	} else {
		destination.DnsSettings = nil
	}

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(configuration.IdleTimeoutInMinutes)

	// IpTags
	if configuration.IpTags != nil {
		ipTagList := make([]v20220301s.VirtualMachineIpTag, len(configuration.IpTags))
		for ipTagIndex, ipTagItem := range configuration.IpTags {
			// Shadow the loop variable to avoid aliasing
			ipTagItem := ipTagItem
			var ipTag v20220301s.VirtualMachineIpTag
			err := ipTagItem.AssignProperties_To_VirtualMachineIpTag(&ipTag)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineIpTag() to populate field IpTags")
			}
			ipTagList[ipTagIndex] = ipTag
		}
		destination.IpTags = ipTagList
	} else {
		destination.IpTags = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(configuration.Name)

	// PublicIPAddressVersion
	destination.PublicIPAddressVersion = genruntime.ClonePointerToString(configuration.PublicIPAddressVersion)

	// PublicIPAllocationMethod
	destination.PublicIPAllocationMethod = genruntime.ClonePointerToString(configuration.PublicIPAllocationMethod)

	// PublicIPPrefix
	if configuration.PublicIPPrefix != nil {
		var subResourceStash v20201201s.SubResource
		err := configuration.PublicIPPrefix.AssignProperties_To_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SubResourceStash from PublicIPPrefix")
		}
		var subResourceStashLocal v20210701s.SubResource
		err = subResourceStash.AssignProperties_To_SubResource(&subResourceStashLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SubResourceStash")
		}
		var publicIPPrefix v20220301s.SubResource
		err = subResourceStashLocal.AssignProperties_To_SubResource(&publicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field PublicIPPrefix from SubResourceStash")
		}
		destination.PublicIPPrefix = &publicIPPrefix
	} else {
		destination.PublicIPPrefix = nil
	}

	// Sku
	if configuration.Sku != nil {
		var sku v20220301s.PublicIPAddressSku
		err := configuration.Sku.AssignProperties_To_PublicIPAddressSku(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PublicIPAddressSku() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachinePublicIPAddressConfiguration interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForVirtualMachinePublicIPAddressConfiguration); ok {
		err := augmentedConfiguration.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.VirtualMachinePublicIPAddressConfiguration_STATUS
// Deprecated version of VirtualMachinePublicIPAddressConfiguration_STATUS. Use v1api20220301.VirtualMachinePublicIPAddressConfiguration_STATUS instead
type VirtualMachinePublicIPAddressConfiguration_STATUS struct {
	DeleteOption             *string                                                       `json:"deleteOption,omitempty"`
	DnsSettings              *VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS `json:"dnsSettings,omitempty"`
	IdleTimeoutInMinutes     *int                                                          `json:"idleTimeoutInMinutes,omitempty"`
	IpTags                   []VirtualMachineIpTag_STATUS                                  `json:"ipTags,omitempty"`
	Name                     *string                                                       `json:"name,omitempty"`
	PropertyBag              genruntime.PropertyBag                                        `json:"$propertyBag,omitempty"`
	PublicIPAddressVersion   *string                                                       `json:"publicIPAddressVersion,omitempty"`
	PublicIPAllocationMethod *string                                                       `json:"publicIPAllocationMethod,omitempty"`
	PublicIPPrefix           *SubResource_STATUS                                           `json:"publicIPPrefix,omitempty"`
	Sku                      *PublicIPAddressSku_STATUS                                    `json:"sku,omitempty"`
}

// AssignProperties_From_VirtualMachinePublicIPAddressConfiguration_STATUS populates our VirtualMachinePublicIPAddressConfiguration_STATUS from the provided source VirtualMachinePublicIPAddressConfiguration_STATUS
func (configuration *VirtualMachinePublicIPAddressConfiguration_STATUS) AssignProperties_From_VirtualMachinePublicIPAddressConfiguration_STATUS(source *v20220301s.VirtualMachinePublicIPAddressConfiguration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DeleteOption
	configuration.DeleteOption = genruntime.ClonePointerToString(source.DeleteOption)

	// DnsSettings
	if source.DnsSettings != nil {
		var dnsSetting VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS
		err := dnsSetting.AssignProperties_From_VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS(source.DnsSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS() to populate field DnsSettings")
		}
		configuration.DnsSettings = &dnsSetting
	} else {
		configuration.DnsSettings = nil
	}

	// IdleTimeoutInMinutes
	configuration.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// IpTags
	if source.IpTags != nil {
		ipTagList := make([]VirtualMachineIpTag_STATUS, len(source.IpTags))
		for ipTagIndex, ipTagItem := range source.IpTags {
			// Shadow the loop variable to avoid aliasing
			ipTagItem := ipTagItem
			var ipTag VirtualMachineIpTag_STATUS
			err := ipTag.AssignProperties_From_VirtualMachineIpTag_STATUS(&ipTagItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineIpTag_STATUS() to populate field IpTags")
			}
			ipTagList[ipTagIndex] = ipTag
		}
		configuration.IpTags = ipTagList
	} else {
		configuration.IpTags = nil
	}

	// Name
	configuration.Name = genruntime.ClonePointerToString(source.Name)

	// PublicIPAddressVersion
	configuration.PublicIPAddressVersion = genruntime.ClonePointerToString(source.PublicIPAddressVersion)

	// PublicIPAllocationMethod
	configuration.PublicIPAllocationMethod = genruntime.ClonePointerToString(source.PublicIPAllocationMethod)

	// PublicIPPrefix
	if source.PublicIPPrefix != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := subResourceSTATUSStash.AssignProperties_From_SubResource_STATUS(source.PublicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash from PublicIPPrefix")
		}
		var subResourceSTATUSStashLocal v20201201s.SubResource_STATUS
		err = subResourceSTATUSStashLocal.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash")
		}
		var publicIPPrefix SubResource_STATUS
		err = publicIPPrefix.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStashLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field PublicIPPrefix from SubResource_STATUSStash")
		}
		configuration.PublicIPPrefix = &publicIPPrefix
	} else {
		configuration.PublicIPPrefix = nil
	}

	// Sku
	if source.Sku != nil {
		var sku PublicIPAddressSku_STATUS
		err := sku.AssignProperties_From_PublicIPAddressSku_STATUS(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PublicIPAddressSku_STATUS() to populate field Sku")
		}
		configuration.Sku = &sku
	} else {
		configuration.Sku = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachinePublicIPAddressConfiguration_STATUS interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForVirtualMachinePublicIPAddressConfiguration_STATUS); ok {
		err := augmentedConfiguration.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachinePublicIPAddressConfiguration_STATUS populates the provided destination VirtualMachinePublicIPAddressConfiguration_STATUS from our VirtualMachinePublicIPAddressConfiguration_STATUS
func (configuration *VirtualMachinePublicIPAddressConfiguration_STATUS) AssignProperties_To_VirtualMachinePublicIPAddressConfiguration_STATUS(destination *v20220301s.VirtualMachinePublicIPAddressConfiguration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// DeleteOption
	destination.DeleteOption = genruntime.ClonePointerToString(configuration.DeleteOption)

	// DnsSettings
	if configuration.DnsSettings != nil {
		var dnsSetting v20220301s.VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS
		err := configuration.DnsSettings.AssignProperties_To_VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS(&dnsSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS() to populate field DnsSettings")
		}
		destination.DnsSettings = &dnsSetting
	} else {
		destination.DnsSettings = nil
	}

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(configuration.IdleTimeoutInMinutes)

	// IpTags
	if configuration.IpTags != nil {
		ipTagList := make([]v20220301s.VirtualMachineIpTag_STATUS, len(configuration.IpTags))
		for ipTagIndex, ipTagItem := range configuration.IpTags {
			// Shadow the loop variable to avoid aliasing
			ipTagItem := ipTagItem
			var ipTag v20220301s.VirtualMachineIpTag_STATUS
			err := ipTagItem.AssignProperties_To_VirtualMachineIpTag_STATUS(&ipTag)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineIpTag_STATUS() to populate field IpTags")
			}
			ipTagList[ipTagIndex] = ipTag
		}
		destination.IpTags = ipTagList
	} else {
		destination.IpTags = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(configuration.Name)

	// PublicIPAddressVersion
	destination.PublicIPAddressVersion = genruntime.ClonePointerToString(configuration.PublicIPAddressVersion)

	// PublicIPAllocationMethod
	destination.PublicIPAllocationMethod = genruntime.ClonePointerToString(configuration.PublicIPAllocationMethod)

	// PublicIPPrefix
	if configuration.PublicIPPrefix != nil {
		var subResourceSTATUSStash v20201201s.SubResource_STATUS
		err := configuration.PublicIPPrefix.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash from PublicIPPrefix")
		}
		var subResourceSTATUSStashLocal v20210701s.SubResource_STATUS
		err = subResourceSTATUSStash.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStashLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash")
		}
		var publicIPPrefix v20220301s.SubResource_STATUS
		err = subResourceSTATUSStashLocal.AssignProperties_To_SubResource_STATUS(&publicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field PublicIPPrefix from SubResource_STATUSStash")
		}
		destination.PublicIPPrefix = &publicIPPrefix
	} else {
		destination.PublicIPPrefix = nil
	}

	// Sku
	if configuration.Sku != nil {
		var sku v20220301s.PublicIPAddressSku_STATUS
		err := configuration.Sku.AssignProperties_To_PublicIPAddressSku_STATUS(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PublicIPAddressSku_STATUS() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachinePublicIPAddressConfiguration_STATUS interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForVirtualMachinePublicIPAddressConfiguration_STATUS); ok {
		err := augmentedConfiguration.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.VMDiskSecurityProfile
// Deprecated version of VMDiskSecurityProfile. Use v1api20220301.VMDiskSecurityProfile instead
type VMDiskSecurityProfile struct {
	DiskEncryptionSet      *SubResource           `json:"diskEncryptionSet,omitempty"`
	PropertyBag            genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SecurityEncryptionType *string                `json:"securityEncryptionType,omitempty"`
}

// AssignProperties_From_VMDiskSecurityProfile populates our VMDiskSecurityProfile from the provided source VMDiskSecurityProfile
func (profile *VMDiskSecurityProfile) AssignProperties_From_VMDiskSecurityProfile(source *v20220301s.VMDiskSecurityProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DiskEncryptionSet
	if source.DiskEncryptionSet != nil {
		var subResourceStash v20210701s.SubResource
		err := subResourceStash.AssignProperties_From_SubResource(source.DiskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SubResourceStash from DiskEncryptionSet")
		}
		var subResourceStashLocal v20201201s.SubResource
		err = subResourceStashLocal.AssignProperties_From_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SubResourceStash")
		}
		var diskEncryptionSet SubResource
		err = diskEncryptionSet.AssignProperties_From_SubResource(&subResourceStashLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field DiskEncryptionSet from SubResourceStash")
		}
		profile.DiskEncryptionSet = &diskEncryptionSet
	} else {
		profile.DiskEncryptionSet = nil
	}

	// SecurityEncryptionType
	profile.SecurityEncryptionType = genruntime.ClonePointerToString(source.SecurityEncryptionType)

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForVMDiskSecurityProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForVMDiskSecurityProfile); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VMDiskSecurityProfile populates the provided destination VMDiskSecurityProfile from our VMDiskSecurityProfile
func (profile *VMDiskSecurityProfile) AssignProperties_To_VMDiskSecurityProfile(destination *v20220301s.VMDiskSecurityProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// DiskEncryptionSet
	if profile.DiskEncryptionSet != nil {
		var subResourceStash v20201201s.SubResource
		err := profile.DiskEncryptionSet.AssignProperties_To_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SubResourceStash from DiskEncryptionSet")
		}
		var subResourceStashLocal v20210701s.SubResource
		err = subResourceStash.AssignProperties_To_SubResource(&subResourceStashLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SubResourceStash")
		}
		var diskEncryptionSet v20220301s.SubResource
		err = subResourceStashLocal.AssignProperties_To_SubResource(&diskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field DiskEncryptionSet from SubResourceStash")
		}
		destination.DiskEncryptionSet = &diskEncryptionSet
	} else {
		destination.DiskEncryptionSet = nil
	}

	// SecurityEncryptionType
	destination.SecurityEncryptionType = genruntime.ClonePointerToString(profile.SecurityEncryptionType)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVMDiskSecurityProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForVMDiskSecurityProfile); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.VMDiskSecurityProfile_STATUS
// Deprecated version of VMDiskSecurityProfile_STATUS. Use v1api20220301.VMDiskSecurityProfile_STATUS instead
type VMDiskSecurityProfile_STATUS struct {
	DiskEncryptionSet      *SubResource_STATUS    `json:"diskEncryptionSet,omitempty"`
	PropertyBag            genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SecurityEncryptionType *string                `json:"securityEncryptionType,omitempty"`
}

// AssignProperties_From_VMDiskSecurityProfile_STATUS populates our VMDiskSecurityProfile_STATUS from the provided source VMDiskSecurityProfile_STATUS
func (profile *VMDiskSecurityProfile_STATUS) AssignProperties_From_VMDiskSecurityProfile_STATUS(source *v20220301s.VMDiskSecurityProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DiskEncryptionSet
	if source.DiskEncryptionSet != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := subResourceSTATUSStash.AssignProperties_From_SubResource_STATUS(source.DiskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash from DiskEncryptionSet")
		}
		var subResourceSTATUSStashLocal v20201201s.SubResource_STATUS
		err = subResourceSTATUSStashLocal.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash")
		}
		var diskEncryptionSet SubResource_STATUS
		err = diskEncryptionSet.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStashLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field DiskEncryptionSet from SubResource_STATUSStash")
		}
		profile.DiskEncryptionSet = &diskEncryptionSet
	} else {
		profile.DiskEncryptionSet = nil
	}

	// SecurityEncryptionType
	profile.SecurityEncryptionType = genruntime.ClonePointerToString(source.SecurityEncryptionType)

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForVMDiskSecurityProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForVMDiskSecurityProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VMDiskSecurityProfile_STATUS populates the provided destination VMDiskSecurityProfile_STATUS from our VMDiskSecurityProfile_STATUS
func (profile *VMDiskSecurityProfile_STATUS) AssignProperties_To_VMDiskSecurityProfile_STATUS(destination *v20220301s.VMDiskSecurityProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// DiskEncryptionSet
	if profile.DiskEncryptionSet != nil {
		var subResourceSTATUSStash v20201201s.SubResource_STATUS
		err := profile.DiskEncryptionSet.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash from DiskEncryptionSet")
		}
		var subResourceSTATUSStashLocal v20210701s.SubResource_STATUS
		err = subResourceSTATUSStash.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStashLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash")
		}
		var diskEncryptionSet v20220301s.SubResource_STATUS
		err = subResourceSTATUSStashLocal.AssignProperties_To_SubResource_STATUS(&diskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field DiskEncryptionSet from SubResource_STATUSStash")
		}
		destination.DiskEncryptionSet = &diskEncryptionSet
	} else {
		destination.DiskEncryptionSet = nil
	}

	// SecurityEncryptionType
	destination.SecurityEncryptionType = genruntime.ClonePointerToString(profile.SecurityEncryptionType)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVMDiskSecurityProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForVMDiskSecurityProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.WindowsVMGuestPatchAutomaticByPlatformSettings
// Deprecated version of WindowsVMGuestPatchAutomaticByPlatformSettings. Use v1api20220301.WindowsVMGuestPatchAutomaticByPlatformSettings instead
type WindowsVMGuestPatchAutomaticByPlatformSettings struct {
	PropertyBag   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	RebootSetting *string                `json:"rebootSetting,omitempty"`
}

// AssignProperties_From_WindowsVMGuestPatchAutomaticByPlatformSettings populates our WindowsVMGuestPatchAutomaticByPlatformSettings from the provided source WindowsVMGuestPatchAutomaticByPlatformSettings
func (settings *WindowsVMGuestPatchAutomaticByPlatformSettings) AssignProperties_From_WindowsVMGuestPatchAutomaticByPlatformSettings(source *v20220301s.WindowsVMGuestPatchAutomaticByPlatformSettings) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// RebootSetting
	settings.RebootSetting = genruntime.ClonePointerToString(source.RebootSetting)

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// Invoke the augmentConversionForWindowsVMGuestPatchAutomaticByPlatformSettings interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForWindowsVMGuestPatchAutomaticByPlatformSettings); ok {
		err := augmentedSettings.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_WindowsVMGuestPatchAutomaticByPlatformSettings populates the provided destination WindowsVMGuestPatchAutomaticByPlatformSettings from our WindowsVMGuestPatchAutomaticByPlatformSettings
func (settings *WindowsVMGuestPatchAutomaticByPlatformSettings) AssignProperties_To_WindowsVMGuestPatchAutomaticByPlatformSettings(destination *v20220301s.WindowsVMGuestPatchAutomaticByPlatformSettings) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// RebootSetting
	destination.RebootSetting = genruntime.ClonePointerToString(settings.RebootSetting)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForWindowsVMGuestPatchAutomaticByPlatformSettings interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForWindowsVMGuestPatchAutomaticByPlatformSettings); ok {
		err := augmentedSettings.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS
// Deprecated version of WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS. Use v1api20220301.WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS instead
type WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS struct {
	PropertyBag   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	RebootSetting *string                `json:"rebootSetting,omitempty"`
}

// AssignProperties_From_WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS populates our WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS from the provided source WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS
func (settings *WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS) AssignProperties_From_WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS(source *v20220301s.WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// RebootSetting
	settings.RebootSetting = genruntime.ClonePointerToString(source.RebootSetting)

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// Invoke the augmentConversionForWindowsVMGuestPatchAutomaticByPlatformSettings_STATUS interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForWindowsVMGuestPatchAutomaticByPlatformSettings_STATUS); ok {
		err := augmentedSettings.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS populates the provided destination WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS from our WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS
func (settings *WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS) AssignProperties_To_WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS(destination *v20220301s.WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// RebootSetting
	destination.RebootSetting = genruntime.ClonePointerToString(settings.RebootSetting)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForWindowsVMGuestPatchAutomaticByPlatformSettings_STATUS interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForWindowsVMGuestPatchAutomaticByPlatformSettings_STATUS); ok {
		err := augmentedSettings.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.WinRMListener
// Deprecated version of WinRMListener. Use v1api20220301.WinRMListener instead
type WinRMListener struct {
	CertificateUrl *string                `json:"certificateUrl,omitempty"`
	PropertyBag    genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Protocol       *string                `json:"protocol,omitempty"`
}

// AssignProperties_From_WinRMListener populates our WinRMListener from the provided source WinRMListener
func (listener *WinRMListener) AssignProperties_From_WinRMListener(source *v20201201s.WinRMListener) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CertificateUrl
	listener.CertificateUrl = genruntime.ClonePointerToString(source.CertificateUrl)

	// Protocol
	listener.Protocol = genruntime.ClonePointerToString(source.Protocol)

	// Update the property bag
	if len(propertyBag) > 0 {
		listener.PropertyBag = propertyBag
	} else {
		listener.PropertyBag = nil
	}

	// Invoke the augmentConversionForWinRMListener interface (if implemented) to customize the conversion
	var listenerAsAny any = listener
	if augmentedListener, ok := listenerAsAny.(augmentConversionForWinRMListener); ok {
		err := augmentedListener.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_WinRMListener populates the provided destination WinRMListener from our WinRMListener
func (listener *WinRMListener) AssignProperties_To_WinRMListener(destination *v20201201s.WinRMListener) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(listener.PropertyBag)

	// CertificateUrl
	destination.CertificateUrl = genruntime.ClonePointerToString(listener.CertificateUrl)

	// Protocol
	destination.Protocol = genruntime.ClonePointerToString(listener.Protocol)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForWinRMListener interface (if implemented) to customize the conversion
	var listenerAsAny any = listener
	if augmentedListener, ok := listenerAsAny.(augmentConversionForWinRMListener); ok {
		err := augmentedListener.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.WinRMListener_STATUS
// Deprecated version of WinRMListener_STATUS. Use v1api20220301.WinRMListener_STATUS instead
type WinRMListener_STATUS struct {
	CertificateUrl *string                `json:"certificateUrl,omitempty"`
	PropertyBag    genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Protocol       *string                `json:"protocol,omitempty"`
}

// AssignProperties_From_WinRMListener_STATUS populates our WinRMListener_STATUS from the provided source WinRMListener_STATUS
func (listener *WinRMListener_STATUS) AssignProperties_From_WinRMListener_STATUS(source *v20201201s.WinRMListener_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CertificateUrl
	listener.CertificateUrl = genruntime.ClonePointerToString(source.CertificateUrl)

	// Protocol
	listener.Protocol = genruntime.ClonePointerToString(source.Protocol)

	// Update the property bag
	if len(propertyBag) > 0 {
		listener.PropertyBag = propertyBag
	} else {
		listener.PropertyBag = nil
	}

	// Invoke the augmentConversionForWinRMListener_STATUS interface (if implemented) to customize the conversion
	var listenerAsAny any = listener
	if augmentedListener, ok := listenerAsAny.(augmentConversionForWinRMListener_STATUS); ok {
		err := augmentedListener.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_WinRMListener_STATUS populates the provided destination WinRMListener_STATUS from our WinRMListener_STATUS
func (listener *WinRMListener_STATUS) AssignProperties_To_WinRMListener_STATUS(destination *v20201201s.WinRMListener_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(listener.PropertyBag)

	// CertificateUrl
	destination.CertificateUrl = genruntime.ClonePointerToString(listener.CertificateUrl)

	// Protocol
	destination.Protocol = genruntime.ClonePointerToString(listener.Protocol)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForWinRMListener_STATUS interface (if implemented) to customize the conversion
	var listenerAsAny any = listener
	if augmentedListener, ok := listenerAsAny.(augmentConversionForWinRMListener_STATUS); ok {
		err := augmentedListener.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.ApiErrorBase_STATUS
// Deprecated version of ApiErrorBase_STATUS. Use v1api20220301.ApiErrorBase_STATUS instead
type ApiErrorBase_STATUS struct {
	Code        *string                `json:"code,omitempty"`
	Message     *string                `json:"message,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Target      *string                `json:"target,omitempty"`
}

// AssignProperties_From_ApiErrorBase_STATUS populates our ApiErrorBase_STATUS from the provided source ApiErrorBase_STATUS
func (base *ApiErrorBase_STATUS) AssignProperties_From_ApiErrorBase_STATUS(source *v20201201s.ApiErrorBase_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Code
	base.Code = genruntime.ClonePointerToString(source.Code)

	// Message
	base.Message = genruntime.ClonePointerToString(source.Message)

	// Target
	base.Target = genruntime.ClonePointerToString(source.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		base.PropertyBag = propertyBag
	} else {
		base.PropertyBag = nil
	}

	// Invoke the augmentConversionForApiErrorBase_STATUS interface (if implemented) to customize the conversion
	var baseAsAny any = base
	if augmentedBase, ok := baseAsAny.(augmentConversionForApiErrorBase_STATUS); ok {
		err := augmentedBase.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ApiErrorBase_STATUS populates the provided destination ApiErrorBase_STATUS from our ApiErrorBase_STATUS
func (base *ApiErrorBase_STATUS) AssignProperties_To_ApiErrorBase_STATUS(destination *v20201201s.ApiErrorBase_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(base.PropertyBag)

	// Code
	destination.Code = genruntime.ClonePointerToString(base.Code)

	// Message
	destination.Message = genruntime.ClonePointerToString(base.Message)

	// Target
	destination.Target = genruntime.ClonePointerToString(base.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForApiErrorBase_STATUS interface (if implemented) to customize the conversion
	var baseAsAny any = base
	if augmentedBase, ok := baseAsAny.(augmentConversionForApiErrorBase_STATUS); ok {
		err := augmentedBase.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForApiError_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.ApiError_STATUS) error
	AssignPropertiesTo(dst *v20201201s.ApiError_STATUS) error
}

type augmentConversionForKeyVaultKeyReference interface {
	AssignPropertiesFrom(src *v20201201s.KeyVaultKeyReference) error
	AssignPropertiesTo(dst *v20201201s.KeyVaultKeyReference) error
}

type augmentConversionForKeyVaultKeyReference_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.KeyVaultKeyReference_STATUS) error
	AssignPropertiesTo(dst *v20201201s.KeyVaultKeyReference_STATUS) error
}

type augmentConversionForKeyVaultSecretReference interface {
	AssignPropertiesFrom(src *v20201201s.KeyVaultSecretReference) error
	AssignPropertiesTo(dst *v20201201s.KeyVaultSecretReference) error
}

type augmentConversionForLinuxVMGuestPatchAutomaticByPlatformSettings interface {
	AssignPropertiesFrom(src *v20220301s.LinuxVMGuestPatchAutomaticByPlatformSettings) error
	AssignPropertiesTo(dst *v20220301s.LinuxVMGuestPatchAutomaticByPlatformSettings) error
}

type augmentConversionForLinuxVMGuestPatchAutomaticByPlatformSettings_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS) error
	AssignPropertiesTo(dst *v20220301s.LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS) error
}

type augmentConversionForSshPublicKey_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.SshPublicKey_STATUS) error
	AssignPropertiesTo(dst *v20201201s.SshPublicKey_STATUS) error
}

type augmentConversionForSshPublicKeySpec interface {
	AssignPropertiesFrom(src *v20201201s.SshPublicKeySpec) error
	AssignPropertiesTo(dst *v20201201s.SshPublicKeySpec) error
}

type augmentConversionForVirtualMachinePublicIPAddressConfiguration interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachinePublicIPAddressConfiguration) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachinePublicIPAddressConfiguration) error
}

type augmentConversionForVirtualMachinePublicIPAddressConfiguration_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachinePublicIPAddressConfiguration_STATUS) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachinePublicIPAddressConfiguration_STATUS) error
}

type augmentConversionForVMDiskSecurityProfile interface {
	AssignPropertiesFrom(src *v20220301s.VMDiskSecurityProfile) error
	AssignPropertiesTo(dst *v20220301s.VMDiskSecurityProfile) error
}

type augmentConversionForVMDiskSecurityProfile_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.VMDiskSecurityProfile_STATUS) error
	AssignPropertiesTo(dst *v20220301s.VMDiskSecurityProfile_STATUS) error
}

type augmentConversionForWindowsVMGuestPatchAutomaticByPlatformSettings interface {
	AssignPropertiesFrom(src *v20220301s.WindowsVMGuestPatchAutomaticByPlatformSettings) error
	AssignPropertiesTo(dst *v20220301s.WindowsVMGuestPatchAutomaticByPlatformSettings) error
}

type augmentConversionForWindowsVMGuestPatchAutomaticByPlatformSettings_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS) error
	AssignPropertiesTo(dst *v20220301s.WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS) error
}

type augmentConversionForWinRMListener interface {
	AssignPropertiesFrom(src *v20201201s.WinRMListener) error
	AssignPropertiesTo(dst *v20201201s.WinRMListener) error
}

type augmentConversionForWinRMListener_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.WinRMListener_STATUS) error
	AssignPropertiesTo(dst *v20201201s.WinRMListener_STATUS) error
}

// Storage version of v1beta20220301.InnerError_STATUS
// Deprecated version of InnerError_STATUS. Use v1api20220301.InnerError_STATUS instead
type InnerError_STATUS struct {
	Errordetail   *string                `json:"errordetail,omitempty"`
	Exceptiontype *string                `json:"exceptiontype,omitempty"`
	PropertyBag   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_InnerError_STATUS populates our InnerError_STATUS from the provided source InnerError_STATUS
func (error *InnerError_STATUS) AssignProperties_From_InnerError_STATUS(source *v20201201s.InnerError_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Errordetail
	error.Errordetail = genruntime.ClonePointerToString(source.Errordetail)

	// Exceptiontype
	error.Exceptiontype = genruntime.ClonePointerToString(source.Exceptiontype)

	// Update the property bag
	if len(propertyBag) > 0 {
		error.PropertyBag = propertyBag
	} else {
		error.PropertyBag = nil
	}

	// Invoke the augmentConversionForInnerError_STATUS interface (if implemented) to customize the conversion
	var errorAsAny any = error
	if augmentedError, ok := errorAsAny.(augmentConversionForInnerError_STATUS); ok {
		err := augmentedError.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_InnerError_STATUS populates the provided destination InnerError_STATUS from our InnerError_STATUS
func (error *InnerError_STATUS) AssignProperties_To_InnerError_STATUS(destination *v20201201s.InnerError_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(error.PropertyBag)

	// Errordetail
	destination.Errordetail = genruntime.ClonePointerToString(error.Errordetail)

	// Exceptiontype
	destination.Exceptiontype = genruntime.ClonePointerToString(error.Exceptiontype)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForInnerError_STATUS interface (if implemented) to customize the conversion
	var errorAsAny any = error
	if augmentedError, ok := errorAsAny.(augmentConversionForInnerError_STATUS); ok {
		err := augmentedError.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.PublicIPAddressSku
// Deprecated version of PublicIPAddressSku. Use v1api20220301.PublicIPAddressSku instead
type PublicIPAddressSku struct {
	Name        *string                `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Tier        *string                `json:"tier,omitempty"`
}

// AssignProperties_From_PublicIPAddressSku populates our PublicIPAddressSku from the provided source PublicIPAddressSku
func (addressSku *PublicIPAddressSku) AssignProperties_From_PublicIPAddressSku(source *v20220301s.PublicIPAddressSku) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	addressSku.Name = genruntime.ClonePointerToString(source.Name)

	// Tier
	addressSku.Tier = genruntime.ClonePointerToString(source.Tier)

	// Update the property bag
	if len(propertyBag) > 0 {
		addressSku.PropertyBag = propertyBag
	} else {
		addressSku.PropertyBag = nil
	}

	// Invoke the augmentConversionForPublicIPAddressSku interface (if implemented) to customize the conversion
	var addressSkuAsAny any = addressSku
	if augmentedAddressSku, ok := addressSkuAsAny.(augmentConversionForPublicIPAddressSku); ok {
		err := augmentedAddressSku.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_PublicIPAddressSku populates the provided destination PublicIPAddressSku from our PublicIPAddressSku
func (addressSku *PublicIPAddressSku) AssignProperties_To_PublicIPAddressSku(destination *v20220301s.PublicIPAddressSku) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(addressSku.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(addressSku.Name)

	// Tier
	destination.Tier = genruntime.ClonePointerToString(addressSku.Tier)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForPublicIPAddressSku interface (if implemented) to customize the conversion
	var addressSkuAsAny any = addressSku
	if augmentedAddressSku, ok := addressSkuAsAny.(augmentConversionForPublicIPAddressSku); ok {
		err := augmentedAddressSku.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.PublicIPAddressSku_STATUS
// Deprecated version of PublicIPAddressSku_STATUS. Use v1api20220301.PublicIPAddressSku_STATUS instead
type PublicIPAddressSku_STATUS struct {
	Name        *string                `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Tier        *string                `json:"tier,omitempty"`
}

// AssignProperties_From_PublicIPAddressSku_STATUS populates our PublicIPAddressSku_STATUS from the provided source PublicIPAddressSku_STATUS
func (addressSku *PublicIPAddressSku_STATUS) AssignProperties_From_PublicIPAddressSku_STATUS(source *v20220301s.PublicIPAddressSku_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	addressSku.Name = genruntime.ClonePointerToString(source.Name)

	// Tier
	addressSku.Tier = genruntime.ClonePointerToString(source.Tier)

	// Update the property bag
	if len(propertyBag) > 0 {
		addressSku.PropertyBag = propertyBag
	} else {
		addressSku.PropertyBag = nil
	}

	// Invoke the augmentConversionForPublicIPAddressSku_STATUS interface (if implemented) to customize the conversion
	var addressSkuAsAny any = addressSku
	if augmentedAddressSku, ok := addressSkuAsAny.(augmentConversionForPublicIPAddressSku_STATUS); ok {
		err := augmentedAddressSku.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_PublicIPAddressSku_STATUS populates the provided destination PublicIPAddressSku_STATUS from our PublicIPAddressSku_STATUS
func (addressSku *PublicIPAddressSku_STATUS) AssignProperties_To_PublicIPAddressSku_STATUS(destination *v20220301s.PublicIPAddressSku_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(addressSku.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(addressSku.Name)

	// Tier
	destination.Tier = genruntime.ClonePointerToString(addressSku.Tier)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForPublicIPAddressSku_STATUS interface (if implemented) to customize the conversion
	var addressSkuAsAny any = addressSku
	if augmentedAddressSku, ok := addressSkuAsAny.(augmentConversionForPublicIPAddressSku_STATUS); ok {
		err := augmentedAddressSku.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.VirtualMachineIpTag
// Deprecated version of VirtualMachineIpTag. Use v1api20220301.VirtualMachineIpTag instead
type VirtualMachineIpTag struct {
	IpTagType   *string                `json:"ipTagType,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Tag         *string                `json:"tag,omitempty"`
}

// AssignProperties_From_VirtualMachineIpTag populates our VirtualMachineIpTag from the provided source VirtualMachineIpTag
func (ipTag *VirtualMachineIpTag) AssignProperties_From_VirtualMachineIpTag(source *v20220301s.VirtualMachineIpTag) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// IpTagType
	ipTag.IpTagType = genruntime.ClonePointerToString(source.IpTagType)

	// Tag
	ipTag.Tag = genruntime.ClonePointerToString(source.Tag)

	// Update the property bag
	if len(propertyBag) > 0 {
		ipTag.PropertyBag = propertyBag
	} else {
		ipTag.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineIpTag interface (if implemented) to customize the conversion
	var ipTagAsAny any = ipTag
	if augmentedIpTag, ok := ipTagAsAny.(augmentConversionForVirtualMachineIpTag); ok {
		err := augmentedIpTag.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineIpTag populates the provided destination VirtualMachineIpTag from our VirtualMachineIpTag
func (ipTag *VirtualMachineIpTag) AssignProperties_To_VirtualMachineIpTag(destination *v20220301s.VirtualMachineIpTag) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(ipTag.PropertyBag)

	// IpTagType
	destination.IpTagType = genruntime.ClonePointerToString(ipTag.IpTagType)

	// Tag
	destination.Tag = genruntime.ClonePointerToString(ipTag.Tag)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineIpTag interface (if implemented) to customize the conversion
	var ipTagAsAny any = ipTag
	if augmentedIpTag, ok := ipTagAsAny.(augmentConversionForVirtualMachineIpTag); ok {
		err := augmentedIpTag.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.VirtualMachineIpTag_STATUS
// Deprecated version of VirtualMachineIpTag_STATUS. Use v1api20220301.VirtualMachineIpTag_STATUS instead
type VirtualMachineIpTag_STATUS struct {
	IpTagType   *string                `json:"ipTagType,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Tag         *string                `json:"tag,omitempty"`
}

// AssignProperties_From_VirtualMachineIpTag_STATUS populates our VirtualMachineIpTag_STATUS from the provided source VirtualMachineIpTag_STATUS
func (ipTag *VirtualMachineIpTag_STATUS) AssignProperties_From_VirtualMachineIpTag_STATUS(source *v20220301s.VirtualMachineIpTag_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// IpTagType
	ipTag.IpTagType = genruntime.ClonePointerToString(source.IpTagType)

	// Tag
	ipTag.Tag = genruntime.ClonePointerToString(source.Tag)

	// Update the property bag
	if len(propertyBag) > 0 {
		ipTag.PropertyBag = propertyBag
	} else {
		ipTag.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineIpTag_STATUS interface (if implemented) to customize the conversion
	var ipTagAsAny any = ipTag
	if augmentedIpTag, ok := ipTagAsAny.(augmentConversionForVirtualMachineIpTag_STATUS); ok {
		err := augmentedIpTag.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineIpTag_STATUS populates the provided destination VirtualMachineIpTag_STATUS from our VirtualMachineIpTag_STATUS
func (ipTag *VirtualMachineIpTag_STATUS) AssignProperties_To_VirtualMachineIpTag_STATUS(destination *v20220301s.VirtualMachineIpTag_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(ipTag.PropertyBag)

	// IpTagType
	destination.IpTagType = genruntime.ClonePointerToString(ipTag.IpTagType)

	// Tag
	destination.Tag = genruntime.ClonePointerToString(ipTag.Tag)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineIpTag_STATUS interface (if implemented) to customize the conversion
	var ipTagAsAny any = ipTag
	if augmentedIpTag, ok := ipTagAsAny.(augmentConversionForVirtualMachineIpTag_STATUS); ok {
		err := augmentedIpTag.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.VirtualMachinePublicIPAddressDnsSettingsConfiguration
// Deprecated version of VirtualMachinePublicIPAddressDnsSettingsConfiguration. Use v1api20220301.VirtualMachinePublicIPAddressDnsSettingsConfiguration instead
type VirtualMachinePublicIPAddressDnsSettingsConfiguration struct {
	DomainNameLabel *string                `json:"domainNameLabel,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_VirtualMachinePublicIPAddressDnsSettingsConfiguration populates our VirtualMachinePublicIPAddressDnsSettingsConfiguration from the provided source VirtualMachinePublicIPAddressDnsSettingsConfiguration
func (configuration *VirtualMachinePublicIPAddressDnsSettingsConfiguration) AssignProperties_From_VirtualMachinePublicIPAddressDnsSettingsConfiguration(source *v20220301s.VirtualMachinePublicIPAddressDnsSettingsConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DomainNameLabel
	configuration.DomainNameLabel = genruntime.ClonePointerToString(source.DomainNameLabel)

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachinePublicIPAddressDnsSettingsConfiguration interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForVirtualMachinePublicIPAddressDnsSettingsConfiguration); ok {
		err := augmentedConfiguration.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachinePublicIPAddressDnsSettingsConfiguration populates the provided destination VirtualMachinePublicIPAddressDnsSettingsConfiguration from our VirtualMachinePublicIPAddressDnsSettingsConfiguration
func (configuration *VirtualMachinePublicIPAddressDnsSettingsConfiguration) AssignProperties_To_VirtualMachinePublicIPAddressDnsSettingsConfiguration(destination *v20220301s.VirtualMachinePublicIPAddressDnsSettingsConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// DomainNameLabel
	destination.DomainNameLabel = genruntime.ClonePointerToString(configuration.DomainNameLabel)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachinePublicIPAddressDnsSettingsConfiguration interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForVirtualMachinePublicIPAddressDnsSettingsConfiguration); ok {
		err := augmentedConfiguration.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20220301.VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS
// Deprecated version of VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS. Use v1api20220301.VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS instead
type VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS struct {
	DomainNameLabel *string                `json:"domainNameLabel,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS populates our VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS from the provided source VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS
func (configuration *VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS) AssignProperties_From_VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS(source *v20220301s.VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DomainNameLabel
	configuration.DomainNameLabel = genruntime.ClonePointerToString(source.DomainNameLabel)

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForVirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS); ok {
		err := augmentedConfiguration.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS populates the provided destination VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS from our VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS
func (configuration *VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS) AssignProperties_To_VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS(destination *v20220301s.VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// DomainNameLabel
	destination.DomainNameLabel = genruntime.ClonePointerToString(configuration.DomainNameLabel)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForVirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS); ok {
		err := augmentedConfiguration.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForApiErrorBase_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.ApiErrorBase_STATUS) error
	AssignPropertiesTo(dst *v20201201s.ApiErrorBase_STATUS) error
}

type augmentConversionForInnerError_STATUS interface {
	AssignPropertiesFrom(src *v20201201s.InnerError_STATUS) error
	AssignPropertiesTo(dst *v20201201s.InnerError_STATUS) error
}

type augmentConversionForPublicIPAddressSku interface {
	AssignPropertiesFrom(src *v20220301s.PublicIPAddressSku) error
	AssignPropertiesTo(dst *v20220301s.PublicIPAddressSku) error
}

type augmentConversionForPublicIPAddressSku_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.PublicIPAddressSku_STATUS) error
	AssignPropertiesTo(dst *v20220301s.PublicIPAddressSku_STATUS) error
}

type augmentConversionForVirtualMachineIpTag interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineIpTag) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineIpTag) error
}

type augmentConversionForVirtualMachineIpTag_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineIpTag_STATUS) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineIpTag_STATUS) error
}

type augmentConversionForVirtualMachinePublicIPAddressDnsSettingsConfiguration interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachinePublicIPAddressDnsSettingsConfiguration) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachinePublicIPAddressDnsSettingsConfiguration) error
}

type augmentConversionForVirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS) error
}

func init() {
	SchemeBuilder.Register(&VirtualMachine{}, &VirtualMachineList{})
}
