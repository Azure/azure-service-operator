// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20220301

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_VirtualMachines_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachines_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachinesSpecARM, VirtualMachinesSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachinesSpecARM runs a test to see if a specific instance of VirtualMachines_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachinesSpecARM(subject VirtualMachines_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachines_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachines_SpecARM instances for property testing - lazily instantiated by
// VirtualMachinesSpecARMGenerator()
var virtualMachinesSpecARMGenerator gopter.Gen

// VirtualMachinesSpecARMGenerator returns a generator of VirtualMachines_SpecARM instances for property testing.
// We first initialize virtualMachinesSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachinesSpecARMGenerator() gopter.Gen {
	if virtualMachinesSpecARMGenerator != nil {
		return virtualMachinesSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinesSpecARM(generators)
	virtualMachinesSpecARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinesSpecARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachinesSpecARM(generators)
	virtualMachinesSpecARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_SpecARM{}), generators)

	return virtualMachinesSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachinesSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachinesSpecARM(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachinesSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachinesSpecARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationARMGenerator())
	gens["Identity"] = gen.PtrOf(VirtualMachineIdentityARMGenerator())
	gens["Plan"] = gen.PtrOf(PlanARMGenerator())
	gens["Properties"] = gen.PtrOf(VirtualMachinesSpecPropertiesARMGenerator())
}

func Test_VirtualMachineIdentityARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineIdentityARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineIdentityARM, VirtualMachineIdentityARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineIdentityARM runs a test to see if a specific instance of VirtualMachineIdentityARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineIdentityARM(subject VirtualMachineIdentityARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineIdentityARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineIdentityARM instances for property testing - lazily instantiated by
// VirtualMachineIdentityARMGenerator()
var virtualMachineIdentityARMGenerator gopter.Gen

// VirtualMachineIdentityARMGenerator returns a generator of VirtualMachineIdentityARM instances for property testing.
func VirtualMachineIdentityARMGenerator() gopter.Gen {
	if virtualMachineIdentityARMGenerator != nil {
		return virtualMachineIdentityARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineIdentityARM(generators)
	virtualMachineIdentityARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineIdentityARM{}), generators)

	return virtualMachineIdentityARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineIdentityARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineIdentityARM(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		VirtualMachineIdentityTypeNone,
		VirtualMachineIdentityTypeSystemAssigned,
		VirtualMachineIdentityTypeSystemAssignedUserAssigned,
		VirtualMachineIdentityTypeUserAssigned))
}

func Test_VirtualMachines_Spec_PropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachines_Spec_PropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachinesSpecPropertiesARM, VirtualMachinesSpecPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachinesSpecPropertiesARM runs a test to see if a specific instance of VirtualMachines_Spec_PropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachinesSpecPropertiesARM(subject VirtualMachines_Spec_PropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachines_Spec_PropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachines_Spec_PropertiesARM instances for property testing - lazily instantiated by
// VirtualMachinesSpecPropertiesARMGenerator()
var virtualMachinesSpecPropertiesARMGenerator gopter.Gen

// VirtualMachinesSpecPropertiesARMGenerator returns a generator of VirtualMachines_Spec_PropertiesARM instances for property testing.
// We first initialize virtualMachinesSpecPropertiesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachinesSpecPropertiesARMGenerator() gopter.Gen {
	if virtualMachinesSpecPropertiesARMGenerator != nil {
		return virtualMachinesSpecPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesARM(generators)
	virtualMachinesSpecPropertiesARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_Spec_PropertiesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesARM(generators)
	virtualMachinesSpecPropertiesARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_Spec_PropertiesARM{}), generators)

	return virtualMachinesSpecPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesARM(gens map[string]gopter.Gen) {
	gens["EvictionPolicy"] = gen.PtrOf(gen.OneConstOf(VirtualMachinesSpecPropertiesEvictionPolicyDeallocate, VirtualMachinesSpecPropertiesEvictionPolicyDelete))
	gens["ExtensionsTimeBudget"] = gen.PtrOf(gen.AlphaString())
	gens["LicenseType"] = gen.PtrOf(gen.AlphaString())
	gens["PlatformFaultDomain"] = gen.PtrOf(gen.Int())
	gens["Priority"] = gen.PtrOf(gen.OneConstOf(VirtualMachinesSpecPropertiesPriorityLow, VirtualMachinesSpecPropertiesPriorityRegular, VirtualMachinesSpecPropertiesPrioritySpot))
	gens["UserData"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesARM(gens map[string]gopter.Gen) {
	gens["AdditionalCapabilities"] = gen.PtrOf(AdditionalCapabilitiesARMGenerator())
	gens["ApplicationProfile"] = gen.PtrOf(ApplicationProfileARMGenerator())
	gens["AvailabilitySet"] = gen.PtrOf(SubResourceARMGenerator())
	gens["BillingProfile"] = gen.PtrOf(BillingProfileARMGenerator())
	gens["CapacityReservation"] = gen.PtrOf(CapacityReservationProfileARMGenerator())
	gens["DiagnosticsProfile"] = gen.PtrOf(DiagnosticsProfileARMGenerator())
	gens["HardwareProfile"] = gen.PtrOf(HardwareProfileARMGenerator())
	gens["Host"] = gen.PtrOf(SubResourceARMGenerator())
	gens["HostGroup"] = gen.PtrOf(SubResourceARMGenerator())
	gens["NetworkProfile"] = gen.PtrOf(VirtualMachinesSpecPropertiesNetworkProfileARMGenerator())
	gens["OsProfile"] = gen.PtrOf(VirtualMachinesSpecPropertiesOsProfileARMGenerator())
	gens["ProximityPlacementGroup"] = gen.PtrOf(SubResourceARMGenerator())
	gens["ScheduledEventsProfile"] = gen.PtrOf(ScheduledEventsProfileARMGenerator())
	gens["SecurityProfile"] = gen.PtrOf(SecurityProfileARMGenerator())
	gens["StorageProfile"] = gen.PtrOf(StorageProfileARMGenerator())
	gens["VirtualMachineScaleSet"] = gen.PtrOf(SubResourceARMGenerator())
}

func Test_ApplicationProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApplicationProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApplicationProfileARM, ApplicationProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApplicationProfileARM runs a test to see if a specific instance of ApplicationProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForApplicationProfileARM(subject ApplicationProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApplicationProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApplicationProfileARM instances for property testing - lazily instantiated by
// ApplicationProfileARMGenerator()
var applicationProfileARMGenerator gopter.Gen

// ApplicationProfileARMGenerator returns a generator of ApplicationProfileARM instances for property testing.
func ApplicationProfileARMGenerator() gopter.Gen {
	if applicationProfileARMGenerator != nil {
		return applicationProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForApplicationProfileARM(generators)
	applicationProfileARMGenerator = gen.Struct(reflect.TypeOf(ApplicationProfileARM{}), generators)

	return applicationProfileARMGenerator
}

// AddRelatedPropertyGeneratorsForApplicationProfileARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForApplicationProfileARM(gens map[string]gopter.Gen) {
	gens["GalleryApplications"] = gen.SliceOf(VMGalleryApplicationARMGenerator())
}

func Test_BillingProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BillingProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBillingProfileARM, BillingProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBillingProfileARM runs a test to see if a specific instance of BillingProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBillingProfileARM(subject BillingProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BillingProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BillingProfileARM instances for property testing - lazily instantiated by BillingProfileARMGenerator()
var billingProfileARMGenerator gopter.Gen

// BillingProfileARMGenerator returns a generator of BillingProfileARM instances for property testing.
func BillingProfileARMGenerator() gopter.Gen {
	if billingProfileARMGenerator != nil {
		return billingProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBillingProfileARM(generators)
	billingProfileARMGenerator = gen.Struct(reflect.TypeOf(BillingProfileARM{}), generators)

	return billingProfileARMGenerator
}

// AddIndependentPropertyGeneratorsForBillingProfileARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBillingProfileARM(gens map[string]gopter.Gen) {
	gens["MaxPrice"] = gen.PtrOf(gen.Float64())
}

func Test_CapacityReservationProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CapacityReservationProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCapacityReservationProfileARM, CapacityReservationProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCapacityReservationProfileARM runs a test to see if a specific instance of CapacityReservationProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCapacityReservationProfileARM(subject CapacityReservationProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CapacityReservationProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CapacityReservationProfileARM instances for property testing - lazily instantiated by
// CapacityReservationProfileARMGenerator()
var capacityReservationProfileARMGenerator gopter.Gen

// CapacityReservationProfileARMGenerator returns a generator of CapacityReservationProfileARM instances for property testing.
func CapacityReservationProfileARMGenerator() gopter.Gen {
	if capacityReservationProfileARMGenerator != nil {
		return capacityReservationProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForCapacityReservationProfileARM(generators)
	capacityReservationProfileARMGenerator = gen.Struct(reflect.TypeOf(CapacityReservationProfileARM{}), generators)

	return capacityReservationProfileARMGenerator
}

// AddRelatedPropertyGeneratorsForCapacityReservationProfileARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCapacityReservationProfileARM(gens map[string]gopter.Gen) {
	gens["CapacityReservationGroup"] = gen.PtrOf(SubResourceARMGenerator())
}

func Test_DiagnosticsProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiagnosticsProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiagnosticsProfileARM, DiagnosticsProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiagnosticsProfileARM runs a test to see if a specific instance of DiagnosticsProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiagnosticsProfileARM(subject DiagnosticsProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiagnosticsProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiagnosticsProfileARM instances for property testing - lazily instantiated by
// DiagnosticsProfileARMGenerator()
var diagnosticsProfileARMGenerator gopter.Gen

// DiagnosticsProfileARMGenerator returns a generator of DiagnosticsProfileARM instances for property testing.
func DiagnosticsProfileARMGenerator() gopter.Gen {
	if diagnosticsProfileARMGenerator != nil {
		return diagnosticsProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDiagnosticsProfileARM(generators)
	diagnosticsProfileARMGenerator = gen.Struct(reflect.TypeOf(DiagnosticsProfileARM{}), generators)

	return diagnosticsProfileARMGenerator
}

// AddRelatedPropertyGeneratorsForDiagnosticsProfileARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiagnosticsProfileARM(gens map[string]gopter.Gen) {
	gens["BootDiagnostics"] = gen.PtrOf(BootDiagnosticsARMGenerator())
}

func Test_HardwareProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HardwareProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHardwareProfileARM, HardwareProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHardwareProfileARM runs a test to see if a specific instance of HardwareProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHardwareProfileARM(subject HardwareProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HardwareProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HardwareProfileARM instances for property testing - lazily instantiated by HardwareProfileARMGenerator()
var hardwareProfileARMGenerator gopter.Gen

// HardwareProfileARMGenerator returns a generator of HardwareProfileARM instances for property testing.
// We first initialize hardwareProfileARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func HardwareProfileARMGenerator() gopter.Gen {
	if hardwareProfileARMGenerator != nil {
		return hardwareProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHardwareProfileARM(generators)
	hardwareProfileARMGenerator = gen.Struct(reflect.TypeOf(HardwareProfileARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHardwareProfileARM(generators)
	AddRelatedPropertyGeneratorsForHardwareProfileARM(generators)
	hardwareProfileARMGenerator = gen.Struct(reflect.TypeOf(HardwareProfileARM{}), generators)

	return hardwareProfileARMGenerator
}

// AddIndependentPropertyGeneratorsForHardwareProfileARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHardwareProfileARM(gens map[string]gopter.Gen) {
	gens["VmSize"] = gen.PtrOf(gen.OneConstOf(
		HardwareProfileVmSizeBasicA0,
		HardwareProfileVmSizeBasicA1,
		HardwareProfileVmSizeBasicA2,
		HardwareProfileVmSizeBasicA3,
		HardwareProfileVmSizeBasicA4,
		HardwareProfileVmSizeStandardA0,
		HardwareProfileVmSizeStandardA1,
		HardwareProfileVmSizeStandardA10,
		HardwareProfileVmSizeStandardA11,
		HardwareProfileVmSizeStandardA1V2,
		HardwareProfileVmSizeStandardA2,
		HardwareProfileVmSizeStandardA2MV2,
		HardwareProfileVmSizeStandardA2V2,
		HardwareProfileVmSizeStandardA3,
		HardwareProfileVmSizeStandardA4,
		HardwareProfileVmSizeStandardA4MV2,
		HardwareProfileVmSizeStandardA4V2,
		HardwareProfileVmSizeStandardA5,
		HardwareProfileVmSizeStandardA6,
		HardwareProfileVmSizeStandardA7,
		HardwareProfileVmSizeStandardA8,
		HardwareProfileVmSizeStandardA8MV2,
		HardwareProfileVmSizeStandardA8V2,
		HardwareProfileVmSizeStandardA9,
		HardwareProfileVmSizeStandardB1Ms,
		HardwareProfileVmSizeStandardB1S,
		HardwareProfileVmSizeStandardB2Ms,
		HardwareProfileVmSizeStandardB2S,
		HardwareProfileVmSizeStandardB4Ms,
		HardwareProfileVmSizeStandardB8Ms,
		HardwareProfileVmSizeStandardD1,
		HardwareProfileVmSizeStandardD11,
		HardwareProfileVmSizeStandardD11V2,
		HardwareProfileVmSizeStandardD12,
		HardwareProfileVmSizeStandardD12V2,
		HardwareProfileVmSizeStandardD13,
		HardwareProfileVmSizeStandardD13V2,
		HardwareProfileVmSizeStandardD14,
		HardwareProfileVmSizeStandardD14V2,
		HardwareProfileVmSizeStandardD15V2,
		HardwareProfileVmSizeStandardD16SV3,
		HardwareProfileVmSizeStandardD16V3,
		HardwareProfileVmSizeStandardD1V2,
		HardwareProfileVmSizeStandardD2,
		HardwareProfileVmSizeStandardD2SV3,
		HardwareProfileVmSizeStandardD2V2,
		HardwareProfileVmSizeStandardD2V3,
		HardwareProfileVmSizeStandardD3,
		HardwareProfileVmSizeStandardD32SV3,
		HardwareProfileVmSizeStandardD32V3,
		HardwareProfileVmSizeStandardD3V2,
		HardwareProfileVmSizeStandardD4,
		HardwareProfileVmSizeStandardD4SV3,
		HardwareProfileVmSizeStandardD4V2,
		HardwareProfileVmSizeStandardD4V3,
		HardwareProfileVmSizeStandardD5V2,
		HardwareProfileVmSizeStandardD64SV3,
		HardwareProfileVmSizeStandardD64V3,
		HardwareProfileVmSizeStandardD8SV3,
		HardwareProfileVmSizeStandardD8V3,
		HardwareProfileVmSizeStandardDS1,
		HardwareProfileVmSizeStandardDS11,
		HardwareProfileVmSizeStandardDS11V2,
		HardwareProfileVmSizeStandardDS12,
		HardwareProfileVmSizeStandardDS12V2,
		HardwareProfileVmSizeStandardDS13,
		HardwareProfileVmSizeStandardDS132V2,
		HardwareProfileVmSizeStandardDS134V2,
		HardwareProfileVmSizeStandardDS13V2,
		HardwareProfileVmSizeStandardDS14,
		HardwareProfileVmSizeStandardDS144V2,
		HardwareProfileVmSizeStandardDS148V2,
		HardwareProfileVmSizeStandardDS14V2,
		HardwareProfileVmSizeStandardDS15V2,
		HardwareProfileVmSizeStandardDS1V2,
		HardwareProfileVmSizeStandardDS2,
		HardwareProfileVmSizeStandardDS2V2,
		HardwareProfileVmSizeStandardDS3,
		HardwareProfileVmSizeStandardDS3V2,
		HardwareProfileVmSizeStandardDS4,
		HardwareProfileVmSizeStandardDS4V2,
		HardwareProfileVmSizeStandardDS5V2,
		HardwareProfileVmSizeStandardE16SV3,
		HardwareProfileVmSizeStandardE16V3,
		HardwareProfileVmSizeStandardE2SV3,
		HardwareProfileVmSizeStandardE2V3,
		HardwareProfileVmSizeStandardE3216V3,
		HardwareProfileVmSizeStandardE328SV3,
		HardwareProfileVmSizeStandardE32SV3,
		HardwareProfileVmSizeStandardE32V3,
		HardwareProfileVmSizeStandardE4SV3,
		HardwareProfileVmSizeStandardE4V3,
		HardwareProfileVmSizeStandardE6416SV3,
		HardwareProfileVmSizeStandardE6432SV3,
		HardwareProfileVmSizeStandardE64SV3,
		HardwareProfileVmSizeStandardE64V3,
		HardwareProfileVmSizeStandardE8SV3,
		HardwareProfileVmSizeStandardE8V3,
		HardwareProfileVmSizeStandardF1,
		HardwareProfileVmSizeStandardF16,
		HardwareProfileVmSizeStandardF16S,
		HardwareProfileVmSizeStandardF16SV2,
		HardwareProfileVmSizeStandardF1S,
		HardwareProfileVmSizeStandardF2,
		HardwareProfileVmSizeStandardF2S,
		HardwareProfileVmSizeStandardF2SV2,
		HardwareProfileVmSizeStandardF32SV2,
		HardwareProfileVmSizeStandardF4,
		HardwareProfileVmSizeStandardF4S,
		HardwareProfileVmSizeStandardF4SV2,
		HardwareProfileVmSizeStandardF64SV2,
		HardwareProfileVmSizeStandardF72SV2,
		HardwareProfileVmSizeStandardF8,
		HardwareProfileVmSizeStandardF8S,
		HardwareProfileVmSizeStandardF8SV2,
		HardwareProfileVmSizeStandardG1,
		HardwareProfileVmSizeStandardG2,
		HardwareProfileVmSizeStandardG3,
		HardwareProfileVmSizeStandardG4,
		HardwareProfileVmSizeStandardG5,
		HardwareProfileVmSizeStandardGS1,
		HardwareProfileVmSizeStandardGS2,
		HardwareProfileVmSizeStandardGS3,
		HardwareProfileVmSizeStandardGS4,
		HardwareProfileVmSizeStandardGS44,
		HardwareProfileVmSizeStandardGS48,
		HardwareProfileVmSizeStandardGS5,
		HardwareProfileVmSizeStandardGS516,
		HardwareProfileVmSizeStandardGS58,
		HardwareProfileVmSizeStandardH16,
		HardwareProfileVmSizeStandardH16M,
		HardwareProfileVmSizeStandardH16Mr,
		HardwareProfileVmSizeStandardH16R,
		HardwareProfileVmSizeStandardH8,
		HardwareProfileVmSizeStandardH8M,
		HardwareProfileVmSizeStandardL16S,
		HardwareProfileVmSizeStandardL32S,
		HardwareProfileVmSizeStandardL4S,
		HardwareProfileVmSizeStandardL8S,
		HardwareProfileVmSizeStandardM12832Ms,
		HardwareProfileVmSizeStandardM12864Ms,
		HardwareProfileVmSizeStandardM128Ms,
		HardwareProfileVmSizeStandardM128S,
		HardwareProfileVmSizeStandardM6416Ms,
		HardwareProfileVmSizeStandardM6432Ms,
		HardwareProfileVmSizeStandardM64Ms,
		HardwareProfileVmSizeStandardM64S,
		HardwareProfileVmSizeStandardNC12,
		HardwareProfileVmSizeStandardNC12SV2,
		HardwareProfileVmSizeStandardNC12SV3,
		HardwareProfileVmSizeStandardNC24,
		HardwareProfileVmSizeStandardNC24R,
		HardwareProfileVmSizeStandardNC24RsV2,
		HardwareProfileVmSizeStandardNC24RsV3,
		HardwareProfileVmSizeStandardNC24SV2,
		HardwareProfileVmSizeStandardNC24SV3,
		HardwareProfileVmSizeStandardNC6,
		HardwareProfileVmSizeStandardNC6SV2,
		HardwareProfileVmSizeStandardNC6SV3,
		HardwareProfileVmSizeStandardND12S,
		HardwareProfileVmSizeStandardND24Rs,
		HardwareProfileVmSizeStandardND24S,
		HardwareProfileVmSizeStandardND6S,
		HardwareProfileVmSizeStandardNV12,
		HardwareProfileVmSizeStandardNV24,
		HardwareProfileVmSizeStandardNV6))
}

// AddRelatedPropertyGeneratorsForHardwareProfileARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForHardwareProfileARM(gens map[string]gopter.Gen) {
	gens["VmSizeProperties"] = gen.PtrOf(VMSizePropertiesARMGenerator())
}

func Test_ScheduledEventsProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScheduledEventsProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScheduledEventsProfileARM, ScheduledEventsProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScheduledEventsProfileARM runs a test to see if a specific instance of ScheduledEventsProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForScheduledEventsProfileARM(subject ScheduledEventsProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScheduledEventsProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScheduledEventsProfileARM instances for property testing - lazily instantiated by
// ScheduledEventsProfileARMGenerator()
var scheduledEventsProfileARMGenerator gopter.Gen

// ScheduledEventsProfileARMGenerator returns a generator of ScheduledEventsProfileARM instances for property testing.
func ScheduledEventsProfileARMGenerator() gopter.Gen {
	if scheduledEventsProfileARMGenerator != nil {
		return scheduledEventsProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForScheduledEventsProfileARM(generators)
	scheduledEventsProfileARMGenerator = gen.Struct(reflect.TypeOf(ScheduledEventsProfileARM{}), generators)

	return scheduledEventsProfileARMGenerator
}

// AddRelatedPropertyGeneratorsForScheduledEventsProfileARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForScheduledEventsProfileARM(gens map[string]gopter.Gen) {
	gens["TerminateNotificationProfile"] = gen.PtrOf(TerminateNotificationProfileARMGenerator())
}

func Test_SecurityProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SecurityProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSecurityProfileARM, SecurityProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSecurityProfileARM runs a test to see if a specific instance of SecurityProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSecurityProfileARM(subject SecurityProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SecurityProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SecurityProfileARM instances for property testing - lazily instantiated by SecurityProfileARMGenerator()
var securityProfileARMGenerator gopter.Gen

// SecurityProfileARMGenerator returns a generator of SecurityProfileARM instances for property testing.
// We first initialize securityProfileARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SecurityProfileARMGenerator() gopter.Gen {
	if securityProfileARMGenerator != nil {
		return securityProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecurityProfileARM(generators)
	securityProfileARMGenerator = gen.Struct(reflect.TypeOf(SecurityProfileARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecurityProfileARM(generators)
	AddRelatedPropertyGeneratorsForSecurityProfileARM(generators)
	securityProfileARMGenerator = gen.Struct(reflect.TypeOf(SecurityProfileARM{}), generators)

	return securityProfileARMGenerator
}

// AddIndependentPropertyGeneratorsForSecurityProfileARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSecurityProfileARM(gens map[string]gopter.Gen) {
	gens["EncryptionAtHost"] = gen.PtrOf(gen.Bool())
	gens["SecurityType"] = gen.PtrOf(gen.OneConstOf(SecurityProfileSecurityTypeConfidentialVM, SecurityProfileSecurityTypeTrustedLaunch))
}

// AddRelatedPropertyGeneratorsForSecurityProfileARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSecurityProfileARM(gens map[string]gopter.Gen) {
	gens["UefiSettings"] = gen.PtrOf(UefiSettingsARMGenerator())
}

func Test_StorageProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageProfileARM, StorageProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageProfileARM runs a test to see if a specific instance of StorageProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageProfileARM(subject StorageProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageProfileARM instances for property testing - lazily instantiated by StorageProfileARMGenerator()
var storageProfileARMGenerator gopter.Gen

// StorageProfileARMGenerator returns a generator of StorageProfileARM instances for property testing.
func StorageProfileARMGenerator() gopter.Gen {
	if storageProfileARMGenerator != nil {
		return storageProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForStorageProfileARM(generators)
	storageProfileARMGenerator = gen.Struct(reflect.TypeOf(StorageProfileARM{}), generators)

	return storageProfileARMGenerator
}

// AddRelatedPropertyGeneratorsForStorageProfileARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageProfileARM(gens map[string]gopter.Gen) {
	gens["DataDisks"] = gen.SliceOf(DataDiskARMGenerator())
	gens["ImageReference"] = gen.PtrOf(ImageReferenceARMGenerator())
	gens["OsDisk"] = gen.PtrOf(OSDiskARMGenerator())
}

func Test_VirtualMachines_Spec_Properties_NetworkProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachines_Spec_Properties_NetworkProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachinesSpecPropertiesNetworkProfileARM, VirtualMachinesSpecPropertiesNetworkProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachinesSpecPropertiesNetworkProfileARM runs a test to see if a specific instance of VirtualMachines_Spec_Properties_NetworkProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachinesSpecPropertiesNetworkProfileARM(subject VirtualMachines_Spec_Properties_NetworkProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachines_Spec_Properties_NetworkProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachines_Spec_Properties_NetworkProfileARM instances for property testing - lazily instantiated
// by VirtualMachinesSpecPropertiesNetworkProfileARMGenerator()
var virtualMachinesSpecPropertiesNetworkProfileARMGenerator gopter.Gen

// VirtualMachinesSpecPropertiesNetworkProfileARMGenerator returns a generator of VirtualMachines_Spec_Properties_NetworkProfileARM instances for property testing.
// We first initialize virtualMachinesSpecPropertiesNetworkProfileARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachinesSpecPropertiesNetworkProfileARMGenerator() gopter.Gen {
	if virtualMachinesSpecPropertiesNetworkProfileARMGenerator != nil {
		return virtualMachinesSpecPropertiesNetworkProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileARM(generators)
	virtualMachinesSpecPropertiesNetworkProfileARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_Spec_Properties_NetworkProfileARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileARM(generators)
	virtualMachinesSpecPropertiesNetworkProfileARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_Spec_Properties_NetworkProfileARM{}), generators)

	return virtualMachinesSpecPropertiesNetworkProfileARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileARM(gens map[string]gopter.Gen) {
	gens["NetworkApiVersion"] = gen.PtrOf(gen.OneConstOf(VirtualMachinesSpecPropertiesNetworkProfileNetworkApiVersion20201101))
}

// AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileARM(gens map[string]gopter.Gen) {
	gens["NetworkInterfaceConfigurations"] = gen.SliceOf(VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsARMGenerator())
	gens["NetworkInterfaces"] = gen.SliceOf(VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesARMGenerator())
}

func Test_VirtualMachines_Spec_Properties_OsProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachines_Spec_Properties_OsProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachinesSpecPropertiesOsProfileARM, VirtualMachinesSpecPropertiesOsProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachinesSpecPropertiesOsProfileARM runs a test to see if a specific instance of VirtualMachines_Spec_Properties_OsProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachinesSpecPropertiesOsProfileARM(subject VirtualMachines_Spec_Properties_OsProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachines_Spec_Properties_OsProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachines_Spec_Properties_OsProfileARM instances for property testing - lazily instantiated by
// VirtualMachinesSpecPropertiesOsProfileARMGenerator()
var virtualMachinesSpecPropertiesOsProfileARMGenerator gopter.Gen

// VirtualMachinesSpecPropertiesOsProfileARMGenerator returns a generator of VirtualMachines_Spec_Properties_OsProfileARM instances for property testing.
// We first initialize virtualMachinesSpecPropertiesOsProfileARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachinesSpecPropertiesOsProfileARMGenerator() gopter.Gen {
	if virtualMachinesSpecPropertiesOsProfileARMGenerator != nil {
		return virtualMachinesSpecPropertiesOsProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesOsProfileARM(generators)
	virtualMachinesSpecPropertiesOsProfileARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_Spec_Properties_OsProfileARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesOsProfileARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesOsProfileARM(generators)
	virtualMachinesSpecPropertiesOsProfileARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_Spec_Properties_OsProfileARM{}), generators)

	return virtualMachinesSpecPropertiesOsProfileARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesOsProfileARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesOsProfileARM(gens map[string]gopter.Gen) {
	gens["AdminPassword"] = gen.PtrOf(gen.AlphaString())
	gens["AdminUsername"] = gen.PtrOf(gen.AlphaString())
	gens["AllowExtensionOperations"] = gen.PtrOf(gen.Bool())
	gens["ComputerName"] = gen.PtrOf(gen.AlphaString())
	gens["CustomData"] = gen.PtrOf(gen.AlphaString())
	gens["RequireGuestProvisionSignal"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesOsProfileARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesOsProfileARM(gens map[string]gopter.Gen) {
	gens["LinuxConfiguration"] = gen.PtrOf(LinuxConfigurationARMGenerator())
	gens["Secrets"] = gen.SliceOf(VaultSecretGroupARMGenerator())
	gens["WindowsConfiguration"] = gen.PtrOf(WindowsConfigurationARMGenerator())
}

func Test_BootDiagnosticsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BootDiagnosticsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBootDiagnosticsARM, BootDiagnosticsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBootDiagnosticsARM runs a test to see if a specific instance of BootDiagnosticsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBootDiagnosticsARM(subject BootDiagnosticsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BootDiagnosticsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BootDiagnosticsARM instances for property testing - lazily instantiated by BootDiagnosticsARMGenerator()
var bootDiagnosticsARMGenerator gopter.Gen

// BootDiagnosticsARMGenerator returns a generator of BootDiagnosticsARM instances for property testing.
func BootDiagnosticsARMGenerator() gopter.Gen {
	if bootDiagnosticsARMGenerator != nil {
		return bootDiagnosticsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBootDiagnosticsARM(generators)
	bootDiagnosticsARMGenerator = gen.Struct(reflect.TypeOf(BootDiagnosticsARM{}), generators)

	return bootDiagnosticsARMGenerator
}

// AddIndependentPropertyGeneratorsForBootDiagnosticsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBootDiagnosticsARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["StorageUri"] = gen.PtrOf(gen.AlphaString())
}

func Test_DataDiskARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataDiskARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataDiskARM, DataDiskARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataDiskARM runs a test to see if a specific instance of DataDiskARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDataDiskARM(subject DataDiskARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataDiskARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataDiskARM instances for property testing - lazily instantiated by DataDiskARMGenerator()
var dataDiskARMGenerator gopter.Gen

// DataDiskARMGenerator returns a generator of DataDiskARM instances for property testing.
// We first initialize dataDiskARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DataDiskARMGenerator() gopter.Gen {
	if dataDiskARMGenerator != nil {
		return dataDiskARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataDiskARM(generators)
	dataDiskARMGenerator = gen.Struct(reflect.TypeOf(DataDiskARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataDiskARM(generators)
	AddRelatedPropertyGeneratorsForDataDiskARM(generators)
	dataDiskARMGenerator = gen.Struct(reflect.TypeOf(DataDiskARM{}), generators)

	return dataDiskARMGenerator
}

// AddIndependentPropertyGeneratorsForDataDiskARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDataDiskARM(gens map[string]gopter.Gen) {
	gens["Caching"] = gen.PtrOf(gen.OneConstOf(DataDiskCachingNone, DataDiskCachingReadOnly, DataDiskCachingReadWrite))
	gens["CreateOption"] = gen.PtrOf(gen.OneConstOf(DataDiskCreateOptionAttach, DataDiskCreateOptionEmpty, DataDiskCreateOptionFromImage))
	gens["DeleteOption"] = gen.PtrOf(gen.OneConstOf(DataDiskDeleteOptionDelete, DataDiskDeleteOptionDetach))
	gens["DetachOption"] = gen.PtrOf(gen.OneConstOf(DataDiskDetachOptionForceDetach))
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["Lun"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ToBeDetached"] = gen.PtrOf(gen.Bool())
	gens["WriteAcceleratorEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForDataDiskARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataDiskARM(gens map[string]gopter.Gen) {
	gens["Image"] = gen.PtrOf(VirtualHardDiskARMGenerator())
	gens["ManagedDisk"] = gen.PtrOf(ManagedDiskParametersARMGenerator())
	gens["Vhd"] = gen.PtrOf(VirtualHardDiskARMGenerator())
}

func Test_ImageReferenceARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ImageReferenceARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForImageReferenceARM, ImageReferenceARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForImageReferenceARM runs a test to see if a specific instance of ImageReferenceARM round trips to JSON and back losslessly
func RunJSONSerializationTestForImageReferenceARM(subject ImageReferenceARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ImageReferenceARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ImageReferenceARM instances for property testing - lazily instantiated by ImageReferenceARMGenerator()
var imageReferenceARMGenerator gopter.Gen

// ImageReferenceARMGenerator returns a generator of ImageReferenceARM instances for property testing.
func ImageReferenceARMGenerator() gopter.Gen {
	if imageReferenceARMGenerator != nil {
		return imageReferenceARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForImageReferenceARM(generators)
	imageReferenceARMGenerator = gen.Struct(reflect.TypeOf(ImageReferenceARM{}), generators)

	return imageReferenceARMGenerator
}

// AddIndependentPropertyGeneratorsForImageReferenceARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForImageReferenceARM(gens map[string]gopter.Gen) {
	gens["CommunityGalleryImageId"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Offer"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
	gens["SharedGalleryImageId"] = gen.PtrOf(gen.AlphaString())
	gens["Sku"] = gen.PtrOf(gen.AlphaString())
	gens["Version"] = gen.PtrOf(gen.AlphaString())
}

func Test_LinuxConfigurationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxConfigurationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxConfigurationARM, LinuxConfigurationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxConfigurationARM runs a test to see if a specific instance of LinuxConfigurationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxConfigurationARM(subject LinuxConfigurationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxConfigurationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxConfigurationARM instances for property testing - lazily instantiated by
// LinuxConfigurationARMGenerator()
var linuxConfigurationARMGenerator gopter.Gen

// LinuxConfigurationARMGenerator returns a generator of LinuxConfigurationARM instances for property testing.
// We first initialize linuxConfigurationARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LinuxConfigurationARMGenerator() gopter.Gen {
	if linuxConfigurationARMGenerator != nil {
		return linuxConfigurationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxConfigurationARM(generators)
	linuxConfigurationARMGenerator = gen.Struct(reflect.TypeOf(LinuxConfigurationARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxConfigurationARM(generators)
	AddRelatedPropertyGeneratorsForLinuxConfigurationARM(generators)
	linuxConfigurationARMGenerator = gen.Struct(reflect.TypeOf(LinuxConfigurationARM{}), generators)

	return linuxConfigurationARMGenerator
}

// AddIndependentPropertyGeneratorsForLinuxConfigurationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxConfigurationARM(gens map[string]gopter.Gen) {
	gens["DisablePasswordAuthentication"] = gen.PtrOf(gen.Bool())
	gens["ProvisionVMAgent"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForLinuxConfigurationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLinuxConfigurationARM(gens map[string]gopter.Gen) {
	gens["PatchSettings"] = gen.PtrOf(LinuxPatchSettingsARMGenerator())
	gens["Ssh"] = gen.PtrOf(SshConfigurationARMGenerator())
}

func Test_OSDiskARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OSDiskARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOSDiskARM, OSDiskARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOSDiskARM runs a test to see if a specific instance of OSDiskARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOSDiskARM(subject OSDiskARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OSDiskARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OSDiskARM instances for property testing - lazily instantiated by OSDiskARMGenerator()
var osDiskARMGenerator gopter.Gen

// OSDiskARMGenerator returns a generator of OSDiskARM instances for property testing.
// We first initialize osDiskARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OSDiskARMGenerator() gopter.Gen {
	if osDiskARMGenerator != nil {
		return osDiskARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSDiskARM(generators)
	osDiskARMGenerator = gen.Struct(reflect.TypeOf(OSDiskARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSDiskARM(generators)
	AddRelatedPropertyGeneratorsForOSDiskARM(generators)
	osDiskARMGenerator = gen.Struct(reflect.TypeOf(OSDiskARM{}), generators)

	return osDiskARMGenerator
}

// AddIndependentPropertyGeneratorsForOSDiskARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOSDiskARM(gens map[string]gopter.Gen) {
	gens["Caching"] = gen.PtrOf(gen.OneConstOf(OSDiskCachingNone, OSDiskCachingReadOnly, OSDiskCachingReadWrite))
	gens["CreateOption"] = gen.PtrOf(gen.OneConstOf(OSDiskCreateOptionAttach, OSDiskCreateOptionEmpty, OSDiskCreateOptionFromImage))
	gens["DeleteOption"] = gen.PtrOf(gen.OneConstOf(OSDiskDeleteOptionDelete, OSDiskDeleteOptionDetach))
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["OsType"] = gen.PtrOf(gen.OneConstOf(OSDiskOsTypeLinux, OSDiskOsTypeWindows))
	gens["WriteAcceleratorEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForOSDiskARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOSDiskARM(gens map[string]gopter.Gen) {
	gens["DiffDiskSettings"] = gen.PtrOf(DiffDiskSettingsARMGenerator())
	gens["EncryptionSettings"] = gen.PtrOf(DiskEncryptionSettingsARMGenerator())
	gens["Image"] = gen.PtrOf(VirtualHardDiskARMGenerator())
	gens["ManagedDisk"] = gen.PtrOf(ManagedDiskParametersARMGenerator())
	gens["Vhd"] = gen.PtrOf(VirtualHardDiskARMGenerator())
}

func Test_TerminateNotificationProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TerminateNotificationProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTerminateNotificationProfileARM, TerminateNotificationProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTerminateNotificationProfileARM runs a test to see if a specific instance of TerminateNotificationProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForTerminateNotificationProfileARM(subject TerminateNotificationProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TerminateNotificationProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TerminateNotificationProfileARM instances for property testing - lazily instantiated by
// TerminateNotificationProfileARMGenerator()
var terminateNotificationProfileARMGenerator gopter.Gen

// TerminateNotificationProfileARMGenerator returns a generator of TerminateNotificationProfileARM instances for property testing.
func TerminateNotificationProfileARMGenerator() gopter.Gen {
	if terminateNotificationProfileARMGenerator != nil {
		return terminateNotificationProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTerminateNotificationProfileARM(generators)
	terminateNotificationProfileARMGenerator = gen.Struct(reflect.TypeOf(TerminateNotificationProfileARM{}), generators)

	return terminateNotificationProfileARMGenerator
}

// AddIndependentPropertyGeneratorsForTerminateNotificationProfileARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTerminateNotificationProfileARM(gens map[string]gopter.Gen) {
	gens["Enable"] = gen.PtrOf(gen.Bool())
	gens["NotBeforeTimeout"] = gen.PtrOf(gen.AlphaString())
}

func Test_UefiSettingsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UefiSettingsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUefiSettingsARM, UefiSettingsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUefiSettingsARM runs a test to see if a specific instance of UefiSettingsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUefiSettingsARM(subject UefiSettingsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UefiSettingsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UefiSettingsARM instances for property testing - lazily instantiated by UefiSettingsARMGenerator()
var uefiSettingsARMGenerator gopter.Gen

// UefiSettingsARMGenerator returns a generator of UefiSettingsARM instances for property testing.
func UefiSettingsARMGenerator() gopter.Gen {
	if uefiSettingsARMGenerator != nil {
		return uefiSettingsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUefiSettingsARM(generators)
	uefiSettingsARMGenerator = gen.Struct(reflect.TypeOf(UefiSettingsARM{}), generators)

	return uefiSettingsARMGenerator
}

// AddIndependentPropertyGeneratorsForUefiSettingsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUefiSettingsARM(gens map[string]gopter.Gen) {
	gens["SecureBootEnabled"] = gen.PtrOf(gen.Bool())
	gens["VTpmEnabled"] = gen.PtrOf(gen.Bool())
}

func Test_VMGalleryApplicationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VMGalleryApplicationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVMGalleryApplicationARM, VMGalleryApplicationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVMGalleryApplicationARM runs a test to see if a specific instance of VMGalleryApplicationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVMGalleryApplicationARM(subject VMGalleryApplicationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VMGalleryApplicationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VMGalleryApplicationARM instances for property testing - lazily instantiated by
// VMGalleryApplicationARMGenerator()
var vmGalleryApplicationARMGenerator gopter.Gen

// VMGalleryApplicationARMGenerator returns a generator of VMGalleryApplicationARM instances for property testing.
func VMGalleryApplicationARMGenerator() gopter.Gen {
	if vmGalleryApplicationARMGenerator != nil {
		return vmGalleryApplicationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVMGalleryApplicationARM(generators)
	vmGalleryApplicationARMGenerator = gen.Struct(reflect.TypeOf(VMGalleryApplicationARM{}), generators)

	return vmGalleryApplicationARMGenerator
}

// AddIndependentPropertyGeneratorsForVMGalleryApplicationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVMGalleryApplicationARM(gens map[string]gopter.Gen) {
	gens["ConfigurationReference"] = gen.PtrOf(gen.AlphaString())
	gens["EnableAutomaticUpgrade"] = gen.PtrOf(gen.Bool())
	gens["Order"] = gen.PtrOf(gen.Int())
	gens["PackageReferenceId"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.PtrOf(gen.AlphaString())
	gens["TreatFailureAsDeploymentFailure"] = gen.PtrOf(gen.Bool())
}

func Test_VMSizePropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VMSizePropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVMSizePropertiesARM, VMSizePropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVMSizePropertiesARM runs a test to see if a specific instance of VMSizePropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVMSizePropertiesARM(subject VMSizePropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VMSizePropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VMSizePropertiesARM instances for property testing - lazily instantiated by
// VMSizePropertiesARMGenerator()
var vmSizePropertiesARMGenerator gopter.Gen

// VMSizePropertiesARMGenerator returns a generator of VMSizePropertiesARM instances for property testing.
func VMSizePropertiesARMGenerator() gopter.Gen {
	if vmSizePropertiesARMGenerator != nil {
		return vmSizePropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVMSizePropertiesARM(generators)
	vmSizePropertiesARMGenerator = gen.Struct(reflect.TypeOf(VMSizePropertiesARM{}), generators)

	return vmSizePropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForVMSizePropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVMSizePropertiesARM(gens map[string]gopter.Gen) {
	gens["VCPUsAvailable"] = gen.PtrOf(gen.Int())
	gens["VCPUsPerCore"] = gen.PtrOf(gen.Int())
}

func Test_VaultSecretGroupARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultSecretGroupARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultSecretGroupARM, VaultSecretGroupARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultSecretGroupARM runs a test to see if a specific instance of VaultSecretGroupARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultSecretGroupARM(subject VaultSecretGroupARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultSecretGroupARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultSecretGroupARM instances for property testing - lazily instantiated by
// VaultSecretGroupARMGenerator()
var vaultSecretGroupARMGenerator gopter.Gen

// VaultSecretGroupARMGenerator returns a generator of VaultSecretGroupARM instances for property testing.
func VaultSecretGroupARMGenerator() gopter.Gen {
	if vaultSecretGroupARMGenerator != nil {
		return vaultSecretGroupARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVaultSecretGroupARM(generators)
	vaultSecretGroupARMGenerator = gen.Struct(reflect.TypeOf(VaultSecretGroupARM{}), generators)

	return vaultSecretGroupARMGenerator
}

// AddRelatedPropertyGeneratorsForVaultSecretGroupARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVaultSecretGroupARM(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SubResourceARMGenerator())
	gens["VaultCertificates"] = gen.SliceOf(VaultCertificateARMGenerator())
}

func Test_VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurationsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurationsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsARM, VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsARM runs a test to see if a specific instance of VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurationsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsARM(subject VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurationsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurationsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurationsARM instances for property
// testing - lazily instantiated by VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsARMGenerator()
var virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsARMGenerator gopter.Gen

// VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsARMGenerator returns a generator of VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurationsARM instances for property testing.
// We first initialize virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsARMGenerator() gopter.Gen {
	if virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsARMGenerator != nil {
		return virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsARM(generators)
	virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurationsARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsARM(generators)
	virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurationsARM{}), generators)

	return virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesARMGenerator())
}

func Test_VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfacesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfacesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesARM, VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesARM runs a test to see if a specific instance of VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfacesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesARM(subject VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfacesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfacesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfacesARM instances for property testing -
// lazily instantiated by VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesARMGenerator()
var virtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesARMGenerator gopter.Gen

// VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesARMGenerator returns a generator of VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfacesARM instances for property testing.
// We first initialize virtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesARMGenerator() gopter.Gen {
	if virtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesARMGenerator != nil {
		return virtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesARM(generators)
	virtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfacesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesARM(generators)
	virtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfacesARM{}), generators)

	return virtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfacesARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(NetworkInterfaceReferencePropertiesARMGenerator())
}

func Test_WindowsConfigurationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WindowsConfigurationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWindowsConfigurationARM, WindowsConfigurationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWindowsConfigurationARM runs a test to see if a specific instance of WindowsConfigurationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWindowsConfigurationARM(subject WindowsConfigurationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WindowsConfigurationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WindowsConfigurationARM instances for property testing - lazily instantiated by
// WindowsConfigurationARMGenerator()
var windowsConfigurationARMGenerator gopter.Gen

// WindowsConfigurationARMGenerator returns a generator of WindowsConfigurationARM instances for property testing.
// We first initialize windowsConfigurationARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WindowsConfigurationARMGenerator() gopter.Gen {
	if windowsConfigurationARMGenerator != nil {
		return windowsConfigurationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsConfigurationARM(generators)
	windowsConfigurationARMGenerator = gen.Struct(reflect.TypeOf(WindowsConfigurationARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsConfigurationARM(generators)
	AddRelatedPropertyGeneratorsForWindowsConfigurationARM(generators)
	windowsConfigurationARMGenerator = gen.Struct(reflect.TypeOf(WindowsConfigurationARM{}), generators)

	return windowsConfigurationARMGenerator
}

// AddIndependentPropertyGeneratorsForWindowsConfigurationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWindowsConfigurationARM(gens map[string]gopter.Gen) {
	gens["EnableAutomaticUpdates"] = gen.PtrOf(gen.Bool())
	gens["ProvisionVMAgent"] = gen.PtrOf(gen.Bool())
	gens["TimeZone"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForWindowsConfigurationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWindowsConfigurationARM(gens map[string]gopter.Gen) {
	gens["AdditionalUnattendContent"] = gen.SliceOf(AdditionalUnattendContentARMGenerator())
	gens["PatchSettings"] = gen.PtrOf(PatchSettingsARMGenerator())
	gens["WinRM"] = gen.PtrOf(WinRMConfigurationARMGenerator())
}

func Test_AdditionalUnattendContentARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdditionalUnattendContentARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdditionalUnattendContentARM, AdditionalUnattendContentARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdditionalUnattendContentARM runs a test to see if a specific instance of AdditionalUnattendContentARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAdditionalUnattendContentARM(subject AdditionalUnattendContentARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdditionalUnattendContentARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdditionalUnattendContentARM instances for property testing - lazily instantiated by
// AdditionalUnattendContentARMGenerator()
var additionalUnattendContentARMGenerator gopter.Gen

// AdditionalUnattendContentARMGenerator returns a generator of AdditionalUnattendContentARM instances for property testing.
func AdditionalUnattendContentARMGenerator() gopter.Gen {
	if additionalUnattendContentARMGenerator != nil {
		return additionalUnattendContentARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdditionalUnattendContentARM(generators)
	additionalUnattendContentARMGenerator = gen.Struct(reflect.TypeOf(AdditionalUnattendContentARM{}), generators)

	return additionalUnattendContentARMGenerator
}

// AddIndependentPropertyGeneratorsForAdditionalUnattendContentARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdditionalUnattendContentARM(gens map[string]gopter.Gen) {
	gens["ComponentName"] = gen.PtrOf(gen.OneConstOf(AdditionalUnattendContentComponentNameMicrosoftWindowsShellSetup))
	gens["Content"] = gen.PtrOf(gen.AlphaString())
	gens["PassName"] = gen.PtrOf(gen.OneConstOf(AdditionalUnattendContentPassNameOobeSystem))
	gens["SettingName"] = gen.PtrOf(gen.OneConstOf(AdditionalUnattendContentSettingNameAutoLogon, AdditionalUnattendContentSettingNameFirstLogonCommands))
}

func Test_DiffDiskSettingsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiffDiskSettingsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiffDiskSettingsARM, DiffDiskSettingsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiffDiskSettingsARM runs a test to see if a specific instance of DiffDiskSettingsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiffDiskSettingsARM(subject DiffDiskSettingsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiffDiskSettingsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiffDiskSettingsARM instances for property testing - lazily instantiated by
// DiffDiskSettingsARMGenerator()
var diffDiskSettingsARMGenerator gopter.Gen

// DiffDiskSettingsARMGenerator returns a generator of DiffDiskSettingsARM instances for property testing.
func DiffDiskSettingsARMGenerator() gopter.Gen {
	if diffDiskSettingsARMGenerator != nil {
		return diffDiskSettingsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiffDiskSettingsARM(generators)
	diffDiskSettingsARMGenerator = gen.Struct(reflect.TypeOf(DiffDiskSettingsARM{}), generators)

	return diffDiskSettingsARMGenerator
}

// AddIndependentPropertyGeneratorsForDiffDiskSettingsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiffDiskSettingsARM(gens map[string]gopter.Gen) {
	gens["Option"] = gen.PtrOf(gen.OneConstOf(DiffDiskSettingsOptionLocal))
	gens["Placement"] = gen.PtrOf(gen.OneConstOf(DiffDiskSettingsPlacementCacheDisk, DiffDiskSettingsPlacementResourceDisk))
}

func Test_DiskEncryptionSettingsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiskEncryptionSettingsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskEncryptionSettingsARM, DiskEncryptionSettingsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskEncryptionSettingsARM runs a test to see if a specific instance of DiskEncryptionSettingsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskEncryptionSettingsARM(subject DiskEncryptionSettingsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiskEncryptionSettingsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiskEncryptionSettingsARM instances for property testing - lazily instantiated by
// DiskEncryptionSettingsARMGenerator()
var diskEncryptionSettingsARMGenerator gopter.Gen

// DiskEncryptionSettingsARMGenerator returns a generator of DiskEncryptionSettingsARM instances for property testing.
// We first initialize diskEncryptionSettingsARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DiskEncryptionSettingsARMGenerator() gopter.Gen {
	if diskEncryptionSettingsARMGenerator != nil {
		return diskEncryptionSettingsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskEncryptionSettingsARM(generators)
	diskEncryptionSettingsARMGenerator = gen.Struct(reflect.TypeOf(DiskEncryptionSettingsARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskEncryptionSettingsARM(generators)
	AddRelatedPropertyGeneratorsForDiskEncryptionSettingsARM(generators)
	diskEncryptionSettingsARMGenerator = gen.Struct(reflect.TypeOf(DiskEncryptionSettingsARM{}), generators)

	return diskEncryptionSettingsARMGenerator
}

// AddIndependentPropertyGeneratorsForDiskEncryptionSettingsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskEncryptionSettingsARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForDiskEncryptionSettingsARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiskEncryptionSettingsARM(gens map[string]gopter.Gen) {
	gens["DiskEncryptionKey"] = gen.PtrOf(KeyVaultSecretReferenceARMGenerator())
	gens["KeyEncryptionKey"] = gen.PtrOf(KeyVaultKeyReferenceARMGenerator())
}

func Test_LinuxPatchSettingsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxPatchSettingsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxPatchSettingsARM, LinuxPatchSettingsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxPatchSettingsARM runs a test to see if a specific instance of LinuxPatchSettingsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxPatchSettingsARM(subject LinuxPatchSettingsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxPatchSettingsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxPatchSettingsARM instances for property testing - lazily instantiated by
// LinuxPatchSettingsARMGenerator()
var linuxPatchSettingsARMGenerator gopter.Gen

// LinuxPatchSettingsARMGenerator returns a generator of LinuxPatchSettingsARM instances for property testing.
// We first initialize linuxPatchSettingsARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LinuxPatchSettingsARMGenerator() gopter.Gen {
	if linuxPatchSettingsARMGenerator != nil {
		return linuxPatchSettingsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxPatchSettingsARM(generators)
	linuxPatchSettingsARMGenerator = gen.Struct(reflect.TypeOf(LinuxPatchSettingsARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxPatchSettingsARM(generators)
	AddRelatedPropertyGeneratorsForLinuxPatchSettingsARM(generators)
	linuxPatchSettingsARMGenerator = gen.Struct(reflect.TypeOf(LinuxPatchSettingsARM{}), generators)

	return linuxPatchSettingsARMGenerator
}

// AddIndependentPropertyGeneratorsForLinuxPatchSettingsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxPatchSettingsARM(gens map[string]gopter.Gen) {
	gens["AssessmentMode"] = gen.PtrOf(gen.OneConstOf(LinuxPatchSettingsAssessmentModeAutomaticByPlatform, LinuxPatchSettingsAssessmentModeImageDefault))
	gens["PatchMode"] = gen.PtrOf(gen.OneConstOf(LinuxPatchSettingsPatchModeAutomaticByPlatform, LinuxPatchSettingsPatchModeImageDefault))
}

// AddRelatedPropertyGeneratorsForLinuxPatchSettingsARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLinuxPatchSettingsARM(gens map[string]gopter.Gen) {
	gens["AutomaticByPlatformSettings"] = gen.PtrOf(LinuxVMGuestPatchAutomaticByPlatformSettingsARMGenerator())
}

func Test_ManagedDiskParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedDiskParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedDiskParametersARM, ManagedDiskParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedDiskParametersARM runs a test to see if a specific instance of ManagedDiskParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedDiskParametersARM(subject ManagedDiskParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedDiskParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedDiskParametersARM instances for property testing - lazily instantiated by
// ManagedDiskParametersARMGenerator()
var managedDiskParametersARMGenerator gopter.Gen

// ManagedDiskParametersARMGenerator returns a generator of ManagedDiskParametersARM instances for property testing.
// We first initialize managedDiskParametersARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedDiskParametersARMGenerator() gopter.Gen {
	if managedDiskParametersARMGenerator != nil {
		return managedDiskParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedDiskParametersARM(generators)
	managedDiskParametersARMGenerator = gen.Struct(reflect.TypeOf(ManagedDiskParametersARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedDiskParametersARM(generators)
	AddRelatedPropertyGeneratorsForManagedDiskParametersARM(generators)
	managedDiskParametersARMGenerator = gen.Struct(reflect.TypeOf(ManagedDiskParametersARM{}), generators)

	return managedDiskParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedDiskParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedDiskParametersARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountType"] = gen.PtrOf(gen.OneConstOf(
		ManagedDiskParametersStorageAccountTypePremiumLRS,
		ManagedDiskParametersStorageAccountTypePremiumV2LRS,
		ManagedDiskParametersStorageAccountTypePremiumZRS,
		ManagedDiskParametersStorageAccountTypeStandardLRS,
		ManagedDiskParametersStorageAccountTypeStandardSSDLRS,
		ManagedDiskParametersStorageAccountTypeStandardSSDZRS,
		ManagedDiskParametersStorageAccountTypeUltraSSDLRS))
}

// AddRelatedPropertyGeneratorsForManagedDiskParametersARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedDiskParametersARM(gens map[string]gopter.Gen) {
	gens["DiskEncryptionSet"] = gen.PtrOf(DiskEncryptionSetParametersARMGenerator())
	gens["SecurityProfile"] = gen.PtrOf(VMDiskSecurityProfileARMGenerator())
}

func Test_NetworkInterfaceReferencePropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceReferencePropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceReferencePropertiesARM, NetworkInterfaceReferencePropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceReferencePropertiesARM runs a test to see if a specific instance of NetworkInterfaceReferencePropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceReferencePropertiesARM(subject NetworkInterfaceReferencePropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceReferencePropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceReferencePropertiesARM instances for property testing - lazily instantiated by
// NetworkInterfaceReferencePropertiesARMGenerator()
var networkInterfaceReferencePropertiesARMGenerator gopter.Gen

// NetworkInterfaceReferencePropertiesARMGenerator returns a generator of NetworkInterfaceReferencePropertiesARM instances for property testing.
func NetworkInterfaceReferencePropertiesARMGenerator() gopter.Gen {
	if networkInterfaceReferencePropertiesARMGenerator != nil {
		return networkInterfaceReferencePropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceReferencePropertiesARM(generators)
	networkInterfaceReferencePropertiesARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceReferencePropertiesARM{}), generators)

	return networkInterfaceReferencePropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceReferencePropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceReferencePropertiesARM(gens map[string]gopter.Gen) {
	gens["DeleteOption"] = gen.PtrOf(gen.OneConstOf(NetworkInterfaceReferencePropertiesDeleteOptionDelete, NetworkInterfaceReferencePropertiesDeleteOptionDetach))
	gens["Primary"] = gen.PtrOf(gen.Bool())
}

func Test_PatchSettingsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PatchSettingsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPatchSettingsARM, PatchSettingsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPatchSettingsARM runs a test to see if a specific instance of PatchSettingsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPatchSettingsARM(subject PatchSettingsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PatchSettingsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PatchSettingsARM instances for property testing - lazily instantiated by PatchSettingsARMGenerator()
var patchSettingsARMGenerator gopter.Gen

// PatchSettingsARMGenerator returns a generator of PatchSettingsARM instances for property testing.
// We first initialize patchSettingsARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PatchSettingsARMGenerator() gopter.Gen {
	if patchSettingsARMGenerator != nil {
		return patchSettingsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPatchSettingsARM(generators)
	patchSettingsARMGenerator = gen.Struct(reflect.TypeOf(PatchSettingsARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPatchSettingsARM(generators)
	AddRelatedPropertyGeneratorsForPatchSettingsARM(generators)
	patchSettingsARMGenerator = gen.Struct(reflect.TypeOf(PatchSettingsARM{}), generators)

	return patchSettingsARMGenerator
}

// AddIndependentPropertyGeneratorsForPatchSettingsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPatchSettingsARM(gens map[string]gopter.Gen) {
	gens["AssessmentMode"] = gen.PtrOf(gen.OneConstOf(PatchSettingsAssessmentModeAutomaticByPlatform, PatchSettingsAssessmentModeImageDefault))
	gens["EnableHotpatching"] = gen.PtrOf(gen.Bool())
	gens["PatchMode"] = gen.PtrOf(gen.OneConstOf(PatchSettingsPatchModeAutomaticByOS, PatchSettingsPatchModeAutomaticByPlatform, PatchSettingsPatchModeManual))
}

// AddRelatedPropertyGeneratorsForPatchSettingsARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPatchSettingsARM(gens map[string]gopter.Gen) {
	gens["AutomaticByPlatformSettings"] = gen.PtrOf(WindowsVMGuestPatchAutomaticByPlatformSettingsARMGenerator())
}

func Test_SshConfigurationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SshConfigurationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSshConfigurationARM, SshConfigurationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSshConfigurationARM runs a test to see if a specific instance of SshConfigurationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSshConfigurationARM(subject SshConfigurationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SshConfigurationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SshConfigurationARM instances for property testing - lazily instantiated by
// SshConfigurationARMGenerator()
var sshConfigurationARMGenerator gopter.Gen

// SshConfigurationARMGenerator returns a generator of SshConfigurationARM instances for property testing.
func SshConfigurationARMGenerator() gopter.Gen {
	if sshConfigurationARMGenerator != nil {
		return sshConfigurationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForSshConfigurationARM(generators)
	sshConfigurationARMGenerator = gen.Struct(reflect.TypeOf(SshConfigurationARM{}), generators)

	return sshConfigurationARMGenerator
}

// AddRelatedPropertyGeneratorsForSshConfigurationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSshConfigurationARM(gens map[string]gopter.Gen) {
	gens["PublicKeys"] = gen.SliceOf(SshPublicKeyARMGenerator())
}

func Test_VaultCertificateARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultCertificateARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultCertificateARM, VaultCertificateARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultCertificateARM runs a test to see if a specific instance of VaultCertificateARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultCertificateARM(subject VaultCertificateARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultCertificateARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultCertificateARM instances for property testing - lazily instantiated by
// VaultCertificateARMGenerator()
var vaultCertificateARMGenerator gopter.Gen

// VaultCertificateARMGenerator returns a generator of VaultCertificateARM instances for property testing.
func VaultCertificateARMGenerator() gopter.Gen {
	if vaultCertificateARMGenerator != nil {
		return vaultCertificateARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVaultCertificateARM(generators)
	vaultCertificateARMGenerator = gen.Struct(reflect.TypeOf(VaultCertificateARM{}), generators)

	return vaultCertificateARMGenerator
}

// AddIndependentPropertyGeneratorsForVaultCertificateARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVaultCertificateARM(gens map[string]gopter.Gen) {
	gens["CertificateStore"] = gen.PtrOf(gen.AlphaString())
	gens["CertificateUrl"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualHardDiskARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualHardDiskARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualHardDiskARM, VirtualHardDiskARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualHardDiskARM runs a test to see if a specific instance of VirtualHardDiskARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualHardDiskARM(subject VirtualHardDiskARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualHardDiskARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualHardDiskARM instances for property testing - lazily instantiated by VirtualHardDiskARMGenerator()
var virtualHardDiskARMGenerator gopter.Gen

// VirtualHardDiskARMGenerator returns a generator of VirtualHardDiskARM instances for property testing.
func VirtualHardDiskARMGenerator() gopter.Gen {
	if virtualHardDiskARMGenerator != nil {
		return virtualHardDiskARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualHardDiskARM(generators)
	virtualHardDiskARMGenerator = gen.Struct(reflect.TypeOf(VirtualHardDiskARM{}), generators)

	return virtualHardDiskARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualHardDiskARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualHardDiskARM(gens map[string]gopter.Gen) {
	gens["Uri"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_PropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_PropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesARM, VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesARM runs a test to see if a specific instance of VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_PropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesARM(subject VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_PropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_PropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_PropertiesARM instances
// for property testing - lazily instantiated by
// VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesARMGenerator()
var virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesARMGenerator gopter.Gen

// VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesARMGenerator returns a generator of VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_PropertiesARM instances for property testing.
// We first initialize virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesARMGenerator() gopter.Gen {
	if virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesARMGenerator != nil {
		return virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesARM(generators)
	virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_PropertiesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesARM(generators)
	virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_PropertiesARM{}), generators)

	return virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesARM(gens map[string]gopter.Gen) {
	gens["DeleteOption"] = gen.PtrOf(gen.OneConstOf(VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesDeleteOptionDelete, VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesDeleteOptionDetach))
	gens["EnableAcceleratedNetworking"] = gen.PtrOf(gen.Bool())
	gens["EnableFpga"] = gen.PtrOf(gen.Bool())
	gens["EnableIPForwarding"] = gen.PtrOf(gen.Bool())
	gens["Primary"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesARM(gens map[string]gopter.Gen) {
	gens["DnsSettings"] = gen.PtrOf(VirtualMachineNetworkInterfaceDnsSettingsConfigurationARMGenerator())
	gens["DscpConfiguration"] = gen.PtrOf(SubResourceARMGenerator())
	gens["IpConfigurations"] = gen.SliceOf(VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsARMGenerator())
	gens["NetworkSecurityGroup"] = gen.PtrOf(SubResourceARMGenerator())
}

func Test_WinRMConfigurationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WinRMConfigurationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWinRMConfigurationARM, WinRMConfigurationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWinRMConfigurationARM runs a test to see if a specific instance of WinRMConfigurationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWinRMConfigurationARM(subject WinRMConfigurationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WinRMConfigurationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WinRMConfigurationARM instances for property testing - lazily instantiated by
// WinRMConfigurationARMGenerator()
var winRMConfigurationARMGenerator gopter.Gen

// WinRMConfigurationARMGenerator returns a generator of WinRMConfigurationARM instances for property testing.
func WinRMConfigurationARMGenerator() gopter.Gen {
	if winRMConfigurationARMGenerator != nil {
		return winRMConfigurationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForWinRMConfigurationARM(generators)
	winRMConfigurationARMGenerator = gen.Struct(reflect.TypeOf(WinRMConfigurationARM{}), generators)

	return winRMConfigurationARMGenerator
}

// AddRelatedPropertyGeneratorsForWinRMConfigurationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWinRMConfigurationARM(gens map[string]gopter.Gen) {
	gens["Listeners"] = gen.SliceOf(WinRMListenerARMGenerator())
}

func Test_KeyVaultKeyReferenceARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultKeyReferenceARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultKeyReferenceARM, KeyVaultKeyReferenceARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultKeyReferenceARM runs a test to see if a specific instance of KeyVaultKeyReferenceARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultKeyReferenceARM(subject KeyVaultKeyReferenceARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultKeyReferenceARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultKeyReferenceARM instances for property testing - lazily instantiated by
// KeyVaultKeyReferenceARMGenerator()
var keyVaultKeyReferenceARMGenerator gopter.Gen

// KeyVaultKeyReferenceARMGenerator returns a generator of KeyVaultKeyReferenceARM instances for property testing.
// We first initialize keyVaultKeyReferenceARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultKeyReferenceARMGenerator() gopter.Gen {
	if keyVaultKeyReferenceARMGenerator != nil {
		return keyVaultKeyReferenceARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultKeyReferenceARM(generators)
	keyVaultKeyReferenceARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultKeyReferenceARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultKeyReferenceARM(generators)
	AddRelatedPropertyGeneratorsForKeyVaultKeyReferenceARM(generators)
	keyVaultKeyReferenceARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultKeyReferenceARM{}), generators)

	return keyVaultKeyReferenceARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultKeyReferenceARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultKeyReferenceARM(gens map[string]gopter.Gen) {
	gens["KeyUrl"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForKeyVaultKeyReferenceARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultKeyReferenceARM(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SubResourceARMGenerator())
}

func Test_KeyVaultSecretReferenceARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultSecretReferenceARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultSecretReferenceARM, KeyVaultSecretReferenceARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultSecretReferenceARM runs a test to see if a specific instance of KeyVaultSecretReferenceARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultSecretReferenceARM(subject KeyVaultSecretReferenceARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultSecretReferenceARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultSecretReferenceARM instances for property testing - lazily instantiated by
// KeyVaultSecretReferenceARMGenerator()
var keyVaultSecretReferenceARMGenerator gopter.Gen

// KeyVaultSecretReferenceARMGenerator returns a generator of KeyVaultSecretReferenceARM instances for property testing.
// We first initialize keyVaultSecretReferenceARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultSecretReferenceARMGenerator() gopter.Gen {
	if keyVaultSecretReferenceARMGenerator != nil {
		return keyVaultSecretReferenceARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultSecretReferenceARM(generators)
	keyVaultSecretReferenceARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultSecretReferenceARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultSecretReferenceARM(generators)
	AddRelatedPropertyGeneratorsForKeyVaultSecretReferenceARM(generators)
	keyVaultSecretReferenceARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultSecretReferenceARM{}), generators)

	return keyVaultSecretReferenceARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultSecretReferenceARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultSecretReferenceARM(gens map[string]gopter.Gen) {
	gens["SecretUrl"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForKeyVaultSecretReferenceARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultSecretReferenceARM(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SubResourceARMGenerator())
}

func Test_LinuxVMGuestPatchAutomaticByPlatformSettingsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxVMGuestPatchAutomaticByPlatformSettingsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxVMGuestPatchAutomaticByPlatformSettingsARM, LinuxVMGuestPatchAutomaticByPlatformSettingsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxVMGuestPatchAutomaticByPlatformSettingsARM runs a test to see if a specific instance of LinuxVMGuestPatchAutomaticByPlatformSettingsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxVMGuestPatchAutomaticByPlatformSettingsARM(subject LinuxVMGuestPatchAutomaticByPlatformSettingsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxVMGuestPatchAutomaticByPlatformSettingsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxVMGuestPatchAutomaticByPlatformSettingsARM instances for property testing - lazily instantiated by
// LinuxVMGuestPatchAutomaticByPlatformSettingsARMGenerator()
var linuxVMGuestPatchAutomaticByPlatformSettingsARMGenerator gopter.Gen

// LinuxVMGuestPatchAutomaticByPlatformSettingsARMGenerator returns a generator of LinuxVMGuestPatchAutomaticByPlatformSettingsARM instances for property testing.
func LinuxVMGuestPatchAutomaticByPlatformSettingsARMGenerator() gopter.Gen {
	if linuxVMGuestPatchAutomaticByPlatformSettingsARMGenerator != nil {
		return linuxVMGuestPatchAutomaticByPlatformSettingsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxVMGuestPatchAutomaticByPlatformSettingsARM(generators)
	linuxVMGuestPatchAutomaticByPlatformSettingsARMGenerator = gen.Struct(reflect.TypeOf(LinuxVMGuestPatchAutomaticByPlatformSettingsARM{}), generators)

	return linuxVMGuestPatchAutomaticByPlatformSettingsARMGenerator
}

// AddIndependentPropertyGeneratorsForLinuxVMGuestPatchAutomaticByPlatformSettingsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxVMGuestPatchAutomaticByPlatformSettingsARM(gens map[string]gopter.Gen) {
	gens["RebootSetting"] = gen.PtrOf(gen.OneConstOf(
		LinuxVMGuestPatchAutomaticByPlatformSettingsRebootSettingAlways,
		LinuxVMGuestPatchAutomaticByPlatformSettingsRebootSettingIfRequired,
		LinuxVMGuestPatchAutomaticByPlatformSettingsRebootSettingNever,
		LinuxVMGuestPatchAutomaticByPlatformSettingsRebootSettingUnknown))
}

func Test_SshPublicKeyARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SshPublicKeyARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSshPublicKeyARM, SshPublicKeyARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSshPublicKeyARM runs a test to see if a specific instance of SshPublicKeyARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSshPublicKeyARM(subject SshPublicKeyARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SshPublicKeyARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SshPublicKeyARM instances for property testing - lazily instantiated by SshPublicKeyARMGenerator()
var sshPublicKeyARMGenerator gopter.Gen

// SshPublicKeyARMGenerator returns a generator of SshPublicKeyARM instances for property testing.
func SshPublicKeyARMGenerator() gopter.Gen {
	if sshPublicKeyARMGenerator != nil {
		return sshPublicKeyARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSshPublicKeyARM(generators)
	sshPublicKeyARMGenerator = gen.Struct(reflect.TypeOf(SshPublicKeyARM{}), generators)

	return sshPublicKeyARMGenerator
}

// AddIndependentPropertyGeneratorsForSshPublicKeyARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSshPublicKeyARM(gens map[string]gopter.Gen) {
	gens["KeyData"] = gen.PtrOf(gen.AlphaString())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
}

func Test_VMDiskSecurityProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VMDiskSecurityProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVMDiskSecurityProfileARM, VMDiskSecurityProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVMDiskSecurityProfileARM runs a test to see if a specific instance of VMDiskSecurityProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVMDiskSecurityProfileARM(subject VMDiskSecurityProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VMDiskSecurityProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VMDiskSecurityProfileARM instances for property testing - lazily instantiated by
// VMDiskSecurityProfileARMGenerator()
var vmDiskSecurityProfileARMGenerator gopter.Gen

// VMDiskSecurityProfileARMGenerator returns a generator of VMDiskSecurityProfileARM instances for property testing.
// We first initialize vmDiskSecurityProfileARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VMDiskSecurityProfileARMGenerator() gopter.Gen {
	if vmDiskSecurityProfileARMGenerator != nil {
		return vmDiskSecurityProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVMDiskSecurityProfileARM(generators)
	vmDiskSecurityProfileARMGenerator = gen.Struct(reflect.TypeOf(VMDiskSecurityProfileARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVMDiskSecurityProfileARM(generators)
	AddRelatedPropertyGeneratorsForVMDiskSecurityProfileARM(generators)
	vmDiskSecurityProfileARMGenerator = gen.Struct(reflect.TypeOf(VMDiskSecurityProfileARM{}), generators)

	return vmDiskSecurityProfileARMGenerator
}

// AddIndependentPropertyGeneratorsForVMDiskSecurityProfileARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVMDiskSecurityProfileARM(gens map[string]gopter.Gen) {
	gens["SecurityEncryptionType"] = gen.PtrOf(gen.OneConstOf(VMDiskSecurityProfileSecurityEncryptionTypeDiskWithVMGuestState, VMDiskSecurityProfileSecurityEncryptionTypeVMGuestStateOnly))
}

// AddRelatedPropertyGeneratorsForVMDiskSecurityProfileARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVMDiskSecurityProfileARM(gens map[string]gopter.Gen) {
	gens["DiskEncryptionSet"] = gen.PtrOf(DiskEncryptionSetParametersARMGenerator())
}

func Test_VirtualMachineNetworkInterfaceDnsSettingsConfigurationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineNetworkInterfaceDnsSettingsConfigurationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineNetworkInterfaceDnsSettingsConfigurationARM, VirtualMachineNetworkInterfaceDnsSettingsConfigurationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineNetworkInterfaceDnsSettingsConfigurationARM runs a test to see if a specific instance of VirtualMachineNetworkInterfaceDnsSettingsConfigurationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineNetworkInterfaceDnsSettingsConfigurationARM(subject VirtualMachineNetworkInterfaceDnsSettingsConfigurationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineNetworkInterfaceDnsSettingsConfigurationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineNetworkInterfaceDnsSettingsConfigurationARM instances for property testing - lazily
// instantiated by VirtualMachineNetworkInterfaceDnsSettingsConfigurationARMGenerator()
var virtualMachineNetworkInterfaceDnsSettingsConfigurationARMGenerator gopter.Gen

// VirtualMachineNetworkInterfaceDnsSettingsConfigurationARMGenerator returns a generator of VirtualMachineNetworkInterfaceDnsSettingsConfigurationARM instances for property testing.
func VirtualMachineNetworkInterfaceDnsSettingsConfigurationARMGenerator() gopter.Gen {
	if virtualMachineNetworkInterfaceDnsSettingsConfigurationARMGenerator != nil {
		return virtualMachineNetworkInterfaceDnsSettingsConfigurationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineNetworkInterfaceDnsSettingsConfigurationARM(generators)
	virtualMachineNetworkInterfaceDnsSettingsConfigurationARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineNetworkInterfaceDnsSettingsConfigurationARM{}), generators)

	return virtualMachineNetworkInterfaceDnsSettingsConfigurationARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineNetworkInterfaceDnsSettingsConfigurationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineNetworkInterfaceDnsSettingsConfigurationARM(gens map[string]gopter.Gen) {
	gens["DnsServers"] = gen.SliceOf(gen.AlphaString())
}

func Test_VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurationsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurationsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsARM, VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsARM runs a test to see if a specific instance of VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurationsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsARM(subject VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurationsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurationsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of
// VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurationsARM instances
// for property testing - lazily instantiated by
// VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsARMGenerator()
var virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsARMGenerator gopter.Gen

// VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsARMGenerator returns a generator of VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurationsARM instances for property testing.
// We first initialize virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsARMGenerator() gopter.Gen {
	if virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsARMGenerator != nil {
		return virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsARM(generators)
	virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurationsARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsARM(generators)
	virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurationsARM{}), generators)

	return virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesARMGenerator())
}

func Test_WinRMListenerARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WinRMListenerARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWinRMListenerARM, WinRMListenerARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWinRMListenerARM runs a test to see if a specific instance of WinRMListenerARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWinRMListenerARM(subject WinRMListenerARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WinRMListenerARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WinRMListenerARM instances for property testing - lazily instantiated by WinRMListenerARMGenerator()
var winRMListenerARMGenerator gopter.Gen

// WinRMListenerARMGenerator returns a generator of WinRMListenerARM instances for property testing.
func WinRMListenerARMGenerator() gopter.Gen {
	if winRMListenerARMGenerator != nil {
		return winRMListenerARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWinRMListenerARM(generators)
	winRMListenerARMGenerator = gen.Struct(reflect.TypeOf(WinRMListenerARM{}), generators)

	return winRMListenerARMGenerator
}

// AddIndependentPropertyGeneratorsForWinRMListenerARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWinRMListenerARM(gens map[string]gopter.Gen) {
	gens["CertificateUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(WinRMListenerProtocolHttp, WinRMListenerProtocolHttps))
}

func Test_WindowsVMGuestPatchAutomaticByPlatformSettingsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WindowsVMGuestPatchAutomaticByPlatformSettingsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWindowsVMGuestPatchAutomaticByPlatformSettingsARM, WindowsVMGuestPatchAutomaticByPlatformSettingsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWindowsVMGuestPatchAutomaticByPlatformSettingsARM runs a test to see if a specific instance of WindowsVMGuestPatchAutomaticByPlatformSettingsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWindowsVMGuestPatchAutomaticByPlatformSettingsARM(subject WindowsVMGuestPatchAutomaticByPlatformSettingsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WindowsVMGuestPatchAutomaticByPlatformSettingsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WindowsVMGuestPatchAutomaticByPlatformSettingsARM instances for property testing - lazily instantiated
// by WindowsVMGuestPatchAutomaticByPlatformSettingsARMGenerator()
var windowsVMGuestPatchAutomaticByPlatformSettingsARMGenerator gopter.Gen

// WindowsVMGuestPatchAutomaticByPlatformSettingsARMGenerator returns a generator of WindowsVMGuestPatchAutomaticByPlatformSettingsARM instances for property testing.
func WindowsVMGuestPatchAutomaticByPlatformSettingsARMGenerator() gopter.Gen {
	if windowsVMGuestPatchAutomaticByPlatformSettingsARMGenerator != nil {
		return windowsVMGuestPatchAutomaticByPlatformSettingsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsVMGuestPatchAutomaticByPlatformSettingsARM(generators)
	windowsVMGuestPatchAutomaticByPlatformSettingsARMGenerator = gen.Struct(reflect.TypeOf(WindowsVMGuestPatchAutomaticByPlatformSettingsARM{}), generators)

	return windowsVMGuestPatchAutomaticByPlatformSettingsARMGenerator
}

// AddIndependentPropertyGeneratorsForWindowsVMGuestPatchAutomaticByPlatformSettingsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWindowsVMGuestPatchAutomaticByPlatformSettingsARM(gens map[string]gopter.Gen) {
	gens["RebootSetting"] = gen.PtrOf(gen.OneConstOf(
		WindowsVMGuestPatchAutomaticByPlatformSettingsRebootSettingAlways,
		WindowsVMGuestPatchAutomaticByPlatformSettingsRebootSettingIfRequired,
		WindowsVMGuestPatchAutomaticByPlatformSettingsRebootSettingNever,
		WindowsVMGuestPatchAutomaticByPlatformSettingsRebootSettingUnknown))
}

func Test_VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_PropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_PropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesARM, VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesARM runs a test to see if a specific instance of VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_PropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesARM(subject VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_PropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_PropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of
// VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_PropertiesARM
// instances for property testing - lazily instantiated by
// VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesARMGenerator()
var virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesARMGenerator gopter.Gen

// VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesARMGenerator returns a generator of VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_PropertiesARM instances for property testing.
// We first initialize virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesARMGenerator() gopter.Gen {
	if virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesARMGenerator != nil {
		return virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesARM(generators)
	virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_PropertiesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesARM(generators)
	virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_PropertiesARM{}), generators)

	return virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesARM(gens map[string]gopter.Gen) {
	gens["Primary"] = gen.PtrOf(gen.Bool())
	gens["PrivateIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPrivateIPAddressVersionIPv4, VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPrivateIPAddressVersionIPv6))
}

// AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesARM(gens map[string]gopter.Gen) {
	gens["ApplicationGatewayBackendAddressPools"] = gen.SliceOf(SubResourceARMGenerator())
	gens["ApplicationSecurityGroups"] = gen.SliceOf(SubResourceARMGenerator())
	gens["LoadBalancerBackendAddressPools"] = gen.SliceOf(SubResourceARMGenerator())
	gens["PublicIPAddressConfiguration"] = gen.PtrOf(VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfigurationARMGenerator())
	gens["Subnet"] = gen.PtrOf(SubResourceARMGenerator())
}

func Test_VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_Properties_PublicIPAddressConfigurationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_Properties_PublicIPAddressConfigurationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfigurationARM, VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfigurationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfigurationARM runs a test to see if a specific instance of VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_Properties_PublicIPAddressConfigurationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfigurationARM(subject VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_Properties_PublicIPAddressConfigurationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_Properties_PublicIPAddressConfigurationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of
// VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_Properties_PublicIPAddressConfigurationARM
// instances for property testing - lazily instantiated by
// VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfigurationARMGenerator()
var virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfigurationARMGenerator gopter.Gen

// VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfigurationARMGenerator returns a generator of VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_Properties_PublicIPAddressConfigurationARM instances for property testing.
// We first initialize virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfigurationARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfigurationARMGenerator() gopter.Gen {
	if virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfigurationARMGenerator != nil {
		return virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfigurationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfigurationARM(generators)
	virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfigurationARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_Properties_PublicIPAddressConfigurationARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfigurationARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfigurationARM(generators)
	virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfigurationARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachines_Spec_Properties_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_Properties_PublicIPAddressConfigurationARM{}), generators)

	return virtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfigurationARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfigurationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfigurationARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfigurationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachinesSpecPropertiesNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfigurationARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(VirtualMachinePublicIPAddressConfigurationPropertiesARMGenerator())
	gens["Sku"] = gen.PtrOf(PublicIPAddressSkuARMGenerator())
}

func Test_PublicIPAddressSkuARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddressSkuARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddressSkuARM, PublicIPAddressSkuARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddressSkuARM runs a test to see if a specific instance of PublicIPAddressSkuARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddressSkuARM(subject PublicIPAddressSkuARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddressSkuARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddressSkuARM instances for property testing - lazily instantiated by
// PublicIPAddressSkuARMGenerator()
var publicIPAddressSkuARMGenerator gopter.Gen

// PublicIPAddressSkuARMGenerator returns a generator of PublicIPAddressSkuARM instances for property testing.
func PublicIPAddressSkuARMGenerator() gopter.Gen {
	if publicIPAddressSkuARMGenerator != nil {
		return publicIPAddressSkuARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressSkuARM(generators)
	publicIPAddressSkuARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressSkuARM{}), generators)

	return publicIPAddressSkuARMGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddressSkuARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddressSkuARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(PublicIPAddressSkuNameBasic, PublicIPAddressSkuNameStandard))
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(PublicIPAddressSkuTierGlobal, PublicIPAddressSkuTierRegional))
}

func Test_VirtualMachinePublicIPAddressConfigurationPropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachinePublicIPAddressConfigurationPropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachinePublicIPAddressConfigurationPropertiesARM, VirtualMachinePublicIPAddressConfigurationPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachinePublicIPAddressConfigurationPropertiesARM runs a test to see if a specific instance of VirtualMachinePublicIPAddressConfigurationPropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachinePublicIPAddressConfigurationPropertiesARM(subject VirtualMachinePublicIPAddressConfigurationPropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachinePublicIPAddressConfigurationPropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachinePublicIPAddressConfigurationPropertiesARM instances for property testing - lazily
// instantiated by VirtualMachinePublicIPAddressConfigurationPropertiesARMGenerator()
var virtualMachinePublicIPAddressConfigurationPropertiesARMGenerator gopter.Gen

// VirtualMachinePublicIPAddressConfigurationPropertiesARMGenerator returns a generator of VirtualMachinePublicIPAddressConfigurationPropertiesARM instances for property testing.
// We first initialize virtualMachinePublicIPAddressConfigurationPropertiesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachinePublicIPAddressConfigurationPropertiesARMGenerator() gopter.Gen {
	if virtualMachinePublicIPAddressConfigurationPropertiesARMGenerator != nil {
		return virtualMachinePublicIPAddressConfigurationPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinePublicIPAddressConfigurationPropertiesARM(generators)
	virtualMachinePublicIPAddressConfigurationPropertiesARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachinePublicIPAddressConfigurationPropertiesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinePublicIPAddressConfigurationPropertiesARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachinePublicIPAddressConfigurationPropertiesARM(generators)
	virtualMachinePublicIPAddressConfigurationPropertiesARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachinePublicIPAddressConfigurationPropertiesARM{}), generators)

	return virtualMachinePublicIPAddressConfigurationPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachinePublicIPAddressConfigurationPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachinePublicIPAddressConfigurationPropertiesARM(gens map[string]gopter.Gen) {
	gens["DeleteOption"] = gen.PtrOf(gen.OneConstOf(VirtualMachinePublicIPAddressConfigurationPropertiesDeleteOptionDelete, VirtualMachinePublicIPAddressConfigurationPropertiesDeleteOptionDetach))
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["PublicIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(VirtualMachinePublicIPAddressConfigurationPropertiesPublicIPAddressVersionIPv4, VirtualMachinePublicIPAddressConfigurationPropertiesPublicIPAddressVersionIPv6))
	gens["PublicIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(VirtualMachinePublicIPAddressConfigurationPropertiesPublicIPAllocationMethodDynamic, VirtualMachinePublicIPAddressConfigurationPropertiesPublicIPAllocationMethodStatic))
}

// AddRelatedPropertyGeneratorsForVirtualMachinePublicIPAddressConfigurationPropertiesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachinePublicIPAddressConfigurationPropertiesARM(gens map[string]gopter.Gen) {
	gens["DnsSettings"] = gen.PtrOf(VirtualMachinePublicIPAddressDnsSettingsConfigurationARMGenerator())
	gens["IpTags"] = gen.SliceOf(VirtualMachineIpTagARMGenerator())
	gens["PublicIPPrefix"] = gen.PtrOf(SubResourceARMGenerator())
}

func Test_VirtualMachineIpTagARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineIpTagARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineIpTagARM, VirtualMachineIpTagARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineIpTagARM runs a test to see if a specific instance of VirtualMachineIpTagARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineIpTagARM(subject VirtualMachineIpTagARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineIpTagARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineIpTagARM instances for property testing - lazily instantiated by
// VirtualMachineIpTagARMGenerator()
var virtualMachineIpTagARMGenerator gopter.Gen

// VirtualMachineIpTagARMGenerator returns a generator of VirtualMachineIpTagARM instances for property testing.
func VirtualMachineIpTagARMGenerator() gopter.Gen {
	if virtualMachineIpTagARMGenerator != nil {
		return virtualMachineIpTagARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineIpTagARM(generators)
	virtualMachineIpTagARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineIpTagARM{}), generators)

	return virtualMachineIpTagARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineIpTagARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineIpTagARM(gens map[string]gopter.Gen) {
	gens["IpTagType"] = gen.PtrOf(gen.AlphaString())
	gens["Tag"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachinePublicIPAddressDnsSettingsConfigurationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachinePublicIPAddressDnsSettingsConfigurationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachinePublicIPAddressDnsSettingsConfigurationARM, VirtualMachinePublicIPAddressDnsSettingsConfigurationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachinePublicIPAddressDnsSettingsConfigurationARM runs a test to see if a specific instance of VirtualMachinePublicIPAddressDnsSettingsConfigurationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachinePublicIPAddressDnsSettingsConfigurationARM(subject VirtualMachinePublicIPAddressDnsSettingsConfigurationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachinePublicIPAddressDnsSettingsConfigurationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachinePublicIPAddressDnsSettingsConfigurationARM instances for property testing - lazily
// instantiated by VirtualMachinePublicIPAddressDnsSettingsConfigurationARMGenerator()
var virtualMachinePublicIPAddressDnsSettingsConfigurationARMGenerator gopter.Gen

// VirtualMachinePublicIPAddressDnsSettingsConfigurationARMGenerator returns a generator of VirtualMachinePublicIPAddressDnsSettingsConfigurationARM instances for property testing.
func VirtualMachinePublicIPAddressDnsSettingsConfigurationARMGenerator() gopter.Gen {
	if virtualMachinePublicIPAddressDnsSettingsConfigurationARMGenerator != nil {
		return virtualMachinePublicIPAddressDnsSettingsConfigurationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinePublicIPAddressDnsSettingsConfigurationARM(generators)
	virtualMachinePublicIPAddressDnsSettingsConfigurationARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachinePublicIPAddressDnsSettingsConfigurationARM{}), generators)

	return virtualMachinePublicIPAddressDnsSettingsConfigurationARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachinePublicIPAddressDnsSettingsConfigurationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachinePublicIPAddressDnsSettingsConfigurationARM(gens map[string]gopter.Gen) {
	gens["DomainNameLabel"] = gen.PtrOf(gen.AlphaString())
}
