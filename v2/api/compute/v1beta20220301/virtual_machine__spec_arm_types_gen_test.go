// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20220301

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_VirtualMachine_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachine_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachine_SpecARM, VirtualMachine_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachine_SpecARM runs a test to see if a specific instance of VirtualMachine_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachine_SpecARM(subject VirtualMachine_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachine_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachine_SpecARM instances for property testing - lazily instantiated by
// VirtualMachine_SpecARMGenerator()
var virtualMachine_SpecARMGenerator gopter.Gen

// VirtualMachine_SpecARMGenerator returns a generator of VirtualMachine_SpecARM instances for property testing.
// We first initialize virtualMachine_SpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachine_SpecARMGenerator() gopter.Gen {
	if virtualMachine_SpecARMGenerator != nil {
		return virtualMachine_SpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachine_SpecARM(generators)
	virtualMachine_SpecARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachine_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachine_SpecARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachine_SpecARM(generators)
	virtualMachine_SpecARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachine_SpecARM{}), generators)

	return virtualMachine_SpecARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachine_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachine_SpecARM(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachine_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachine_SpecARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationARMGenerator())
	gens["Identity"] = gen.PtrOf(VirtualMachineIdentityARMGenerator())
	gens["Plan"] = gen.PtrOf(PlanARMGenerator())
	gens["Properties"] = gen.PtrOf(VirtualMachinePropertiesARMGenerator())
}

func Test_VirtualMachineIdentityARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineIdentityARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineIdentityARM, VirtualMachineIdentityARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineIdentityARM runs a test to see if a specific instance of VirtualMachineIdentityARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineIdentityARM(subject VirtualMachineIdentityARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineIdentityARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineIdentityARM instances for property testing - lazily instantiated by
// VirtualMachineIdentityARMGenerator()
var virtualMachineIdentityARMGenerator gopter.Gen

// VirtualMachineIdentityARMGenerator returns a generator of VirtualMachineIdentityARM instances for property testing.
func VirtualMachineIdentityARMGenerator() gopter.Gen {
	if virtualMachineIdentityARMGenerator != nil {
		return virtualMachineIdentityARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineIdentityARM(generators)
	virtualMachineIdentityARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineIdentityARM{}), generators)

	return virtualMachineIdentityARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineIdentityARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineIdentityARM(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		VirtualMachineIdentity_Type_None,
		VirtualMachineIdentity_Type_SystemAssigned,
		VirtualMachineIdentity_Type_SystemAssignedUserAssigned,
		VirtualMachineIdentity_Type_UserAssigned))
}

func Test_VirtualMachinePropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachinePropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachinePropertiesARM, VirtualMachinePropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachinePropertiesARM runs a test to see if a specific instance of VirtualMachinePropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachinePropertiesARM(subject VirtualMachinePropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachinePropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachinePropertiesARM instances for property testing - lazily instantiated by
// VirtualMachinePropertiesARMGenerator()
var virtualMachinePropertiesARMGenerator gopter.Gen

// VirtualMachinePropertiesARMGenerator returns a generator of VirtualMachinePropertiesARM instances for property testing.
// We first initialize virtualMachinePropertiesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachinePropertiesARMGenerator() gopter.Gen {
	if virtualMachinePropertiesARMGenerator != nil {
		return virtualMachinePropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinePropertiesARM(generators)
	virtualMachinePropertiesARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachinePropertiesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinePropertiesARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachinePropertiesARM(generators)
	virtualMachinePropertiesARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachinePropertiesARM{}), generators)

	return virtualMachinePropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachinePropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachinePropertiesARM(gens map[string]gopter.Gen) {
	gens["EvictionPolicy"] = gen.PtrOf(gen.OneConstOf(EvictionPolicy_Deallocate, EvictionPolicy_Delete))
	gens["ExtensionsTimeBudget"] = gen.PtrOf(gen.AlphaString())
	gens["LicenseType"] = gen.PtrOf(gen.AlphaString())
	gens["PlatformFaultDomain"] = gen.PtrOf(gen.Int())
	gens["Priority"] = gen.PtrOf(gen.OneConstOf(Priority_Low, Priority_Regular, Priority_Spot))
	gens["UserData"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachinePropertiesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachinePropertiesARM(gens map[string]gopter.Gen) {
	gens["AdditionalCapabilities"] = gen.PtrOf(AdditionalCapabilitiesARMGenerator())
	gens["ApplicationProfile"] = gen.PtrOf(ApplicationProfileARMGenerator())
	gens["AvailabilitySet"] = gen.PtrOf(SubResourceARMGenerator())
	gens["BillingProfile"] = gen.PtrOf(BillingProfileARMGenerator())
	gens["CapacityReservation"] = gen.PtrOf(CapacityReservationProfileARMGenerator())
	gens["DiagnosticsProfile"] = gen.PtrOf(DiagnosticsProfileARMGenerator())
	gens["HardwareProfile"] = gen.PtrOf(HardwareProfileARMGenerator())
	gens["Host"] = gen.PtrOf(SubResourceARMGenerator())
	gens["HostGroup"] = gen.PtrOf(SubResourceARMGenerator())
	gens["NetworkProfile"] = gen.PtrOf(NetworkProfileARMGenerator())
	gens["OsProfile"] = gen.PtrOf(OSProfileARMGenerator())
	gens["ProximityPlacementGroup"] = gen.PtrOf(SubResourceARMGenerator())
	gens["ScheduledEventsProfile"] = gen.PtrOf(ScheduledEventsProfileARMGenerator())
	gens["SecurityProfile"] = gen.PtrOf(SecurityProfileARMGenerator())
	gens["StorageProfile"] = gen.PtrOf(StorageProfileARMGenerator())
	gens["VirtualMachineScaleSet"] = gen.PtrOf(SubResourceARMGenerator())
}

func Test_ApplicationProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApplicationProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApplicationProfileARM, ApplicationProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApplicationProfileARM runs a test to see if a specific instance of ApplicationProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForApplicationProfileARM(subject ApplicationProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApplicationProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApplicationProfileARM instances for property testing - lazily instantiated by
// ApplicationProfileARMGenerator()
var applicationProfileARMGenerator gopter.Gen

// ApplicationProfileARMGenerator returns a generator of ApplicationProfileARM instances for property testing.
func ApplicationProfileARMGenerator() gopter.Gen {
	if applicationProfileARMGenerator != nil {
		return applicationProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForApplicationProfileARM(generators)
	applicationProfileARMGenerator = gen.Struct(reflect.TypeOf(ApplicationProfileARM{}), generators)

	return applicationProfileARMGenerator
}

// AddRelatedPropertyGeneratorsForApplicationProfileARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForApplicationProfileARM(gens map[string]gopter.Gen) {
	gens["GalleryApplications"] = gen.SliceOf(VMGalleryApplicationARMGenerator())
}

func Test_BillingProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BillingProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBillingProfileARM, BillingProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBillingProfileARM runs a test to see if a specific instance of BillingProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBillingProfileARM(subject BillingProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BillingProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BillingProfileARM instances for property testing - lazily instantiated by BillingProfileARMGenerator()
var billingProfileARMGenerator gopter.Gen

// BillingProfileARMGenerator returns a generator of BillingProfileARM instances for property testing.
func BillingProfileARMGenerator() gopter.Gen {
	if billingProfileARMGenerator != nil {
		return billingProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBillingProfileARM(generators)
	billingProfileARMGenerator = gen.Struct(reflect.TypeOf(BillingProfileARM{}), generators)

	return billingProfileARMGenerator
}

// AddIndependentPropertyGeneratorsForBillingProfileARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBillingProfileARM(gens map[string]gopter.Gen) {
	gens["MaxPrice"] = gen.PtrOf(gen.Float64())
}

func Test_CapacityReservationProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CapacityReservationProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCapacityReservationProfileARM, CapacityReservationProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCapacityReservationProfileARM runs a test to see if a specific instance of CapacityReservationProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCapacityReservationProfileARM(subject CapacityReservationProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CapacityReservationProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CapacityReservationProfileARM instances for property testing - lazily instantiated by
// CapacityReservationProfileARMGenerator()
var capacityReservationProfileARMGenerator gopter.Gen

// CapacityReservationProfileARMGenerator returns a generator of CapacityReservationProfileARM instances for property testing.
func CapacityReservationProfileARMGenerator() gopter.Gen {
	if capacityReservationProfileARMGenerator != nil {
		return capacityReservationProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForCapacityReservationProfileARM(generators)
	capacityReservationProfileARMGenerator = gen.Struct(reflect.TypeOf(CapacityReservationProfileARM{}), generators)

	return capacityReservationProfileARMGenerator
}

// AddRelatedPropertyGeneratorsForCapacityReservationProfileARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCapacityReservationProfileARM(gens map[string]gopter.Gen) {
	gens["CapacityReservationGroup"] = gen.PtrOf(SubResourceARMGenerator())
}

func Test_DiagnosticsProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiagnosticsProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiagnosticsProfileARM, DiagnosticsProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiagnosticsProfileARM runs a test to see if a specific instance of DiagnosticsProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiagnosticsProfileARM(subject DiagnosticsProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiagnosticsProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiagnosticsProfileARM instances for property testing - lazily instantiated by
// DiagnosticsProfileARMGenerator()
var diagnosticsProfileARMGenerator gopter.Gen

// DiagnosticsProfileARMGenerator returns a generator of DiagnosticsProfileARM instances for property testing.
func DiagnosticsProfileARMGenerator() gopter.Gen {
	if diagnosticsProfileARMGenerator != nil {
		return diagnosticsProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDiagnosticsProfileARM(generators)
	diagnosticsProfileARMGenerator = gen.Struct(reflect.TypeOf(DiagnosticsProfileARM{}), generators)

	return diagnosticsProfileARMGenerator
}

// AddRelatedPropertyGeneratorsForDiagnosticsProfileARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiagnosticsProfileARM(gens map[string]gopter.Gen) {
	gens["BootDiagnostics"] = gen.PtrOf(BootDiagnosticsARMGenerator())
}

func Test_HardwareProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HardwareProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHardwareProfileARM, HardwareProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHardwareProfileARM runs a test to see if a specific instance of HardwareProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHardwareProfileARM(subject HardwareProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HardwareProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HardwareProfileARM instances for property testing - lazily instantiated by HardwareProfileARMGenerator()
var hardwareProfileARMGenerator gopter.Gen

// HardwareProfileARMGenerator returns a generator of HardwareProfileARM instances for property testing.
// We first initialize hardwareProfileARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func HardwareProfileARMGenerator() gopter.Gen {
	if hardwareProfileARMGenerator != nil {
		return hardwareProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHardwareProfileARM(generators)
	hardwareProfileARMGenerator = gen.Struct(reflect.TypeOf(HardwareProfileARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHardwareProfileARM(generators)
	AddRelatedPropertyGeneratorsForHardwareProfileARM(generators)
	hardwareProfileARMGenerator = gen.Struct(reflect.TypeOf(HardwareProfileARM{}), generators)

	return hardwareProfileARMGenerator
}

// AddIndependentPropertyGeneratorsForHardwareProfileARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHardwareProfileARM(gens map[string]gopter.Gen) {
	gens["VmSize"] = gen.PtrOf(gen.OneConstOf(
		HardwareProfile_VmSize_Basic_A0,
		HardwareProfile_VmSize_Basic_A1,
		HardwareProfile_VmSize_Basic_A2,
		HardwareProfile_VmSize_Basic_A3,
		HardwareProfile_VmSize_Basic_A4,
		HardwareProfile_VmSize_Standard_A0,
		HardwareProfile_VmSize_Standard_A1,
		HardwareProfile_VmSize_Standard_A10,
		HardwareProfile_VmSize_Standard_A11,
		HardwareProfile_VmSize_Standard_A1_V2,
		HardwareProfile_VmSize_Standard_A2,
		HardwareProfile_VmSize_Standard_A2M_V2,
		HardwareProfile_VmSize_Standard_A2_V2,
		HardwareProfile_VmSize_Standard_A3,
		HardwareProfile_VmSize_Standard_A4,
		HardwareProfile_VmSize_Standard_A4M_V2,
		HardwareProfile_VmSize_Standard_A4_V2,
		HardwareProfile_VmSize_Standard_A5,
		HardwareProfile_VmSize_Standard_A6,
		HardwareProfile_VmSize_Standard_A7,
		HardwareProfile_VmSize_Standard_A8,
		HardwareProfile_VmSize_Standard_A8M_V2,
		HardwareProfile_VmSize_Standard_A8_V2,
		HardwareProfile_VmSize_Standard_A9,
		HardwareProfile_VmSize_Standard_B1Ms,
		HardwareProfile_VmSize_Standard_B1S,
		HardwareProfile_VmSize_Standard_B2Ms,
		HardwareProfile_VmSize_Standard_B2S,
		HardwareProfile_VmSize_Standard_B4Ms,
		HardwareProfile_VmSize_Standard_B8Ms,
		HardwareProfile_VmSize_Standard_D1,
		HardwareProfile_VmSize_Standard_D11,
		HardwareProfile_VmSize_Standard_D11_V2,
		HardwareProfile_VmSize_Standard_D12,
		HardwareProfile_VmSize_Standard_D12_V2,
		HardwareProfile_VmSize_Standard_D13,
		HardwareProfile_VmSize_Standard_D13_V2,
		HardwareProfile_VmSize_Standard_D14,
		HardwareProfile_VmSize_Standard_D14_V2,
		HardwareProfile_VmSize_Standard_D15_V2,
		HardwareProfile_VmSize_Standard_D16S_V3,
		HardwareProfile_VmSize_Standard_D16_V3,
		HardwareProfile_VmSize_Standard_D1_V2,
		HardwareProfile_VmSize_Standard_D2,
		HardwareProfile_VmSize_Standard_D2S_V3,
		HardwareProfile_VmSize_Standard_D2_V2,
		HardwareProfile_VmSize_Standard_D2_V3,
		HardwareProfile_VmSize_Standard_D3,
		HardwareProfile_VmSize_Standard_D32S_V3,
		HardwareProfile_VmSize_Standard_D32_V3,
		HardwareProfile_VmSize_Standard_D3_V2,
		HardwareProfile_VmSize_Standard_D4,
		HardwareProfile_VmSize_Standard_D4S_V3,
		HardwareProfile_VmSize_Standard_D4_V2,
		HardwareProfile_VmSize_Standard_D4_V3,
		HardwareProfile_VmSize_Standard_D5_V2,
		HardwareProfile_VmSize_Standard_D64S_V3,
		HardwareProfile_VmSize_Standard_D64_V3,
		HardwareProfile_VmSize_Standard_D8S_V3,
		HardwareProfile_VmSize_Standard_D8_V3,
		HardwareProfile_VmSize_Standard_DS1,
		HardwareProfile_VmSize_Standard_DS11,
		HardwareProfile_VmSize_Standard_DS11_V2,
		HardwareProfile_VmSize_Standard_DS12,
		HardwareProfile_VmSize_Standard_DS12_V2,
		HardwareProfile_VmSize_Standard_DS13,
		HardwareProfile_VmSize_Standard_DS132_V2,
		HardwareProfile_VmSize_Standard_DS134_V2,
		HardwareProfile_VmSize_Standard_DS13_V2,
		HardwareProfile_VmSize_Standard_DS14,
		HardwareProfile_VmSize_Standard_DS144_V2,
		HardwareProfile_VmSize_Standard_DS148_V2,
		HardwareProfile_VmSize_Standard_DS14_V2,
		HardwareProfile_VmSize_Standard_DS15_V2,
		HardwareProfile_VmSize_Standard_DS1_V2,
		HardwareProfile_VmSize_Standard_DS2,
		HardwareProfile_VmSize_Standard_DS2_V2,
		HardwareProfile_VmSize_Standard_DS3,
		HardwareProfile_VmSize_Standard_DS3_V2,
		HardwareProfile_VmSize_Standard_DS4,
		HardwareProfile_VmSize_Standard_DS4_V2,
		HardwareProfile_VmSize_Standard_DS5_V2,
		HardwareProfile_VmSize_Standard_E16S_V3,
		HardwareProfile_VmSize_Standard_E16_V3,
		HardwareProfile_VmSize_Standard_E2S_V3,
		HardwareProfile_VmSize_Standard_E2_V3,
		HardwareProfile_VmSize_Standard_E3216_V3,
		HardwareProfile_VmSize_Standard_E328S_V3,
		HardwareProfile_VmSize_Standard_E32S_V3,
		HardwareProfile_VmSize_Standard_E32_V3,
		HardwareProfile_VmSize_Standard_E4S_V3,
		HardwareProfile_VmSize_Standard_E4_V3,
		HardwareProfile_VmSize_Standard_E6416S_V3,
		HardwareProfile_VmSize_Standard_E6432S_V3,
		HardwareProfile_VmSize_Standard_E64S_V3,
		HardwareProfile_VmSize_Standard_E64_V3,
		HardwareProfile_VmSize_Standard_E8S_V3,
		HardwareProfile_VmSize_Standard_E8_V3,
		HardwareProfile_VmSize_Standard_F1,
		HardwareProfile_VmSize_Standard_F16,
		HardwareProfile_VmSize_Standard_F16S,
		HardwareProfile_VmSize_Standard_F16S_V2,
		HardwareProfile_VmSize_Standard_F1S,
		HardwareProfile_VmSize_Standard_F2,
		HardwareProfile_VmSize_Standard_F2S,
		HardwareProfile_VmSize_Standard_F2S_V2,
		HardwareProfile_VmSize_Standard_F32S_V2,
		HardwareProfile_VmSize_Standard_F4,
		HardwareProfile_VmSize_Standard_F4S,
		HardwareProfile_VmSize_Standard_F4S_V2,
		HardwareProfile_VmSize_Standard_F64S_V2,
		HardwareProfile_VmSize_Standard_F72S_V2,
		HardwareProfile_VmSize_Standard_F8,
		HardwareProfile_VmSize_Standard_F8S,
		HardwareProfile_VmSize_Standard_F8S_V2,
		HardwareProfile_VmSize_Standard_G1,
		HardwareProfile_VmSize_Standard_G2,
		HardwareProfile_VmSize_Standard_G3,
		HardwareProfile_VmSize_Standard_G4,
		HardwareProfile_VmSize_Standard_G5,
		HardwareProfile_VmSize_Standard_GS1,
		HardwareProfile_VmSize_Standard_GS2,
		HardwareProfile_VmSize_Standard_GS3,
		HardwareProfile_VmSize_Standard_GS4,
		HardwareProfile_VmSize_Standard_GS44,
		HardwareProfile_VmSize_Standard_GS48,
		HardwareProfile_VmSize_Standard_GS5,
		HardwareProfile_VmSize_Standard_GS516,
		HardwareProfile_VmSize_Standard_GS58,
		HardwareProfile_VmSize_Standard_H16,
		HardwareProfile_VmSize_Standard_H16M,
		HardwareProfile_VmSize_Standard_H16Mr,
		HardwareProfile_VmSize_Standard_H16R,
		HardwareProfile_VmSize_Standard_H8,
		HardwareProfile_VmSize_Standard_H8M,
		HardwareProfile_VmSize_Standard_L16S,
		HardwareProfile_VmSize_Standard_L32S,
		HardwareProfile_VmSize_Standard_L4S,
		HardwareProfile_VmSize_Standard_L8S,
		HardwareProfile_VmSize_Standard_M12832Ms,
		HardwareProfile_VmSize_Standard_M12864Ms,
		HardwareProfile_VmSize_Standard_M128Ms,
		HardwareProfile_VmSize_Standard_M128S,
		HardwareProfile_VmSize_Standard_M6416Ms,
		HardwareProfile_VmSize_Standard_M6432Ms,
		HardwareProfile_VmSize_Standard_M64Ms,
		HardwareProfile_VmSize_Standard_M64S,
		HardwareProfile_VmSize_Standard_NC12,
		HardwareProfile_VmSize_Standard_NC12S_V2,
		HardwareProfile_VmSize_Standard_NC12S_V3,
		HardwareProfile_VmSize_Standard_NC24,
		HardwareProfile_VmSize_Standard_NC24R,
		HardwareProfile_VmSize_Standard_NC24Rs_V2,
		HardwareProfile_VmSize_Standard_NC24Rs_V3,
		HardwareProfile_VmSize_Standard_NC24S_V2,
		HardwareProfile_VmSize_Standard_NC24S_V3,
		HardwareProfile_VmSize_Standard_NC6,
		HardwareProfile_VmSize_Standard_NC6S_V2,
		HardwareProfile_VmSize_Standard_NC6S_V3,
		HardwareProfile_VmSize_Standard_ND12S,
		HardwareProfile_VmSize_Standard_ND24Rs,
		HardwareProfile_VmSize_Standard_ND24S,
		HardwareProfile_VmSize_Standard_ND6S,
		HardwareProfile_VmSize_Standard_NV12,
		HardwareProfile_VmSize_Standard_NV24,
		HardwareProfile_VmSize_Standard_NV6))
}

// AddRelatedPropertyGeneratorsForHardwareProfileARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForHardwareProfileARM(gens map[string]gopter.Gen) {
	gens["VmSizeProperties"] = gen.PtrOf(VMSizePropertiesARMGenerator())
}

func Test_NetworkProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkProfileARM, NetworkProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkProfileARM runs a test to see if a specific instance of NetworkProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkProfileARM(subject NetworkProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkProfileARM instances for property testing - lazily instantiated by NetworkProfileARMGenerator()
var networkProfileARMGenerator gopter.Gen

// NetworkProfileARMGenerator returns a generator of NetworkProfileARM instances for property testing.
// We first initialize networkProfileARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkProfileARMGenerator() gopter.Gen {
	if networkProfileARMGenerator != nil {
		return networkProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkProfileARM(generators)
	networkProfileARMGenerator = gen.Struct(reflect.TypeOf(NetworkProfileARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkProfileARM(generators)
	AddRelatedPropertyGeneratorsForNetworkProfileARM(generators)
	networkProfileARMGenerator = gen.Struct(reflect.TypeOf(NetworkProfileARM{}), generators)

	return networkProfileARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkProfileARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkProfileARM(gens map[string]gopter.Gen) {
	gens["NetworkApiVersion"] = gen.PtrOf(gen.OneConstOf(NetworkProfile_NetworkApiVersion_20201101))
}

// AddRelatedPropertyGeneratorsForNetworkProfileARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkProfileARM(gens map[string]gopter.Gen) {
	gens["NetworkInterfaceConfigurations"] = gen.SliceOf(VirtualMachineNetworkInterfaceConfigurationARMGenerator())
	gens["NetworkInterfaces"] = gen.SliceOf(NetworkInterfaceReferenceARMGenerator())
}

func Test_OSProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OSProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOSProfileARM, OSProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOSProfileARM runs a test to see if a specific instance of OSProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOSProfileARM(subject OSProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OSProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OSProfileARM instances for property testing - lazily instantiated by OSProfileARMGenerator()
var osProfileARMGenerator gopter.Gen

// OSProfileARMGenerator returns a generator of OSProfileARM instances for property testing.
// We first initialize osProfileARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OSProfileARMGenerator() gopter.Gen {
	if osProfileARMGenerator != nil {
		return osProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSProfileARM(generators)
	osProfileARMGenerator = gen.Struct(reflect.TypeOf(OSProfileARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSProfileARM(generators)
	AddRelatedPropertyGeneratorsForOSProfileARM(generators)
	osProfileARMGenerator = gen.Struct(reflect.TypeOf(OSProfileARM{}), generators)

	return osProfileARMGenerator
}

// AddIndependentPropertyGeneratorsForOSProfileARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOSProfileARM(gens map[string]gopter.Gen) {
	gens["AdminPassword"] = gen.PtrOf(gen.AlphaString())
	gens["AdminUsername"] = gen.PtrOf(gen.AlphaString())
	gens["AllowExtensionOperations"] = gen.PtrOf(gen.Bool())
	gens["ComputerName"] = gen.PtrOf(gen.AlphaString())
	gens["CustomData"] = gen.PtrOf(gen.AlphaString())
	gens["RequireGuestProvisionSignal"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForOSProfileARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOSProfileARM(gens map[string]gopter.Gen) {
	gens["LinuxConfiguration"] = gen.PtrOf(LinuxConfigurationARMGenerator())
	gens["Secrets"] = gen.SliceOf(VaultSecretGroupARMGenerator())
	gens["WindowsConfiguration"] = gen.PtrOf(WindowsConfigurationARMGenerator())
}

func Test_ScheduledEventsProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ScheduledEventsProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForScheduledEventsProfileARM, ScheduledEventsProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForScheduledEventsProfileARM runs a test to see if a specific instance of ScheduledEventsProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForScheduledEventsProfileARM(subject ScheduledEventsProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ScheduledEventsProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ScheduledEventsProfileARM instances for property testing - lazily instantiated by
// ScheduledEventsProfileARMGenerator()
var scheduledEventsProfileARMGenerator gopter.Gen

// ScheduledEventsProfileARMGenerator returns a generator of ScheduledEventsProfileARM instances for property testing.
func ScheduledEventsProfileARMGenerator() gopter.Gen {
	if scheduledEventsProfileARMGenerator != nil {
		return scheduledEventsProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForScheduledEventsProfileARM(generators)
	scheduledEventsProfileARMGenerator = gen.Struct(reflect.TypeOf(ScheduledEventsProfileARM{}), generators)

	return scheduledEventsProfileARMGenerator
}

// AddRelatedPropertyGeneratorsForScheduledEventsProfileARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForScheduledEventsProfileARM(gens map[string]gopter.Gen) {
	gens["TerminateNotificationProfile"] = gen.PtrOf(TerminateNotificationProfileARMGenerator())
}

func Test_SecurityProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SecurityProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSecurityProfileARM, SecurityProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSecurityProfileARM runs a test to see if a specific instance of SecurityProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSecurityProfileARM(subject SecurityProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SecurityProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SecurityProfileARM instances for property testing - lazily instantiated by SecurityProfileARMGenerator()
var securityProfileARMGenerator gopter.Gen

// SecurityProfileARMGenerator returns a generator of SecurityProfileARM instances for property testing.
// We first initialize securityProfileARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SecurityProfileARMGenerator() gopter.Gen {
	if securityProfileARMGenerator != nil {
		return securityProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecurityProfileARM(generators)
	securityProfileARMGenerator = gen.Struct(reflect.TypeOf(SecurityProfileARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecurityProfileARM(generators)
	AddRelatedPropertyGeneratorsForSecurityProfileARM(generators)
	securityProfileARMGenerator = gen.Struct(reflect.TypeOf(SecurityProfileARM{}), generators)

	return securityProfileARMGenerator
}

// AddIndependentPropertyGeneratorsForSecurityProfileARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSecurityProfileARM(gens map[string]gopter.Gen) {
	gens["EncryptionAtHost"] = gen.PtrOf(gen.Bool())
	gens["SecurityType"] = gen.PtrOf(gen.OneConstOf(SecurityProfile_SecurityType_ConfidentialVM, SecurityProfile_SecurityType_TrustedLaunch))
}

// AddRelatedPropertyGeneratorsForSecurityProfileARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSecurityProfileARM(gens map[string]gopter.Gen) {
	gens["UefiSettings"] = gen.PtrOf(UefiSettingsARMGenerator())
}

func Test_StorageProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageProfileARM, StorageProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageProfileARM runs a test to see if a specific instance of StorageProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageProfileARM(subject StorageProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageProfileARM instances for property testing - lazily instantiated by StorageProfileARMGenerator()
var storageProfileARMGenerator gopter.Gen

// StorageProfileARMGenerator returns a generator of StorageProfileARM instances for property testing.
func StorageProfileARMGenerator() gopter.Gen {
	if storageProfileARMGenerator != nil {
		return storageProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForStorageProfileARM(generators)
	storageProfileARMGenerator = gen.Struct(reflect.TypeOf(StorageProfileARM{}), generators)

	return storageProfileARMGenerator
}

// AddRelatedPropertyGeneratorsForStorageProfileARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageProfileARM(gens map[string]gopter.Gen) {
	gens["DataDisks"] = gen.SliceOf(DataDiskARMGenerator())
	gens["ImageReference"] = gen.PtrOf(ImageReferenceARMGenerator())
	gens["OsDisk"] = gen.PtrOf(OSDiskARMGenerator())
}

func Test_BootDiagnosticsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BootDiagnosticsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBootDiagnosticsARM, BootDiagnosticsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBootDiagnosticsARM runs a test to see if a specific instance of BootDiagnosticsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBootDiagnosticsARM(subject BootDiagnosticsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BootDiagnosticsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BootDiagnosticsARM instances for property testing - lazily instantiated by BootDiagnosticsARMGenerator()
var bootDiagnosticsARMGenerator gopter.Gen

// BootDiagnosticsARMGenerator returns a generator of BootDiagnosticsARM instances for property testing.
func BootDiagnosticsARMGenerator() gopter.Gen {
	if bootDiagnosticsARMGenerator != nil {
		return bootDiagnosticsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBootDiagnosticsARM(generators)
	bootDiagnosticsARMGenerator = gen.Struct(reflect.TypeOf(BootDiagnosticsARM{}), generators)

	return bootDiagnosticsARMGenerator
}

// AddIndependentPropertyGeneratorsForBootDiagnosticsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBootDiagnosticsARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["StorageUri"] = gen.PtrOf(gen.AlphaString())
}

func Test_DataDiskARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataDiskARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataDiskARM, DataDiskARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataDiskARM runs a test to see if a specific instance of DataDiskARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDataDiskARM(subject DataDiskARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataDiskARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataDiskARM instances for property testing - lazily instantiated by DataDiskARMGenerator()
var dataDiskARMGenerator gopter.Gen

// DataDiskARMGenerator returns a generator of DataDiskARM instances for property testing.
// We first initialize dataDiskARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DataDiskARMGenerator() gopter.Gen {
	if dataDiskARMGenerator != nil {
		return dataDiskARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataDiskARM(generators)
	dataDiskARMGenerator = gen.Struct(reflect.TypeOf(DataDiskARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataDiskARM(generators)
	AddRelatedPropertyGeneratorsForDataDiskARM(generators)
	dataDiskARMGenerator = gen.Struct(reflect.TypeOf(DataDiskARM{}), generators)

	return dataDiskARMGenerator
}

// AddIndependentPropertyGeneratorsForDataDiskARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDataDiskARM(gens map[string]gopter.Gen) {
	gens["Caching"] = gen.PtrOf(gen.OneConstOf(Caching_None, Caching_ReadOnly, Caching_ReadWrite))
	gens["CreateOption"] = gen.PtrOf(gen.OneConstOf(CreateOption_Attach, CreateOption_Empty, CreateOption_FromImage))
	gens["DeleteOption"] = gen.PtrOf(gen.OneConstOf(DeleteOption_Delete, DeleteOption_Detach))
	gens["DetachOption"] = gen.PtrOf(gen.OneConstOf(DetachOption_ForceDetach))
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["Lun"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ToBeDetached"] = gen.PtrOf(gen.Bool())
	gens["WriteAcceleratorEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForDataDiskARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataDiskARM(gens map[string]gopter.Gen) {
	gens["Image"] = gen.PtrOf(VirtualHardDiskARMGenerator())
	gens["ManagedDisk"] = gen.PtrOf(ManagedDiskParametersARMGenerator())
	gens["Vhd"] = gen.PtrOf(VirtualHardDiskARMGenerator())
}

func Test_ImageReferenceARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ImageReferenceARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForImageReferenceARM, ImageReferenceARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForImageReferenceARM runs a test to see if a specific instance of ImageReferenceARM round trips to JSON and back losslessly
func RunJSONSerializationTestForImageReferenceARM(subject ImageReferenceARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ImageReferenceARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ImageReferenceARM instances for property testing - lazily instantiated by ImageReferenceARMGenerator()
var imageReferenceARMGenerator gopter.Gen

// ImageReferenceARMGenerator returns a generator of ImageReferenceARM instances for property testing.
func ImageReferenceARMGenerator() gopter.Gen {
	if imageReferenceARMGenerator != nil {
		return imageReferenceARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForImageReferenceARM(generators)
	imageReferenceARMGenerator = gen.Struct(reflect.TypeOf(ImageReferenceARM{}), generators)

	return imageReferenceARMGenerator
}

// AddIndependentPropertyGeneratorsForImageReferenceARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForImageReferenceARM(gens map[string]gopter.Gen) {
	gens["CommunityGalleryImageId"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Offer"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
	gens["SharedGalleryImageId"] = gen.PtrOf(gen.AlphaString())
	gens["Sku"] = gen.PtrOf(gen.AlphaString())
	gens["Version"] = gen.PtrOf(gen.AlphaString())
}

func Test_LinuxConfigurationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxConfigurationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxConfigurationARM, LinuxConfigurationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxConfigurationARM runs a test to see if a specific instance of LinuxConfigurationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxConfigurationARM(subject LinuxConfigurationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxConfigurationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxConfigurationARM instances for property testing - lazily instantiated by
// LinuxConfigurationARMGenerator()
var linuxConfigurationARMGenerator gopter.Gen

// LinuxConfigurationARMGenerator returns a generator of LinuxConfigurationARM instances for property testing.
// We first initialize linuxConfigurationARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LinuxConfigurationARMGenerator() gopter.Gen {
	if linuxConfigurationARMGenerator != nil {
		return linuxConfigurationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxConfigurationARM(generators)
	linuxConfigurationARMGenerator = gen.Struct(reflect.TypeOf(LinuxConfigurationARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxConfigurationARM(generators)
	AddRelatedPropertyGeneratorsForLinuxConfigurationARM(generators)
	linuxConfigurationARMGenerator = gen.Struct(reflect.TypeOf(LinuxConfigurationARM{}), generators)

	return linuxConfigurationARMGenerator
}

// AddIndependentPropertyGeneratorsForLinuxConfigurationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxConfigurationARM(gens map[string]gopter.Gen) {
	gens["DisablePasswordAuthentication"] = gen.PtrOf(gen.Bool())
	gens["ProvisionVMAgent"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForLinuxConfigurationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLinuxConfigurationARM(gens map[string]gopter.Gen) {
	gens["PatchSettings"] = gen.PtrOf(LinuxPatchSettingsARMGenerator())
	gens["Ssh"] = gen.PtrOf(SshConfigurationARMGenerator())
}

func Test_NetworkInterfaceReferenceARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceReferenceARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceReferenceARM, NetworkInterfaceReferenceARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceReferenceARM runs a test to see if a specific instance of NetworkInterfaceReferenceARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceReferenceARM(subject NetworkInterfaceReferenceARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceReferenceARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceReferenceARM instances for property testing - lazily instantiated by
// NetworkInterfaceReferenceARMGenerator()
var networkInterfaceReferenceARMGenerator gopter.Gen

// NetworkInterfaceReferenceARMGenerator returns a generator of NetworkInterfaceReferenceARM instances for property testing.
// We first initialize networkInterfaceReferenceARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkInterfaceReferenceARMGenerator() gopter.Gen {
	if networkInterfaceReferenceARMGenerator != nil {
		return networkInterfaceReferenceARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceReferenceARM(generators)
	networkInterfaceReferenceARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceReferenceARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceReferenceARM(generators)
	AddRelatedPropertyGeneratorsForNetworkInterfaceReferenceARM(generators)
	networkInterfaceReferenceARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceReferenceARM{}), generators)

	return networkInterfaceReferenceARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceReferenceARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceReferenceARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNetworkInterfaceReferenceARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkInterfaceReferenceARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(NetworkInterfaceReferencePropertiesARMGenerator())
}

func Test_OSDiskARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OSDiskARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOSDiskARM, OSDiskARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOSDiskARM runs a test to see if a specific instance of OSDiskARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOSDiskARM(subject OSDiskARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OSDiskARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OSDiskARM instances for property testing - lazily instantiated by OSDiskARMGenerator()
var osDiskARMGenerator gopter.Gen

// OSDiskARMGenerator returns a generator of OSDiskARM instances for property testing.
// We first initialize osDiskARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OSDiskARMGenerator() gopter.Gen {
	if osDiskARMGenerator != nil {
		return osDiskARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSDiskARM(generators)
	osDiskARMGenerator = gen.Struct(reflect.TypeOf(OSDiskARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSDiskARM(generators)
	AddRelatedPropertyGeneratorsForOSDiskARM(generators)
	osDiskARMGenerator = gen.Struct(reflect.TypeOf(OSDiskARM{}), generators)

	return osDiskARMGenerator
}

// AddIndependentPropertyGeneratorsForOSDiskARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOSDiskARM(gens map[string]gopter.Gen) {
	gens["Caching"] = gen.PtrOf(gen.OneConstOf(Caching_None, Caching_ReadOnly, Caching_ReadWrite))
	gens["CreateOption"] = gen.PtrOf(gen.OneConstOf(CreateOption_Attach, CreateOption_Empty, CreateOption_FromImage))
	gens["DeleteOption"] = gen.PtrOf(gen.OneConstOf(DeleteOption_Delete, DeleteOption_Detach))
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["OsType"] = gen.PtrOf(gen.OneConstOf(OSDisk_OsType_Linux, OSDisk_OsType_Windows))
	gens["WriteAcceleratorEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForOSDiskARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOSDiskARM(gens map[string]gopter.Gen) {
	gens["DiffDiskSettings"] = gen.PtrOf(DiffDiskSettingsARMGenerator())
	gens["EncryptionSettings"] = gen.PtrOf(DiskEncryptionSettingsARMGenerator())
	gens["Image"] = gen.PtrOf(VirtualHardDiskARMGenerator())
	gens["ManagedDisk"] = gen.PtrOf(ManagedDiskParametersARMGenerator())
	gens["Vhd"] = gen.PtrOf(VirtualHardDiskARMGenerator())
}

func Test_TerminateNotificationProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TerminateNotificationProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTerminateNotificationProfileARM, TerminateNotificationProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTerminateNotificationProfileARM runs a test to see if a specific instance of TerminateNotificationProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForTerminateNotificationProfileARM(subject TerminateNotificationProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TerminateNotificationProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TerminateNotificationProfileARM instances for property testing - lazily instantiated by
// TerminateNotificationProfileARMGenerator()
var terminateNotificationProfileARMGenerator gopter.Gen

// TerminateNotificationProfileARMGenerator returns a generator of TerminateNotificationProfileARM instances for property testing.
func TerminateNotificationProfileARMGenerator() gopter.Gen {
	if terminateNotificationProfileARMGenerator != nil {
		return terminateNotificationProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTerminateNotificationProfileARM(generators)
	terminateNotificationProfileARMGenerator = gen.Struct(reflect.TypeOf(TerminateNotificationProfileARM{}), generators)

	return terminateNotificationProfileARMGenerator
}

// AddIndependentPropertyGeneratorsForTerminateNotificationProfileARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTerminateNotificationProfileARM(gens map[string]gopter.Gen) {
	gens["Enable"] = gen.PtrOf(gen.Bool())
	gens["NotBeforeTimeout"] = gen.PtrOf(gen.AlphaString())
}

func Test_UefiSettingsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UefiSettingsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUefiSettingsARM, UefiSettingsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUefiSettingsARM runs a test to see if a specific instance of UefiSettingsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUefiSettingsARM(subject UefiSettingsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UefiSettingsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UefiSettingsARM instances for property testing - lazily instantiated by UefiSettingsARMGenerator()
var uefiSettingsARMGenerator gopter.Gen

// UefiSettingsARMGenerator returns a generator of UefiSettingsARM instances for property testing.
func UefiSettingsARMGenerator() gopter.Gen {
	if uefiSettingsARMGenerator != nil {
		return uefiSettingsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUefiSettingsARM(generators)
	uefiSettingsARMGenerator = gen.Struct(reflect.TypeOf(UefiSettingsARM{}), generators)

	return uefiSettingsARMGenerator
}

// AddIndependentPropertyGeneratorsForUefiSettingsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUefiSettingsARM(gens map[string]gopter.Gen) {
	gens["SecureBootEnabled"] = gen.PtrOf(gen.Bool())
	gens["VTpmEnabled"] = gen.PtrOf(gen.Bool())
}

func Test_VaultSecretGroupARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultSecretGroupARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultSecretGroupARM, VaultSecretGroupARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultSecretGroupARM runs a test to see if a specific instance of VaultSecretGroupARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultSecretGroupARM(subject VaultSecretGroupARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultSecretGroupARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultSecretGroupARM instances for property testing - lazily instantiated by
// VaultSecretGroupARMGenerator()
var vaultSecretGroupARMGenerator gopter.Gen

// VaultSecretGroupARMGenerator returns a generator of VaultSecretGroupARM instances for property testing.
func VaultSecretGroupARMGenerator() gopter.Gen {
	if vaultSecretGroupARMGenerator != nil {
		return vaultSecretGroupARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVaultSecretGroupARM(generators)
	vaultSecretGroupARMGenerator = gen.Struct(reflect.TypeOf(VaultSecretGroupARM{}), generators)

	return vaultSecretGroupARMGenerator
}

// AddRelatedPropertyGeneratorsForVaultSecretGroupARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVaultSecretGroupARM(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SubResourceARMGenerator())
	gens["VaultCertificates"] = gen.SliceOf(VaultCertificateARMGenerator())
}

func Test_VirtualMachineNetworkInterfaceConfigurationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineNetworkInterfaceConfigurationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineNetworkInterfaceConfigurationARM, VirtualMachineNetworkInterfaceConfigurationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineNetworkInterfaceConfigurationARM runs a test to see if a specific instance of VirtualMachineNetworkInterfaceConfigurationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineNetworkInterfaceConfigurationARM(subject VirtualMachineNetworkInterfaceConfigurationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineNetworkInterfaceConfigurationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineNetworkInterfaceConfigurationARM instances for property testing - lazily instantiated by
// VirtualMachineNetworkInterfaceConfigurationARMGenerator()
var virtualMachineNetworkInterfaceConfigurationARMGenerator gopter.Gen

// VirtualMachineNetworkInterfaceConfigurationARMGenerator returns a generator of VirtualMachineNetworkInterfaceConfigurationARM instances for property testing.
// We first initialize virtualMachineNetworkInterfaceConfigurationARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineNetworkInterfaceConfigurationARMGenerator() gopter.Gen {
	if virtualMachineNetworkInterfaceConfigurationARMGenerator != nil {
		return virtualMachineNetworkInterfaceConfigurationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineNetworkInterfaceConfigurationARM(generators)
	virtualMachineNetworkInterfaceConfigurationARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineNetworkInterfaceConfigurationARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineNetworkInterfaceConfigurationARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineNetworkInterfaceConfigurationARM(generators)
	virtualMachineNetworkInterfaceConfigurationARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineNetworkInterfaceConfigurationARM{}), generators)

	return virtualMachineNetworkInterfaceConfigurationARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineNetworkInterfaceConfigurationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineNetworkInterfaceConfigurationARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineNetworkInterfaceConfigurationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineNetworkInterfaceConfigurationARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(VirtualMachineNetworkInterfaceConfigurationPropertiesARMGenerator())
}

func Test_VMGalleryApplicationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VMGalleryApplicationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVMGalleryApplicationARM, VMGalleryApplicationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVMGalleryApplicationARM runs a test to see if a specific instance of VMGalleryApplicationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVMGalleryApplicationARM(subject VMGalleryApplicationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VMGalleryApplicationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VMGalleryApplicationARM instances for property testing - lazily instantiated by
// VMGalleryApplicationARMGenerator()
var vmGalleryApplicationARMGenerator gopter.Gen

// VMGalleryApplicationARMGenerator returns a generator of VMGalleryApplicationARM instances for property testing.
func VMGalleryApplicationARMGenerator() gopter.Gen {
	if vmGalleryApplicationARMGenerator != nil {
		return vmGalleryApplicationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVMGalleryApplicationARM(generators)
	vmGalleryApplicationARMGenerator = gen.Struct(reflect.TypeOf(VMGalleryApplicationARM{}), generators)

	return vmGalleryApplicationARMGenerator
}

// AddIndependentPropertyGeneratorsForVMGalleryApplicationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVMGalleryApplicationARM(gens map[string]gopter.Gen) {
	gens["ConfigurationReference"] = gen.PtrOf(gen.AlphaString())
	gens["EnableAutomaticUpgrade"] = gen.PtrOf(gen.Bool())
	gens["Order"] = gen.PtrOf(gen.Int())
	gens["PackageReferenceId"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.PtrOf(gen.AlphaString())
	gens["TreatFailureAsDeploymentFailure"] = gen.PtrOf(gen.Bool())
}

func Test_VMSizePropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VMSizePropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVMSizePropertiesARM, VMSizePropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVMSizePropertiesARM runs a test to see if a specific instance of VMSizePropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVMSizePropertiesARM(subject VMSizePropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VMSizePropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VMSizePropertiesARM instances for property testing - lazily instantiated by
// VMSizePropertiesARMGenerator()
var vmSizePropertiesARMGenerator gopter.Gen

// VMSizePropertiesARMGenerator returns a generator of VMSizePropertiesARM instances for property testing.
func VMSizePropertiesARMGenerator() gopter.Gen {
	if vmSizePropertiesARMGenerator != nil {
		return vmSizePropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVMSizePropertiesARM(generators)
	vmSizePropertiesARMGenerator = gen.Struct(reflect.TypeOf(VMSizePropertiesARM{}), generators)

	return vmSizePropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForVMSizePropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVMSizePropertiesARM(gens map[string]gopter.Gen) {
	gens["VCPUsAvailable"] = gen.PtrOf(gen.Int())
	gens["VCPUsPerCore"] = gen.PtrOf(gen.Int())
}

func Test_WindowsConfigurationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WindowsConfigurationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWindowsConfigurationARM, WindowsConfigurationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWindowsConfigurationARM runs a test to see if a specific instance of WindowsConfigurationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWindowsConfigurationARM(subject WindowsConfigurationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WindowsConfigurationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WindowsConfigurationARM instances for property testing - lazily instantiated by
// WindowsConfigurationARMGenerator()
var windowsConfigurationARMGenerator gopter.Gen

// WindowsConfigurationARMGenerator returns a generator of WindowsConfigurationARM instances for property testing.
// We first initialize windowsConfigurationARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WindowsConfigurationARMGenerator() gopter.Gen {
	if windowsConfigurationARMGenerator != nil {
		return windowsConfigurationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsConfigurationARM(generators)
	windowsConfigurationARMGenerator = gen.Struct(reflect.TypeOf(WindowsConfigurationARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsConfigurationARM(generators)
	AddRelatedPropertyGeneratorsForWindowsConfigurationARM(generators)
	windowsConfigurationARMGenerator = gen.Struct(reflect.TypeOf(WindowsConfigurationARM{}), generators)

	return windowsConfigurationARMGenerator
}

// AddIndependentPropertyGeneratorsForWindowsConfigurationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWindowsConfigurationARM(gens map[string]gopter.Gen) {
	gens["EnableAutomaticUpdates"] = gen.PtrOf(gen.Bool())
	gens["ProvisionVMAgent"] = gen.PtrOf(gen.Bool())
	gens["TimeZone"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForWindowsConfigurationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWindowsConfigurationARM(gens map[string]gopter.Gen) {
	gens["AdditionalUnattendContent"] = gen.SliceOf(AdditionalUnattendContentARMGenerator())
	gens["PatchSettings"] = gen.PtrOf(PatchSettingsARMGenerator())
	gens["WinRM"] = gen.PtrOf(WinRMConfigurationARMGenerator())
}

func Test_AdditionalUnattendContentARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdditionalUnattendContentARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdditionalUnattendContentARM, AdditionalUnattendContentARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdditionalUnattendContentARM runs a test to see if a specific instance of AdditionalUnattendContentARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAdditionalUnattendContentARM(subject AdditionalUnattendContentARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdditionalUnattendContentARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdditionalUnattendContentARM instances for property testing - lazily instantiated by
// AdditionalUnattendContentARMGenerator()
var additionalUnattendContentARMGenerator gopter.Gen

// AdditionalUnattendContentARMGenerator returns a generator of AdditionalUnattendContentARM instances for property testing.
func AdditionalUnattendContentARMGenerator() gopter.Gen {
	if additionalUnattendContentARMGenerator != nil {
		return additionalUnattendContentARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdditionalUnattendContentARM(generators)
	additionalUnattendContentARMGenerator = gen.Struct(reflect.TypeOf(AdditionalUnattendContentARM{}), generators)

	return additionalUnattendContentARMGenerator
}

// AddIndependentPropertyGeneratorsForAdditionalUnattendContentARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdditionalUnattendContentARM(gens map[string]gopter.Gen) {
	gens["ComponentName"] = gen.PtrOf(gen.OneConstOf(AdditionalUnattendContent_ComponentName_MicrosoftWindowsShellSetup))
	gens["Content"] = gen.PtrOf(gen.AlphaString())
	gens["PassName"] = gen.PtrOf(gen.OneConstOf(AdditionalUnattendContent_PassName_OobeSystem))
	gens["SettingName"] = gen.PtrOf(gen.OneConstOf(AdditionalUnattendContent_SettingName_AutoLogon, AdditionalUnattendContent_SettingName_FirstLogonCommands))
}

func Test_DiffDiskSettingsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiffDiskSettingsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiffDiskSettingsARM, DiffDiskSettingsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiffDiskSettingsARM runs a test to see if a specific instance of DiffDiskSettingsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiffDiskSettingsARM(subject DiffDiskSettingsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiffDiskSettingsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiffDiskSettingsARM instances for property testing - lazily instantiated by
// DiffDiskSettingsARMGenerator()
var diffDiskSettingsARMGenerator gopter.Gen

// DiffDiskSettingsARMGenerator returns a generator of DiffDiskSettingsARM instances for property testing.
func DiffDiskSettingsARMGenerator() gopter.Gen {
	if diffDiskSettingsARMGenerator != nil {
		return diffDiskSettingsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiffDiskSettingsARM(generators)
	diffDiskSettingsARMGenerator = gen.Struct(reflect.TypeOf(DiffDiskSettingsARM{}), generators)

	return diffDiskSettingsARMGenerator
}

// AddIndependentPropertyGeneratorsForDiffDiskSettingsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiffDiskSettingsARM(gens map[string]gopter.Gen) {
	gens["Option"] = gen.PtrOf(gen.OneConstOf(DiffDiskOption_Local))
	gens["Placement"] = gen.PtrOf(gen.OneConstOf(DiffDiskPlacement_CacheDisk, DiffDiskPlacement_ResourceDisk))
}

func Test_DiskEncryptionSettingsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiskEncryptionSettingsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskEncryptionSettingsARM, DiskEncryptionSettingsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskEncryptionSettingsARM runs a test to see if a specific instance of DiskEncryptionSettingsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskEncryptionSettingsARM(subject DiskEncryptionSettingsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiskEncryptionSettingsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiskEncryptionSettingsARM instances for property testing - lazily instantiated by
// DiskEncryptionSettingsARMGenerator()
var diskEncryptionSettingsARMGenerator gopter.Gen

// DiskEncryptionSettingsARMGenerator returns a generator of DiskEncryptionSettingsARM instances for property testing.
// We first initialize diskEncryptionSettingsARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DiskEncryptionSettingsARMGenerator() gopter.Gen {
	if diskEncryptionSettingsARMGenerator != nil {
		return diskEncryptionSettingsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskEncryptionSettingsARM(generators)
	diskEncryptionSettingsARMGenerator = gen.Struct(reflect.TypeOf(DiskEncryptionSettingsARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskEncryptionSettingsARM(generators)
	AddRelatedPropertyGeneratorsForDiskEncryptionSettingsARM(generators)
	diskEncryptionSettingsARMGenerator = gen.Struct(reflect.TypeOf(DiskEncryptionSettingsARM{}), generators)

	return diskEncryptionSettingsARMGenerator
}

// AddIndependentPropertyGeneratorsForDiskEncryptionSettingsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskEncryptionSettingsARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForDiskEncryptionSettingsARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiskEncryptionSettingsARM(gens map[string]gopter.Gen) {
	gens["DiskEncryptionKey"] = gen.PtrOf(KeyVaultSecretReferenceARMGenerator())
	gens["KeyEncryptionKey"] = gen.PtrOf(KeyVaultKeyReferenceARMGenerator())
}

func Test_LinuxPatchSettingsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxPatchSettingsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxPatchSettingsARM, LinuxPatchSettingsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxPatchSettingsARM runs a test to see if a specific instance of LinuxPatchSettingsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxPatchSettingsARM(subject LinuxPatchSettingsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxPatchSettingsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxPatchSettingsARM instances for property testing - lazily instantiated by
// LinuxPatchSettingsARMGenerator()
var linuxPatchSettingsARMGenerator gopter.Gen

// LinuxPatchSettingsARMGenerator returns a generator of LinuxPatchSettingsARM instances for property testing.
// We first initialize linuxPatchSettingsARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LinuxPatchSettingsARMGenerator() gopter.Gen {
	if linuxPatchSettingsARMGenerator != nil {
		return linuxPatchSettingsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxPatchSettingsARM(generators)
	linuxPatchSettingsARMGenerator = gen.Struct(reflect.TypeOf(LinuxPatchSettingsARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxPatchSettingsARM(generators)
	AddRelatedPropertyGeneratorsForLinuxPatchSettingsARM(generators)
	linuxPatchSettingsARMGenerator = gen.Struct(reflect.TypeOf(LinuxPatchSettingsARM{}), generators)

	return linuxPatchSettingsARMGenerator
}

// AddIndependentPropertyGeneratorsForLinuxPatchSettingsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxPatchSettingsARM(gens map[string]gopter.Gen) {
	gens["AssessmentMode"] = gen.PtrOf(gen.OneConstOf(LinuxPatchSettings_AssessmentMode_AutomaticByPlatform, LinuxPatchSettings_AssessmentMode_ImageDefault))
	gens["PatchMode"] = gen.PtrOf(gen.OneConstOf(LinuxPatchSettings_PatchMode_AutomaticByPlatform, LinuxPatchSettings_PatchMode_ImageDefault))
}

// AddRelatedPropertyGeneratorsForLinuxPatchSettingsARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLinuxPatchSettingsARM(gens map[string]gopter.Gen) {
	gens["AutomaticByPlatformSettings"] = gen.PtrOf(LinuxVMGuestPatchAutomaticByPlatformSettingsARMGenerator())
}

func Test_ManagedDiskParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedDiskParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedDiskParametersARM, ManagedDiskParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedDiskParametersARM runs a test to see if a specific instance of ManagedDiskParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedDiskParametersARM(subject ManagedDiskParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedDiskParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedDiskParametersARM instances for property testing - lazily instantiated by
// ManagedDiskParametersARMGenerator()
var managedDiskParametersARMGenerator gopter.Gen

// ManagedDiskParametersARMGenerator returns a generator of ManagedDiskParametersARM instances for property testing.
// We first initialize managedDiskParametersARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedDiskParametersARMGenerator() gopter.Gen {
	if managedDiskParametersARMGenerator != nil {
		return managedDiskParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedDiskParametersARM(generators)
	managedDiskParametersARMGenerator = gen.Struct(reflect.TypeOf(ManagedDiskParametersARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedDiskParametersARM(generators)
	AddRelatedPropertyGeneratorsForManagedDiskParametersARM(generators)
	managedDiskParametersARMGenerator = gen.Struct(reflect.TypeOf(ManagedDiskParametersARM{}), generators)

	return managedDiskParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedDiskParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedDiskParametersARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountType"] = gen.PtrOf(gen.OneConstOf(
		StorageAccountType_PremiumV2_LRS,
		StorageAccountType_Premium_LRS,
		StorageAccountType_Premium_ZRS,
		StorageAccountType_StandardSSD_LRS,
		StorageAccountType_StandardSSD_ZRS,
		StorageAccountType_Standard_LRS,
		StorageAccountType_UltraSSD_LRS))
}

// AddRelatedPropertyGeneratorsForManagedDiskParametersARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedDiskParametersARM(gens map[string]gopter.Gen) {
	gens["DiskEncryptionSet"] = gen.PtrOf(SubResourceARMGenerator())
	gens["SecurityProfile"] = gen.PtrOf(VMDiskSecurityProfileARMGenerator())
}

func Test_NetworkInterfaceReferencePropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceReferencePropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceReferencePropertiesARM, NetworkInterfaceReferencePropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceReferencePropertiesARM runs a test to see if a specific instance of NetworkInterfaceReferencePropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceReferencePropertiesARM(subject NetworkInterfaceReferencePropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceReferencePropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceReferencePropertiesARM instances for property testing - lazily instantiated by
// NetworkInterfaceReferencePropertiesARMGenerator()
var networkInterfaceReferencePropertiesARMGenerator gopter.Gen

// NetworkInterfaceReferencePropertiesARMGenerator returns a generator of NetworkInterfaceReferencePropertiesARM instances for property testing.
func NetworkInterfaceReferencePropertiesARMGenerator() gopter.Gen {
	if networkInterfaceReferencePropertiesARMGenerator != nil {
		return networkInterfaceReferencePropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceReferencePropertiesARM(generators)
	networkInterfaceReferencePropertiesARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceReferencePropertiesARM{}), generators)

	return networkInterfaceReferencePropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceReferencePropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceReferencePropertiesARM(gens map[string]gopter.Gen) {
	gens["DeleteOption"] = gen.PtrOf(gen.OneConstOf(NetworkInterfaceReferenceProperties_DeleteOption_Delete, NetworkInterfaceReferenceProperties_DeleteOption_Detach))
	gens["Primary"] = gen.PtrOf(gen.Bool())
}

func Test_PatchSettingsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PatchSettingsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPatchSettingsARM, PatchSettingsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPatchSettingsARM runs a test to see if a specific instance of PatchSettingsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPatchSettingsARM(subject PatchSettingsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PatchSettingsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PatchSettingsARM instances for property testing - lazily instantiated by PatchSettingsARMGenerator()
var patchSettingsARMGenerator gopter.Gen

// PatchSettingsARMGenerator returns a generator of PatchSettingsARM instances for property testing.
// We first initialize patchSettingsARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PatchSettingsARMGenerator() gopter.Gen {
	if patchSettingsARMGenerator != nil {
		return patchSettingsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPatchSettingsARM(generators)
	patchSettingsARMGenerator = gen.Struct(reflect.TypeOf(PatchSettingsARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPatchSettingsARM(generators)
	AddRelatedPropertyGeneratorsForPatchSettingsARM(generators)
	patchSettingsARMGenerator = gen.Struct(reflect.TypeOf(PatchSettingsARM{}), generators)

	return patchSettingsARMGenerator
}

// AddIndependentPropertyGeneratorsForPatchSettingsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPatchSettingsARM(gens map[string]gopter.Gen) {
	gens["AssessmentMode"] = gen.PtrOf(gen.OneConstOf(PatchSettings_AssessmentMode_AutomaticByPlatform, PatchSettings_AssessmentMode_ImageDefault))
	gens["EnableHotpatching"] = gen.PtrOf(gen.Bool())
	gens["PatchMode"] = gen.PtrOf(gen.OneConstOf(PatchSettings_PatchMode_AutomaticByOS, PatchSettings_PatchMode_AutomaticByPlatform, PatchSettings_PatchMode_Manual))
}

// AddRelatedPropertyGeneratorsForPatchSettingsARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPatchSettingsARM(gens map[string]gopter.Gen) {
	gens["AutomaticByPlatformSettings"] = gen.PtrOf(WindowsVMGuestPatchAutomaticByPlatformSettingsARMGenerator())
}

func Test_SshConfigurationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SshConfigurationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSshConfigurationARM, SshConfigurationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSshConfigurationARM runs a test to see if a specific instance of SshConfigurationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSshConfigurationARM(subject SshConfigurationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SshConfigurationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SshConfigurationARM instances for property testing - lazily instantiated by
// SshConfigurationARMGenerator()
var sshConfigurationARMGenerator gopter.Gen

// SshConfigurationARMGenerator returns a generator of SshConfigurationARM instances for property testing.
func SshConfigurationARMGenerator() gopter.Gen {
	if sshConfigurationARMGenerator != nil {
		return sshConfigurationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForSshConfigurationARM(generators)
	sshConfigurationARMGenerator = gen.Struct(reflect.TypeOf(SshConfigurationARM{}), generators)

	return sshConfigurationARMGenerator
}

// AddRelatedPropertyGeneratorsForSshConfigurationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSshConfigurationARM(gens map[string]gopter.Gen) {
	gens["PublicKeys"] = gen.SliceOf(SshPublicKeySpecARMGenerator())
}

func Test_VaultCertificateARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultCertificateARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultCertificateARM, VaultCertificateARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultCertificateARM runs a test to see if a specific instance of VaultCertificateARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultCertificateARM(subject VaultCertificateARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultCertificateARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultCertificateARM instances for property testing - lazily instantiated by
// VaultCertificateARMGenerator()
var vaultCertificateARMGenerator gopter.Gen

// VaultCertificateARMGenerator returns a generator of VaultCertificateARM instances for property testing.
func VaultCertificateARMGenerator() gopter.Gen {
	if vaultCertificateARMGenerator != nil {
		return vaultCertificateARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVaultCertificateARM(generators)
	vaultCertificateARMGenerator = gen.Struct(reflect.TypeOf(VaultCertificateARM{}), generators)

	return vaultCertificateARMGenerator
}

// AddIndependentPropertyGeneratorsForVaultCertificateARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVaultCertificateARM(gens map[string]gopter.Gen) {
	gens["CertificateStore"] = gen.PtrOf(gen.AlphaString())
	gens["CertificateUrl"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualHardDiskARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualHardDiskARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualHardDiskARM, VirtualHardDiskARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualHardDiskARM runs a test to see if a specific instance of VirtualHardDiskARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualHardDiskARM(subject VirtualHardDiskARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualHardDiskARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualHardDiskARM instances for property testing - lazily instantiated by VirtualHardDiskARMGenerator()
var virtualHardDiskARMGenerator gopter.Gen

// VirtualHardDiskARMGenerator returns a generator of VirtualHardDiskARM instances for property testing.
func VirtualHardDiskARMGenerator() gopter.Gen {
	if virtualHardDiskARMGenerator != nil {
		return virtualHardDiskARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualHardDiskARM(generators)
	virtualHardDiskARMGenerator = gen.Struct(reflect.TypeOf(VirtualHardDiskARM{}), generators)

	return virtualHardDiskARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualHardDiskARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualHardDiskARM(gens map[string]gopter.Gen) {
	gens["Uri"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachineNetworkInterfaceConfigurationPropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineNetworkInterfaceConfigurationPropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineNetworkInterfaceConfigurationPropertiesARM, VirtualMachineNetworkInterfaceConfigurationPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineNetworkInterfaceConfigurationPropertiesARM runs a test to see if a specific instance of VirtualMachineNetworkInterfaceConfigurationPropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineNetworkInterfaceConfigurationPropertiesARM(subject VirtualMachineNetworkInterfaceConfigurationPropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineNetworkInterfaceConfigurationPropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineNetworkInterfaceConfigurationPropertiesARM instances for property testing - lazily
// instantiated by VirtualMachineNetworkInterfaceConfigurationPropertiesARMGenerator()
var virtualMachineNetworkInterfaceConfigurationPropertiesARMGenerator gopter.Gen

// VirtualMachineNetworkInterfaceConfigurationPropertiesARMGenerator returns a generator of VirtualMachineNetworkInterfaceConfigurationPropertiesARM instances for property testing.
// We first initialize virtualMachineNetworkInterfaceConfigurationPropertiesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineNetworkInterfaceConfigurationPropertiesARMGenerator() gopter.Gen {
	if virtualMachineNetworkInterfaceConfigurationPropertiesARMGenerator != nil {
		return virtualMachineNetworkInterfaceConfigurationPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineNetworkInterfaceConfigurationPropertiesARM(generators)
	virtualMachineNetworkInterfaceConfigurationPropertiesARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineNetworkInterfaceConfigurationPropertiesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineNetworkInterfaceConfigurationPropertiesARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineNetworkInterfaceConfigurationPropertiesARM(generators)
	virtualMachineNetworkInterfaceConfigurationPropertiesARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineNetworkInterfaceConfigurationPropertiesARM{}), generators)

	return virtualMachineNetworkInterfaceConfigurationPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineNetworkInterfaceConfigurationPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineNetworkInterfaceConfigurationPropertiesARM(gens map[string]gopter.Gen) {
	gens["DeleteOption"] = gen.PtrOf(gen.OneConstOf(VirtualMachineNetworkInterfaceConfigurationProperties_DeleteOption_Delete, VirtualMachineNetworkInterfaceConfigurationProperties_DeleteOption_Detach))
	gens["EnableAcceleratedNetworking"] = gen.PtrOf(gen.Bool())
	gens["EnableFpga"] = gen.PtrOf(gen.Bool())
	gens["EnableIPForwarding"] = gen.PtrOf(gen.Bool())
	gens["Primary"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForVirtualMachineNetworkInterfaceConfigurationPropertiesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineNetworkInterfaceConfigurationPropertiesARM(gens map[string]gopter.Gen) {
	gens["DnsSettings"] = gen.PtrOf(VirtualMachineNetworkInterfaceDnsSettingsConfigurationARMGenerator())
	gens["DscpConfiguration"] = gen.PtrOf(SubResourceARMGenerator())
	gens["IpConfigurations"] = gen.SliceOf(VirtualMachineNetworkInterfaceIPConfigurationARMGenerator())
	gens["NetworkSecurityGroup"] = gen.PtrOf(SubResourceARMGenerator())
}

func Test_WinRMConfigurationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WinRMConfigurationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWinRMConfigurationARM, WinRMConfigurationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWinRMConfigurationARM runs a test to see if a specific instance of WinRMConfigurationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWinRMConfigurationARM(subject WinRMConfigurationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WinRMConfigurationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WinRMConfigurationARM instances for property testing - lazily instantiated by
// WinRMConfigurationARMGenerator()
var winRMConfigurationARMGenerator gopter.Gen

// WinRMConfigurationARMGenerator returns a generator of WinRMConfigurationARM instances for property testing.
func WinRMConfigurationARMGenerator() gopter.Gen {
	if winRMConfigurationARMGenerator != nil {
		return winRMConfigurationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForWinRMConfigurationARM(generators)
	winRMConfigurationARMGenerator = gen.Struct(reflect.TypeOf(WinRMConfigurationARM{}), generators)

	return winRMConfigurationARMGenerator
}

// AddRelatedPropertyGeneratorsForWinRMConfigurationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWinRMConfigurationARM(gens map[string]gopter.Gen) {
	gens["Listeners"] = gen.SliceOf(WinRMListenerARMGenerator())
}

func Test_KeyVaultKeyReferenceARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultKeyReferenceARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultKeyReferenceARM, KeyVaultKeyReferenceARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultKeyReferenceARM runs a test to see if a specific instance of KeyVaultKeyReferenceARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultKeyReferenceARM(subject KeyVaultKeyReferenceARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultKeyReferenceARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultKeyReferenceARM instances for property testing - lazily instantiated by
// KeyVaultKeyReferenceARMGenerator()
var keyVaultKeyReferenceARMGenerator gopter.Gen

// KeyVaultKeyReferenceARMGenerator returns a generator of KeyVaultKeyReferenceARM instances for property testing.
// We first initialize keyVaultKeyReferenceARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultKeyReferenceARMGenerator() gopter.Gen {
	if keyVaultKeyReferenceARMGenerator != nil {
		return keyVaultKeyReferenceARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultKeyReferenceARM(generators)
	keyVaultKeyReferenceARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultKeyReferenceARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultKeyReferenceARM(generators)
	AddRelatedPropertyGeneratorsForKeyVaultKeyReferenceARM(generators)
	keyVaultKeyReferenceARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultKeyReferenceARM{}), generators)

	return keyVaultKeyReferenceARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultKeyReferenceARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultKeyReferenceARM(gens map[string]gopter.Gen) {
	gens["KeyUrl"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForKeyVaultKeyReferenceARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultKeyReferenceARM(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SubResourceARMGenerator())
}

func Test_KeyVaultSecretReferenceARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultSecretReferenceARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultSecretReferenceARM, KeyVaultSecretReferenceARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultSecretReferenceARM runs a test to see if a specific instance of KeyVaultSecretReferenceARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultSecretReferenceARM(subject KeyVaultSecretReferenceARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultSecretReferenceARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultSecretReferenceARM instances for property testing - lazily instantiated by
// KeyVaultSecretReferenceARMGenerator()
var keyVaultSecretReferenceARMGenerator gopter.Gen

// KeyVaultSecretReferenceARMGenerator returns a generator of KeyVaultSecretReferenceARM instances for property testing.
// We first initialize keyVaultSecretReferenceARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultSecretReferenceARMGenerator() gopter.Gen {
	if keyVaultSecretReferenceARMGenerator != nil {
		return keyVaultSecretReferenceARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultSecretReferenceARM(generators)
	keyVaultSecretReferenceARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultSecretReferenceARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultSecretReferenceARM(generators)
	AddRelatedPropertyGeneratorsForKeyVaultSecretReferenceARM(generators)
	keyVaultSecretReferenceARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultSecretReferenceARM{}), generators)

	return keyVaultSecretReferenceARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultSecretReferenceARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultSecretReferenceARM(gens map[string]gopter.Gen) {
	gens["SecretUrl"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForKeyVaultSecretReferenceARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultSecretReferenceARM(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SubResourceARMGenerator())
}

func Test_LinuxVMGuestPatchAutomaticByPlatformSettingsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxVMGuestPatchAutomaticByPlatformSettingsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxVMGuestPatchAutomaticByPlatformSettingsARM, LinuxVMGuestPatchAutomaticByPlatformSettingsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxVMGuestPatchAutomaticByPlatformSettingsARM runs a test to see if a specific instance of LinuxVMGuestPatchAutomaticByPlatformSettingsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxVMGuestPatchAutomaticByPlatformSettingsARM(subject LinuxVMGuestPatchAutomaticByPlatformSettingsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxVMGuestPatchAutomaticByPlatformSettingsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxVMGuestPatchAutomaticByPlatformSettingsARM instances for property testing - lazily instantiated by
// LinuxVMGuestPatchAutomaticByPlatformSettingsARMGenerator()
var linuxVMGuestPatchAutomaticByPlatformSettingsARMGenerator gopter.Gen

// LinuxVMGuestPatchAutomaticByPlatformSettingsARMGenerator returns a generator of LinuxVMGuestPatchAutomaticByPlatformSettingsARM instances for property testing.
func LinuxVMGuestPatchAutomaticByPlatformSettingsARMGenerator() gopter.Gen {
	if linuxVMGuestPatchAutomaticByPlatformSettingsARMGenerator != nil {
		return linuxVMGuestPatchAutomaticByPlatformSettingsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxVMGuestPatchAutomaticByPlatformSettingsARM(generators)
	linuxVMGuestPatchAutomaticByPlatformSettingsARMGenerator = gen.Struct(reflect.TypeOf(LinuxVMGuestPatchAutomaticByPlatformSettingsARM{}), generators)

	return linuxVMGuestPatchAutomaticByPlatformSettingsARMGenerator
}

// AddIndependentPropertyGeneratorsForLinuxVMGuestPatchAutomaticByPlatformSettingsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxVMGuestPatchAutomaticByPlatformSettingsARM(gens map[string]gopter.Gen) {
	gens["RebootSetting"] = gen.PtrOf(gen.OneConstOf(
		LinuxVMGuestPatchAutomaticByPlatformSettings_RebootSetting_Always,
		LinuxVMGuestPatchAutomaticByPlatformSettings_RebootSetting_IfRequired,
		LinuxVMGuestPatchAutomaticByPlatformSettings_RebootSetting_Never,
		LinuxVMGuestPatchAutomaticByPlatformSettings_RebootSetting_Unknown))
}

func Test_SshPublicKeySpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SshPublicKeySpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSshPublicKeySpecARM, SshPublicKeySpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSshPublicKeySpecARM runs a test to see if a specific instance of SshPublicKeySpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSshPublicKeySpecARM(subject SshPublicKeySpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SshPublicKeySpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SshPublicKeySpecARM instances for property testing - lazily instantiated by
// SshPublicKeySpecARMGenerator()
var sshPublicKeySpecARMGenerator gopter.Gen

// SshPublicKeySpecARMGenerator returns a generator of SshPublicKeySpecARM instances for property testing.
func SshPublicKeySpecARMGenerator() gopter.Gen {
	if sshPublicKeySpecARMGenerator != nil {
		return sshPublicKeySpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSshPublicKeySpecARM(generators)
	sshPublicKeySpecARMGenerator = gen.Struct(reflect.TypeOf(SshPublicKeySpecARM{}), generators)

	return sshPublicKeySpecARMGenerator
}

// AddIndependentPropertyGeneratorsForSshPublicKeySpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSshPublicKeySpecARM(gens map[string]gopter.Gen) {
	gens["KeyData"] = gen.PtrOf(gen.AlphaString())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachineNetworkInterfaceDnsSettingsConfigurationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineNetworkInterfaceDnsSettingsConfigurationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineNetworkInterfaceDnsSettingsConfigurationARM, VirtualMachineNetworkInterfaceDnsSettingsConfigurationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineNetworkInterfaceDnsSettingsConfigurationARM runs a test to see if a specific instance of VirtualMachineNetworkInterfaceDnsSettingsConfigurationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineNetworkInterfaceDnsSettingsConfigurationARM(subject VirtualMachineNetworkInterfaceDnsSettingsConfigurationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineNetworkInterfaceDnsSettingsConfigurationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineNetworkInterfaceDnsSettingsConfigurationARM instances for property testing - lazily
// instantiated by VirtualMachineNetworkInterfaceDnsSettingsConfigurationARMGenerator()
var virtualMachineNetworkInterfaceDnsSettingsConfigurationARMGenerator gopter.Gen

// VirtualMachineNetworkInterfaceDnsSettingsConfigurationARMGenerator returns a generator of VirtualMachineNetworkInterfaceDnsSettingsConfigurationARM instances for property testing.
func VirtualMachineNetworkInterfaceDnsSettingsConfigurationARMGenerator() gopter.Gen {
	if virtualMachineNetworkInterfaceDnsSettingsConfigurationARMGenerator != nil {
		return virtualMachineNetworkInterfaceDnsSettingsConfigurationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineNetworkInterfaceDnsSettingsConfigurationARM(generators)
	virtualMachineNetworkInterfaceDnsSettingsConfigurationARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineNetworkInterfaceDnsSettingsConfigurationARM{}), generators)

	return virtualMachineNetworkInterfaceDnsSettingsConfigurationARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineNetworkInterfaceDnsSettingsConfigurationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineNetworkInterfaceDnsSettingsConfigurationARM(gens map[string]gopter.Gen) {
	gens["DnsServers"] = gen.SliceOf(gen.AlphaString())
}

func Test_VirtualMachineNetworkInterfaceIPConfigurationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineNetworkInterfaceIPConfigurationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineNetworkInterfaceIPConfigurationARM, VirtualMachineNetworkInterfaceIPConfigurationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineNetworkInterfaceIPConfigurationARM runs a test to see if a specific instance of VirtualMachineNetworkInterfaceIPConfigurationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineNetworkInterfaceIPConfigurationARM(subject VirtualMachineNetworkInterfaceIPConfigurationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineNetworkInterfaceIPConfigurationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineNetworkInterfaceIPConfigurationARM instances for property testing - lazily instantiated by
// VirtualMachineNetworkInterfaceIPConfigurationARMGenerator()
var virtualMachineNetworkInterfaceIPConfigurationARMGenerator gopter.Gen

// VirtualMachineNetworkInterfaceIPConfigurationARMGenerator returns a generator of VirtualMachineNetworkInterfaceIPConfigurationARM instances for property testing.
// We first initialize virtualMachineNetworkInterfaceIPConfigurationARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineNetworkInterfaceIPConfigurationARMGenerator() gopter.Gen {
	if virtualMachineNetworkInterfaceIPConfigurationARMGenerator != nil {
		return virtualMachineNetworkInterfaceIPConfigurationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineNetworkInterfaceIPConfigurationARM(generators)
	virtualMachineNetworkInterfaceIPConfigurationARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineNetworkInterfaceIPConfigurationARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineNetworkInterfaceIPConfigurationARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineNetworkInterfaceIPConfigurationARM(generators)
	virtualMachineNetworkInterfaceIPConfigurationARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineNetworkInterfaceIPConfigurationARM{}), generators)

	return virtualMachineNetworkInterfaceIPConfigurationARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineNetworkInterfaceIPConfigurationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineNetworkInterfaceIPConfigurationARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineNetworkInterfaceIPConfigurationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineNetworkInterfaceIPConfigurationARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(VirtualMachineNetworkInterfaceIPConfigurationPropertiesARMGenerator())
}

func Test_VMDiskSecurityProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VMDiskSecurityProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVMDiskSecurityProfileARM, VMDiskSecurityProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVMDiskSecurityProfileARM runs a test to see if a specific instance of VMDiskSecurityProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVMDiskSecurityProfileARM(subject VMDiskSecurityProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VMDiskSecurityProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VMDiskSecurityProfileARM instances for property testing - lazily instantiated by
// VMDiskSecurityProfileARMGenerator()
var vmDiskSecurityProfileARMGenerator gopter.Gen

// VMDiskSecurityProfileARMGenerator returns a generator of VMDiskSecurityProfileARM instances for property testing.
// We first initialize vmDiskSecurityProfileARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VMDiskSecurityProfileARMGenerator() gopter.Gen {
	if vmDiskSecurityProfileARMGenerator != nil {
		return vmDiskSecurityProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVMDiskSecurityProfileARM(generators)
	vmDiskSecurityProfileARMGenerator = gen.Struct(reflect.TypeOf(VMDiskSecurityProfileARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVMDiskSecurityProfileARM(generators)
	AddRelatedPropertyGeneratorsForVMDiskSecurityProfileARM(generators)
	vmDiskSecurityProfileARMGenerator = gen.Struct(reflect.TypeOf(VMDiskSecurityProfileARM{}), generators)

	return vmDiskSecurityProfileARMGenerator
}

// AddIndependentPropertyGeneratorsForVMDiskSecurityProfileARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVMDiskSecurityProfileARM(gens map[string]gopter.Gen) {
	gens["SecurityEncryptionType"] = gen.PtrOf(gen.OneConstOf(VMDiskSecurityProfile_SecurityEncryptionType_DiskWithVMGuestState, VMDiskSecurityProfile_SecurityEncryptionType_VMGuestStateOnly))
}

// AddRelatedPropertyGeneratorsForVMDiskSecurityProfileARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVMDiskSecurityProfileARM(gens map[string]gopter.Gen) {
	gens["DiskEncryptionSet"] = gen.PtrOf(SubResourceARMGenerator())
}

func Test_WindowsVMGuestPatchAutomaticByPlatformSettingsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WindowsVMGuestPatchAutomaticByPlatformSettingsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWindowsVMGuestPatchAutomaticByPlatformSettingsARM, WindowsVMGuestPatchAutomaticByPlatformSettingsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWindowsVMGuestPatchAutomaticByPlatformSettingsARM runs a test to see if a specific instance of WindowsVMGuestPatchAutomaticByPlatformSettingsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWindowsVMGuestPatchAutomaticByPlatformSettingsARM(subject WindowsVMGuestPatchAutomaticByPlatformSettingsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WindowsVMGuestPatchAutomaticByPlatformSettingsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WindowsVMGuestPatchAutomaticByPlatformSettingsARM instances for property testing - lazily instantiated
// by WindowsVMGuestPatchAutomaticByPlatformSettingsARMGenerator()
var windowsVMGuestPatchAutomaticByPlatformSettingsARMGenerator gopter.Gen

// WindowsVMGuestPatchAutomaticByPlatformSettingsARMGenerator returns a generator of WindowsVMGuestPatchAutomaticByPlatformSettingsARM instances for property testing.
func WindowsVMGuestPatchAutomaticByPlatformSettingsARMGenerator() gopter.Gen {
	if windowsVMGuestPatchAutomaticByPlatformSettingsARMGenerator != nil {
		return windowsVMGuestPatchAutomaticByPlatformSettingsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsVMGuestPatchAutomaticByPlatformSettingsARM(generators)
	windowsVMGuestPatchAutomaticByPlatformSettingsARMGenerator = gen.Struct(reflect.TypeOf(WindowsVMGuestPatchAutomaticByPlatformSettingsARM{}), generators)

	return windowsVMGuestPatchAutomaticByPlatformSettingsARMGenerator
}

// AddIndependentPropertyGeneratorsForWindowsVMGuestPatchAutomaticByPlatformSettingsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWindowsVMGuestPatchAutomaticByPlatformSettingsARM(gens map[string]gopter.Gen) {
	gens["RebootSetting"] = gen.PtrOf(gen.OneConstOf(
		WindowsVMGuestPatchAutomaticByPlatformSettings_RebootSetting_Always,
		WindowsVMGuestPatchAutomaticByPlatformSettings_RebootSetting_IfRequired,
		WindowsVMGuestPatchAutomaticByPlatformSettings_RebootSetting_Never,
		WindowsVMGuestPatchAutomaticByPlatformSettings_RebootSetting_Unknown))
}

func Test_WinRMListenerARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WinRMListenerARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWinRMListenerARM, WinRMListenerARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWinRMListenerARM runs a test to see if a specific instance of WinRMListenerARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWinRMListenerARM(subject WinRMListenerARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WinRMListenerARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WinRMListenerARM instances for property testing - lazily instantiated by WinRMListenerARMGenerator()
var winRMListenerARMGenerator gopter.Gen

// WinRMListenerARMGenerator returns a generator of WinRMListenerARM instances for property testing.
func WinRMListenerARMGenerator() gopter.Gen {
	if winRMListenerARMGenerator != nil {
		return winRMListenerARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWinRMListenerARM(generators)
	winRMListenerARMGenerator = gen.Struct(reflect.TypeOf(WinRMListenerARM{}), generators)

	return winRMListenerARMGenerator
}

// AddIndependentPropertyGeneratorsForWinRMListenerARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWinRMListenerARM(gens map[string]gopter.Gen) {
	gens["CertificateUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(WinRMListener_Protocol_Http, WinRMListener_Protocol_Https))
}

func Test_VirtualMachineNetworkInterfaceIPConfigurationPropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineNetworkInterfaceIPConfigurationPropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineNetworkInterfaceIPConfigurationPropertiesARM, VirtualMachineNetworkInterfaceIPConfigurationPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineNetworkInterfaceIPConfigurationPropertiesARM runs a test to see if a specific instance of VirtualMachineNetworkInterfaceIPConfigurationPropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineNetworkInterfaceIPConfigurationPropertiesARM(subject VirtualMachineNetworkInterfaceIPConfigurationPropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineNetworkInterfaceIPConfigurationPropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineNetworkInterfaceIPConfigurationPropertiesARM instances for property testing - lazily
// instantiated by VirtualMachineNetworkInterfaceIPConfigurationPropertiesARMGenerator()
var virtualMachineNetworkInterfaceIPConfigurationPropertiesARMGenerator gopter.Gen

// VirtualMachineNetworkInterfaceIPConfigurationPropertiesARMGenerator returns a generator of VirtualMachineNetworkInterfaceIPConfigurationPropertiesARM instances for property testing.
// We first initialize virtualMachineNetworkInterfaceIPConfigurationPropertiesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineNetworkInterfaceIPConfigurationPropertiesARMGenerator() gopter.Gen {
	if virtualMachineNetworkInterfaceIPConfigurationPropertiesARMGenerator != nil {
		return virtualMachineNetworkInterfaceIPConfigurationPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineNetworkInterfaceIPConfigurationPropertiesARM(generators)
	virtualMachineNetworkInterfaceIPConfigurationPropertiesARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineNetworkInterfaceIPConfigurationPropertiesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineNetworkInterfaceIPConfigurationPropertiesARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineNetworkInterfaceIPConfigurationPropertiesARM(generators)
	virtualMachineNetworkInterfaceIPConfigurationPropertiesARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineNetworkInterfaceIPConfigurationPropertiesARM{}), generators)

	return virtualMachineNetworkInterfaceIPConfigurationPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineNetworkInterfaceIPConfigurationPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineNetworkInterfaceIPConfigurationPropertiesARM(gens map[string]gopter.Gen) {
	gens["Primary"] = gen.PtrOf(gen.Bool())
	gens["PrivateIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(VirtualMachineNetworkInterfaceIPConfigurationProperties_PrivateIPAddressVersion_IPv4, VirtualMachineNetworkInterfaceIPConfigurationProperties_PrivateIPAddressVersion_IPv6))
}

// AddRelatedPropertyGeneratorsForVirtualMachineNetworkInterfaceIPConfigurationPropertiesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineNetworkInterfaceIPConfigurationPropertiesARM(gens map[string]gopter.Gen) {
	gens["ApplicationGatewayBackendAddressPools"] = gen.SliceOf(SubResourceARMGenerator())
	gens["ApplicationSecurityGroups"] = gen.SliceOf(SubResourceARMGenerator())
	gens["LoadBalancerBackendAddressPools"] = gen.SliceOf(SubResourceARMGenerator())
	gens["PublicIPAddressConfiguration"] = gen.PtrOf(VirtualMachinePublicIPAddressConfigurationARMGenerator())
	gens["Subnet"] = gen.PtrOf(SubResourceARMGenerator())
}

func Test_VirtualMachinePublicIPAddressConfigurationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachinePublicIPAddressConfigurationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachinePublicIPAddressConfigurationARM, VirtualMachinePublicIPAddressConfigurationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachinePublicIPAddressConfigurationARM runs a test to see if a specific instance of VirtualMachinePublicIPAddressConfigurationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachinePublicIPAddressConfigurationARM(subject VirtualMachinePublicIPAddressConfigurationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachinePublicIPAddressConfigurationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachinePublicIPAddressConfigurationARM instances for property testing - lazily instantiated by
// VirtualMachinePublicIPAddressConfigurationARMGenerator()
var virtualMachinePublicIPAddressConfigurationARMGenerator gopter.Gen

// VirtualMachinePublicIPAddressConfigurationARMGenerator returns a generator of VirtualMachinePublicIPAddressConfigurationARM instances for property testing.
// We first initialize virtualMachinePublicIPAddressConfigurationARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachinePublicIPAddressConfigurationARMGenerator() gopter.Gen {
	if virtualMachinePublicIPAddressConfigurationARMGenerator != nil {
		return virtualMachinePublicIPAddressConfigurationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinePublicIPAddressConfigurationARM(generators)
	virtualMachinePublicIPAddressConfigurationARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachinePublicIPAddressConfigurationARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinePublicIPAddressConfigurationARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachinePublicIPAddressConfigurationARM(generators)
	virtualMachinePublicIPAddressConfigurationARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachinePublicIPAddressConfigurationARM{}), generators)

	return virtualMachinePublicIPAddressConfigurationARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachinePublicIPAddressConfigurationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachinePublicIPAddressConfigurationARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachinePublicIPAddressConfigurationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachinePublicIPAddressConfigurationARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(VirtualMachinePublicIPAddressConfigurationPropertiesARMGenerator())
	gens["Sku"] = gen.PtrOf(PublicIPAddressSkuARMGenerator())
}

func Test_PublicIPAddressSkuARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PublicIPAddressSkuARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPublicIPAddressSkuARM, PublicIPAddressSkuARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPublicIPAddressSkuARM runs a test to see if a specific instance of PublicIPAddressSkuARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPublicIPAddressSkuARM(subject PublicIPAddressSkuARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PublicIPAddressSkuARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PublicIPAddressSkuARM instances for property testing - lazily instantiated by
// PublicIPAddressSkuARMGenerator()
var publicIPAddressSkuARMGenerator gopter.Gen

// PublicIPAddressSkuARMGenerator returns a generator of PublicIPAddressSkuARM instances for property testing.
func PublicIPAddressSkuARMGenerator() gopter.Gen {
	if publicIPAddressSkuARMGenerator != nil {
		return publicIPAddressSkuARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPublicIPAddressSkuARM(generators)
	publicIPAddressSkuARMGenerator = gen.Struct(reflect.TypeOf(PublicIPAddressSkuARM{}), generators)

	return publicIPAddressSkuARMGenerator
}

// AddIndependentPropertyGeneratorsForPublicIPAddressSkuARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPublicIPAddressSkuARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(PublicIPAddressSku_Name_Basic, PublicIPAddressSku_Name_Standard))
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(PublicIPAddressSku_Tier_Global, PublicIPAddressSku_Tier_Regional))
}

func Test_VirtualMachinePublicIPAddressConfigurationPropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachinePublicIPAddressConfigurationPropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachinePublicIPAddressConfigurationPropertiesARM, VirtualMachinePublicIPAddressConfigurationPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachinePublicIPAddressConfigurationPropertiesARM runs a test to see if a specific instance of VirtualMachinePublicIPAddressConfigurationPropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachinePublicIPAddressConfigurationPropertiesARM(subject VirtualMachinePublicIPAddressConfigurationPropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachinePublicIPAddressConfigurationPropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachinePublicIPAddressConfigurationPropertiesARM instances for property testing - lazily
// instantiated by VirtualMachinePublicIPAddressConfigurationPropertiesARMGenerator()
var virtualMachinePublicIPAddressConfigurationPropertiesARMGenerator gopter.Gen

// VirtualMachinePublicIPAddressConfigurationPropertiesARMGenerator returns a generator of VirtualMachinePublicIPAddressConfigurationPropertiesARM instances for property testing.
// We first initialize virtualMachinePublicIPAddressConfigurationPropertiesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachinePublicIPAddressConfigurationPropertiesARMGenerator() gopter.Gen {
	if virtualMachinePublicIPAddressConfigurationPropertiesARMGenerator != nil {
		return virtualMachinePublicIPAddressConfigurationPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinePublicIPAddressConfigurationPropertiesARM(generators)
	virtualMachinePublicIPAddressConfigurationPropertiesARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachinePublicIPAddressConfigurationPropertiesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinePublicIPAddressConfigurationPropertiesARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachinePublicIPAddressConfigurationPropertiesARM(generators)
	virtualMachinePublicIPAddressConfigurationPropertiesARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachinePublicIPAddressConfigurationPropertiesARM{}), generators)

	return virtualMachinePublicIPAddressConfigurationPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachinePublicIPAddressConfigurationPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachinePublicIPAddressConfigurationPropertiesARM(gens map[string]gopter.Gen) {
	gens["DeleteOption"] = gen.PtrOf(gen.OneConstOf(VirtualMachinePublicIPAddressConfigurationProperties_DeleteOption_Delete, VirtualMachinePublicIPAddressConfigurationProperties_DeleteOption_Detach))
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
	gens["PublicIPAddressVersion"] = gen.PtrOf(gen.OneConstOf(VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAddressVersion_IPv4, VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAddressVersion_IPv6))
	gens["PublicIPAllocationMethod"] = gen.PtrOf(gen.OneConstOf(VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAllocationMethod_Dynamic, VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAllocationMethod_Static))
}

// AddRelatedPropertyGeneratorsForVirtualMachinePublicIPAddressConfigurationPropertiesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachinePublicIPAddressConfigurationPropertiesARM(gens map[string]gopter.Gen) {
	gens["DnsSettings"] = gen.PtrOf(VirtualMachinePublicIPAddressDnsSettingsConfigurationARMGenerator())
	gens["IpTags"] = gen.SliceOf(VirtualMachineIpTagARMGenerator())
	gens["PublicIPPrefix"] = gen.PtrOf(SubResourceARMGenerator())
}

func Test_VirtualMachineIpTagARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineIpTagARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineIpTagARM, VirtualMachineIpTagARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineIpTagARM runs a test to see if a specific instance of VirtualMachineIpTagARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineIpTagARM(subject VirtualMachineIpTagARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineIpTagARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineIpTagARM instances for property testing - lazily instantiated by
// VirtualMachineIpTagARMGenerator()
var virtualMachineIpTagARMGenerator gopter.Gen

// VirtualMachineIpTagARMGenerator returns a generator of VirtualMachineIpTagARM instances for property testing.
func VirtualMachineIpTagARMGenerator() gopter.Gen {
	if virtualMachineIpTagARMGenerator != nil {
		return virtualMachineIpTagARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineIpTagARM(generators)
	virtualMachineIpTagARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineIpTagARM{}), generators)

	return virtualMachineIpTagARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineIpTagARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineIpTagARM(gens map[string]gopter.Gen) {
	gens["IpTagType"] = gen.PtrOf(gen.AlphaString())
	gens["Tag"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachinePublicIPAddressDnsSettingsConfigurationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachinePublicIPAddressDnsSettingsConfigurationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachinePublicIPAddressDnsSettingsConfigurationARM, VirtualMachinePublicIPAddressDnsSettingsConfigurationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachinePublicIPAddressDnsSettingsConfigurationARM runs a test to see if a specific instance of VirtualMachinePublicIPAddressDnsSettingsConfigurationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachinePublicIPAddressDnsSettingsConfigurationARM(subject VirtualMachinePublicIPAddressDnsSettingsConfigurationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachinePublicIPAddressDnsSettingsConfigurationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachinePublicIPAddressDnsSettingsConfigurationARM instances for property testing - lazily
// instantiated by VirtualMachinePublicIPAddressDnsSettingsConfigurationARMGenerator()
var virtualMachinePublicIPAddressDnsSettingsConfigurationARMGenerator gopter.Gen

// VirtualMachinePublicIPAddressDnsSettingsConfigurationARMGenerator returns a generator of VirtualMachinePublicIPAddressDnsSettingsConfigurationARM instances for property testing.
func VirtualMachinePublicIPAddressDnsSettingsConfigurationARMGenerator() gopter.Gen {
	if virtualMachinePublicIPAddressDnsSettingsConfigurationARMGenerator != nil {
		return virtualMachinePublicIPAddressDnsSettingsConfigurationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinePublicIPAddressDnsSettingsConfigurationARM(generators)
	virtualMachinePublicIPAddressDnsSettingsConfigurationARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachinePublicIPAddressDnsSettingsConfigurationARM{}), generators)

	return virtualMachinePublicIPAddressDnsSettingsConfigurationARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachinePublicIPAddressDnsSettingsConfigurationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachinePublicIPAddressDnsSettingsConfigurationARM(gens map[string]gopter.Gen) {
	gens["DomainNameLabel"] = gen.PtrOf(gen.AlphaString())
}
