// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20201201

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_VirtualMachine_Spec_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachine_Spec_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachine_Spec_ARM, VirtualMachine_Spec_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachine_Spec_ARM runs a test to see if a specific instance of VirtualMachine_Spec_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachine_Spec_ARM(subject VirtualMachine_Spec_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachine_Spec_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachine_Spec_ARM instances for property testing - lazily instantiated by
// VirtualMachine_Spec_ARMGenerator()
var virtualMachine_Spec_ARMGenerator gopter.Gen

// VirtualMachine_Spec_ARMGenerator returns a generator of VirtualMachine_Spec_ARM instances for property testing.
// We first initialize virtualMachine_Spec_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachine_Spec_ARMGenerator() gopter.Gen {
	if virtualMachine_Spec_ARMGenerator != nil {
		return virtualMachine_Spec_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachine_Spec_ARM(generators)
	virtualMachine_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachine_Spec_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachine_Spec_ARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachine_Spec_ARM(generators)
	virtualMachine_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachine_Spec_ARM{}), generators)

	return virtualMachine_Spec_ARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachine_Spec_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachine_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachine_Spec_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachine_Spec_ARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocation_ARMGenerator())
	gens["Identity"] = gen.PtrOf(VirtualMachineIdentity_ARMGenerator())
	gens["Plan"] = gen.PtrOf(Plan_ARMGenerator())
	gens["Properties"] = gen.PtrOf(VirtualMachineProperties_ARMGenerator())
}

func Test_VirtualMachineIdentity_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineIdentity_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineIdentity_ARM, VirtualMachineIdentity_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineIdentity_ARM runs a test to see if a specific instance of VirtualMachineIdentity_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineIdentity_ARM(subject VirtualMachineIdentity_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineIdentity_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineIdentity_ARM instances for property testing - lazily instantiated by
// VirtualMachineIdentity_ARMGenerator()
var virtualMachineIdentity_ARMGenerator gopter.Gen

// VirtualMachineIdentity_ARMGenerator returns a generator of VirtualMachineIdentity_ARM instances for property testing.
// We first initialize virtualMachineIdentity_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineIdentity_ARMGenerator() gopter.Gen {
	if virtualMachineIdentity_ARMGenerator != nil {
		return virtualMachineIdentity_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineIdentity_ARM(generators)
	virtualMachineIdentity_ARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineIdentity_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineIdentity_ARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineIdentity_ARM(generators)
	virtualMachineIdentity_ARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineIdentity_ARM{}), generators)

	return virtualMachineIdentity_ARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineIdentity_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineIdentity_ARM(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		VirtualMachineIdentity_Type_None,
		VirtualMachineIdentity_Type_SystemAssigned,
		VirtualMachineIdentity_Type_SystemAssignedUserAssigned,
		VirtualMachineIdentity_Type_UserAssigned))
}

// AddRelatedPropertyGeneratorsForVirtualMachineIdentity_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineIdentity_ARM(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(
		gen.AlphaString(),
		UserAssignedIdentityDetails_ARMGenerator())
}

func Test_VirtualMachineProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineProperties_ARM, VirtualMachineProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineProperties_ARM runs a test to see if a specific instance of VirtualMachineProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineProperties_ARM(subject VirtualMachineProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineProperties_ARM instances for property testing - lazily instantiated by
// VirtualMachineProperties_ARMGenerator()
var virtualMachineProperties_ARMGenerator gopter.Gen

// VirtualMachineProperties_ARMGenerator returns a generator of VirtualMachineProperties_ARM instances for property testing.
// We first initialize virtualMachineProperties_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineProperties_ARMGenerator() gopter.Gen {
	if virtualMachineProperties_ARMGenerator != nil {
		return virtualMachineProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineProperties_ARM(generators)
	virtualMachineProperties_ARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineProperties_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineProperties_ARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineProperties_ARM(generators)
	virtualMachineProperties_ARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineProperties_ARM{}), generators)

	return virtualMachineProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineProperties_ARM(gens map[string]gopter.Gen) {
	gens["EvictionPolicy"] = gen.PtrOf(gen.OneConstOf(EvictionPolicy_Deallocate, EvictionPolicy_Delete))
	gens["ExtensionsTimeBudget"] = gen.PtrOf(gen.AlphaString())
	gens["LicenseType"] = gen.PtrOf(gen.AlphaString())
	gens["PlatformFaultDomain"] = gen.PtrOf(gen.Int())
	gens["Priority"] = gen.PtrOf(gen.OneConstOf(Priority_Low, Priority_Regular, Priority_Spot))
}

// AddRelatedPropertyGeneratorsForVirtualMachineProperties_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineProperties_ARM(gens map[string]gopter.Gen) {
	gens["AdditionalCapabilities"] = gen.PtrOf(AdditionalCapabilities_ARMGenerator())
	gens["AvailabilitySet"] = gen.PtrOf(SubResource_ARMGenerator())
	gens["BillingProfile"] = gen.PtrOf(BillingProfile_ARMGenerator())
	gens["DiagnosticsProfile"] = gen.PtrOf(DiagnosticsProfile_ARMGenerator())
	gens["HardwareProfile"] = gen.PtrOf(HardwareProfile_ARMGenerator())
	gens["Host"] = gen.PtrOf(SubResource_ARMGenerator())
	gens["HostGroup"] = gen.PtrOf(SubResource_ARMGenerator())
	gens["NetworkProfile"] = gen.PtrOf(NetworkProfile_ARMGenerator())
	gens["OsProfile"] = gen.PtrOf(OSProfile_ARMGenerator())
	gens["ProximityPlacementGroup"] = gen.PtrOf(SubResource_ARMGenerator())
	gens["SecurityProfile"] = gen.PtrOf(SecurityProfile_ARMGenerator())
	gens["StorageProfile"] = gen.PtrOf(StorageProfile_ARMGenerator())
	gens["VirtualMachineScaleSet"] = gen.PtrOf(SubResource_ARMGenerator())
}

func Test_BillingProfile_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BillingProfile_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBillingProfile_ARM, BillingProfile_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBillingProfile_ARM runs a test to see if a specific instance of BillingProfile_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBillingProfile_ARM(subject BillingProfile_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BillingProfile_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BillingProfile_ARM instances for property testing - lazily instantiated by BillingProfile_ARMGenerator()
var billingProfile_ARMGenerator gopter.Gen

// BillingProfile_ARMGenerator returns a generator of BillingProfile_ARM instances for property testing.
func BillingProfile_ARMGenerator() gopter.Gen {
	if billingProfile_ARMGenerator != nil {
		return billingProfile_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBillingProfile_ARM(generators)
	billingProfile_ARMGenerator = gen.Struct(reflect.TypeOf(BillingProfile_ARM{}), generators)

	return billingProfile_ARMGenerator
}

// AddIndependentPropertyGeneratorsForBillingProfile_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBillingProfile_ARM(gens map[string]gopter.Gen) {
	gens["MaxPrice"] = gen.PtrOf(gen.Float64())
}

func Test_DiagnosticsProfile_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiagnosticsProfile_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiagnosticsProfile_ARM, DiagnosticsProfile_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiagnosticsProfile_ARM runs a test to see if a specific instance of DiagnosticsProfile_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiagnosticsProfile_ARM(subject DiagnosticsProfile_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiagnosticsProfile_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiagnosticsProfile_ARM instances for property testing - lazily instantiated by
// DiagnosticsProfile_ARMGenerator()
var diagnosticsProfile_ARMGenerator gopter.Gen

// DiagnosticsProfile_ARMGenerator returns a generator of DiagnosticsProfile_ARM instances for property testing.
func DiagnosticsProfile_ARMGenerator() gopter.Gen {
	if diagnosticsProfile_ARMGenerator != nil {
		return diagnosticsProfile_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDiagnosticsProfile_ARM(generators)
	diagnosticsProfile_ARMGenerator = gen.Struct(reflect.TypeOf(DiagnosticsProfile_ARM{}), generators)

	return diagnosticsProfile_ARMGenerator
}

// AddRelatedPropertyGeneratorsForDiagnosticsProfile_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiagnosticsProfile_ARM(gens map[string]gopter.Gen) {
	gens["BootDiagnostics"] = gen.PtrOf(BootDiagnostics_ARMGenerator())
}

func Test_HardwareProfile_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HardwareProfile_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHardwareProfile_ARM, HardwareProfile_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHardwareProfile_ARM runs a test to see if a specific instance of HardwareProfile_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHardwareProfile_ARM(subject HardwareProfile_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HardwareProfile_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HardwareProfile_ARM instances for property testing - lazily instantiated by
// HardwareProfile_ARMGenerator()
var hardwareProfile_ARMGenerator gopter.Gen

// HardwareProfile_ARMGenerator returns a generator of HardwareProfile_ARM instances for property testing.
func HardwareProfile_ARMGenerator() gopter.Gen {
	if hardwareProfile_ARMGenerator != nil {
		return hardwareProfile_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHardwareProfile_ARM(generators)
	hardwareProfile_ARMGenerator = gen.Struct(reflect.TypeOf(HardwareProfile_ARM{}), generators)

	return hardwareProfile_ARMGenerator
}

// AddIndependentPropertyGeneratorsForHardwareProfile_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHardwareProfile_ARM(gens map[string]gopter.Gen) {
	gens["VmSize"] = gen.PtrOf(gen.AlphaString())
}

func Test_NetworkProfile_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkProfile_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkProfile_ARM, NetworkProfile_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkProfile_ARM runs a test to see if a specific instance of NetworkProfile_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkProfile_ARM(subject NetworkProfile_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkProfile_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkProfile_ARM instances for property testing - lazily instantiated by NetworkProfile_ARMGenerator()
var networkProfile_ARMGenerator gopter.Gen

// NetworkProfile_ARMGenerator returns a generator of NetworkProfile_ARM instances for property testing.
func NetworkProfile_ARMGenerator() gopter.Gen {
	if networkProfile_ARMGenerator != nil {
		return networkProfile_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForNetworkProfile_ARM(generators)
	networkProfile_ARMGenerator = gen.Struct(reflect.TypeOf(NetworkProfile_ARM{}), generators)

	return networkProfile_ARMGenerator
}

// AddRelatedPropertyGeneratorsForNetworkProfile_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkProfile_ARM(gens map[string]gopter.Gen) {
	gens["NetworkInterfaces"] = gen.SliceOf(NetworkInterfaceReference_ARMGenerator())
}

func Test_OSProfile_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OSProfile_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOSProfile_ARM, OSProfile_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOSProfile_ARM runs a test to see if a specific instance of OSProfile_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOSProfile_ARM(subject OSProfile_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OSProfile_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OSProfile_ARM instances for property testing - lazily instantiated by OSProfile_ARMGenerator()
var osProfile_ARMGenerator gopter.Gen

// OSProfile_ARMGenerator returns a generator of OSProfile_ARM instances for property testing.
// We first initialize osProfile_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OSProfile_ARMGenerator() gopter.Gen {
	if osProfile_ARMGenerator != nil {
		return osProfile_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSProfile_ARM(generators)
	osProfile_ARMGenerator = gen.Struct(reflect.TypeOf(OSProfile_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSProfile_ARM(generators)
	AddRelatedPropertyGeneratorsForOSProfile_ARM(generators)
	osProfile_ARMGenerator = gen.Struct(reflect.TypeOf(OSProfile_ARM{}), generators)

	return osProfile_ARMGenerator
}

// AddIndependentPropertyGeneratorsForOSProfile_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOSProfile_ARM(gens map[string]gopter.Gen) {
	gens["AdminPassword"] = gen.PtrOf(gen.AlphaString())
	gens["AdminUsername"] = gen.PtrOf(gen.AlphaString())
	gens["AllowExtensionOperations"] = gen.PtrOf(gen.Bool())
	gens["ComputerName"] = gen.PtrOf(gen.AlphaString())
	gens["CustomData"] = gen.PtrOf(gen.AlphaString())
	gens["RequireGuestProvisionSignal"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForOSProfile_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOSProfile_ARM(gens map[string]gopter.Gen) {
	gens["LinuxConfiguration"] = gen.PtrOf(LinuxConfiguration_ARMGenerator())
	gens["Secrets"] = gen.SliceOf(VaultSecretGroup_ARMGenerator())
	gens["WindowsConfiguration"] = gen.PtrOf(WindowsConfiguration_ARMGenerator())
}

func Test_SecurityProfile_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SecurityProfile_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSecurityProfile_ARM, SecurityProfile_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSecurityProfile_ARM runs a test to see if a specific instance of SecurityProfile_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSecurityProfile_ARM(subject SecurityProfile_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SecurityProfile_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SecurityProfile_ARM instances for property testing - lazily instantiated by
// SecurityProfile_ARMGenerator()
var securityProfile_ARMGenerator gopter.Gen

// SecurityProfile_ARMGenerator returns a generator of SecurityProfile_ARM instances for property testing.
// We first initialize securityProfile_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SecurityProfile_ARMGenerator() gopter.Gen {
	if securityProfile_ARMGenerator != nil {
		return securityProfile_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecurityProfile_ARM(generators)
	securityProfile_ARMGenerator = gen.Struct(reflect.TypeOf(SecurityProfile_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecurityProfile_ARM(generators)
	AddRelatedPropertyGeneratorsForSecurityProfile_ARM(generators)
	securityProfile_ARMGenerator = gen.Struct(reflect.TypeOf(SecurityProfile_ARM{}), generators)

	return securityProfile_ARMGenerator
}

// AddIndependentPropertyGeneratorsForSecurityProfile_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSecurityProfile_ARM(gens map[string]gopter.Gen) {
	gens["EncryptionAtHost"] = gen.PtrOf(gen.Bool())
	gens["SecurityType"] = gen.PtrOf(gen.OneConstOf(SecurityProfile_SecurityType_TrustedLaunch))
}

// AddRelatedPropertyGeneratorsForSecurityProfile_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSecurityProfile_ARM(gens map[string]gopter.Gen) {
	gens["UefiSettings"] = gen.PtrOf(UefiSettings_ARMGenerator())
}

func Test_StorageProfile_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageProfile_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageProfile_ARM, StorageProfile_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageProfile_ARM runs a test to see if a specific instance of StorageProfile_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageProfile_ARM(subject StorageProfile_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageProfile_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageProfile_ARM instances for property testing - lazily instantiated by StorageProfile_ARMGenerator()
var storageProfile_ARMGenerator gopter.Gen

// StorageProfile_ARMGenerator returns a generator of StorageProfile_ARM instances for property testing.
func StorageProfile_ARMGenerator() gopter.Gen {
	if storageProfile_ARMGenerator != nil {
		return storageProfile_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForStorageProfile_ARM(generators)
	storageProfile_ARMGenerator = gen.Struct(reflect.TypeOf(StorageProfile_ARM{}), generators)

	return storageProfile_ARMGenerator
}

// AddRelatedPropertyGeneratorsForStorageProfile_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageProfile_ARM(gens map[string]gopter.Gen) {
	gens["DataDisks"] = gen.SliceOf(DataDisk_ARMGenerator())
	gens["ImageReference"] = gen.PtrOf(ImageReference_ARMGenerator())
	gens["OsDisk"] = gen.PtrOf(OSDisk_ARMGenerator())
}

func Test_BootDiagnostics_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BootDiagnostics_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBootDiagnostics_ARM, BootDiagnostics_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBootDiagnostics_ARM runs a test to see if a specific instance of BootDiagnostics_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBootDiagnostics_ARM(subject BootDiagnostics_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BootDiagnostics_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BootDiagnostics_ARM instances for property testing - lazily instantiated by
// BootDiagnostics_ARMGenerator()
var bootDiagnostics_ARMGenerator gopter.Gen

// BootDiagnostics_ARMGenerator returns a generator of BootDiagnostics_ARM instances for property testing.
func BootDiagnostics_ARMGenerator() gopter.Gen {
	if bootDiagnostics_ARMGenerator != nil {
		return bootDiagnostics_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBootDiagnostics_ARM(generators)
	bootDiagnostics_ARMGenerator = gen.Struct(reflect.TypeOf(BootDiagnostics_ARM{}), generators)

	return bootDiagnostics_ARMGenerator
}

// AddIndependentPropertyGeneratorsForBootDiagnostics_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBootDiagnostics_ARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["StorageUri"] = gen.PtrOf(gen.AlphaString())
}

func Test_DataDisk_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataDisk_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataDisk_ARM, DataDisk_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataDisk_ARM runs a test to see if a specific instance of DataDisk_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDataDisk_ARM(subject DataDisk_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataDisk_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataDisk_ARM instances for property testing - lazily instantiated by DataDisk_ARMGenerator()
var dataDisk_ARMGenerator gopter.Gen

// DataDisk_ARMGenerator returns a generator of DataDisk_ARM instances for property testing.
// We first initialize dataDisk_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DataDisk_ARMGenerator() gopter.Gen {
	if dataDisk_ARMGenerator != nil {
		return dataDisk_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataDisk_ARM(generators)
	dataDisk_ARMGenerator = gen.Struct(reflect.TypeOf(DataDisk_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataDisk_ARM(generators)
	AddRelatedPropertyGeneratorsForDataDisk_ARM(generators)
	dataDisk_ARMGenerator = gen.Struct(reflect.TypeOf(DataDisk_ARM{}), generators)

	return dataDisk_ARMGenerator
}

// AddIndependentPropertyGeneratorsForDataDisk_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDataDisk_ARM(gens map[string]gopter.Gen) {
	gens["Caching"] = gen.PtrOf(gen.OneConstOf(Caching_None, Caching_ReadOnly, Caching_ReadWrite))
	gens["CreateOption"] = gen.PtrOf(gen.OneConstOf(CreateOption_Attach, CreateOption_Empty, CreateOption_FromImage))
	gens["DetachOption"] = gen.PtrOf(gen.OneConstOf(DetachOption_ForceDetach))
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["Lun"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ToBeDetached"] = gen.PtrOf(gen.Bool())
	gens["WriteAcceleratorEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForDataDisk_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataDisk_ARM(gens map[string]gopter.Gen) {
	gens["Image"] = gen.PtrOf(VirtualHardDisk_ARMGenerator())
	gens["ManagedDisk"] = gen.PtrOf(ManagedDiskParameters_ARMGenerator())
	gens["Vhd"] = gen.PtrOf(VirtualHardDisk_ARMGenerator())
}

func Test_ImageReference_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ImageReference_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForImageReference_ARM, ImageReference_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForImageReference_ARM runs a test to see if a specific instance of ImageReference_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForImageReference_ARM(subject ImageReference_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ImageReference_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ImageReference_ARM instances for property testing - lazily instantiated by ImageReference_ARMGenerator()
var imageReference_ARMGenerator gopter.Gen

// ImageReference_ARMGenerator returns a generator of ImageReference_ARM instances for property testing.
func ImageReference_ARMGenerator() gopter.Gen {
	if imageReference_ARMGenerator != nil {
		return imageReference_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForImageReference_ARM(generators)
	imageReference_ARMGenerator = gen.Struct(reflect.TypeOf(ImageReference_ARM{}), generators)

	return imageReference_ARMGenerator
}

// AddIndependentPropertyGeneratorsForImageReference_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForImageReference_ARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Offer"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
	gens["Sku"] = gen.PtrOf(gen.AlphaString())
	gens["Version"] = gen.PtrOf(gen.AlphaString())
}

func Test_LinuxConfiguration_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxConfiguration_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxConfiguration_ARM, LinuxConfiguration_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxConfiguration_ARM runs a test to see if a specific instance of LinuxConfiguration_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxConfiguration_ARM(subject LinuxConfiguration_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxConfiguration_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxConfiguration_ARM instances for property testing - lazily instantiated by
// LinuxConfiguration_ARMGenerator()
var linuxConfiguration_ARMGenerator gopter.Gen

// LinuxConfiguration_ARMGenerator returns a generator of LinuxConfiguration_ARM instances for property testing.
// We first initialize linuxConfiguration_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LinuxConfiguration_ARMGenerator() gopter.Gen {
	if linuxConfiguration_ARMGenerator != nil {
		return linuxConfiguration_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxConfiguration_ARM(generators)
	linuxConfiguration_ARMGenerator = gen.Struct(reflect.TypeOf(LinuxConfiguration_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxConfiguration_ARM(generators)
	AddRelatedPropertyGeneratorsForLinuxConfiguration_ARM(generators)
	linuxConfiguration_ARMGenerator = gen.Struct(reflect.TypeOf(LinuxConfiguration_ARM{}), generators)

	return linuxConfiguration_ARMGenerator
}

// AddIndependentPropertyGeneratorsForLinuxConfiguration_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxConfiguration_ARM(gens map[string]gopter.Gen) {
	gens["DisablePasswordAuthentication"] = gen.PtrOf(gen.Bool())
	gens["ProvisionVMAgent"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForLinuxConfiguration_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLinuxConfiguration_ARM(gens map[string]gopter.Gen) {
	gens["PatchSettings"] = gen.PtrOf(LinuxPatchSettings_ARMGenerator())
	gens["Ssh"] = gen.PtrOf(SshConfiguration_ARMGenerator())
}

func Test_NetworkInterfaceReference_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceReference_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceReference_ARM, NetworkInterfaceReference_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceReference_ARM runs a test to see if a specific instance of NetworkInterfaceReference_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceReference_ARM(subject NetworkInterfaceReference_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceReference_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceReference_ARM instances for property testing - lazily instantiated by
// NetworkInterfaceReference_ARMGenerator()
var networkInterfaceReference_ARMGenerator gopter.Gen

// NetworkInterfaceReference_ARMGenerator returns a generator of NetworkInterfaceReference_ARM instances for property testing.
// We first initialize networkInterfaceReference_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkInterfaceReference_ARMGenerator() gopter.Gen {
	if networkInterfaceReference_ARMGenerator != nil {
		return networkInterfaceReference_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceReference_ARM(generators)
	networkInterfaceReference_ARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceReference_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceReference_ARM(generators)
	AddRelatedPropertyGeneratorsForNetworkInterfaceReference_ARM(generators)
	networkInterfaceReference_ARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceReference_ARM{}), generators)

	return networkInterfaceReference_ARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceReference_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceReference_ARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNetworkInterfaceReference_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkInterfaceReference_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(NetworkInterfaceReferenceProperties_ARMGenerator())
}

func Test_OSDisk_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OSDisk_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOSDisk_ARM, OSDisk_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOSDisk_ARM runs a test to see if a specific instance of OSDisk_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOSDisk_ARM(subject OSDisk_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OSDisk_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OSDisk_ARM instances for property testing - lazily instantiated by OSDisk_ARMGenerator()
var osDisk_ARMGenerator gopter.Gen

// OSDisk_ARMGenerator returns a generator of OSDisk_ARM instances for property testing.
// We first initialize osDisk_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OSDisk_ARMGenerator() gopter.Gen {
	if osDisk_ARMGenerator != nil {
		return osDisk_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSDisk_ARM(generators)
	osDisk_ARMGenerator = gen.Struct(reflect.TypeOf(OSDisk_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSDisk_ARM(generators)
	AddRelatedPropertyGeneratorsForOSDisk_ARM(generators)
	osDisk_ARMGenerator = gen.Struct(reflect.TypeOf(OSDisk_ARM{}), generators)

	return osDisk_ARMGenerator
}

// AddIndependentPropertyGeneratorsForOSDisk_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOSDisk_ARM(gens map[string]gopter.Gen) {
	gens["Caching"] = gen.PtrOf(gen.OneConstOf(Caching_None, Caching_ReadOnly, Caching_ReadWrite))
	gens["CreateOption"] = gen.PtrOf(gen.OneConstOf(CreateOption_Attach, CreateOption_Empty, CreateOption_FromImage))
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["OsType"] = gen.PtrOf(gen.OneConstOf(OSDisk_OsType_Linux, OSDisk_OsType_Windows))
	gens["WriteAcceleratorEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForOSDisk_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOSDisk_ARM(gens map[string]gopter.Gen) {
	gens["DiffDiskSettings"] = gen.PtrOf(DiffDiskSettings_ARMGenerator())
	gens["EncryptionSettings"] = gen.PtrOf(DiskEncryptionSettings_ARMGenerator())
	gens["Image"] = gen.PtrOf(VirtualHardDisk_ARMGenerator())
	gens["ManagedDisk"] = gen.PtrOf(ManagedDiskParameters_ARMGenerator())
	gens["Vhd"] = gen.PtrOf(VirtualHardDisk_ARMGenerator())
}

func Test_UefiSettings_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UefiSettings_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUefiSettings_ARM, UefiSettings_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUefiSettings_ARM runs a test to see if a specific instance of UefiSettings_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUefiSettings_ARM(subject UefiSettings_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UefiSettings_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UefiSettings_ARM instances for property testing - lazily instantiated by UefiSettings_ARMGenerator()
var uefiSettings_ARMGenerator gopter.Gen

// UefiSettings_ARMGenerator returns a generator of UefiSettings_ARM instances for property testing.
func UefiSettings_ARMGenerator() gopter.Gen {
	if uefiSettings_ARMGenerator != nil {
		return uefiSettings_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUefiSettings_ARM(generators)
	uefiSettings_ARMGenerator = gen.Struct(reflect.TypeOf(UefiSettings_ARM{}), generators)

	return uefiSettings_ARMGenerator
}

// AddIndependentPropertyGeneratorsForUefiSettings_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUefiSettings_ARM(gens map[string]gopter.Gen) {
	gens["SecureBootEnabled"] = gen.PtrOf(gen.Bool())
	gens["VTpmEnabled"] = gen.PtrOf(gen.Bool())
}

func Test_VaultSecretGroup_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultSecretGroup_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultSecretGroup_ARM, VaultSecretGroup_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultSecretGroup_ARM runs a test to see if a specific instance of VaultSecretGroup_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultSecretGroup_ARM(subject VaultSecretGroup_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultSecretGroup_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultSecretGroup_ARM instances for property testing - lazily instantiated by
// VaultSecretGroup_ARMGenerator()
var vaultSecretGroup_ARMGenerator gopter.Gen

// VaultSecretGroup_ARMGenerator returns a generator of VaultSecretGroup_ARM instances for property testing.
func VaultSecretGroup_ARMGenerator() gopter.Gen {
	if vaultSecretGroup_ARMGenerator != nil {
		return vaultSecretGroup_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVaultSecretGroup_ARM(generators)
	vaultSecretGroup_ARMGenerator = gen.Struct(reflect.TypeOf(VaultSecretGroup_ARM{}), generators)

	return vaultSecretGroup_ARMGenerator
}

// AddRelatedPropertyGeneratorsForVaultSecretGroup_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVaultSecretGroup_ARM(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SubResource_ARMGenerator())
	gens["VaultCertificates"] = gen.SliceOf(VaultCertificate_ARMGenerator())
}

func Test_WindowsConfiguration_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WindowsConfiguration_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWindowsConfiguration_ARM, WindowsConfiguration_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWindowsConfiguration_ARM runs a test to see if a specific instance of WindowsConfiguration_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWindowsConfiguration_ARM(subject WindowsConfiguration_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WindowsConfiguration_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WindowsConfiguration_ARM instances for property testing - lazily instantiated by
// WindowsConfiguration_ARMGenerator()
var windowsConfiguration_ARMGenerator gopter.Gen

// WindowsConfiguration_ARMGenerator returns a generator of WindowsConfiguration_ARM instances for property testing.
// We first initialize windowsConfiguration_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WindowsConfiguration_ARMGenerator() gopter.Gen {
	if windowsConfiguration_ARMGenerator != nil {
		return windowsConfiguration_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsConfiguration_ARM(generators)
	windowsConfiguration_ARMGenerator = gen.Struct(reflect.TypeOf(WindowsConfiguration_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsConfiguration_ARM(generators)
	AddRelatedPropertyGeneratorsForWindowsConfiguration_ARM(generators)
	windowsConfiguration_ARMGenerator = gen.Struct(reflect.TypeOf(WindowsConfiguration_ARM{}), generators)

	return windowsConfiguration_ARMGenerator
}

// AddIndependentPropertyGeneratorsForWindowsConfiguration_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWindowsConfiguration_ARM(gens map[string]gopter.Gen) {
	gens["EnableAutomaticUpdates"] = gen.PtrOf(gen.Bool())
	gens["ProvisionVMAgent"] = gen.PtrOf(gen.Bool())
	gens["TimeZone"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForWindowsConfiguration_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWindowsConfiguration_ARM(gens map[string]gopter.Gen) {
	gens["AdditionalUnattendContent"] = gen.SliceOf(AdditionalUnattendContent_ARMGenerator())
	gens["PatchSettings"] = gen.PtrOf(PatchSettings_ARMGenerator())
	gens["WinRM"] = gen.PtrOf(WinRMConfiguration_ARMGenerator())
}

func Test_AdditionalUnattendContent_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdditionalUnattendContent_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdditionalUnattendContent_ARM, AdditionalUnattendContent_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdditionalUnattendContent_ARM runs a test to see if a specific instance of AdditionalUnattendContent_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAdditionalUnattendContent_ARM(subject AdditionalUnattendContent_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdditionalUnattendContent_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdditionalUnattendContent_ARM instances for property testing - lazily instantiated by
// AdditionalUnattendContent_ARMGenerator()
var additionalUnattendContent_ARMGenerator gopter.Gen

// AdditionalUnattendContent_ARMGenerator returns a generator of AdditionalUnattendContent_ARM instances for property testing.
func AdditionalUnattendContent_ARMGenerator() gopter.Gen {
	if additionalUnattendContent_ARMGenerator != nil {
		return additionalUnattendContent_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdditionalUnattendContent_ARM(generators)
	additionalUnattendContent_ARMGenerator = gen.Struct(reflect.TypeOf(AdditionalUnattendContent_ARM{}), generators)

	return additionalUnattendContent_ARMGenerator
}

// AddIndependentPropertyGeneratorsForAdditionalUnattendContent_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdditionalUnattendContent_ARM(gens map[string]gopter.Gen) {
	gens["ComponentName"] = gen.PtrOf(gen.OneConstOf(AdditionalUnattendContent_ComponentName_MicrosoftWindowsShellSetup))
	gens["Content"] = gen.PtrOf(gen.AlphaString())
	gens["PassName"] = gen.PtrOf(gen.OneConstOf(AdditionalUnattendContent_PassName_OobeSystem))
	gens["SettingName"] = gen.PtrOf(gen.OneConstOf(AdditionalUnattendContent_SettingName_AutoLogon, AdditionalUnattendContent_SettingName_FirstLogonCommands))
}

func Test_DiffDiskSettings_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiffDiskSettings_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiffDiskSettings_ARM, DiffDiskSettings_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiffDiskSettings_ARM runs a test to see if a specific instance of DiffDiskSettings_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiffDiskSettings_ARM(subject DiffDiskSettings_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiffDiskSettings_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiffDiskSettings_ARM instances for property testing - lazily instantiated by
// DiffDiskSettings_ARMGenerator()
var diffDiskSettings_ARMGenerator gopter.Gen

// DiffDiskSettings_ARMGenerator returns a generator of DiffDiskSettings_ARM instances for property testing.
func DiffDiskSettings_ARMGenerator() gopter.Gen {
	if diffDiskSettings_ARMGenerator != nil {
		return diffDiskSettings_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiffDiskSettings_ARM(generators)
	diffDiskSettings_ARMGenerator = gen.Struct(reflect.TypeOf(DiffDiskSettings_ARM{}), generators)

	return diffDiskSettings_ARMGenerator
}

// AddIndependentPropertyGeneratorsForDiffDiskSettings_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiffDiskSettings_ARM(gens map[string]gopter.Gen) {
	gens["Option"] = gen.PtrOf(gen.OneConstOf(DiffDiskOption_Local))
	gens["Placement"] = gen.PtrOf(gen.OneConstOf(DiffDiskPlacement_CacheDisk, DiffDiskPlacement_ResourceDisk))
}

func Test_DiskEncryptionSettings_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiskEncryptionSettings_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskEncryptionSettings_ARM, DiskEncryptionSettings_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskEncryptionSettings_ARM runs a test to see if a specific instance of DiskEncryptionSettings_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskEncryptionSettings_ARM(subject DiskEncryptionSettings_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiskEncryptionSettings_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiskEncryptionSettings_ARM instances for property testing - lazily instantiated by
// DiskEncryptionSettings_ARMGenerator()
var diskEncryptionSettings_ARMGenerator gopter.Gen

// DiskEncryptionSettings_ARMGenerator returns a generator of DiskEncryptionSettings_ARM instances for property testing.
// We first initialize diskEncryptionSettings_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DiskEncryptionSettings_ARMGenerator() gopter.Gen {
	if diskEncryptionSettings_ARMGenerator != nil {
		return diskEncryptionSettings_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskEncryptionSettings_ARM(generators)
	diskEncryptionSettings_ARMGenerator = gen.Struct(reflect.TypeOf(DiskEncryptionSettings_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskEncryptionSettings_ARM(generators)
	AddRelatedPropertyGeneratorsForDiskEncryptionSettings_ARM(generators)
	diskEncryptionSettings_ARMGenerator = gen.Struct(reflect.TypeOf(DiskEncryptionSettings_ARM{}), generators)

	return diskEncryptionSettings_ARMGenerator
}

// AddIndependentPropertyGeneratorsForDiskEncryptionSettings_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskEncryptionSettings_ARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForDiskEncryptionSettings_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiskEncryptionSettings_ARM(gens map[string]gopter.Gen) {
	gens["DiskEncryptionKey"] = gen.PtrOf(KeyVaultSecretReference_ARMGenerator())
	gens["KeyEncryptionKey"] = gen.PtrOf(KeyVaultKeyReference_ARMGenerator())
}

func Test_LinuxPatchSettings_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxPatchSettings_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxPatchSettings_ARM, LinuxPatchSettings_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxPatchSettings_ARM runs a test to see if a specific instance of LinuxPatchSettings_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxPatchSettings_ARM(subject LinuxPatchSettings_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxPatchSettings_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxPatchSettings_ARM instances for property testing - lazily instantiated by
// LinuxPatchSettings_ARMGenerator()
var linuxPatchSettings_ARMGenerator gopter.Gen

// LinuxPatchSettings_ARMGenerator returns a generator of LinuxPatchSettings_ARM instances for property testing.
func LinuxPatchSettings_ARMGenerator() gopter.Gen {
	if linuxPatchSettings_ARMGenerator != nil {
		return linuxPatchSettings_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxPatchSettings_ARM(generators)
	linuxPatchSettings_ARMGenerator = gen.Struct(reflect.TypeOf(LinuxPatchSettings_ARM{}), generators)

	return linuxPatchSettings_ARMGenerator
}

// AddIndependentPropertyGeneratorsForLinuxPatchSettings_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxPatchSettings_ARM(gens map[string]gopter.Gen) {
	gens["PatchMode"] = gen.PtrOf(gen.OneConstOf(LinuxPatchSettings_PatchMode_AutomaticByPlatform, LinuxPatchSettings_PatchMode_ImageDefault))
}

func Test_ManagedDiskParameters_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedDiskParameters_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedDiskParameters_ARM, ManagedDiskParameters_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedDiskParameters_ARM runs a test to see if a specific instance of ManagedDiskParameters_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedDiskParameters_ARM(subject ManagedDiskParameters_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedDiskParameters_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedDiskParameters_ARM instances for property testing - lazily instantiated by
// ManagedDiskParameters_ARMGenerator()
var managedDiskParameters_ARMGenerator gopter.Gen

// ManagedDiskParameters_ARMGenerator returns a generator of ManagedDiskParameters_ARM instances for property testing.
// We first initialize managedDiskParameters_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedDiskParameters_ARMGenerator() gopter.Gen {
	if managedDiskParameters_ARMGenerator != nil {
		return managedDiskParameters_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedDiskParameters_ARM(generators)
	managedDiskParameters_ARMGenerator = gen.Struct(reflect.TypeOf(ManagedDiskParameters_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedDiskParameters_ARM(generators)
	AddRelatedPropertyGeneratorsForManagedDiskParameters_ARM(generators)
	managedDiskParameters_ARMGenerator = gen.Struct(reflect.TypeOf(ManagedDiskParameters_ARM{}), generators)

	return managedDiskParameters_ARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedDiskParameters_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedDiskParameters_ARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountType"] = gen.PtrOf(gen.OneConstOf(
		StorageAccountType_Premium_LRS,
		StorageAccountType_Premium_ZRS,
		StorageAccountType_StandardSSD_LRS,
		StorageAccountType_StandardSSD_ZRS,
		StorageAccountType_Standard_LRS,
		StorageAccountType_UltraSSD_LRS))
}

// AddRelatedPropertyGeneratorsForManagedDiskParameters_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedDiskParameters_ARM(gens map[string]gopter.Gen) {
	gens["DiskEncryptionSet"] = gen.PtrOf(SubResource_ARMGenerator())
}

func Test_NetworkInterfaceReferenceProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceReferenceProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceReferenceProperties_ARM, NetworkInterfaceReferenceProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceReferenceProperties_ARM runs a test to see if a specific instance of NetworkInterfaceReferenceProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceReferenceProperties_ARM(subject NetworkInterfaceReferenceProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceReferenceProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceReferenceProperties_ARM instances for property testing - lazily instantiated by
// NetworkInterfaceReferenceProperties_ARMGenerator()
var networkInterfaceReferenceProperties_ARMGenerator gopter.Gen

// NetworkInterfaceReferenceProperties_ARMGenerator returns a generator of NetworkInterfaceReferenceProperties_ARM instances for property testing.
func NetworkInterfaceReferenceProperties_ARMGenerator() gopter.Gen {
	if networkInterfaceReferenceProperties_ARMGenerator != nil {
		return networkInterfaceReferenceProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceReferenceProperties_ARM(generators)
	networkInterfaceReferenceProperties_ARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceReferenceProperties_ARM{}), generators)

	return networkInterfaceReferenceProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceReferenceProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceReferenceProperties_ARM(gens map[string]gopter.Gen) {
	gens["Primary"] = gen.PtrOf(gen.Bool())
}

func Test_PatchSettings_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PatchSettings_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPatchSettings_ARM, PatchSettings_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPatchSettings_ARM runs a test to see if a specific instance of PatchSettings_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPatchSettings_ARM(subject PatchSettings_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PatchSettings_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PatchSettings_ARM instances for property testing - lazily instantiated by PatchSettings_ARMGenerator()
var patchSettings_ARMGenerator gopter.Gen

// PatchSettings_ARMGenerator returns a generator of PatchSettings_ARM instances for property testing.
func PatchSettings_ARMGenerator() gopter.Gen {
	if patchSettings_ARMGenerator != nil {
		return patchSettings_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPatchSettings_ARM(generators)
	patchSettings_ARMGenerator = gen.Struct(reflect.TypeOf(PatchSettings_ARM{}), generators)

	return patchSettings_ARMGenerator
}

// AddIndependentPropertyGeneratorsForPatchSettings_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPatchSettings_ARM(gens map[string]gopter.Gen) {
	gens["EnableHotpatching"] = gen.PtrOf(gen.Bool())
	gens["PatchMode"] = gen.PtrOf(gen.OneConstOf(PatchSettings_PatchMode_AutomaticByOS, PatchSettings_PatchMode_AutomaticByPlatform, PatchSettings_PatchMode_Manual))
}

func Test_SshConfiguration_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SshConfiguration_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSshConfiguration_ARM, SshConfiguration_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSshConfiguration_ARM runs a test to see if a specific instance of SshConfiguration_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSshConfiguration_ARM(subject SshConfiguration_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SshConfiguration_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SshConfiguration_ARM instances for property testing - lazily instantiated by
// SshConfiguration_ARMGenerator()
var sshConfiguration_ARMGenerator gopter.Gen

// SshConfiguration_ARMGenerator returns a generator of SshConfiguration_ARM instances for property testing.
func SshConfiguration_ARMGenerator() gopter.Gen {
	if sshConfiguration_ARMGenerator != nil {
		return sshConfiguration_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForSshConfiguration_ARM(generators)
	sshConfiguration_ARMGenerator = gen.Struct(reflect.TypeOf(SshConfiguration_ARM{}), generators)

	return sshConfiguration_ARMGenerator
}

// AddRelatedPropertyGeneratorsForSshConfiguration_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSshConfiguration_ARM(gens map[string]gopter.Gen) {
	gens["PublicKeys"] = gen.SliceOf(SshPublicKeySpec_ARMGenerator())
}

func Test_VaultCertificate_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultCertificate_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultCertificate_ARM, VaultCertificate_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultCertificate_ARM runs a test to see if a specific instance of VaultCertificate_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultCertificate_ARM(subject VaultCertificate_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultCertificate_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultCertificate_ARM instances for property testing - lazily instantiated by
// VaultCertificate_ARMGenerator()
var vaultCertificate_ARMGenerator gopter.Gen

// VaultCertificate_ARMGenerator returns a generator of VaultCertificate_ARM instances for property testing.
func VaultCertificate_ARMGenerator() gopter.Gen {
	if vaultCertificate_ARMGenerator != nil {
		return vaultCertificate_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVaultCertificate_ARM(generators)
	vaultCertificate_ARMGenerator = gen.Struct(reflect.TypeOf(VaultCertificate_ARM{}), generators)

	return vaultCertificate_ARMGenerator
}

// AddIndependentPropertyGeneratorsForVaultCertificate_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVaultCertificate_ARM(gens map[string]gopter.Gen) {
	gens["CertificateStore"] = gen.PtrOf(gen.AlphaString())
	gens["CertificateUrl"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualHardDisk_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualHardDisk_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualHardDisk_ARM, VirtualHardDisk_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualHardDisk_ARM runs a test to see if a specific instance of VirtualHardDisk_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualHardDisk_ARM(subject VirtualHardDisk_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualHardDisk_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualHardDisk_ARM instances for property testing - lazily instantiated by
// VirtualHardDisk_ARMGenerator()
var virtualHardDisk_ARMGenerator gopter.Gen

// VirtualHardDisk_ARMGenerator returns a generator of VirtualHardDisk_ARM instances for property testing.
func VirtualHardDisk_ARMGenerator() gopter.Gen {
	if virtualHardDisk_ARMGenerator != nil {
		return virtualHardDisk_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualHardDisk_ARM(generators)
	virtualHardDisk_ARMGenerator = gen.Struct(reflect.TypeOf(VirtualHardDisk_ARM{}), generators)

	return virtualHardDisk_ARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualHardDisk_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualHardDisk_ARM(gens map[string]gopter.Gen) {
	gens["Uri"] = gen.PtrOf(gen.AlphaString())
}

func Test_WinRMConfiguration_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WinRMConfiguration_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWinRMConfiguration_ARM, WinRMConfiguration_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWinRMConfiguration_ARM runs a test to see if a specific instance of WinRMConfiguration_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWinRMConfiguration_ARM(subject WinRMConfiguration_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WinRMConfiguration_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WinRMConfiguration_ARM instances for property testing - lazily instantiated by
// WinRMConfiguration_ARMGenerator()
var winRMConfiguration_ARMGenerator gopter.Gen

// WinRMConfiguration_ARMGenerator returns a generator of WinRMConfiguration_ARM instances for property testing.
func WinRMConfiguration_ARMGenerator() gopter.Gen {
	if winRMConfiguration_ARMGenerator != nil {
		return winRMConfiguration_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForWinRMConfiguration_ARM(generators)
	winRMConfiguration_ARMGenerator = gen.Struct(reflect.TypeOf(WinRMConfiguration_ARM{}), generators)

	return winRMConfiguration_ARMGenerator
}

// AddRelatedPropertyGeneratorsForWinRMConfiguration_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWinRMConfiguration_ARM(gens map[string]gopter.Gen) {
	gens["Listeners"] = gen.SliceOf(WinRMListener_ARMGenerator())
}

func Test_KeyVaultKeyReference_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultKeyReference_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultKeyReference_ARM, KeyVaultKeyReference_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultKeyReference_ARM runs a test to see if a specific instance of KeyVaultKeyReference_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultKeyReference_ARM(subject KeyVaultKeyReference_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultKeyReference_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultKeyReference_ARM instances for property testing - lazily instantiated by
// KeyVaultKeyReference_ARMGenerator()
var keyVaultKeyReference_ARMGenerator gopter.Gen

// KeyVaultKeyReference_ARMGenerator returns a generator of KeyVaultKeyReference_ARM instances for property testing.
// We first initialize keyVaultKeyReference_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultKeyReference_ARMGenerator() gopter.Gen {
	if keyVaultKeyReference_ARMGenerator != nil {
		return keyVaultKeyReference_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultKeyReference_ARM(generators)
	keyVaultKeyReference_ARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultKeyReference_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultKeyReference_ARM(generators)
	AddRelatedPropertyGeneratorsForKeyVaultKeyReference_ARM(generators)
	keyVaultKeyReference_ARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultKeyReference_ARM{}), generators)

	return keyVaultKeyReference_ARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultKeyReference_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultKeyReference_ARM(gens map[string]gopter.Gen) {
	gens["KeyUrl"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForKeyVaultKeyReference_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultKeyReference_ARM(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SubResource_ARMGenerator())
}

func Test_KeyVaultSecretReference_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultSecretReference_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultSecretReference_ARM, KeyVaultSecretReference_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultSecretReference_ARM runs a test to see if a specific instance of KeyVaultSecretReference_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultSecretReference_ARM(subject KeyVaultSecretReference_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultSecretReference_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultSecretReference_ARM instances for property testing - lazily instantiated by
// KeyVaultSecretReference_ARMGenerator()
var keyVaultSecretReference_ARMGenerator gopter.Gen

// KeyVaultSecretReference_ARMGenerator returns a generator of KeyVaultSecretReference_ARM instances for property testing.
// We first initialize keyVaultSecretReference_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultSecretReference_ARMGenerator() gopter.Gen {
	if keyVaultSecretReference_ARMGenerator != nil {
		return keyVaultSecretReference_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultSecretReference_ARM(generators)
	keyVaultSecretReference_ARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultSecretReference_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultSecretReference_ARM(generators)
	AddRelatedPropertyGeneratorsForKeyVaultSecretReference_ARM(generators)
	keyVaultSecretReference_ARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultSecretReference_ARM{}), generators)

	return keyVaultSecretReference_ARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultSecretReference_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultSecretReference_ARM(gens map[string]gopter.Gen) {
	gens["SecretUrl"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForKeyVaultSecretReference_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultSecretReference_ARM(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SubResource_ARMGenerator())
}

func Test_SshPublicKeySpec_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SshPublicKeySpec_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSshPublicKeySpec_ARM, SshPublicKeySpec_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSshPublicKeySpec_ARM runs a test to see if a specific instance of SshPublicKeySpec_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSshPublicKeySpec_ARM(subject SshPublicKeySpec_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SshPublicKeySpec_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SshPublicKeySpec_ARM instances for property testing - lazily instantiated by
// SshPublicKeySpec_ARMGenerator()
var sshPublicKeySpec_ARMGenerator gopter.Gen

// SshPublicKeySpec_ARMGenerator returns a generator of SshPublicKeySpec_ARM instances for property testing.
func SshPublicKeySpec_ARMGenerator() gopter.Gen {
	if sshPublicKeySpec_ARMGenerator != nil {
		return sshPublicKeySpec_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSshPublicKeySpec_ARM(generators)
	sshPublicKeySpec_ARMGenerator = gen.Struct(reflect.TypeOf(SshPublicKeySpec_ARM{}), generators)

	return sshPublicKeySpec_ARMGenerator
}

// AddIndependentPropertyGeneratorsForSshPublicKeySpec_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSshPublicKeySpec_ARM(gens map[string]gopter.Gen) {
	gens["KeyData"] = gen.PtrOf(gen.AlphaString())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
}

func Test_WinRMListener_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WinRMListener_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWinRMListener_ARM, WinRMListener_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWinRMListener_ARM runs a test to see if a specific instance of WinRMListener_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWinRMListener_ARM(subject WinRMListener_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WinRMListener_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WinRMListener_ARM instances for property testing - lazily instantiated by WinRMListener_ARMGenerator()
var winRMListener_ARMGenerator gopter.Gen

// WinRMListener_ARMGenerator returns a generator of WinRMListener_ARM instances for property testing.
func WinRMListener_ARMGenerator() gopter.Gen {
	if winRMListener_ARMGenerator != nil {
		return winRMListener_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWinRMListener_ARM(generators)
	winRMListener_ARMGenerator = gen.Struct(reflect.TypeOf(WinRMListener_ARM{}), generators)

	return winRMListener_ARMGenerator
}

// AddIndependentPropertyGeneratorsForWinRMListener_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWinRMListener_ARM(gens map[string]gopter.Gen) {
	gens["CertificateUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(WinRMListener_Protocol_Http, WinRMListener_Protocol_Https))
}
