// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20201201

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_VirtualMachine_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachine_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineSTATUSARM, VirtualMachineSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineSTATUSARM runs a test to see if a specific instance of VirtualMachine_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineSTATUSARM(subject VirtualMachine_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachine_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachine_STATUSARM instances for property testing - lazily instantiated by
// VirtualMachineSTATUSARMGenerator()
var virtualMachineSTATUSARMGenerator gopter.Gen

// VirtualMachineSTATUSARMGenerator returns a generator of VirtualMachine_STATUSARM instances for property testing.
// We first initialize virtualMachineSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineSTATUSARMGenerator() gopter.Gen {
	if virtualMachineSTATUSARMGenerator != nil {
		return virtualMachineSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineSTATUSARM(generators)
	virtualMachineSTATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachine_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineSTATUSARM(generators)
	virtualMachineSTATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachine_STATUSARM{}), generators)

	return virtualMachineSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineSTATUSARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineSTATUSARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationSTATUSARMGenerator())
	gens["Identity"] = gen.PtrOf(VirtualMachineIdentitySTATUSARMGenerator())
	gens["Plan"] = gen.PtrOf(PlanSTATUSARMGenerator())
	gens["Properties"] = gen.PtrOf(VirtualMachinePropertiesSTATUSARMGenerator())
	gens["Resources"] = gen.SliceOf(VirtualMachineExtensionSTATUSARMGenerator())
}

func Test_VirtualMachineExtension_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineExtension_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineExtensionSTATUSARM, VirtualMachineExtensionSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineExtensionSTATUSARM runs a test to see if a specific instance of VirtualMachineExtension_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineExtensionSTATUSARM(subject VirtualMachineExtension_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineExtension_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineExtension_STATUSARM instances for property testing - lazily instantiated by
// VirtualMachineExtensionSTATUSARMGenerator()
var virtualMachineExtensionSTATUSARMGenerator gopter.Gen

// VirtualMachineExtensionSTATUSARMGenerator returns a generator of VirtualMachineExtension_STATUSARM instances for property testing.
// We first initialize virtualMachineExtensionSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineExtensionSTATUSARMGenerator() gopter.Gen {
	if virtualMachineExtensionSTATUSARMGenerator != nil {
		return virtualMachineExtensionSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionSTATUSARM(generators)
	virtualMachineExtensionSTATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtension_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineExtensionSTATUSARM(generators)
	virtualMachineExtensionSTATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtension_STATUSARM{}), generators)

	return virtualMachineExtensionSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineExtensionSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineExtensionSTATUSARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineExtensionSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineExtensionSTATUSARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(VirtualMachineExtensionPropertiesSTATUSARMGenerator())
}

func Test_VirtualMachineIdentity_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineIdentity_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineIdentitySTATUSARM, VirtualMachineIdentitySTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineIdentitySTATUSARM runs a test to see if a specific instance of VirtualMachineIdentity_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineIdentitySTATUSARM(subject VirtualMachineIdentity_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineIdentity_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineIdentity_STATUSARM instances for property testing - lazily instantiated by
// VirtualMachineIdentitySTATUSARMGenerator()
var virtualMachineIdentitySTATUSARMGenerator gopter.Gen

// VirtualMachineIdentitySTATUSARMGenerator returns a generator of VirtualMachineIdentity_STATUSARM instances for property testing.
func VirtualMachineIdentitySTATUSARMGenerator() gopter.Gen {
	if virtualMachineIdentitySTATUSARMGenerator != nil {
		return virtualMachineIdentitySTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineIdentitySTATUSARM(generators)
	virtualMachineIdentitySTATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineIdentity_STATUSARM{}), generators)

	return virtualMachineIdentitySTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineIdentitySTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineIdentitySTATUSARM(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		VirtualMachineIdentitySTATUSType_None,
		VirtualMachineIdentitySTATUSType_SystemAssigned,
		VirtualMachineIdentitySTATUSType_SystemAssignedUserAssigned,
		VirtualMachineIdentitySTATUSType_UserAssigned))
}

func Test_VirtualMachineProperties_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineProperties_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachinePropertiesSTATUSARM, VirtualMachinePropertiesSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachinePropertiesSTATUSARM runs a test to see if a specific instance of VirtualMachineProperties_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachinePropertiesSTATUSARM(subject VirtualMachineProperties_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineProperties_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineProperties_STATUSARM instances for property testing - lazily instantiated by
// VirtualMachinePropertiesSTATUSARMGenerator()
var virtualMachinePropertiesSTATUSARMGenerator gopter.Gen

// VirtualMachinePropertiesSTATUSARMGenerator returns a generator of VirtualMachineProperties_STATUSARM instances for property testing.
// We first initialize virtualMachinePropertiesSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachinePropertiesSTATUSARMGenerator() gopter.Gen {
	if virtualMachinePropertiesSTATUSARMGenerator != nil {
		return virtualMachinePropertiesSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinePropertiesSTATUSARM(generators)
	virtualMachinePropertiesSTATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineProperties_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinePropertiesSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachinePropertiesSTATUSARM(generators)
	virtualMachinePropertiesSTATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineProperties_STATUSARM{}), generators)

	return virtualMachinePropertiesSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachinePropertiesSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachinePropertiesSTATUSARM(gens map[string]gopter.Gen) {
	gens["EvictionPolicy"] = gen.PtrOf(gen.OneConstOf(EvictionPolicy_STATUS_Deallocate, EvictionPolicy_STATUS_Delete))
	gens["ExtensionsTimeBudget"] = gen.PtrOf(gen.AlphaString())
	gens["LicenseType"] = gen.PtrOf(gen.AlphaString())
	gens["PlatformFaultDomain"] = gen.PtrOf(gen.Int())
	gens["Priority"] = gen.PtrOf(gen.OneConstOf(Priority_STATUS_Low, Priority_STATUS_Regular, Priority_STATUS_Spot))
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["VmId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachinePropertiesSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachinePropertiesSTATUSARM(gens map[string]gopter.Gen) {
	gens["AdditionalCapabilities"] = gen.PtrOf(AdditionalCapabilitiesSTATUSARMGenerator())
	gens["AvailabilitySet"] = gen.PtrOf(SubResourceSTATUSARMGenerator())
	gens["BillingProfile"] = gen.PtrOf(BillingProfileSTATUSARMGenerator())
	gens["DiagnosticsProfile"] = gen.PtrOf(DiagnosticsProfileSTATUSARMGenerator())
	gens["HardwareProfile"] = gen.PtrOf(HardwareProfileSTATUSARMGenerator())
	gens["Host"] = gen.PtrOf(SubResourceSTATUSARMGenerator())
	gens["HostGroup"] = gen.PtrOf(SubResourceSTATUSARMGenerator())
	gens["InstanceView"] = gen.PtrOf(VirtualMachineInstanceViewSTATUSARMGenerator())
	gens["NetworkProfile"] = gen.PtrOf(NetworkProfileSTATUSARMGenerator())
	gens["OsProfile"] = gen.PtrOf(OSProfileSTATUSARMGenerator())
	gens["ProximityPlacementGroup"] = gen.PtrOf(SubResourceSTATUSARMGenerator())
	gens["SecurityProfile"] = gen.PtrOf(SecurityProfileSTATUSARMGenerator())
	gens["StorageProfile"] = gen.PtrOf(StorageProfileSTATUSARMGenerator())
	gens["VirtualMachineScaleSet"] = gen.PtrOf(SubResourceSTATUSARMGenerator())
}

func Test_BillingProfile_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BillingProfile_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBillingProfileSTATUSARM, BillingProfileSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBillingProfileSTATUSARM runs a test to see if a specific instance of BillingProfile_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBillingProfileSTATUSARM(subject BillingProfile_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BillingProfile_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BillingProfile_STATUSARM instances for property testing - lazily instantiated by
// BillingProfileSTATUSARMGenerator()
var billingProfileSTATUSARMGenerator gopter.Gen

// BillingProfileSTATUSARMGenerator returns a generator of BillingProfile_STATUSARM instances for property testing.
func BillingProfileSTATUSARMGenerator() gopter.Gen {
	if billingProfileSTATUSARMGenerator != nil {
		return billingProfileSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBillingProfileSTATUSARM(generators)
	billingProfileSTATUSARMGenerator = gen.Struct(reflect.TypeOf(BillingProfile_STATUSARM{}), generators)

	return billingProfileSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForBillingProfileSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBillingProfileSTATUSARM(gens map[string]gopter.Gen) {
	gens["MaxPrice"] = gen.PtrOf(gen.Float64())
}

func Test_DiagnosticsProfile_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiagnosticsProfile_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiagnosticsProfileSTATUSARM, DiagnosticsProfileSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiagnosticsProfileSTATUSARM runs a test to see if a specific instance of DiagnosticsProfile_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiagnosticsProfileSTATUSARM(subject DiagnosticsProfile_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiagnosticsProfile_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiagnosticsProfile_STATUSARM instances for property testing - lazily instantiated by
// DiagnosticsProfileSTATUSARMGenerator()
var diagnosticsProfileSTATUSARMGenerator gopter.Gen

// DiagnosticsProfileSTATUSARMGenerator returns a generator of DiagnosticsProfile_STATUSARM instances for property testing.
func DiagnosticsProfileSTATUSARMGenerator() gopter.Gen {
	if diagnosticsProfileSTATUSARMGenerator != nil {
		return diagnosticsProfileSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDiagnosticsProfileSTATUSARM(generators)
	diagnosticsProfileSTATUSARMGenerator = gen.Struct(reflect.TypeOf(DiagnosticsProfile_STATUSARM{}), generators)

	return diagnosticsProfileSTATUSARMGenerator
}

// AddRelatedPropertyGeneratorsForDiagnosticsProfileSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiagnosticsProfileSTATUSARM(gens map[string]gopter.Gen) {
	gens["BootDiagnostics"] = gen.PtrOf(BootDiagnosticsSTATUSARMGenerator())
}

func Test_HardwareProfile_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HardwareProfile_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHardwareProfileSTATUSARM, HardwareProfileSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHardwareProfileSTATUSARM runs a test to see if a specific instance of HardwareProfile_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHardwareProfileSTATUSARM(subject HardwareProfile_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HardwareProfile_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HardwareProfile_STATUSARM instances for property testing - lazily instantiated by
// HardwareProfileSTATUSARMGenerator()
var hardwareProfileSTATUSARMGenerator gopter.Gen

// HardwareProfileSTATUSARMGenerator returns a generator of HardwareProfile_STATUSARM instances for property testing.
func HardwareProfileSTATUSARMGenerator() gopter.Gen {
	if hardwareProfileSTATUSARMGenerator != nil {
		return hardwareProfileSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHardwareProfileSTATUSARM(generators)
	hardwareProfileSTATUSARMGenerator = gen.Struct(reflect.TypeOf(HardwareProfile_STATUSARM{}), generators)

	return hardwareProfileSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForHardwareProfileSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHardwareProfileSTATUSARM(gens map[string]gopter.Gen) {
	gens["VmSize"] = gen.PtrOf(gen.OneConstOf(
		HardwareProfileSTATUSVmSize_BasicA0,
		HardwareProfileSTATUSVmSize_BasicA1,
		HardwareProfileSTATUSVmSize_BasicA2,
		HardwareProfileSTATUSVmSize_BasicA3,
		HardwareProfileSTATUSVmSize_BasicA4,
		HardwareProfileSTATUSVmSize_StandardA0,
		HardwareProfileSTATUSVmSize_StandardA1,
		HardwareProfileSTATUSVmSize_StandardA10,
		HardwareProfileSTATUSVmSize_StandardA11,
		HardwareProfileSTATUSVmSize_StandardA1V2,
		HardwareProfileSTATUSVmSize_StandardA2,
		HardwareProfileSTATUSVmSize_StandardA2MV2,
		HardwareProfileSTATUSVmSize_StandardA2V2,
		HardwareProfileSTATUSVmSize_StandardA3,
		HardwareProfileSTATUSVmSize_StandardA4,
		HardwareProfileSTATUSVmSize_StandardA4MV2,
		HardwareProfileSTATUSVmSize_StandardA4V2,
		HardwareProfileSTATUSVmSize_StandardA5,
		HardwareProfileSTATUSVmSize_StandardA6,
		HardwareProfileSTATUSVmSize_StandardA7,
		HardwareProfileSTATUSVmSize_StandardA8,
		HardwareProfileSTATUSVmSize_StandardA8MV2,
		HardwareProfileSTATUSVmSize_StandardA8V2,
		HardwareProfileSTATUSVmSize_StandardA9,
		HardwareProfileSTATUSVmSize_StandardB1Ms,
		HardwareProfileSTATUSVmSize_StandardB1S,
		HardwareProfileSTATUSVmSize_StandardB2Ms,
		HardwareProfileSTATUSVmSize_StandardB2S,
		HardwareProfileSTATUSVmSize_StandardB4Ms,
		HardwareProfileSTATUSVmSize_StandardB8Ms,
		HardwareProfileSTATUSVmSize_StandardD1,
		HardwareProfileSTATUSVmSize_StandardD11,
		HardwareProfileSTATUSVmSize_StandardD11V2,
		HardwareProfileSTATUSVmSize_StandardD12,
		HardwareProfileSTATUSVmSize_StandardD12V2,
		HardwareProfileSTATUSVmSize_StandardD13,
		HardwareProfileSTATUSVmSize_StandardD13V2,
		HardwareProfileSTATUSVmSize_StandardD14,
		HardwareProfileSTATUSVmSize_StandardD14V2,
		HardwareProfileSTATUSVmSize_StandardD15V2,
		HardwareProfileSTATUSVmSize_StandardD16SV3,
		HardwareProfileSTATUSVmSize_StandardD16V3,
		HardwareProfileSTATUSVmSize_StandardD1V2,
		HardwareProfileSTATUSVmSize_StandardD2,
		HardwareProfileSTATUSVmSize_StandardD2SV3,
		HardwareProfileSTATUSVmSize_StandardD2V2,
		HardwareProfileSTATUSVmSize_StandardD2V3,
		HardwareProfileSTATUSVmSize_StandardD3,
		HardwareProfileSTATUSVmSize_StandardD32SV3,
		HardwareProfileSTATUSVmSize_StandardD32V3,
		HardwareProfileSTATUSVmSize_StandardD3V2,
		HardwareProfileSTATUSVmSize_StandardD4,
		HardwareProfileSTATUSVmSize_StandardD4SV3,
		HardwareProfileSTATUSVmSize_StandardD4V2,
		HardwareProfileSTATUSVmSize_StandardD4V3,
		HardwareProfileSTATUSVmSize_StandardD5V2,
		HardwareProfileSTATUSVmSize_StandardD64SV3,
		HardwareProfileSTATUSVmSize_StandardD64V3,
		HardwareProfileSTATUSVmSize_StandardD8SV3,
		HardwareProfileSTATUSVmSize_StandardD8V3,
		HardwareProfileSTATUSVmSize_StandardDS1,
		HardwareProfileSTATUSVmSize_StandardDS11,
		HardwareProfileSTATUSVmSize_StandardDS11V2,
		HardwareProfileSTATUSVmSize_StandardDS12,
		HardwareProfileSTATUSVmSize_StandardDS12V2,
		HardwareProfileSTATUSVmSize_StandardDS13,
		HardwareProfileSTATUSVmSize_StandardDS132V2,
		HardwareProfileSTATUSVmSize_StandardDS134V2,
		HardwareProfileSTATUSVmSize_StandardDS13V2,
		HardwareProfileSTATUSVmSize_StandardDS14,
		HardwareProfileSTATUSVmSize_StandardDS144V2,
		HardwareProfileSTATUSVmSize_StandardDS148V2,
		HardwareProfileSTATUSVmSize_StandardDS14V2,
		HardwareProfileSTATUSVmSize_StandardDS15V2,
		HardwareProfileSTATUSVmSize_StandardDS1V2,
		HardwareProfileSTATUSVmSize_StandardDS2,
		HardwareProfileSTATUSVmSize_StandardDS2V2,
		HardwareProfileSTATUSVmSize_StandardDS3,
		HardwareProfileSTATUSVmSize_StandardDS3V2,
		HardwareProfileSTATUSVmSize_StandardDS4,
		HardwareProfileSTATUSVmSize_StandardDS4V2,
		HardwareProfileSTATUSVmSize_StandardDS5V2,
		HardwareProfileSTATUSVmSize_StandardE16SV3,
		HardwareProfileSTATUSVmSize_StandardE16V3,
		HardwareProfileSTATUSVmSize_StandardE2SV3,
		HardwareProfileSTATUSVmSize_StandardE2V3,
		HardwareProfileSTATUSVmSize_StandardE3216V3,
		HardwareProfileSTATUSVmSize_StandardE328SV3,
		HardwareProfileSTATUSVmSize_StandardE32SV3,
		HardwareProfileSTATUSVmSize_StandardE32V3,
		HardwareProfileSTATUSVmSize_StandardE4SV3,
		HardwareProfileSTATUSVmSize_StandardE4V3,
		HardwareProfileSTATUSVmSize_StandardE6416SV3,
		HardwareProfileSTATUSVmSize_StandardE6432SV3,
		HardwareProfileSTATUSVmSize_StandardE64SV3,
		HardwareProfileSTATUSVmSize_StandardE64V3,
		HardwareProfileSTATUSVmSize_StandardE8SV3,
		HardwareProfileSTATUSVmSize_StandardE8V3,
		HardwareProfileSTATUSVmSize_StandardF1,
		HardwareProfileSTATUSVmSize_StandardF16,
		HardwareProfileSTATUSVmSize_StandardF16S,
		HardwareProfileSTATUSVmSize_StandardF16SV2,
		HardwareProfileSTATUSVmSize_StandardF1S,
		HardwareProfileSTATUSVmSize_StandardF2,
		HardwareProfileSTATUSVmSize_StandardF2S,
		HardwareProfileSTATUSVmSize_StandardF2SV2,
		HardwareProfileSTATUSVmSize_StandardF32SV2,
		HardwareProfileSTATUSVmSize_StandardF4,
		HardwareProfileSTATUSVmSize_StandardF4S,
		HardwareProfileSTATUSVmSize_StandardF4SV2,
		HardwareProfileSTATUSVmSize_StandardF64SV2,
		HardwareProfileSTATUSVmSize_StandardF72SV2,
		HardwareProfileSTATUSVmSize_StandardF8,
		HardwareProfileSTATUSVmSize_StandardF8S,
		HardwareProfileSTATUSVmSize_StandardF8SV2,
		HardwareProfileSTATUSVmSize_StandardG1,
		HardwareProfileSTATUSVmSize_StandardG2,
		HardwareProfileSTATUSVmSize_StandardG3,
		HardwareProfileSTATUSVmSize_StandardG4,
		HardwareProfileSTATUSVmSize_StandardG5,
		HardwareProfileSTATUSVmSize_StandardGS1,
		HardwareProfileSTATUSVmSize_StandardGS2,
		HardwareProfileSTATUSVmSize_StandardGS3,
		HardwareProfileSTATUSVmSize_StandardGS4,
		HardwareProfileSTATUSVmSize_StandardGS44,
		HardwareProfileSTATUSVmSize_StandardGS48,
		HardwareProfileSTATUSVmSize_StandardGS5,
		HardwareProfileSTATUSVmSize_StandardGS516,
		HardwareProfileSTATUSVmSize_StandardGS58,
		HardwareProfileSTATUSVmSize_StandardH16,
		HardwareProfileSTATUSVmSize_StandardH16M,
		HardwareProfileSTATUSVmSize_StandardH16Mr,
		HardwareProfileSTATUSVmSize_StandardH16R,
		HardwareProfileSTATUSVmSize_StandardH8,
		HardwareProfileSTATUSVmSize_StandardH8M,
		HardwareProfileSTATUSVmSize_StandardL16S,
		HardwareProfileSTATUSVmSize_StandardL32S,
		HardwareProfileSTATUSVmSize_StandardL4S,
		HardwareProfileSTATUSVmSize_StandardL8S,
		HardwareProfileSTATUSVmSize_StandardM12832Ms,
		HardwareProfileSTATUSVmSize_StandardM12864Ms,
		HardwareProfileSTATUSVmSize_StandardM128Ms,
		HardwareProfileSTATUSVmSize_StandardM128S,
		HardwareProfileSTATUSVmSize_StandardM6416Ms,
		HardwareProfileSTATUSVmSize_StandardM6432Ms,
		HardwareProfileSTATUSVmSize_StandardM64Ms,
		HardwareProfileSTATUSVmSize_StandardM64S,
		HardwareProfileSTATUSVmSize_StandardNC12,
		HardwareProfileSTATUSVmSize_StandardNC12SV2,
		HardwareProfileSTATUSVmSize_StandardNC12SV3,
		HardwareProfileSTATUSVmSize_StandardNC24,
		HardwareProfileSTATUSVmSize_StandardNC24R,
		HardwareProfileSTATUSVmSize_StandardNC24RsV2,
		HardwareProfileSTATUSVmSize_StandardNC24RsV3,
		HardwareProfileSTATUSVmSize_StandardNC24SV2,
		HardwareProfileSTATUSVmSize_StandardNC24SV3,
		HardwareProfileSTATUSVmSize_StandardNC6,
		HardwareProfileSTATUSVmSize_StandardNC6SV2,
		HardwareProfileSTATUSVmSize_StandardNC6SV3,
		HardwareProfileSTATUSVmSize_StandardND12S,
		HardwareProfileSTATUSVmSize_StandardND24Rs,
		HardwareProfileSTATUSVmSize_StandardND24S,
		HardwareProfileSTATUSVmSize_StandardND6S,
		HardwareProfileSTATUSVmSize_StandardNV12,
		HardwareProfileSTATUSVmSize_StandardNV24,
		HardwareProfileSTATUSVmSize_StandardNV6))
}

func Test_NetworkProfile_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkProfile_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkProfileSTATUSARM, NetworkProfileSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkProfileSTATUSARM runs a test to see if a specific instance of NetworkProfile_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkProfileSTATUSARM(subject NetworkProfile_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkProfile_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkProfile_STATUSARM instances for property testing - lazily instantiated by
// NetworkProfileSTATUSARMGenerator()
var networkProfileSTATUSARMGenerator gopter.Gen

// NetworkProfileSTATUSARMGenerator returns a generator of NetworkProfile_STATUSARM instances for property testing.
func NetworkProfileSTATUSARMGenerator() gopter.Gen {
	if networkProfileSTATUSARMGenerator != nil {
		return networkProfileSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForNetworkProfileSTATUSARM(generators)
	networkProfileSTATUSARMGenerator = gen.Struct(reflect.TypeOf(NetworkProfile_STATUSARM{}), generators)

	return networkProfileSTATUSARMGenerator
}

// AddRelatedPropertyGeneratorsForNetworkProfileSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkProfileSTATUSARM(gens map[string]gopter.Gen) {
	gens["NetworkInterfaces"] = gen.SliceOf(NetworkInterfaceReferenceSTATUSARMGenerator())
}

func Test_OSProfile_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OSProfile_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOSProfileSTATUSARM, OSProfileSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOSProfileSTATUSARM runs a test to see if a specific instance of OSProfile_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOSProfileSTATUSARM(subject OSProfile_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OSProfile_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OSProfile_STATUSARM instances for property testing - lazily instantiated by OSProfileSTATUSARMGenerator()
var osProfileSTATUSARMGenerator gopter.Gen

// OSProfileSTATUSARMGenerator returns a generator of OSProfile_STATUSARM instances for property testing.
// We first initialize osProfileSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OSProfileSTATUSARMGenerator() gopter.Gen {
	if osProfileSTATUSARMGenerator != nil {
		return osProfileSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSProfileSTATUSARM(generators)
	osProfileSTATUSARMGenerator = gen.Struct(reflect.TypeOf(OSProfile_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSProfileSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForOSProfileSTATUSARM(generators)
	osProfileSTATUSARMGenerator = gen.Struct(reflect.TypeOf(OSProfile_STATUSARM{}), generators)

	return osProfileSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForOSProfileSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOSProfileSTATUSARM(gens map[string]gopter.Gen) {
	gens["AdminUsername"] = gen.PtrOf(gen.AlphaString())
	gens["AllowExtensionOperations"] = gen.PtrOf(gen.Bool())
	gens["ComputerName"] = gen.PtrOf(gen.AlphaString())
	gens["CustomData"] = gen.PtrOf(gen.AlphaString())
	gens["RequireGuestProvisionSignal"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForOSProfileSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOSProfileSTATUSARM(gens map[string]gopter.Gen) {
	gens["LinuxConfiguration"] = gen.PtrOf(LinuxConfigurationSTATUSARMGenerator())
	gens["Secrets"] = gen.SliceOf(VaultSecretGroupSTATUSARMGenerator())
	gens["WindowsConfiguration"] = gen.PtrOf(WindowsConfigurationSTATUSARMGenerator())
}

func Test_SecurityProfile_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SecurityProfile_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSecurityProfileSTATUSARM, SecurityProfileSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSecurityProfileSTATUSARM runs a test to see if a specific instance of SecurityProfile_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSecurityProfileSTATUSARM(subject SecurityProfile_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SecurityProfile_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SecurityProfile_STATUSARM instances for property testing - lazily instantiated by
// SecurityProfileSTATUSARMGenerator()
var securityProfileSTATUSARMGenerator gopter.Gen

// SecurityProfileSTATUSARMGenerator returns a generator of SecurityProfile_STATUSARM instances for property testing.
// We first initialize securityProfileSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SecurityProfileSTATUSARMGenerator() gopter.Gen {
	if securityProfileSTATUSARMGenerator != nil {
		return securityProfileSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecurityProfileSTATUSARM(generators)
	securityProfileSTATUSARMGenerator = gen.Struct(reflect.TypeOf(SecurityProfile_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecurityProfileSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForSecurityProfileSTATUSARM(generators)
	securityProfileSTATUSARMGenerator = gen.Struct(reflect.TypeOf(SecurityProfile_STATUSARM{}), generators)

	return securityProfileSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForSecurityProfileSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSecurityProfileSTATUSARM(gens map[string]gopter.Gen) {
	gens["EncryptionAtHost"] = gen.PtrOf(gen.Bool())
	gens["SecurityType"] = gen.PtrOf(gen.OneConstOf(SecurityProfileSTATUSSecurityType_TrustedLaunch))
}

// AddRelatedPropertyGeneratorsForSecurityProfileSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSecurityProfileSTATUSARM(gens map[string]gopter.Gen) {
	gens["UefiSettings"] = gen.PtrOf(UefiSettingsSTATUSARMGenerator())
}

func Test_StorageProfile_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageProfile_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageProfileSTATUSARM, StorageProfileSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageProfileSTATUSARM runs a test to see if a specific instance of StorageProfile_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageProfileSTATUSARM(subject StorageProfile_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageProfile_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageProfile_STATUSARM instances for property testing - lazily instantiated by
// StorageProfileSTATUSARMGenerator()
var storageProfileSTATUSARMGenerator gopter.Gen

// StorageProfileSTATUSARMGenerator returns a generator of StorageProfile_STATUSARM instances for property testing.
func StorageProfileSTATUSARMGenerator() gopter.Gen {
	if storageProfileSTATUSARMGenerator != nil {
		return storageProfileSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForStorageProfileSTATUSARM(generators)
	storageProfileSTATUSARMGenerator = gen.Struct(reflect.TypeOf(StorageProfile_STATUSARM{}), generators)

	return storageProfileSTATUSARMGenerator
}

// AddRelatedPropertyGeneratorsForStorageProfileSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageProfileSTATUSARM(gens map[string]gopter.Gen) {
	gens["DataDisks"] = gen.SliceOf(DataDiskSTATUSARMGenerator())
	gens["ImageReference"] = gen.PtrOf(ImageReferenceSTATUSARMGenerator())
	gens["OsDisk"] = gen.PtrOf(OSDiskSTATUSARMGenerator())
}

func Test_VirtualMachineExtensionProperties_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineExtensionProperties_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineExtensionPropertiesSTATUSARM, VirtualMachineExtensionPropertiesSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineExtensionPropertiesSTATUSARM runs a test to see if a specific instance of VirtualMachineExtensionProperties_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineExtensionPropertiesSTATUSARM(subject VirtualMachineExtensionProperties_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineExtensionProperties_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineExtensionProperties_STATUSARM instances for property testing - lazily instantiated by
// VirtualMachineExtensionPropertiesSTATUSARMGenerator()
var virtualMachineExtensionPropertiesSTATUSARMGenerator gopter.Gen

// VirtualMachineExtensionPropertiesSTATUSARMGenerator returns a generator of VirtualMachineExtensionProperties_STATUSARM instances for property testing.
// We first initialize virtualMachineExtensionPropertiesSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineExtensionPropertiesSTATUSARMGenerator() gopter.Gen {
	if virtualMachineExtensionPropertiesSTATUSARMGenerator != nil {
		return virtualMachineExtensionPropertiesSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionPropertiesSTATUSARM(generators)
	virtualMachineExtensionPropertiesSTATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtensionProperties_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionPropertiesSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineExtensionPropertiesSTATUSARM(generators)
	virtualMachineExtensionPropertiesSTATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtensionProperties_STATUSARM{}), generators)

	return virtualMachineExtensionPropertiesSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineExtensionPropertiesSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineExtensionPropertiesSTATUSARM(gens map[string]gopter.Gen) {
	gens["AutoUpgradeMinorVersion"] = gen.PtrOf(gen.Bool())
	gens["EnableAutomaticUpgrade"] = gen.PtrOf(gen.Bool())
	gens["ForceUpdateTag"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["TypeHandlerVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineExtensionPropertiesSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineExtensionPropertiesSTATUSARM(gens map[string]gopter.Gen) {
	gens["InstanceView"] = gen.PtrOf(VirtualMachineExtensionInstanceViewSTATUSARMGenerator())
}

func Test_VirtualMachineInstanceView_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineInstanceView_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineInstanceViewSTATUSARM, VirtualMachineInstanceViewSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineInstanceViewSTATUSARM runs a test to see if a specific instance of VirtualMachineInstanceView_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineInstanceViewSTATUSARM(subject VirtualMachineInstanceView_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineInstanceView_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineInstanceView_STATUSARM instances for property testing - lazily instantiated by
// VirtualMachineInstanceViewSTATUSARMGenerator()
var virtualMachineInstanceViewSTATUSARMGenerator gopter.Gen

// VirtualMachineInstanceViewSTATUSARMGenerator returns a generator of VirtualMachineInstanceView_STATUSARM instances for property testing.
// We first initialize virtualMachineInstanceViewSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineInstanceViewSTATUSARMGenerator() gopter.Gen {
	if virtualMachineInstanceViewSTATUSARMGenerator != nil {
		return virtualMachineInstanceViewSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineInstanceViewSTATUSARM(generators)
	virtualMachineInstanceViewSTATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineInstanceView_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineInstanceViewSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineInstanceViewSTATUSARM(generators)
	virtualMachineInstanceViewSTATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineInstanceView_STATUSARM{}), generators)

	return virtualMachineInstanceViewSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineInstanceViewSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineInstanceViewSTATUSARM(gens map[string]gopter.Gen) {
	gens["AssignedHost"] = gen.PtrOf(gen.AlphaString())
	gens["ComputerName"] = gen.PtrOf(gen.AlphaString())
	gens["HyperVGeneration"] = gen.PtrOf(gen.OneConstOf(VirtualMachineInstanceViewSTATUSHyperVGeneration_V1, VirtualMachineInstanceViewSTATUSHyperVGeneration_V2))
	gens["OsName"] = gen.PtrOf(gen.AlphaString())
	gens["OsVersion"] = gen.PtrOf(gen.AlphaString())
	gens["PlatformFaultDomain"] = gen.PtrOf(gen.Int())
	gens["PlatformUpdateDomain"] = gen.PtrOf(gen.Int())
	gens["RdpThumbPrint"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineInstanceViewSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineInstanceViewSTATUSARM(gens map[string]gopter.Gen) {
	gens["BootDiagnostics"] = gen.PtrOf(BootDiagnosticsInstanceViewSTATUSARMGenerator())
	gens["Disks"] = gen.SliceOf(DiskInstanceViewSTATUSARMGenerator())
	gens["Extensions"] = gen.SliceOf(VirtualMachineExtensionInstanceViewSTATUSARMGenerator())
	gens["MaintenanceRedeployStatus"] = gen.PtrOf(MaintenanceRedeployStatusSTATUSARMGenerator())
	gens["PatchStatus"] = gen.PtrOf(VirtualMachinePatchStatusSTATUSARMGenerator())
	gens["Statuses"] = gen.SliceOf(InstanceViewStatusSTATUSARMGenerator())
	gens["VmAgent"] = gen.PtrOf(VirtualMachineAgentInstanceViewSTATUSARMGenerator())
	gens["VmHealth"] = gen.PtrOf(VirtualMachineHealthStatusSTATUSARMGenerator())
}

func Test_BootDiagnostics_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BootDiagnostics_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBootDiagnosticsSTATUSARM, BootDiagnosticsSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBootDiagnosticsSTATUSARM runs a test to see if a specific instance of BootDiagnostics_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBootDiagnosticsSTATUSARM(subject BootDiagnostics_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BootDiagnostics_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BootDiagnostics_STATUSARM instances for property testing - lazily instantiated by
// BootDiagnosticsSTATUSARMGenerator()
var bootDiagnosticsSTATUSARMGenerator gopter.Gen

// BootDiagnosticsSTATUSARMGenerator returns a generator of BootDiagnostics_STATUSARM instances for property testing.
func BootDiagnosticsSTATUSARMGenerator() gopter.Gen {
	if bootDiagnosticsSTATUSARMGenerator != nil {
		return bootDiagnosticsSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBootDiagnosticsSTATUSARM(generators)
	bootDiagnosticsSTATUSARMGenerator = gen.Struct(reflect.TypeOf(BootDiagnostics_STATUSARM{}), generators)

	return bootDiagnosticsSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForBootDiagnosticsSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBootDiagnosticsSTATUSARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["StorageUri"] = gen.PtrOf(gen.AlphaString())
}

func Test_BootDiagnosticsInstanceView_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BootDiagnosticsInstanceView_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBootDiagnosticsInstanceViewSTATUSARM, BootDiagnosticsInstanceViewSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBootDiagnosticsInstanceViewSTATUSARM runs a test to see if a specific instance of BootDiagnosticsInstanceView_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBootDiagnosticsInstanceViewSTATUSARM(subject BootDiagnosticsInstanceView_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BootDiagnosticsInstanceView_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BootDiagnosticsInstanceView_STATUSARM instances for property testing - lazily instantiated by
// BootDiagnosticsInstanceViewSTATUSARMGenerator()
var bootDiagnosticsInstanceViewSTATUSARMGenerator gopter.Gen

// BootDiagnosticsInstanceViewSTATUSARMGenerator returns a generator of BootDiagnosticsInstanceView_STATUSARM instances for property testing.
// We first initialize bootDiagnosticsInstanceViewSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BootDiagnosticsInstanceViewSTATUSARMGenerator() gopter.Gen {
	if bootDiagnosticsInstanceViewSTATUSARMGenerator != nil {
		return bootDiagnosticsInstanceViewSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBootDiagnosticsInstanceViewSTATUSARM(generators)
	bootDiagnosticsInstanceViewSTATUSARMGenerator = gen.Struct(reflect.TypeOf(BootDiagnosticsInstanceView_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBootDiagnosticsInstanceViewSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForBootDiagnosticsInstanceViewSTATUSARM(generators)
	bootDiagnosticsInstanceViewSTATUSARMGenerator = gen.Struct(reflect.TypeOf(BootDiagnosticsInstanceView_STATUSARM{}), generators)

	return bootDiagnosticsInstanceViewSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForBootDiagnosticsInstanceViewSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBootDiagnosticsInstanceViewSTATUSARM(gens map[string]gopter.Gen) {
	gens["ConsoleScreenshotBlobUri"] = gen.PtrOf(gen.AlphaString())
	gens["SerialConsoleLogBlobUri"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForBootDiagnosticsInstanceViewSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBootDiagnosticsInstanceViewSTATUSARM(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(InstanceViewStatusSTATUSARMGenerator())
}

func Test_DataDisk_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataDisk_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataDiskSTATUSARM, DataDiskSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataDiskSTATUSARM runs a test to see if a specific instance of DataDisk_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDataDiskSTATUSARM(subject DataDisk_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataDisk_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataDisk_STATUSARM instances for property testing - lazily instantiated by DataDiskSTATUSARMGenerator()
var dataDiskSTATUSARMGenerator gopter.Gen

// DataDiskSTATUSARMGenerator returns a generator of DataDisk_STATUSARM instances for property testing.
// We first initialize dataDiskSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DataDiskSTATUSARMGenerator() gopter.Gen {
	if dataDiskSTATUSARMGenerator != nil {
		return dataDiskSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataDiskSTATUSARM(generators)
	dataDiskSTATUSARMGenerator = gen.Struct(reflect.TypeOf(DataDisk_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataDiskSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForDataDiskSTATUSARM(generators)
	dataDiskSTATUSARMGenerator = gen.Struct(reflect.TypeOf(DataDisk_STATUSARM{}), generators)

	return dataDiskSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForDataDiskSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDataDiskSTATUSARM(gens map[string]gopter.Gen) {
	gens["Caching"] = gen.PtrOf(gen.OneConstOf(Caching_STATUS_None, Caching_STATUS_ReadOnly, Caching_STATUS_ReadWrite))
	gens["CreateOption"] = gen.PtrOf(gen.OneConstOf(CreateOption_STATUS_Attach, CreateOption_STATUS_Empty, CreateOption_STATUS_FromImage))
	gens["DetachOption"] = gen.PtrOf(gen.OneConstOf(DetachOption_STATUS_ForceDetach))
	gens["DiskIOPSReadWrite"] = gen.PtrOf(gen.Int())
	gens["DiskMBpsReadWrite"] = gen.PtrOf(gen.Int())
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["Lun"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ToBeDetached"] = gen.PtrOf(gen.Bool())
	gens["WriteAcceleratorEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForDataDiskSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataDiskSTATUSARM(gens map[string]gopter.Gen) {
	gens["Image"] = gen.PtrOf(VirtualHardDiskSTATUSARMGenerator())
	gens["ManagedDisk"] = gen.PtrOf(ManagedDiskParametersSTATUSARMGenerator())
	gens["Vhd"] = gen.PtrOf(VirtualHardDiskSTATUSARMGenerator())
}

func Test_DiskInstanceView_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiskInstanceView_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskInstanceViewSTATUSARM, DiskInstanceViewSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskInstanceViewSTATUSARM runs a test to see if a specific instance of DiskInstanceView_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskInstanceViewSTATUSARM(subject DiskInstanceView_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiskInstanceView_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiskInstanceView_STATUSARM instances for property testing - lazily instantiated by
// DiskInstanceViewSTATUSARMGenerator()
var diskInstanceViewSTATUSARMGenerator gopter.Gen

// DiskInstanceViewSTATUSARMGenerator returns a generator of DiskInstanceView_STATUSARM instances for property testing.
// We first initialize diskInstanceViewSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DiskInstanceViewSTATUSARMGenerator() gopter.Gen {
	if diskInstanceViewSTATUSARMGenerator != nil {
		return diskInstanceViewSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskInstanceViewSTATUSARM(generators)
	diskInstanceViewSTATUSARMGenerator = gen.Struct(reflect.TypeOf(DiskInstanceView_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskInstanceViewSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForDiskInstanceViewSTATUSARM(generators)
	diskInstanceViewSTATUSARMGenerator = gen.Struct(reflect.TypeOf(DiskInstanceView_STATUSARM{}), generators)

	return diskInstanceViewSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForDiskInstanceViewSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskInstanceViewSTATUSARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDiskInstanceViewSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiskInstanceViewSTATUSARM(gens map[string]gopter.Gen) {
	gens["EncryptionSettings"] = gen.SliceOf(DiskEncryptionSettingsSTATUSARMGenerator())
	gens["Statuses"] = gen.SliceOf(InstanceViewStatusSTATUSARMGenerator())
}

func Test_ImageReference_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ImageReference_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForImageReferenceSTATUSARM, ImageReferenceSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForImageReferenceSTATUSARM runs a test to see if a specific instance of ImageReference_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForImageReferenceSTATUSARM(subject ImageReference_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ImageReference_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ImageReference_STATUSARM instances for property testing - lazily instantiated by
// ImageReferenceSTATUSARMGenerator()
var imageReferenceSTATUSARMGenerator gopter.Gen

// ImageReferenceSTATUSARMGenerator returns a generator of ImageReference_STATUSARM instances for property testing.
func ImageReferenceSTATUSARMGenerator() gopter.Gen {
	if imageReferenceSTATUSARMGenerator != nil {
		return imageReferenceSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForImageReferenceSTATUSARM(generators)
	imageReferenceSTATUSARMGenerator = gen.Struct(reflect.TypeOf(ImageReference_STATUSARM{}), generators)

	return imageReferenceSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForImageReferenceSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForImageReferenceSTATUSARM(gens map[string]gopter.Gen) {
	gens["ExactVersion"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Offer"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
	gens["Sku"] = gen.PtrOf(gen.AlphaString())
	gens["Version"] = gen.PtrOf(gen.AlphaString())
}

func Test_InstanceViewStatus_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InstanceViewStatus_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInstanceViewStatusSTATUSARM, InstanceViewStatusSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInstanceViewStatusSTATUSARM runs a test to see if a specific instance of InstanceViewStatus_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForInstanceViewStatusSTATUSARM(subject InstanceViewStatus_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InstanceViewStatus_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InstanceViewStatus_STATUSARM instances for property testing - lazily instantiated by
// InstanceViewStatusSTATUSARMGenerator()
var instanceViewStatusSTATUSARMGenerator gopter.Gen

// InstanceViewStatusSTATUSARMGenerator returns a generator of InstanceViewStatus_STATUSARM instances for property testing.
func InstanceViewStatusSTATUSARMGenerator() gopter.Gen {
	if instanceViewStatusSTATUSARMGenerator != nil {
		return instanceViewStatusSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInstanceViewStatusSTATUSARM(generators)
	instanceViewStatusSTATUSARMGenerator = gen.Struct(reflect.TypeOf(InstanceViewStatus_STATUSARM{}), generators)

	return instanceViewStatusSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForInstanceViewStatusSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInstanceViewStatusSTATUSARM(gens map[string]gopter.Gen) {
	gens["Code"] = gen.PtrOf(gen.AlphaString())
	gens["DisplayStatus"] = gen.PtrOf(gen.AlphaString())
	gens["Level"] = gen.PtrOf(gen.OneConstOf(InstanceViewStatusSTATUSLevel_Error, InstanceViewStatusSTATUSLevel_Info, InstanceViewStatusSTATUSLevel_Warning))
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Time"] = gen.PtrOf(gen.AlphaString())
}

func Test_LinuxConfiguration_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxConfiguration_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxConfigurationSTATUSARM, LinuxConfigurationSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxConfigurationSTATUSARM runs a test to see if a specific instance of LinuxConfiguration_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxConfigurationSTATUSARM(subject LinuxConfiguration_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxConfiguration_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxConfiguration_STATUSARM instances for property testing - lazily instantiated by
// LinuxConfigurationSTATUSARMGenerator()
var linuxConfigurationSTATUSARMGenerator gopter.Gen

// LinuxConfigurationSTATUSARMGenerator returns a generator of LinuxConfiguration_STATUSARM instances for property testing.
// We first initialize linuxConfigurationSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LinuxConfigurationSTATUSARMGenerator() gopter.Gen {
	if linuxConfigurationSTATUSARMGenerator != nil {
		return linuxConfigurationSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxConfigurationSTATUSARM(generators)
	linuxConfigurationSTATUSARMGenerator = gen.Struct(reflect.TypeOf(LinuxConfiguration_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxConfigurationSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForLinuxConfigurationSTATUSARM(generators)
	linuxConfigurationSTATUSARMGenerator = gen.Struct(reflect.TypeOf(LinuxConfiguration_STATUSARM{}), generators)

	return linuxConfigurationSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForLinuxConfigurationSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxConfigurationSTATUSARM(gens map[string]gopter.Gen) {
	gens["DisablePasswordAuthentication"] = gen.PtrOf(gen.Bool())
	gens["ProvisionVMAgent"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForLinuxConfigurationSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLinuxConfigurationSTATUSARM(gens map[string]gopter.Gen) {
	gens["PatchSettings"] = gen.PtrOf(LinuxPatchSettingsSTATUSARMGenerator())
	gens["Ssh"] = gen.PtrOf(SshConfigurationSTATUSARMGenerator())
}

func Test_MaintenanceRedeployStatus_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MaintenanceRedeployStatus_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMaintenanceRedeployStatusSTATUSARM, MaintenanceRedeployStatusSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMaintenanceRedeployStatusSTATUSARM runs a test to see if a specific instance of MaintenanceRedeployStatus_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForMaintenanceRedeployStatusSTATUSARM(subject MaintenanceRedeployStatus_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MaintenanceRedeployStatus_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MaintenanceRedeployStatus_STATUSARM instances for property testing - lazily instantiated by
// MaintenanceRedeployStatusSTATUSARMGenerator()
var maintenanceRedeployStatusSTATUSARMGenerator gopter.Gen

// MaintenanceRedeployStatusSTATUSARMGenerator returns a generator of MaintenanceRedeployStatus_STATUSARM instances for property testing.
func MaintenanceRedeployStatusSTATUSARMGenerator() gopter.Gen {
	if maintenanceRedeployStatusSTATUSARMGenerator != nil {
		return maintenanceRedeployStatusSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMaintenanceRedeployStatusSTATUSARM(generators)
	maintenanceRedeployStatusSTATUSARMGenerator = gen.Struct(reflect.TypeOf(MaintenanceRedeployStatus_STATUSARM{}), generators)

	return maintenanceRedeployStatusSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForMaintenanceRedeployStatusSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMaintenanceRedeployStatusSTATUSARM(gens map[string]gopter.Gen) {
	gens["IsCustomerInitiatedMaintenanceAllowed"] = gen.PtrOf(gen.Bool())
	gens["LastOperationMessage"] = gen.PtrOf(gen.AlphaString())
	gens["LastOperationResultCode"] = gen.PtrOf(gen.OneConstOf(
		MaintenanceRedeployStatusSTATUSLastOperationResultCode_MaintenanceAborted,
		MaintenanceRedeployStatusSTATUSLastOperationResultCode_MaintenanceCompleted,
		MaintenanceRedeployStatusSTATUSLastOperationResultCode_None,
		MaintenanceRedeployStatusSTATUSLastOperationResultCode_RetryLater))
	gens["MaintenanceWindowEndTime"] = gen.PtrOf(gen.AlphaString())
	gens["MaintenanceWindowStartTime"] = gen.PtrOf(gen.AlphaString())
	gens["PreMaintenanceWindowEndTime"] = gen.PtrOf(gen.AlphaString())
	gens["PreMaintenanceWindowStartTime"] = gen.PtrOf(gen.AlphaString())
}

func Test_NetworkInterfaceReference_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceReference_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceReferenceSTATUSARM, NetworkInterfaceReferenceSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceReferenceSTATUSARM runs a test to see if a specific instance of NetworkInterfaceReference_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceReferenceSTATUSARM(subject NetworkInterfaceReference_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceReference_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceReference_STATUSARM instances for property testing - lazily instantiated by
// NetworkInterfaceReferenceSTATUSARMGenerator()
var networkInterfaceReferenceSTATUSARMGenerator gopter.Gen

// NetworkInterfaceReferenceSTATUSARMGenerator returns a generator of NetworkInterfaceReference_STATUSARM instances for property testing.
// We first initialize networkInterfaceReferenceSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkInterfaceReferenceSTATUSARMGenerator() gopter.Gen {
	if networkInterfaceReferenceSTATUSARMGenerator != nil {
		return networkInterfaceReferenceSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceReferenceSTATUSARM(generators)
	networkInterfaceReferenceSTATUSARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceReference_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceReferenceSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForNetworkInterfaceReferenceSTATUSARM(generators)
	networkInterfaceReferenceSTATUSARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceReference_STATUSARM{}), generators)

	return networkInterfaceReferenceSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceReferenceSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceReferenceSTATUSARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNetworkInterfaceReferenceSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkInterfaceReferenceSTATUSARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(NetworkInterfaceReferencePropertiesSTATUSARMGenerator())
}

func Test_OSDisk_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OSDisk_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOSDiskSTATUSARM, OSDiskSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOSDiskSTATUSARM runs a test to see if a specific instance of OSDisk_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOSDiskSTATUSARM(subject OSDisk_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OSDisk_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OSDisk_STATUSARM instances for property testing - lazily instantiated by OSDiskSTATUSARMGenerator()
var osDiskSTATUSARMGenerator gopter.Gen

// OSDiskSTATUSARMGenerator returns a generator of OSDisk_STATUSARM instances for property testing.
// We first initialize osDiskSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OSDiskSTATUSARMGenerator() gopter.Gen {
	if osDiskSTATUSARMGenerator != nil {
		return osDiskSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSDiskSTATUSARM(generators)
	osDiskSTATUSARMGenerator = gen.Struct(reflect.TypeOf(OSDisk_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSDiskSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForOSDiskSTATUSARM(generators)
	osDiskSTATUSARMGenerator = gen.Struct(reflect.TypeOf(OSDisk_STATUSARM{}), generators)

	return osDiskSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForOSDiskSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOSDiskSTATUSARM(gens map[string]gopter.Gen) {
	gens["Caching"] = gen.PtrOf(gen.OneConstOf(Caching_STATUS_None, Caching_STATUS_ReadOnly, Caching_STATUS_ReadWrite))
	gens["CreateOption"] = gen.PtrOf(gen.OneConstOf(CreateOption_STATUS_Attach, CreateOption_STATUS_Empty, CreateOption_STATUS_FromImage))
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["OsType"] = gen.PtrOf(gen.OneConstOf(OSDiskSTATUSOsType_Linux, OSDiskSTATUSOsType_Windows))
	gens["WriteAcceleratorEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForOSDiskSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOSDiskSTATUSARM(gens map[string]gopter.Gen) {
	gens["DiffDiskSettings"] = gen.PtrOf(DiffDiskSettingsSTATUSARMGenerator())
	gens["EncryptionSettings"] = gen.PtrOf(DiskEncryptionSettingsSTATUSARMGenerator())
	gens["Image"] = gen.PtrOf(VirtualHardDiskSTATUSARMGenerator())
	gens["ManagedDisk"] = gen.PtrOf(ManagedDiskParametersSTATUSARMGenerator())
	gens["Vhd"] = gen.PtrOf(VirtualHardDiskSTATUSARMGenerator())
}

func Test_UefiSettings_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UefiSettings_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUefiSettingsSTATUSARM, UefiSettingsSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUefiSettingsSTATUSARM runs a test to see if a specific instance of UefiSettings_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUefiSettingsSTATUSARM(subject UefiSettings_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UefiSettings_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UefiSettings_STATUSARM instances for property testing - lazily instantiated by
// UefiSettingsSTATUSARMGenerator()
var uefiSettingsSTATUSARMGenerator gopter.Gen

// UefiSettingsSTATUSARMGenerator returns a generator of UefiSettings_STATUSARM instances for property testing.
func UefiSettingsSTATUSARMGenerator() gopter.Gen {
	if uefiSettingsSTATUSARMGenerator != nil {
		return uefiSettingsSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUefiSettingsSTATUSARM(generators)
	uefiSettingsSTATUSARMGenerator = gen.Struct(reflect.TypeOf(UefiSettings_STATUSARM{}), generators)

	return uefiSettingsSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForUefiSettingsSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUefiSettingsSTATUSARM(gens map[string]gopter.Gen) {
	gens["SecureBootEnabled"] = gen.PtrOf(gen.Bool())
	gens["VTpmEnabled"] = gen.PtrOf(gen.Bool())
}

func Test_VaultSecretGroup_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultSecretGroup_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultSecretGroupSTATUSARM, VaultSecretGroupSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultSecretGroupSTATUSARM runs a test to see if a specific instance of VaultSecretGroup_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultSecretGroupSTATUSARM(subject VaultSecretGroup_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultSecretGroup_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultSecretGroup_STATUSARM instances for property testing - lazily instantiated by
// VaultSecretGroupSTATUSARMGenerator()
var vaultSecretGroupSTATUSARMGenerator gopter.Gen

// VaultSecretGroupSTATUSARMGenerator returns a generator of VaultSecretGroup_STATUSARM instances for property testing.
func VaultSecretGroupSTATUSARMGenerator() gopter.Gen {
	if vaultSecretGroupSTATUSARMGenerator != nil {
		return vaultSecretGroupSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVaultSecretGroupSTATUSARM(generators)
	vaultSecretGroupSTATUSARMGenerator = gen.Struct(reflect.TypeOf(VaultSecretGroup_STATUSARM{}), generators)

	return vaultSecretGroupSTATUSARMGenerator
}

// AddRelatedPropertyGeneratorsForVaultSecretGroupSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVaultSecretGroupSTATUSARM(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SubResourceSTATUSARMGenerator())
	gens["VaultCertificates"] = gen.SliceOf(VaultCertificateSTATUSARMGenerator())
}

func Test_VirtualMachineAgentInstanceView_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineAgentInstanceView_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineAgentInstanceViewSTATUSARM, VirtualMachineAgentInstanceViewSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineAgentInstanceViewSTATUSARM runs a test to see if a specific instance of VirtualMachineAgentInstanceView_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineAgentInstanceViewSTATUSARM(subject VirtualMachineAgentInstanceView_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineAgentInstanceView_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineAgentInstanceView_STATUSARM instances for property testing - lazily instantiated by
// VirtualMachineAgentInstanceViewSTATUSARMGenerator()
var virtualMachineAgentInstanceViewSTATUSARMGenerator gopter.Gen

// VirtualMachineAgentInstanceViewSTATUSARMGenerator returns a generator of VirtualMachineAgentInstanceView_STATUSARM instances for property testing.
// We first initialize virtualMachineAgentInstanceViewSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineAgentInstanceViewSTATUSARMGenerator() gopter.Gen {
	if virtualMachineAgentInstanceViewSTATUSARMGenerator != nil {
		return virtualMachineAgentInstanceViewSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineAgentInstanceViewSTATUSARM(generators)
	virtualMachineAgentInstanceViewSTATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineAgentInstanceView_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineAgentInstanceViewSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineAgentInstanceViewSTATUSARM(generators)
	virtualMachineAgentInstanceViewSTATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineAgentInstanceView_STATUSARM{}), generators)

	return virtualMachineAgentInstanceViewSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineAgentInstanceViewSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineAgentInstanceViewSTATUSARM(gens map[string]gopter.Gen) {
	gens["VmAgentVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineAgentInstanceViewSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineAgentInstanceViewSTATUSARM(gens map[string]gopter.Gen) {
	gens["ExtensionHandlers"] = gen.SliceOf(VirtualMachineExtensionHandlerInstanceViewSTATUSARMGenerator())
	gens["Statuses"] = gen.SliceOf(InstanceViewStatusSTATUSARMGenerator())
}

func Test_VirtualMachineExtensionInstanceView_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineExtensionInstanceView_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineExtensionInstanceViewSTATUSARM, VirtualMachineExtensionInstanceViewSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineExtensionInstanceViewSTATUSARM runs a test to see if a specific instance of VirtualMachineExtensionInstanceView_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineExtensionInstanceViewSTATUSARM(subject VirtualMachineExtensionInstanceView_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineExtensionInstanceView_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineExtensionInstanceView_STATUSARM instances for property testing - lazily instantiated by
// VirtualMachineExtensionInstanceViewSTATUSARMGenerator()
var virtualMachineExtensionInstanceViewSTATUSARMGenerator gopter.Gen

// VirtualMachineExtensionInstanceViewSTATUSARMGenerator returns a generator of VirtualMachineExtensionInstanceView_STATUSARM instances for property testing.
// We first initialize virtualMachineExtensionInstanceViewSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineExtensionInstanceViewSTATUSARMGenerator() gopter.Gen {
	if virtualMachineExtensionInstanceViewSTATUSARMGenerator != nil {
		return virtualMachineExtensionInstanceViewSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionInstanceViewSTATUSARM(generators)
	virtualMachineExtensionInstanceViewSTATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtensionInstanceView_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionInstanceViewSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineExtensionInstanceViewSTATUSARM(generators)
	virtualMachineExtensionInstanceViewSTATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtensionInstanceView_STATUSARM{}), generators)

	return virtualMachineExtensionInstanceViewSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineExtensionInstanceViewSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineExtensionInstanceViewSTATUSARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["TypeHandlerVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineExtensionInstanceViewSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineExtensionInstanceViewSTATUSARM(gens map[string]gopter.Gen) {
	gens["Statuses"] = gen.SliceOf(InstanceViewStatusSTATUSARMGenerator())
	gens["Substatuses"] = gen.SliceOf(InstanceViewStatusSTATUSARMGenerator())
}

func Test_VirtualMachineHealthStatus_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineHealthStatus_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineHealthStatusSTATUSARM, VirtualMachineHealthStatusSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineHealthStatusSTATUSARM runs a test to see if a specific instance of VirtualMachineHealthStatus_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineHealthStatusSTATUSARM(subject VirtualMachineHealthStatus_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineHealthStatus_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineHealthStatus_STATUSARM instances for property testing - lazily instantiated by
// VirtualMachineHealthStatusSTATUSARMGenerator()
var virtualMachineHealthStatusSTATUSARMGenerator gopter.Gen

// VirtualMachineHealthStatusSTATUSARMGenerator returns a generator of VirtualMachineHealthStatus_STATUSARM instances for property testing.
func VirtualMachineHealthStatusSTATUSARMGenerator() gopter.Gen {
	if virtualMachineHealthStatusSTATUSARMGenerator != nil {
		return virtualMachineHealthStatusSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVirtualMachineHealthStatusSTATUSARM(generators)
	virtualMachineHealthStatusSTATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineHealthStatus_STATUSARM{}), generators)

	return virtualMachineHealthStatusSTATUSARMGenerator
}

// AddRelatedPropertyGeneratorsForVirtualMachineHealthStatusSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineHealthStatusSTATUSARM(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(InstanceViewStatusSTATUSARMGenerator())
}

func Test_VirtualMachinePatchStatus_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachinePatchStatus_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachinePatchStatusSTATUSARM, VirtualMachinePatchStatusSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachinePatchStatusSTATUSARM runs a test to see if a specific instance of VirtualMachinePatchStatus_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachinePatchStatusSTATUSARM(subject VirtualMachinePatchStatus_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachinePatchStatus_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachinePatchStatus_STATUSARM instances for property testing - lazily instantiated by
// VirtualMachinePatchStatusSTATUSARMGenerator()
var virtualMachinePatchStatusSTATUSARMGenerator gopter.Gen

// VirtualMachinePatchStatusSTATUSARMGenerator returns a generator of VirtualMachinePatchStatus_STATUSARM instances for property testing.
func VirtualMachinePatchStatusSTATUSARMGenerator() gopter.Gen {
	if virtualMachinePatchStatusSTATUSARMGenerator != nil {
		return virtualMachinePatchStatusSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVirtualMachinePatchStatusSTATUSARM(generators)
	virtualMachinePatchStatusSTATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachinePatchStatus_STATUSARM{}), generators)

	return virtualMachinePatchStatusSTATUSARMGenerator
}

// AddRelatedPropertyGeneratorsForVirtualMachinePatchStatusSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachinePatchStatusSTATUSARM(gens map[string]gopter.Gen) {
	gens["AvailablePatchSummary"] = gen.PtrOf(AvailablePatchSummarySTATUSARMGenerator())
	gens["ConfigurationStatuses"] = gen.SliceOf(InstanceViewStatusSTATUSARMGenerator())
	gens["LastPatchInstallationSummary"] = gen.PtrOf(LastPatchInstallationSummarySTATUSARMGenerator())
}

func Test_WindowsConfiguration_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WindowsConfiguration_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWindowsConfigurationSTATUSARM, WindowsConfigurationSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWindowsConfigurationSTATUSARM runs a test to see if a specific instance of WindowsConfiguration_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWindowsConfigurationSTATUSARM(subject WindowsConfiguration_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WindowsConfiguration_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WindowsConfiguration_STATUSARM instances for property testing - lazily instantiated by
// WindowsConfigurationSTATUSARMGenerator()
var windowsConfigurationSTATUSARMGenerator gopter.Gen

// WindowsConfigurationSTATUSARMGenerator returns a generator of WindowsConfiguration_STATUSARM instances for property testing.
// We first initialize windowsConfigurationSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WindowsConfigurationSTATUSARMGenerator() gopter.Gen {
	if windowsConfigurationSTATUSARMGenerator != nil {
		return windowsConfigurationSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsConfigurationSTATUSARM(generators)
	windowsConfigurationSTATUSARMGenerator = gen.Struct(reflect.TypeOf(WindowsConfiguration_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsConfigurationSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForWindowsConfigurationSTATUSARM(generators)
	windowsConfigurationSTATUSARMGenerator = gen.Struct(reflect.TypeOf(WindowsConfiguration_STATUSARM{}), generators)

	return windowsConfigurationSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForWindowsConfigurationSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWindowsConfigurationSTATUSARM(gens map[string]gopter.Gen) {
	gens["EnableAutomaticUpdates"] = gen.PtrOf(gen.Bool())
	gens["ProvisionVMAgent"] = gen.PtrOf(gen.Bool())
	gens["TimeZone"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForWindowsConfigurationSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWindowsConfigurationSTATUSARM(gens map[string]gopter.Gen) {
	gens["AdditionalUnattendContent"] = gen.SliceOf(AdditionalUnattendContentSTATUSARMGenerator())
	gens["PatchSettings"] = gen.PtrOf(PatchSettingsSTATUSARMGenerator())
	gens["WinRM"] = gen.PtrOf(WinRMConfigurationSTATUSARMGenerator())
}

func Test_AdditionalUnattendContent_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdditionalUnattendContent_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdditionalUnattendContentSTATUSARM, AdditionalUnattendContentSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdditionalUnattendContentSTATUSARM runs a test to see if a specific instance of AdditionalUnattendContent_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAdditionalUnattendContentSTATUSARM(subject AdditionalUnattendContent_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdditionalUnattendContent_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdditionalUnattendContent_STATUSARM instances for property testing - lazily instantiated by
// AdditionalUnattendContentSTATUSARMGenerator()
var additionalUnattendContentSTATUSARMGenerator gopter.Gen

// AdditionalUnattendContentSTATUSARMGenerator returns a generator of AdditionalUnattendContent_STATUSARM instances for property testing.
func AdditionalUnattendContentSTATUSARMGenerator() gopter.Gen {
	if additionalUnattendContentSTATUSARMGenerator != nil {
		return additionalUnattendContentSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdditionalUnattendContentSTATUSARM(generators)
	additionalUnattendContentSTATUSARMGenerator = gen.Struct(reflect.TypeOf(AdditionalUnattendContent_STATUSARM{}), generators)

	return additionalUnattendContentSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForAdditionalUnattendContentSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdditionalUnattendContentSTATUSARM(gens map[string]gopter.Gen) {
	gens["ComponentName"] = gen.PtrOf(gen.OneConstOf(AdditionalUnattendContentSTATUSComponentName_MicrosoftWindowsShellSetup))
	gens["Content"] = gen.PtrOf(gen.AlphaString())
	gens["PassName"] = gen.PtrOf(gen.OneConstOf(AdditionalUnattendContentSTATUSPassName_OobeSystem))
	gens["SettingName"] = gen.PtrOf(gen.OneConstOf(AdditionalUnattendContentSTATUSSettingName_AutoLogon, AdditionalUnattendContentSTATUSSettingName_FirstLogonCommands))
}

func Test_AvailablePatchSummary_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AvailablePatchSummary_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAvailablePatchSummarySTATUSARM, AvailablePatchSummarySTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAvailablePatchSummarySTATUSARM runs a test to see if a specific instance of AvailablePatchSummary_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAvailablePatchSummarySTATUSARM(subject AvailablePatchSummary_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AvailablePatchSummary_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AvailablePatchSummary_STATUSARM instances for property testing - lazily instantiated by
// AvailablePatchSummarySTATUSARMGenerator()
var availablePatchSummarySTATUSARMGenerator gopter.Gen

// AvailablePatchSummarySTATUSARMGenerator returns a generator of AvailablePatchSummary_STATUSARM instances for property testing.
// We first initialize availablePatchSummarySTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AvailablePatchSummarySTATUSARMGenerator() gopter.Gen {
	if availablePatchSummarySTATUSARMGenerator != nil {
		return availablePatchSummarySTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAvailablePatchSummarySTATUSARM(generators)
	availablePatchSummarySTATUSARMGenerator = gen.Struct(reflect.TypeOf(AvailablePatchSummary_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAvailablePatchSummarySTATUSARM(generators)
	AddRelatedPropertyGeneratorsForAvailablePatchSummarySTATUSARM(generators)
	availablePatchSummarySTATUSARMGenerator = gen.Struct(reflect.TypeOf(AvailablePatchSummary_STATUSARM{}), generators)

	return availablePatchSummarySTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForAvailablePatchSummarySTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAvailablePatchSummarySTATUSARM(gens map[string]gopter.Gen) {
	gens["AssessmentActivityId"] = gen.PtrOf(gen.AlphaString())
	gens["CriticalAndSecurityPatchCount"] = gen.PtrOf(gen.Int())
	gens["LastModifiedTime"] = gen.PtrOf(gen.AlphaString())
	gens["OtherPatchCount"] = gen.PtrOf(gen.Int())
	gens["RebootPending"] = gen.PtrOf(gen.Bool())
	gens["StartTime"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(
		AvailablePatchSummarySTATUSStatus_CompletedWithWarnings,
		AvailablePatchSummarySTATUSStatus_Failed,
		AvailablePatchSummarySTATUSStatus_InProgress,
		AvailablePatchSummarySTATUSStatus_Succeeded,
		AvailablePatchSummarySTATUSStatus_Unknown))
}

// AddRelatedPropertyGeneratorsForAvailablePatchSummarySTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAvailablePatchSummarySTATUSARM(gens map[string]gopter.Gen) {
	gens["Error"] = gen.PtrOf(ApiErrorSTATUSARMGenerator())
}

func Test_DiffDiskSettings_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiffDiskSettings_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiffDiskSettingsSTATUSARM, DiffDiskSettingsSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiffDiskSettingsSTATUSARM runs a test to see if a specific instance of DiffDiskSettings_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiffDiskSettingsSTATUSARM(subject DiffDiskSettings_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiffDiskSettings_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiffDiskSettings_STATUSARM instances for property testing - lazily instantiated by
// DiffDiskSettingsSTATUSARMGenerator()
var diffDiskSettingsSTATUSARMGenerator gopter.Gen

// DiffDiskSettingsSTATUSARMGenerator returns a generator of DiffDiskSettings_STATUSARM instances for property testing.
func DiffDiskSettingsSTATUSARMGenerator() gopter.Gen {
	if diffDiskSettingsSTATUSARMGenerator != nil {
		return diffDiskSettingsSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiffDiskSettingsSTATUSARM(generators)
	diffDiskSettingsSTATUSARMGenerator = gen.Struct(reflect.TypeOf(DiffDiskSettings_STATUSARM{}), generators)

	return diffDiskSettingsSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForDiffDiskSettingsSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiffDiskSettingsSTATUSARM(gens map[string]gopter.Gen) {
	gens["Option"] = gen.PtrOf(gen.OneConstOf(DiffDiskOption_STATUS_Local))
	gens["Placement"] = gen.PtrOf(gen.OneConstOf(DiffDiskPlacement_STATUS_CacheDisk, DiffDiskPlacement_STATUS_ResourceDisk))
}

func Test_DiskEncryptionSettings_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiskEncryptionSettings_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskEncryptionSettingsSTATUSARM, DiskEncryptionSettingsSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskEncryptionSettingsSTATUSARM runs a test to see if a specific instance of DiskEncryptionSettings_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskEncryptionSettingsSTATUSARM(subject DiskEncryptionSettings_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiskEncryptionSettings_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiskEncryptionSettings_STATUSARM instances for property testing - lazily instantiated by
// DiskEncryptionSettingsSTATUSARMGenerator()
var diskEncryptionSettingsSTATUSARMGenerator gopter.Gen

// DiskEncryptionSettingsSTATUSARMGenerator returns a generator of DiskEncryptionSettings_STATUSARM instances for property testing.
// We first initialize diskEncryptionSettingsSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DiskEncryptionSettingsSTATUSARMGenerator() gopter.Gen {
	if diskEncryptionSettingsSTATUSARMGenerator != nil {
		return diskEncryptionSettingsSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskEncryptionSettingsSTATUSARM(generators)
	diskEncryptionSettingsSTATUSARMGenerator = gen.Struct(reflect.TypeOf(DiskEncryptionSettings_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskEncryptionSettingsSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForDiskEncryptionSettingsSTATUSARM(generators)
	diskEncryptionSettingsSTATUSARMGenerator = gen.Struct(reflect.TypeOf(DiskEncryptionSettings_STATUSARM{}), generators)

	return diskEncryptionSettingsSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForDiskEncryptionSettingsSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskEncryptionSettingsSTATUSARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForDiskEncryptionSettingsSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiskEncryptionSettingsSTATUSARM(gens map[string]gopter.Gen) {
	gens["DiskEncryptionKey"] = gen.PtrOf(KeyVaultSecretReferenceSTATUSARMGenerator())
	gens["KeyEncryptionKey"] = gen.PtrOf(KeyVaultKeyReferenceSTATUSARMGenerator())
}

func Test_LastPatchInstallationSummary_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LastPatchInstallationSummary_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLastPatchInstallationSummarySTATUSARM, LastPatchInstallationSummarySTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLastPatchInstallationSummarySTATUSARM runs a test to see if a specific instance of LastPatchInstallationSummary_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLastPatchInstallationSummarySTATUSARM(subject LastPatchInstallationSummary_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LastPatchInstallationSummary_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LastPatchInstallationSummary_STATUSARM instances for property testing - lazily instantiated by
// LastPatchInstallationSummarySTATUSARMGenerator()
var lastPatchInstallationSummarySTATUSARMGenerator gopter.Gen

// LastPatchInstallationSummarySTATUSARMGenerator returns a generator of LastPatchInstallationSummary_STATUSARM instances for property testing.
// We first initialize lastPatchInstallationSummarySTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LastPatchInstallationSummarySTATUSARMGenerator() gopter.Gen {
	if lastPatchInstallationSummarySTATUSARMGenerator != nil {
		return lastPatchInstallationSummarySTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLastPatchInstallationSummarySTATUSARM(generators)
	lastPatchInstallationSummarySTATUSARMGenerator = gen.Struct(reflect.TypeOf(LastPatchInstallationSummary_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLastPatchInstallationSummarySTATUSARM(generators)
	AddRelatedPropertyGeneratorsForLastPatchInstallationSummarySTATUSARM(generators)
	lastPatchInstallationSummarySTATUSARMGenerator = gen.Struct(reflect.TypeOf(LastPatchInstallationSummary_STATUSARM{}), generators)

	return lastPatchInstallationSummarySTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForLastPatchInstallationSummarySTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLastPatchInstallationSummarySTATUSARM(gens map[string]gopter.Gen) {
	gens["ExcludedPatchCount"] = gen.PtrOf(gen.Int())
	gens["FailedPatchCount"] = gen.PtrOf(gen.Int())
	gens["InstallationActivityId"] = gen.PtrOf(gen.AlphaString())
	gens["InstalledPatchCount"] = gen.PtrOf(gen.Int())
	gens["LastModifiedTime"] = gen.PtrOf(gen.AlphaString())
	gens["MaintenanceWindowExceeded"] = gen.PtrOf(gen.Bool())
	gens["NotSelectedPatchCount"] = gen.PtrOf(gen.Int())
	gens["PendingPatchCount"] = gen.PtrOf(gen.Int())
	gens["StartTime"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(
		LastPatchInstallationSummarySTATUSStatus_CompletedWithWarnings,
		LastPatchInstallationSummarySTATUSStatus_Failed,
		LastPatchInstallationSummarySTATUSStatus_InProgress,
		LastPatchInstallationSummarySTATUSStatus_Succeeded,
		LastPatchInstallationSummarySTATUSStatus_Unknown))
}

// AddRelatedPropertyGeneratorsForLastPatchInstallationSummarySTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLastPatchInstallationSummarySTATUSARM(gens map[string]gopter.Gen) {
	gens["Error"] = gen.PtrOf(ApiErrorSTATUSARMGenerator())
}

func Test_LinuxPatchSettings_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxPatchSettings_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxPatchSettingsSTATUSARM, LinuxPatchSettingsSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxPatchSettingsSTATUSARM runs a test to see if a specific instance of LinuxPatchSettings_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxPatchSettingsSTATUSARM(subject LinuxPatchSettings_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxPatchSettings_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxPatchSettings_STATUSARM instances for property testing - lazily instantiated by
// LinuxPatchSettingsSTATUSARMGenerator()
var linuxPatchSettingsSTATUSARMGenerator gopter.Gen

// LinuxPatchSettingsSTATUSARMGenerator returns a generator of LinuxPatchSettings_STATUSARM instances for property testing.
func LinuxPatchSettingsSTATUSARMGenerator() gopter.Gen {
	if linuxPatchSettingsSTATUSARMGenerator != nil {
		return linuxPatchSettingsSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxPatchSettingsSTATUSARM(generators)
	linuxPatchSettingsSTATUSARMGenerator = gen.Struct(reflect.TypeOf(LinuxPatchSettings_STATUSARM{}), generators)

	return linuxPatchSettingsSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForLinuxPatchSettingsSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxPatchSettingsSTATUSARM(gens map[string]gopter.Gen) {
	gens["PatchMode"] = gen.PtrOf(gen.OneConstOf(LinuxPatchSettingsSTATUSPatchMode_AutomaticByPlatform, LinuxPatchSettingsSTATUSPatchMode_ImageDefault))
}

func Test_ManagedDiskParameters_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedDiskParameters_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedDiskParametersSTATUSARM, ManagedDiskParametersSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedDiskParametersSTATUSARM runs a test to see if a specific instance of ManagedDiskParameters_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedDiskParametersSTATUSARM(subject ManagedDiskParameters_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedDiskParameters_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedDiskParameters_STATUSARM instances for property testing - lazily instantiated by
// ManagedDiskParametersSTATUSARMGenerator()
var managedDiskParametersSTATUSARMGenerator gopter.Gen

// ManagedDiskParametersSTATUSARMGenerator returns a generator of ManagedDiskParameters_STATUSARM instances for property testing.
// We first initialize managedDiskParametersSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedDiskParametersSTATUSARMGenerator() gopter.Gen {
	if managedDiskParametersSTATUSARMGenerator != nil {
		return managedDiskParametersSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedDiskParametersSTATUSARM(generators)
	managedDiskParametersSTATUSARMGenerator = gen.Struct(reflect.TypeOf(ManagedDiskParameters_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedDiskParametersSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForManagedDiskParametersSTATUSARM(generators)
	managedDiskParametersSTATUSARMGenerator = gen.Struct(reflect.TypeOf(ManagedDiskParameters_STATUSARM{}), generators)

	return managedDiskParametersSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedDiskParametersSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedDiskParametersSTATUSARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountType"] = gen.PtrOf(gen.OneConstOf(
		StorageAccountType_STATUS_PremiumLRS,
		StorageAccountType_STATUS_PremiumZRS,
		StorageAccountType_STATUS_StandardLRS,
		StorageAccountType_STATUS_StandardSSDLRS,
		StorageAccountType_STATUS_StandardSSDZRS,
		StorageAccountType_STATUS_UltraSSDLRS))
}

// AddRelatedPropertyGeneratorsForManagedDiskParametersSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedDiskParametersSTATUSARM(gens map[string]gopter.Gen) {
	gens["DiskEncryptionSet"] = gen.PtrOf(SubResourceSTATUSARMGenerator())
}

func Test_NetworkInterfaceReferenceProperties_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceReferenceProperties_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceReferencePropertiesSTATUSARM, NetworkInterfaceReferencePropertiesSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceReferencePropertiesSTATUSARM runs a test to see if a specific instance of NetworkInterfaceReferenceProperties_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceReferencePropertiesSTATUSARM(subject NetworkInterfaceReferenceProperties_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceReferenceProperties_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceReferenceProperties_STATUSARM instances for property testing - lazily instantiated by
// NetworkInterfaceReferencePropertiesSTATUSARMGenerator()
var networkInterfaceReferencePropertiesSTATUSARMGenerator gopter.Gen

// NetworkInterfaceReferencePropertiesSTATUSARMGenerator returns a generator of NetworkInterfaceReferenceProperties_STATUSARM instances for property testing.
func NetworkInterfaceReferencePropertiesSTATUSARMGenerator() gopter.Gen {
	if networkInterfaceReferencePropertiesSTATUSARMGenerator != nil {
		return networkInterfaceReferencePropertiesSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceReferencePropertiesSTATUSARM(generators)
	networkInterfaceReferencePropertiesSTATUSARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceReferenceProperties_STATUSARM{}), generators)

	return networkInterfaceReferencePropertiesSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceReferencePropertiesSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceReferencePropertiesSTATUSARM(gens map[string]gopter.Gen) {
	gens["Primary"] = gen.PtrOf(gen.Bool())
}

func Test_PatchSettings_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PatchSettings_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPatchSettingsSTATUSARM, PatchSettingsSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPatchSettingsSTATUSARM runs a test to see if a specific instance of PatchSettings_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPatchSettingsSTATUSARM(subject PatchSettings_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PatchSettings_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PatchSettings_STATUSARM instances for property testing - lazily instantiated by
// PatchSettingsSTATUSARMGenerator()
var patchSettingsSTATUSARMGenerator gopter.Gen

// PatchSettingsSTATUSARMGenerator returns a generator of PatchSettings_STATUSARM instances for property testing.
func PatchSettingsSTATUSARMGenerator() gopter.Gen {
	if patchSettingsSTATUSARMGenerator != nil {
		return patchSettingsSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPatchSettingsSTATUSARM(generators)
	patchSettingsSTATUSARMGenerator = gen.Struct(reflect.TypeOf(PatchSettings_STATUSARM{}), generators)

	return patchSettingsSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForPatchSettingsSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPatchSettingsSTATUSARM(gens map[string]gopter.Gen) {
	gens["EnableHotpatching"] = gen.PtrOf(gen.Bool())
	gens["PatchMode"] = gen.PtrOf(gen.OneConstOf(PatchSettingsSTATUSPatchMode_AutomaticByOS, PatchSettingsSTATUSPatchMode_AutomaticByPlatform, PatchSettingsSTATUSPatchMode_Manual))
}

func Test_SshConfiguration_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SshConfiguration_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSshConfigurationSTATUSARM, SshConfigurationSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSshConfigurationSTATUSARM runs a test to see if a specific instance of SshConfiguration_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSshConfigurationSTATUSARM(subject SshConfiguration_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SshConfiguration_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SshConfiguration_STATUSARM instances for property testing - lazily instantiated by
// SshConfigurationSTATUSARMGenerator()
var sshConfigurationSTATUSARMGenerator gopter.Gen

// SshConfigurationSTATUSARMGenerator returns a generator of SshConfiguration_STATUSARM instances for property testing.
func SshConfigurationSTATUSARMGenerator() gopter.Gen {
	if sshConfigurationSTATUSARMGenerator != nil {
		return sshConfigurationSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForSshConfigurationSTATUSARM(generators)
	sshConfigurationSTATUSARMGenerator = gen.Struct(reflect.TypeOf(SshConfiguration_STATUSARM{}), generators)

	return sshConfigurationSTATUSARMGenerator
}

// AddRelatedPropertyGeneratorsForSshConfigurationSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSshConfigurationSTATUSARM(gens map[string]gopter.Gen) {
	gens["PublicKeys"] = gen.SliceOf(SshPublicKeySTATUSARMGenerator())
}

func Test_VaultCertificate_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultCertificate_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultCertificateSTATUSARM, VaultCertificateSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultCertificateSTATUSARM runs a test to see if a specific instance of VaultCertificate_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultCertificateSTATUSARM(subject VaultCertificate_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultCertificate_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultCertificate_STATUSARM instances for property testing - lazily instantiated by
// VaultCertificateSTATUSARMGenerator()
var vaultCertificateSTATUSARMGenerator gopter.Gen

// VaultCertificateSTATUSARMGenerator returns a generator of VaultCertificate_STATUSARM instances for property testing.
func VaultCertificateSTATUSARMGenerator() gopter.Gen {
	if vaultCertificateSTATUSARMGenerator != nil {
		return vaultCertificateSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVaultCertificateSTATUSARM(generators)
	vaultCertificateSTATUSARMGenerator = gen.Struct(reflect.TypeOf(VaultCertificate_STATUSARM{}), generators)

	return vaultCertificateSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForVaultCertificateSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVaultCertificateSTATUSARM(gens map[string]gopter.Gen) {
	gens["CertificateStore"] = gen.PtrOf(gen.AlphaString())
	gens["CertificateUrl"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualHardDisk_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualHardDisk_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualHardDiskSTATUSARM, VirtualHardDiskSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualHardDiskSTATUSARM runs a test to see if a specific instance of VirtualHardDisk_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualHardDiskSTATUSARM(subject VirtualHardDisk_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualHardDisk_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualHardDisk_STATUSARM instances for property testing - lazily instantiated by
// VirtualHardDiskSTATUSARMGenerator()
var virtualHardDiskSTATUSARMGenerator gopter.Gen

// VirtualHardDiskSTATUSARMGenerator returns a generator of VirtualHardDisk_STATUSARM instances for property testing.
func VirtualHardDiskSTATUSARMGenerator() gopter.Gen {
	if virtualHardDiskSTATUSARMGenerator != nil {
		return virtualHardDiskSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualHardDiskSTATUSARM(generators)
	virtualHardDiskSTATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualHardDisk_STATUSARM{}), generators)

	return virtualHardDiskSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualHardDiskSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualHardDiskSTATUSARM(gens map[string]gopter.Gen) {
	gens["Uri"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachineExtensionHandlerInstanceView_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineExtensionHandlerInstanceView_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineExtensionHandlerInstanceViewSTATUSARM, VirtualMachineExtensionHandlerInstanceViewSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineExtensionHandlerInstanceViewSTATUSARM runs a test to see if a specific instance of VirtualMachineExtensionHandlerInstanceView_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineExtensionHandlerInstanceViewSTATUSARM(subject VirtualMachineExtensionHandlerInstanceView_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineExtensionHandlerInstanceView_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineExtensionHandlerInstanceView_STATUSARM instances for property testing - lazily
// instantiated by VirtualMachineExtensionHandlerInstanceViewSTATUSARMGenerator()
var virtualMachineExtensionHandlerInstanceViewSTATUSARMGenerator gopter.Gen

// VirtualMachineExtensionHandlerInstanceViewSTATUSARMGenerator returns a generator of VirtualMachineExtensionHandlerInstanceView_STATUSARM instances for property testing.
// We first initialize virtualMachineExtensionHandlerInstanceViewSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineExtensionHandlerInstanceViewSTATUSARMGenerator() gopter.Gen {
	if virtualMachineExtensionHandlerInstanceViewSTATUSARMGenerator != nil {
		return virtualMachineExtensionHandlerInstanceViewSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceViewSTATUSARM(generators)
	virtualMachineExtensionHandlerInstanceViewSTATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtensionHandlerInstanceView_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceViewSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceViewSTATUSARM(generators)
	virtualMachineExtensionHandlerInstanceViewSTATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtensionHandlerInstanceView_STATUSARM{}), generators)

	return virtualMachineExtensionHandlerInstanceViewSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceViewSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceViewSTATUSARM(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["TypeHandlerVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceViewSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceViewSTATUSARM(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(InstanceViewStatusSTATUSARMGenerator())
}

func Test_WinRMConfiguration_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WinRMConfiguration_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWinRMConfigurationSTATUSARM, WinRMConfigurationSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWinRMConfigurationSTATUSARM runs a test to see if a specific instance of WinRMConfiguration_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWinRMConfigurationSTATUSARM(subject WinRMConfiguration_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WinRMConfiguration_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WinRMConfiguration_STATUSARM instances for property testing - lazily instantiated by
// WinRMConfigurationSTATUSARMGenerator()
var winRMConfigurationSTATUSARMGenerator gopter.Gen

// WinRMConfigurationSTATUSARMGenerator returns a generator of WinRMConfiguration_STATUSARM instances for property testing.
func WinRMConfigurationSTATUSARMGenerator() gopter.Gen {
	if winRMConfigurationSTATUSARMGenerator != nil {
		return winRMConfigurationSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForWinRMConfigurationSTATUSARM(generators)
	winRMConfigurationSTATUSARMGenerator = gen.Struct(reflect.TypeOf(WinRMConfiguration_STATUSARM{}), generators)

	return winRMConfigurationSTATUSARMGenerator
}

// AddRelatedPropertyGeneratorsForWinRMConfigurationSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWinRMConfigurationSTATUSARM(gens map[string]gopter.Gen) {
	gens["Listeners"] = gen.SliceOf(WinRMListenerSTATUSARMGenerator())
}

func Test_ApiError_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiError_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiErrorSTATUSARM, ApiErrorSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiErrorSTATUSARM runs a test to see if a specific instance of ApiError_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForApiErrorSTATUSARM(subject ApiError_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiError_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiError_STATUSARM instances for property testing - lazily instantiated by ApiErrorSTATUSARMGenerator()
var apiErrorSTATUSARMGenerator gopter.Gen

// ApiErrorSTATUSARMGenerator returns a generator of ApiError_STATUSARM instances for property testing.
// We first initialize apiErrorSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ApiErrorSTATUSARMGenerator() gopter.Gen {
	if apiErrorSTATUSARMGenerator != nil {
		return apiErrorSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiErrorSTATUSARM(generators)
	apiErrorSTATUSARMGenerator = gen.Struct(reflect.TypeOf(ApiError_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiErrorSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForApiErrorSTATUSARM(generators)
	apiErrorSTATUSARMGenerator = gen.Struct(reflect.TypeOf(ApiError_STATUSARM{}), generators)

	return apiErrorSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForApiErrorSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiErrorSTATUSARM(gens map[string]gopter.Gen) {
	gens["Code"] = gen.PtrOf(gen.AlphaString())
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForApiErrorSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForApiErrorSTATUSARM(gens map[string]gopter.Gen) {
	gens["Details"] = gen.SliceOf(ApiErrorBaseSTATUSARMGenerator())
	gens["Innererror"] = gen.PtrOf(InnerErrorSTATUSARMGenerator())
}

func Test_KeyVaultKeyReference_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultKeyReference_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultKeyReferenceSTATUSARM, KeyVaultKeyReferenceSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultKeyReferenceSTATUSARM runs a test to see if a specific instance of KeyVaultKeyReference_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultKeyReferenceSTATUSARM(subject KeyVaultKeyReference_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultKeyReference_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultKeyReference_STATUSARM instances for property testing - lazily instantiated by
// KeyVaultKeyReferenceSTATUSARMGenerator()
var keyVaultKeyReferenceSTATUSARMGenerator gopter.Gen

// KeyVaultKeyReferenceSTATUSARMGenerator returns a generator of KeyVaultKeyReference_STATUSARM instances for property testing.
// We first initialize keyVaultKeyReferenceSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultKeyReferenceSTATUSARMGenerator() gopter.Gen {
	if keyVaultKeyReferenceSTATUSARMGenerator != nil {
		return keyVaultKeyReferenceSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultKeyReferenceSTATUSARM(generators)
	keyVaultKeyReferenceSTATUSARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultKeyReference_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultKeyReferenceSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForKeyVaultKeyReferenceSTATUSARM(generators)
	keyVaultKeyReferenceSTATUSARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultKeyReference_STATUSARM{}), generators)

	return keyVaultKeyReferenceSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultKeyReferenceSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultKeyReferenceSTATUSARM(gens map[string]gopter.Gen) {
	gens["KeyUrl"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForKeyVaultKeyReferenceSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultKeyReferenceSTATUSARM(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SubResourceSTATUSARMGenerator())
}

func Test_KeyVaultSecretReference_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultSecretReference_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultSecretReferenceSTATUSARM, KeyVaultSecretReferenceSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultSecretReferenceSTATUSARM runs a test to see if a specific instance of KeyVaultSecretReference_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultSecretReferenceSTATUSARM(subject KeyVaultSecretReference_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultSecretReference_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultSecretReference_STATUSARM instances for property testing - lazily instantiated by
// KeyVaultSecretReferenceSTATUSARMGenerator()
var keyVaultSecretReferenceSTATUSARMGenerator gopter.Gen

// KeyVaultSecretReferenceSTATUSARMGenerator returns a generator of KeyVaultSecretReference_STATUSARM instances for property testing.
// We first initialize keyVaultSecretReferenceSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultSecretReferenceSTATUSARMGenerator() gopter.Gen {
	if keyVaultSecretReferenceSTATUSARMGenerator != nil {
		return keyVaultSecretReferenceSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultSecretReferenceSTATUSARM(generators)
	keyVaultSecretReferenceSTATUSARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultSecretReference_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultSecretReferenceSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForKeyVaultSecretReferenceSTATUSARM(generators)
	keyVaultSecretReferenceSTATUSARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultSecretReference_STATUSARM{}), generators)

	return keyVaultSecretReferenceSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultSecretReferenceSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultSecretReferenceSTATUSARM(gens map[string]gopter.Gen) {
	gens["SecretUrl"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForKeyVaultSecretReferenceSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultSecretReferenceSTATUSARM(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SubResourceSTATUSARMGenerator())
}

func Test_SshPublicKey_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SshPublicKey_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSshPublicKeySTATUSARM, SshPublicKeySTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSshPublicKeySTATUSARM runs a test to see if a specific instance of SshPublicKey_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSshPublicKeySTATUSARM(subject SshPublicKey_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SshPublicKey_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SshPublicKey_STATUSARM instances for property testing - lazily instantiated by
// SshPublicKeySTATUSARMGenerator()
var sshPublicKeySTATUSARMGenerator gopter.Gen

// SshPublicKeySTATUSARMGenerator returns a generator of SshPublicKey_STATUSARM instances for property testing.
func SshPublicKeySTATUSARMGenerator() gopter.Gen {
	if sshPublicKeySTATUSARMGenerator != nil {
		return sshPublicKeySTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSshPublicKeySTATUSARM(generators)
	sshPublicKeySTATUSARMGenerator = gen.Struct(reflect.TypeOf(SshPublicKey_STATUSARM{}), generators)

	return sshPublicKeySTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForSshPublicKeySTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSshPublicKeySTATUSARM(gens map[string]gopter.Gen) {
	gens["KeyData"] = gen.PtrOf(gen.AlphaString())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
}

func Test_WinRMListener_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WinRMListener_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWinRMListenerSTATUSARM, WinRMListenerSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWinRMListenerSTATUSARM runs a test to see if a specific instance of WinRMListener_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWinRMListenerSTATUSARM(subject WinRMListener_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WinRMListener_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WinRMListener_STATUSARM instances for property testing - lazily instantiated by
// WinRMListenerSTATUSARMGenerator()
var winRMListenerSTATUSARMGenerator gopter.Gen

// WinRMListenerSTATUSARMGenerator returns a generator of WinRMListener_STATUSARM instances for property testing.
func WinRMListenerSTATUSARMGenerator() gopter.Gen {
	if winRMListenerSTATUSARMGenerator != nil {
		return winRMListenerSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWinRMListenerSTATUSARM(generators)
	winRMListenerSTATUSARMGenerator = gen.Struct(reflect.TypeOf(WinRMListener_STATUSARM{}), generators)

	return winRMListenerSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForWinRMListenerSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWinRMListenerSTATUSARM(gens map[string]gopter.Gen) {
	gens["CertificateUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(WinRMListenerSTATUSProtocol_Http, WinRMListenerSTATUSProtocol_Https))
}

func Test_ApiErrorBase_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiErrorBase_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiErrorBaseSTATUSARM, ApiErrorBaseSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiErrorBaseSTATUSARM runs a test to see if a specific instance of ApiErrorBase_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForApiErrorBaseSTATUSARM(subject ApiErrorBase_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiErrorBase_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiErrorBase_STATUSARM instances for property testing - lazily instantiated by
// ApiErrorBaseSTATUSARMGenerator()
var apiErrorBaseSTATUSARMGenerator gopter.Gen

// ApiErrorBaseSTATUSARMGenerator returns a generator of ApiErrorBase_STATUSARM instances for property testing.
func ApiErrorBaseSTATUSARMGenerator() gopter.Gen {
	if apiErrorBaseSTATUSARMGenerator != nil {
		return apiErrorBaseSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiErrorBaseSTATUSARM(generators)
	apiErrorBaseSTATUSARMGenerator = gen.Struct(reflect.TypeOf(ApiErrorBase_STATUSARM{}), generators)

	return apiErrorBaseSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForApiErrorBaseSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiErrorBaseSTATUSARM(gens map[string]gopter.Gen) {
	gens["Code"] = gen.PtrOf(gen.AlphaString())
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
}

func Test_InnerError_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InnerError_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInnerErrorSTATUSARM, InnerErrorSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInnerErrorSTATUSARM runs a test to see if a specific instance of InnerError_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForInnerErrorSTATUSARM(subject InnerError_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InnerError_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InnerError_STATUSARM instances for property testing - lazily instantiated by
// InnerErrorSTATUSARMGenerator()
var innerErrorSTATUSARMGenerator gopter.Gen

// InnerErrorSTATUSARMGenerator returns a generator of InnerError_STATUSARM instances for property testing.
func InnerErrorSTATUSARMGenerator() gopter.Gen {
	if innerErrorSTATUSARMGenerator != nil {
		return innerErrorSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInnerErrorSTATUSARM(generators)
	innerErrorSTATUSARMGenerator = gen.Struct(reflect.TypeOf(InnerError_STATUSARM{}), generators)

	return innerErrorSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForInnerErrorSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInnerErrorSTATUSARM(gens map[string]gopter.Gen) {
	gens["Errordetail"] = gen.PtrOf(gen.AlphaString())
	gens["Exceptiontype"] = gen.PtrOf(gen.AlphaString())
}
