// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20201201

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_VirtualMachine_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachine_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachine_SpecARM, VirtualMachine_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachine_SpecARM runs a test to see if a specific instance of VirtualMachine_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachine_SpecARM(subject VirtualMachine_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachine_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachine_SpecARM instances for property testing - lazily instantiated by
// VirtualMachine_SpecARMGenerator()
var virtualMachine_SpecARMGenerator gopter.Gen

// VirtualMachine_SpecARMGenerator returns a generator of VirtualMachine_SpecARM instances for property testing.
// We first initialize virtualMachine_SpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachine_SpecARMGenerator() gopter.Gen {
	if virtualMachine_SpecARMGenerator != nil {
		return virtualMachine_SpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachine_SpecARM(generators)
	virtualMachine_SpecARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachine_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachine_SpecARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachine_SpecARM(generators)
	virtualMachine_SpecARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachine_SpecARM{}), generators)

	return virtualMachine_SpecARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachine_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachine_SpecARM(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachine_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachine_SpecARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationARMGenerator())
	gens["Identity"] = gen.PtrOf(VirtualMachineIdentityARMGenerator())
	gens["Plan"] = gen.PtrOf(PlanARMGenerator())
	gens["Properties"] = gen.PtrOf(VirtualMachinePropertiesARMGenerator())
}

func Test_VirtualMachineIdentityARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineIdentityARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineIdentityARM, VirtualMachineIdentityARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineIdentityARM runs a test to see if a specific instance of VirtualMachineIdentityARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineIdentityARM(subject VirtualMachineIdentityARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineIdentityARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineIdentityARM instances for property testing - lazily instantiated by
// VirtualMachineIdentityARMGenerator()
var virtualMachineIdentityARMGenerator gopter.Gen

// VirtualMachineIdentityARMGenerator returns a generator of VirtualMachineIdentityARM instances for property testing.
// We first initialize virtualMachineIdentityARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineIdentityARMGenerator() gopter.Gen {
	if virtualMachineIdentityARMGenerator != nil {
		return virtualMachineIdentityARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineIdentityARM(generators)
	virtualMachineIdentityARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineIdentityARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineIdentityARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineIdentityARM(generators)
	virtualMachineIdentityARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineIdentityARM{}), generators)

	return virtualMachineIdentityARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineIdentityARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineIdentityARM(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		VirtualMachineIdentity_Type_None,
		VirtualMachineIdentity_Type_SystemAssigned,
		VirtualMachineIdentity_Type_SystemAssignedUserAssigned,
		VirtualMachineIdentity_Type_UserAssigned))
}

// AddRelatedPropertyGeneratorsForVirtualMachineIdentityARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineIdentityARM(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), VirtualMachineIdentity_UserAssignedIdentitiesARMGenerator())
}

func Test_VirtualMachinePropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachinePropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachinePropertiesARM, VirtualMachinePropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachinePropertiesARM runs a test to see if a specific instance of VirtualMachinePropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachinePropertiesARM(subject VirtualMachinePropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachinePropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachinePropertiesARM instances for property testing - lazily instantiated by
// VirtualMachinePropertiesARMGenerator()
var virtualMachinePropertiesARMGenerator gopter.Gen

// VirtualMachinePropertiesARMGenerator returns a generator of VirtualMachinePropertiesARM instances for property testing.
// We first initialize virtualMachinePropertiesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachinePropertiesARMGenerator() gopter.Gen {
	if virtualMachinePropertiesARMGenerator != nil {
		return virtualMachinePropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinePropertiesARM(generators)
	virtualMachinePropertiesARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachinePropertiesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachinePropertiesARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachinePropertiesARM(generators)
	virtualMachinePropertiesARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachinePropertiesARM{}), generators)

	return virtualMachinePropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachinePropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachinePropertiesARM(gens map[string]gopter.Gen) {
	gens["EvictionPolicy"] = gen.PtrOf(gen.OneConstOf(EvictionPolicy_Deallocate, EvictionPolicy_Delete))
	gens["ExtensionsTimeBudget"] = gen.PtrOf(gen.AlphaString())
	gens["LicenseType"] = gen.PtrOf(gen.AlphaString())
	gens["PlatformFaultDomain"] = gen.PtrOf(gen.Int())
	gens["Priority"] = gen.PtrOf(gen.OneConstOf(Priority_Low, Priority_Regular, Priority_Spot))
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["VmId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachinePropertiesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachinePropertiesARM(gens map[string]gopter.Gen) {
	gens["AdditionalCapabilities"] = gen.PtrOf(AdditionalCapabilitiesARMGenerator())
	gens["AvailabilitySet"] = gen.PtrOf(SubResourceARMGenerator())
	gens["BillingProfile"] = gen.PtrOf(BillingProfileARMGenerator())
	gens["DiagnosticsProfile"] = gen.PtrOf(DiagnosticsProfileARMGenerator())
	gens["HardwareProfile"] = gen.PtrOf(HardwareProfileARMGenerator())
	gens["Host"] = gen.PtrOf(SubResourceARMGenerator())
	gens["HostGroup"] = gen.PtrOf(SubResourceARMGenerator())
	gens["InstanceView"] = gen.PtrOf(VirtualMachineInstanceViewARMGenerator())
	gens["NetworkProfile"] = gen.PtrOf(NetworkProfileARMGenerator())
	gens["OsProfile"] = gen.PtrOf(OSProfileARMGenerator())
	gens["ProximityPlacementGroup"] = gen.PtrOf(SubResourceARMGenerator())
	gens["SecurityProfile"] = gen.PtrOf(SecurityProfileARMGenerator())
	gens["StorageProfile"] = gen.PtrOf(StorageProfileARMGenerator())
	gens["VirtualMachineScaleSet"] = gen.PtrOf(SubResourceARMGenerator())
}

func Test_BillingProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BillingProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBillingProfileARM, BillingProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBillingProfileARM runs a test to see if a specific instance of BillingProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBillingProfileARM(subject BillingProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BillingProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BillingProfileARM instances for property testing - lazily instantiated by BillingProfileARMGenerator()
var billingProfileARMGenerator gopter.Gen

// BillingProfileARMGenerator returns a generator of BillingProfileARM instances for property testing.
func BillingProfileARMGenerator() gopter.Gen {
	if billingProfileARMGenerator != nil {
		return billingProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBillingProfileARM(generators)
	billingProfileARMGenerator = gen.Struct(reflect.TypeOf(BillingProfileARM{}), generators)

	return billingProfileARMGenerator
}

// AddIndependentPropertyGeneratorsForBillingProfileARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBillingProfileARM(gens map[string]gopter.Gen) {
	gens["MaxPrice"] = gen.PtrOf(gen.Float64())
}

func Test_DiagnosticsProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiagnosticsProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiagnosticsProfileARM, DiagnosticsProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiagnosticsProfileARM runs a test to see if a specific instance of DiagnosticsProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiagnosticsProfileARM(subject DiagnosticsProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiagnosticsProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiagnosticsProfileARM instances for property testing - lazily instantiated by
// DiagnosticsProfileARMGenerator()
var diagnosticsProfileARMGenerator gopter.Gen

// DiagnosticsProfileARMGenerator returns a generator of DiagnosticsProfileARM instances for property testing.
func DiagnosticsProfileARMGenerator() gopter.Gen {
	if diagnosticsProfileARMGenerator != nil {
		return diagnosticsProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDiagnosticsProfileARM(generators)
	diagnosticsProfileARMGenerator = gen.Struct(reflect.TypeOf(DiagnosticsProfileARM{}), generators)

	return diagnosticsProfileARMGenerator
}

// AddRelatedPropertyGeneratorsForDiagnosticsProfileARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiagnosticsProfileARM(gens map[string]gopter.Gen) {
	gens["BootDiagnostics"] = gen.PtrOf(BootDiagnosticsARMGenerator())
}

func Test_HardwareProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HardwareProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHardwareProfileARM, HardwareProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHardwareProfileARM runs a test to see if a specific instance of HardwareProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHardwareProfileARM(subject HardwareProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HardwareProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HardwareProfileARM instances for property testing - lazily instantiated by HardwareProfileARMGenerator()
var hardwareProfileARMGenerator gopter.Gen

// HardwareProfileARMGenerator returns a generator of HardwareProfileARM instances for property testing.
func HardwareProfileARMGenerator() gopter.Gen {
	if hardwareProfileARMGenerator != nil {
		return hardwareProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHardwareProfileARM(generators)
	hardwareProfileARMGenerator = gen.Struct(reflect.TypeOf(HardwareProfileARM{}), generators)

	return hardwareProfileARMGenerator
}

// AddIndependentPropertyGeneratorsForHardwareProfileARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHardwareProfileARM(gens map[string]gopter.Gen) {
	gens["VmSize"] = gen.PtrOf(gen.OneConstOf(
		HardwareProfile_VmSize_Basic_A0,
		HardwareProfile_VmSize_Basic_A1,
		HardwareProfile_VmSize_Basic_A2,
		HardwareProfile_VmSize_Basic_A3,
		HardwareProfile_VmSize_Basic_A4,
		HardwareProfile_VmSize_Standard_A0,
		HardwareProfile_VmSize_Standard_A1,
		HardwareProfile_VmSize_Standard_A10,
		HardwareProfile_VmSize_Standard_A11,
		HardwareProfile_VmSize_Standard_A1_V2,
		HardwareProfile_VmSize_Standard_A2,
		HardwareProfile_VmSize_Standard_A2M_V2,
		HardwareProfile_VmSize_Standard_A2_V2,
		HardwareProfile_VmSize_Standard_A3,
		HardwareProfile_VmSize_Standard_A4,
		HardwareProfile_VmSize_Standard_A4M_V2,
		HardwareProfile_VmSize_Standard_A4_V2,
		HardwareProfile_VmSize_Standard_A5,
		HardwareProfile_VmSize_Standard_A6,
		HardwareProfile_VmSize_Standard_A7,
		HardwareProfile_VmSize_Standard_A8,
		HardwareProfile_VmSize_Standard_A8M_V2,
		HardwareProfile_VmSize_Standard_A8_V2,
		HardwareProfile_VmSize_Standard_A9,
		HardwareProfile_VmSize_Standard_B1Ms,
		HardwareProfile_VmSize_Standard_B1S,
		HardwareProfile_VmSize_Standard_B2Ms,
		HardwareProfile_VmSize_Standard_B2S,
		HardwareProfile_VmSize_Standard_B4Ms,
		HardwareProfile_VmSize_Standard_B8Ms,
		HardwareProfile_VmSize_Standard_D1,
		HardwareProfile_VmSize_Standard_D11,
		HardwareProfile_VmSize_Standard_D11_V2,
		HardwareProfile_VmSize_Standard_D12,
		HardwareProfile_VmSize_Standard_D12_V2,
		HardwareProfile_VmSize_Standard_D13,
		HardwareProfile_VmSize_Standard_D13_V2,
		HardwareProfile_VmSize_Standard_D14,
		HardwareProfile_VmSize_Standard_D14_V2,
		HardwareProfile_VmSize_Standard_D15_V2,
		HardwareProfile_VmSize_Standard_D16S_V3,
		HardwareProfile_VmSize_Standard_D16_V3,
		HardwareProfile_VmSize_Standard_D1_V2,
		HardwareProfile_VmSize_Standard_D2,
		HardwareProfile_VmSize_Standard_D2S_V3,
		HardwareProfile_VmSize_Standard_D2_V2,
		HardwareProfile_VmSize_Standard_D2_V3,
		HardwareProfile_VmSize_Standard_D3,
		HardwareProfile_VmSize_Standard_D32S_V3,
		HardwareProfile_VmSize_Standard_D32_V3,
		HardwareProfile_VmSize_Standard_D3_V2,
		HardwareProfile_VmSize_Standard_D4,
		HardwareProfile_VmSize_Standard_D4S_V3,
		HardwareProfile_VmSize_Standard_D4_V2,
		HardwareProfile_VmSize_Standard_D4_V3,
		HardwareProfile_VmSize_Standard_D5_V2,
		HardwareProfile_VmSize_Standard_D64S_V3,
		HardwareProfile_VmSize_Standard_D64_V3,
		HardwareProfile_VmSize_Standard_D8S_V3,
		HardwareProfile_VmSize_Standard_D8_V3,
		HardwareProfile_VmSize_Standard_DS1,
		HardwareProfile_VmSize_Standard_DS11,
		HardwareProfile_VmSize_Standard_DS11_V2,
		HardwareProfile_VmSize_Standard_DS12,
		HardwareProfile_VmSize_Standard_DS12_V2,
		HardwareProfile_VmSize_Standard_DS13,
		HardwareProfile_VmSize_Standard_DS132_V2,
		HardwareProfile_VmSize_Standard_DS134_V2,
		HardwareProfile_VmSize_Standard_DS13_V2,
		HardwareProfile_VmSize_Standard_DS14,
		HardwareProfile_VmSize_Standard_DS144_V2,
		HardwareProfile_VmSize_Standard_DS148_V2,
		HardwareProfile_VmSize_Standard_DS14_V2,
		HardwareProfile_VmSize_Standard_DS15_V2,
		HardwareProfile_VmSize_Standard_DS1_V2,
		HardwareProfile_VmSize_Standard_DS2,
		HardwareProfile_VmSize_Standard_DS2_V2,
		HardwareProfile_VmSize_Standard_DS3,
		HardwareProfile_VmSize_Standard_DS3_V2,
		HardwareProfile_VmSize_Standard_DS4,
		HardwareProfile_VmSize_Standard_DS4_V2,
		HardwareProfile_VmSize_Standard_DS5_V2,
		HardwareProfile_VmSize_Standard_E16S_V3,
		HardwareProfile_VmSize_Standard_E16_V3,
		HardwareProfile_VmSize_Standard_E2S_V3,
		HardwareProfile_VmSize_Standard_E2_V3,
		HardwareProfile_VmSize_Standard_E3216_V3,
		HardwareProfile_VmSize_Standard_E328S_V3,
		HardwareProfile_VmSize_Standard_E32S_V3,
		HardwareProfile_VmSize_Standard_E32_V3,
		HardwareProfile_VmSize_Standard_E4S_V3,
		HardwareProfile_VmSize_Standard_E4_V3,
		HardwareProfile_VmSize_Standard_E6416S_V3,
		HardwareProfile_VmSize_Standard_E6432S_V3,
		HardwareProfile_VmSize_Standard_E64S_V3,
		HardwareProfile_VmSize_Standard_E64_V3,
		HardwareProfile_VmSize_Standard_E8S_V3,
		HardwareProfile_VmSize_Standard_E8_V3,
		HardwareProfile_VmSize_Standard_F1,
		HardwareProfile_VmSize_Standard_F16,
		HardwareProfile_VmSize_Standard_F16S,
		HardwareProfile_VmSize_Standard_F16S_V2,
		HardwareProfile_VmSize_Standard_F1S,
		HardwareProfile_VmSize_Standard_F2,
		HardwareProfile_VmSize_Standard_F2S,
		HardwareProfile_VmSize_Standard_F2S_V2,
		HardwareProfile_VmSize_Standard_F32S_V2,
		HardwareProfile_VmSize_Standard_F4,
		HardwareProfile_VmSize_Standard_F4S,
		HardwareProfile_VmSize_Standard_F4S_V2,
		HardwareProfile_VmSize_Standard_F64S_V2,
		HardwareProfile_VmSize_Standard_F72S_V2,
		HardwareProfile_VmSize_Standard_F8,
		HardwareProfile_VmSize_Standard_F8S,
		HardwareProfile_VmSize_Standard_F8S_V2,
		HardwareProfile_VmSize_Standard_G1,
		HardwareProfile_VmSize_Standard_G2,
		HardwareProfile_VmSize_Standard_G3,
		HardwareProfile_VmSize_Standard_G4,
		HardwareProfile_VmSize_Standard_G5,
		HardwareProfile_VmSize_Standard_GS1,
		HardwareProfile_VmSize_Standard_GS2,
		HardwareProfile_VmSize_Standard_GS3,
		HardwareProfile_VmSize_Standard_GS4,
		HardwareProfile_VmSize_Standard_GS44,
		HardwareProfile_VmSize_Standard_GS48,
		HardwareProfile_VmSize_Standard_GS5,
		HardwareProfile_VmSize_Standard_GS516,
		HardwareProfile_VmSize_Standard_GS58,
		HardwareProfile_VmSize_Standard_H16,
		HardwareProfile_VmSize_Standard_H16M,
		HardwareProfile_VmSize_Standard_H16Mr,
		HardwareProfile_VmSize_Standard_H16R,
		HardwareProfile_VmSize_Standard_H8,
		HardwareProfile_VmSize_Standard_H8M,
		HardwareProfile_VmSize_Standard_L16S,
		HardwareProfile_VmSize_Standard_L32S,
		HardwareProfile_VmSize_Standard_L4S,
		HardwareProfile_VmSize_Standard_L8S,
		HardwareProfile_VmSize_Standard_M12832Ms,
		HardwareProfile_VmSize_Standard_M12864Ms,
		HardwareProfile_VmSize_Standard_M128Ms,
		HardwareProfile_VmSize_Standard_M128S,
		HardwareProfile_VmSize_Standard_M6416Ms,
		HardwareProfile_VmSize_Standard_M6432Ms,
		HardwareProfile_VmSize_Standard_M64Ms,
		HardwareProfile_VmSize_Standard_M64S,
		HardwareProfile_VmSize_Standard_NC12,
		HardwareProfile_VmSize_Standard_NC12S_V2,
		HardwareProfile_VmSize_Standard_NC12S_V3,
		HardwareProfile_VmSize_Standard_NC24,
		HardwareProfile_VmSize_Standard_NC24R,
		HardwareProfile_VmSize_Standard_NC24Rs_V2,
		HardwareProfile_VmSize_Standard_NC24Rs_V3,
		HardwareProfile_VmSize_Standard_NC24S_V2,
		HardwareProfile_VmSize_Standard_NC24S_V3,
		HardwareProfile_VmSize_Standard_NC6,
		HardwareProfile_VmSize_Standard_NC6S_V2,
		HardwareProfile_VmSize_Standard_NC6S_V3,
		HardwareProfile_VmSize_Standard_ND12S,
		HardwareProfile_VmSize_Standard_ND24Rs,
		HardwareProfile_VmSize_Standard_ND24S,
		HardwareProfile_VmSize_Standard_ND6S,
		HardwareProfile_VmSize_Standard_NV12,
		HardwareProfile_VmSize_Standard_NV24,
		HardwareProfile_VmSize_Standard_NV6))
}

func Test_NetworkProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkProfileARM, NetworkProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkProfileARM runs a test to see if a specific instance of NetworkProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkProfileARM(subject NetworkProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkProfileARM instances for property testing - lazily instantiated by NetworkProfileARMGenerator()
var networkProfileARMGenerator gopter.Gen

// NetworkProfileARMGenerator returns a generator of NetworkProfileARM instances for property testing.
func NetworkProfileARMGenerator() gopter.Gen {
	if networkProfileARMGenerator != nil {
		return networkProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForNetworkProfileARM(generators)
	networkProfileARMGenerator = gen.Struct(reflect.TypeOf(NetworkProfileARM{}), generators)

	return networkProfileARMGenerator
}

// AddRelatedPropertyGeneratorsForNetworkProfileARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkProfileARM(gens map[string]gopter.Gen) {
	gens["NetworkInterfaces"] = gen.SliceOf(NetworkInterfaceReferenceARMGenerator())
}

func Test_OSProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OSProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOSProfileARM, OSProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOSProfileARM runs a test to see if a specific instance of OSProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOSProfileARM(subject OSProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OSProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OSProfileARM instances for property testing - lazily instantiated by OSProfileARMGenerator()
var osProfileARMGenerator gopter.Gen

// OSProfileARMGenerator returns a generator of OSProfileARM instances for property testing.
// We first initialize osProfileARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OSProfileARMGenerator() gopter.Gen {
	if osProfileARMGenerator != nil {
		return osProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSProfileARM(generators)
	osProfileARMGenerator = gen.Struct(reflect.TypeOf(OSProfileARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSProfileARM(generators)
	AddRelatedPropertyGeneratorsForOSProfileARM(generators)
	osProfileARMGenerator = gen.Struct(reflect.TypeOf(OSProfileARM{}), generators)

	return osProfileARMGenerator
}

// AddIndependentPropertyGeneratorsForOSProfileARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOSProfileARM(gens map[string]gopter.Gen) {
	gens["AdminPassword"] = gen.PtrOf(gen.AlphaString())
	gens["AdminUsername"] = gen.PtrOf(gen.AlphaString())
	gens["AllowExtensionOperations"] = gen.PtrOf(gen.Bool())
	gens["ComputerName"] = gen.PtrOf(gen.AlphaString())
	gens["CustomData"] = gen.PtrOf(gen.AlphaString())
	gens["RequireGuestProvisionSignal"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForOSProfileARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOSProfileARM(gens map[string]gopter.Gen) {
	gens["LinuxConfiguration"] = gen.PtrOf(LinuxConfigurationARMGenerator())
	gens["Secrets"] = gen.SliceOf(VaultSecretGroupARMGenerator())
	gens["WindowsConfiguration"] = gen.PtrOf(WindowsConfigurationARMGenerator())
}

func Test_SecurityProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SecurityProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSecurityProfileARM, SecurityProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSecurityProfileARM runs a test to see if a specific instance of SecurityProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSecurityProfileARM(subject SecurityProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SecurityProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SecurityProfileARM instances for property testing - lazily instantiated by SecurityProfileARMGenerator()
var securityProfileARMGenerator gopter.Gen

// SecurityProfileARMGenerator returns a generator of SecurityProfileARM instances for property testing.
// We first initialize securityProfileARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SecurityProfileARMGenerator() gopter.Gen {
	if securityProfileARMGenerator != nil {
		return securityProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecurityProfileARM(generators)
	securityProfileARMGenerator = gen.Struct(reflect.TypeOf(SecurityProfileARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecurityProfileARM(generators)
	AddRelatedPropertyGeneratorsForSecurityProfileARM(generators)
	securityProfileARMGenerator = gen.Struct(reflect.TypeOf(SecurityProfileARM{}), generators)

	return securityProfileARMGenerator
}

// AddIndependentPropertyGeneratorsForSecurityProfileARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSecurityProfileARM(gens map[string]gopter.Gen) {
	gens["EncryptionAtHost"] = gen.PtrOf(gen.Bool())
	gens["SecurityType"] = gen.PtrOf(gen.OneConstOf(SecurityProfile_SecurityType_TrustedLaunch))
}

// AddRelatedPropertyGeneratorsForSecurityProfileARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSecurityProfileARM(gens map[string]gopter.Gen) {
	gens["UefiSettings"] = gen.PtrOf(UefiSettingsARMGenerator())
}

func Test_StorageProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageProfileARM, StorageProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageProfileARM runs a test to see if a specific instance of StorageProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageProfileARM(subject StorageProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageProfileARM instances for property testing - lazily instantiated by StorageProfileARMGenerator()
var storageProfileARMGenerator gopter.Gen

// StorageProfileARMGenerator returns a generator of StorageProfileARM instances for property testing.
func StorageProfileARMGenerator() gopter.Gen {
	if storageProfileARMGenerator != nil {
		return storageProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForStorageProfileARM(generators)
	storageProfileARMGenerator = gen.Struct(reflect.TypeOf(StorageProfileARM{}), generators)

	return storageProfileARMGenerator
}

// AddRelatedPropertyGeneratorsForStorageProfileARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageProfileARM(gens map[string]gopter.Gen) {
	gens["DataDisks"] = gen.SliceOf(DataDiskARMGenerator())
	gens["ImageReference"] = gen.PtrOf(ImageReferenceARMGenerator())
	gens["OsDisk"] = gen.PtrOf(OSDiskARMGenerator())
}

func Test_VirtualMachineIdentity_UserAssignedIdentitiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineIdentity_UserAssignedIdentitiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineIdentity_UserAssignedIdentitiesARM, VirtualMachineIdentity_UserAssignedIdentitiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineIdentity_UserAssignedIdentitiesARM runs a test to see if a specific instance of VirtualMachineIdentity_UserAssignedIdentitiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineIdentity_UserAssignedIdentitiesARM(subject VirtualMachineIdentity_UserAssignedIdentitiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineIdentity_UserAssignedIdentitiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineIdentity_UserAssignedIdentitiesARM instances for property testing - lazily instantiated by
// VirtualMachineIdentity_UserAssignedIdentitiesARMGenerator()
var virtualMachineIdentity_UserAssignedIdentitiesARMGenerator gopter.Gen

// VirtualMachineIdentity_UserAssignedIdentitiesARMGenerator returns a generator of VirtualMachineIdentity_UserAssignedIdentitiesARM instances for property testing.
func VirtualMachineIdentity_UserAssignedIdentitiesARMGenerator() gopter.Gen {
	if virtualMachineIdentity_UserAssignedIdentitiesARMGenerator != nil {
		return virtualMachineIdentity_UserAssignedIdentitiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineIdentity_UserAssignedIdentitiesARM(generators)
	virtualMachineIdentity_UserAssignedIdentitiesARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineIdentity_UserAssignedIdentitiesARM{}), generators)

	return virtualMachineIdentity_UserAssignedIdentitiesARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineIdentity_UserAssignedIdentitiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineIdentity_UserAssignedIdentitiesARM(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachineInstanceViewARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineInstanceViewARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineInstanceViewARM, VirtualMachineInstanceViewARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineInstanceViewARM runs a test to see if a specific instance of VirtualMachineInstanceViewARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineInstanceViewARM(subject VirtualMachineInstanceViewARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineInstanceViewARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineInstanceViewARM instances for property testing - lazily instantiated by
// VirtualMachineInstanceViewARMGenerator()
var virtualMachineInstanceViewARMGenerator gopter.Gen

// VirtualMachineInstanceViewARMGenerator returns a generator of VirtualMachineInstanceViewARM instances for property testing.
// We first initialize virtualMachineInstanceViewARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineInstanceViewARMGenerator() gopter.Gen {
	if virtualMachineInstanceViewARMGenerator != nil {
		return virtualMachineInstanceViewARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineInstanceViewARM(generators)
	virtualMachineInstanceViewARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineInstanceViewARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineInstanceViewARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineInstanceViewARM(generators)
	virtualMachineInstanceViewARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineInstanceViewARM{}), generators)

	return virtualMachineInstanceViewARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineInstanceViewARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineInstanceViewARM(gens map[string]gopter.Gen) {
	gens["AssignedHost"] = gen.PtrOf(gen.AlphaString())
	gens["ComputerName"] = gen.PtrOf(gen.AlphaString())
	gens["HyperVGeneration"] = gen.PtrOf(gen.OneConstOf(VirtualMachineInstanceView_HyperVGeneration_V1, VirtualMachineInstanceView_HyperVGeneration_V2))
	gens["OsName"] = gen.PtrOf(gen.AlphaString())
	gens["OsVersion"] = gen.PtrOf(gen.AlphaString())
	gens["PlatformFaultDomain"] = gen.PtrOf(gen.Int())
	gens["PlatformUpdateDomain"] = gen.PtrOf(gen.Int())
	gens["RdpThumbPrint"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineInstanceViewARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineInstanceViewARM(gens map[string]gopter.Gen) {
	gens["BootDiagnostics"] = gen.PtrOf(BootDiagnosticsInstanceViewARMGenerator())
	gens["Disks"] = gen.SliceOf(DiskInstanceViewARMGenerator())
	gens["Extensions"] = gen.SliceOf(VirtualMachineExtensionInstanceViewARMGenerator())
	gens["MaintenanceRedeployStatus"] = gen.PtrOf(MaintenanceRedeployStatusARMGenerator())
	gens["PatchStatus"] = gen.PtrOf(VirtualMachinePatchStatusARMGenerator())
	gens["Statuses"] = gen.SliceOf(InstanceViewStatusARMGenerator())
	gens["VmAgent"] = gen.PtrOf(VirtualMachineAgentInstanceViewARMGenerator())
	gens["VmHealth"] = gen.PtrOf(VirtualMachineHealthStatusARMGenerator())
}

func Test_BootDiagnosticsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BootDiagnosticsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBootDiagnosticsARM, BootDiagnosticsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBootDiagnosticsARM runs a test to see if a specific instance of BootDiagnosticsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBootDiagnosticsARM(subject BootDiagnosticsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BootDiagnosticsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BootDiagnosticsARM instances for property testing - lazily instantiated by BootDiagnosticsARMGenerator()
var bootDiagnosticsARMGenerator gopter.Gen

// BootDiagnosticsARMGenerator returns a generator of BootDiagnosticsARM instances for property testing.
func BootDiagnosticsARMGenerator() gopter.Gen {
	if bootDiagnosticsARMGenerator != nil {
		return bootDiagnosticsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBootDiagnosticsARM(generators)
	bootDiagnosticsARMGenerator = gen.Struct(reflect.TypeOf(BootDiagnosticsARM{}), generators)

	return bootDiagnosticsARMGenerator
}

// AddIndependentPropertyGeneratorsForBootDiagnosticsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBootDiagnosticsARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["StorageUri"] = gen.PtrOf(gen.AlphaString())
}

func Test_BootDiagnosticsInstanceViewARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BootDiagnosticsInstanceViewARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBootDiagnosticsInstanceViewARM, BootDiagnosticsInstanceViewARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBootDiagnosticsInstanceViewARM runs a test to see if a specific instance of BootDiagnosticsInstanceViewARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBootDiagnosticsInstanceViewARM(subject BootDiagnosticsInstanceViewARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BootDiagnosticsInstanceViewARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BootDiagnosticsInstanceViewARM instances for property testing - lazily instantiated by
// BootDiagnosticsInstanceViewARMGenerator()
var bootDiagnosticsInstanceViewARMGenerator gopter.Gen

// BootDiagnosticsInstanceViewARMGenerator returns a generator of BootDiagnosticsInstanceViewARM instances for property testing.
// We first initialize bootDiagnosticsInstanceViewARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func BootDiagnosticsInstanceViewARMGenerator() gopter.Gen {
	if bootDiagnosticsInstanceViewARMGenerator != nil {
		return bootDiagnosticsInstanceViewARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBootDiagnosticsInstanceViewARM(generators)
	bootDiagnosticsInstanceViewARMGenerator = gen.Struct(reflect.TypeOf(BootDiagnosticsInstanceViewARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBootDiagnosticsInstanceViewARM(generators)
	AddRelatedPropertyGeneratorsForBootDiagnosticsInstanceViewARM(generators)
	bootDiagnosticsInstanceViewARMGenerator = gen.Struct(reflect.TypeOf(BootDiagnosticsInstanceViewARM{}), generators)

	return bootDiagnosticsInstanceViewARMGenerator
}

// AddIndependentPropertyGeneratorsForBootDiagnosticsInstanceViewARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBootDiagnosticsInstanceViewARM(gens map[string]gopter.Gen) {
	gens["ConsoleScreenshotBlobUri"] = gen.PtrOf(gen.AlphaString())
	gens["SerialConsoleLogBlobUri"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForBootDiagnosticsInstanceViewARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBootDiagnosticsInstanceViewARM(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(InstanceViewStatusARMGenerator())
}

func Test_DataDiskARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataDiskARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataDiskARM, DataDiskARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataDiskARM runs a test to see if a specific instance of DataDiskARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDataDiskARM(subject DataDiskARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataDiskARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataDiskARM instances for property testing - lazily instantiated by DataDiskARMGenerator()
var dataDiskARMGenerator gopter.Gen

// DataDiskARMGenerator returns a generator of DataDiskARM instances for property testing.
// We first initialize dataDiskARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DataDiskARMGenerator() gopter.Gen {
	if dataDiskARMGenerator != nil {
		return dataDiskARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataDiskARM(generators)
	dataDiskARMGenerator = gen.Struct(reflect.TypeOf(DataDiskARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataDiskARM(generators)
	AddRelatedPropertyGeneratorsForDataDiskARM(generators)
	dataDiskARMGenerator = gen.Struct(reflect.TypeOf(DataDiskARM{}), generators)

	return dataDiskARMGenerator
}

// AddIndependentPropertyGeneratorsForDataDiskARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDataDiskARM(gens map[string]gopter.Gen) {
	gens["Caching"] = gen.PtrOf(gen.OneConstOf(Caching_None, Caching_ReadOnly, Caching_ReadWrite))
	gens["CreateOption"] = gen.PtrOf(gen.OneConstOf(CreateOption_Attach, CreateOption_Empty, CreateOption_FromImage))
	gens["DetachOption"] = gen.PtrOf(gen.OneConstOf(DetachOption_ForceDetach))
	gens["DiskIOPSReadWrite"] = gen.PtrOf(gen.Int())
	gens["DiskMBpsReadWrite"] = gen.PtrOf(gen.Int())
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["Lun"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ToBeDetached"] = gen.PtrOf(gen.Bool())
	gens["WriteAcceleratorEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForDataDiskARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDataDiskARM(gens map[string]gopter.Gen) {
	gens["Image"] = gen.PtrOf(VirtualHardDiskARMGenerator())
	gens["ManagedDisk"] = gen.PtrOf(ManagedDiskParametersARMGenerator())
	gens["Vhd"] = gen.PtrOf(VirtualHardDiskARMGenerator())
}

func Test_DiskInstanceViewARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiskInstanceViewARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskInstanceViewARM, DiskInstanceViewARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskInstanceViewARM runs a test to see if a specific instance of DiskInstanceViewARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskInstanceViewARM(subject DiskInstanceViewARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiskInstanceViewARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiskInstanceViewARM instances for property testing - lazily instantiated by
// DiskInstanceViewARMGenerator()
var diskInstanceViewARMGenerator gopter.Gen

// DiskInstanceViewARMGenerator returns a generator of DiskInstanceViewARM instances for property testing.
// We first initialize diskInstanceViewARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DiskInstanceViewARMGenerator() gopter.Gen {
	if diskInstanceViewARMGenerator != nil {
		return diskInstanceViewARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskInstanceViewARM(generators)
	diskInstanceViewARMGenerator = gen.Struct(reflect.TypeOf(DiskInstanceViewARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskInstanceViewARM(generators)
	AddRelatedPropertyGeneratorsForDiskInstanceViewARM(generators)
	diskInstanceViewARMGenerator = gen.Struct(reflect.TypeOf(DiskInstanceViewARM{}), generators)

	return diskInstanceViewARMGenerator
}

// AddIndependentPropertyGeneratorsForDiskInstanceViewARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskInstanceViewARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDiskInstanceViewARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiskInstanceViewARM(gens map[string]gopter.Gen) {
	gens["EncryptionSettings"] = gen.SliceOf(DiskEncryptionSettingsARMGenerator())
	gens["Statuses"] = gen.SliceOf(InstanceViewStatusARMGenerator())
}

func Test_ImageReferenceARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ImageReferenceARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForImageReferenceARM, ImageReferenceARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForImageReferenceARM runs a test to see if a specific instance of ImageReferenceARM round trips to JSON and back losslessly
func RunJSONSerializationTestForImageReferenceARM(subject ImageReferenceARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ImageReferenceARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ImageReferenceARM instances for property testing - lazily instantiated by ImageReferenceARMGenerator()
var imageReferenceARMGenerator gopter.Gen

// ImageReferenceARMGenerator returns a generator of ImageReferenceARM instances for property testing.
func ImageReferenceARMGenerator() gopter.Gen {
	if imageReferenceARMGenerator != nil {
		return imageReferenceARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForImageReferenceARM(generators)
	imageReferenceARMGenerator = gen.Struct(reflect.TypeOf(ImageReferenceARM{}), generators)

	return imageReferenceARMGenerator
}

// AddIndependentPropertyGeneratorsForImageReferenceARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForImageReferenceARM(gens map[string]gopter.Gen) {
	gens["ExactVersion"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Offer"] = gen.PtrOf(gen.AlphaString())
	gens["Publisher"] = gen.PtrOf(gen.AlphaString())
	gens["Sku"] = gen.PtrOf(gen.AlphaString())
	gens["Version"] = gen.PtrOf(gen.AlphaString())
}

func Test_InstanceViewStatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InstanceViewStatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInstanceViewStatusARM, InstanceViewStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInstanceViewStatusARM runs a test to see if a specific instance of InstanceViewStatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForInstanceViewStatusARM(subject InstanceViewStatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InstanceViewStatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InstanceViewStatusARM instances for property testing - lazily instantiated by
// InstanceViewStatusARMGenerator()
var instanceViewStatusARMGenerator gopter.Gen

// InstanceViewStatusARMGenerator returns a generator of InstanceViewStatusARM instances for property testing.
func InstanceViewStatusARMGenerator() gopter.Gen {
	if instanceViewStatusARMGenerator != nil {
		return instanceViewStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInstanceViewStatusARM(generators)
	instanceViewStatusARMGenerator = gen.Struct(reflect.TypeOf(InstanceViewStatusARM{}), generators)

	return instanceViewStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForInstanceViewStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInstanceViewStatusARM(gens map[string]gopter.Gen) {
	gens["Code"] = gen.PtrOf(gen.AlphaString())
	gens["DisplayStatus"] = gen.PtrOf(gen.AlphaString())
	gens["Level"] = gen.PtrOf(gen.OneConstOf(InstanceViewStatus_Level_Error, InstanceViewStatus_Level_Info, InstanceViewStatus_Level_Warning))
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Time"] = gen.PtrOf(gen.AlphaString())
}

func Test_LinuxConfigurationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxConfigurationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxConfigurationARM, LinuxConfigurationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxConfigurationARM runs a test to see if a specific instance of LinuxConfigurationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxConfigurationARM(subject LinuxConfigurationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxConfigurationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxConfigurationARM instances for property testing - lazily instantiated by
// LinuxConfigurationARMGenerator()
var linuxConfigurationARMGenerator gopter.Gen

// LinuxConfigurationARMGenerator returns a generator of LinuxConfigurationARM instances for property testing.
// We first initialize linuxConfigurationARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LinuxConfigurationARMGenerator() gopter.Gen {
	if linuxConfigurationARMGenerator != nil {
		return linuxConfigurationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxConfigurationARM(generators)
	linuxConfigurationARMGenerator = gen.Struct(reflect.TypeOf(LinuxConfigurationARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxConfigurationARM(generators)
	AddRelatedPropertyGeneratorsForLinuxConfigurationARM(generators)
	linuxConfigurationARMGenerator = gen.Struct(reflect.TypeOf(LinuxConfigurationARM{}), generators)

	return linuxConfigurationARMGenerator
}

// AddIndependentPropertyGeneratorsForLinuxConfigurationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxConfigurationARM(gens map[string]gopter.Gen) {
	gens["DisablePasswordAuthentication"] = gen.PtrOf(gen.Bool())
	gens["ProvisionVMAgent"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForLinuxConfigurationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLinuxConfigurationARM(gens map[string]gopter.Gen) {
	gens["PatchSettings"] = gen.PtrOf(LinuxPatchSettingsARMGenerator())
	gens["Ssh"] = gen.PtrOf(SshConfigurationARMGenerator())
}

func Test_MaintenanceRedeployStatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MaintenanceRedeployStatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMaintenanceRedeployStatusARM, MaintenanceRedeployStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMaintenanceRedeployStatusARM runs a test to see if a specific instance of MaintenanceRedeployStatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForMaintenanceRedeployStatusARM(subject MaintenanceRedeployStatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MaintenanceRedeployStatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MaintenanceRedeployStatusARM instances for property testing - lazily instantiated by
// MaintenanceRedeployStatusARMGenerator()
var maintenanceRedeployStatusARMGenerator gopter.Gen

// MaintenanceRedeployStatusARMGenerator returns a generator of MaintenanceRedeployStatusARM instances for property testing.
func MaintenanceRedeployStatusARMGenerator() gopter.Gen {
	if maintenanceRedeployStatusARMGenerator != nil {
		return maintenanceRedeployStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMaintenanceRedeployStatusARM(generators)
	maintenanceRedeployStatusARMGenerator = gen.Struct(reflect.TypeOf(MaintenanceRedeployStatusARM{}), generators)

	return maintenanceRedeployStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForMaintenanceRedeployStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMaintenanceRedeployStatusARM(gens map[string]gopter.Gen) {
	gens["IsCustomerInitiatedMaintenanceAllowed"] = gen.PtrOf(gen.Bool())
	gens["LastOperationMessage"] = gen.PtrOf(gen.AlphaString())
	gens["LastOperationResultCode"] = gen.PtrOf(gen.OneConstOf(
		MaintenanceRedeployStatus_LastOperationResultCode_MaintenanceAborted,
		MaintenanceRedeployStatus_LastOperationResultCode_MaintenanceCompleted,
		MaintenanceRedeployStatus_LastOperationResultCode_None,
		MaintenanceRedeployStatus_LastOperationResultCode_RetryLater))
	gens["MaintenanceWindowEndTime"] = gen.PtrOf(gen.AlphaString())
	gens["MaintenanceWindowStartTime"] = gen.PtrOf(gen.AlphaString())
	gens["PreMaintenanceWindowEndTime"] = gen.PtrOf(gen.AlphaString())
	gens["PreMaintenanceWindowStartTime"] = gen.PtrOf(gen.AlphaString())
}

func Test_NetworkInterfaceReferenceARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceReferenceARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceReferenceARM, NetworkInterfaceReferenceARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceReferenceARM runs a test to see if a specific instance of NetworkInterfaceReferenceARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceReferenceARM(subject NetworkInterfaceReferenceARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceReferenceARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceReferenceARM instances for property testing - lazily instantiated by
// NetworkInterfaceReferenceARMGenerator()
var networkInterfaceReferenceARMGenerator gopter.Gen

// NetworkInterfaceReferenceARMGenerator returns a generator of NetworkInterfaceReferenceARM instances for property testing.
// We first initialize networkInterfaceReferenceARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkInterfaceReferenceARMGenerator() gopter.Gen {
	if networkInterfaceReferenceARMGenerator != nil {
		return networkInterfaceReferenceARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceReferenceARM(generators)
	networkInterfaceReferenceARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceReferenceARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceReferenceARM(generators)
	AddRelatedPropertyGeneratorsForNetworkInterfaceReferenceARM(generators)
	networkInterfaceReferenceARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceReferenceARM{}), generators)

	return networkInterfaceReferenceARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceReferenceARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceReferenceARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNetworkInterfaceReferenceARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkInterfaceReferenceARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(NetworkInterfaceReferencePropertiesARMGenerator())
}

func Test_OSDiskARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OSDiskARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOSDiskARM, OSDiskARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOSDiskARM runs a test to see if a specific instance of OSDiskARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOSDiskARM(subject OSDiskARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OSDiskARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OSDiskARM instances for property testing - lazily instantiated by OSDiskARMGenerator()
var osDiskARMGenerator gopter.Gen

// OSDiskARMGenerator returns a generator of OSDiskARM instances for property testing.
// We first initialize osDiskARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OSDiskARMGenerator() gopter.Gen {
	if osDiskARMGenerator != nil {
		return osDiskARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSDiskARM(generators)
	osDiskARMGenerator = gen.Struct(reflect.TypeOf(OSDiskARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOSDiskARM(generators)
	AddRelatedPropertyGeneratorsForOSDiskARM(generators)
	osDiskARMGenerator = gen.Struct(reflect.TypeOf(OSDiskARM{}), generators)

	return osDiskARMGenerator
}

// AddIndependentPropertyGeneratorsForOSDiskARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOSDiskARM(gens map[string]gopter.Gen) {
	gens["Caching"] = gen.PtrOf(gen.OneConstOf(Caching_None, Caching_ReadOnly, Caching_ReadWrite))
	gens["CreateOption"] = gen.PtrOf(gen.OneConstOf(CreateOption_Attach, CreateOption_Empty, CreateOption_FromImage))
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["OsType"] = gen.PtrOf(gen.OneConstOf(OSDisk_OsType_Linux, OSDisk_OsType_Windows))
	gens["WriteAcceleratorEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForOSDiskARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOSDiskARM(gens map[string]gopter.Gen) {
	gens["DiffDiskSettings"] = gen.PtrOf(DiffDiskSettingsARMGenerator())
	gens["EncryptionSettings"] = gen.PtrOf(DiskEncryptionSettingsARMGenerator())
	gens["Image"] = gen.PtrOf(VirtualHardDiskARMGenerator())
	gens["ManagedDisk"] = gen.PtrOf(ManagedDiskParametersARMGenerator())
	gens["Vhd"] = gen.PtrOf(VirtualHardDiskARMGenerator())
}

func Test_UefiSettingsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UefiSettingsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUefiSettingsARM, UefiSettingsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUefiSettingsARM runs a test to see if a specific instance of UefiSettingsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUefiSettingsARM(subject UefiSettingsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UefiSettingsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UefiSettingsARM instances for property testing - lazily instantiated by UefiSettingsARMGenerator()
var uefiSettingsARMGenerator gopter.Gen

// UefiSettingsARMGenerator returns a generator of UefiSettingsARM instances for property testing.
func UefiSettingsARMGenerator() gopter.Gen {
	if uefiSettingsARMGenerator != nil {
		return uefiSettingsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUefiSettingsARM(generators)
	uefiSettingsARMGenerator = gen.Struct(reflect.TypeOf(UefiSettingsARM{}), generators)

	return uefiSettingsARMGenerator
}

// AddIndependentPropertyGeneratorsForUefiSettingsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUefiSettingsARM(gens map[string]gopter.Gen) {
	gens["SecureBootEnabled"] = gen.PtrOf(gen.Bool())
	gens["VTpmEnabled"] = gen.PtrOf(gen.Bool())
}

func Test_VaultSecretGroupARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultSecretGroupARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultSecretGroupARM, VaultSecretGroupARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultSecretGroupARM runs a test to see if a specific instance of VaultSecretGroupARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultSecretGroupARM(subject VaultSecretGroupARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultSecretGroupARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultSecretGroupARM instances for property testing - lazily instantiated by
// VaultSecretGroupARMGenerator()
var vaultSecretGroupARMGenerator gopter.Gen

// VaultSecretGroupARMGenerator returns a generator of VaultSecretGroupARM instances for property testing.
func VaultSecretGroupARMGenerator() gopter.Gen {
	if vaultSecretGroupARMGenerator != nil {
		return vaultSecretGroupARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVaultSecretGroupARM(generators)
	vaultSecretGroupARMGenerator = gen.Struct(reflect.TypeOf(VaultSecretGroupARM{}), generators)

	return vaultSecretGroupARMGenerator
}

// AddRelatedPropertyGeneratorsForVaultSecretGroupARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVaultSecretGroupARM(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SubResourceARMGenerator())
	gens["VaultCertificates"] = gen.SliceOf(VaultCertificateARMGenerator())
}

func Test_VirtualMachineAgentInstanceViewARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineAgentInstanceViewARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineAgentInstanceViewARM, VirtualMachineAgentInstanceViewARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineAgentInstanceViewARM runs a test to see if a specific instance of VirtualMachineAgentInstanceViewARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineAgentInstanceViewARM(subject VirtualMachineAgentInstanceViewARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineAgentInstanceViewARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineAgentInstanceViewARM instances for property testing - lazily instantiated by
// VirtualMachineAgentInstanceViewARMGenerator()
var virtualMachineAgentInstanceViewARMGenerator gopter.Gen

// VirtualMachineAgentInstanceViewARMGenerator returns a generator of VirtualMachineAgentInstanceViewARM instances for property testing.
// We first initialize virtualMachineAgentInstanceViewARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineAgentInstanceViewARMGenerator() gopter.Gen {
	if virtualMachineAgentInstanceViewARMGenerator != nil {
		return virtualMachineAgentInstanceViewARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineAgentInstanceViewARM(generators)
	virtualMachineAgentInstanceViewARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineAgentInstanceViewARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineAgentInstanceViewARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineAgentInstanceViewARM(generators)
	virtualMachineAgentInstanceViewARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineAgentInstanceViewARM{}), generators)

	return virtualMachineAgentInstanceViewARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineAgentInstanceViewARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineAgentInstanceViewARM(gens map[string]gopter.Gen) {
	gens["VmAgentVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineAgentInstanceViewARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineAgentInstanceViewARM(gens map[string]gopter.Gen) {
	gens["ExtensionHandlers"] = gen.SliceOf(VirtualMachineExtensionHandlerInstanceViewARMGenerator())
	gens["Statuses"] = gen.SliceOf(InstanceViewStatusARMGenerator())
}

func Test_VirtualMachineExtensionInstanceViewARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineExtensionInstanceViewARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineExtensionInstanceViewARM, VirtualMachineExtensionInstanceViewARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineExtensionInstanceViewARM runs a test to see if a specific instance of VirtualMachineExtensionInstanceViewARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineExtensionInstanceViewARM(subject VirtualMachineExtensionInstanceViewARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineExtensionInstanceViewARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineExtensionInstanceViewARM instances for property testing - lazily instantiated by
// VirtualMachineExtensionInstanceViewARMGenerator()
var virtualMachineExtensionInstanceViewARMGenerator gopter.Gen

// VirtualMachineExtensionInstanceViewARMGenerator returns a generator of VirtualMachineExtensionInstanceViewARM instances for property testing.
// We first initialize virtualMachineExtensionInstanceViewARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineExtensionInstanceViewARMGenerator() gopter.Gen {
	if virtualMachineExtensionInstanceViewARMGenerator != nil {
		return virtualMachineExtensionInstanceViewARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionInstanceViewARM(generators)
	virtualMachineExtensionInstanceViewARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtensionInstanceViewARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionInstanceViewARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineExtensionInstanceViewARM(generators)
	virtualMachineExtensionInstanceViewARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtensionInstanceViewARM{}), generators)

	return virtualMachineExtensionInstanceViewARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineExtensionInstanceViewARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineExtensionInstanceViewARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["TypeHandlerVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineExtensionInstanceViewARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineExtensionInstanceViewARM(gens map[string]gopter.Gen) {
	gens["Statuses"] = gen.SliceOf(InstanceViewStatusARMGenerator())
	gens["Substatuses"] = gen.SliceOf(InstanceViewStatusARMGenerator())
}

func Test_VirtualMachineHealthStatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineHealthStatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineHealthStatusARM, VirtualMachineHealthStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineHealthStatusARM runs a test to see if a specific instance of VirtualMachineHealthStatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineHealthStatusARM(subject VirtualMachineHealthStatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineHealthStatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineHealthStatusARM instances for property testing - lazily instantiated by
// VirtualMachineHealthStatusARMGenerator()
var virtualMachineHealthStatusARMGenerator gopter.Gen

// VirtualMachineHealthStatusARMGenerator returns a generator of VirtualMachineHealthStatusARM instances for property testing.
func VirtualMachineHealthStatusARMGenerator() gopter.Gen {
	if virtualMachineHealthStatusARMGenerator != nil {
		return virtualMachineHealthStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVirtualMachineHealthStatusARM(generators)
	virtualMachineHealthStatusARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineHealthStatusARM{}), generators)

	return virtualMachineHealthStatusARMGenerator
}

// AddRelatedPropertyGeneratorsForVirtualMachineHealthStatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineHealthStatusARM(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(InstanceViewStatusARMGenerator())
}

func Test_VirtualMachinePatchStatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachinePatchStatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachinePatchStatusARM, VirtualMachinePatchStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachinePatchStatusARM runs a test to see if a specific instance of VirtualMachinePatchStatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachinePatchStatusARM(subject VirtualMachinePatchStatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachinePatchStatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachinePatchStatusARM instances for property testing - lazily instantiated by
// VirtualMachinePatchStatusARMGenerator()
var virtualMachinePatchStatusARMGenerator gopter.Gen

// VirtualMachinePatchStatusARMGenerator returns a generator of VirtualMachinePatchStatusARM instances for property testing.
func VirtualMachinePatchStatusARMGenerator() gopter.Gen {
	if virtualMachinePatchStatusARMGenerator != nil {
		return virtualMachinePatchStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForVirtualMachinePatchStatusARM(generators)
	virtualMachinePatchStatusARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachinePatchStatusARM{}), generators)

	return virtualMachinePatchStatusARMGenerator
}

// AddRelatedPropertyGeneratorsForVirtualMachinePatchStatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachinePatchStatusARM(gens map[string]gopter.Gen) {
	gens["AvailablePatchSummary"] = gen.PtrOf(AvailablePatchSummaryARMGenerator())
	gens["ConfigurationStatuses"] = gen.SliceOf(InstanceViewStatusARMGenerator())
	gens["LastPatchInstallationSummary"] = gen.PtrOf(LastPatchInstallationSummaryARMGenerator())
}

func Test_WindowsConfigurationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WindowsConfigurationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWindowsConfigurationARM, WindowsConfigurationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWindowsConfigurationARM runs a test to see if a specific instance of WindowsConfigurationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWindowsConfigurationARM(subject WindowsConfigurationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WindowsConfigurationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WindowsConfigurationARM instances for property testing - lazily instantiated by
// WindowsConfigurationARMGenerator()
var windowsConfigurationARMGenerator gopter.Gen

// WindowsConfigurationARMGenerator returns a generator of WindowsConfigurationARM instances for property testing.
// We first initialize windowsConfigurationARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WindowsConfigurationARMGenerator() gopter.Gen {
	if windowsConfigurationARMGenerator != nil {
		return windowsConfigurationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsConfigurationARM(generators)
	windowsConfigurationARMGenerator = gen.Struct(reflect.TypeOf(WindowsConfigurationARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWindowsConfigurationARM(generators)
	AddRelatedPropertyGeneratorsForWindowsConfigurationARM(generators)
	windowsConfigurationARMGenerator = gen.Struct(reflect.TypeOf(WindowsConfigurationARM{}), generators)

	return windowsConfigurationARMGenerator
}

// AddIndependentPropertyGeneratorsForWindowsConfigurationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWindowsConfigurationARM(gens map[string]gopter.Gen) {
	gens["EnableAutomaticUpdates"] = gen.PtrOf(gen.Bool())
	gens["ProvisionVMAgent"] = gen.PtrOf(gen.Bool())
	gens["TimeZone"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForWindowsConfigurationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWindowsConfigurationARM(gens map[string]gopter.Gen) {
	gens["AdditionalUnattendContent"] = gen.SliceOf(AdditionalUnattendContentARMGenerator())
	gens["PatchSettings"] = gen.PtrOf(PatchSettingsARMGenerator())
	gens["WinRM"] = gen.PtrOf(WinRMConfigurationARMGenerator())
}

func Test_AdditionalUnattendContentARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdditionalUnattendContentARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdditionalUnattendContentARM, AdditionalUnattendContentARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdditionalUnattendContentARM runs a test to see if a specific instance of AdditionalUnattendContentARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAdditionalUnattendContentARM(subject AdditionalUnattendContentARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdditionalUnattendContentARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdditionalUnattendContentARM instances for property testing - lazily instantiated by
// AdditionalUnattendContentARMGenerator()
var additionalUnattendContentARMGenerator gopter.Gen

// AdditionalUnattendContentARMGenerator returns a generator of AdditionalUnattendContentARM instances for property testing.
func AdditionalUnattendContentARMGenerator() gopter.Gen {
	if additionalUnattendContentARMGenerator != nil {
		return additionalUnattendContentARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdditionalUnattendContentARM(generators)
	additionalUnattendContentARMGenerator = gen.Struct(reflect.TypeOf(AdditionalUnattendContentARM{}), generators)

	return additionalUnattendContentARMGenerator
}

// AddIndependentPropertyGeneratorsForAdditionalUnattendContentARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdditionalUnattendContentARM(gens map[string]gopter.Gen) {
	gens["ComponentName"] = gen.PtrOf(gen.OneConstOf(AdditionalUnattendContent_ComponentName_MicrosoftWindowsShellSetup))
	gens["Content"] = gen.PtrOf(gen.AlphaString())
	gens["PassName"] = gen.PtrOf(gen.OneConstOf(AdditionalUnattendContent_PassName_OobeSystem))
	gens["SettingName"] = gen.PtrOf(gen.OneConstOf(AdditionalUnattendContent_SettingName_AutoLogon, AdditionalUnattendContent_SettingName_FirstLogonCommands))
}

func Test_AvailablePatchSummaryARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AvailablePatchSummaryARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAvailablePatchSummaryARM, AvailablePatchSummaryARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAvailablePatchSummaryARM runs a test to see if a specific instance of AvailablePatchSummaryARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAvailablePatchSummaryARM(subject AvailablePatchSummaryARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AvailablePatchSummaryARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AvailablePatchSummaryARM instances for property testing - lazily instantiated by
// AvailablePatchSummaryARMGenerator()
var availablePatchSummaryARMGenerator gopter.Gen

// AvailablePatchSummaryARMGenerator returns a generator of AvailablePatchSummaryARM instances for property testing.
// We first initialize availablePatchSummaryARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AvailablePatchSummaryARMGenerator() gopter.Gen {
	if availablePatchSummaryARMGenerator != nil {
		return availablePatchSummaryARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAvailablePatchSummaryARM(generators)
	availablePatchSummaryARMGenerator = gen.Struct(reflect.TypeOf(AvailablePatchSummaryARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAvailablePatchSummaryARM(generators)
	AddRelatedPropertyGeneratorsForAvailablePatchSummaryARM(generators)
	availablePatchSummaryARMGenerator = gen.Struct(reflect.TypeOf(AvailablePatchSummaryARM{}), generators)

	return availablePatchSummaryARMGenerator
}

// AddIndependentPropertyGeneratorsForAvailablePatchSummaryARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAvailablePatchSummaryARM(gens map[string]gopter.Gen) {
	gens["AssessmentActivityId"] = gen.PtrOf(gen.AlphaString())
	gens["CriticalAndSecurityPatchCount"] = gen.PtrOf(gen.Int())
	gens["LastModifiedTime"] = gen.PtrOf(gen.AlphaString())
	gens["OtherPatchCount"] = gen.PtrOf(gen.Int())
	gens["RebootPending"] = gen.PtrOf(gen.Bool())
	gens["StartTime"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(
		AvailablePatchSummary_Status_CompletedWithWarnings,
		AvailablePatchSummary_Status_Failed,
		AvailablePatchSummary_Status_InProgress,
		AvailablePatchSummary_Status_Succeeded,
		AvailablePatchSummary_Status_Unknown))
}

// AddRelatedPropertyGeneratorsForAvailablePatchSummaryARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAvailablePatchSummaryARM(gens map[string]gopter.Gen) {
	gens["Error"] = gen.PtrOf(ApiErrorARMGenerator())
}

func Test_DiffDiskSettingsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiffDiskSettingsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiffDiskSettingsARM, DiffDiskSettingsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiffDiskSettingsARM runs a test to see if a specific instance of DiffDiskSettingsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiffDiskSettingsARM(subject DiffDiskSettingsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiffDiskSettingsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiffDiskSettingsARM instances for property testing - lazily instantiated by
// DiffDiskSettingsARMGenerator()
var diffDiskSettingsARMGenerator gopter.Gen

// DiffDiskSettingsARMGenerator returns a generator of DiffDiskSettingsARM instances for property testing.
func DiffDiskSettingsARMGenerator() gopter.Gen {
	if diffDiskSettingsARMGenerator != nil {
		return diffDiskSettingsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiffDiskSettingsARM(generators)
	diffDiskSettingsARMGenerator = gen.Struct(reflect.TypeOf(DiffDiskSettingsARM{}), generators)

	return diffDiskSettingsARMGenerator
}

// AddIndependentPropertyGeneratorsForDiffDiskSettingsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiffDiskSettingsARM(gens map[string]gopter.Gen) {
	gens["Option"] = gen.PtrOf(gen.OneConstOf(DiffDiskOption_Local))
	gens["Placement"] = gen.PtrOf(gen.OneConstOf(DiffDiskPlacement_CacheDisk, DiffDiskPlacement_ResourceDisk))
}

func Test_DiskEncryptionSettingsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DiskEncryptionSettingsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDiskEncryptionSettingsARM, DiskEncryptionSettingsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDiskEncryptionSettingsARM runs a test to see if a specific instance of DiskEncryptionSettingsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDiskEncryptionSettingsARM(subject DiskEncryptionSettingsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DiskEncryptionSettingsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DiskEncryptionSettingsARM instances for property testing - lazily instantiated by
// DiskEncryptionSettingsARMGenerator()
var diskEncryptionSettingsARMGenerator gopter.Gen

// DiskEncryptionSettingsARMGenerator returns a generator of DiskEncryptionSettingsARM instances for property testing.
// We first initialize diskEncryptionSettingsARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DiskEncryptionSettingsARMGenerator() gopter.Gen {
	if diskEncryptionSettingsARMGenerator != nil {
		return diskEncryptionSettingsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskEncryptionSettingsARM(generators)
	diskEncryptionSettingsARMGenerator = gen.Struct(reflect.TypeOf(DiskEncryptionSettingsARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDiskEncryptionSettingsARM(generators)
	AddRelatedPropertyGeneratorsForDiskEncryptionSettingsARM(generators)
	diskEncryptionSettingsARMGenerator = gen.Struct(reflect.TypeOf(DiskEncryptionSettingsARM{}), generators)

	return diskEncryptionSettingsARMGenerator
}

// AddIndependentPropertyGeneratorsForDiskEncryptionSettingsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDiskEncryptionSettingsARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForDiskEncryptionSettingsARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDiskEncryptionSettingsARM(gens map[string]gopter.Gen) {
	gens["DiskEncryptionKey"] = gen.PtrOf(KeyVaultSecretReferenceARMGenerator())
	gens["KeyEncryptionKey"] = gen.PtrOf(KeyVaultKeyReferenceARMGenerator())
}

func Test_LastPatchInstallationSummaryARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LastPatchInstallationSummaryARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLastPatchInstallationSummaryARM, LastPatchInstallationSummaryARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLastPatchInstallationSummaryARM runs a test to see if a specific instance of LastPatchInstallationSummaryARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLastPatchInstallationSummaryARM(subject LastPatchInstallationSummaryARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LastPatchInstallationSummaryARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LastPatchInstallationSummaryARM instances for property testing - lazily instantiated by
// LastPatchInstallationSummaryARMGenerator()
var lastPatchInstallationSummaryARMGenerator gopter.Gen

// LastPatchInstallationSummaryARMGenerator returns a generator of LastPatchInstallationSummaryARM instances for property testing.
// We first initialize lastPatchInstallationSummaryARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LastPatchInstallationSummaryARMGenerator() gopter.Gen {
	if lastPatchInstallationSummaryARMGenerator != nil {
		return lastPatchInstallationSummaryARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLastPatchInstallationSummaryARM(generators)
	lastPatchInstallationSummaryARMGenerator = gen.Struct(reflect.TypeOf(LastPatchInstallationSummaryARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLastPatchInstallationSummaryARM(generators)
	AddRelatedPropertyGeneratorsForLastPatchInstallationSummaryARM(generators)
	lastPatchInstallationSummaryARMGenerator = gen.Struct(reflect.TypeOf(LastPatchInstallationSummaryARM{}), generators)

	return lastPatchInstallationSummaryARMGenerator
}

// AddIndependentPropertyGeneratorsForLastPatchInstallationSummaryARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLastPatchInstallationSummaryARM(gens map[string]gopter.Gen) {
	gens["ExcludedPatchCount"] = gen.PtrOf(gen.Int())
	gens["FailedPatchCount"] = gen.PtrOf(gen.Int())
	gens["InstallationActivityId"] = gen.PtrOf(gen.AlphaString())
	gens["InstalledPatchCount"] = gen.PtrOf(gen.Int())
	gens["LastModifiedTime"] = gen.PtrOf(gen.AlphaString())
	gens["MaintenanceWindowExceeded"] = gen.PtrOf(gen.Bool())
	gens["NotSelectedPatchCount"] = gen.PtrOf(gen.Int())
	gens["PendingPatchCount"] = gen.PtrOf(gen.Int())
	gens["StartTime"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(
		LastPatchInstallationSummary_Status_CompletedWithWarnings,
		LastPatchInstallationSummary_Status_Failed,
		LastPatchInstallationSummary_Status_InProgress,
		LastPatchInstallationSummary_Status_Succeeded,
		LastPatchInstallationSummary_Status_Unknown))
}

// AddRelatedPropertyGeneratorsForLastPatchInstallationSummaryARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLastPatchInstallationSummaryARM(gens map[string]gopter.Gen) {
	gens["Error"] = gen.PtrOf(ApiErrorARMGenerator())
}

func Test_LinuxPatchSettingsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxPatchSettingsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxPatchSettingsARM, LinuxPatchSettingsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxPatchSettingsARM runs a test to see if a specific instance of LinuxPatchSettingsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxPatchSettingsARM(subject LinuxPatchSettingsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxPatchSettingsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxPatchSettingsARM instances for property testing - lazily instantiated by
// LinuxPatchSettingsARMGenerator()
var linuxPatchSettingsARMGenerator gopter.Gen

// LinuxPatchSettingsARMGenerator returns a generator of LinuxPatchSettingsARM instances for property testing.
func LinuxPatchSettingsARMGenerator() gopter.Gen {
	if linuxPatchSettingsARMGenerator != nil {
		return linuxPatchSettingsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxPatchSettingsARM(generators)
	linuxPatchSettingsARMGenerator = gen.Struct(reflect.TypeOf(LinuxPatchSettingsARM{}), generators)

	return linuxPatchSettingsARMGenerator
}

// AddIndependentPropertyGeneratorsForLinuxPatchSettingsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxPatchSettingsARM(gens map[string]gopter.Gen) {
	gens["PatchMode"] = gen.PtrOf(gen.OneConstOf(LinuxPatchSettings_PatchMode_AutomaticByPlatform, LinuxPatchSettings_PatchMode_ImageDefault))
}

func Test_ManagedDiskParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedDiskParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedDiskParametersARM, ManagedDiskParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedDiskParametersARM runs a test to see if a specific instance of ManagedDiskParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedDiskParametersARM(subject ManagedDiskParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedDiskParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedDiskParametersARM instances for property testing - lazily instantiated by
// ManagedDiskParametersARMGenerator()
var managedDiskParametersARMGenerator gopter.Gen

// ManagedDiskParametersARMGenerator returns a generator of ManagedDiskParametersARM instances for property testing.
// We first initialize managedDiskParametersARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedDiskParametersARMGenerator() gopter.Gen {
	if managedDiskParametersARMGenerator != nil {
		return managedDiskParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedDiskParametersARM(generators)
	managedDiskParametersARMGenerator = gen.Struct(reflect.TypeOf(ManagedDiskParametersARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedDiskParametersARM(generators)
	AddRelatedPropertyGeneratorsForManagedDiskParametersARM(generators)
	managedDiskParametersARMGenerator = gen.Struct(reflect.TypeOf(ManagedDiskParametersARM{}), generators)

	return managedDiskParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedDiskParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedDiskParametersARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["StorageAccountType"] = gen.PtrOf(gen.OneConstOf(
		StorageAccountType_Premium_LRS,
		StorageAccountType_Premium_ZRS,
		StorageAccountType_StandardSSD_LRS,
		StorageAccountType_StandardSSD_ZRS,
		StorageAccountType_Standard_LRS,
		StorageAccountType_UltraSSD_LRS))
}

// AddRelatedPropertyGeneratorsForManagedDiskParametersARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedDiskParametersARM(gens map[string]gopter.Gen) {
	gens["DiskEncryptionSet"] = gen.PtrOf(SubResourceARMGenerator())
}

func Test_NetworkInterfaceReferencePropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkInterfaceReferencePropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkInterfaceReferencePropertiesARM, NetworkInterfaceReferencePropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkInterfaceReferencePropertiesARM runs a test to see if a specific instance of NetworkInterfaceReferencePropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkInterfaceReferencePropertiesARM(subject NetworkInterfaceReferencePropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkInterfaceReferencePropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkInterfaceReferencePropertiesARM instances for property testing - lazily instantiated by
// NetworkInterfaceReferencePropertiesARMGenerator()
var networkInterfaceReferencePropertiesARMGenerator gopter.Gen

// NetworkInterfaceReferencePropertiesARMGenerator returns a generator of NetworkInterfaceReferencePropertiesARM instances for property testing.
func NetworkInterfaceReferencePropertiesARMGenerator() gopter.Gen {
	if networkInterfaceReferencePropertiesARMGenerator != nil {
		return networkInterfaceReferencePropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkInterfaceReferencePropertiesARM(generators)
	networkInterfaceReferencePropertiesARMGenerator = gen.Struct(reflect.TypeOf(NetworkInterfaceReferencePropertiesARM{}), generators)

	return networkInterfaceReferencePropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkInterfaceReferencePropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkInterfaceReferencePropertiesARM(gens map[string]gopter.Gen) {
	gens["Primary"] = gen.PtrOf(gen.Bool())
}

func Test_PatchSettingsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PatchSettingsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPatchSettingsARM, PatchSettingsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPatchSettingsARM runs a test to see if a specific instance of PatchSettingsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPatchSettingsARM(subject PatchSettingsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PatchSettingsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PatchSettingsARM instances for property testing - lazily instantiated by PatchSettingsARMGenerator()
var patchSettingsARMGenerator gopter.Gen

// PatchSettingsARMGenerator returns a generator of PatchSettingsARM instances for property testing.
func PatchSettingsARMGenerator() gopter.Gen {
	if patchSettingsARMGenerator != nil {
		return patchSettingsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPatchSettingsARM(generators)
	patchSettingsARMGenerator = gen.Struct(reflect.TypeOf(PatchSettingsARM{}), generators)

	return patchSettingsARMGenerator
}

// AddIndependentPropertyGeneratorsForPatchSettingsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPatchSettingsARM(gens map[string]gopter.Gen) {
	gens["EnableHotpatching"] = gen.PtrOf(gen.Bool())
	gens["PatchMode"] = gen.PtrOf(gen.OneConstOf(PatchSettings_PatchMode_AutomaticByOS, PatchSettings_PatchMode_AutomaticByPlatform, PatchSettings_PatchMode_Manual))
}

func Test_SshConfigurationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SshConfigurationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSshConfigurationARM, SshConfigurationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSshConfigurationARM runs a test to see if a specific instance of SshConfigurationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSshConfigurationARM(subject SshConfigurationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SshConfigurationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SshConfigurationARM instances for property testing - lazily instantiated by
// SshConfigurationARMGenerator()
var sshConfigurationARMGenerator gopter.Gen

// SshConfigurationARMGenerator returns a generator of SshConfigurationARM instances for property testing.
func SshConfigurationARMGenerator() gopter.Gen {
	if sshConfigurationARMGenerator != nil {
		return sshConfigurationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForSshConfigurationARM(generators)
	sshConfigurationARMGenerator = gen.Struct(reflect.TypeOf(SshConfigurationARM{}), generators)

	return sshConfigurationARMGenerator
}

// AddRelatedPropertyGeneratorsForSshConfigurationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSshConfigurationARM(gens map[string]gopter.Gen) {
	gens["PublicKeys"] = gen.SliceOf(SshPublicKeySpecARMGenerator())
}

func Test_VaultCertificateARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VaultCertificateARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVaultCertificateARM, VaultCertificateARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVaultCertificateARM runs a test to see if a specific instance of VaultCertificateARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVaultCertificateARM(subject VaultCertificateARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VaultCertificateARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VaultCertificateARM instances for property testing - lazily instantiated by
// VaultCertificateARMGenerator()
var vaultCertificateARMGenerator gopter.Gen

// VaultCertificateARMGenerator returns a generator of VaultCertificateARM instances for property testing.
func VaultCertificateARMGenerator() gopter.Gen {
	if vaultCertificateARMGenerator != nil {
		return vaultCertificateARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVaultCertificateARM(generators)
	vaultCertificateARMGenerator = gen.Struct(reflect.TypeOf(VaultCertificateARM{}), generators)

	return vaultCertificateARMGenerator
}

// AddIndependentPropertyGeneratorsForVaultCertificateARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVaultCertificateARM(gens map[string]gopter.Gen) {
	gens["CertificateStore"] = gen.PtrOf(gen.AlphaString())
	gens["CertificateUrl"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualHardDiskARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualHardDiskARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualHardDiskARM, VirtualHardDiskARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualHardDiskARM runs a test to see if a specific instance of VirtualHardDiskARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualHardDiskARM(subject VirtualHardDiskARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualHardDiskARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualHardDiskARM instances for property testing - lazily instantiated by VirtualHardDiskARMGenerator()
var virtualHardDiskARMGenerator gopter.Gen

// VirtualHardDiskARMGenerator returns a generator of VirtualHardDiskARM instances for property testing.
func VirtualHardDiskARMGenerator() gopter.Gen {
	if virtualHardDiskARMGenerator != nil {
		return virtualHardDiskARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualHardDiskARM(generators)
	virtualHardDiskARMGenerator = gen.Struct(reflect.TypeOf(VirtualHardDiskARM{}), generators)

	return virtualHardDiskARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualHardDiskARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualHardDiskARM(gens map[string]gopter.Gen) {
	gens["Uri"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualMachineExtensionHandlerInstanceViewARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualMachineExtensionHandlerInstanceViewARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualMachineExtensionHandlerInstanceViewARM, VirtualMachineExtensionHandlerInstanceViewARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualMachineExtensionHandlerInstanceViewARM runs a test to see if a specific instance of VirtualMachineExtensionHandlerInstanceViewARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualMachineExtensionHandlerInstanceViewARM(subject VirtualMachineExtensionHandlerInstanceViewARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualMachineExtensionHandlerInstanceViewARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualMachineExtensionHandlerInstanceViewARM instances for property testing - lazily instantiated by
// VirtualMachineExtensionHandlerInstanceViewARMGenerator()
var virtualMachineExtensionHandlerInstanceViewARMGenerator gopter.Gen

// VirtualMachineExtensionHandlerInstanceViewARMGenerator returns a generator of VirtualMachineExtensionHandlerInstanceViewARM instances for property testing.
// We first initialize virtualMachineExtensionHandlerInstanceViewARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func VirtualMachineExtensionHandlerInstanceViewARMGenerator() gopter.Gen {
	if virtualMachineExtensionHandlerInstanceViewARMGenerator != nil {
		return virtualMachineExtensionHandlerInstanceViewARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceViewARM(generators)
	virtualMachineExtensionHandlerInstanceViewARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtensionHandlerInstanceViewARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceViewARM(generators)
	AddRelatedPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceViewARM(generators)
	virtualMachineExtensionHandlerInstanceViewARMGenerator = gen.Struct(reflect.TypeOf(VirtualMachineExtensionHandlerInstanceViewARM{}), generators)

	return virtualMachineExtensionHandlerInstanceViewARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceViewARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceViewARM(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["TypeHandlerVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceViewARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForVirtualMachineExtensionHandlerInstanceViewARM(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(InstanceViewStatusARMGenerator())
}

func Test_WinRMConfigurationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WinRMConfigurationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWinRMConfigurationARM, WinRMConfigurationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWinRMConfigurationARM runs a test to see if a specific instance of WinRMConfigurationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWinRMConfigurationARM(subject WinRMConfigurationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WinRMConfigurationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WinRMConfigurationARM instances for property testing - lazily instantiated by
// WinRMConfigurationARMGenerator()
var winRMConfigurationARMGenerator gopter.Gen

// WinRMConfigurationARMGenerator returns a generator of WinRMConfigurationARM instances for property testing.
func WinRMConfigurationARMGenerator() gopter.Gen {
	if winRMConfigurationARMGenerator != nil {
		return winRMConfigurationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForWinRMConfigurationARM(generators)
	winRMConfigurationARMGenerator = gen.Struct(reflect.TypeOf(WinRMConfigurationARM{}), generators)

	return winRMConfigurationARMGenerator
}

// AddRelatedPropertyGeneratorsForWinRMConfigurationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWinRMConfigurationARM(gens map[string]gopter.Gen) {
	gens["Listeners"] = gen.SliceOf(WinRMListenerARMGenerator())
}

func Test_ApiErrorARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiErrorARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiErrorARM, ApiErrorARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiErrorARM runs a test to see if a specific instance of ApiErrorARM round trips to JSON and back losslessly
func RunJSONSerializationTestForApiErrorARM(subject ApiErrorARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiErrorARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiErrorARM instances for property testing - lazily instantiated by ApiErrorARMGenerator()
var apiErrorARMGenerator gopter.Gen

// ApiErrorARMGenerator returns a generator of ApiErrorARM instances for property testing.
// We first initialize apiErrorARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ApiErrorARMGenerator() gopter.Gen {
	if apiErrorARMGenerator != nil {
		return apiErrorARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiErrorARM(generators)
	apiErrorARMGenerator = gen.Struct(reflect.TypeOf(ApiErrorARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiErrorARM(generators)
	AddRelatedPropertyGeneratorsForApiErrorARM(generators)
	apiErrorARMGenerator = gen.Struct(reflect.TypeOf(ApiErrorARM{}), generators)

	return apiErrorARMGenerator
}

// AddIndependentPropertyGeneratorsForApiErrorARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiErrorARM(gens map[string]gopter.Gen) {
	gens["Code"] = gen.PtrOf(gen.AlphaString())
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForApiErrorARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForApiErrorARM(gens map[string]gopter.Gen) {
	gens["Details"] = gen.SliceOf(ApiErrorBaseARMGenerator())
	gens["Innererror"] = gen.PtrOf(InnerErrorARMGenerator())
}

func Test_KeyVaultKeyReferenceARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultKeyReferenceARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultKeyReferenceARM, KeyVaultKeyReferenceARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultKeyReferenceARM runs a test to see if a specific instance of KeyVaultKeyReferenceARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultKeyReferenceARM(subject KeyVaultKeyReferenceARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultKeyReferenceARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultKeyReferenceARM instances for property testing - lazily instantiated by
// KeyVaultKeyReferenceARMGenerator()
var keyVaultKeyReferenceARMGenerator gopter.Gen

// KeyVaultKeyReferenceARMGenerator returns a generator of KeyVaultKeyReferenceARM instances for property testing.
// We first initialize keyVaultKeyReferenceARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultKeyReferenceARMGenerator() gopter.Gen {
	if keyVaultKeyReferenceARMGenerator != nil {
		return keyVaultKeyReferenceARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultKeyReferenceARM(generators)
	keyVaultKeyReferenceARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultKeyReferenceARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultKeyReferenceARM(generators)
	AddRelatedPropertyGeneratorsForKeyVaultKeyReferenceARM(generators)
	keyVaultKeyReferenceARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultKeyReferenceARM{}), generators)

	return keyVaultKeyReferenceARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultKeyReferenceARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultKeyReferenceARM(gens map[string]gopter.Gen) {
	gens["KeyUrl"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForKeyVaultKeyReferenceARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultKeyReferenceARM(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SubResourceARMGenerator())
}

func Test_KeyVaultSecretReferenceARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultSecretReferenceARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultSecretReferenceARM, KeyVaultSecretReferenceARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultSecretReferenceARM runs a test to see if a specific instance of KeyVaultSecretReferenceARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultSecretReferenceARM(subject KeyVaultSecretReferenceARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultSecretReferenceARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultSecretReferenceARM instances for property testing - lazily instantiated by
// KeyVaultSecretReferenceARMGenerator()
var keyVaultSecretReferenceARMGenerator gopter.Gen

// KeyVaultSecretReferenceARMGenerator returns a generator of KeyVaultSecretReferenceARM instances for property testing.
// We first initialize keyVaultSecretReferenceARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func KeyVaultSecretReferenceARMGenerator() gopter.Gen {
	if keyVaultSecretReferenceARMGenerator != nil {
		return keyVaultSecretReferenceARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultSecretReferenceARM(generators)
	keyVaultSecretReferenceARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultSecretReferenceARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultSecretReferenceARM(generators)
	AddRelatedPropertyGeneratorsForKeyVaultSecretReferenceARM(generators)
	keyVaultSecretReferenceARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultSecretReferenceARM{}), generators)

	return keyVaultSecretReferenceARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultSecretReferenceARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultSecretReferenceARM(gens map[string]gopter.Gen) {
	gens["SecretUrl"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForKeyVaultSecretReferenceARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKeyVaultSecretReferenceARM(gens map[string]gopter.Gen) {
	gens["SourceVault"] = gen.PtrOf(SubResourceARMGenerator())
}

func Test_SshPublicKeySpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SshPublicKeySpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSshPublicKeySpecARM, SshPublicKeySpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSshPublicKeySpecARM runs a test to see if a specific instance of SshPublicKeySpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSshPublicKeySpecARM(subject SshPublicKeySpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SshPublicKeySpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SshPublicKeySpecARM instances for property testing - lazily instantiated by
// SshPublicKeySpecARMGenerator()
var sshPublicKeySpecARMGenerator gopter.Gen

// SshPublicKeySpecARMGenerator returns a generator of SshPublicKeySpecARM instances for property testing.
func SshPublicKeySpecARMGenerator() gopter.Gen {
	if sshPublicKeySpecARMGenerator != nil {
		return sshPublicKeySpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSshPublicKeySpecARM(generators)
	sshPublicKeySpecARMGenerator = gen.Struct(reflect.TypeOf(SshPublicKeySpecARM{}), generators)

	return sshPublicKeySpecARMGenerator
}

// AddIndependentPropertyGeneratorsForSshPublicKeySpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSshPublicKeySpecARM(gens map[string]gopter.Gen) {
	gens["KeyData"] = gen.PtrOf(gen.AlphaString())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
}

func Test_WinRMListenerARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WinRMListenerARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWinRMListenerARM, WinRMListenerARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWinRMListenerARM runs a test to see if a specific instance of WinRMListenerARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWinRMListenerARM(subject WinRMListenerARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WinRMListenerARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WinRMListenerARM instances for property testing - lazily instantiated by WinRMListenerARMGenerator()
var winRMListenerARMGenerator gopter.Gen

// WinRMListenerARMGenerator returns a generator of WinRMListenerARM instances for property testing.
func WinRMListenerARMGenerator() gopter.Gen {
	if winRMListenerARMGenerator != nil {
		return winRMListenerARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWinRMListenerARM(generators)
	winRMListenerARMGenerator = gen.Struct(reflect.TypeOf(WinRMListenerARM{}), generators)

	return winRMListenerARMGenerator
}

// AddIndependentPropertyGeneratorsForWinRMListenerARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWinRMListenerARM(gens map[string]gopter.Gen) {
	gens["CertificateUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Protocol"] = gen.PtrOf(gen.OneConstOf(WinRMListener_Protocol_Http, WinRMListener_Protocol_Https))
}

func Test_ApiErrorBaseARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiErrorBaseARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiErrorBaseARM, ApiErrorBaseARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiErrorBaseARM runs a test to see if a specific instance of ApiErrorBaseARM round trips to JSON and back losslessly
func RunJSONSerializationTestForApiErrorBaseARM(subject ApiErrorBaseARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiErrorBaseARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiErrorBaseARM instances for property testing - lazily instantiated by ApiErrorBaseARMGenerator()
var apiErrorBaseARMGenerator gopter.Gen

// ApiErrorBaseARMGenerator returns a generator of ApiErrorBaseARM instances for property testing.
func ApiErrorBaseARMGenerator() gopter.Gen {
	if apiErrorBaseARMGenerator != nil {
		return apiErrorBaseARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiErrorBaseARM(generators)
	apiErrorBaseARMGenerator = gen.Struct(reflect.TypeOf(ApiErrorBaseARM{}), generators)

	return apiErrorBaseARMGenerator
}

// AddIndependentPropertyGeneratorsForApiErrorBaseARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiErrorBaseARM(gens map[string]gopter.Gen) {
	gens["Code"] = gen.PtrOf(gen.AlphaString())
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
}

func Test_InnerErrorARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of InnerErrorARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForInnerErrorARM, InnerErrorARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForInnerErrorARM runs a test to see if a specific instance of InnerErrorARM round trips to JSON and back losslessly
func RunJSONSerializationTestForInnerErrorARM(subject InnerErrorARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual InnerErrorARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of InnerErrorARM instances for property testing - lazily instantiated by InnerErrorARMGenerator()
var innerErrorARMGenerator gopter.Gen

// InnerErrorARMGenerator returns a generator of InnerErrorARM instances for property testing.
func InnerErrorARMGenerator() gopter.Gen {
	if innerErrorARMGenerator != nil {
		return innerErrorARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForInnerErrorARM(generators)
	innerErrorARMGenerator = gen.Struct(reflect.TypeOf(InnerErrorARM{}), generators)

	return innerErrorARMGenerator
}

// AddIndependentPropertyGeneratorsForInnerErrorARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForInnerErrorARM(gens map[string]gopter.Gen) {
	gens["Errordetail"] = gen.PtrOf(gen.AlphaString())
	gens["Exceptiontype"] = gen.PtrOf(gen.AlphaString())
}
